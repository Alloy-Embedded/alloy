/// Auto-generated code for MSP432P411V
/// Generated by Alloy Code Generator
/// Source: texasinstruments_msp432p411.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:43
#ifndef ALLOY_GENERATED_MSP432P411V_PERIPHERALS_HPP
#define ALLOY_GENERATED_MSP432P411V_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::msp432p411v {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_tlv = true;
    constexpr uint32_t num_tlv_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_eusci = true;
    constexpr uint32_t num_eusci_instances = 8;
    constexpr bool has_ref = true;
    constexpr uint32_t num_ref_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 2;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_crc32 = true;
    constexpr uint32_t num_crc32_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_dio = true;
    constexpr uint32_t num_dio_instances = 1;
    constexpr bool has_pmap = true;
    constexpr uint32_t num_pmap_instances = 1;
    constexpr bool has_captio0 = true;
    constexpr uint32_t num_captio0_instances = 1;
    constexpr bool has_captio1 = true;
    constexpr uint32_t num_captio1_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_pcm = true;
    constexpr uint32_t num_pcm_instances = 1;
    constexpr bool has_cs = true;
    constexpr uint32_t num_cs_instances = 1;
    constexpr bool has_pss = true;
    constexpr uint32_t num_pss_instances = 1;
    constexpr bool has_flctl = true;
    constexpr uint32_t num_flctl_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_itm = true;
    constexpr uint32_t num_itm_instances = 1;
    constexpr bool has_dwt = true;
    constexpr uint32_t num_dwt_instances = 1;
    constexpr bool has_fpb = true;
    constexpr uint32_t num_fpb_instances = 1;
    constexpr bool has_systemcontrolspace = true;
    constexpr uint32_t num_systemcontrolspace_instances = 1;
    constexpr bool has_rstctl = true;
    constexpr uint32_t num_rstctl_instances = 1;
    constexpr bool has_sysctl = true;
    constexpr uint32_t num_sysctl_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct tlv_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct eusci_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct ref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc32_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmap_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct captio0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct captio1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pss_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flctl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct itm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrolspace_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rstctl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sysctl_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits

    // USART-specific traits
}

// ============================================================================
// TLV Peripheral
// ============================================================================

namespace tlv {
    /// Base addresses
    constexpr uint32_t TLV_BASE = 0x00201000;

    /// TLV Register structure
    struct Registers {
        volatile uint32_t TLV_CHECKSUM;  ///< Offset: 0x00 - TLV Checksum
        volatile uint32_t DEVICE_INFO_TAG;  ///< Offset: 0x04 - Device Info Tag
        volatile uint32_t DEVICE_INFO_LEN;  ///< Offset: 0x08 - Device Info Length
        volatile uint32_t DEVICE_ID;  ///< Offset: 0x0C - Device ID
        volatile uint32_t HWREV;  ///< Offset: 0x10 - HW Revision
        volatile uint32_t BCREV;  ///< Offset: 0x14 - Boot Code Revision
        volatile uint32_t ROM_DRVLIB_REV;  ///< Offset: 0x18 - ROM Driver Library Revision
        volatile uint32_t DIE_REC_TAG;  ///< Offset: 0x1C - Die Record Tag
        volatile uint32_t DIE_REC_LEN;  ///< Offset: 0x20 - Die Record Length
        volatile uint32_t DIE_XPOS;  ///< Offset: 0x24 - Die X-Position
        volatile uint32_t DIE_YPOS;  ///< Offset: 0x28 - Die Y-Position
        volatile uint32_t WAFER_ID;  ///< Offset: 0x2C - Wafer ID
        volatile uint32_t LOT_ID;  ///< Offset: 0x30 - Lot ID
        volatile uint32_t RESERVED0;  ///< Offset: 0x34 - Reserved
        volatile uint32_t RESERVED1;  ///< Offset: 0x38 - Reserved
        volatile uint32_t RESERVED2;  ///< Offset: 0x3C - Reserved
        volatile uint32_t TEST_RESULTS;  ///< Offset: 0x40 - Test Results
        volatile uint32_t CS_CAL_TAG;  ///< Offset: 0x44 - Clock System Calibration Tag
        volatile uint32_t CS_CAL_LEN;  ///< Offset: 0x48 - Clock System Calibration Length
        volatile uint32_t DCOIR_FCAL_RSEL04;  ///< Offset: 0x4C - DCO IR mode: Frequency calibration for DCORSEL 0 to 4
        volatile uint32_t DCOIR_FCAL_RSEL5;  ///< Offset: 0x50 - DCO IR mode: Frequency calibration for DCORSEL 5
        volatile uint32_t RESERVED3;  ///< Offset: 0x54 - Reserved
        volatile uint32_t RESERVED4;  ///< Offset: 0x58 - Reserved
        volatile uint32_t RESERVED5;  ///< Offset: 0x5C - Reserved
        volatile uint32_t RESERVED6;  ///< Offset: 0x60 - Reserved
        volatile uint32_t DCOIR_CONSTK_RSEL04;  ///< Offset: 0x64 - DCO IR mode: DCO Constant (K) for DCORSEL 0 to 4
        volatile uint32_t DCOIR_CONSTK_RSEL5;  ///< Offset: 0x68 - DCO IR mode: DCO Constant (K) for DCORSEL 5
        volatile uint32_t DCOER_FCAL_RSEL04;  ///< Offset: 0x6C - DCO ER mode: Frequency calibration for DCORSEL 0 to 4
        volatile uint32_t DCOER_FCAL_RSEL5;  ///< Offset: 0x70 - DCO ER mode: Frequency calibration for DCORSEL 5
        volatile uint32_t RESERVED7;  ///< Offset: 0x74 - Reserved
        volatile uint32_t RESERVED8;  ///< Offset: 0x78 - Reserved
        volatile uint32_t RESERVED9;  ///< Offset: 0x7C - Reserved
        volatile uint32_t RESERVED10;  ///< Offset: 0x80 - Reserved
        volatile uint32_t DCOER_CONSTK_RSEL04;  ///< Offset: 0x84 - DCO ER mode: DCO Constant (K) for DCORSEL 0 to 4
        volatile uint32_t DCOER_CONSTK_RSEL5;  ///< Offset: 0x88 - DCO ER mode: DCO Constant (K) for DCORSEL 5
        volatile uint32_t ADC14_CAL_TAG;  ///< Offset: 0x8C - ADC14 Calibration Tag
        volatile uint32_t ADC14_CAL_LEN;  ///< Offset: 0x90 - ADC14 Calibration Length
        volatile uint32_t ADC_GAIN_FACTOR;  ///< Offset: 0x94 - ADC Gain Factor
        volatile uint32_t ADC_OFFSET;  ///< Offset: 0x98 - ADC Offset
        volatile uint32_t RESERVED11;  ///< Offset: 0x9C - Reserved
        volatile uint32_t RESERVED12;  ///< Offset: 0xA0 - Reserved
        volatile uint32_t RESERVED13;  ///< Offset: 0xA4 - Reserved
        volatile uint32_t RESERVED14;  ///< Offset: 0xA8 - Reserved
        volatile uint32_t RESERVED15;  ///< Offset: 0xAC - Reserved
        volatile uint32_t RESERVED16;  ///< Offset: 0xB0 - Reserved
        volatile uint32_t RESERVED17;  ///< Offset: 0xB4 - Reserved
        volatile uint32_t RESERVED18;  ///< Offset: 0xB8 - Reserved
        volatile uint32_t RESERVED19;  ///< Offset: 0xBC - Reserved
        volatile uint32_t RESERVED20;  ///< Offset: 0xC0 - Reserved
        volatile uint32_t RESERVED21;  ///< Offset: 0xC4 - Reserved
        volatile uint32_t RESERVED22;  ///< Offset: 0xC8 - Reserved
        volatile uint32_t RESERVED23;  ///< Offset: 0xCC - Reserved
        volatile uint32_t RESERVED24;  ///< Offset: 0xD0 - Reserved
        volatile uint32_t RESERVED25;  ///< Offset: 0xD4 - Reserved
        volatile uint32_t RESERVED26;  ///< Offset: 0xD8 - Reserved
        volatile uint32_t ADC14_REF1P2V_TS30C;  ///< Offset: 0xDC - ADC14 1.2V Reference Temp. Sensor 30C
        volatile uint32_t ADC14_REF1P2V_TS85C;  ///< Offset: 0xE0 - ADC14 1.2V Reference Temp. Sensor 85C
        volatile uint32_t ADC14_REF1P45V_TS30C;  ///< Offset: 0xE4 - ADC14 1.45V Reference Temp. Sensor 30C
        volatile uint32_t ADC14_REF1P45V_TS85C;  ///< Offset: 0xE8 - ADC14 1.45V Reference Temp. Sensor 85C
        volatile uint32_t ADC14_REF2P5V_TS30C;  ///< Offset: 0xEC - ADC14 2.5V Reference Temp. Sensor 30C
        volatile uint32_t ADC14_REF2P5V_TS85C;  ///< Offset: 0xF0 - ADC14 2.5V Reference Temp. Sensor 85C
        volatile uint32_t REF_CAL_TAG;  ///< Offset: 0xF4 - REF Calibration Tag
        volatile uint32_t REF_CAL_LEN;  ///< Offset: 0xF8 - REF Calibration Length
        volatile uint32_t REF_1P2V;  ///< Offset: 0xFC - REF 1.2V Reference
        volatile uint32_t REF_1P45V;  ///< Offset: 0x100 - REF 1.45V Reference
        volatile uint32_t REF_2P5V;  ///< Offset: 0x104 - REF 2.5V Reference
        volatile uint32_t FLASH_INFO_TAG;  ///< Offset: 0x108 - Flash Info Tag
        volatile uint32_t FLASH_INFO_LEN;  ///< Offset: 0x10C - Flash Info Length
        volatile uint32_t FLASH_MAX_PROG_PULSES;  ///< Offset: 0x110 - Flash Maximum Programming Pulses
        volatile uint32_t FLASH_MAX_ERASE_PULSES;  ///< Offset: 0x114 - Flash Maximum Erase Pulses
        volatile uint32_t RANDOM_NUM_TAG;  ///< Offset: 0x118 - 128-bit Random Number Tag
        volatile uint32_t RANDOM_NUM_LEN;  ///< Offset: 0x11C - 128-bit Random Number Length
        volatile uint32_t RANDOM_NUM_1;  ///< Offset: 0x120 - 32-bit Random Number 1
        volatile uint32_t RANDOM_NUM_2;  ///< Offset: 0x124 - 32-bit Random Number 2
        volatile uint32_t RANDOM_NUM_3;  ///< Offset: 0x128 - 32-bit Random Number 3
        volatile uint32_t RANDOM_NUM_4;  ///< Offset: 0x12C - 32-bit Random Number 4
        volatile uint32_t BSL_CFG_TAG;  ///< Offset: 0x130 - BSL Configuration Tag
        volatile uint32_t BSL_CFG_LEN;  ///< Offset: 0x134 - BSL Configuration Length
        volatile uint32_t BSL_PERIPHIF_SEL;  ///< Offset: 0x138 - BSL Peripheral Interface Selection
        volatile uint32_t BSL_PORTIF_CFG_UART;  ///< Offset: 0x13C - BSL Port Interface Configuration for UART
        volatile uint32_t BSL_PORTIF_CFG_SPI;  ///< Offset: 0x140 - BSL Port Interface Configuration for SPI
        volatile uint32_t BSL_PORTIF_CFG_I2C;  ///< Offset: 0x144 - BSL Port Interface Configuration for I2C
        volatile uint32_t TLV_END;  ///< Offset: 0x148 - TLV End Word
    };

    /// Peripheral instances
    inline Registers* TLV = reinterpret_cast<Registers*>(TLV_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER_A0_BASE = 0x40000000;
    constexpr uint32_t TIMER_A1_BASE = 0x40000400;
    constexpr uint32_t TIMER_A2_BASE = 0x40000800;
    constexpr uint32_t TIMER_A3_BASE = 0x40000C00;
    constexpr uint32_t TIMER32_BASE = 0x4000C000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TAxCTL;  ///< Offset: 0x00 - TimerAx Control Register
        volatile uint32_t TAxCCTL__;  ///< Offset: 0x02 - Timer_A Capture/Compare Control Register (renamed from TAxCCTL__)
        volatile uint32_t TAxR;  ///< Offset: 0x10 - TimerA register
        volatile uint32_t TAxCCR__;  ///< Offset: 0x12 - Timer_A Capture/Compare Register (renamed from TAxCCR__)
        volatile uint32_t TAxEX0;  ///< Offset: 0x20 - TimerAx Expansion 0 Register
        volatile uint32_t TAxIV;  ///< Offset: 0x2E - TimerAx Interrupt Vector Register
    };

    /// Peripheral instances
    inline Registers* TIMER_A0 = reinterpret_cast<Registers*>(TIMER_A0_BASE);
    inline Registers* TIMER_A1 = reinterpret_cast<Registers*>(TIMER_A1_BASE);
    inline Registers* TIMER_A2 = reinterpret_cast<Registers*>(TIMER_A2_BASE);
    inline Registers* TIMER_A3 = reinterpret_cast<Registers*>(TIMER_A3_BASE);
    inline Registers* TIMER32 = reinterpret_cast<Registers*>(TIMER32_BASE);

    // Bit definitions
    /// TAxCTL Register bits
    namespace taxctl_bits {
        constexpr uint32_t TAIFG = (1U << 0);  ///< TimerA interrupt flag
        constexpr uint32_t TAIE = (1U << 1);  ///< TimerA interrupt enable
        constexpr uint32_t TACLR = (1U << 2);  ///< TimerA clear
        constexpr uint32_t MC = (2 << 4);  ///< Mode control
        constexpr uint32_t ID = (2 << 6);  ///< Input divider
        constexpr uint32_t TASSEL = (2 << 8);  ///< TimerA clock source select
    }

    /// TAxCCTL__ Register bits
    namespace taxcctl___bits {
        constexpr uint32_t CCIFG = (1U << 0);  ///< Capture/compare interrupt flag
        constexpr uint32_t COV = (1U << 1);  ///< Capture overflow
        constexpr uint32_t OUT = (1U << 2);  ///< Output
        constexpr uint32_t CCI = (1U << 3);  ///< Capture/compare input
        constexpr uint32_t CCIE = (1U << 4);  ///< Capture/compare interrupt enable
        constexpr uint32_t OUTMOD = (3 << 5);  ///< Output mode
        constexpr uint32_t CAP = (1U << 8);  ///< Capture mode
        constexpr uint32_t SCCI = (1U << 10);  ///< Synchronized capture/compare input
        constexpr uint32_t SCS = (1U << 11);  ///< Synchronize capture source
        constexpr uint32_t CCIS = (2 << 12);  ///< Capture/compare input select
        constexpr uint32_t CM = (2 << 14);  ///< Capture mode
    }

    /// TAxCCR__ Register bits
    namespace taxccr___bits {
        constexpr uint32_t TAxR = (16 << 0);  ///< TimerA register
    }

    /// TAxEX0 Register bits
    namespace taxex0_bits {
        constexpr uint32_t TAIDEX = (3 << 0);  ///< Input divider expansion
    }

    /// TAxIV Register bits
    namespace taxiv_bits {
        constexpr uint32_t TAIV = (16 << 0);  ///< TimerA interrupt vector value
    }

}

// ============================================================================
// EUSCI Peripheral
// ============================================================================

namespace eusci {
    /// Base addresses
    constexpr uint32_t EUSCI_A0_BASE = 0x40001000;
    constexpr uint32_t EUSCI_A1_BASE = 0x40001400;
    constexpr uint32_t EUSCI_A2_BASE = 0x40001800;
    constexpr uint32_t EUSCI_A3_BASE = 0x40001C00;
    constexpr uint32_t EUSCI_B0_BASE = 0x40002000;
    constexpr uint32_t EUSCI_B1_BASE = 0x40002400;
    constexpr uint32_t EUSCI_B2_BASE = 0x40002800;
    constexpr uint32_t EUSCI_B3_BASE = 0x40002C00;

    /// EUSCI Register structure
    struct Registers {
        volatile uint32_t UCAxCTLW0;  ///< Offset: 0x00 - eUSCI_Ax Control Word Register 0
        volatile uint32_t UCAxCTLW1;  ///< Offset: 0x02 - eUSCI_Ax Control Word Register 1
        volatile uint32_t UCAxBRW;  ///< Offset: 0x06 - eUSCI_Ax Baud Rate Control Word Register
        volatile uint32_t UCAxMCTLW;  ///< Offset: 0x08 - eUSCI_Ax Modulation Control Word Register
        volatile uint32_t UCAxSTATW;  ///< Offset: 0x0A - eUSCI_Ax Status Register
        volatile uint32_t UCAxRXBUF;  ///< Offset: 0x0C - eUSCI_Ax Receive Buffer Register
        volatile uint32_t UCAxTXBUF;  ///< Offset: 0x0E - eUSCI_Ax Transmit Buffer Register
        volatile uint32_t UCAxABCTL;  ///< Offset: 0x10 - eUSCI_Ax Auto Baud Rate Control Register
        volatile uint32_t UCAxIRCTL;  ///< Offset: 0x12 - eUSCI_Ax IrDA Control Word Register
        volatile uint32_t UCAxIE;  ///< Offset: 0x1A - eUSCI_Ax Interrupt Enable Register
        volatile uint32_t UCAxIFG;  ///< Offset: 0x1C - eUSCI_Ax Interrupt Flag Register
        volatile uint32_t UCAxIV;  ///< Offset: 0x1E - eUSCI_Ax Interrupt Vector Register
    };

    /// Peripheral instances
    inline Registers* EUSCI_A0 = reinterpret_cast<Registers*>(EUSCI_A0_BASE);
    inline Registers* EUSCI_A1 = reinterpret_cast<Registers*>(EUSCI_A1_BASE);
    inline Registers* EUSCI_A2 = reinterpret_cast<Registers*>(EUSCI_A2_BASE);
    inline Registers* EUSCI_A3 = reinterpret_cast<Registers*>(EUSCI_A3_BASE);
    inline Registers* EUSCI_B0 = reinterpret_cast<Registers*>(EUSCI_B0_BASE);
    inline Registers* EUSCI_B1 = reinterpret_cast<Registers*>(EUSCI_B1_BASE);
    inline Registers* EUSCI_B2 = reinterpret_cast<Registers*>(EUSCI_B2_BASE);
    inline Registers* EUSCI_B3 = reinterpret_cast<Registers*>(EUSCI_B3_BASE);

    // Bit definitions
    /// UCAxCTLW0 Register bits
    namespace ucaxctlw0_bits {
        constexpr uint32_t UCSWRST = (1U << 0);  ///< Software reset enable
        constexpr uint32_t UCTXBRK = (1U << 1);  ///< Transmit break
        constexpr uint32_t UCTXADDR = (1U << 2);  ///< Transmit address
        constexpr uint32_t UCDORM = (1U << 3);  ///< Dormant
        constexpr uint32_t UCBRKIE = (1U << 4);  ///< Receive break character interrupt enable
        constexpr uint32_t UCRXEIE = (1U << 5);  ///< Receive erroneous-character interrupt enable
        constexpr uint32_t UCSSEL = (2 << 6);  ///< eUSCI_A clock source select
        constexpr uint32_t UCSYNC = (1U << 8);  ///< Synchronous mode enable
        constexpr uint32_t UCMODE = (2 << 9);  ///< eUSCI_A mode
        constexpr uint32_t UCSPB = (1U << 11);  ///< Stop bit select
        constexpr uint32_t UC7BIT = (1U << 12);  ///< Character length
        constexpr uint32_t UCMSB = (1U << 13);  ///< MSB first select
        constexpr uint32_t UCPAR = (1U << 14);  ///< Parity select
        constexpr uint32_t UCPEN = (1U << 15);  ///< Parity enable
    }

    /// UCAxCTLW1 Register bits
    namespace ucaxctlw1_bits {
        constexpr uint32_t UCGLIT = (2 << 0);  ///< Deglitch time
    }

    /// UCAxBRW Register bits
    namespace ucaxbrw_bits {
        constexpr uint32_t UCBR = (16 << 0);  ///< Clock prescaler setting of the Baud rate generator
    }

    /// UCAxMCTLW Register bits
    namespace ucaxmctlw_bits {
        constexpr uint32_t UCOS16 = (1U << 0);  ///< Oversampling mode enabled
        constexpr uint32_t UCBRF = (4 << 4);  ///< First modulation stage select
        constexpr uint32_t UCBRS = (8 << 8);  ///< Second modulation stage select
    }

    /// UCAxSTATW Register bits
    namespace ucaxstatw_bits {
        constexpr uint32_t UCBUSY = (1U << 0);  ///< eUSCI_A busy
        constexpr uint32_t UCADDR_UCIDLE = (1U << 1);  ///< Address received / Idle line detected
        constexpr uint32_t UCRXERR = (1U << 2);  ///< Receive error flag
        constexpr uint32_t UCBRK = (1U << 3);  ///< Break detect flag
        constexpr uint32_t UCPE = (1U << 4);  ///< Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.
        constexpr uint32_t UCOE = (1U << 5);  ///< Overrun error flag
        constexpr uint32_t UCFE = (1U << 6);  ///< Framing error flag
        constexpr uint32_t UCLISTEN = (1U << 7);  ///< Listen enable
    }

    /// UCAxRXBUF Register bits
    namespace ucaxrxbuf_bits {
        constexpr uint32_t UCRXBUF = (8 << 0);  ///< Receive data buffer
    }

    /// UCAxTXBUF Register bits
    namespace ucaxtxbuf_bits {
        constexpr uint32_t UCTXBUF = (8 << 0);  ///< Transmit data buffer
    }

    /// UCAxABCTL Register bits
    namespace ucaxabctl_bits {
        constexpr uint32_t UCABDEN = (1U << 0);  ///< Automatic baud-rate detect enable
        constexpr uint32_t UCBTOE = (1U << 2);  ///< Break time out error
        constexpr uint32_t UCSTOE = (1U << 3);  ///< Synch field time out error
        constexpr uint32_t UCDELIM = (2 << 4);  ///< Break/synch delimiter length
    }

    /// UCAxIRCTL Register bits
    namespace ucaxirctl_bits {
        constexpr uint32_t UCIREN = (1U << 0);  ///< IrDA encoder/decoder enable
        constexpr uint32_t UCIRTXCLK = (1U << 1);  ///< IrDA transmit pulse clock select
        constexpr uint32_t UCIRTXPL = (6 << 2);  ///< Transmit pulse length
        constexpr uint32_t UCIRRXFE = (1U << 8);  ///< IrDA receive filter enabled
        constexpr uint32_t UCIRRXPL = (1U << 9);  ///< IrDA receive input UCAxRXD polarity
        constexpr uint32_t UCIRRXFL = (4 << 10);  ///< Receive filter length
    }

    /// UCAxIE Register bits
    namespace ucaxie_bits {
        constexpr uint32_t UCRXIE = (1U << 0);  ///< Receive interrupt enable
        constexpr uint32_t UCTXIE = (1U << 1);  ///< Transmit interrupt enable
        constexpr uint32_t UCSTTIE = (1U << 2);  ///< Start bit interrupt enable
        constexpr uint32_t UCTXCPTIE = (1U << 3);  ///< Transmit complete interrupt enable
    }

    /// UCAxIFG Register bits
    namespace ucaxifg_bits {
        constexpr uint32_t UCRXIFG = (1U << 0);  ///< Receive interrupt flag
        constexpr uint32_t UCTXIFG = (1U << 1);  ///< Transmit interrupt flag
        constexpr uint32_t UCSTTIFG = (1U << 2);  ///< Start bit interrupt flag
        constexpr uint32_t UCTXCPTIFG = (1U << 3);  ///< Transmit ready interrupt enable
    }

    /// UCAxIV Register bits
    namespace ucaxiv_bits {
        constexpr uint32_t UCIV = (16 << 0);  ///< eUSCI_A interrupt vector value
    }

}

// ============================================================================
// REF Peripheral
// ============================================================================

namespace ref {
    /// Base addresses
    constexpr uint32_t REF_A_BASE = 0x40003000;

    /// REF Register structure
    struct Registers {
        volatile uint32_t REFCTL0;  ///< Offset: 0x00 - REF Control Register 0
    };

    /// Peripheral instances
    inline Registers* REF_A = reinterpret_cast<Registers*>(REF_A_BASE);

    // Bit definitions
    /// REFCTL0 Register bits
    namespace refctl0_bits {
        constexpr uint32_t REFON = (1U << 0);  ///< Reference enable
        constexpr uint32_t REFOUT = (1U << 1);  ///< Reference output buffer
        constexpr uint32_t REFTCOFF = (1U << 3);  ///< Temperature sensor disabled
        constexpr uint32_t REFVSEL = (2 << 4);  ///< Reference voltage level select
        constexpr uint32_t REFGENOT = (1U << 6);  ///< Reference generator one-time trigger
        constexpr uint32_t REFBGOT = (1U << 7);  ///< Bandgap and bandgap buffer one-time trigger
        constexpr uint32_t REFGENACT = (1U << 8);  ///< Reference generator active
        constexpr uint32_t REFBGACT = (1U << 9);  ///< Reference bandgap active
        constexpr uint32_t REFGENBUSY = (1U << 10);  ///< Reference generator busy
        constexpr uint32_t BGMODE = (1U << 11);  ///< Bandgap mode
        constexpr uint32_t REFGENRDY = (1U << 12);  ///< Variable reference voltage ready status
        constexpr uint32_t REFBGRDY = (1U << 13);  ///< Buffered bandgap voltage ready status
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_E0_BASE = 0x40003400;
    constexpr uint32_t COMP_E1_BASE = 0x40003800;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t CExCTL0;  ///< Offset: 0x00 - Comparator Control Register 0
        volatile uint32_t CExCTL1;  ///< Offset: 0x02 - Comparator Control Register 1
        volatile uint32_t CExCTL2;  ///< Offset: 0x04 - Comparator Control Register 2
        volatile uint32_t CExCTL3;  ///< Offset: 0x06 - Comparator Control Register 3
        volatile uint32_t CExINT;  ///< Offset: 0x0C - Comparator Interrupt Control Register
        volatile uint32_t CExIV;  ///< Offset: 0x0E - Comparator Interrupt Vector Word Register
    };

    /// Peripheral instances
    inline Registers* COMP_E0 = reinterpret_cast<Registers*>(COMP_E0_BASE);
    inline Registers* COMP_E1 = reinterpret_cast<Registers*>(COMP_E1_BASE);

    // Bit definitions
    /// CExCTL0 Register bits
    namespace cexctl0_bits {
        constexpr uint32_t CEIPSEL = (4 << 0);  ///< Channel input selected for the V+ terminal
        constexpr uint32_t CEIPEN = (1U << 7);  ///< Channel input enable for the V+ terminal
        constexpr uint32_t CEIMSEL = (4 << 8);  ///< Channel input selected for the - terminal
        constexpr uint32_t CEIMEN = (1U << 15);  ///< Channel input enable for the - terminal
    }

    /// CExCTL1 Register bits
    namespace cexctl1_bits {
        constexpr uint32_t CEOUT = (1U << 0);  ///< Comparator output value
        constexpr uint32_t CEOUTPOL = (1U << 1);  ///< Comparator output polarity
        constexpr uint32_t CEF = (1U << 2);  ///< Comparator output filter
        constexpr uint32_t CEIES = (1U << 3);  ///< Interrupt edge select for CEIIFG and CEIFG
        constexpr uint32_t CESHORT = (1U << 4);  ///< Input short
        constexpr uint32_t CEEX = (1U << 5);  ///< Exchange
        constexpr uint32_t CEFDLY = (2 << 6);  ///< Filter delay
        constexpr uint32_t CEPWRMD = (2 << 8);  ///< Power Mode
        constexpr uint32_t CEON = (1U << 10);  ///< Comparator On
        constexpr uint32_t CEMRVL = (1U << 11);  ///< This bit is valid of CEMRVS is set to 1
        constexpr uint32_t CEMRVS = (1U << 12);  ///< This bit defines if the comparator output selects between VREF0 or VREF1 if CERS = 00, 01, or 10.
    }

    /// CExCTL2 Register bits
    namespace cexctl2_bits {
        constexpr uint32_t CEREF0 = (5 << 0);  ///< Reference resistor tap 0
        constexpr uint32_t CERSEL = (1U << 5);  ///< Reference select
        constexpr uint32_t CERS = (2 << 6);  ///< Reference source
        constexpr uint32_t CEREF1 = (5 << 8);  ///< Reference resistor tap 1
        constexpr uint32_t CEREFL = (2 << 13);  ///< Reference voltage level
        constexpr uint32_t CEREFACC = (1U << 15);  ///< Reference accuracy
    }

    /// CExCTL3 Register bits
    namespace cexctl3_bits {
        constexpr uint32_t CEPD0 = (1U << 0);  ///< Port disable
        constexpr uint32_t CEPD1 = (1U << 1);  ///< Port disable
        constexpr uint32_t CEPD2 = (1U << 2);  ///< Port disable
        constexpr uint32_t CEPD3 = (1U << 3);  ///< Port disable
        constexpr uint32_t CEPD4 = (1U << 4);  ///< Port disable
        constexpr uint32_t CEPD5 = (1U << 5);  ///< Port disable
        constexpr uint32_t CEPD6 = (1U << 6);  ///< Port disable
        constexpr uint32_t CEPD7 = (1U << 7);  ///< Port disable
        constexpr uint32_t CEPD8 = (1U << 8);  ///< Port disable
        constexpr uint32_t CEPD9 = (1U << 9);  ///< Port disable
        constexpr uint32_t CEPD10 = (1U << 10);  ///< Port disable
        constexpr uint32_t CEPD11 = (1U << 11);  ///< Port disable
        constexpr uint32_t CEPD12 = (1U << 12);  ///< Port disable
        constexpr uint32_t CEPD13 = (1U << 13);  ///< Port disable
        constexpr uint32_t CEPD14 = (1U << 14);  ///< Port disable
        constexpr uint32_t CEPD15 = (1U << 15);  ///< Port disable
    }

    /// CExINT Register bits
    namespace cexint_bits {
        constexpr uint32_t CEIFG = (1U << 0);  ///< Comparator output interrupt flag
        constexpr uint32_t CEIIFG = (1U << 1);  ///< Comparator output inverted interrupt flag
        constexpr uint32_t CERDYIFG = (1U << 4);  ///< Comparator ready interrupt flag
        constexpr uint32_t CEIE = (1U << 8);  ///< Comparator output interrupt enable
        constexpr uint32_t CEIIE = (1U << 9);  ///< Comparator output interrupt enable inverted polarity
        constexpr uint32_t CERDYIE = (1U << 12);  ///< Comparator ready interrupt enable
    }

    /// CExIV Register bits
    namespace cexiv_bits {
        constexpr uint32_t CEIV = (16 << 0);  ///< Comparator interrupt vector word register
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES256_BASE = 0x40003C00;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t AESACTL0;  ///< Offset: 0x00 - AES Accelerator Control Register 0
        volatile uint32_t AESACTL1;  ///< Offset: 0x02 - AES Accelerator Control Register 1
        volatile uint32_t AESASTAT;  ///< Offset: 0x04 - AES Accelerator Status Register
        volatile uint32_t AESAKEY;  ///< Offset: 0x06 - AES Accelerator Key Register
        volatile uint32_t AESADIN;  ///< Offset: 0x08 - AES Accelerator Data In Register
        volatile uint32_t AESADOUT;  ///< Offset: 0x0A - AES Accelerator Data Out Register
        volatile uint32_t AESAXDIN;  ///< Offset: 0x0C - AES Accelerator XORed Data In Register
        volatile uint32_t AESAXIN;  ///< Offset: 0x0E - AES Accelerator XORed Data In Register
    };

    /// Peripheral instances
    inline Registers* AES256 = reinterpret_cast<Registers*>(AES256_BASE);

    // Bit definitions
    /// AESACTL0 Register bits
    namespace aesactl0_bits {
        constexpr uint32_t AESOPx = (2 << 0);  ///< AES operation
        constexpr uint32_t AESKLx = (2 << 2);  ///< AES key length
        constexpr uint32_t AESCMx = (2 << 5);  ///< AES cipher mode select
        constexpr uint32_t AESSWRST = (1U << 7);  ///< AES software reset
        constexpr uint32_t AESRDYIFG = (1U << 8);  ///< AES ready interrupt flag
        constexpr uint32_t AESERRFG = (1U << 11);  ///< AES error flag
        constexpr uint32_t AESRDYIE = (1U << 12);  ///< AES ready interrupt enable
        constexpr uint32_t AESCMEN = (1U << 15);  ///< AES cipher mode enable
    }

    /// AESACTL1 Register bits
    namespace aesactl1_bits {
        constexpr uint32_t AESBLKCNTx = (8 << 0);  ///< Cipher Block Counter
    }

    /// AESASTAT Register bits
    namespace aesastat_bits {
        constexpr uint32_t AESBUSY = (1U << 0);  ///< AES accelerator module busy
        constexpr uint32_t AESKEYWR = (1U << 1);  ///< All 16 bytes written to AESAKEY
        constexpr uint32_t AESDINWR = (1U << 2);  ///< All 16 bytes written to AESADIN, AESAXDIN or AESAXIN
        constexpr uint32_t AESDOUTRD = (1U << 3);  ///< All 16 bytes read from AESADOUT
        constexpr uint32_t AESKEYCNTx = (4 << 4);  ///< Bytes written via AESAKEY for AESKLx=00, half-words written via AESAKEY
        constexpr uint32_t AESDINCNTx = (4 << 8);  ///< Bytes written via AESADIN, AESAXDIN or AESAXIN
        constexpr uint32_t AESDOUTCNTx = (4 << 12);  ///< Bytes read via AESADOUT
    }

    /// AESAKEY Register bits
    namespace aesakey_bits {
        constexpr uint32_t AESKEY0x = (8 << 0);  ///< AES key byte n when AESAKEY is written as half-word
        constexpr uint32_t AESKEY1x = (8 << 8);  ///< AES key byte n+1 when AESAKEY is written as half-word
    }

    /// AESADIN Register bits
    namespace aesadin_bits {
        constexpr uint32_t AESDIN0x = (8 << 0);  ///< AES data in byte n when AESADIN is written as half-word
        constexpr uint32_t AESDIN1x = (8 << 8);  ///< AES data in byte n+1 when AESADIN is written as half-word
    }

    /// AESADOUT Register bits
    namespace aesadout_bits {
        constexpr uint32_t AESDOUT0x = (8 << 0);  ///< AES data out byte n when AESADOUT is read as half-word
        constexpr uint32_t AESDOUT1x = (8 << 8);  ///< AES data out byte n+1 when AESADOUT is read as half-word
    }

    /// AESAXDIN Register bits
    namespace aesaxdin_bits {
        constexpr uint32_t AESXDIN0x = (8 << 0);  ///< AES data in byte n when AESAXDIN is written as half-word
        constexpr uint32_t AESXDIN1x = (8 << 8);  ///< AES data in byte n+1 when AESAXDIN is written as half-word
    }

    /// AESAXIN Register bits
    namespace aesaxin_bits {
        constexpr uint32_t AESXIN0x = (8 << 0);  ///< AES data in byte n when AESAXIN is written as half-word
        constexpr uint32_t AESXIN1x = (8 << 8);  ///< AES data in byte n+1 when AESAXIN is written as half-word
    }

}

// ============================================================================
// CRC32 Peripheral
// ============================================================================

namespace crc32 {
    /// Base addresses
    constexpr uint32_t CRC32_BASE = 0x40004000;

    /// CRC32 Register structure
    struct Registers {
        volatile uint32_t CRC32DI;  ///< Offset: 0x00 - Data Input for CRC32 Signature Computation
        volatile uint32_t CRC32DIRB;  ///< Offset: 0x04 - Data In Reverse for CRC32 Computation
        volatile uint32_t CRC32INIRES_LO;  ///< Offset: 0x08 - CRC32 Initialization and Result, lower 16 bits
        volatile uint32_t CRC32INIRES_HI;  ///< Offset: 0x0A - CRC32 Initialization and Result, upper 16 bits
        volatile uint32_t CRC32RESR_LO;  ///< Offset: 0x0C - CRC32 Result Reverse, lower 16 bits
        volatile uint32_t CRC32RESR_HI;  ///< Offset: 0x0E - CRC32 Result Reverse, Upper 16 bits
        volatile uint32_t CRC16DI;  ///< Offset: 0x10 - Data Input for CRC16 computation
        volatile uint32_t CRC16DIRB;  ///< Offset: 0x14 - CRC16 Data In Reverse
        volatile uint32_t CRC16INIRES;  ///< Offset: 0x18 - CRC16 Initialization and Result register
        volatile uint32_t CRC16RESR;  ///< Offset: 0x1E - CRC16 Result Reverse
    };

    /// Peripheral instances
    inline Registers* CRC32 = reinterpret_cast<Registers*>(CRC32_BASE);

    // Bit definitions
    /// CRC32DI Register bits
    namespace crc32di_bits {
        constexpr uint32_t CRC32DI = (16 << 0);  ///< Data input register
    }

    /// CRC32DIRB Register bits
    namespace crc32dirb_bits {
        constexpr uint32_t CRC32DIRB = (16 << 0);  ///< Data input register reversed
    }

    /// CRC32INIRES_LO Register bits
    namespace crc32inires_lo_bits {
        constexpr uint32_t CRC32INIRES_LO = (16 << 0);  ///< CRC32 initialization and result, lower 16 bits
    }

    /// CRC32INIRES_HI Register bits
    namespace crc32inires_hi_bits {
        constexpr uint32_t CRC32INIRES_HI = (16 << 0);  ///< CRC32 initialization and result, upper 16 bits
    }

    /// CRC32RESR_LO Register bits
    namespace crc32resr_lo_bits {
        constexpr uint32_t CRC32RESR_LO = (16 << 0);  ///< CRC32 reverse result, lower 16 bits
    }

    /// CRC32RESR_HI Register bits
    namespace crc32resr_hi_bits {
        constexpr uint32_t CRC32RESR_HI = (16 << 0);  ///< CRC32 reverse result, upper 16 bits
    }

    /// CRC16DI Register bits
    namespace crc16di_bits {
        constexpr uint32_t CRC16DI = (16 << 0);  ///< CRC16 data in
    }

    /// CRC16DIRB Register bits
    namespace crc16dirb_bits {
        constexpr uint32_t CRC16DIRB = (16 << 0);  ///< CRC16 data in reverse byte
    }

    /// CRC16INIRES Register bits
    namespace crc16inires_bits {
        constexpr uint32_t CRC16INIRES = (16 << 0);  ///< CRC16 initialization and result
    }

    /// CRC16RESR Register bits
    namespace crc16resr_bits {
        constexpr uint32_t CRC16RESR = (16 << 0);  ///< CRC16 reverse result
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_C_BASE = 0x40004400;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTCCTL0;  ///< Offset: 0x00 - RTCCTL0 Register
        volatile uint32_t RTCCTL13;  ///< Offset: 0x02 - RTCCTL13 Register
        volatile uint32_t RTCOCAL;  ///< Offset: 0x04 - RTCOCAL Register
        volatile uint32_t RTCTCMP;  ///< Offset: 0x06 - RTCTCMP Register
        volatile uint32_t RTCPS0CTL;  ///< Offset: 0x08 - Real-Time Clock Prescale Timer 0 Control Register
        volatile uint32_t RTCPS1CTL;  ///< Offset: 0x0A - Real-Time Clock Prescale Timer 1 Control Register
        volatile uint32_t RTCPS;  ///< Offset: 0x0C - Real-Time Clock Prescale Timer Counter Register
        volatile uint32_t RTCIV;  ///< Offset: 0x0E - Real-Time Clock Interrupt Vector Register
        volatile uint32_t RTCTIM0;  ///< Offset: 0x10 - RTCTIM0 Register Hexadecimal Format
        volatile uint32_t RTCTIM1;  ///< Offset: 0x12 - Real-Time Clock Hour, Day of Week
        volatile uint32_t RTCDATE;  ///< Offset: 0x14 - RTCDATE - Hexadecimal Format
        volatile uint32_t RTCYEAR;  ///< Offset: 0x16 - RTCYEAR Register Hexadecimal Format
        volatile uint32_t RTCAMINHR;  ///< Offset: 0x18 - RTCMINHR - Hexadecimal Format
        volatile uint32_t RTCADOWDAY;  ///< Offset: 0x1A - RTCADOWDAY - Hexadecimal Format
        volatile uint32_t RTCBIN2BCD;  ///< Offset: 0x1C - Binary-to-BCD Conversion Register
        volatile uint32_t RTCBCD2BIN;  ///< Offset: 0x1E - BCD-to-Binary Conversion Register
    };

    /// Peripheral instances
    inline Registers* RTC_C = reinterpret_cast<Registers*>(RTC_C_BASE);

    // Bit definitions
    /// RTCCTL0 Register bits
    namespace rtcctl0_bits {
        constexpr uint32_t RTCRDYIFG = (1U << 0);  ///< Real-time clock ready interrupt flag
        constexpr uint32_t RTCAIFG = (1U << 1);  ///< Real-time clock alarm interrupt flag
        constexpr uint32_t RTCTEVIFG = (1U << 2);  ///< Real-time clock time event interrupt flag
        constexpr uint32_t RTCOFIFG = (1U << 3);  ///< 32-kHz crystal oscillator fault interrupt flag
        constexpr uint32_t RTCRDYIE = (1U << 4);  ///< Real-time clock ready interrupt enable
        constexpr uint32_t RTCAIE = (1U << 5);  ///< Real-time clock alarm interrupt enable
        constexpr uint32_t RTCTEVIE = (1U << 6);  ///< Real-time clock time event interrupt enable
        constexpr uint32_t RTCOFIE = (1U << 7);  ///< 32-kHz crystal oscillator fault interrupt enable
        constexpr uint32_t RTCKEY = (8 << 8);  ///< Real-time clock key
    }

    /// RTCCTL13 Register bits
    namespace rtcctl13_bits {
        constexpr uint32_t RTCTEV = (2 << 0);  ///< Real-time clock time event
        constexpr uint32_t RTCSSEL = (2 << 2);  ///< Real-time clock source select
        constexpr uint32_t RTCRDY = (1U << 4);  ///< Real-time clock ready
        constexpr uint32_t RTCMODE = (1U << 5);  ///< Calendar mode. Always reads a value of 1.
        constexpr uint32_t RTCHOLD = (1U << 6);  ///< Real-time clock hold
        constexpr uint32_t RTCBCD = (1U << 7);  ///< Real-time clock BCD select
        constexpr uint32_t RTCCALF = (2 << 8);  ///< Real-time clock calibration frequency
    }

    /// RTCOCAL Register bits
    namespace rtcocal_bits {
        constexpr uint32_t RTCOCAL = (8 << 0);  ///< Real-time clock offset error calibration
        constexpr uint32_t RTCOCALS = (1U << 15);  ///< Real-time clock offset error calibration sign
    }

    /// RTCTCMP Register bits
    namespace rtctcmp_bits {
        constexpr uint32_t RTCTCMP = (8 << 0);  ///< Real-time clock temperature compensation
        constexpr uint32_t RTCTCOK = (1U << 13);  ///< Real-time clock temperature compensation write OK
        constexpr uint32_t RTCTCRDY = (1U << 14);  ///< Real-time clock temperature compensation ready
        constexpr uint32_t RTCTCMPS = (1U << 15);  ///< Real-time clock temperature compensation sign
    }

    /// RTCPS0CTL Register bits
    namespace rtcps0ctl_bits {
        constexpr uint32_t RT0PSIFG = (1U << 0);  ///< Prescale timer 0 interrupt flag
        constexpr uint32_t RT0PSIE = (1U << 1);  ///< Prescale timer 0 interrupt enable
        constexpr uint32_t RT0IP = (3 << 2);  ///< Prescale timer 0 interrupt interval
    }

    /// RTCPS1CTL Register bits
    namespace rtcps1ctl_bits {
        constexpr uint32_t RT1PSIFG = (1U << 0);  ///< Prescale timer 1 interrupt flag
        constexpr uint32_t RT1PSIE = (1U << 1);  ///< Prescale timer 1 interrupt enable
        constexpr uint32_t RT1IP = (3 << 2);  ///< Prescale timer 1 interrupt interval
    }

    /// RTCPS Register bits
    namespace rtcps_bits {
        constexpr uint32_t RT0PS = (8 << 0);  ///< Prescale timer 0 counter value
        constexpr uint32_t RT1PS = (8 << 8);  ///< Prescale timer 1 counter value
    }

    /// RTCIV Register bits
    namespace rtciv_bits {
        constexpr uint32_t RTCIV = (16 << 0);  ///< Real-time clock interrupt vector value
    }

    /// RTCTIM0 Register bits
    namespace rtctim0_bits {
        constexpr uint32_t Seconds = (6 << 0);  ///< Seconds (0 to 59)
        constexpr uint32_t Minutes = (6 << 8);  ///< Minutes (0 to 59)
    }

    /// RTCTIM1 Register bits
    namespace rtctim1_bits {
        constexpr uint32_t Hours = (5 << 0);  ///< Hours (0 to 23)
        constexpr uint32_t DayofWeek = (3 << 8);  ///< Day of week (0 to 6)
    }

    /// RTCDATE Register bits
    namespace rtcdate_bits {
        constexpr uint32_t Day = (5 << 0);  ///< Day of month (1 to 28, 29, 30, 31)
        constexpr uint32_t Month = (4 << 8);  ///< Month (1 to 12)
    }

    /// RTCYEAR Register bits
    namespace rtcyear_bits {
        constexpr uint32_t YearLowByte = (8 << 0);  ///< Year low byte. Valid values for Year are 0 to 4095.
        constexpr uint32_t YearHighByte = (4 << 8);  ///< Year high byte. Valid values for Year are 0 to 4095.
    }

    /// RTCAMINHR Register bits
    namespace rtcaminhr_bits {
        constexpr uint32_t Minutes = (6 << 0);  ///< Minutes (0 to 59)
        constexpr uint32_t MINAE = (1U << 7);  ///< Alarm enable
        constexpr uint32_t Hours = (5 << 8);  ///< Hours (0 to 23)
        constexpr uint32_t HOURAE = (1U << 15);  ///< Alarm enable
    }

    /// RTCADOWDAY Register bits
    namespace rtcadowday_bits {
        constexpr uint32_t DayofWeek = (3 << 0);  ///< Day of week (0 to 6)
        constexpr uint32_t DOWAE = (1U << 7);  ///< Alarm enable
        constexpr uint32_t DayofMonth = (5 << 8);  ///< Day of month (1 to 28, 29, 30, 31)
        constexpr uint32_t DAYAE = (1U << 15);  ///< Alarm enable
    }

    /// RTCBIN2BCD Register bits
    namespace rtcbin2bcd_bits {
        constexpr uint32_t BIN2BCD = (16 << 0);  ///< bin to bcd conversion
    }

    /// RTCBCD2BIN Register bits
    namespace rtcbcd2bin_bits {
        constexpr uint32_t BCD2BIN = (16 << 0);  ///< bcd to bin conversion
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_A_BASE = 0x40004800;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDTCTL;  ///< Offset: 0x0C - Watchdog Timer Control Register
    };

    /// Peripheral instances
    inline Registers* WDT_A = reinterpret_cast<Registers*>(WDT_A_BASE);

    // Bit definitions
    /// WDTCTL Register bits
    namespace wdtctl_bits {
        constexpr uint32_t WDTIS = (3 << 0);  ///< Watchdog timer interval select
        constexpr uint32_t WDTCNTCL = (1U << 3);  ///< Watchdog timer counter clear
        constexpr uint32_t WDTTMSEL = (1U << 4);  ///< Watchdog timer mode select
        constexpr uint32_t WDTSSEL = (2 << 5);  ///< Watchdog timer clock source select
        constexpr uint32_t WDTHOLD = (1U << 7);  ///< Watchdog timer hold
        constexpr uint32_t WDTPW = (8 << 8);  ///< Watchdog timer password
    }

}

// ============================================================================
// DIO Peripheral
// ============================================================================

namespace dio {
    /// Base addresses
    constexpr uint32_t DIO_BASE = 0x40004C00;

    /// DIO Register structure
    struct Registers {
        volatile uint32_t PAIN;  ///< Offset: 0x00 - Port A Input
        volatile uint32_t PAOUT;  ///< Offset: 0x02 - Port A Output
        volatile uint32_t PADIR;  ///< Offset: 0x04 - Port A Direction
        volatile uint32_t PAREN;  ///< Offset: 0x06 - Port A Resistor Enable
        volatile uint32_t PADS;  ///< Offset: 0x08 - Port A Drive Strength
        volatile uint32_t PASEL0;  ///< Offset: 0x0A - Port A Select 0
        volatile uint32_t PASEL1;  ///< Offset: 0x0C - Port A Select 1
        volatile uint32_t P1IV;  ///< Offset: 0x0E - Port 1 Interrupt Vector Register
        volatile uint32_t PASELC;  ///< Offset: 0x16 - Port A Complement Select
        volatile uint32_t PAIES;  ///< Offset: 0x18 - Port A Interrupt Edge Select
        volatile uint32_t PAIE;  ///< Offset: 0x1A - Port A Interrupt Enable
        volatile uint32_t PAIFG;  ///< Offset: 0x1C - Port A Interrupt Flag
        volatile uint32_t P2IV;  ///< Offset: 0x1E - Port 2 Interrupt Vector Register
        volatile uint32_t PBIN;  ///< Offset: 0x20 - Port B Input
        volatile uint32_t PBOUT;  ///< Offset: 0x22 - Port B Output
        volatile uint32_t PBDIR;  ///< Offset: 0x24 - Port B Direction
        volatile uint32_t PBREN;  ///< Offset: 0x26 - Port B Resistor Enable
        volatile uint32_t PBDS;  ///< Offset: 0x28 - Port B Drive Strength
        volatile uint32_t PBSEL0;  ///< Offset: 0x2A - Port B Select 0
        volatile uint32_t PBSEL1;  ///< Offset: 0x2C - Port B Select 1
        volatile uint32_t P3IV;  ///< Offset: 0x2E - Port 3 Interrupt Vector Register
        volatile uint32_t PBSELC;  ///< Offset: 0x36 - Port B Complement Select
        volatile uint32_t PBIES;  ///< Offset: 0x38 - Port B Interrupt Edge Select
        volatile uint32_t PBIE;  ///< Offset: 0x3A - Port B Interrupt Enable
        volatile uint32_t PBIFG;  ///< Offset: 0x3C - Port B Interrupt Flag
        volatile uint32_t P4IV;  ///< Offset: 0x3E - Port 4 Interrupt Vector Register
        volatile uint32_t PCIN;  ///< Offset: 0x40 - Port C Input
        volatile uint32_t PCOUT;  ///< Offset: 0x42 - Port C Output
        volatile uint32_t PCDIR;  ///< Offset: 0x44 - Port C Direction
        volatile uint32_t PCREN;  ///< Offset: 0x46 - Port C Resistor Enable
        volatile uint32_t PCDS;  ///< Offset: 0x48 - Port C Drive Strength
        volatile uint32_t PCSEL0;  ///< Offset: 0x4A - Port C Select 0
        volatile uint32_t PCSEL1;  ///< Offset: 0x4C - Port C Select 1
        volatile uint32_t P5IV;  ///< Offset: 0x4E - Port 5 Interrupt Vector Register
        volatile uint32_t PCSELC;  ///< Offset: 0x56 - Port C Complement Select
        volatile uint32_t PCIES;  ///< Offset: 0x58 - Port C Interrupt Edge Select
        volatile uint32_t PCIE;  ///< Offset: 0x5A - Port C Interrupt Enable
        volatile uint32_t PCIFG;  ///< Offset: 0x5C - Port C Interrupt Flag
        volatile uint32_t P6IV;  ///< Offset: 0x5E - Port 6 Interrupt Vector Register
        volatile uint32_t PDIN;  ///< Offset: 0x60 - Port D Input
        volatile uint32_t PDOUT;  ///< Offset: 0x62 - Port D Output
        volatile uint32_t PDDIR;  ///< Offset: 0x64 - Port D Direction
        volatile uint32_t PDREN;  ///< Offset: 0x66 - Port D Resistor Enable
        volatile uint32_t PDDS;  ///< Offset: 0x68 - Port D Drive Strength
        volatile uint32_t PDSEL0;  ///< Offset: 0x6A - Port D Select 0
        volatile uint32_t PDSEL1;  ///< Offset: 0x6C - Port D Select 1
        volatile uint32_t P7IV;  ///< Offset: 0x6E - Port 7 Interrupt Vector Register
        volatile uint32_t PDSELC;  ///< Offset: 0x76 - Port D Complement Select
        volatile uint32_t PDIES;  ///< Offset: 0x78 - Port D Interrupt Edge Select
        volatile uint32_t PDIE;  ///< Offset: 0x7A - Port D Interrupt Enable
        volatile uint32_t PDIFG;  ///< Offset: 0x7C - Port D Interrupt Flag
        volatile uint32_t P8IV;  ///< Offset: 0x7E - Port 8 Interrupt Vector Register
        volatile uint32_t PEIN;  ///< Offset: 0x80 - Port E Input
        volatile uint32_t PEOUT;  ///< Offset: 0x82 - Port E Output
        volatile uint32_t PEDIR;  ///< Offset: 0x84 - Port E Direction
        volatile uint32_t PEREN;  ///< Offset: 0x86 - Port E Resistor Enable
        volatile uint32_t PEDS;  ///< Offset: 0x88 - Port E Drive Strength
        volatile uint32_t PESEL0;  ///< Offset: 0x8A - Port E Select 0
        volatile uint32_t PESEL1;  ///< Offset: 0x8C - Port E Select 1
        volatile uint32_t P9IV;  ///< Offset: 0x8E - Port 9 Interrupt Vector Register
        volatile uint32_t PESELC;  ///< Offset: 0x96 - Port E Complement Select
        volatile uint32_t PEIES;  ///< Offset: 0x98 - Port E Interrupt Edge Select
        volatile uint32_t PEIE;  ///< Offset: 0x9A - Port E Interrupt Enable
        volatile uint32_t PEIFG;  ///< Offset: 0x9C - Port E Interrupt Flag
        volatile uint32_t P10IV;  ///< Offset: 0x9E - Port 10 Interrupt Vector Register
        volatile uint32_t PJIN;  ///< Offset: 0x120 - Port J Input
        volatile uint32_t PJOUT;  ///< Offset: 0x122 - Port J Output
        volatile uint32_t PJDIR;  ///< Offset: 0x124 - Port J Direction
        volatile uint32_t PJREN;  ///< Offset: 0x126 - Port J Resistor Enable
        volatile uint32_t PJDS;  ///< Offset: 0x128 - Port J Drive Strength
        volatile uint32_t PJSEL0;  ///< Offset: 0x12A - Port J Select 0
        volatile uint32_t PJSEL1;  ///< Offset: 0x12C - Port J Select 1
        volatile uint32_t PJSELC;  ///< Offset: 0x136 - Port J Complement Select
    };

    /// Peripheral instances
    inline Registers* DIO = reinterpret_cast<Registers*>(DIO_BASE);

    // Bit definitions
    /// PAIN Register bits
    namespace pain_bits {
        constexpr uint32_t P1IN = (8 << 0);  ///< Port 1 Input
        constexpr uint32_t P2IN = (8 << 8);  ///< Port 2 Input
    }

    /// PAOUT Register bits
    namespace paout_bits {
        constexpr uint32_t P2OUT = (8 << 8);  ///< Port 2 Output
        constexpr uint32_t P1OUT = (8 << 0);  ///< Port 1 Output
    }

    /// PADIR Register bits
    namespace padir_bits {
        constexpr uint32_t P1DIR = (8 << 0);  ///< Port 1 Direction
        constexpr uint32_t P2DIR = (8 << 8);  ///< Port 2 Direction
    }

    /// PAREN Register bits
    namespace paren_bits {
        constexpr uint32_t P1REN = (8 << 0);  ///< Port 1 Resistor Enable
        constexpr uint32_t P2REN = (8 << 8);  ///< Port 2 Resistor Enable
    }

    /// PADS Register bits
    namespace pads_bits {
        constexpr uint32_t P1DS = (8 << 0);  ///< Port 1 Drive Strength
        constexpr uint32_t P2DS = (8 << 8);  ///< Port 2 Drive Strength
    }

    /// PASEL0 Register bits
    namespace pasel0_bits {
        constexpr uint32_t P1SEL0 = (8 << 0);  ///< Port 1 Select 0
        constexpr uint32_t P2SEL0 = (8 << 8);  ///< Port 2 Select 0
    }

    /// PASEL1 Register bits
    namespace pasel1_bits {
        constexpr uint32_t P1SEL1 = (8 << 0);  ///< Port 1 Select 1
        constexpr uint32_t P2SEL1 = (8 << 8);  ///< Port 2 Select 1
    }

    /// P1IV Register bits
    namespace p1iv_bits {
        constexpr uint32_t P1IV = (5 << 0);  ///< Port 1 interrupt vector value
    }

    /// PASELC Register bits
    namespace paselc_bits {
        constexpr uint32_t P1SELC = (8 << 0);  ///< Port 1 Complement Select
        constexpr uint32_t P2SELC = (8 << 8);  ///< Port 2 Complement Select
    }

    /// PAIES Register bits
    namespace paies_bits {
        constexpr uint32_t P1IES = (8 << 0);  ///< Port 1 Interrupt Edge Select
        constexpr uint32_t P2IES = (8 << 8);  ///< Port 2 Interrupt Edge Select
    }

    /// PAIE Register bits
    namespace paie_bits {
        constexpr uint32_t P1IE = (8 << 0);  ///< Port 1 Interrupt Enable
        constexpr uint32_t P2IE = (8 << 8);  ///< Port 2 Interrupt Enable
    }

    /// PAIFG Register bits
    namespace paifg_bits {
        constexpr uint32_t P1IFG = (8 << 0);  ///< Port 1 Interrupt Flag
        constexpr uint32_t P2IFG = (8 << 8);  ///< Port 2 Interrupt Flag
    }

    /// P2IV Register bits
    namespace p2iv_bits {
        constexpr uint32_t P2IV = (5 << 0);  ///< Port 2 interrupt vector value
    }

    /// PBIN Register bits
    namespace pbin_bits {
        constexpr uint32_t P3IN = (8 << 0);  ///< Port 3 Input
        constexpr uint32_t P4IN = (8 << 8);  ///< Port 4 Input
    }

    /// PBOUT Register bits
    namespace pbout_bits {
        constexpr uint32_t P3OUT = (8 << 0);  ///< Port 3 Output
        constexpr uint32_t P4OUT = (8 << 8);  ///< Port 4 Output
    }

    /// PBDIR Register bits
    namespace pbdir_bits {
        constexpr uint32_t P3DIR = (8 << 0);  ///< Port 3 Direction
        constexpr uint32_t P4DIR = (8 << 8);  ///< Port 4 Direction
    }

    /// PBREN Register bits
    namespace pbren_bits {
        constexpr uint32_t P3REN = (8 << 0);  ///< Port 3 Resistor Enable
        constexpr uint32_t P4REN = (8 << 8);  ///< Port 4 Resistor Enable
    }

    /// PBDS Register bits
    namespace pbds_bits {
        constexpr uint32_t P3DS = (8 << 0);  ///< Port 3 Drive Strength
        constexpr uint32_t P4DS = (8 << 8);  ///< Port 4 Drive Strength
    }

    /// PBSEL0 Register bits
    namespace pbsel0_bits {
        constexpr uint32_t P4SEL0 = (8 << 8);  ///< Port 4 Select 0
        constexpr uint32_t P3SEL0 = (8 << 0);  ///< Port 3 Select 0
    }

    /// PBSEL1 Register bits
    namespace pbsel1_bits {
        constexpr uint32_t P3SEL1 = (8 << 0);  ///< Port 3 Select 1
        constexpr uint32_t P4SEL1 = (8 << 8);  ///< Port 4 Select 1
    }

    /// P3IV Register bits
    namespace p3iv_bits {
        constexpr uint32_t P3IV = (5 << 0);  ///< Port 3 interrupt vector value
    }

    /// PBSELC Register bits
    namespace pbselc_bits {
        constexpr uint32_t P3SELC = (8 << 0);  ///< Port 3 Complement Select
        constexpr uint32_t P4SELC = (8 << 8);  ///< Port 4 Complement Select
    }

    /// PBIES Register bits
    namespace pbies_bits {
        constexpr uint32_t P3IES = (8 << 0);  ///< Port 3 Interrupt Edge Select
        constexpr uint32_t P4IES = (8 << 8);  ///< Port 4 Interrupt Edge Select
    }

    /// PBIE Register bits
    namespace pbie_bits {
        constexpr uint32_t P3IE = (8 << 0);  ///< Port 3 Interrupt Enable
        constexpr uint32_t P4IE = (8 << 8);  ///< Port 4 Interrupt Enable
    }

    /// PBIFG Register bits
    namespace pbifg_bits {
        constexpr uint32_t P3IFG = (8 << 0);  ///< Port 3 Interrupt Flag
        constexpr uint32_t P4IFG = (8 << 8);  ///< Port 4 Interrupt Flag
    }

    /// P4IV Register bits
    namespace p4iv_bits {
        constexpr uint32_t P4IV = (5 << 0);  ///< Port 4 interrupt vector value
    }

    /// PCIN Register bits
    namespace pcin_bits {
        constexpr uint32_t P5IN = (8 << 0);  ///< Port 5 Input
        constexpr uint32_t P6IN = (8 << 8);  ///< Port 6 Input
    }

    /// PCOUT Register bits
    namespace pcout_bits {
        constexpr uint32_t P5OUT = (8 << 0);  ///< Port 5 Output
        constexpr uint32_t P6OUT = (8 << 8);  ///< Port 6 Output
    }

    /// PCDIR Register bits
    namespace pcdir_bits {
        constexpr uint32_t P5DIR = (8 << 0);  ///< Port 5 Direction
        constexpr uint32_t P6DIR = (8 << 8);  ///< Port 6 Direction
    }

    /// PCREN Register bits
    namespace pcren_bits {
        constexpr uint32_t P5REN = (8 << 0);  ///< Port 5 Resistor Enable
        constexpr uint32_t P6REN = (8 << 8);  ///< Port 6 Resistor Enable
    }

    /// PCDS Register bits
    namespace pcds_bits {
        constexpr uint32_t P5DS = (8 << 0);  ///< Port 5 Drive Strength
        constexpr uint32_t P6DS = (8 << 8);  ///< Port 6 Drive Strength
    }

    /// PCSEL0 Register bits
    namespace pcsel0_bits {
        constexpr uint32_t P5SEL0 = (8 << 0);  ///< Port 5 Select 0
        constexpr uint32_t P6SEL0 = (8 << 8);  ///< Port 6 Select 0
    }

    /// PCSEL1 Register bits
    namespace pcsel1_bits {
        constexpr uint32_t P5SEL1 = (8 << 0);  ///< Port 5 Select 1
        constexpr uint32_t P6SEL1 = (8 << 8);  ///< Port 6 Select 1
    }

    /// P5IV Register bits
    namespace p5iv_bits {
        constexpr uint32_t P5IV = (5 << 0);  ///< Port 5 interrupt vector value
    }

    /// PCSELC Register bits
    namespace pcselc_bits {
        constexpr uint32_t P5SELC = (8 << 0);  ///< Port 5 Complement Select
        constexpr uint32_t P6SELC = (8 << 8);  ///< Port 6 Complement Select
    }

    /// PCIES Register bits
    namespace pcies_bits {
        constexpr uint32_t P5IES = (8 << 0);  ///< Port 5 Interrupt Edge Select
        constexpr uint32_t P6IES = (8 << 8);  ///< Port 6 Interrupt Edge Select
    }

    /// PCIE Register bits
    namespace pcie_bits {
        constexpr uint32_t P5IE = (8 << 0);  ///< Port 5 Interrupt Enable
        constexpr uint32_t P6IE = (8 << 8);  ///< Port 6 Interrupt Enable
    }

    /// PCIFG Register bits
    namespace pcifg_bits {
        constexpr uint32_t P5IFG = (8 << 0);  ///< Port 5 Interrupt Flag
        constexpr uint32_t P6IFG = (8 << 8);  ///< Port 6 Interrupt Flag
    }

    /// P6IV Register bits
    namespace p6iv_bits {
        constexpr uint32_t P6IV = (5 << 0);  ///< Port 6 interrupt vector value
    }

    /// PDIN Register bits
    namespace pdin_bits {
        constexpr uint32_t P7IN = (8 << 0);  ///< Port 7 Input
        constexpr uint32_t P8IN = (8 << 8);  ///< Port 8 Input
    }

    /// PDOUT Register bits
    namespace pdout_bits {
        constexpr uint32_t P7OUT = (8 << 0);  ///< Port 7 Output
        constexpr uint32_t P8OUT = (8 << 8);  ///< Port 8 Output
    }

    /// PDDIR Register bits
    namespace pddir_bits {
        constexpr uint32_t P7DIR = (8 << 0);  ///< Port 7 Direction
        constexpr uint32_t P8DIR = (8 << 8);  ///< Port 8 Direction
    }

    /// PDREN Register bits
    namespace pdren_bits {
        constexpr uint32_t P7REN = (8 << 0);  ///< Port 7 Resistor Enable
        constexpr uint32_t P8REN = (8 << 8);  ///< Port 8 Resistor Enable
    }

    /// PDDS Register bits
    namespace pdds_bits {
        constexpr uint32_t P7DS = (8 << 0);  ///< Port 7 Drive Strength
        constexpr uint32_t P8DS = (8 << 8);  ///< Port 8 Drive Strength
    }

    /// PDSEL0 Register bits
    namespace pdsel0_bits {
        constexpr uint32_t P7SEL0 = (8 << 0);  ///< Port 7 Select 0
        constexpr uint32_t P8SEL0 = (8 << 8);  ///< Port 8 Select 0
    }

    /// PDSEL1 Register bits
    namespace pdsel1_bits {
        constexpr uint32_t P7SEL1 = (8 << 0);  ///< Port 7 Select 1
        constexpr uint32_t P8SEL1 = (8 << 8);  ///< Port 8 Select 1
    }

    /// P7IV Register bits
    namespace p7iv_bits {
        constexpr uint32_t P7IV = (5 << 0);  ///< Port 7 interrupt vector value
    }

    /// PDSELC Register bits
    namespace pdselc_bits {
        constexpr uint32_t P7SELC = (8 << 0);  ///< Port 7 Complement Select
        constexpr uint32_t P8SELC = (8 << 8);  ///< Port 8 Complement Select
    }

    /// PDIES Register bits
    namespace pdies_bits {
        constexpr uint32_t P7IES = (8 << 0);  ///< Port 7 Interrupt Edge Select
        constexpr uint32_t P8IES = (8 << 8);  ///< Port 8 Interrupt Edge Select
    }

    /// PDIE Register bits
    namespace pdie_bits {
        constexpr uint32_t P7IE = (8 << 0);  ///< Port 7 Interrupt Enable
        constexpr uint32_t P8IE = (8 << 8);  ///< Port 8 Interrupt Enable
    }

    /// PDIFG Register bits
    namespace pdifg_bits {
        constexpr uint32_t P7IFG = (8 << 0);  ///< Port 7 Interrupt Flag
        constexpr uint32_t P8IFG = (8 << 8);  ///< Port 8 Interrupt Flag
    }

    /// P8IV Register bits
    namespace p8iv_bits {
        constexpr uint32_t P8IV = (5 << 0);  ///< Port 8 interrupt vector value
    }

    /// PEIN Register bits
    namespace pein_bits {
        constexpr uint32_t P9IN = (8 << 0);  ///< Port 9 Input
        constexpr uint32_t P10IN = (8 << 8);  ///< Port 10 Input
    }

    /// PEOUT Register bits
    namespace peout_bits {
        constexpr uint32_t P9OUT = (8 << 0);  ///< Port 9 Output
        constexpr uint32_t P10OUT = (8 << 8);  ///< Port 10 Output
    }

    /// PEDIR Register bits
    namespace pedir_bits {
        constexpr uint32_t P9DIR = (8 << 0);  ///< Port 9 Direction
        constexpr uint32_t P10DIR = (8 << 8);  ///< Port 10 Direction
    }

    /// PEREN Register bits
    namespace peren_bits {
        constexpr uint32_t P9REN = (8 << 0);  ///< Port 9 Resistor Enable
        constexpr uint32_t P10REN = (8 << 8);  ///< Port 10 Resistor Enable
    }

    /// PEDS Register bits
    namespace peds_bits {
        constexpr uint32_t P9DS = (8 << 0);  ///< Port 9 Drive Strength
        constexpr uint32_t P10DS = (8 << 8);  ///< Port 10 Drive Strength
    }

    /// PESEL0 Register bits
    namespace pesel0_bits {
        constexpr uint32_t P9SEL0 = (8 << 0);  ///< Port 9 Select 0
        constexpr uint32_t P10SEL0 = (8 << 8);  ///< Port 10 Select 0
    }

    /// PESEL1 Register bits
    namespace pesel1_bits {
        constexpr uint32_t P9SEL1 = (8 << 0);  ///< Port 9 Select 1
        constexpr uint32_t P10SEL1 = (8 << 8);  ///< Port 10 Select 1
    }

    /// P9IV Register bits
    namespace p9iv_bits {
        constexpr uint32_t P9IV = (5 << 0);  ///< Port 9 interrupt vector value
    }

    /// PESELC Register bits
    namespace peselc_bits {
        constexpr uint32_t P9SELC = (8 << 0);  ///< Port 9 Complement Select
        constexpr uint32_t P10SELC = (8 << 8);  ///< Port 10 Complement Select
    }

    /// PEIES Register bits
    namespace peies_bits {
        constexpr uint32_t P9IES = (8 << 0);  ///< Port 9 Interrupt Edge Select
        constexpr uint32_t P10IES = (8 << 8);  ///< Port 10 Interrupt Edge Select
    }

    /// PEIE Register bits
    namespace peie_bits {
        constexpr uint32_t P9IE = (8 << 0);  ///< Port 9 Interrupt Enable
        constexpr uint32_t P10IE = (8 << 8);  ///< Port 10 Interrupt Enable
    }

    /// PEIFG Register bits
    namespace peifg_bits {
        constexpr uint32_t P9IFG = (8 << 0);  ///< Port 9 Interrupt Flag
        constexpr uint32_t P10IFG = (8 << 8);  ///< Port 10 Interrupt Flag
    }

    /// P10IV Register bits
    namespace p10iv_bits {
        constexpr uint32_t P10IV = (5 << 0);  ///< Port 10 interrupt vector value
    }

    /// PJIN Register bits
    namespace pjin_bits {
        constexpr uint32_t PJIN = (16 << 0);  ///< Port J Input
    }

    /// PJOUT Register bits
    namespace pjout_bits {
        constexpr uint32_t PJOUT = (16 << 0);  ///< Port J Output
    }

    /// PJDIR Register bits
    namespace pjdir_bits {
        constexpr uint32_t PJDIR = (16 << 0);  ///< Port J Direction
    }

    /// PJREN Register bits
    namespace pjren_bits {
        constexpr uint32_t PJREN = (16 << 0);  ///< Port J Resistor Enable
    }

    /// PJDS Register bits
    namespace pjds_bits {
        constexpr uint32_t PJDS = (16 << 0);  ///< Port J Drive Strength
    }

    /// PJSEL0 Register bits
    namespace pjsel0_bits {
        constexpr uint32_t PJSEL0 = (16 << 0);  ///< Port J Select 0
    }

    /// PJSEL1 Register bits
    namespace pjsel1_bits {
        constexpr uint32_t PJSEL1 = (16 << 0);  ///< Port J Select 1
    }

    /// PJSELC Register bits
    namespace pjselc_bits {
        constexpr uint32_t PJSELC = (16 << 0);  ///< Port J Complement Select
    }

}

// ============================================================================
// PMAP Peripheral
// ============================================================================

namespace pmap {
    /// Base addresses
    constexpr uint32_t PMAP_BASE = 0x40005000;

    /// PMAP Register structure
    struct Registers {
        volatile uint32_t PMAPKEYID;  ///< Offset: 0x00 - Port Mapping Key Register
        volatile uint32_t PMAPCTL;  ///< Offset: 0x02 - Port Mapping Control Register
        volatile uint32_t P1MAP01;  ///< Offset: 0x08 - Port mapping register, P1.0 and P1.1
        volatile uint32_t P1MAP23;  ///< Offset: 0x0A - Port mapping register, P1.2 and P1.3
        volatile uint32_t P1MAP45;  ///< Offset: 0x0C - Port mapping register, P1.4 and P1.5
        volatile uint32_t P1MAP67;  ///< Offset: 0x0E - Port mapping register, P1.6 and P1.7
        volatile uint32_t P2MAP01;  ///< Offset: 0x10 - Port mapping register, P2.0 and P2.1
        volatile uint32_t P2MAP23;  ///< Offset: 0x12 - Port mapping register, P2.2 and P2.3
        volatile uint32_t P2MAP45;  ///< Offset: 0x14 - Port mapping register, P2.4 and P2.5
        volatile uint32_t P2MAP67;  ///< Offset: 0x16 - Port mapping register, P2.6 and P2.7
        volatile uint32_t P3MAP01;  ///< Offset: 0x18 - Port mapping register, P3.0 and P3.1
        volatile uint32_t P3MAP23;  ///< Offset: 0x1A - Port mapping register, P3.2 and P3.3
        volatile uint32_t P3MAP45;  ///< Offset: 0x1C - Port mapping register, P3.4 and P3.5
        volatile uint32_t P3MAP67;  ///< Offset: 0x1E - Port mapping register, P3.6 and P3.7
        volatile uint32_t P4MAP01;  ///< Offset: 0x20 - Port mapping register, P4.0 and P4.1
        volatile uint32_t P4MAP23;  ///< Offset: 0x22 - Port mapping register, P4.2 and P4.3
        volatile uint32_t P4MAP45;  ///< Offset: 0x24 - Port mapping register, P4.4 and P4.5
        volatile uint32_t P4MAP67;  ///< Offset: 0x26 - Port mapping register, P4.6 and P4.7
        volatile uint32_t P5MAP01;  ///< Offset: 0x28 - Port mapping register, P5.0 and P5.1
        volatile uint32_t P5MAP23;  ///< Offset: 0x2A - Port mapping register, P5.2 and P5.3
        volatile uint32_t P5MAP45;  ///< Offset: 0x2C - Port mapping register, P5.4 and P5.5
        volatile uint32_t P5MAP67;  ///< Offset: 0x2E - Port mapping register, P5.6 and P5.7
        volatile uint32_t P6MAP01;  ///< Offset: 0x30 - Port mapping register, P6.0 and P6.1
        volatile uint32_t P6MAP23;  ///< Offset: 0x32 - Port mapping register, P6.2 and P6.3
        volatile uint32_t P6MAP45;  ///< Offset: 0x34 - Port mapping register, P6.4 and P6.5
        volatile uint32_t P6MAP67;  ///< Offset: 0x36 - Port mapping register, P6.6 and P6.7
        volatile uint32_t P7MAP01;  ///< Offset: 0x38 - Port mapping register, P7.0 and P7.1
        volatile uint32_t P7MAP23;  ///< Offset: 0x3A - Port mapping register, P7.2 and P7.3
        volatile uint32_t P7MAP45;  ///< Offset: 0x3C - Port mapping register, P7.4 and P7.5
        volatile uint32_t P7MAP67;  ///< Offset: 0x3E - Port mapping register, P7.6 and P7.7
    };

    /// Peripheral instances
    inline Registers* PMAP = reinterpret_cast<Registers*>(PMAP_BASE);

    // Bit definitions
    /// PMAPKEYID Register bits
    namespace pmapkeyid_bits {
        constexpr uint32_t PMAPKEY = (16 << 0);  ///< Port mapping controller write access key
    }

    /// PMAPCTL Register bits
    namespace pmapctl_bits {
        constexpr uint32_t PMAPLOCKED = (1U << 0);  ///< Port mapping lock bit
        constexpr uint32_t PMAPRECFG = (1U << 1);  ///< Port mapping reconfiguration control bit
    }

    /// P1MAP01 Register bits
    namespace p1map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P1MAP23 Register bits
    namespace p1map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P1MAP45 Register bits
    namespace p1map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P1MAP67 Register bits
    namespace p1map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P2MAP01 Register bits
    namespace p2map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P2MAP23 Register bits
    namespace p2map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P2MAP45 Register bits
    namespace p2map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P2MAP67 Register bits
    namespace p2map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P3MAP01 Register bits
    namespace p3map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P3MAP23 Register bits
    namespace p3map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P3MAP45 Register bits
    namespace p3map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P3MAP67 Register bits
    namespace p3map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P4MAP01 Register bits
    namespace p4map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P4MAP23 Register bits
    namespace p4map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P4MAP45 Register bits
    namespace p4map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P4MAP67 Register bits
    namespace p4map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P5MAP01 Register bits
    namespace p5map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P5MAP23 Register bits
    namespace p5map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P5MAP45 Register bits
    namespace p5map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P5MAP67 Register bits
    namespace p5map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P6MAP01 Register bits
    namespace p6map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P6MAP23 Register bits
    namespace p6map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P6MAP45 Register bits
    namespace p6map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P6MAP67 Register bits
    namespace p6map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P7MAP01 Register bits
    namespace p7map01_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P7MAP23 Register bits
    namespace p7map23_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P7MAP45 Register bits
    namespace p7map45_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

    /// P7MAP67 Register bits
    namespace p7map67_bits {
        constexpr uint32_t PMAPx = (16 << 0);  ///< Selects secondary port function
    }

}

// ============================================================================
// CAPTIO0 Peripheral
// ============================================================================

namespace captio0 {
    /// Base addresses
    constexpr uint32_t CAPTIO0_BASE = 0x40005400;

    /// CAPTIO0 Register structure
    struct Registers {
        volatile uint32_t CAPTIOxCTL;  ///< Offset: 0x0E - Capacitive Touch IO x Control Register
    };

    /// Peripheral instances
    inline Registers* CAPTIO0 = reinterpret_cast<Registers*>(CAPTIO0_BASE);

    // Bit definitions
    /// CAPTIOxCTL Register bits
    namespace captioxctl_bits {
        constexpr uint32_t CAPTIOPISELx = (3 << 1);  ///< Capacitive Touch IO pin select
        constexpr uint32_t CAPTIOPOSELx = (4 << 4);  ///< Capacitive Touch IO port select
        constexpr uint32_t CAPTIOEN = (1U << 8);  ///< Capacitive Touch IO enable
        constexpr uint32_t CAPTIOSTATE = (1U << 9);  ///< Capacitive Touch IO state
    }

}

// ============================================================================
// CAPTIO1 Peripheral
// ============================================================================

namespace captio1 {
    /// Base addresses
    constexpr uint32_t CAPTIO1_BASE = 0x40005800;

    /// CAPTIO1 Register structure
    struct Registers {
        volatile uint32_t CAPTIOxCTL;  ///< Offset: 0x0E - Capacitive Touch IO x Control Register
    };

    /// Peripheral instances
    inline Registers* CAPTIO1 = reinterpret_cast<Registers*>(CAPTIO1_BASE);

    // Bit definitions
    /// CAPTIOxCTL Register bits
    namespace captioxctl_bits {
        constexpr uint32_t CAPTIOPISELx = (3 << 1);  ///< Capacitive Touch IO pin select
        constexpr uint32_t CAPTIOPOSELx = (4 << 4);  ///< Capacitive Touch IO port select
        constexpr uint32_t CAPTIOEN = (1U << 8);  ///< Capacitive Touch IO enable
        constexpr uint32_t CAPTIOSTATE = (1U << 9);  ///< Capacitive Touch IO state
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x4000E000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMA_DEVICE_CFG;  ///< Offset: 0x00 - Device Configuration Status
        volatile uint32_t DMA_SW_CHTRIG;  ///< Offset: 0x04 - Software Channel Trigger Register
        volatile uint32_t DMA_CH_SRCCFG__;  ///< Offset: 0x10 - Channel n Source Configuration Register (renamed from DMA_CH_SRCCFG__)
        volatile uint32_t DMA_INT1_SRCCFG;  ///< Offset: 0x100 - Interrupt 1 Source Channel Configuration
        volatile uint32_t DMA_INT2_SRCCFG;  ///< Offset: 0x104 - Interrupt 2 Source Channel Configuration Register
        volatile uint32_t DMA_INT3_SRCCFG;  ///< Offset: 0x108 - Interrupt 3 Source Channel Configuration Register
        volatile uint32_t DMA_INT0_SRCFLG;  ///< Offset: 0x110 - Interrupt 0 Source Channel Flag Register
        volatile uint32_t DMA_INT0_CLRFLG;  ///< Offset: 0x114 - Interrupt 0 Source Channel Clear Flag Register
        volatile uint32_t DMA_STAT;  ///< Offset: 0x1000 - Status Register
        volatile uint32_t DMA_CFG;  ///< Offset: 0x1004 - Configuration Register
        volatile uint32_t DMA_CTLBASE;  ///< Offset: 0x1008 - Channel Control Data Base Pointer Register
        volatile uint32_t DMA_ALTBASE;  ///< Offset: 0x100C - Channel Alternate Control Data Base Pointer Register
        volatile uint32_t DMA_WAITSTAT;  ///< Offset: 0x1010 - Channel Wait on Request Status Register
        volatile uint32_t DMA_SWREQ;  ///< Offset: 0x1014 - Channel Software Request Register
        volatile uint32_t DMA_USEBURSTSET;  ///< Offset: 0x1018 - Channel Useburst Set Register
        volatile uint32_t DMA_USEBURSTCLR;  ///< Offset: 0x101C - Channel Useburst Clear Register
        volatile uint32_t DMA_REQMASKSET;  ///< Offset: 0x1020 - Channel Request Mask Set Register
        volatile uint32_t DMA_REQMASKCLR;  ///< Offset: 0x1024 - Channel Request Mask Clear Register
        volatile uint32_t DMA_ENASET;  ///< Offset: 0x1028 - Channel Enable Set Register
        volatile uint32_t DMA_ENACLR;  ///< Offset: 0x102C - Channel Enable Clear Register
        volatile uint32_t DMA_ALTSET;  ///< Offset: 0x1030 - Channel Primary-Alternate Set Register
        volatile uint32_t DMA_ALTCLR;  ///< Offset: 0x1034 - Channel Primary-Alternate Clear Register
        volatile uint32_t DMA_PRIOSET;  ///< Offset: 0x1038 - Channel Priority Set Register
        volatile uint32_t DMA_PRIOCLR;  ///< Offset: 0x103C - Channel Priority Clear Register
        volatile uint32_t DMA_ERRCLR;  ///< Offset: 0x104C - Bus Error Clear Register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// DMA_DEVICE_CFG Register bits
    namespace dma_device_cfg_bits {
        constexpr uint32_t NUM_DMA_CHANNELS = (8 << 0);  ///< Number of DMA channels available
        constexpr uint32_t NUM_SRC_PER_CHANNEL = (8 << 8);  ///< Number of DMA sources per channel
    }

    /// DMA_SW_CHTRIG Register bits
    namespace dma_sw_chtrig_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Write 1, triggers DMA_CHANNEL0
        constexpr uint32_t CH1 = (1U << 1);  ///< Write 1, triggers DMA_CHANNEL1
        constexpr uint32_t CH2 = (1U << 2);  ///< Write 1, triggers DMA_CHANNEL2
        constexpr uint32_t CH3 = (1U << 3);  ///< Write 1, triggers DMA_CHANNEL3
        constexpr uint32_t CH4 = (1U << 4);  ///< Write 1, triggers DMA_CHANNEL4
        constexpr uint32_t CH5 = (1U << 5);  ///< Write 1, triggers DMA_CHANNEL5
        constexpr uint32_t CH6 = (1U << 6);  ///< Write 1, triggers DMA_CHANNEL6
        constexpr uint32_t CH7 = (1U << 7);  ///< Write 1, triggers DMA_CHANNEL7
        constexpr uint32_t CH8 = (1U << 8);  ///< Write 1, triggers DMA_CHANNEL8
        constexpr uint32_t CH9 = (1U << 9);  ///< Write 1, triggers DMA_CHANNEL9
        constexpr uint32_t CH10 = (1U << 10);  ///< Write 1, triggers DMA_CHANNEL10
        constexpr uint32_t CH11 = (1U << 11);  ///< Write 1, triggers DMA_CHANNEL11
        constexpr uint32_t CH12 = (1U << 12);  ///< Write 1, triggers DMA_CHANNEL12
        constexpr uint32_t CH13 = (1U << 13);  ///< Write 1, triggers DMA_CHANNEL13
        constexpr uint32_t CH14 = (1U << 14);  ///< Write 1, triggers DMA_CHANNEL14
        constexpr uint32_t CH15 = (1U << 15);  ///< Write 1, triggers DMA_CHANNEL15
        constexpr uint32_t CH16 = (1U << 16);  ///< Write 1, triggers DMA_CHANNEL16
        constexpr uint32_t CH17 = (1U << 17);  ///< Write 1, triggers DMA_CHANNEL17
        constexpr uint32_t CH18 = (1U << 18);  ///< Write 1, triggers DMA_CHANNEL18
        constexpr uint32_t CH19 = (1U << 19);  ///< Write 1, triggers DMA_CHANNEL19
        constexpr uint32_t CH20 = (1U << 20);  ///< Write 1, triggers DMA_CHANNEL20
        constexpr uint32_t CH21 = (1U << 21);  ///< Write 1, triggers DMA_CHANNEL21
        constexpr uint32_t CH22 = (1U << 22);  ///< Write 1, triggers DMA_CHANNEL22
        constexpr uint32_t CH23 = (1U << 23);  ///< Write 1, triggers DMA_CHANNEL23
        constexpr uint32_t CH24 = (1U << 24);  ///< Write 1, triggers DMA_CHANNEL24
        constexpr uint32_t CH25 = (1U << 25);  ///< Write 1, triggers DMA_CHANNEL25
        constexpr uint32_t CH26 = (1U << 26);  ///< Write 1, triggers DMA_CHANNEL26
        constexpr uint32_t CH27 = (1U << 27);  ///< Write 1, triggers DMA_CHANNEL27
        constexpr uint32_t CH28 = (1U << 28);  ///< Write 1, triggers DMA_CHANNEL28
        constexpr uint32_t CH29 = (1U << 29);  ///< Write 1, triggers DMA_CHANNEL29
        constexpr uint32_t CH30 = (1U << 30);  ///< Write 1, triggers DMA_CHANNEL30
        constexpr uint32_t CH31 = (1U << 31);  ///< Write 1, triggers DMA_CHANNEL31
    }

    /// DMA_CH_SRCCFG__ Register bits
    namespace dma_ch_srccfg___bits {
        constexpr uint32_t DMA_SRC = (8 << 0);  ///< Device level DMA source mapping to channel input
    }

    /// DMA_INT1_SRCCFG Register bits
    namespace dma_int1_srccfg_bits {
        constexpr uint32_t INT_SRC = (5 << 0);  ///< Controls which channel's completion event is mapped as a source of this Interrupt
        constexpr uint32_t EN = (1U << 5);  ///< Enables DMA_INT1 mapping
    }

    /// DMA_INT2_SRCCFG Register bits
    namespace dma_int2_srccfg_bits {
        constexpr uint32_t INT_SRC = (5 << 0);  ///< Controls which channel's completion event is mapped as a source of this Interrupt
        constexpr uint32_t EN = (1U << 5);  ///< Enables DMA_INT2 mapping
    }

    /// DMA_INT3_SRCCFG Register bits
    namespace dma_int3_srccfg_bits {
        constexpr uint32_t INT_SRC = (5 << 0);  ///< Controls which channel's completion event is mapped as a source of this Interrupt
        constexpr uint32_t EN = (1U << 5);  ///< Enables DMA_INT3 mapping
    }

    /// DMA_INT0_SRCFLG Register bits
    namespace dma_int0_srcflg_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Channel 0 was the source of DMA_INT0
        constexpr uint32_t CH1 = (1U << 1);  ///< Channel 1 was the source of DMA_INT0
        constexpr uint32_t CH2 = (1U << 2);  ///< Channel 2 was the source of DMA_INT0
        constexpr uint32_t CH3 = (1U << 3);  ///< Channel 3 was the source of DMA_INT0
        constexpr uint32_t CH4 = (1U << 4);  ///< Channel 4 was the source of DMA_INT0
        constexpr uint32_t CH5 = (1U << 5);  ///< Channel 5 was the source of DMA_INT0
        constexpr uint32_t CH6 = (1U << 6);  ///< Channel 6 was the source of DMA_INT0
        constexpr uint32_t CH7 = (1U << 7);  ///< Channel 7 was the source of DMA_INT0
        constexpr uint32_t CH8 = (1U << 8);  ///< Channel 8 was the source of DMA_INT0
        constexpr uint32_t CH9 = (1U << 9);  ///< Channel 9 was the source of DMA_INT0
        constexpr uint32_t CH10 = (1U << 10);  ///< Channel 10 was the source of DMA_INT0
        constexpr uint32_t CH11 = (1U << 11);  ///< Channel 11 was the source of DMA_INT0
        constexpr uint32_t CH12 = (1U << 12);  ///< Channel 12 was the source of DMA_INT0
        constexpr uint32_t CH13 = (1U << 13);  ///< Channel 13 was the source of DMA_INT0
        constexpr uint32_t CH14 = (1U << 14);  ///< Channel 14 was the source of DMA_INT0
        constexpr uint32_t CH15 = (1U << 15);  ///< Channel 15 was the source of DMA_INT0
        constexpr uint32_t CH16 = (1U << 16);  ///< Channel 16 was the source of DMA_INT0
        constexpr uint32_t CH17 = (1U << 17);  ///< Channel 17 was the source of DMA_INT0
        constexpr uint32_t CH18 = (1U << 18);  ///< Channel 18 was the source of DMA_INT0
        constexpr uint32_t CH19 = (1U << 19);  ///< Channel 19 was the source of DMA_INT0
        constexpr uint32_t CH20 = (1U << 20);  ///< Channel 20 was the source of DMA_INT0
        constexpr uint32_t CH21 = (1U << 21);  ///< Channel 21 was the source of DMA_INT0
        constexpr uint32_t CH22 = (1U << 22);  ///< Channel 22 was the source of DMA_INT0
        constexpr uint32_t CH23 = (1U << 23);  ///< Channel 23 was the source of DMA_INT0
        constexpr uint32_t CH24 = (1U << 24);  ///< Channel 24 was the source of DMA_INT0
        constexpr uint32_t CH25 = (1U << 25);  ///< Channel 25 was the source of DMA_INT0
        constexpr uint32_t CH26 = (1U << 26);  ///< Channel 26 was the source of DMA_INT0
        constexpr uint32_t CH27 = (1U << 27);  ///< Channel 27 was the source of DMA_INT0
        constexpr uint32_t CH28 = (1U << 28);  ///< Channel 28 was the source of DMA_INT0
        constexpr uint32_t CH29 = (1U << 29);  ///< Channel 29 was the source of DMA_INT0
        constexpr uint32_t CH30 = (1U << 30);  ///< Channel 30 was the source of DMA_INT0
        constexpr uint32_t CH31 = (1U << 31);  ///< Channel 31 was the source of DMA_INT0
    }

    /// DMA_INT0_CLRFLG Register bits
    namespace dma_int0_clrflg_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH1 = (1U << 1);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH2 = (1U << 2);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH3 = (1U << 3);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH4 = (1U << 4);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH5 = (1U << 5);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH6 = (1U << 6);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH7 = (1U << 7);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH8 = (1U << 8);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH9 = (1U << 9);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH10 = (1U << 10);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH11 = (1U << 11);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH12 = (1U << 12);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH13 = (1U << 13);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH14 = (1U << 14);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH15 = (1U << 15);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH16 = (1U << 16);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH17 = (1U << 17);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH18 = (1U << 18);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH19 = (1U << 19);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH20 = (1U << 20);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH21 = (1U << 21);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH22 = (1U << 22);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH23 = (1U << 23);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH24 = (1U << 24);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH25 = (1U << 25);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH26 = (1U << 26);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH27 = (1U << 27);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH28 = (1U << 28);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH29 = (1U << 29);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH30 = (1U << 30);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
        constexpr uint32_t CH31 = (1U << 31);  ///< Clear corresponding DMA_INT0_SRCFLG_REG
    }

    /// DMA_STAT Register bits
    namespace dma_stat_bits {
        constexpr uint32_t MASTEN = (1U << 0);  ///< Enable status of the controller
        constexpr uint32_t STATE = (4 << 4);  ///< Current state of the control state machine. State can be one of the following:
        constexpr uint32_t DMACHANS = (5 << 16);  ///< Number of available DMA channels minus one.
        constexpr uint32_t TESTSTAT = (4 << 28);  ///< To reduce the gate count the controller can be configured to exclude the integration test logic. The values 2h to Fh are Reserved.
    }

    /// DMA_CFG Register bits
    namespace dma_cfg_bits {
        constexpr uint32_t MASTEN = (1U << 0);  ///< Enable status of the controller
        constexpr uint32_t CHPROTCTRL = (3 << 5);  ///< Sets the AHB-Lite protection by controlling the HPROT[3:1] signal levels as follows: Bit [7] Controls HPROT[3] to indicate if a cacheable access is occurring. Bit [6] Controls HPROT[2] to indicate if a bufferable access is occurring. Bit [5] Controls HPROT[1] to indicate if a privileged access is occurring. Note: When bit [n] = 1 then the corresponding HPROT is HIGH. When bit [n] = 0 then the corresponding HPROT is LOW.
    }

    /// DMA_CTLBASE Register bits
    namespace dma_ctlbase_bits {
        constexpr uint32_t ADDR = (27 << 5);  ///< Pointer to the base address of the primary data structure.
    }

    /// DMA_ALTBASE Register bits
    namespace dma_altbase_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< Base address of the alternate data structure
    }

    /// DMA_WAITSTAT Register bits
    namespace dma_waitstat_bits {
        constexpr uint32_t WAITREQ = (32 << 0);  ///< Channel wait on request status.
    }

    /// DMA_SWREQ Register bits
    namespace dma_swreq_bits {
        constexpr uint32_t CHNL_SW_REQ = (32 << 0);  ///< Set the appropriate bit to generate a software DMA request on the corresponding DMA channel. Writing to a bit where a DMA channel is not implemented does not create a DMA request for that channel.
    }

    /// DMA_USEBURSTSET Register bits
    namespace dma_useburstset_bits {
        constexpr uint32_t SET = (32 << 0);  ///< Returns the useburst status, or disables dma_sreq from generating DMA requests.
    }

    /// DMA_USEBURSTCLR Register bits
    namespace dma_useburstclr_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Set the appropriate bit to enable dma_sreq to generate requests.
    }

    /// DMA_REQMASKSET Register bits
    namespace dma_reqmaskset_bits {
        constexpr uint32_t SET = (32 << 0);  ///< Returns the request mask status of dma_req and dma_sreq, or disables the corresponding channel from generating DMA requests.
    }

    /// DMA_REQMASKCLR Register bits
    namespace dma_reqmaskclr_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Set the appropriate bit to enable DMA requests for the channel corresponding to dma_req and dma_sreq.
    }

    /// DMA_ENASET Register bits
    namespace dma_enaset_bits {
        constexpr uint32_t SET = (32 << 0);  ///< Returns the enable status of the channels, or enables the corresponding channels.
    }

    /// DMA_ENACLR Register bits
    namespace dma_enaclr_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Set the appropriate bit to disable the corresponding DMA channel. Note: The controller disables a channel, by setting the appropriate bit, when: a) it completes the DMA cycle b) it reads a channel_cfg memory location which has cycle_ctrl = b000 c) an ERROR occurs on the AHB-Lite bus.
    }

    /// DMA_ALTSET Register bits
    namespace dma_altset_bits {
        constexpr uint32_t SET = (32 << 0);  ///< Channel Primary-Alternate Set Register
    }

    /// DMA_ALTCLR Register bits
    namespace dma_altclr_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Channel Primary-Alternate Clear Register
    }

    /// DMA_PRIOSET Register bits
    namespace dma_prioset_bits {
        constexpr uint32_t SET = (32 << 0);  ///< Returns the channel priority mask status, or sets the channel priority to high.
    }

    /// DMA_PRIOCLR Register bits
    namespace dma_prioclr_bits {
        constexpr uint32_t CLR = (32 << 0);  ///< Set the appropriate bit to select the default priority level for the specified DMA channel.
    }

    /// DMA_ERRCLR Register bits
    namespace dma_errclr_bits {
        constexpr uint32_t ERRCLR = (1U << 0);  ///< Returns the status of dma_err, or sets the signal LOW. For test purposes, use the ERRSET register to set dma_err HIGH. Note: If you deassert dma_err at the same time as an ERROR occurs on the AHB-Lite bus, then the ERROR condition takes precedence and dma_err remains asserted.
    }

}

// ============================================================================
// PCM Peripheral
// ============================================================================

namespace pcm {
    /// Base addresses
    constexpr uint32_t PCM_BASE = 0x40010000;

    /// PCM Register structure
    struct Registers {
        volatile uint32_t PCMCTL0;  ///< Offset: 0x00 - Control 0 Register
        volatile uint32_t PCMCTL1;  ///< Offset: 0x04 - Control 1 Register
        volatile uint32_t PCMIE;  ///< Offset: 0x08 - Interrupt Enable Register
        volatile uint32_t PCMIFG;  ///< Offset: 0x0C - Interrupt Flag Register
        volatile uint32_t PCMCLRIFG;  ///< Offset: 0x10 - Clear Interrupt Flag Register
    };

    /// Peripheral instances
    inline Registers* PCM = reinterpret_cast<Registers*>(PCM_BASE);

    // Bit definitions
    /// PCMCTL0 Register bits
    namespace pcmctl0_bits {
        constexpr uint32_t AMR = (4 << 0);  ///< Active Mode Request
        constexpr uint32_t LPMR = (4 << 4);  ///< Low Power Mode Request
        constexpr uint32_t CPM = (6 << 8);  ///< Current Power Mode
        constexpr uint32_t PCMKEY = (16 << 16);  ///< PCM key
    }

    /// PCMCTL1 Register bits
    namespace pcmctl1_bits {
        constexpr uint32_t LOCKLPM5 = (1U << 0);  ///< Lock LPM5
        constexpr uint32_t LOCKBKUP = (1U << 1);  ///< Lock Backup
        constexpr uint32_t FORCE_LPM_ENTRY = (1U << 2);  ///< Force LPM entry
        constexpr uint32_t PMR_BUSY = (1U << 8);  ///< Power mode request busy flag
        constexpr uint32_t PCMKEY = (16 << 16);  ///< PCM key
    }

    /// PCMIE Register bits
    namespace pcmie_bits {
        constexpr uint32_t LPM_INVALID_TR_IE = (1U << 0);  ///< LPM invalid transition interrupt enable
        constexpr uint32_t LPM_INVALID_CLK_IE = (1U << 1);  ///< LPM invalid clock interrupt enable
        constexpr uint32_t AM_INVALID_TR_IE = (1U << 2);  ///< Active mode invalid transition interrupt enable
        constexpr uint32_t DCDC_ERROR_IE = (1U << 6);  ///< DC-DC error interrupt enable
    }

    /// PCMIFG Register bits
    namespace pcmifg_bits {
        constexpr uint32_t LPM_INVALID_TR_IFG = (1U << 0);  ///< LPM invalid transition flag
        constexpr uint32_t LPM_INVALID_CLK_IFG = (1U << 1);  ///< LPM invalid clock flag
        constexpr uint32_t AM_INVALID_TR_IFG = (1U << 2);  ///< Active mode invalid transition flag
        constexpr uint32_t DCDC_ERROR_IFG = (1U << 6);  ///< DC-DC error flag
    }

    /// PCMCLRIFG Register bits
    namespace pcmclrifg_bits {
        constexpr uint32_t CLR_LPM_INVALID_TR_IFG = (1U << 0);  ///< Clear LPM invalid transition flag
        constexpr uint32_t CLR_LPM_INVALID_CLK_IFG = (1U << 1);  ///< Clear LPM invalid clock flag
        constexpr uint32_t CLR_AM_INVALID_TR_IFG = (1U << 2);  ///< Clear active mode invalid transition flag
        constexpr uint32_t CLR_DCDC_ERROR_IFG = (1U << 6);  ///< Clear DC-DC error flag
    }

}

// ============================================================================
// CS Peripheral
// ============================================================================

namespace cs {
    /// Base addresses
    constexpr uint32_t CS_BASE = 0x40010400;

    /// CS Register structure
    struct Registers {
        volatile uint32_t CSKEY;  ///< Offset: 0x00 - Key Register
        volatile uint32_t CSCTL0;  ///< Offset: 0x04 - Control 0 Register
        volatile uint32_t CSCTL1;  ///< Offset: 0x08 - Control 1 Register
        volatile uint32_t CSCTL2;  ///< Offset: 0x0C - Control 2 Register
        volatile uint32_t CSCTL3;  ///< Offset: 0x10 - Control 3 Register
        volatile uint32_t CSCLKEN;  ///< Offset: 0x30 - Clock Enable Register
        volatile uint32_t CSSTAT;  ///< Offset: 0x34 - Status Register
        volatile uint32_t CSIE;  ///< Offset: 0x40 - Interrupt Enable Register
        volatile uint32_t CSIFG;  ///< Offset: 0x48 - Interrupt Flag Register
        volatile uint32_t CSCLRIFG;  ///< Offset: 0x50 - Clear Interrupt Flag Register
        volatile uint32_t CSSETIFG;  ///< Offset: 0x58 - Set Interrupt Flag Register
        volatile uint32_t CSDCOERCAL0;  ///< Offset: 0x60 - DCO External Resistor Cailbration 0 Register
        volatile uint32_t CSDCOERCAL1;  ///< Offset: 0x64 - DCO External Resistor Calibration 1 Register
    };

    /// Peripheral instances
    inline Registers* CS = reinterpret_cast<Registers*>(CS_BASE);

    // Bit definitions
    /// CSKEY Register bits
    namespace cskey_bits {
        constexpr uint32_t CSKEY = (16 << 0);  ///< Write xxxx_695Ah to unlock
    }

    /// CSCTL0 Register bits
    namespace csctl0_bits {
        constexpr uint32_t DCOTUNE = (10 << 0);  ///< DCO frequency tuning select
        constexpr uint32_t DCORSEL = (3 << 16);  ///< DCO frequency range select
        constexpr uint32_t DCORES = (1U << 22);  ///< Enables the DCO external resistor mode
        constexpr uint32_t DCOEN = (1U << 23);  ///< Enables the DCO oscillator
    }

    /// CSCTL1 Register bits
    namespace csctl1_bits {
        constexpr uint32_t SELM = (3 << 0);  ///< Selects the MCLK source
        constexpr uint32_t SELS = (3 << 4);  ///< Selects the SMCLK and HSMCLK source
        constexpr uint32_t SELA = (3 << 8);  ///< Selects the ACLK source
        constexpr uint32_t SELB = (1U << 12);  ///< Selects the BCLK source
        constexpr uint32_t DIVM = (3 << 16);  ///< MCLK source divider
        constexpr uint32_t DIVHS = (3 << 20);  ///< HSMCLK source divider
        constexpr uint32_t DIVA = (3 << 24);  ///< ACLK source divider
        constexpr uint32_t DIVS = (3 << 28);  ///< SMCLK source divider
    }

    /// CSCTL2 Register bits
    namespace csctl2_bits {
        constexpr uint32_t LFXTDRIVE = (2 << 0);  ///< LFXT oscillator current can be adjusted to its drive needs
        constexpr uint32_t LFXTAGCOFF = (1U << 7);  ///< Disables the automatic gain control of the LFXT crystal
        constexpr uint32_t LFXT_EN = (1U << 8);  ///< Turns on the LFXT oscillator regardless if used as a clock resource
        constexpr uint32_t LFXTBYPASS = (1U << 9);  ///< LFXT bypass select
        constexpr uint32_t HFXTDRIVE = (1U << 16);  ///< HFXT oscillator drive selection
        constexpr uint32_t HFXTFREQ = (3 << 20);  ///< HFXT frequency selection
        constexpr uint32_t HFXT_EN = (1U << 24);  ///< Turns on the HFXT oscillator regardless if used as a clock resource
        constexpr uint32_t HFXTBYPASS = (1U << 25);  ///< HFXT bypass select
    }

    /// CSCTL3 Register bits
    namespace csctl3_bits {
        constexpr uint32_t FCNTLF = (2 << 0);  ///< Start flag counter for LFXT
        constexpr uint32_t RFCNTLF = (1U << 2);  ///< Reset start fault counter for LFXT
        constexpr uint32_t FCNTLF_EN = (1U << 3);  ///< Enable start fault counter for LFXT
        constexpr uint32_t FCNTHF = (2 << 4);  ///< Start flag counter for HFXT
        constexpr uint32_t RFCNTHF = (1U << 6);  ///< Reset start fault counter for HFXT
        constexpr uint32_t FCNTHF_EN = (1U << 7);  ///< Enable start fault counter for HFXT
        constexpr uint32_t FCNTHF2 = (2 << 8);  ///< Start flag counter for HFXT2
        constexpr uint32_t RFCNTHF2 = (1U << 10);  ///< Reset start fault counter for HFXT2
        constexpr uint32_t FCNTHF2_EN = (1U << 11);  ///< Enable start fault counter for HFXT2
    }

    /// CSCLKEN Register bits
    namespace csclken_bits {
        constexpr uint32_t ACLK_EN = (1U << 0);  ///< ACLK system clock conditional request enable
        constexpr uint32_t MCLK_EN = (1U << 1);  ///< MCLK system clock conditional request enable
        constexpr uint32_t HSMCLK_EN = (1U << 2);  ///< HSMCLK system clock conditional request enable
        constexpr uint32_t SMCLK_EN = (1U << 3);  ///< SMCLK system clock conditional request enable
        constexpr uint32_t VLO_EN = (1U << 8);  ///< Turns on the VLO oscillator
        constexpr uint32_t REFO_EN = (1U << 9);  ///< Turns on the REFO oscillator
        constexpr uint32_t MODOSC_EN = (1U << 10);  ///< Turns on the MODOSC oscillator
        constexpr uint32_t REFOFSEL = (1U << 15);  ///< Selects REFO nominal frequency
    }

    /// CSSTAT Register bits
    namespace csstat_bits {
        constexpr uint32_t DCO_ON = (1U << 0);  ///< DCO status
        constexpr uint32_t DCOBIAS_ON = (1U << 1);  ///< DCO bias status
        constexpr uint32_t HFXT_ON = (1U << 2);  ///< HFXT status
        constexpr uint32_t HFXT2_ON = (1U << 3);  ///< HFXT2 status
        constexpr uint32_t MODOSC_ON = (1U << 4);  ///< MODOSC status
        constexpr uint32_t VLO_ON = (1U << 5);  ///< VLO status
        constexpr uint32_t LFXT_ON = (1U << 6);  ///< LFXT status
        constexpr uint32_t REFO_ON = (1U << 7);  ///< REFO status
        constexpr uint32_t ACLK_ON = (1U << 16);  ///< ACLK system clock status
        constexpr uint32_t MCLK_ON = (1U << 17);  ///< MCLK system clock status
        constexpr uint32_t HSMCLK_ON = (1U << 18);  ///< HSMCLK system clock status
        constexpr uint32_t SMCLK_ON = (1U << 19);  ///< SMCLK system clock status
        constexpr uint32_t MODCLK_ON = (1U << 20);  ///< MODCLK system clock status
        constexpr uint32_t VLOCLK_ON = (1U << 21);  ///< VLOCLK system clock status
        constexpr uint32_t LFXTCLK_ON = (1U << 22);  ///< LFXTCLK system clock status
        constexpr uint32_t REFOCLK_ON = (1U << 23);  ///< REFOCLK system clock status
        constexpr uint32_t ACLK_READY = (1U << 24);  ///< ACLK Ready status
        constexpr uint32_t MCLK_READY = (1U << 25);  ///< MCLK Ready status
        constexpr uint32_t HSMCLK_READY = (1U << 26);  ///< HSMCLK Ready status
        constexpr uint32_t SMCLK_READY = (1U << 27);  ///< SMCLK Ready status
        constexpr uint32_t BCLK_READY = (1U << 28);  ///< BCLK Ready status
    }

    /// CSIE Register bits
    namespace csie_bits {
        constexpr uint32_t LFXTIE = (1U << 0);  ///< LFXT oscillator fault flag interrupt enable
        constexpr uint32_t HFXTIE = (1U << 1);  ///< HFXT oscillator fault flag interrupt enable
        constexpr uint32_t HFXT2IE = (1U << 2);  ///< HFXT2 oscillator fault flag interrupt enable
        constexpr uint32_t DCOR_OPNIE = (1U << 6);  ///< DCO external resistor open circuit fault flag interrupt enable.
        constexpr uint32_t FCNTLFIE = (1U << 8);  ///< Start fault counter interrupt enable LFXT
        constexpr uint32_t FCNTHFIE = (1U << 9);  ///< Start fault counter interrupt enable HFXT
        constexpr uint32_t FCNTHF2IE = (1U << 10);  ///< Start fault counter interrupt enable HFXT2
        constexpr uint32_t PLLOOLIE = (1U << 12);  ///< PLL out-of-lock interrupt enable
        constexpr uint32_t PLLLOSIE = (1U << 13);  ///< PLL loss-of-signal interrupt enable
        constexpr uint32_t PLLOORIE = (1U << 14);  ///< PLL out-of-range interrupt enable
        constexpr uint32_t CALIE = (1U << 15);  ///< REFCNT period counter interrupt enable
    }

    /// CSIFG Register bits
    namespace csifg_bits {
        constexpr uint32_t LFXTIFG = (1U << 0);  ///< LFXT oscillator fault flag
        constexpr uint32_t HFXTIFG = (1U << 1);  ///< HFXT oscillator fault flag
        constexpr uint32_t HFXT2IFG = (1U << 2);  ///< HFXT2 oscillator fault flag
        constexpr uint32_t DCOR_SHTIFG = (1U << 5);  ///< DCO external resistor short circuit fault flag.
        constexpr uint32_t DCOR_OPNIFG = (1U << 6);  ///< DCO external resistor open circuit fault flag.
        constexpr uint32_t FCNTLFIFG = (1U << 8);  ///< Start fault counter interrupt flag LFXT
        constexpr uint32_t FCNTHFIFG = (1U << 9);  ///< Start fault counter interrupt flag HFXT
        constexpr uint32_t FCNTHF2IFG = (1U << 11);  ///< Start fault counter interrupt flag HFXT2
        constexpr uint32_t PLLOOLIFG = (1U << 12);  ///< PLL out-of-lock interrupt flag
        constexpr uint32_t PLLLOSIFG = (1U << 13);  ///< PLL loss-of-signal interrupt flag
        constexpr uint32_t PLLOORIFG = (1U << 14);  ///< PLL out-of-range interrupt flag
        constexpr uint32_t CALIFG = (1U << 15);  ///< REFCNT period counter expired
    }

    /// CSCLRIFG Register bits
    namespace csclrifg_bits {
        constexpr uint32_t CLR_LFXTIFG = (1U << 0);  ///< Clear LFXT oscillator fault interrupt flag
        constexpr uint32_t CLR_HFXTIFG = (1U << 1);  ///< Clear HFXT oscillator fault interrupt flag
        constexpr uint32_t CLR_HFXT2IFG = (1U << 2);  ///< Clear HFXT2 oscillator fault interrupt flag
        constexpr uint32_t CLR_DCOR_OPNIFG = (1U << 6);  ///< Clear DCO external resistor open circuit fault interrupt flag.
        constexpr uint32_t CLR_CALIFG = (1U << 15);  ///< REFCNT period counter clear interrupt flag
        constexpr uint32_t CLR_FCNTLFIFG = (1U << 8);  ///< Start fault counter clear interrupt flag LFXT
        constexpr uint32_t CLR_FCNTHFIFG = (1U << 9);  ///< Start fault counter clear interrupt flag HFXT
        constexpr uint32_t CLR_FCNTHF2IFG = (1U << 10);  ///< Start fault counter clear interrupt flag HFXT2
        constexpr uint32_t CLR_PLLOOLIFG = (1U << 12);  ///< PLL out-of-lock clear interrupt flag
        constexpr uint32_t CLR_PLLLOSIFG = (1U << 13);  ///< PLL loss-of-signal clear interrupt flag
        constexpr uint32_t CLR_PLLOORIFG = (1U << 14);  ///< PLL out-of-range clear interrupt flag
    }

    /// CSSETIFG Register bits
    namespace cssetifg_bits {
        constexpr uint32_t SET_LFXTIFG = (1U << 0);  ///< Set LFXT oscillator fault interrupt flag
        constexpr uint32_t SET_HFXTIFG = (1U << 1);  ///< Set HFXT oscillator fault interrupt flag
        constexpr uint32_t SET_HFXT2IFG = (1U << 2);  ///< Set HFXT2 oscillator fault interrupt flag
        constexpr uint32_t SET_DCOR_OPNIFG = (1U << 6);  ///< Set DCO external resistor open circuit fault interrupt flag.
        constexpr uint32_t SET_CALIFG = (1U << 15);  ///< REFCNT period counter set interrupt flag
        constexpr uint32_t SET_FCNTHFIFG = (1U << 9);  ///< Start fault counter set interrupt flag HFXT
        constexpr uint32_t SET_FCNTHF2IFG = (1U << 10);  ///< Start fault counter set interrupt flag HFXT2
        constexpr uint32_t SET_FCNTLFIFG = (1U << 8);  ///< Start fault counter set interrupt flag LFXT
        constexpr uint32_t SET_PLLOOLIFG = (1U << 12);  ///< PLL out-of-lock set interrupt flag
        constexpr uint32_t SET_PLLLOSIFG = (1U << 13);  ///< PLL loss-of-signal set interrupt flag
        constexpr uint32_t SET_PLLOORIFG = (1U << 14);  ///< PLL out-of-range set interrupt flag
    }

    /// CSDCOERCAL0 Register bits
    namespace csdcoercal0_bits {
        constexpr uint32_t DCO_TCCAL = (2 << 0);  ///< DCO Temperature compensation calibration
        constexpr uint32_t DCO_FCAL_RSEL04 = (10 << 16);  ///< DCO frequency calibration for DCO frequency range (DCORSEL) 0 to 4.
    }

    /// CSDCOERCAL1 Register bits
    namespace csdcoercal1_bits {
        constexpr uint32_t DCO_FCAL_RSEL5 = (10 << 0);  ///< DCO frequency calibration for DCO frequency range (DCORSEL) 5.
    }

}

// ============================================================================
// PSS Peripheral
// ============================================================================

namespace pss {
    /// Base addresses
    constexpr uint32_t PSS_BASE = 0x40010800;

    /// PSS Register structure
    struct Registers {
        volatile uint32_t PSSKEY;  ///< Offset: 0x00 - Key Register
        volatile uint32_t PSSCTL0;  ///< Offset: 0x04 - Control 0 Register
        volatile uint32_t PSSIE;  ///< Offset: 0x34 - Interrupt Enable Register
        volatile uint32_t PSSIFG;  ///< Offset: 0x38 - Interrupt Flag Register
        volatile uint32_t PSSCLRIFG;  ///< Offset: 0x3C - Clear Interrupt Flag Register
    };

    /// Peripheral instances
    inline Registers* PSS = reinterpret_cast<Registers*>(PSS_BASE);

    // Bit definitions
    /// PSSKEY Register bits
    namespace psskey_bits {
        constexpr uint32_t PSSKEY = (16 << 0);  ///< PSS control key
    }

    /// PSSCTL0 Register bits
    namespace pssctl0_bits {
        constexpr uint32_t SVSMHOFF = (1U << 0);  ///< SVSM high-side off
        constexpr uint32_t SVSMHLP = (1U << 1);  ///< SVSM high-side low power normal performance mode
        constexpr uint32_t SVSMHS = (1U << 2);  ///< Supply supervisor or monitor selection for the high-side
        constexpr uint32_t SVSMHTH = (3 << 3);  ///< SVSM high-side reset voltage level
        constexpr uint32_t SVMHOE = (1U << 6);  ///< SVSM high-side output enable
        constexpr uint32_t SVMHOUTPOLAL = (1U << 7);  ///< SVMHOUT pin polarity active low
        constexpr uint32_t DCDC_FORCE = (1U << 10);  ///< Force DC-DC regulator operation
        constexpr uint32_t VCORETRAN = (2 << 12);  ///< Controls core voltage level transition time
    }

    /// PSSIE Register bits
    namespace pssie_bits {
        constexpr uint32_t SVSMHIE = (1U << 1);  ///< High-side SVSM interrupt enable
    }

    /// PSSIFG Register bits
    namespace pssifg_bits {
        constexpr uint32_t SVSMHIFG = (1U << 1);  ///< High-side SVSM interrupt flag
    }

    /// PSSCLRIFG Register bits
    namespace pssclrifg_bits {
        constexpr uint32_t CLRSVSMHIFG = (1U << 1);  ///< SVSMH clear interrupt flag
    }

}

// ============================================================================
// FLCTL Peripheral
// ============================================================================

namespace flctl {
    /// Base addresses
    constexpr uint32_t FLCTL_A_BASE = 0x40011000;

    /// FLCTL Register structure
    struct Registers {
        volatile uint32_t FLCTL_POWER_STAT;  ///< Offset: 0x00 - Power Status Register
        volatile uint32_t FLCTL_BANK0_RDCTL;  ///< Offset: 0x10 - Bank0 Read Control Register
        volatile uint32_t FLCTL_BANK1_RDCTL;  ///< Offset: 0x14 - Bank1 Read Control Register
        volatile uint32_t FLCTL_RDBRST_CTLSTAT;  ///< Offset: 0x20 - Read Burst/Compare Control and Status Register
        volatile uint32_t FLCTL_RDBRST_STARTADDR;  ///< Offset: 0x24 - Read Burst/Compare Start Address Register
        volatile uint32_t FLCTL_RDBRST_LEN;  ///< Offset: 0x28 - Read Burst/Compare Length Register
        volatile uint32_t FLCTL_RDBRST_FAILADDR;  ///< Offset: 0x3C - Read Burst/Compare Fail Address Register
        volatile uint32_t FLCTL_RDBRST_FAILCNT;  ///< Offset: 0x40 - Read Burst/Compare Fail Count Register
        volatile uint32_t FLCTL_PRG_CTLSTAT;  ///< Offset: 0x50 - Program Control and Status Register
        volatile uint32_t FLCTL_PRGBRST_CTLSTAT;  ///< Offset: 0x54 - Program Burst Control and Status Register
        volatile uint32_t FLCTL_PRGBRST_STARTADDR;  ///< Offset: 0x58 - Program Burst Start Address Register
        volatile uint32_t FLCTL_PRGBRST_DATA0_0;  ///< Offset: 0x60 - Program Burst Data0 Register0
        volatile uint32_t FLCTL_PRGBRST_DATA0_1;  ///< Offset: 0x64 - Program Burst Data0 Register1
        volatile uint32_t FLCTL_PRGBRST_DATA0_2;  ///< Offset: 0x68 - Program Burst Data0 Register2
        volatile uint32_t FLCTL_PRGBRST_DATA0_3;  ///< Offset: 0x6C - Program Burst Data0 Register3
        volatile uint32_t FLCTL_PRGBRST_DATA1_0;  ///< Offset: 0x70 - Program Burst Data1 Register0
        volatile uint32_t FLCTL_PRGBRST_DATA1_1;  ///< Offset: 0x74 - Program Burst Data1 Register1
        volatile uint32_t FLCTL_PRGBRST_DATA1_2;  ///< Offset: 0x78 - Program Burst Data1 Register2
        volatile uint32_t FLCTL_PRGBRST_DATA1_3;  ///< Offset: 0x7C - Program Burst Data1 Register3
        volatile uint32_t FLCTL_PRGBRST_DATA2_0;  ///< Offset: 0x80 - Program Burst Data2 Register0
        volatile uint32_t FLCTL_PRGBRST_DATA2_1;  ///< Offset: 0x84 - Program Burst Data2 Register1
        volatile uint32_t FLCTL_PRGBRST_DATA2_2;  ///< Offset: 0x88 - Program Burst Data2 Register2
        volatile uint32_t FLCTL_PRGBRST_DATA2_3;  ///< Offset: 0x8C - Program Burst Data2 Register3
        volatile uint32_t FLCTL_PRGBRST_DATA3_0;  ///< Offset: 0x90 - Program Burst Data3 Register0
        volatile uint32_t FLCTL_PRGBRST_DATA3_1;  ///< Offset: 0x94 - Program Burst Data3 Register1
        volatile uint32_t FLCTL_PRGBRST_DATA3_2;  ///< Offset: 0x98 - Program Burst Data3 Register2
        volatile uint32_t FLCTL_PRGBRST_DATA3_3;  ///< Offset: 0x9C - Program Burst Data3 Register3
        volatile uint32_t FLCTL_ERASE_CTLSTAT;  ///< Offset: 0xA0 - Erase Control and Status Register
        volatile uint32_t FLCTL_ERASE_SECTADDR;  ///< Offset: 0xA4 - Erase Sector Address Register
        volatile uint32_t FLCTL_BANK0_INFO_WEPROT;  ///< Offset: 0xB0 - Information Memory Bank0 Write/Erase Protection Register
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT;  ///< Offset: 0xB4 - Main Memory Bank0 Write/Erase Protection Register
        volatile uint32_t FLCTL_BANK1_INFO_WEPROT;  ///< Offset: 0xC0 - Information Memory Bank1 Write/Erase Protection Register
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT;  ///< Offset: 0xC4 - Main Memory Bank1 Write/Erase Protection Register
        volatile uint32_t FLCTL_BMRK_CTLSTAT;  ///< Offset: 0xD0 - Benchmark Control and Status Register
        volatile uint32_t FLCTL_BMRK_IFETCH;  ///< Offset: 0xD4 - Benchmark Instruction Fetch Count Register
        volatile uint32_t FLCTL_BMRK_DREAD;  ///< Offset: 0xD8 - Benchmark Data Read Count Register
        volatile uint32_t FLCTL_BMRK_CMP;  ///< Offset: 0xDC - Benchmark Count Compare Register
        volatile uint32_t FLCTL_IFG;  ///< Offset: 0xF0 - Interrupt Flag Register
        volatile uint32_t FLCTL_IE;  ///< Offset: 0xF4 - Interrupt Enable Register
        volatile uint32_t FLCTL_CLRIFG;  ///< Offset: 0xF8 - Clear Interrupt Flag Register
        volatile uint32_t FLCTL_SETIFG;  ///< Offset: 0xFC - Set Interrupt Flag Register
        volatile uint32_t FLCTL_READ_TIMCTL;  ///< Offset: 0x100 - Read Timing Control Register
        volatile uint32_t FLCTL_READMARGIN_TIMCTL;  ///< Offset: 0x104 - Read Margin Timing Control Register
        volatile uint32_t FLCTL_PRGVER_TIMCTL;  ///< Offset: 0x108 - Program Verify Timing Control Register
        volatile uint32_t FLCTL_ERSVER_TIMCTL;  ///< Offset: 0x10C - Erase Verify Timing Control Register
        volatile uint32_t FLCTL_LKGVER_TIMCTL;  ///< Offset: 0x110 - Leakage Verify Timing Control Register
        volatile uint32_t FLCTL_PROGRAM_TIMCTL;  ///< Offset: 0x114 - Program Timing Control Register
        volatile uint32_t FLCTL_ERASE_TIMCTL;  ///< Offset: 0x118 - Erase Timing Control Register
        volatile uint32_t FLCTL_MASSERASE_TIMCTL;  ///< Offset: 0x11C - Mass Erase Timing Control Register
        volatile uint32_t FLCTL_BURSTPRG_TIMCTL;  ///< Offset: 0x120 - Burst Program Timing Control Register
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT0;  ///< Offset: 0x200 - Main Memory Bank0 Write/Erase Protection Register 0
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT1;  ///< Offset: 0x204 - Main Memory Bank0 Write/Erase Protection Register 1
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT2;  ///< Offset: 0x208 - Main Memory Bank0 Write/Erase Protection Register 2
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT3;  ///< Offset: 0x20C - Main Memory Bank0 Write/Erase Protection Register 3
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT4;  ///< Offset: 0x210 - Main Memory Bank0 Write/Erase Protection Register 4
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT5;  ///< Offset: 0x214 - Main Memory Bank0 Write/Erase Protection Register 5
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT6;  ///< Offset: 0x218 - Main Memory Bank0 Write/Erase Protection Register 6
        volatile uint32_t FLCTL_BANK0_MAIN_WEPROT7;  ///< Offset: 0x21C - Main Memory Bank0 Write/Erase Protection Register 7
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT0;  ///< Offset: 0x240 - Main Memory Bank1 Write/Erase Protection Register 0
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT1;  ///< Offset: 0x244 - Main Memory Bank1 Write/Erase Protection Register 1
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT2;  ///< Offset: 0x248 - Main Memory Bank1 Write/Erase Protection Register 2
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT3;  ///< Offset: 0x24C - Main Memory Bank1 Write/Erase Protection Register 3
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT4;  ///< Offset: 0x250 - Main Memory Bank1 Write/Erase Protection Register 4
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT5;  ///< Offset: 0x254 - Main Memory Bank1 Write/Erase Protection Register 5
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT6;  ///< Offset: 0x258 - Main Memory Bank1 Write/Erase Protection Register 6
        volatile uint32_t FLCTL_BANK1_MAIN_WEPROT7;  ///< Offset: 0x25C - Main Memory Bank1 Write/Erase Protection Register 7
    };

    /// Peripheral instances
    inline Registers* FLCTL_A = reinterpret_cast<Registers*>(FLCTL_A_BASE);

    // Bit definitions
    /// FLCTL_POWER_STAT Register bits
    namespace flctl_power_stat_bits {
        constexpr uint32_t PSTAT = (3 << 0);  ///< Flash power status
        constexpr uint32_t LDOSTAT = (1U << 3);  ///< PSS FLDO GOOD status
        constexpr uint32_t VREFSTAT = (1U << 4);  ///< PSS VREF stable status
        constexpr uint32_t IREFSTAT = (1U << 5);  ///< PSS IREF stable status
        constexpr uint32_t TRIMSTAT = (1U << 6);  ///< PSS trim done status
        constexpr uint32_t RD_2T = (1U << 7);  ///< Indicates if Flash is being accessed in 2T mode
    }

    /// FLCTL_BANK0_RDCTL Register bits
    namespace flctl_bank0_rdctl_bits {
        constexpr uint32_t RD_MODE = (4 << 0);  ///< Flash read mode control setting for Bank 0
        constexpr uint32_t BUFI = (1U << 4);  ///< Enables read buffering feature for instruction fetches to this Bank
        constexpr uint32_t BUFD = (1U << 5);  ///< Enables read buffering feature for data reads to this Bank
        constexpr uint32_t WAIT = (4 << 12);  ///< Number of wait states for read
        constexpr uint32_t RD_MODE_STATUS = (4 << 16);  ///< Read mode
    }

    /// FLCTL_BANK1_RDCTL Register bits
    namespace flctl_bank1_rdctl_bits {
        constexpr uint32_t RD_MODE = (4 << 0);  ///< Flash read mode control setting for Bank 0
        constexpr uint32_t BUFI = (1U << 4);  ///< Enables read buffering feature for instruction fetches to this Bank
        constexpr uint32_t BUFD = (1U << 5);  ///< Enables read buffering feature for data reads to this Bank
        constexpr uint32_t RD_MODE_STATUS = (4 << 16);  ///< Read mode
        constexpr uint32_t WAIT = (4 << 12);  ///< Number of wait states for read
    }

    /// FLCTL_RDBRST_CTLSTAT Register bits
    namespace flctl_rdbrst_ctlstat_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start of burst/compare operation
        constexpr uint32_t MEM_TYPE = (2 << 1);  ///< Type of memory that burst is carried out on
        constexpr uint32_t STOP_FAIL = (1U << 3);  ///< Terminate burst/compare operation
        constexpr uint32_t DATA_CMP = (1U << 4);  ///< Data pattern used for comparison against memory read data
        constexpr uint32_t TEST_EN = (1U << 6);  ///< Enable comparison against test data compare registers
        constexpr uint32_t BRST_STAT = (2 << 16);  ///< Status of Burst/Compare operation
        constexpr uint32_t CMP_ERR = (1U << 18);  ///< Burst/Compare Operation encountered atleast one data
        constexpr uint32_t ADDR_ERR = (1U << 19);  ///< Burst/Compare Operation was terminated due to access to
        constexpr uint32_t CLR_STAT = (1U << 23);  ///< Clear status bits 19-16 of this register
    }

    /// FLCTL_RDBRST_STARTADDR Register bits
    namespace flctl_rdbrst_startaddr_bits {
        constexpr uint32_t START_ADDRESS = (21 << 0);  ///< Start Address of Burst Operation
    }

    /// FLCTL_RDBRST_LEN Register bits
    namespace flctl_rdbrst_len_bits {
        constexpr uint32_t BURST_LENGTH = (21 << 0);  ///< Length of Burst Operation
    }

    /// FLCTL_RDBRST_FAILADDR Register bits
    namespace flctl_rdbrst_failaddr_bits {
        constexpr uint32_t FAIL_ADDRESS = (21 << 0);  ///< Reflects address of last failed compare
    }

    /// FLCTL_RDBRST_FAILCNT Register bits
    namespace flctl_rdbrst_failcnt_bits {
        constexpr uint32_t FAIL_COUNT = (17 << 0);  ///< Number of failures encountered in burst operation
    }

    /// FLCTL_PRG_CTLSTAT Register bits
    namespace flctl_prg_ctlstat_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Master control for all word program operations
        constexpr uint32_t MODE = (1U << 1);  ///< Write mode
        constexpr uint32_t VER_PRE = (1U << 2);  ///< Controls automatic pre program verify operations
        constexpr uint32_t VER_PST = (1U << 3);  ///< Controls automatic post program verify operations
        constexpr uint32_t STATUS = (2 << 16);  ///< Status of program operations in the Flash memory
        constexpr uint32_t BNK_ACT = (1U << 18);  ///< Bank active
    }

    /// FLCTL_PRGBRST_CTLSTAT Register bits
    namespace flctl_prgbrst_ctlstat_bits {
        constexpr uint32_t START = (1U << 0);  ///< Trigger start of burst program operation
        constexpr uint32_t TYPE = (2 << 1);  ///< Type of memory that burst program is carried out on
        constexpr uint32_t LEN = (3 << 3);  ///< Length of burst
        constexpr uint32_t AUTO_PRE = (1U << 6);  ///< Auto-Verify operation before the Burst Program
        constexpr uint32_t AUTO_PST = (1U << 7);  ///< Auto-Verify operation after the Burst Program
        constexpr uint32_t BURST_STATUS = (3 << 16);  ///< Status of a Burst Operation
        constexpr uint32_t PRE_ERR = (1U << 19);  ///< Burst Operation encountered preprogram auto-verify errors
        constexpr uint32_t PST_ERR = (1U << 20);  ///< Burst Operation encountered postprogram auto-verify errors
        constexpr uint32_t ADDR_ERR = (1U << 21);  ///< Burst Operation was terminated due to attempted program of reserved memory
        constexpr uint32_t CLR_STAT = (1U << 23);  ///< Clear status bits 21-16 of this register
    }

    /// FLCTL_PRGBRST_STARTADDR Register bits
    namespace flctl_prgbrst_startaddr_bits {
        constexpr uint32_t START_ADDRESS = (22 << 0);  ///< Start Address of Program Burst Operation
    }

    /// FLCTL_PRGBRST_DATA0_0 Register bits
    namespace flctl_prgbrst_data0_0_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 0
    }

    /// FLCTL_PRGBRST_DATA0_1 Register bits
    namespace flctl_prgbrst_data0_1_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 0
    }

    /// FLCTL_PRGBRST_DATA0_2 Register bits
    namespace flctl_prgbrst_data0_2_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 0
    }

    /// FLCTL_PRGBRST_DATA0_3 Register bits
    namespace flctl_prgbrst_data0_3_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 0
    }

    /// FLCTL_PRGBRST_DATA1_0 Register bits
    namespace flctl_prgbrst_data1_0_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 1
    }

    /// FLCTL_PRGBRST_DATA1_1 Register bits
    namespace flctl_prgbrst_data1_1_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 1
    }

    /// FLCTL_PRGBRST_DATA1_2 Register bits
    namespace flctl_prgbrst_data1_2_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 1
    }

    /// FLCTL_PRGBRST_DATA1_3 Register bits
    namespace flctl_prgbrst_data1_3_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 1
    }

    /// FLCTL_PRGBRST_DATA2_0 Register bits
    namespace flctl_prgbrst_data2_0_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 2
    }

    /// FLCTL_PRGBRST_DATA2_1 Register bits
    namespace flctl_prgbrst_data2_1_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 2
    }

    /// FLCTL_PRGBRST_DATA2_2 Register bits
    namespace flctl_prgbrst_data2_2_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 2
    }

    /// FLCTL_PRGBRST_DATA2_3 Register bits
    namespace flctl_prgbrst_data2_3_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 2
    }

    /// FLCTL_PRGBRST_DATA3_0 Register bits
    namespace flctl_prgbrst_data3_0_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 3
    }

    /// FLCTL_PRGBRST_DATA3_1 Register bits
    namespace flctl_prgbrst_data3_1_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 3
    }

    /// FLCTL_PRGBRST_DATA3_2 Register bits
    namespace flctl_prgbrst_data3_2_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 3
    }

    /// FLCTL_PRGBRST_DATA3_3 Register bits
    namespace flctl_prgbrst_data3_3_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Program Burst 128 bit Data Word 3
    }

    /// FLCTL_ERASE_CTLSTAT Register bits
    namespace flctl_erase_ctlstat_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start of Erase operation
        constexpr uint32_t MODE = (1U << 1);  ///< Erase mode selected by application
        constexpr uint32_t TYPE = (2 << 2);  ///< Type of memory that erase operation is carried out on
        constexpr uint32_t STATUS = (2 << 16);  ///< Status of erase operations in the Flash memory
        constexpr uint32_t ADDR_ERR = (1U << 18);  ///< Erase Operation was terminated due to attempted erase of reserved memory address
        constexpr uint32_t CLR_STAT = (1U << 19);  ///< Clear status bits 18-16 of this register
    }

    /// FLCTL_ERASE_SECTADDR Register bits
    namespace flctl_erase_sectaddr_bits {
        constexpr uint32_t SECT_ADDRESS = (22 << 0);  ///< Address of Sector being Erased
    }

    /// FLCTL_BANK0_INFO_WEPROT Register bits
    namespace flctl_bank0_info_weprot_bits {
        constexpr uint32_t PROT0 = (1U << 0);  ///< Protects Sector 0 from program or erase
        constexpr uint32_t PROT1 = (1U << 1);  ///< Protects Sector 1 from program or erase
        constexpr uint32_t PROT2 = (1U << 2);  ///< Protects Sector 2 from program or erase
        constexpr uint32_t PROT3 = (1U << 3);  ///< Protects Sector 3 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT Register bits
    namespace flctl_bank0_main_weprot_bits {
        constexpr uint32_t PROT0 = (1U << 0);  ///< Protects Sector 0 from program or erase
        constexpr uint32_t PROT1 = (1U << 1);  ///< Protects Sector 1 from program or erase
        constexpr uint32_t PROT2 = (1U << 2);  ///< Protects Sector 2 from program or erase
        constexpr uint32_t PROT3 = (1U << 3);  ///< Protects Sector 3 from program or erase
        constexpr uint32_t PROT4 = (1U << 4);  ///< Protects Sector 4 from program or erase
        constexpr uint32_t PROT5 = (1U << 5);  ///< Protects Sector 5 from program or erase
        constexpr uint32_t PROT6 = (1U << 6);  ///< Protects Sector 6 from program or erase
        constexpr uint32_t PROT7 = (1U << 7);  ///< Protects Sector 7 from program or erase
        constexpr uint32_t PROT8 = (1U << 8);  ///< Protects Sector 8 from program or erase
        constexpr uint32_t PROT9 = (1U << 9);  ///< Protects Sector 9 from program or erase
        constexpr uint32_t PROT10 = (1U << 10);  ///< Protects Sector 10 from program or erase
        constexpr uint32_t PROT11 = (1U << 11);  ///< Protects Sector 11 from program or erase
        constexpr uint32_t PROT12 = (1U << 12);  ///< Protects Sector 12 from program or erase
        constexpr uint32_t PROT13 = (1U << 13);  ///< Protects Sector 13 from program or erase
        constexpr uint32_t PROT14 = (1U << 14);  ///< Protects Sector 14 from program or erase
        constexpr uint32_t PROT15 = (1U << 15);  ///< Protects Sector 15 from program or erase
        constexpr uint32_t PROT16 = (1U << 16);  ///< Protects Sector 16 from program or erase
        constexpr uint32_t PROT17 = (1U << 17);  ///< Protects Sector 17 from program or erase
        constexpr uint32_t PROT18 = (1U << 18);  ///< Protects Sector 18 from program or erase
        constexpr uint32_t PROT19 = (1U << 19);  ///< Protects Sector 19 from program or erase
        constexpr uint32_t PROT20 = (1U << 20);  ///< Protects Sector 20 from program or erase
        constexpr uint32_t PROT21 = (1U << 21);  ///< Protects Sector 21 from program or erase
        constexpr uint32_t PROT22 = (1U << 22);  ///< Protects Sector 22 from program or erase
        constexpr uint32_t PROT23 = (1U << 23);  ///< Protects Sector 23 from program or erase
        constexpr uint32_t PROT24 = (1U << 24);  ///< Protects Sector 24 from program or erase
        constexpr uint32_t PROT25 = (1U << 25);  ///< Protects Sector 25 from program or erase
        constexpr uint32_t PROT26 = (1U << 26);  ///< Protects Sector 26 from program or erase
        constexpr uint32_t PROT27 = (1U << 27);  ///< Protects Sector 27 from program or erase
        constexpr uint32_t PROT28 = (1U << 28);  ///< Protects Sector 28 from program or erase
        constexpr uint32_t PROT29 = (1U << 29);  ///< Protects Sector 29 from program or erase
        constexpr uint32_t PROT30 = (1U << 30);  ///< Protects Sector 30 from program or erase
        constexpr uint32_t PROT31 = (1U << 31);  ///< Protects Sector 31 from program or erase
    }

    /// FLCTL_BANK1_INFO_WEPROT Register bits
    namespace flctl_bank1_info_weprot_bits {
        constexpr uint32_t PROT0 = (1U << 0);  ///< Protects Sector 0 from program or erase operations
        constexpr uint32_t PROT1 = (1U << 1);  ///< Protects Sector 1 from program or erase operations
        constexpr uint32_t PROT2 = (1U << 2);  ///< Protects Sector 2 from program or erase
        constexpr uint32_t PROT3 = (1U << 3);  ///< Protects Sector 3 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT Register bits
    namespace flctl_bank1_main_weprot_bits {
        constexpr uint32_t PROT0 = (1U << 0);  ///< Protects Sector 0 from program or erase operations
        constexpr uint32_t PROT1 = (1U << 1);  ///< Protects Sector 1 from program or erase operations
        constexpr uint32_t PROT2 = (1U << 2);  ///< Protects Sector 2 from program or erase operations
        constexpr uint32_t PROT3 = (1U << 3);  ///< Protects Sector 3 from program or erase operations
        constexpr uint32_t PROT4 = (1U << 4);  ///< Protects Sector 4 from program or erase operations
        constexpr uint32_t PROT5 = (1U << 5);  ///< Protects Sector 5 from program or erase operations
        constexpr uint32_t PROT6 = (1U << 6);  ///< Protects Sector 6 from program or erase operations
        constexpr uint32_t PROT7 = (1U << 7);  ///< Protects Sector 7 from program or erase operations
        constexpr uint32_t PROT8 = (1U << 8);  ///< Protects Sector 8 from program or erase operations
        constexpr uint32_t PROT9 = (1U << 9);  ///< Protects Sector 9 from program or erase operations
        constexpr uint32_t PROT10 = (1U << 10);  ///< Protects Sector 10 from program or erase operations
        constexpr uint32_t PROT11 = (1U << 11);  ///< Protects Sector 11 from program or erase operations
        constexpr uint32_t PROT12 = (1U << 12);  ///< Protects Sector 12 from program or erase operations
        constexpr uint32_t PROT13 = (1U << 13);  ///< Protects Sector 13 from program or erase operations
        constexpr uint32_t PROT14 = (1U << 14);  ///< Protects Sector 14 from program or erase operations
        constexpr uint32_t PROT15 = (1U << 15);  ///< Protects Sector 15 from program or erase operations
        constexpr uint32_t PROT16 = (1U << 16);  ///< Protects Sector 16 from program or erase operations
        constexpr uint32_t PROT17 = (1U << 17);  ///< Protects Sector 17 from program or erase operations
        constexpr uint32_t PROT18 = (1U << 18);  ///< Protects Sector 18 from program or erase operations
        constexpr uint32_t PROT19 = (1U << 19);  ///< Protects Sector 19 from program or erase operations
        constexpr uint32_t PROT20 = (1U << 20);  ///< Protects Sector 20 from program or erase operations
        constexpr uint32_t PROT21 = (1U << 21);  ///< Protects Sector 21 from program or erase operations
        constexpr uint32_t PROT22 = (1U << 22);  ///< Protects Sector 22 from program or erase operations
        constexpr uint32_t PROT23 = (1U << 23);  ///< Protects Sector 23 from program or erase operations
        constexpr uint32_t PROT24 = (1U << 24);  ///< Protects Sector 24 from program or erase operations
        constexpr uint32_t PROT25 = (1U << 25);  ///< Protects Sector 25 from program or erase operations
        constexpr uint32_t PROT26 = (1U << 26);  ///< Protects Sector 26 from program or erase operations
        constexpr uint32_t PROT27 = (1U << 27);  ///< Protects Sector 27 from program or erase operations
        constexpr uint32_t PROT28 = (1U << 28);  ///< Protects Sector 28 from program or erase operations
        constexpr uint32_t PROT29 = (1U << 29);  ///< Protects Sector 29 from program or erase operations
        constexpr uint32_t PROT30 = (1U << 30);  ///< Protects Sector 30 from program or erase operations
        constexpr uint32_t PROT31 = (1U << 31);  ///< Protects Sector 31 from program or erase operations
    }

    /// FLCTL_BMRK_CTLSTAT Register bits
    namespace flctl_bmrk_ctlstat_bits {
        constexpr uint32_t I_BMRK = (1U << 0);  ///< When 1, increments the Instruction Benchmark count register on each instruction fetch to the Flash
        constexpr uint32_t D_BMRK = (1U << 1);  ///< When 1, increments the Data Benchmark count register on each data read access to the Flash
        constexpr uint32_t CMP_EN = (1U << 2);  ///< When 1, enables comparison of the Instruction or Data Benchmark Registers against the threshold value
        constexpr uint32_t CMP_SEL = (1U << 3);  ///< Selects which benchmark register should be compared against the threshold
    }

    /// FLCTL_BMRK_IFETCH Register bits
    namespace flctl_bmrk_ifetch_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Reflects the number of Instruction Fetches to the Flash (increments by one on each fetch)
    }

    /// FLCTL_BMRK_DREAD Register bits
    namespace flctl_bmrk_dread_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Reflects the number of Data Read operations to the Flash (increments by one on each read)
    }

    /// FLCTL_BMRK_CMP Register bits
    namespace flctl_bmrk_cmp_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< Reflects the threshold value that is compared against either the IFETCH or DREAD Benchmark Counters
    }

    /// FLCTL_IFG Register bits
    namespace flctl_ifg_bits {
        constexpr uint32_t RDBRST = (1U << 0);  ///< If set to 1, indicates that the Read Burst/Compare operation is complete
        constexpr uint32_t AVPRE = (1U << 1);  ///< If set to 1, indicates that the pre-program verify operation has detected an error
        constexpr uint32_t AVPST = (1U << 2);  ///< If set to 1, indicates that the post-program verify operation has failed comparison
        constexpr uint32_t PRG = (1U << 3);  ///< If set to 1, indicates that a word Program operation is complete
        constexpr uint32_t PRGB = (1U << 4);  ///< If set to 1, indicates that the configured Burst Program operation is complete
        constexpr uint32_t ERASE = (1U << 5);  ///< If set to 1, indicates that the Erase operation is complete
        constexpr uint32_t BMRK = (1U << 8);  ///< If set to 1, indicates that a Benchmark Compare match occurred
        constexpr uint32_t PRG_ERR = (1U << 9);  ///< If set to 1, indicates a word composition error in full word write mode (possible data loss due to writes crossing over to a new 128bit boundary before full word has been composed)
    }

    /// FLCTL_IE Register bits
    namespace flctl_ie_bits {
        constexpr uint32_t RDBRST = (1U << 0);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t AVPRE = (1U << 1);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t AVPST = (1U << 2);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t PRG = (1U << 3);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t PRGB = (1U << 4);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t ERASE = (1U << 5);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t BMRK = (1U << 8);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
        constexpr uint32_t PRG_ERR = (1U << 9);  ///< If set to 1, enables the Controller to generate an interrupt based on the corresponding bit in the FLCTL_IFG
    }

    /// FLCTL_CLRIFG Register bits
    namespace flctl_clrifg_bits {
        constexpr uint32_t RDBRST = (1U << 0);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t AVPRE = (1U << 1);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t AVPST = (1U << 2);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t PRG = (1U << 3);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t PRGB = (1U << 4);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t ERASE = (1U << 5);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t BMRK = (1U << 8);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t PRG_ERR = (1U << 9);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
    }

    /// FLCTL_SETIFG Register bits
    namespace flctl_setifg_bits {
        constexpr uint32_t RDBRST = (1U << 0);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t AVPRE = (1U << 1);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t AVPST = (1U << 2);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t PRG = (1U << 3);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t PRGB = (1U << 4);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t ERASE = (1U << 5);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t BMRK = (1U << 8);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
        constexpr uint32_t PRG_ERR = (1U << 9);  ///< Write 1 clears the corresponding interrupt flag bit in the FLCTL_IFG
    }

    /// FLCTL_READ_TIMCTL Register bits
    namespace flctl_read_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Configures the length of the Setup phase for this operation
        constexpr uint32_t IREF_BOOST1 = (4 << 12);  ///< Length of the IREF_BOOST1 signal of the IP
        constexpr uint32_t SETUP_LONG = (8 << 16);  ///< Length of the Setup time into read mode when the device is recovering from one of the following conditions: Moving from Power-down or Standby back to Active and device is not trimmed. Moving from standby to active state in low-frequency active mode. Recovering from the LDO Boost operation after a Mass Erase.
    }

    /// FLCTL_READMARGIN_TIMCTL Register bits
    namespace flctl_readmargin_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Length of the Setup phase for this operation
    }

    /// FLCTL_PRGVER_TIMCTL Register bits
    namespace flctl_prgver_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Length of the Setup phase for this operation
        constexpr uint32_t ACTIVE = (4 << 8);  ///< Length of the Active phase for this operation
        constexpr uint32_t HOLD = (4 << 12);  ///< Length of the Hold phase for this operation
    }

    /// FLCTL_ERSVER_TIMCTL Register bits
    namespace flctl_ersver_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Length of the Setup phase for this operation
    }

    /// FLCTL_LKGVER_TIMCTL Register bits
    namespace flctl_lkgver_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Length of the Setup phase for this operation
    }

    /// FLCTL_PROGRAM_TIMCTL Register bits
    namespace flctl_program_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Length of the Setup phase for this operation
        constexpr uint32_t ACTIVE = (20 << 8);  ///< Length of the Active phase for this operation
        constexpr uint32_t HOLD = (4 << 28);  ///< Length of the Hold phase for this operation
    }

    /// FLCTL_ERASE_TIMCTL Register bits
    namespace flctl_erase_timctl_bits {
        constexpr uint32_t SETUP = (8 << 0);  ///< Length of the Setup phase for this operation
        constexpr uint32_t ACTIVE = (20 << 8);  ///< Length of the Active phase for this operation
        constexpr uint32_t HOLD = (4 << 28);  ///< Length of the Hold phase for this operation
    }

    /// FLCTL_MASSERASE_TIMCTL Register bits
    namespace flctl_masserase_timctl_bits {
        constexpr uint32_t BOOST_ACTIVE = (8 << 0);  ///< Length of the time for which LDO Boost Signal is kept active
        constexpr uint32_t BOOST_HOLD = (8 << 8);  ///< Length for which Flash deactivates the LDO Boost signal before processing any new commands
    }

    /// FLCTL_BURSTPRG_TIMCTL Register bits
    namespace flctl_burstprg_timctl_bits {
        constexpr uint32_t ACTIVE = (20 << 8);  ///< Length of the Active phase for this operation
    }

    /// FLCTL_BANK0_MAIN_WEPROT0 Register bits
    namespace flctl_bank0_main_weprot0_bits {
        constexpr uint32_t PROT0 = (1U << 0);  ///< Protects Sector 0 from program or erase
        constexpr uint32_t PROT1 = (1U << 1);  ///< Protects Sector 1 from program or erase
        constexpr uint32_t PROT2 = (1U << 2);  ///< Protects Sector 2 from program or erase
        constexpr uint32_t PROT3 = (1U << 3);  ///< Protects Sector 3 from program or erase
        constexpr uint32_t PROT4 = (1U << 4);  ///< Protects Sector 4 from program or erase
        constexpr uint32_t PROT5 = (1U << 5);  ///< Protects Sector 5 from program or erase
        constexpr uint32_t PROT6 = (1U << 6);  ///< Protects Sector 6 from program or erase
        constexpr uint32_t PROT7 = (1U << 7);  ///< Protects Sector 7 from program or erase
        constexpr uint32_t PROT8 = (1U << 8);  ///< Protects Sector 8 from program or erase
        constexpr uint32_t PROT9 = (1U << 9);  ///< Protects Sector 9 from program or erase
        constexpr uint32_t PROT10 = (1U << 10);  ///< Protects Sector 10 from program or erase
        constexpr uint32_t PROT11 = (1U << 11);  ///< Protects Sector 11 from program or erase
        constexpr uint32_t PROT12 = (1U << 12);  ///< Protects Sector 12 from program or erase
        constexpr uint32_t PROT13 = (1U << 13);  ///< Protects Sector 13 from program or erase
        constexpr uint32_t PROT14 = (1U << 14);  ///< Protects Sector 14 from program or erase
        constexpr uint32_t PROT15 = (1U << 15);  ///< Protects Sector 15 from program or erase
        constexpr uint32_t PROT16 = (1U << 16);  ///< Protects Sector 16 from program or erase
        constexpr uint32_t PROT17 = (1U << 17);  ///< Protects Sector 17 from program or erase
        constexpr uint32_t PROT18 = (1U << 18);  ///< Protects Sector 18 from program or erase
        constexpr uint32_t PROT19 = (1U << 19);  ///< Protects Sector 19 from program or erase
        constexpr uint32_t PROT20 = (1U << 20);  ///< Protects Sector 20 from program or erase
        constexpr uint32_t PROT21 = (1U << 21);  ///< Protects Sector 21 from program or erase
        constexpr uint32_t PROT22 = (1U << 22);  ///< Protects Sector 22 from program or erase
        constexpr uint32_t PROT23 = (1U << 23);  ///< Protects Sector 23 from program or erase
        constexpr uint32_t PROT24 = (1U << 24);  ///< Protects Sector 24 from program or erase
        constexpr uint32_t PROT25 = (1U << 25);  ///< Protects Sector 25 from program or erase
        constexpr uint32_t PROT26 = (1U << 26);  ///< Protects Sector 26 from program or erase
        constexpr uint32_t PROT27 = (1U << 27);  ///< Protects Sector 27 from program or erase
        constexpr uint32_t PROT28 = (1U << 28);  ///< Protects Sector 28 from program or erase
        constexpr uint32_t PROT29 = (1U << 29);  ///< Protects Sector 29 from program or erase
        constexpr uint32_t PROT30 = (1U << 30);  ///< Protects Sector 30 from program or erase
        constexpr uint32_t PROT31 = (1U << 31);  ///< Protects Sector 31 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT1 Register bits
    namespace flctl_bank0_main_weprot1_bits {
        constexpr uint32_t PROT32 = (1U << 0);  ///< Protects Sector 32 from program or erase
        constexpr uint32_t PROT33 = (1U << 1);  ///< Protects Sector 33 from program or erase
        constexpr uint32_t PROT34 = (1U << 2);  ///< Protects Sector 34 from program or erase
        constexpr uint32_t PROT35 = (1U << 3);  ///< Protects Sector 35 from program or erase
        constexpr uint32_t PROT36 = (1U << 4);  ///< Protects Sector 36 from program or erase
        constexpr uint32_t PROT37 = (1U << 5);  ///< Protects Sector 37 from program or erase
        constexpr uint32_t PROT38 = (1U << 6);  ///< Protects Sector 38 from program or erase
        constexpr uint32_t PROT39 = (1U << 7);  ///< Protects Sector 39 from program or erase
        constexpr uint32_t PROT40 = (1U << 8);  ///< Protects Sector 40 from program or erase
        constexpr uint32_t PROT41 = (1U << 9);  ///< Protects Sector 41 from program or erase
        constexpr uint32_t PROT42 = (1U << 10);  ///< Protects Sector 42 from program or erase
        constexpr uint32_t PROT43 = (1U << 11);  ///< Protects Sector 43 from program or erase
        constexpr uint32_t PROT44 = (1U << 12);  ///< Protects Sector 44 from program or erase
        constexpr uint32_t PROT45 = (1U << 13);  ///< Protects Sector 45 from program or erase
        constexpr uint32_t PROT46 = (1U << 14);  ///< Protects Sector 46 from program or erase
        constexpr uint32_t PROT47 = (1U << 15);  ///< Protects Sector 47 from program or erase
        constexpr uint32_t PROT48 = (1U << 16);  ///< Protects Sector 48 from program or erase
        constexpr uint32_t PROT49 = (1U << 17);  ///< Protects Sector 49 from program or erase
        constexpr uint32_t PROT50 = (1U << 18);  ///< Protects Sector 50 from program or erase
        constexpr uint32_t PROT51 = (1U << 19);  ///< Protects Sector 51 from program or erase
        constexpr uint32_t PROT52 = (1U << 20);  ///< Protects Sector 52 from program or erase
        constexpr uint32_t PROT53 = (1U << 21);  ///< Protects Sector 53 from program or erase
        constexpr uint32_t PROT54 = (1U << 22);  ///< Protects Sector 54 from program or erase
        constexpr uint32_t PROT55 = (1U << 23);  ///< Protects Sector 55 from program or erase
        constexpr uint32_t PROT56 = (1U << 24);  ///< Protects Sector 56 from program or erase
        constexpr uint32_t PROT57 = (1U << 25);  ///< Protects Sector 57 from program or erase
        constexpr uint32_t PROT58 = (1U << 26);  ///< Protects Sector 58 from program or erase
        constexpr uint32_t PROT59 = (1U << 27);  ///< Protects Sector 59 from program or erase
        constexpr uint32_t PROT60 = (1U << 28);  ///< Protects Sector 60 from program or erase
        constexpr uint32_t PROT61 = (1U << 29);  ///< Protects Sector 61 from program or erase
        constexpr uint32_t PROT62 = (1U << 30);  ///< Protects Sector 62 from program or erase
        constexpr uint32_t PROT63 = (1U << 31);  ///< Protects Sector 63 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT2 Register bits
    namespace flctl_bank0_main_weprot2_bits {
        constexpr uint32_t PROT64 = (1U << 0);  ///< Protects Sector 64 from program or erase
        constexpr uint32_t PROT65 = (1U << 1);  ///< Protects Sector 65 from program or erase
        constexpr uint32_t PROT66 = (1U << 2);  ///< Protects Sector 66 from program or erase
        constexpr uint32_t PROT67 = (1U << 3);  ///< Protects Sector 67 from program or erase
        constexpr uint32_t PROT68 = (1U << 4);  ///< Protects Sector 68 from program or erase
        constexpr uint32_t PROT69 = (1U << 5);  ///< Protects Sector 69 from program or erase
        constexpr uint32_t PROT70 = (1U << 6);  ///< Protects Sector 70 from program or erase
        constexpr uint32_t PROT71 = (1U << 7);  ///< Protects Sector 71 from program or erase
        constexpr uint32_t PROT72 = (1U << 8);  ///< Protects Sector 72 from program or erase
        constexpr uint32_t PROT73 = (1U << 9);  ///< Protects Sector 73 from program or erase
        constexpr uint32_t PROT74 = (1U << 10);  ///< Protects Sector 74 from program or erase
        constexpr uint32_t PROT75 = (1U << 11);  ///< Protects Sector 75 from program or erase
        constexpr uint32_t PROT76 = (1U << 12);  ///< Protects Sector 76 from program or erase
        constexpr uint32_t PROT77 = (1U << 13);  ///< Protects Sector 77 from program or erase
        constexpr uint32_t PROT78 = (1U << 14);  ///< Protects Sector 78 from program or erase
        constexpr uint32_t PROT79 = (1U << 15);  ///< Protects Sector 79 from program or erase
        constexpr uint32_t PROT80 = (1U << 16);  ///< Protects Sector 80 from program or erase
        constexpr uint32_t PROT81 = (1U << 17);  ///< Protects Sector 81 from program or erase
        constexpr uint32_t PROT82 = (1U << 18);  ///< Protects Sector 82 from program or erase
        constexpr uint32_t PROT83 = (1U << 19);  ///< Protects Sector 83 from program or erase
        constexpr uint32_t PROT84 = (1U << 20);  ///< Protects Sector 84 from program or erase
        constexpr uint32_t PROT85 = (1U << 21);  ///< Protects Sector 85 from program or erase
        constexpr uint32_t PROT86 = (1U << 22);  ///< Protects Sector 86 from program or erase
        constexpr uint32_t PROT87 = (1U << 23);  ///< Protects Sector 87 from program or erase
        constexpr uint32_t PROT88 = (1U << 24);  ///< Protects Sector 88 from program or erase
        constexpr uint32_t PROT89 = (1U << 25);  ///< Protects Sector 89 from program or erase
        constexpr uint32_t PROT90 = (1U << 26);  ///< Protects Sector 90 from program or erase
        constexpr uint32_t PROT91 = (1U << 27);  ///< Protects Sector 91 from program or erase
        constexpr uint32_t PROT92 = (1U << 28);  ///< Protects Sector 92 from program or erase
        constexpr uint32_t PROT93 = (1U << 29);  ///< Protects Sector 93 from program or erase
        constexpr uint32_t PROT94 = (1U << 30);  ///< Protects Sector 94 from program or erase
        constexpr uint32_t PROT95 = (1U << 31);  ///< Protects Sector 95 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT3 Register bits
    namespace flctl_bank0_main_weprot3_bits {
        constexpr uint32_t PROT96 = (1U << 0);  ///< Protects Sector 96 from program or erase
        constexpr uint32_t PROT97 = (1U << 1);  ///< Protects Sector 97 from program or erase
        constexpr uint32_t PROT98 = (1U << 2);  ///< Protects Sector 98 from program or erase
        constexpr uint32_t PROT99 = (1U << 3);  ///< Protects Sector 99 from program or erase
        constexpr uint32_t PROT100 = (1U << 4);  ///< Protects Sector 100 from program or erase
        constexpr uint32_t PROT101 = (1U << 5);  ///< Protects Sector 101 from program or erase
        constexpr uint32_t PROT102 = (1U << 6);  ///< Protects Sector 102 from program or erase
        constexpr uint32_t PROT103 = (1U << 7);  ///< Protects Sector 103 from program or erase
        constexpr uint32_t PROT104 = (1U << 8);  ///< Protects Sector 104 from program or erase
        constexpr uint32_t PROT105 = (1U << 9);  ///< Protects Sector 105 from program or erase
        constexpr uint32_t PROT106 = (1U << 10);  ///< Protects Sector 106 from program or erase
        constexpr uint32_t PROT107 = (1U << 11);  ///< Protects Sector 107 from program or erase
        constexpr uint32_t PROT108 = (1U << 12);  ///< Protects Sector 108 from program or erase
        constexpr uint32_t PROT109 = (1U << 13);  ///< Protects Sector 109 from program or erase
        constexpr uint32_t PROT110 = (1U << 14);  ///< Protects Sector 110 from program or erase
        constexpr uint32_t PROT111 = (1U << 15);  ///< Protects Sector 111 from program or erase
        constexpr uint32_t PROT112 = (1U << 16);  ///< Protects Sector 112 from program or erase
        constexpr uint32_t PROT113 = (1U << 17);  ///< Protects Sector 113 from program or erase
        constexpr uint32_t PROT114 = (1U << 18);  ///< Protects Sector 114 from program or erase
        constexpr uint32_t PROT115 = (1U << 19);  ///< Protects Sector 115 from program or erase
        constexpr uint32_t PROT116 = (1U << 20);  ///< Protects Sector 116 from program or erase
        constexpr uint32_t PROT117 = (1U << 21);  ///< Protects Sector 117 from program or erase
        constexpr uint32_t PROT118 = (1U << 22);  ///< Protects Sector 118 from program or erase
        constexpr uint32_t PROT119 = (1U << 23);  ///< Protects Sector 119 from program or erase
        constexpr uint32_t PROT120 = (1U << 24);  ///< Protects Sector 120 from program or erase
        constexpr uint32_t PROT121 = (1U << 25);  ///< Protects Sector 121 from program or erase
        constexpr uint32_t PROT122 = (1U << 26);  ///< Protects Sector 122 from program or erase
        constexpr uint32_t PROT123 = (1U << 27);  ///< Protects Sector 123 from program or erase
        constexpr uint32_t PROT124 = (1U << 28);  ///< Protects Sector 124 from program or erase
        constexpr uint32_t PROT125 = (1U << 29);  ///< Protects Sector 125 from program or erase
        constexpr uint32_t PROT126 = (1U << 30);  ///< Protects Sector 126 from program or erase
        constexpr uint32_t PROT127 = (1U << 31);  ///< Protects Sector 127 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT4 Register bits
    namespace flctl_bank0_main_weprot4_bits {
        constexpr uint32_t PROT128 = (1U << 0);  ///< Protects Sector 128 from program or erase
        constexpr uint32_t PROT129 = (1U << 1);  ///< Protects Sector 129 from program or erase
        constexpr uint32_t PROT130 = (1U << 2);  ///< Protects Sector 130 from program or erase
        constexpr uint32_t PROT131 = (1U << 3);  ///< Protects Sector 131 from program or erase
        constexpr uint32_t PROT132 = (1U << 4);  ///< Protects Sector 132 from program or erase
        constexpr uint32_t PROT133 = (1U << 5);  ///< Protects Sector 133 from program or erase
        constexpr uint32_t PROT134 = (1U << 6);  ///< Protects Sector 134 from program or erase
        constexpr uint32_t PROT135 = (1U << 7);  ///< Protects Sector 135 from program or erase
        constexpr uint32_t PROT136 = (1U << 8);  ///< Protects Sector 136 from program or erase
        constexpr uint32_t PROT137 = (1U << 9);  ///< Protects Sector 137 from program or erase
        constexpr uint32_t PROT138 = (1U << 10);  ///< Protects Sector 138 from program or erase
        constexpr uint32_t PROT139 = (1U << 11);  ///< Protects Sector 139 from program or erase
        constexpr uint32_t PROT140 = (1U << 12);  ///< Protects Sector 140 from program or erase
        constexpr uint32_t PROT141 = (1U << 13);  ///< Protects Sector 141 from program or erase
        constexpr uint32_t PROT142 = (1U << 14);  ///< Protects Sector 142 from program or erase
        constexpr uint32_t PROT143 = (1U << 15);  ///< Protects Sector 143 from program or erase
        constexpr uint32_t PROT144 = (1U << 16);  ///< Protects Sector 144 from program or erase
        constexpr uint32_t PROT145 = (1U << 17);  ///< Protects Sector 145 from program or erase
        constexpr uint32_t PROT146 = (1U << 18);  ///< Protects Sector 146 from program or erase
        constexpr uint32_t PROT147 = (1U << 19);  ///< Protects Sector 147 from program or erase
        constexpr uint32_t PROT148 = (1U << 20);  ///< Protects Sector 148 from program or erase
        constexpr uint32_t PROT149 = (1U << 21);  ///< Protects Sector 149 from program or erase
        constexpr uint32_t PROT150 = (1U << 22);  ///< Protects Sector 150 from program or erase
        constexpr uint32_t PROT151 = (1U << 23);  ///< Protects Sector 151 from program or erase
        constexpr uint32_t PROT152 = (1U << 24);  ///< Protects Sector 152 from program or erase
        constexpr uint32_t PROT153 = (1U << 25);  ///< Protects Sector 153 from program or erase
        constexpr uint32_t PROT154 = (1U << 26);  ///< Protects Sector 154 from program or erase
        constexpr uint32_t PROT155 = (1U << 27);  ///< Protects Sector 155 from program or erase
        constexpr uint32_t PROT156 = (1U << 28);  ///< Protects Sector 156 from program or erase
        constexpr uint32_t PROT157 = (1U << 29);  ///< Protects Sector 157 from program or erase
        constexpr uint32_t PROT158 = (1U << 30);  ///< Protects Sector 158 from program or erase
        constexpr uint32_t PROT159 = (1U << 31);  ///< Protects Sector 159 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT5 Register bits
    namespace flctl_bank0_main_weprot5_bits {
        constexpr uint32_t PROT160 = (1U << 0);  ///< Protects Sector 160 from program or erase
        constexpr uint32_t PROT161 = (1U << 1);  ///< Protects Sector 161 from program or erase
        constexpr uint32_t PROT162 = (1U << 2);  ///< Protects Sector 162 from program or erase
        constexpr uint32_t PROT163 = (1U << 3);  ///< Protects Sector 163 from program or erase
        constexpr uint32_t PROT164 = (1U << 4);  ///< Protects Sector 164 from program or erase
        constexpr uint32_t PROT165 = (1U << 5);  ///< Protects Sector 165 from program or erase
        constexpr uint32_t PROT166 = (1U << 6);  ///< Protects Sector 166 from program or erase
        constexpr uint32_t PROT167 = (1U << 7);  ///< Protects Sector 167 from program or erase
        constexpr uint32_t PROT168 = (1U << 8);  ///< Protects Sector 168 from program or erase
        constexpr uint32_t PROT169 = (1U << 9);  ///< Protects Sector 169 from program or erase
        constexpr uint32_t PROT170 = (1U << 10);  ///< Protects Sector 170 from program or erase
        constexpr uint32_t PROT171 = (1U << 11);  ///< Protects Sector 171 from program or erase
        constexpr uint32_t PROT172 = (1U << 12);  ///< Protects Sector 172 from program or erase
        constexpr uint32_t PROT173 = (1U << 13);  ///< Protects Sector 173 from program or erase
        constexpr uint32_t PROT174 = (1U << 14);  ///< Protects Sector 174 from program or erase
        constexpr uint32_t PROT175 = (1U << 15);  ///< Protects Sector 175 from program or erase
        constexpr uint32_t PROT176 = (1U << 16);  ///< Protects Sector 176 from program or erase
        constexpr uint32_t PROT177 = (1U << 17);  ///< Protects Sector 177 from program or erase
        constexpr uint32_t PROT178 = (1U << 18);  ///< Protects Sector 178 from program or erase
        constexpr uint32_t PROT179 = (1U << 19);  ///< Protects Sector 179 from program or erase
        constexpr uint32_t PROT180 = (1U << 20);  ///< Protects Sector 180 from program or erase
        constexpr uint32_t PROT181 = (1U << 21);  ///< Protects Sector 181 from program or erase
        constexpr uint32_t PROT182 = (1U << 22);  ///< Protects Sector 182 from program or erase
        constexpr uint32_t PROT183 = (1U << 23);  ///< Protects Sector 183 from program or erase
        constexpr uint32_t PROT184 = (1U << 24);  ///< Protects Sector 184 from program or erase
        constexpr uint32_t PROT185 = (1U << 25);  ///< Protects Sector 185 from program or erase
        constexpr uint32_t PROT186 = (1U << 26);  ///< Protects Sector 186 from program or erase
        constexpr uint32_t PROT187 = (1U << 27);  ///< Protects Sector 187 from program or erase
        constexpr uint32_t PROT188 = (1U << 28);  ///< Protects Sector 188 from program or erase
        constexpr uint32_t PROT189 = (1U << 29);  ///< Protects Sector 189 from program or erase
        constexpr uint32_t PROT190 = (1U << 30);  ///< Protects Sector 190 from program or erase
        constexpr uint32_t PROT191 = (1U << 31);  ///< Protects Sector 191 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT6 Register bits
    namespace flctl_bank0_main_weprot6_bits {
        constexpr uint32_t PROT192 = (1U << 0);  ///< Protects Sector 192 from program or erase
        constexpr uint32_t PROT193 = (1U << 1);  ///< Protects Sector 193 from program or erase
        constexpr uint32_t PROT194 = (1U << 2);  ///< Protects Sector 194 from program or erase
        constexpr uint32_t PROT195 = (1U << 3);  ///< Protects Sector 195 from program or erase
        constexpr uint32_t PROT196 = (1U << 4);  ///< Protects Sector 196 from program or erase
        constexpr uint32_t PROT197 = (1U << 5);  ///< Protects Sector 197 from program or erase
        constexpr uint32_t PROT198 = (1U << 6);  ///< Protects Sector 198 from program or erase
        constexpr uint32_t PROT199 = (1U << 7);  ///< Protects Sector 199 from program or erase
        constexpr uint32_t PROT200 = (1U << 8);  ///< Protects Sector 200 from program or erase
        constexpr uint32_t PROT201 = (1U << 9);  ///< Protects Sector 201 from program or erase
        constexpr uint32_t PROT202 = (1U << 10);  ///< Protects Sector 202 from program or erase
        constexpr uint32_t PROT203 = (1U << 11);  ///< Protects Sector 203 from program or erase
        constexpr uint32_t PROT204 = (1U << 12);  ///< Protects Sector 204 from program or erase
        constexpr uint32_t PROT205 = (1U << 13);  ///< Protects Sector 205 from program or erase
        constexpr uint32_t PROT206 = (1U << 14);  ///< Protects Sector 206 from program or erase
        constexpr uint32_t PROT207 = (1U << 15);  ///< Protects Sector 207 from program or erase
        constexpr uint32_t PROT208 = (1U << 16);  ///< Protects Sector 208 from program or erase
        constexpr uint32_t PROT209 = (1U << 17);  ///< Protects Sector 209 from program or erase
        constexpr uint32_t PROT210 = (1U << 18);  ///< Protects Sector 210 from program or erase
        constexpr uint32_t PROT211 = (1U << 19);  ///< Protects Sector 211 from program or erase
        constexpr uint32_t PROT212 = (1U << 20);  ///< Protects Sector 212 from program or erase
        constexpr uint32_t PROT213 = (1U << 21);  ///< Protects Sector 213 from program or erase
        constexpr uint32_t PROT214 = (1U << 22);  ///< Protects Sector 214 from program or erase
        constexpr uint32_t PROT215 = (1U << 23);  ///< Protects Sector 215 from program or erase
        constexpr uint32_t PROT216 = (1U << 24);  ///< Protects Sector 216 from program or erase
        constexpr uint32_t PROT217 = (1U << 25);  ///< Protects Sector 217 from program or erase
        constexpr uint32_t PROT218 = (1U << 26);  ///< Protects Sector 218 from program or erase
        constexpr uint32_t PROT219 = (1U << 27);  ///< Protects Sector 219 from program or erase
        constexpr uint32_t PROT220 = (1U << 28);  ///< Protects Sector 220 from program or erase
        constexpr uint32_t PROT221 = (1U << 29);  ///< Protects Sector 221 from program or erase
        constexpr uint32_t PROT222 = (1U << 30);  ///< Protects Sector 222 from program or erase
        constexpr uint32_t PROT223 = (1U << 31);  ///< Protects Sector 223 from program or erase
    }

    /// FLCTL_BANK0_MAIN_WEPROT7 Register bits
    namespace flctl_bank0_main_weprot7_bits {
        constexpr uint32_t PROT224 = (1U << 0);  ///< Protects Sector 224 from program or erase
        constexpr uint32_t PROT225 = (1U << 1);  ///< Protects Sector 225 from program or erase
        constexpr uint32_t PROT226 = (1U << 2);  ///< Protects Sector 226 from program or erase
        constexpr uint32_t PROT227 = (1U << 3);  ///< Protects Sector 227 from program or erase
        constexpr uint32_t PROT228 = (1U << 4);  ///< Protects Sector 228 from program or erase
        constexpr uint32_t PROT229 = (1U << 5);  ///< Protects Sector 229 from program or erase
        constexpr uint32_t PROT230 = (1U << 6);  ///< Protects Sector 230 from program or erase
        constexpr uint32_t PROT231 = (1U << 7);  ///< Protects Sector 231 from program or erase
        constexpr uint32_t PROT232 = (1U << 8);  ///< Protects Sector 232 from program or erase
        constexpr uint32_t PROT233 = (1U << 9);  ///< Protects Sector 233 from program or erase
        constexpr uint32_t PROT234 = (1U << 10);  ///< Protects Sector 234 from program or erase
        constexpr uint32_t PROT235 = (1U << 11);  ///< Protects Sector 235 from program or erase
        constexpr uint32_t PROT236 = (1U << 12);  ///< Protects Sector 236 from program or erase
        constexpr uint32_t PROT237 = (1U << 13);  ///< Protects Sector 237 from program or erase
        constexpr uint32_t PROT238 = (1U << 14);  ///< Protects Sector 238 from program or erase
        constexpr uint32_t PROT239 = (1U << 15);  ///< Protects Sector 239 from program or erase
        constexpr uint32_t PROT240 = (1U << 16);  ///< Protects Sector 240 from program or erase
        constexpr uint32_t PROT241 = (1U << 17);  ///< Protects Sector 241 from program or erase
        constexpr uint32_t PROT242 = (1U << 18);  ///< Protects Sector 242 from program or erase
        constexpr uint32_t PROT243 = (1U << 19);  ///< Protects Sector 243 from program or erase
        constexpr uint32_t PROT244 = (1U << 20);  ///< Protects Sector 244 from program or erase
        constexpr uint32_t PROT245 = (1U << 21);  ///< Protects Sector 245 from program or erase
        constexpr uint32_t PROT246 = (1U << 22);  ///< Protects Sector 246 from program or erase
        constexpr uint32_t PROT247 = (1U << 23);  ///< Protects Sector 247 from program or erase
        constexpr uint32_t PROT248 = (1U << 24);  ///< Protects Sector 248 from program or erase
        constexpr uint32_t PROT249 = (1U << 25);  ///< Protects Sector 249 from program or erase
        constexpr uint32_t PROT250 = (1U << 26);  ///< Protects Sector 250 from program or erase
        constexpr uint32_t PROT251 = (1U << 27);  ///< Protects Sector 251 from program or erase
        constexpr uint32_t PROT252 = (1U << 28);  ///< Protects Sector 252 from program or erase
        constexpr uint32_t PROT253 = (1U << 29);  ///< Protects Sector 253 from program or erase
        constexpr uint32_t PROT254 = (1U << 30);  ///< Protects Sector 254 from program or erase
        constexpr uint32_t PROT255 = (1U << 31);  ///< Protects Sector 255 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT0 Register bits
    namespace flctl_bank1_main_weprot0_bits {
        constexpr uint32_t PROT0 = (1U << 0);  ///< Protects Sector 0 from program or erase
        constexpr uint32_t PROT1 = (1U << 1);  ///< Protects Sector 1 from program or erase
        constexpr uint32_t PROT2 = (1U << 2);  ///< Protects Sector 2 from program or erase
        constexpr uint32_t PROT3 = (1U << 3);  ///< Protects Sector 3 from program or erase
        constexpr uint32_t PROT4 = (1U << 4);  ///< Protects Sector 4 from program or erase
        constexpr uint32_t PROT5 = (1U << 5);  ///< Protects Sector 5 from program or erase
        constexpr uint32_t PROT6 = (1U << 6);  ///< Protects Sector 6 from program or erase
        constexpr uint32_t PROT7 = (1U << 7);  ///< Protects Sector 7 from program or erase
        constexpr uint32_t PROT8 = (1U << 8);  ///< Protects Sector 8 from program or erase
        constexpr uint32_t PROT9 = (1U << 9);  ///< Protects Sector 9 from program or erase
        constexpr uint32_t PROT10 = (1U << 10);  ///< Protects Sector 10 from program or erase
        constexpr uint32_t PROT11 = (1U << 11);  ///< Protects Sector 11 from program or erase
        constexpr uint32_t PROT12 = (1U << 12);  ///< Protects Sector 12 from program or erase
        constexpr uint32_t PROT13 = (1U << 13);  ///< Protects Sector 13 from program or erase
        constexpr uint32_t PROT14 = (1U << 14);  ///< Protects Sector 14 from program or erase
        constexpr uint32_t PROT15 = (1U << 15);  ///< Protects Sector 15 from program or erase
        constexpr uint32_t PROT16 = (1U << 16);  ///< Protects Sector 16 from program or erase
        constexpr uint32_t PROT17 = (1U << 17);  ///< Protects Sector 17 from program or erase
        constexpr uint32_t PROT18 = (1U << 18);  ///< Protects Sector 18 from program or erase
        constexpr uint32_t PROT19 = (1U << 19);  ///< Protects Sector 19 from program or erase
        constexpr uint32_t PROT20 = (1U << 20);  ///< Protects Sector 20 from program or erase
        constexpr uint32_t PROT21 = (1U << 21);  ///< Protects Sector 21 from program or erase
        constexpr uint32_t PROT22 = (1U << 22);  ///< Protects Sector 22 from program or erase
        constexpr uint32_t PROT23 = (1U << 23);  ///< Protects Sector 23 from program or erase
        constexpr uint32_t PROT24 = (1U << 24);  ///< Protects Sector 24 from program or erase
        constexpr uint32_t PROT25 = (1U << 25);  ///< Protects Sector 25 from program or erase
        constexpr uint32_t PROT26 = (1U << 26);  ///< Protects Sector 26 from program or erase
        constexpr uint32_t PROT27 = (1U << 27);  ///< Protects Sector 27 from program or erase
        constexpr uint32_t PROT28 = (1U << 28);  ///< Protects Sector 28 from program or erase
        constexpr uint32_t PROT29 = (1U << 29);  ///< Protects Sector 29 from program or erase
        constexpr uint32_t PROT30 = (1U << 30);  ///< Protects Sector 30 from program or erase
        constexpr uint32_t PROT31 = (1U << 31);  ///< Protects Sector 31 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT1 Register bits
    namespace flctl_bank1_main_weprot1_bits {
        constexpr uint32_t PROT32 = (1U << 0);  ///< Protects Sector 32 from program or erase
        constexpr uint32_t PROT33 = (1U << 1);  ///< Protects Sector 33 from program or erase
        constexpr uint32_t PROT34 = (1U << 2);  ///< Protects Sector 34 from program or erase
        constexpr uint32_t PROT35 = (1U << 3);  ///< Protects Sector 35 from program or erase
        constexpr uint32_t PROT36 = (1U << 4);  ///< Protects Sector 36 from program or erase
        constexpr uint32_t PROT37 = (1U << 5);  ///< Protects Sector 37 from program or erase
        constexpr uint32_t PROT38 = (1U << 6);  ///< Protects Sector 38 from program or erase
        constexpr uint32_t PROT39 = (1U << 7);  ///< Protects Sector 39 from program or erase
        constexpr uint32_t PROT40 = (1U << 8);  ///< Protects Sector 40 from program or erase
        constexpr uint32_t PROT41 = (1U << 9);  ///< Protects Sector 41 from program or erase
        constexpr uint32_t PROT42 = (1U << 10);  ///< Protects Sector 42 from program or erase
        constexpr uint32_t PROT43 = (1U << 11);  ///< Protects Sector 43 from program or erase
        constexpr uint32_t PROT44 = (1U << 12);  ///< Protects Sector 44 from program or erase
        constexpr uint32_t PROT45 = (1U << 13);  ///< Protects Sector 45 from program or erase
        constexpr uint32_t PROT46 = (1U << 14);  ///< Protects Sector 46 from program or erase
        constexpr uint32_t PROT47 = (1U << 15);  ///< Protects Sector 47 from program or erase
        constexpr uint32_t PROT48 = (1U << 16);  ///< Protects Sector 48 from program or erase
        constexpr uint32_t PROT49 = (1U << 17);  ///< Protects Sector 49 from program or erase
        constexpr uint32_t PROT50 = (1U << 18);  ///< Protects Sector 50 from program or erase
        constexpr uint32_t PROT51 = (1U << 19);  ///< Protects Sector 51 from program or erase
        constexpr uint32_t PROT52 = (1U << 20);  ///< Protects Sector 52 from program or erase
        constexpr uint32_t PROT53 = (1U << 21);  ///< Protects Sector 53 from program or erase
        constexpr uint32_t PROT54 = (1U << 22);  ///< Protects Sector 54 from program or erase
        constexpr uint32_t PROT55 = (1U << 23);  ///< Protects Sector 55 from program or erase
        constexpr uint32_t PROT56 = (1U << 24);  ///< Protects Sector 56 from program or erase
        constexpr uint32_t PROT57 = (1U << 25);  ///< Protects Sector 57 from program or erase
        constexpr uint32_t PROT58 = (1U << 26);  ///< Protects Sector 58 from program or erase
        constexpr uint32_t PROT59 = (1U << 27);  ///< Protects Sector 59 from program or erase
        constexpr uint32_t PROT60 = (1U << 28);  ///< Protects Sector 60 from program or erase
        constexpr uint32_t PROT61 = (1U << 29);  ///< Protects Sector 61 from program or erase
        constexpr uint32_t PROT62 = (1U << 30);  ///< Protects Sector 62 from program or erase
        constexpr uint32_t PROT63 = (1U << 31);  ///< Protects Sector 63 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT2 Register bits
    namespace flctl_bank1_main_weprot2_bits {
        constexpr uint32_t PROT64 = (1U << 0);  ///< Protects Sector 64 from program or erase
        constexpr uint32_t PROT65 = (1U << 1);  ///< Protects Sector 65 from program or erase
        constexpr uint32_t PROT66 = (1U << 2);  ///< Protects Sector 66 from program or erase
        constexpr uint32_t PROT67 = (1U << 3);  ///< Protects Sector 67 from program or erase
        constexpr uint32_t PROT68 = (1U << 4);  ///< Protects Sector 68 from program or erase
        constexpr uint32_t PROT69 = (1U << 5);  ///< Protects Sector 69 from program or erase
        constexpr uint32_t PROT70 = (1U << 6);  ///< Protects Sector 70 from program or erase
        constexpr uint32_t PROT71 = (1U << 7);  ///< Protects Sector 71 from program or erase
        constexpr uint32_t PROT72 = (1U << 8);  ///< Protects Sector 72 from program or erase
        constexpr uint32_t PROT73 = (1U << 9);  ///< Protects Sector 73 from program or erase
        constexpr uint32_t PROT74 = (1U << 10);  ///< Protects Sector 74 from program or erase
        constexpr uint32_t PROT75 = (1U << 11);  ///< Protects Sector 75 from program or erase
        constexpr uint32_t PROT76 = (1U << 12);  ///< Protects Sector 76 from program or erase
        constexpr uint32_t PROT77 = (1U << 13);  ///< Protects Sector 77 from program or erase
        constexpr uint32_t PROT78 = (1U << 14);  ///< Protects Sector 78 from program or erase
        constexpr uint32_t PROT79 = (1U << 15);  ///< Protects Sector 79 from program or erase
        constexpr uint32_t PROT80 = (1U << 16);  ///< Protects Sector 80 from program or erase
        constexpr uint32_t PROT81 = (1U << 17);  ///< Protects Sector 81 from program or erase
        constexpr uint32_t PROT82 = (1U << 18);  ///< Protects Sector 82 from program or erase
        constexpr uint32_t PROT83 = (1U << 19);  ///< Protects Sector 83 from program or erase
        constexpr uint32_t PROT84 = (1U << 20);  ///< Protects Sector 84 from program or erase
        constexpr uint32_t PROT85 = (1U << 21);  ///< Protects Sector 85 from program or erase
        constexpr uint32_t PROT86 = (1U << 22);  ///< Protects Sector 86 from program or erase
        constexpr uint32_t PROT87 = (1U << 23);  ///< Protects Sector 87 from program or erase
        constexpr uint32_t PROT88 = (1U << 24);  ///< Protects Sector 88 from program or erase
        constexpr uint32_t PROT89 = (1U << 25);  ///< Protects Sector 89 from program or erase
        constexpr uint32_t PROT90 = (1U << 26);  ///< Protects Sector 90 from program or erase
        constexpr uint32_t PROT91 = (1U << 27);  ///< Protects Sector 91 from program or erase
        constexpr uint32_t PROT92 = (1U << 28);  ///< Protects Sector 92 from program or erase
        constexpr uint32_t PROT93 = (1U << 29);  ///< Protects Sector 93 from program or erase
        constexpr uint32_t PROT94 = (1U << 30);  ///< Protects Sector 94 from program or erase
        constexpr uint32_t PROT95 = (1U << 31);  ///< Protects Sector 95 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT3 Register bits
    namespace flctl_bank1_main_weprot3_bits {
        constexpr uint32_t PROT96 = (1U << 0);  ///< Protects Sector 96 from program or erase
        constexpr uint32_t PROT97 = (1U << 1);  ///< Protects Sector 97 from program or erase
        constexpr uint32_t PROT98 = (1U << 2);  ///< Protects Sector 98 from program or erase
        constexpr uint32_t PROT99 = (1U << 3);  ///< Protects Sector 99 from program or erase
        constexpr uint32_t PROT100 = (1U << 4);  ///< Protects Sector 100 from program or erase
        constexpr uint32_t PROT101 = (1U << 5);  ///< Protects Sector 101 from program or erase
        constexpr uint32_t PROT102 = (1U << 6);  ///< Protects Sector 102 from program or erase
        constexpr uint32_t PROT103 = (1U << 7);  ///< Protects Sector 103 from program or erase
        constexpr uint32_t PROT104 = (1U << 8);  ///< Protects Sector 104 from program or erase
        constexpr uint32_t PROT105 = (1U << 9);  ///< Protects Sector 105 from program or erase
        constexpr uint32_t PROT106 = (1U << 10);  ///< Protects Sector 106 from program or erase
        constexpr uint32_t PROT107 = (1U << 11);  ///< Protects Sector 107 from program or erase
        constexpr uint32_t PROT108 = (1U << 12);  ///< Protects Sector 108 from program or erase
        constexpr uint32_t PROT109 = (1U << 13);  ///< Protects Sector 109 from program or erase
        constexpr uint32_t PROT110 = (1U << 14);  ///< Protects Sector 110 from program or erase
        constexpr uint32_t PROT111 = (1U << 15);  ///< Protects Sector 111 from program or erase
        constexpr uint32_t PROT112 = (1U << 16);  ///< Protects Sector 112 from program or erase
        constexpr uint32_t PROT113 = (1U << 17);  ///< Protects Sector 113 from program or erase
        constexpr uint32_t PROT114 = (1U << 18);  ///< Protects Sector 114 from program or erase
        constexpr uint32_t PROT115 = (1U << 19);  ///< Protects Sector 115 from program or erase
        constexpr uint32_t PROT116 = (1U << 20);  ///< Protects Sector 116 from program or erase
        constexpr uint32_t PROT117 = (1U << 21);  ///< Protects Sector 117 from program or erase
        constexpr uint32_t PROT118 = (1U << 22);  ///< Protects Sector 118 from program or erase
        constexpr uint32_t PROT119 = (1U << 23);  ///< Protects Sector 119 from program or erase
        constexpr uint32_t PROT120 = (1U << 24);  ///< Protects Sector 120 from program or erase
        constexpr uint32_t PROT121 = (1U << 25);  ///< Protects Sector 121 from program or erase
        constexpr uint32_t PROT122 = (1U << 26);  ///< Protects Sector 122 from program or erase
        constexpr uint32_t PROT123 = (1U << 27);  ///< Protects Sector 123 from program or erase
        constexpr uint32_t PROT124 = (1U << 28);  ///< Protects Sector 124 from program or erase
        constexpr uint32_t PROT125 = (1U << 29);  ///< Protects Sector 125 from program or erase
        constexpr uint32_t PROT126 = (1U << 30);  ///< Protects Sector 126 from program or erase
        constexpr uint32_t PROT127 = (1U << 31);  ///< Protects Sector 127 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT4 Register bits
    namespace flctl_bank1_main_weprot4_bits {
        constexpr uint32_t PROT128 = (1U << 0);  ///< Protects Sector 128 from program or erase
        constexpr uint32_t PROT129 = (1U << 1);  ///< Protects Sector 129 from program or erase
        constexpr uint32_t PROT130 = (1U << 2);  ///< Protects Sector 130 from program or erase
        constexpr uint32_t PROT131 = (1U << 3);  ///< Protects Sector 131 from program or erase
        constexpr uint32_t PROT132 = (1U << 4);  ///< Protects Sector 132 from program or erase
        constexpr uint32_t PROT133 = (1U << 5);  ///< Protects Sector 133 from program or erase
        constexpr uint32_t PROT134 = (1U << 6);  ///< Protects Sector 134 from program or erase
        constexpr uint32_t PROT135 = (1U << 7);  ///< Protects Sector 135 from program or erase
        constexpr uint32_t PROT136 = (1U << 8);  ///< Protects Sector 136 from program or erase
        constexpr uint32_t PROT137 = (1U << 9);  ///< Protects Sector 137 from program or erase
        constexpr uint32_t PROT138 = (1U << 10);  ///< Protects Sector 138 from program or erase
        constexpr uint32_t PROT139 = (1U << 11);  ///< Protects Sector 139 from program or erase
        constexpr uint32_t PROT140 = (1U << 12);  ///< Protects Sector 140 from program or erase
        constexpr uint32_t PROT141 = (1U << 13);  ///< Protects Sector 141 from program or erase
        constexpr uint32_t PROT142 = (1U << 14);  ///< Protects Sector 142 from program or erase
        constexpr uint32_t PROT143 = (1U << 15);  ///< Protects Sector 143 from program or erase
        constexpr uint32_t PROT144 = (1U << 16);  ///< Protects Sector 144 from program or erase
        constexpr uint32_t PROT145 = (1U << 17);  ///< Protects Sector 145 from program or erase
        constexpr uint32_t PROT146 = (1U << 18);  ///< Protects Sector 146 from program or erase
        constexpr uint32_t PROT147 = (1U << 19);  ///< Protects Sector 147 from program or erase
        constexpr uint32_t PROT148 = (1U << 20);  ///< Protects Sector 148 from program or erase
        constexpr uint32_t PROT149 = (1U << 21);  ///< Protects Sector 149 from program or erase
        constexpr uint32_t PROT150 = (1U << 22);  ///< Protects Sector 150 from program or erase
        constexpr uint32_t PROT151 = (1U << 23);  ///< Protects Sector 151 from program or erase
        constexpr uint32_t PROT152 = (1U << 24);  ///< Protects Sector 152 from program or erase
        constexpr uint32_t PROT153 = (1U << 25);  ///< Protects Sector 153 from program or erase
        constexpr uint32_t PROT154 = (1U << 26);  ///< Protects Sector 154 from program or erase
        constexpr uint32_t PROT155 = (1U << 27);  ///< Protects Sector 155 from program or erase
        constexpr uint32_t PROT156 = (1U << 28);  ///< Protects Sector 156 from program or erase
        constexpr uint32_t PROT157 = (1U << 29);  ///< Protects Sector 157 from program or erase
        constexpr uint32_t PROT158 = (1U << 30);  ///< Protects Sector 158 from program or erase
        constexpr uint32_t PROT159 = (1U << 31);  ///< Protects Sector 159 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT5 Register bits
    namespace flctl_bank1_main_weprot5_bits {
        constexpr uint32_t PROT160 = (1U << 0);  ///< Protects Sector 160 from program or erase
        constexpr uint32_t PROT161 = (1U << 1);  ///< Protects Sector 161 from program or erase
        constexpr uint32_t PROT162 = (1U << 2);  ///< Protects Sector 162 from program or erase
        constexpr uint32_t PROT163 = (1U << 3);  ///< Protects Sector 163 from program or erase
        constexpr uint32_t PROT164 = (1U << 4);  ///< Protects Sector 164 from program or erase
        constexpr uint32_t PROT165 = (1U << 5);  ///< Protects Sector 165 from program or erase
        constexpr uint32_t PROT166 = (1U << 6);  ///< Protects Sector 166 from program or erase
        constexpr uint32_t PROT167 = (1U << 7);  ///< Protects Sector 167 from program or erase
        constexpr uint32_t PROT168 = (1U << 8);  ///< Protects Sector 168 from program or erase
        constexpr uint32_t PROT169 = (1U << 9);  ///< Protects Sector 169 from program or erase
        constexpr uint32_t PROT170 = (1U << 10);  ///< Protects Sector 170 from program or erase
        constexpr uint32_t PROT171 = (1U << 11);  ///< Protects Sector 171 from program or erase
        constexpr uint32_t PROT172 = (1U << 12);  ///< Protects Sector 172 from program or erase
        constexpr uint32_t PROT173 = (1U << 13);  ///< Protects Sector 173 from program or erase
        constexpr uint32_t PROT174 = (1U << 14);  ///< Protects Sector 174 from program or erase
        constexpr uint32_t PROT175 = (1U << 15);  ///< Protects Sector 175 from program or erase
        constexpr uint32_t PROT176 = (1U << 16);  ///< Protects Sector 176 from program or erase
        constexpr uint32_t PROT177 = (1U << 17);  ///< Protects Sector 177 from program or erase
        constexpr uint32_t PROT178 = (1U << 18);  ///< Protects Sector 178 from program or erase
        constexpr uint32_t PROT179 = (1U << 19);  ///< Protects Sector 179 from program or erase
        constexpr uint32_t PROT180 = (1U << 20);  ///< Protects Sector 180 from program or erase
        constexpr uint32_t PROT181 = (1U << 21);  ///< Protects Sector 181 from program or erase
        constexpr uint32_t PROT182 = (1U << 22);  ///< Protects Sector 182 from program or erase
        constexpr uint32_t PROT183 = (1U << 23);  ///< Protects Sector 183 from program or erase
        constexpr uint32_t PROT184 = (1U << 24);  ///< Protects Sector 184 from program or erase
        constexpr uint32_t PROT185 = (1U << 25);  ///< Protects Sector 185 from program or erase
        constexpr uint32_t PROT186 = (1U << 26);  ///< Protects Sector 186 from program or erase
        constexpr uint32_t PROT187 = (1U << 27);  ///< Protects Sector 187 from program or erase
        constexpr uint32_t PROT188 = (1U << 28);  ///< Protects Sector 188 from program or erase
        constexpr uint32_t PROT189 = (1U << 29);  ///< Protects Sector 189 from program or erase
        constexpr uint32_t PROT190 = (1U << 30);  ///< Protects Sector 190 from program or erase
        constexpr uint32_t PROT191 = (1U << 31);  ///< Protects Sector 191 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT6 Register bits
    namespace flctl_bank1_main_weprot6_bits {
        constexpr uint32_t PROT192 = (1U << 0);  ///< Protects Sector 192 from program or erase
        constexpr uint32_t PROT193 = (1U << 1);  ///< Protects Sector 193 from program or erase
        constexpr uint32_t PROT194 = (1U << 2);  ///< Protects Sector 194 from program or erase
        constexpr uint32_t PROT195 = (1U << 3);  ///< Protects Sector 195 from program or erase
        constexpr uint32_t PROT196 = (1U << 4);  ///< Protects Sector 196 from program or erase
        constexpr uint32_t PROT197 = (1U << 5);  ///< Protects Sector 197 from program or erase
        constexpr uint32_t PROT198 = (1U << 6);  ///< Protects Sector 198 from program or erase
        constexpr uint32_t PROT199 = (1U << 7);  ///< Protects Sector 199 from program or erase
        constexpr uint32_t PROT200 = (1U << 8);  ///< Protects Sector 200 from program or erase
        constexpr uint32_t PROT201 = (1U << 9);  ///< Protects Sector 201 from program or erase
        constexpr uint32_t PROT202 = (1U << 10);  ///< Protects Sector 202 from program or erase
        constexpr uint32_t PROT203 = (1U << 11);  ///< Protects Sector 203 from program or erase
        constexpr uint32_t PROT204 = (1U << 12);  ///< Protects Sector 204 from program or erase
        constexpr uint32_t PROT205 = (1U << 13);  ///< Protects Sector 205 from program or erase
        constexpr uint32_t PROT206 = (1U << 14);  ///< Protects Sector 206 from program or erase
        constexpr uint32_t PROT207 = (1U << 15);  ///< Protects Sector 207 from program or erase
        constexpr uint32_t PROT208 = (1U << 16);  ///< Protects Sector 208 from program or erase
        constexpr uint32_t PROT209 = (1U << 17);  ///< Protects Sector 209 from program or erase
        constexpr uint32_t PROT210 = (1U << 18);  ///< Protects Sector 210 from program or erase
        constexpr uint32_t PROT211 = (1U << 19);  ///< Protects Sector 211 from program or erase
        constexpr uint32_t PROT212 = (1U << 20);  ///< Protects Sector 212 from program or erase
        constexpr uint32_t PROT213 = (1U << 21);  ///< Protects Sector 213 from program or erase
        constexpr uint32_t PROT214 = (1U << 22);  ///< Protects Sector 214 from program or erase
        constexpr uint32_t PROT215 = (1U << 23);  ///< Protects Sector 215 from program or erase
        constexpr uint32_t PROT216 = (1U << 24);  ///< Protects Sector 216 from program or erase
        constexpr uint32_t PROT217 = (1U << 25);  ///< Protects Sector 217 from program or erase
        constexpr uint32_t PROT218 = (1U << 26);  ///< Protects Sector 218 from program or erase
        constexpr uint32_t PROT219 = (1U << 27);  ///< Protects Sector 219 from program or erase
        constexpr uint32_t PROT220 = (1U << 28);  ///< Protects Sector 220 from program or erase
        constexpr uint32_t PROT221 = (1U << 29);  ///< Protects Sector 221 from program or erase
        constexpr uint32_t PROT222 = (1U << 30);  ///< Protects Sector 222 from program or erase
        constexpr uint32_t PROT223 = (1U << 31);  ///< Protects Sector 223 from program or erase
    }

    /// FLCTL_BANK1_MAIN_WEPROT7 Register bits
    namespace flctl_bank1_main_weprot7_bits {
        constexpr uint32_t PROT224 = (1U << 0);  ///< Protects Sector 224 from program or erase
        constexpr uint32_t PROT225 = (1U << 1);  ///< Protects Sector 225 from program or erase
        constexpr uint32_t PROT226 = (1U << 2);  ///< Protects Sector 226 from program or erase
        constexpr uint32_t PROT227 = (1U << 3);  ///< Protects Sector 227 from program or erase
        constexpr uint32_t PROT228 = (1U << 4);  ///< Protects Sector 228 from program or erase
        constexpr uint32_t PROT229 = (1U << 5);  ///< Protects Sector 229 from program or erase
        constexpr uint32_t PROT230 = (1U << 6);  ///< Protects Sector 230 from program or erase
        constexpr uint32_t PROT231 = (1U << 7);  ///< Protects Sector 231 from program or erase
        constexpr uint32_t PROT232 = (1U << 8);  ///< Protects Sector 232 from program or erase
        constexpr uint32_t PROT233 = (1U << 9);  ///< Protects Sector 233 from program or erase
        constexpr uint32_t PROT234 = (1U << 10);  ///< Protects Sector 234 from program or erase
        constexpr uint32_t PROT235 = (1U << 11);  ///< Protects Sector 235 from program or erase
        constexpr uint32_t PROT236 = (1U << 12);  ///< Protects Sector 236 from program or erase
        constexpr uint32_t PROT237 = (1U << 13);  ///< Protects Sector 237 from program or erase
        constexpr uint32_t PROT238 = (1U << 14);  ///< Protects Sector 238 from program or erase
        constexpr uint32_t PROT239 = (1U << 15);  ///< Protects Sector 239 from program or erase
        constexpr uint32_t PROT240 = (1U << 16);  ///< Protects Sector 240 from program or erase
        constexpr uint32_t PROT241 = (1U << 17);  ///< Protects Sector 241 from program or erase
        constexpr uint32_t PROT242 = (1U << 18);  ///< Protects Sector 242 from program or erase
        constexpr uint32_t PROT243 = (1U << 19);  ///< Protects Sector 243 from program or erase
        constexpr uint32_t PROT244 = (1U << 20);  ///< Protects Sector 244 from program or erase
        constexpr uint32_t PROT245 = (1U << 21);  ///< Protects Sector 245 from program or erase
        constexpr uint32_t PROT246 = (1U << 22);  ///< Protects Sector 246 from program or erase
        constexpr uint32_t PROT247 = (1U << 23);  ///< Protects Sector 247 from program or erase
        constexpr uint32_t PROT248 = (1U << 24);  ///< Protects Sector 248 from program or erase
        constexpr uint32_t PROT249 = (1U << 25);  ///< Protects Sector 249 from program or erase
        constexpr uint32_t PROT250 = (1U << 26);  ///< Protects Sector 250 from program or erase
        constexpr uint32_t PROT251 = (1U << 27);  ///< Protects Sector 251 from program or erase
        constexpr uint32_t PROT252 = (1U << 28);  ///< Protects Sector 252 from program or erase
        constexpr uint32_t PROT253 = (1U << 29);  ///< Protects Sector 253 from program or erase
        constexpr uint32_t PROT254 = (1U << 30);  ///< Protects Sector 254 from program or erase
        constexpr uint32_t PROT255 = (1U << 31);  ///< Protects Sector 255 from program or erase
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC14_BASE = 0x40012000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC14CTL0;  ///< Offset: 0x00 - Control 0 Register
        volatile uint32_t ADC14CTL1;  ///< Offset: 0x04 - Control 1 Register
        volatile uint32_t ADC14LO0;  ///< Offset: 0x08 - Window Comparator Low Threshold 0 Register
        volatile uint32_t ADC14HI0;  ///< Offset: 0x0C - Window Comparator High Threshold 0 Register
        volatile uint32_t ADC14LO1;  ///< Offset: 0x10 - Window Comparator Low Threshold 1 Register
        volatile uint32_t ADC14HI1;  ///< Offset: 0x14 - Window Comparator High Threshold 1 Register
        volatile uint32_t ADC14MCTL__;  ///< Offset: 0x18 - Conversion Memory Control Register (renamed from ADC14MCTL__)
        volatile uint32_t ADC14MEM__;  ///< Offset: 0x98 - Conversion Memory Register (renamed from ADC14MEM__)
        volatile uint32_t ADC14IER0;  ///< Offset: 0x13C - Interrupt Enable 0 Register
        volatile uint32_t ADC14IER1;  ///< Offset: 0x140 - Interrupt Enable 1 Register
        volatile uint32_t ADC14IFGR0;  ///< Offset: 0x144 - Interrupt Flag 0 Register
        volatile uint32_t ADC14IFGR1;  ///< Offset: 0x148 - Interrupt Flag 1 Register
        volatile uint32_t ADC14CLRIFGR0;  ///< Offset: 0x14C - Clear Interrupt Flag 0 Register
        volatile uint32_t ADC14CLRIFGR1;  ///< Offset: 0x150 - Clear Interrupt Flag 1 Register
        volatile uint32_t ADC14IV;  ///< Offset: 0x154 - Interrupt Vector Register
    };

    /// Peripheral instances
    inline Registers* ADC14 = reinterpret_cast<Registers*>(ADC14_BASE);

    // Bit definitions
    /// ADC14CTL0 Register bits
    namespace adc14ctl0_bits {
        constexpr uint32_t ADC14SC = (1U << 0);  ///< ADC14 start conversion
        constexpr uint32_t ADC14ENC = (1U << 1);  ///< ADC14 enable conversion
        constexpr uint32_t ADC14ON = (1U << 4);  ///< ADC14 on
        constexpr uint32_t ADC14MSC = (1U << 7);  ///< ADC14 multiple sample and conversion
        constexpr uint32_t ADC14SHT0 = (4 << 8);  ///< ADC14 sample-and-hold time
        constexpr uint32_t ADC14SHT1 = (4 << 12);  ///< ADC14 sample-and-hold time
        constexpr uint32_t ADC14BUSY = (1U << 16);  ///< ADC14 busy
        constexpr uint32_t ADC14CONSEQ = (2 << 17);  ///< ADC14 conversion sequence mode select
        constexpr uint32_t ADC14SSEL = (3 << 19);  ///< ADC14 clock source select
        constexpr uint32_t ADC14DIV = (3 << 22);  ///< ADC14 clock divider
        constexpr uint32_t ADC14ISSH = (1U << 25);  ///< ADC14 invert signal sample-and-hold
        constexpr uint32_t ADC14SHP = (1U << 26);  ///< ADC14 sample-and-hold pulse-mode select
        constexpr uint32_t ADC14SHS = (3 << 27);  ///< ADC14 sample-and-hold source select
        constexpr uint32_t ADC14PDIV = (2 << 30);  ///< ADC14 predivider
    }

    /// ADC14CTL1 Register bits
    namespace adc14ctl1_bits {
        constexpr uint32_t ADC14PWRMD = (2 << 0);  ///< ADC14 power modes
        constexpr uint32_t ADC14REFBURST = (1U << 2);  ///< ADC14 reference buffer burst
        constexpr uint32_t ADC14DF = (1U << 3);  ///< ADC14 data read-back format
        constexpr uint32_t ADC14RES = (2 << 4);  ///< ADC14 resolution
        constexpr uint32_t ADC14CSTARTADD = (5 << 16);  ///< ADC14 conversion start address
        constexpr uint32_t ADC14BATMAP = (1U << 22);  ///< Controls 1/2 AVCC ADC input channel selection
        constexpr uint32_t ADC14TCMAP = (1U << 23);  ///< Controls temperature sensor ADC input channel selection
        constexpr uint32_t ADC14CH0MAP = (1U << 24);  ///< Controls internal channel 0 selection to ADC input channel MAX-2
        constexpr uint32_t ADC14CH1MAP = (1U << 25);  ///< Controls internal channel 1 selection to ADC input channel MAX-3
        constexpr uint32_t ADC14CH2MAP = (1U << 26);  ///< Controls internal channel 2 selection to ADC input channel MAX-4
        constexpr uint32_t ADC14CH3MAP = (1U << 27);  ///< Controls internal channel 3 selection to ADC input channel MAX-5
    }

    /// ADC14LO0 Register bits
    namespace adc14lo0_bits {
        constexpr uint32_t ADC14LO0 = (16 << 0);  ///< Low threshold 0
    }

    /// ADC14HI0 Register bits
    namespace adc14hi0_bits {
        constexpr uint32_t ADC14HI0 = (16 << 0);  ///< High threshold 0
    }

    /// ADC14LO1 Register bits
    namespace adc14lo1_bits {
        constexpr uint32_t ADC14LO1 = (16 << 0);  ///< Low threshold 1
    }

    /// ADC14HI1 Register bits
    namespace adc14hi1_bits {
        constexpr uint32_t ADC14HI1 = (16 << 0);  ///< High threshold 1
    }

    /// ADC14MCTL__ Register bits
    namespace adc14mctl___bits {
        constexpr uint32_t ADC14INCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t ADC14EOS = (1U << 7);  ///< End of sequence
        constexpr uint32_t ADC14VRSEL = (4 << 8);  ///< Selects combinations of V(R+) and V(R-) sources
        constexpr uint32_t ADC14DIF = (1U << 13);  ///< Differential mode
        constexpr uint32_t ADC14WINC = (1U << 14);  ///< Comparator window enable
        constexpr uint32_t ADC14WINCTH = (1U << 15);  ///< Window comparator threshold register selection
    }

    /// ADC14MEM__ Register bits
    namespace adc14mem___bits {
        constexpr uint32_t Conversion_Results = (16 << 0);  ///< Conversion Result
    }

    /// ADC14IER0 Register bits
    namespace adc14ier0_bits {
        constexpr uint32_t ADC14IE0 = (1U << 0);  ///< Interrupt enable
        constexpr uint32_t ADC14IE1 = (1U << 1);  ///< Interrupt enable
        constexpr uint32_t ADC14IE2 = (1U << 2);  ///< Interrupt enable
        constexpr uint32_t ADC14IE3 = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t ADC14IE4 = (1U << 4);  ///< Interrupt enable
        constexpr uint32_t ADC14IE5 = (1U << 5);  ///< Interrupt enable
        constexpr uint32_t ADC14IE6 = (1U << 6);  ///< Interrupt enable
        constexpr uint32_t ADC14IE7 = (1U << 7);  ///< Interrupt enable
        constexpr uint32_t ADC14IE8 = (1U << 8);  ///< Interrupt enable
        constexpr uint32_t ADC14IE9 = (1U << 9);  ///< Interrupt enable
        constexpr uint32_t ADC14IE10 = (1U << 10);  ///< Interrupt enable
        constexpr uint32_t ADC14IE11 = (1U << 11);  ///< Interrupt enable
        constexpr uint32_t ADC14IE12 = (1U << 12);  ///< Interrupt enable
        constexpr uint32_t ADC14IE13 = (1U << 13);  ///< Interrupt enable
        constexpr uint32_t ADC14IE14 = (1U << 14);  ///< Interrupt enable
        constexpr uint32_t ADC14IE15 = (1U << 15);  ///< Interrupt enable
        constexpr uint32_t ADC14IE16 = (1U << 16);  ///< Interrupt enable
        constexpr uint32_t ADC14IE17 = (1U << 17);  ///< Interrupt enable
        constexpr uint32_t ADC14IE19 = (1U << 19);  ///< Interrupt enable
        constexpr uint32_t ADC14IE18 = (1U << 18);  ///< Interrupt enable
        constexpr uint32_t ADC14IE20 = (1U << 20);  ///< Interrupt enable
        constexpr uint32_t ADC14IE21 = (1U << 21);  ///< Interrupt enable
        constexpr uint32_t ADC14IE22 = (1U << 22);  ///< Interrupt enable
        constexpr uint32_t ADC14IE23 = (1U << 23);  ///< Interrupt enable
        constexpr uint32_t ADC14IE24 = (1U << 24);  ///< Interrupt enable
        constexpr uint32_t ADC14IE25 = (1U << 25);  ///< Interrupt enable
        constexpr uint32_t ADC14IE26 = (1U << 26);  ///< Interrupt enable
        constexpr uint32_t ADC14IE27 = (1U << 27);  ///< Interrupt enable
        constexpr uint32_t ADC14IE28 = (1U << 28);  ///< Interrupt enable
        constexpr uint32_t ADC14IE29 = (1U << 29);  ///< Interrupt enable
        constexpr uint32_t ADC14IE30 = (1U << 30);  ///< Interrupt enable
        constexpr uint32_t ADC14IE31 = (1U << 31);  ///< Interrupt enable
    }

    /// ADC14IER1 Register bits
    namespace adc14ier1_bits {
        constexpr uint32_t ADC14INIE = (1U << 1);  ///< Interrupt enable for ADC14MEMx within comparator window
        constexpr uint32_t ADC14LOIE = (1U << 2);  ///< Interrupt enable for ADC14MEMx below comparator window
        constexpr uint32_t ADC14HIIE = (1U << 3);  ///< Interrupt enable for ADC14MEMx above comparator window
        constexpr uint32_t ADC14OVIE = (1U << 4);  ///< ADC14MEMx overflow-interrupt enable
        constexpr uint32_t ADC14TOVIE = (1U << 5);  ///< ADC14 conversion-time-overflow interrupt enable
        constexpr uint32_t ADC14RDYIE = (1U << 6);  ///< ADC14 local buffered reference ready interrupt enable
    }

    /// ADC14IFGR0 Register bits
    namespace adc14ifgr0_bits {
        constexpr uint32_t ADC14IFG0 = (1U << 0);  ///< ADC14MEM0 interrupt flag
        constexpr uint32_t ADC14IFG1 = (1U << 1);  ///< ADC14MEM1 interrupt flag
        constexpr uint32_t ADC14IFG2 = (1U << 2);  ///< ADC14MEM2 interrupt flag
        constexpr uint32_t ADC14IFG3 = (1U << 3);  ///< ADC14MEM3 interrupt flag
        constexpr uint32_t ADC14IFG4 = (1U << 4);  ///< ADC14MEM4 interrupt flag
        constexpr uint32_t ADC14IFG5 = (1U << 5);  ///< ADC14MEM5 interrupt flag
        constexpr uint32_t ADC14IFG6 = (1U << 6);  ///< ADC14MEM6 interrupt flag
        constexpr uint32_t ADC14IFG7 = (1U << 7);  ///< ADC14MEM7 interrupt flag
        constexpr uint32_t ADC14IFG8 = (1U << 8);  ///< ADC14MEM8 interrupt flag
        constexpr uint32_t ADC14IFG9 = (1U << 9);  ///< ADC14MEM9 interrupt flag
        constexpr uint32_t ADC14IFG10 = (1U << 10);  ///< ADC14MEM10 interrupt flag
        constexpr uint32_t ADC14IFG11 = (1U << 11);  ///< ADC14MEM11 interrupt flag
        constexpr uint32_t ADC14IFG12 = (1U << 12);  ///< ADC14MEM12 interrupt flag
        constexpr uint32_t ADC14IFG13 = (1U << 13);  ///< ADC14MEM13 interrupt flag
        constexpr uint32_t ADC14IFG14 = (1U << 14);  ///< ADC14MEM14 interrupt flag
        constexpr uint32_t ADC14IFG15 = (1U << 15);  ///< ADC14MEM15 interrupt flag
        constexpr uint32_t ADC14IFG16 = (1U << 16);  ///< ADC14MEM16 interrupt flag
        constexpr uint32_t ADC14IFG17 = (1U << 17);  ///< ADC14MEM17 interrupt flag
        constexpr uint32_t ADC14IFG18 = (1U << 18);  ///< ADC14MEM18 interrupt flag
        constexpr uint32_t ADC14IFG19 = (1U << 19);  ///< ADC14MEM19 interrupt flag
        constexpr uint32_t ADC14IFG20 = (1U << 20);  ///< ADC14MEM20 interrupt flag
        constexpr uint32_t ADC14IFG21 = (1U << 21);  ///< ADC14MEM21 interrupt flag
        constexpr uint32_t ADC14IFG22 = (1U << 22);  ///< ADC14MEM22 interrupt flag
        constexpr uint32_t ADC14IFG23 = (1U << 23);  ///< ADC14MEM23 interrupt flag
        constexpr uint32_t ADC14IFG24 = (1U << 24);  ///< ADC14MEM24 interrupt flag
        constexpr uint32_t ADC14IFG25 = (1U << 25);  ///< ADC14MEM25 interrupt flag
        constexpr uint32_t ADC14IFG26 = (1U << 26);  ///< ADC14MEM26 interrupt flag
        constexpr uint32_t ADC14IFG27 = (1U << 27);  ///< ADC14MEM27 interrupt flag
        constexpr uint32_t ADC14IFG28 = (1U << 28);  ///< ADC14MEM28 interrupt flag
        constexpr uint32_t ADC14IFG29 = (1U << 29);  ///< ADC14MEM29 interrupt flag
        constexpr uint32_t ADC14IFG30 = (1U << 30);  ///< ADC14MEM30 interrupt flag
        constexpr uint32_t ADC14IFG31 = (1U << 31);  ///< ADC14MEM31 interrupt flag
    }

    /// ADC14IFGR1 Register bits
    namespace adc14ifgr1_bits {
        constexpr uint32_t ADC14INIFG = (1U << 1);  ///< Interrupt flag for ADC14MEMx within comparator window
        constexpr uint32_t ADC14LOIFG = (1U << 2);  ///< Interrupt flag for ADC14MEMx below comparator window
        constexpr uint32_t ADC14HIIFG = (1U << 3);  ///< Interrupt flag for ADC14MEMx above comparator window
        constexpr uint32_t ADC14OVIFG = (1U << 4);  ///< ADC14MEMx overflow interrupt flag
        constexpr uint32_t ADC14TOVIFG = (1U << 5);  ///< ADC14 conversion time overflow interrupt flag
        constexpr uint32_t ADC14RDYIFG = (1U << 6);  ///< ADC14 local buffered reference ready interrupt flag
    }

    /// ADC14CLRIFGR0 Register bits
    namespace adc14clrifgr0_bits {
        constexpr uint32_t CLRADC14IFG0 = (1U << 0);  ///< clear ADC14IFG0
        constexpr uint32_t CLRADC14IFG1 = (1U << 1);  ///< clear ADC14IFG1
        constexpr uint32_t CLRADC14IFG2 = (1U << 2);  ///< clear ADC14IFG2
        constexpr uint32_t CLRADC14IFG3 = (1U << 3);  ///< clear ADC14IFG3
        constexpr uint32_t CLRADC14IFG4 = (1U << 4);  ///< clear ADC14IFG4
        constexpr uint32_t CLRADC14IFG5 = (1U << 5);  ///< clear ADC14IFG5
        constexpr uint32_t CLRADC14IFG6 = (1U << 6);  ///< clear ADC14IFG6
        constexpr uint32_t CLRADC14IFG7 = (1U << 7);  ///< clear ADC14IFG7
        constexpr uint32_t CLRADC14IFG8 = (1U << 8);  ///< clear ADC14IFG8
        constexpr uint32_t CLRADC14IFG9 = (1U << 9);  ///< clear ADC14IFG9
        constexpr uint32_t CLRADC14IFG10 = (1U << 10);  ///< clear ADC14IFG10
        constexpr uint32_t CLRADC14IFG11 = (1U << 11);  ///< clear ADC14IFG11
        constexpr uint32_t CLRADC14IFG12 = (1U << 12);  ///< clear ADC14IFG12
        constexpr uint32_t CLRADC14IFG13 = (1U << 13);  ///< clear ADC14IFG13
        constexpr uint32_t CLRADC14IFG14 = (1U << 14);  ///< clear ADC14IFG14
        constexpr uint32_t CLRADC14IFG15 = (1U << 15);  ///< clear ADC14IFG15
        constexpr uint32_t CLRADC14IFG16 = (1U << 16);  ///< clear ADC14IFG16
        constexpr uint32_t CLRADC14IFG17 = (1U << 17);  ///< clear ADC14IFG17
        constexpr uint32_t CLRADC14IFG18 = (1U << 18);  ///< clear ADC14IFG18
        constexpr uint32_t CLRADC14IFG19 = (1U << 19);  ///< clear ADC14IFG19
        constexpr uint32_t CLRADC14IFG20 = (1U << 20);  ///< clear ADC14IFG20
        constexpr uint32_t CLRADC14IFG21 = (1U << 21);  ///< clear ADC14IFG21
        constexpr uint32_t CLRADC14IFG22 = (1U << 22);  ///< clear ADC14IFG22
        constexpr uint32_t CLRADC14IFG23 = (1U << 23);  ///< clear ADC14IFG23
        constexpr uint32_t CLRADC14IFG24 = (1U << 24);  ///< clear ADC14IFG24
        constexpr uint32_t CLRADC14IFG25 = (1U << 25);  ///< clear ADC14IFG25
        constexpr uint32_t CLRADC14IFG26 = (1U << 26);  ///< clear ADC14IFG26
        constexpr uint32_t CLRADC14IFG27 = (1U << 27);  ///< clear ADC14IFG27
        constexpr uint32_t CLRADC14IFG28 = (1U << 28);  ///< clear ADC14IFG28
        constexpr uint32_t CLRADC14IFG29 = (1U << 29);  ///< clear ADC14IFG29
        constexpr uint32_t CLRADC14IFG30 = (1U << 30);  ///< clear ADC14IFG30
        constexpr uint32_t CLRADC14IFG31 = (1U << 31);  ///< clear ADC14IFG31
    }

    /// ADC14CLRIFGR1 Register bits
    namespace adc14clrifgr1_bits {
        constexpr uint32_t CLRADC14INIFG = (1U << 1);  ///< clear ADC14INIFG
        constexpr uint32_t CLRADC14LOIFG = (1U << 2);  ///< clear ADC14LOIFG
        constexpr uint32_t CLRADC14HIIFG = (1U << 3);  ///< clear ADC14HIIFG
        constexpr uint32_t CLRADC14OVIFG = (1U << 4);  ///< clear ADC14OVIFG
        constexpr uint32_t CLRADC14TOVIFG = (1U << 5);  ///< clear ADC14TOVIFG
        constexpr uint32_t CLRADC14RDYIFG = (1U << 6);  ///< clear ADC14RDYIFG
    }

    /// ADC14IV Register bits
    namespace adc14iv_bits {
        constexpr uint32_t ADC14IV = (32 << 0);  ///< ADC14 interrupt vector value
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_F_BASE = 0x40012400;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t LCDCTL;  ///< Offset: 0x00 - LCD_F control
        volatile uint32_t LCDBMCTL;  ///< Offset: 0x04 - LCD_F blinking and memory control
        volatile uint32_t LCDVCTL;  ///< Offset: 0x08 - LCD_F voltage control
        volatile uint32_t LCDPCTL0;  ///< Offset: 0x0C - LCD_F port control 0
        volatile uint32_t LCDPCTL1;  ///< Offset: 0x10 - LCD_F port control 1
        volatile uint32_t LCDCSSEL0;  ///< Offset: 0x14 - LCD_F COM/SEG select register 0
        volatile uint32_t LCDCSSEL1;  ///< Offset: 0x18 - LCD_F COM/SEG select register 1
        volatile uint32_t LCDANMCTL;  ///< Offset: 0x1C - LCD_F Animation Control Register
        volatile uint32_t LCDIE;  ///< Offset: 0x110 - LCD_F interrupt enable register
        volatile uint32_t LCDIFG;  ///< Offset: 0x114 - LCD_F interrupt flag register
        volatile uint32_t LCDSETIFG;  ///< Offset: 0x118 - LCD_F set interrupt flag register
        volatile uint32_t LCDCLRIFG;  ///< Offset: 0x11C - LCD_F clear interrupt flag register
        volatile uint32_t LCDM__;  ///< Offset: 0x120 - LCD memory registers (renamed from LCDM__)
        volatile uint32_t LCDBM__;  ///< Offset: 0x160 - LCD Blinking memory registers (renamed from LCDBM__)
        volatile uint32_t LCDANM__;  ///< Offset: 0x1A0 - LCD Animation memory registers (renamed from LCDANM__)
    };

    /// Peripheral instances
    inline Registers* LCD_F = reinterpret_cast<Registers*>(LCD_F_BASE);

    // Bit definitions
    /// LCDCTL Register bits
    namespace lcdctl_bits {
        constexpr uint32_t LCDON = (1U << 0);  ///< LCD on
        constexpr uint32_t LCDLP = (1U << 1);  ///< LCD Low-power Waveform
        constexpr uint32_t LCDSON = (1U << 2);  ///< LCD segments on
        constexpr uint32_t LCDMXx = (3 << 3);  ///< LCD mux rate
        constexpr uint32_t LCDPREx = (3 << 8);  ///< LCD frequency pre-scaler
        constexpr uint32_t LCDDIVx = (5 << 11);  ///< LCD frequency divider
        constexpr uint32_t LCDSSEL = (2 << 16);  ///< Clock source select
    }

    /// LCDBMCTL Register bits
    namespace lcdbmctl_bits {
        constexpr uint32_t LCDBLKMODx = (2 << 0);  ///< Blinking mode
        constexpr uint32_t LCDBLKPREx = (3 << 2);  ///< Clock pre-scaler for blinking frequency
        constexpr uint32_t LCDBLKDIVx = (3 << 5);  ///< Clock divider for blinking frequency
        constexpr uint32_t LCDDISP = (1U << 16);  ///< Select LCD memory registers for display
        constexpr uint32_t LCDCLRM = (1U << 17);  ///< Clear LCD memory
        constexpr uint32_t LCDCLRBM = (1U << 18);  ///< Clear LCD blinking memory
    }

    /// LCDVCTL Register bits
    namespace lcdvctl_bits {
        constexpr uint32_t LCD2B = (1U << 0);  ///< Bias select.
        constexpr uint32_t LCDEXTBIAS = (1U << 5);  ///< V2 to V4 voltage select
        constexpr uint32_t R03EXT = (1U << 6);  ///< V5 voltage select
        constexpr uint32_t LCDREXT = (1U << 7);  ///< V2 to V4 voltage on external Rx3 pins
    }

    /// LCDPCTL0 Register bits
    namespace lcdpctl0_bits {
        constexpr uint32_t LCDS0 = (1U << 0);  ///< LCD pin 0 enable
        constexpr uint32_t LCDS1 = (1U << 1);  ///< LCD pin 1 enable
        constexpr uint32_t LCDS2 = (1U << 2);  ///< LCD pin 2 enable
        constexpr uint32_t LCDS3 = (1U << 3);  ///< LCD pin 3 enable
        constexpr uint32_t LCDS4 = (1U << 4);  ///< LCD pin 4 enable
        constexpr uint32_t LCDS5 = (1U << 5);  ///< LCD pin 5 enable
        constexpr uint32_t LCDS6 = (1U << 6);  ///< LCD pin 6 enable
        constexpr uint32_t LCDS7 = (1U << 7);  ///< LCD pin 7 enable
        constexpr uint32_t LCDS8 = (1U << 8);  ///< LCD pin 8 enable
        constexpr uint32_t LCDS9 = (1U << 9);  ///< LCD pin 9 enable
        constexpr uint32_t LCDS10 = (1U << 10);  ///< LCD pin 10 enable
        constexpr uint32_t LCDS11 = (1U << 11);  ///< LCD pin 11 enable
        constexpr uint32_t LCDS12 = (1U << 12);  ///< LCD pin 12 enable
        constexpr uint32_t LCDS13 = (1U << 13);  ///< LCD pin 13 enable
        constexpr uint32_t LCDS14 = (1U << 14);  ///< LCD pin 14 enable
        constexpr uint32_t LCDS15 = (1U << 15);  ///< LCD pin 15 enable
        constexpr uint32_t LCDS16 = (1U << 16);  ///< LCD pin 16 enable
        constexpr uint32_t LCDS17 = (1U << 17);  ///< LCD pin 17 enable
        constexpr uint32_t LCDS18 = (1U << 18);  ///< LCD pin 18 enable
        constexpr uint32_t LCDS19 = (1U << 19);  ///< LCD pin 19 enable
        constexpr uint32_t LCDS20 = (1U << 20);  ///< LCD pin 20 enable
        constexpr uint32_t LCDS21 = (1U << 21);  ///< LCD pin 21 enable
        constexpr uint32_t LCDS22 = (1U << 22);  ///< LCD pin 22 enable
        constexpr uint32_t LCDS23 = (1U << 23);  ///< LCD pin 23 enable
        constexpr uint32_t LCDS24 = (1U << 24);  ///< LCD pin 24 enable
        constexpr uint32_t LCDS25 = (1U << 25);  ///< LCD pin 25 enable
        constexpr uint32_t LCDS26 = (1U << 26);  ///< LCD pin 26 enable
        constexpr uint32_t LCDS27 = (1U << 27);  ///< LCD pin 27 enable
        constexpr uint32_t LCDS28 = (1U << 28);  ///< LCD pin 28 enable
        constexpr uint32_t LCDS29 = (1U << 29);  ///< LCD pin 29 enable
        constexpr uint32_t LCDS30 = (1U << 30);  ///< LCD pin 30 enable
        constexpr uint32_t LCDS31 = (1U << 31);  ///< LCD pin 31 enable
    }

    /// LCDPCTL1 Register bits
    namespace lcdpctl1_bits {
        constexpr uint32_t LCDS32 = (1U << 0);  ///< LCD pin 32 enable
        constexpr uint32_t LCDS33 = (1U << 1);  ///< LCD pin 33 enable
        constexpr uint32_t LCDS34 = (1U << 2);  ///< LCD pin 34 enable
        constexpr uint32_t LCDS35 = (1U << 3);  ///< LCD pin 35 enable
        constexpr uint32_t LCDS36 = (1U << 4);  ///< LCD pin 36 enable
        constexpr uint32_t LCDS37 = (1U << 5);  ///< LCD pin 37 enable
        constexpr uint32_t LCDS38 = (1U << 6);  ///< LCD pin 38 enable
        constexpr uint32_t LCDS39 = (1U << 7);  ///< LCD pin 39 enable
        constexpr uint32_t LCDS40 = (1U << 8);  ///< LCD pin 40 enable
        constexpr uint32_t LCDS41 = (1U << 9);  ///< LCD pin 41 enable
        constexpr uint32_t LCDS42 = (1U << 10);  ///< LCD pin 42 enable
        constexpr uint32_t LCDS43 = (1U << 11);  ///< LCD pin 43 enable
        constexpr uint32_t LCDS44 = (1U << 12);  ///< LCD pin 44 enable
        constexpr uint32_t LCDS45 = (1U << 13);  ///< LCD pin 45 enable
        constexpr uint32_t LCDS46 = (1U << 14);  ///< LCD pin 46 enable
        constexpr uint32_t LCDS47 = (1U << 15);  ///< LCD pin 47 enable
        constexpr uint32_t LCDS48 = (1U << 16);  ///< LCD pin 48 enable
        constexpr uint32_t LCDS49 = (1U << 17);  ///< LCD pin 49 enable
        constexpr uint32_t LCDS50 = (1U << 18);  ///< LCD pin 50 enable
        constexpr uint32_t LCDS51 = (1U << 19);  ///< LCD pin 51 enable
        constexpr uint32_t LCDS52 = (1U << 20);  ///< LCD pin 52 enable
        constexpr uint32_t LCDS53 = (1U << 21);  ///< LCD pin 53 enable
        constexpr uint32_t LCDS54 = (1U << 22);  ///< LCD pin 54 enable
        constexpr uint32_t LCDS55 = (1U << 23);  ///< LCD pin 55 enable
        constexpr uint32_t LCDS56 = (1U << 24);  ///< LCD pin 56 enable
        constexpr uint32_t LCDS57 = (1U << 25);  ///< LCD pin 57 enable
        constexpr uint32_t LCDS58 = (1U << 26);  ///< LCD pin 58 enable
        constexpr uint32_t LCDS59 = (1U << 27);  ///< LCD pin 59 enable
        constexpr uint32_t LCDS60 = (1U << 28);  ///< LCD pin 60 enable
        constexpr uint32_t LCDS61 = (1U << 29);  ///< LCD pin 61 enable
        constexpr uint32_t LCDS62 = (1U << 30);  ///< LCD pin 62 enable
        constexpr uint32_t LCDS63 = (1U << 31);  ///< LCD pin 63 enable
    }

    /// LCDCSSEL0 Register bits
    namespace lcdcssel0_bits {
        constexpr uint32_t LCDCSS0 = (1U << 0);  ///< L0 Com Seg select
        constexpr uint32_t LCDCSS1 = (1U << 1);  ///< L1 Com Seg select
        constexpr uint32_t LCDCSS2 = (1U << 2);  ///< L2 Com Seg select
        constexpr uint32_t LCDCSS3 = (1U << 3);  ///< L3 Com Seg select
        constexpr uint32_t LCDCSS4 = (1U << 4);  ///< L4 Com Seg select
        constexpr uint32_t LCDCSS5 = (1U << 5);  ///< L5 Com Seg select
        constexpr uint32_t LCDCSS6 = (1U << 6);  ///< L6 Com Seg select
        constexpr uint32_t LCDCSS7 = (1U << 7);  ///< L7 Com Seg select
        constexpr uint32_t LCDCSS8 = (1U << 8);  ///< L8 Com Seg select
        constexpr uint32_t LCDCSS9 = (1U << 9);  ///< L9 Com Seg select
        constexpr uint32_t LCDCSS10 = (1U << 10);  ///< L10 Com Seg select
        constexpr uint32_t LCDCSS11 = (1U << 11);  ///< L11 Com Seg select
        constexpr uint32_t LCDCSS12 = (1U << 12);  ///< L12 Com Seg select
        constexpr uint32_t LCDCSS13 = (1U << 13);  ///< L13 Com Seg select
        constexpr uint32_t LCDCSS14 = (1U << 14);  ///< L14 Com Seg select
        constexpr uint32_t LCDCSS15 = (1U << 15);  ///< L15 Com Seg select
        constexpr uint32_t LCDCSS16 = (1U << 16);  ///< L16 Com Seg select
        constexpr uint32_t LCDCSS17 = (1U << 17);  ///< L17 Com Seg select
        constexpr uint32_t LCDCSS18 = (1U << 18);  ///< L18 Com Seg select
        constexpr uint32_t LCDCSS19 = (1U << 19);  ///< L19 Com Seg select
        constexpr uint32_t LCDCSS20 = (1U << 20);  ///< L20 Com Seg select
        constexpr uint32_t LCDCSS21 = (1U << 21);  ///< L21 Com Seg select
        constexpr uint32_t LCDCSS22 = (1U << 22);  ///< L22 Com Seg select
        constexpr uint32_t LCDCSS23 = (1U << 23);  ///< L23 Com Seg select
        constexpr uint32_t LCDCSS24 = (1U << 24);  ///< L24 Com Seg select
        constexpr uint32_t LCDCSS25 = (1U << 25);  ///< L25 Com Seg select
        constexpr uint32_t LCDCSS26 = (1U << 26);  ///< L26 Com Seg select
        constexpr uint32_t LCDCSS27 = (1U << 27);  ///< L27 Com Seg select
        constexpr uint32_t LCDCSS28 = (1U << 28);  ///< L28 Com Seg select
        constexpr uint32_t LCDCSS29 = (1U << 29);  ///< L29 Com Seg select
        constexpr uint32_t LCDCSS30 = (1U << 30);  ///< L30 Com Seg select
        constexpr uint32_t LCDCSS31 = (1U << 31);  ///< L31 Com Seg select
    }

    /// LCDCSSEL1 Register bits
    namespace lcdcssel1_bits {
        constexpr uint32_t LCDCSS32 = (1U << 0);  ///< L32 Com Seg select
        constexpr uint32_t LCDCSS33 = (1U << 1);  ///< L33 Com Seg select
        constexpr uint32_t LCDCSS34 = (1U << 2);  ///< L34 Com Seg select
        constexpr uint32_t LCDCSS35 = (1U << 3);  ///< L35 Com Seg select
        constexpr uint32_t LCDCSS36 = (1U << 4);  ///< L36 Com Seg select
        constexpr uint32_t LCDCSS37 = (1U << 5);  ///< L37 Com Seg select
        constexpr uint32_t LCDCSS38 = (1U << 6);  ///< L38 Com Seg select
        constexpr uint32_t LCDCSS39 = (1U << 7);  ///< L39 Com Seg select
        constexpr uint32_t LCDCSS40 = (1U << 8);  ///< L40 Com Seg select
        constexpr uint32_t LCDCSS41 = (1U << 9);  ///< L41 Com Seg select
        constexpr uint32_t LCDCSS42 = (1U << 10);  ///< L42 Com Seg select
        constexpr uint32_t LCDCSS43 = (1U << 11);  ///< L43 Com Seg select
        constexpr uint32_t LCDCSS44 = (1U << 12);  ///< L44 Com Seg select
        constexpr uint32_t LCDCSS45 = (1U << 13);  ///< L45 Com Seg select
        constexpr uint32_t LCDCSS46 = (1U << 14);  ///< L46 Com Seg select
        constexpr uint32_t LCDCSS47 = (1U << 15);  ///< L47 Com Seg select
        constexpr uint32_t LCDCSS48 = (1U << 16);  ///< L48 Com Seg select
        constexpr uint32_t LCDCSS49 = (1U << 17);  ///< L49 Com Seg select
        constexpr uint32_t LCDCSS50 = (1U << 18);  ///< L50 Com Seg select
        constexpr uint32_t LCDCSS51 = (1U << 19);  ///< L51 Com Seg select
        constexpr uint32_t LCDCSS52 = (1U << 20);  ///< L52 Com Seg select
        constexpr uint32_t LCDCSS53 = (1U << 21);  ///< L53 Com Seg select
        constexpr uint32_t LCDCSS54 = (1U << 22);  ///< L54 Com Seg select
        constexpr uint32_t LCDCSS55 = (1U << 23);  ///< L55 Com Seg select
        constexpr uint32_t LCDCSS56 = (1U << 24);  ///< L56 Com Seg select
        constexpr uint32_t LCDCSS57 = (1U << 25);  ///< L57 Com Seg select
        constexpr uint32_t LCDCSS58 = (1U << 26);  ///< L58 Com Seg select
        constexpr uint32_t LCDCSS59 = (1U << 27);  ///< L59 Com Seg select
        constexpr uint32_t LCDCSS60 = (1U << 28);  ///< L60 Com Seg select
        constexpr uint32_t LCDCSS61 = (1U << 29);  ///< L61 Com Seg select
        constexpr uint32_t LCDCSS62 = (1U << 30);  ///< L62 Com Seg select
        constexpr uint32_t LCDCSS63 = (1U << 31);  ///< L63 Com Seg select
    }

    /// LCDANMCTL Register bits
    namespace lcdanmctl_bits {
        constexpr uint32_t LCDANMEN = (1U << 0);  ///< Enable Animation
        constexpr uint32_t LCDANMSTP = (3 << 1);  ///< Number of Amimation frames
        constexpr uint32_t LCDANMCLR = (1U << 7);  ///< Clear Animation Memory
        constexpr uint32_t LCDANMPREx = (3 << 16);  ///< Clock pre-scaler for animation frequency
        constexpr uint32_t LCDANMDIVx = (3 << 19);  ///< Clock divider for animation frequency
    }

    /// LCDIE Register bits
    namespace lcdie_bits {
        constexpr uint32_t LCDBLKOFFIE = (1U << 1);  ///< LCD Blink, segments off interrupt enable
        constexpr uint32_t LCDBLKONIE = (1U << 2);  ///< LCD Blink, segments on interrupt enable
        constexpr uint32_t LCDFRMIE = (1U << 3);  ///< LCD Frame interrupt enable
        constexpr uint32_t LCDANMSTPIE = (1U << 8);  ///< LCD Animation step interrupt enable
        constexpr uint32_t LCDANMLOOPIE = (1U << 9);  ///< LCD Animation loop interrupt enable
    }

    /// LCDIFG Register bits
    namespace lcdifg_bits {
        constexpr uint32_t LCDBLKOFFIFG = (1U << 1);  ///< LCD Blink, segments off interrupt flag
        constexpr uint32_t LCDBLKONIFG = (1U << 2);  ///< LCD Blink, segments on interrupt flag
        constexpr uint32_t LCDFRMIFG = (1U << 3);  ///< LCD Frame interrupt flag
        constexpr uint32_t LCDANMSTPIFG = (1U << 8);  ///< LCD Animation step interrupt flag
        constexpr uint32_t LCDANMLOOPIFG = (1U << 9);  ///< LCD Animation loop interrupt flag
    }

    /// LCDSETIFG Register bits
    namespace lcdsetifg_bits {
        constexpr uint32_t SETLCDBLKOFFIFG = (1U << 1);  ///< Sets LCDBLKOFFIFG
        constexpr uint32_t SETLCDBLKONIFG = (1U << 2);  ///< Sets LCDBLKONIFG
        constexpr uint32_t SETLCDFRMIFG = (1U << 3);  ///< Sets LCDFRMIFG
        constexpr uint32_t SETLCDANMSTPIFG = (1U << 8);  ///< Sets LCDANMSTPIFG
        constexpr uint32_t SETLCDANMLOOPIFG = (1U << 9);  ///< Sets LCDANMLOOPIFG
    }

    /// LCDCLRIFG Register bits
    namespace lcdclrifg_bits {
        constexpr uint32_t CLRLCDBLKOFFIFG = (1U << 1);  ///< Clears LCDBLKOFFIFG
        constexpr uint32_t CLRLCDBLKONIFG = (1U << 2);  ///< Clears LCDBLKONIFG
        constexpr uint32_t CLRLCDFRMIFG = (1U << 3);  ///< Clears LCDFRMIFG
        constexpr uint32_t CLRLCDANMSTPIFG = (1U << 8);  ///< Clears LCDANMSTPIFG
        constexpr uint32_t CLRLCDANMLOOPIFG = (1U << 9);  ///< Clears LCDANMLOOPIFG
    }

    /// LCDM__ Register bits
    namespace lcdm___bits {
        constexpr uint32_t LCDMEMORY = (8 << 0);  ///< LCD Memory Contains LCD Segment on/off data for Line Lx if LCDSSx = 0 Contains COM assignment for Line Lx if LCDSSx = 1
    }

    /// LCDBM__ Register bits
    namespace lcdbm___bits {
        constexpr uint32_t LCDMEMORY = (8 << 0);  ///< LCD Memory Contains LCD Segment on/off data for Line Lx if LCDSSx = 0 Contains COM assignment for Line Lx if LCDSSx = 1
    }

    /// LCDANM__ Register bits
    namespace lcdanm___bits {
        constexpr uint32_t LCDANIMMEMORY = (8 << 0);  ///< LCD Animation memory Contains Animation data for animation step Tx
    }

}

// ============================================================================
// ITM Peripheral
// ============================================================================

namespace itm {
    /// Base addresses
    constexpr uint32_t ITM_BASE = 0xE0000000;

    /// ITM Register structure
    struct Registers {
        volatile uint32_t ITM_STIM0;  ///< Offset: 0x00 - ITM Stimulus Port 0
        volatile uint32_t ITM_STIM1;  ///< Offset: 0x04 - ITM Stimulus Port 1
        volatile uint32_t ITM_STIM2;  ///< Offset: 0x08 - ITM Stimulus Port 2
        volatile uint32_t ITM_STIM3;  ///< Offset: 0x0C - ITM Stimulus Port 3
        volatile uint32_t ITM_STIM4;  ///< Offset: 0x10 - ITM Stimulus Port 4
        volatile uint32_t ITM_STIM5;  ///< Offset: 0x14 - ITM Stimulus Port 5
        volatile uint32_t ITM_STIM6;  ///< Offset: 0x18 - ITM Stimulus Port 6
        volatile uint32_t ITM_STIM7;  ///< Offset: 0x1C - ITM Stimulus Port 7
        volatile uint32_t ITM_STIM8;  ///< Offset: 0x20 - ITM Stimulus Port 8
        volatile uint32_t ITM_STIM9;  ///< Offset: 0x24 - ITM Stimulus Port 9
        volatile uint32_t ITM_STIM10;  ///< Offset: 0x28 - ITM Stimulus Port 10
        volatile uint32_t ITM_STIM11;  ///< Offset: 0x2C - ITM Stimulus Port 11
        volatile uint32_t ITM_STIM12;  ///< Offset: 0x30 - ITM Stimulus Port 12
        volatile uint32_t ITM_STIM13;  ///< Offset: 0x34 - ITM Stimulus Port 13
        volatile uint32_t ITM_STIM14;  ///< Offset: 0x38 - ITM Stimulus Port 14
        volatile uint32_t ITM_STIM15;  ///< Offset: 0x3C - ITM Stimulus Port 15
        volatile uint32_t ITM_STIM16;  ///< Offset: 0x40 - ITM Stimulus Port 16
        volatile uint32_t ITM_STIM17;  ///< Offset: 0x44 - ITM Stimulus Port 17
        volatile uint32_t ITM_STIM18;  ///< Offset: 0x48 - ITM Stimulus Port 18
        volatile uint32_t ITM_STIM19;  ///< Offset: 0x4C - ITM Stimulus Port 19
        volatile uint32_t ITM_STIM20;  ///< Offset: 0x50 - ITM Stimulus Port 20
        volatile uint32_t ITM_STIM21;  ///< Offset: 0x54 - ITM Stimulus Port 21
        volatile uint32_t ITM_STIM22;  ///< Offset: 0x58 - ITM Stimulus Port 22
        volatile uint32_t ITM_STIM23;  ///< Offset: 0x5C - ITM Stimulus Port 23
        volatile uint32_t ITM_STIM24;  ///< Offset: 0x60 - ITM Stimulus Port 24
        volatile uint32_t ITM_STIM25;  ///< Offset: 0x64 - ITM Stimulus Port 25
        volatile uint32_t ITM_STIM26;  ///< Offset: 0x68 - ITM Stimulus Port 26
        volatile uint32_t ITM_STIM27;  ///< Offset: 0x6C - ITM Stimulus Port 27
        volatile uint32_t ITM_STIM28;  ///< Offset: 0x70 - ITM Stimulus Port 28
        volatile uint32_t ITM_STIM29;  ///< Offset: 0x74 - ITM Stimulus Port 29
        volatile uint32_t ITM_STIM30;  ///< Offset: 0x78 - ITM Stimulus Port 30
        volatile uint32_t ITM_STIM31;  ///< Offset: 0x7C - ITM Stimulus Port 31
        volatile uint32_t ITM_TER;  ///< Offset: 0xE00 - ITM Trace Enable Register
        volatile uint32_t ITM_TPR;  ///< Offset: 0xE40 - ITM Trace Privilege Register
        volatile uint32_t ITM_TCR;  ///< Offset: 0xE80 - ITM Trace Control Register
        volatile uint32_t ITM_IWR;  ///< Offset: 0xEF8 - ITM Integration Write Register
        volatile uint32_t ITM_IMCR;  ///< Offset: 0xF00 - ITM Integration Mode Control Register
        volatile uint32_t ITM_LAR;  ///< Offset: 0xFB0 - ITM Lock Access Register
        volatile uint32_t ITM_LSR;  ///< Offset: 0xFB4 - ITM Lock Status Register
    };

    /// Peripheral instances
    inline Registers* ITM = reinterpret_cast<Registers*>(ITM_BASE);

    // Bit definitions
    /// ITM_TER Register bits
    namespace itm_ter_bits {
        constexpr uint32_t STIMENA = (32 << 0);  ///< Bit mask to enable tracing on ITM stimulus ports. One bit per stimulus port.
    }

    /// ITM_TPR Register bits
    namespace itm_tpr_bits {
        constexpr uint32_t PRIVMASK = (4 << 0);  ///< Bit mask to enable tracing on ITM stimulus ports: bit [0] = stimulus ports [7:0], bit [1] = stimulus ports [15:8], bit [2] = stimulus ports [23:16], bit [3] = stimulus ports [31:24].
    }

    /// ITM_TCR Register bits
    namespace itm_tcr_bits {
        constexpr uint32_t ITMENA = (1U << 0);  ///< Enable ITM. This is the master enable, and must be set before ITM Stimulus and Trace Enable registers can be written.
        constexpr uint32_t TSENA = (1U << 1);  ///< Enables differential timestamps. Differential timestamps are emitted when a packet is written to the FIFO with a non-zero timestamp counter, and when the timestamp counter overflows. Timestamps are emitted during idle times after a fixed number of two million cycles. This provides a time reference for packets and inter-packet gaps. If SWOENA (bit [4]) is set, timestamps are triggered by activity on the internal trace bus only. In this case there is no regular timestamp output when the ITM is idle.
        constexpr uint32_t SYNCENA = (1U << 2);  ///< Enables sync packets for TPIU.
        constexpr uint32_t DWTENA = (1U << 3);  ///< Enables the DWT stimulus.
        constexpr uint32_t SWOENA = (1U << 4);  ///< Enables asynchronous clocking of the timestamp counter.
        constexpr uint32_t TSPRESCALE = (2 << 8);  ///< TSPrescale Timestamp prescaler.
        constexpr uint32_t ATBID = (7 << 16);  ///< ATB ID for CoreSight system.
        constexpr uint32_t BUSY = (1U << 23);  ///< Set when ITM events present and being drained.
    }

    /// ITM_IWR Register bits
    namespace itm_iwr_bits {
        constexpr uint32_t ATVALIDM = (1U << 0);  ///< When the integration mode is set: 0 = ATVALIDM clear. 1 = ATVALIDM set.
    }

    /// ITM_IMCR Register bits
    namespace itm_imcr_bits {
        constexpr uint32_t INTEGRATION = (1U << 0);  ///< ATVALIDM normal
    }

    /// ITM_LAR Register bits
    namespace itm_lar_bits {
        constexpr uint32_t LOCK_ACCESS = (32 << 0);  ///< A privileged write of 0xC5ACCE55 enables more write access to Control Register 0xE00::0xFFC. An invalid write removes write access.
    }

    /// ITM_LSR Register bits
    namespace itm_lsr_bits {
        constexpr uint32_t PRESENT = (1U << 0);  ///< Indicates that a lock mechanism exists for this component.
        constexpr uint32_t ACCESS = (1U << 1);  ///< Write access to component is blocked. All writes are ignored, reads are permitted.
        constexpr uint32_t BYTEACC = (1U << 2);  ///< You cannot implement 8-bit lock accesses.
    }

}

// ============================================================================
// DWT Peripheral
// ============================================================================

namespace dwt {
    /// Base addresses
    constexpr uint32_t DWT_BASE = 0xE0001000;

    /// DWT Register structure
    struct Registers {
        volatile uint32_t DWT_CTRL;  ///< Offset: 0x00 - DWT Control Register
        volatile uint32_t DWT_CYCCNT;  ///< Offset: 0x04 - DWT Current PC Sampler Cycle Count Register
        volatile uint32_t DWT_CPICNT;  ///< Offset: 0x08 - DWT CPI Count Register
        volatile uint32_t DWT_EXCCNT;  ///< Offset: 0x0C - DWT Exception Overhead Count Register
        volatile uint32_t DWT_SLEEPCNT;  ///< Offset: 0x10 - DWT Sleep Count Register
        volatile uint32_t DWT_LSUCNT;  ///< Offset: 0x14 - DWT LSU Count Register
        volatile uint32_t DWT_FOLDCNT;  ///< Offset: 0x18 - DWT Fold Count Register
        volatile uint32_t DWT_PCSR;  ///< Offset: 0x1C - DWT Program Counter Sample Register
        volatile uint32_t DWT_COMP0;  ///< Offset: 0x20 - DWT Comparator Register 0
        volatile uint32_t DWT_MASK0;  ///< Offset: 0x24 - DWT Mask Register 0
        volatile uint32_t DWT_FUNCTION0;  ///< Offset: 0x28 - DWT Function Register 0
        volatile uint32_t DWT_COMP1;  ///< Offset: 0x30 - DWT Comparator Register 1
        volatile uint32_t DWT_MASK1;  ///< Offset: 0x34 - DWT Mask Register 1
        volatile uint32_t DWT_FUNCTION1;  ///< Offset: 0x38 - DWT Function Register 1
        volatile uint32_t DWT_COMP2;  ///< Offset: 0x40 - DWT Comparator Register 2
        volatile uint32_t DWT_MASK2;  ///< Offset: 0x44 - DWT Mask Register 2
        volatile uint32_t DWT_FUNCTION2;  ///< Offset: 0x48 - DWT Function Register 2
        volatile uint32_t DWT_COMP3;  ///< Offset: 0x50 - DWT Comparator Register 3
        volatile uint32_t DWT_MASK3;  ///< Offset: 0x54 - DWT Mask Register 3
        volatile uint32_t DWT_FUNCTION3;  ///< Offset: 0x58 - DWT Function Register 3
    };

    /// Peripheral instances
    inline Registers* DWT = reinterpret_cast<Registers*>(DWT_BASE);

    // Bit definitions
    /// DWT_CTRL Register bits
    namespace dwt_ctrl_bits {
        constexpr uint32_t CYCCNTENA = (1U << 0);  ///< Enable the CYCCNT counter. If not enabled, the counter does not count and no event is generated for PS sampling or CYCCNTENA. In normal use, the debugger must initialize the CYCCNT counter to 0.
        constexpr uint32_t POSTPRESET = (4 << 1);  ///< Reload value for POSTCNT, bits [8:5], post-scalar counter. If this value is 0, events are triggered on each tap change (a power of 2). If this field has a non-0 value, this forms a count-down value, to be reloaded into POSTCNT each time it reaches 0. For example, a value 1 in this register means an event is formed every other tap change.
        constexpr uint32_t POSTCNT = (4 << 5);  ///< Post-scalar counter for CYCTAP. When the selected tapped bit changes from 0 to 1 or 1 to 0, the post scalar counter is down-counted when not 0. If 0, it triggers an event for PCSAMPLENA or CYCEVTENA use. It also reloads with the value from POSTPRESET (bits [4:1]).
        constexpr uint32_t CYCTAP = (1U << 9);  ///< Selects a tap on the DWT_CYCCNT register. These are spaced at bits [6] and [10]. When the selected bit in the CYCCNT register changes from 0 to 1 or 1 to 0, it emits into the POSTCNT, bits [8:5], post-scalar counter. That counter then counts down. On a bit change when post-scalar is 0, it triggers an event for PC sampling or CYCEVTCNT.
        constexpr uint32_t SYNCTAP = (2 << 10);  ///< Feeds a synchronization pulse to the ITM SYNCENA control. The value selected here picks the rate (approximately 1/second or less) by selecting a tap on the DWT_CYCCNT register. To use synchronization (heartbeat and hot-connect synchronization), CYCCNTENA must be set to 1, SYNCTAP must be set to one of its values, and SYNCENA must be set to 1.
        constexpr uint32_t PCSAMPLEENA = (1U << 12);  ///< Enables PC Sampling event. A PC sample event is emitted when the POSTCNT counter triggers it. See CYCTAP, bit [9], and POSTPRESET, bits [4:1], for details. Enabling this bit overrides CYCEVTENA (bit [20]). Reset clears the PCSAMPLENA bit.
        constexpr uint32_t EXCTRCENA = (1U << 16);  ///< Enables Interrupt event tracing. Reset clears the EXCEVTENA bit.
        constexpr uint32_t CPIEVTENA = (1U << 17);  ///< Enables CPI count event. Emits an event when DWT_CPICNT overflows (every 256 cycles of multi-cycle instructions). Reset clears the CPIEVTENA bit.
        constexpr uint32_t EXCEVTENA = (1U << 18);  ///< Enables Interrupt overhead event. Emits an event when DWT_EXCCNT overflows (every 256 cycles of interrupt overhead). Reset clears the EXCEVTENA bit.
        constexpr uint32_t SLEEPEVTENA = (1U << 19);  ///< Enables Sleep count event. Emits an event when DWT_SLEEPCNT overflows (every 256 cycles that the processor is sleeping). Reset clears the SLEEPEVTENA bit.
        constexpr uint32_t LSUEVTENA = (1U << 20);  ///< Enables LSU count event. Emits an event when DWT_LSUCNT overflows (every 256 cycles of LSU operation). LSU counts include all LSU costs after the initial cycle for the instruction. Reset clears the LSUEVTENA bit.
        constexpr uint32_t FOLDEVTENA = (1U << 21);  ///< Enables Folded instruction count event. Emits an event when DWT_FOLDCNT overflows (every 256 cycles of folded instructions). A folded instruction is one that does not incur even one cycle to execute. For example, an IT instruction is folded away and so does not use up one cycle. Reset clears the FOLDEVTENA bit.
        constexpr uint32_t CYCEVTENA = (1U << 22);  ///< Enables Cycle count event. Emits an event when the POSTCNT counter triggers it. See CYCTAP (bit [9]) and POSTPRESET, bits [4:1], for details. This event is only emitted if PCSAMPLENA, bit [12], is disabled. PCSAMPLENA overrides the setting of this bit. Reset clears the CYCEVTENA bit.
        constexpr uint32_t NOPRFCNT = (1U << 24);  ///< When set, DWT_FOLDCNT, DWT_LSUCNT, DWT_SLEEPCNT, DWT_EXCCNT, and DWT_CPICNT are not supported.
        constexpr uint32_t NOCYCCNT = (1U << 25);  ///< When set, DWT_CYCCNT is not supported.
    }

    /// DWT_CYCCNT Register bits
    namespace dwt_cyccnt_bits {
        constexpr uint32_t CYCCNT = (32 << 0);  ///< Current PC Sampler Cycle Counter count value. When enabled, this counter counts the number of core cycles, except when the core is halted. CYCCNT is a free running counter, counting upwards. It wraps around to 0 on overflow. The debugger must initialize this to 0 when first enabling.
    }

    /// DWT_CPICNT Register bits
    namespace dwt_cpicnt_bits {
        constexpr uint32_t CPICNT = (8 << 0);  ///< Current CPI counter value. Increments on the additional cycles (the first cycle is not counted) required to execute all instructions except those recorded by DWT_LSUCNT. This counter also increments on all instruction fetch stalls. If CPIEVTENA is set, an event is emitted when the counter overflows. Clears to 0 on enabling.
    }

    /// DWT_EXCCNT Register bits
    namespace dwt_exccnt_bits {
        constexpr uint32_t EXCCNT = (8 << 0);  ///< Current interrupt overhead counter value. Counts the total cycles spent in interrupt processing (for example entry stacking, return unstacking, pre-emption). An event is emitted on counter overflow (every 256 cycles). This counter initializes to 0 when enabled. Clears to 0 on enabling.
    }

    /// DWT_SLEEPCNT Register bits
    namespace dwt_sleepcnt_bits {
        constexpr uint32_t SLEEPCNT = (8 << 0);  ///< Sleep counter. Counts the number of cycles during which the processor is sleeping. An event is emitted on counter overflow (every 256 cycles). This counter initializes to 0 when enabled. Note that SLEEPCNT is clocked using FCLK. It is possible that the frequency of FCLK might be reduced while the processor is sleeping to minimize power consumption. This means that sleep duration must be calculated with the frequency of FCLK during sleep.
    }

    /// DWT_LSUCNT Register bits
    namespace dwt_lsucnt_bits {
        constexpr uint32_t LSUCNT = (8 << 0);  ///< LSU counter. This counts the total number of cycles that the processor is processing an LSU operation. The initial execution cost of the instruction is not counted. For example, an LDR that takes two cycles to complete increments this counter one cycle. Equivalently, an LDR that stalls for two cycles (and so takes four cycles), increments this counter three times. An event is emitted on counter overflow (every 256 cycles). Clears to 0 on enabling.
    }

    /// DWT_FOLDCNT Register bits
    namespace dwt_foldcnt_bits {
        constexpr uint32_t FOLDCNT = (8 << 0);  ///< This counts the total number folded instructions. This counter initializes to 0 when enabled.
    }

    /// DWT_PCSR Register bits
    namespace dwt_pcsr_bits {
        constexpr uint32_t EIASAMPLE = (32 << 0);  ///< Execution instruction address sample, or 0xFFFFFFFF if the core is halted.
    }

    /// DWT_COMP0 Register bits
    namespace dwt_comp0_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Data value to compare against PC and the data address as given by DWT_FUNCTION0. DWT_COMP0 can also compare against the value of the PC Sampler Counter (DWT_CYCCNT).
    }

    /// DWT_MASK0 Register bits
    namespace dwt_mask0_bits {
        constexpr uint32_t MASK = (4 << 0);  ///< Mask on data address when matching against COMP. This is the size of the ignore mask. hat is, DWT matching is performed as:(ADDR ANDed with (~0 left bit-shifted by MASK)) == COMP. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP is 3, this matches a word access of 0, because 3 would be within the word.
    }

    /// DWT_FUNCTION0 Register bits
    namespace dwt_function0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< Emit range field. Reserved to permit emitting offset when range match occurs. Reset clears the EMITRANGE bit. PC sampling is not supported when EMITRANGE is enabled. EMITRANGE only applies for: FUNCTION = b0001, b0010, b0011, b1100, b1101, b1110, and b1111.
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< This bit is only available in comparator 1. When DATAVMATCH is set, this comparator performs data value compares. The comparators given by DATAVADDR0 and DATAVADDR1provide the address for the data comparison. If DATAVMATCH is set in DWT_FUNCTION1, the FUNCTION setting for the comparators given by DATAVADDR0 and DATAVADDR1 are overridden and those comparators only provide the address match for the data comparison.
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< DATAVADDR1 not supported
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Defines the size of the data in the COMP register that is to be matched:
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Identity of a linked address comparator for data value matching when DATAVMATCH == 1.
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< Identity of a second linked address comparator for data value matching when DATAVMATCH == 1 and LNK1ENA == 1.
        constexpr uint32_t MATCHED = (1U << 24);  ///< This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.
    }

    /// DWT_COMP1 Register bits
    namespace dwt_comp1_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Data value to compare against PC and the data address as given by DWT_FUNCTION1.
    }

    /// DWT_MASK1 Register bits
    namespace dwt_mask1_bits {
        constexpr uint32_t MASK = (4 << 0);  ///< Mask on data address when matching against COMP. This is the size of the ignore mask. hat is, DWT matching is performed as:(ADDR ANDed with (~0 left bit-shifted by MASK)) == COMP. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP is 3, this matches a word access of 0, because 3 would be within the word.
    }

    /// DWT_FUNCTION1 Register bits
    namespace dwt_function1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: FUNCTION is overridden for comparators given by DATAVADDR0 and DATAVADDR1 in DWT_FUNCTION1if DATAVMATCH is also set in DWT_FUNCTION1. The comparators given by DATAVADDR0 and DATAVADDR1 can then only perform address comparator matches for comparator 1 data matches. Note 4: If the data matching functionality is not included during implementation it is not possible to set DATAVADDR0, DATAVADDR1, or DATAVMATCH in DWT_FUNCTION1. This means that the data matching functionality is not available in the implementation. Test the availability of data matching by writing and reading the DATAVMATCH bit in DWT_FUNCTION1. If it is not settable then data matching is unavailable. Note 5: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< Emit range field. Reserved to permit emitting offset when range match occurs. Reset clears the EMITRANGE bit. PC sampling is not supported when EMITRANGE is enabled. EMITRANGE only applies for: FUNCTION = b0001, b0010, b0011, b1100, b1101, b1110, and b1111.
        constexpr uint32_t CYCMATCH = (1U << 7);  ///< Only available in comparator 0. When set, this comparator compares against the clock cycle counter.
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< This bit is only available in comparator 1. When DATAVMATCH is set, this comparator performs data value compares. The comparators given by DATAVADDR0 and DATAVADDR1provide the address for the data comparison. If DATAVMATCH is set in DWT_FUNCTION1, the FUNCTION setting for the comparators given by DATAVADDR0 and DATAVADDR1 are overridden and those comparators only provide the address match for the data comparison.
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< DATAVADDR1 not supported
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Defines the size of the data in the COMP register that is to be matched:
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Identity of a linked address comparator for data value matching when DATAVMATCH == 1.
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< Identity of a second linked address comparator for data value matching when DATAVMATCH == 1 and LNK1ENA == 1.
        constexpr uint32_t MATCHED = (1U << 24);  ///< This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.
    }

    /// DWT_COMP2 Register bits
    namespace dwt_comp2_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Data value to compare against PC and the data address as given by DWT_FUNCTION2.
    }

    /// DWT_MASK2 Register bits
    namespace dwt_mask2_bits {
        constexpr uint32_t MASK = (4 << 0);  ///< Mask on data address when matching against COMP. This is the size of the ignore mask. hat is, DWT matching is performed as:(ADDR ANDed with (~0 left bit-shifted by MASK)) == COMP. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP is 3, this matches a word access of 0, because 3 would be within the word.
    }

    /// DWT_FUNCTION2 Register bits
    namespace dwt_function2_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< Emit range field. Reserved to permit emitting offset when range match occurs. Reset clears the EMITRANGE bit. PC sampling is not supported when EMITRANGE is enabled. EMITRANGE only applies for: FUNCTION = b0001, b0010, b0011, b1100, b1101, b1110, and b1111.
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< This bit is only available in comparator 1. When DATAVMATCH is set, this comparator performs data value compares. The comparators given by DATAVADDR0 and DATAVADDR1provide the address for the data comparison. If DATAVMATCH is set in DWT_FUNCTION1, the FUNCTION setting for the comparators given by DATAVADDR0 and DATAVADDR1 are overridden and those comparators only provide the address match for the data comparison.
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< DATAVADDR1 not supported
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Defines the size of the data in the COMP register that is to be matched:
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Identity of a linked address comparator for data value matching when DATAVMATCH == 1.
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< Identity of a second linked address comparator for data value matching when DATAVMATCH == 1 and LNK1ENA == 1.
        constexpr uint32_t MATCHED = (1U << 24);  ///< This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.
    }

    /// DWT_COMP3 Register bits
    namespace dwt_comp3_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Data value to compare against PC and the data address as given by DWT_FUNCTION3.
    }

    /// DWT_MASK3 Register bits
    namespace dwt_mask3_bits {
        constexpr uint32_t MASK = (4 << 0);  ///< Mask on data address when matching against COMP. This is the size of the ignore mask. hat is, DWT matching is performed as:(ADDR ANDed with (~0 left bit-shifted by MASK)) == COMP. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP is 3, this matches a word access of 0, because 3 would be within the word.
    }

    /// DWT_FUNCTION3 Register bits
    namespace dwt_function3_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
        constexpr uint32_t EMITRANGE = (1U << 5);  ///< Emit range field. Reserved to permit emitting offset when range match occurs. Reset clears the EMITRANGE bit. PC sampling is not supported when EMITRANGE is enabled. EMITRANGE only applies for: FUNCTION = b0001, b0010, b0011, b1100, b1101, b1110, and b1111.
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< This bit is only available in comparator 1. When DATAVMATCH is set, this comparator performs data value compares. The comparators given by DATAVADDR0 and DATAVADDR1provide the address for the data comparison. If DATAVMATCH is set in DWT_FUNCTION1, the FUNCTION setting for the comparators given by DATAVADDR0 and DATAVADDR1 are overridden and those comparators only provide the address match for the data comparison.
        constexpr uint32_t LNK1ENA = (1U << 9);  ///< DATAVADDR1 not supported
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Defines the size of the data in the COMP register that is to be matched:
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Identity of a linked address comparator for data value matching when DATAVMATCH == 1.
        constexpr uint32_t DATAVADDR1 = (4 << 16);  ///< Identity of a second linked address comparator for data value matching when DATAVMATCH == 1 and LNK1ENA == 1.
        constexpr uint32_t MATCHED = (1U << 24);  ///< This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.
    }

}

// ============================================================================
// FPB Peripheral
// ============================================================================

namespace fpb {
    /// Base addresses
    constexpr uint32_t FPB_BASE = 0xE0002000;

    /// FPB Register structure
    struct Registers {
        volatile uint32_t FP_CTRL;  ///< Offset: 0x00 - Flash Patch Control Register
        volatile uint32_t FP_REMAP;  ///< Offset: 0x04 - Flash Patch Remap Register
        volatile uint32_t FP_COMP0;  ///< Offset: 0x08 - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP1;  ///< Offset: 0x0C - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP2;  ///< Offset: 0x10 - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP3;  ///< Offset: 0x14 - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP4;  ///< Offset: 0x18 - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP5;  ///< Offset: 0x1C - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP6;  ///< Offset: 0x20 - Flash Patch Comparator Registers
        volatile uint32_t FP_COMP7;  ///< Offset: 0x24 - Flash Patch Comparator Registers
    };

    /// Peripheral instances
    inline Registers* FPB = reinterpret_cast<Registers*>(FPB_BASE);

    // Bit definitions
    /// FP_CTRL Register bits
    namespace fp_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Flash patch unit enable bit
        constexpr uint32_t KEY = (1U << 1);  ///< Key field. To write to the Flash Patch Control Register, you must write a 1 to this write-only bit.
        constexpr uint32_t NUM_CODE1 = (4 << 4);  ///< Number of code slots field.
        constexpr uint32_t NUM_LIT = (4 << 8);  ///< Number of literal slots field.
        constexpr uint32_t NUM_CODE2 = (2 << 12);  ///< Number of full banks of code comparators, sixteen comparators per bank. Where less than sixteen code comparators are provided, the bank count is zero, and the number present indicated by NUM_CODE. This read only field contains 3'b000 to indicate 0 banks for Cortex-M4 processor.
    }

    /// FP_REMAP Register bits
    namespace fp_remap_bits {
        constexpr uint32_t REMAP = (24 << 5);  ///< Remap base address field.
    }

    /// FP_COMP0 Register bits
    namespace fp_comp0_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 0. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP1 Register bits
    namespace fp_comp1_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 1. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP2 Register bits
    namespace fp_comp2_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 2. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP3 Register bits
    namespace fp_comp3_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 3. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP4 Register bits
    namespace fp_comp4_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 4. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP5 Register bits
    namespace fp_comp5_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 5. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP6 Register bits
    namespace fp_comp6_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 6. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

    /// FP_COMP7 Register bits
    namespace fp_comp7_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Compare and remap enable for Flash Patch Comparator Register 7. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
        constexpr uint32_t COMP = (27 << 2);  ///< Comparison address.
        constexpr uint32_t REPLACE = (2 << 30);  ///< This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
    }

}

// ============================================================================
// SystemControlSpace Peripheral
// ============================================================================

namespace systemcontrolspace {
    /// Base addresses
    constexpr uint32_t SystemControlSpace_BASE = 0xE000E000;

    /// SystemControlSpace Register structure
    struct Registers {
        volatile uint32_t FPCCR;  ///< Offset: 0xF34 - Floating Point Context Control Register
        volatile uint32_t FPCAR;  ///< Offset: 0xF38 - Floating-Point Context Address Register
        volatile uint32_t FPDSCR;  ///< Offset: 0xF3C - Floating Point Default Status Control Register
        volatile uint32_t MVFR0;  ///< Offset: 0xF40 - Media and FP Feature Register 0 (MVFR0)
        volatile uint32_t MVFR1;  ///< Offset: 0xF44 - Media and FP Feature Register 1 (MVFR1)
        volatile uint32_t MPU_TYPE;  ///< Offset: 0xD90 - MPU Type Register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0xD94 - MPU Control Register
        volatile uint32_t MPU_RNR;  ///< Offset: 0xD98 - MPU Region Number Register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0xD9C - MPU Region Base Address Register
        volatile uint32_t MPU_RASR;  ///< Offset: 0xDA0 - MPU Region Attribute and Size Register
        volatile uint32_t MPU_RBAR_A1;  ///< Offset: 0xDA4 - MPU Alias 1 Region Base Address register
        volatile uint32_t MPU_RASR_A1;  ///< Offset: 0xDA8 - MPU Alias 1 Region Attribute and Size register
        volatile uint32_t MPU_RBAR_A2;  ///< Offset: 0xDAC - MPU Alias 2 Region Base Address register
        volatile uint32_t MPU_RASR_A2;  ///< Offset: 0xDB0 - MPU Alias 2 Region Attribute and Size register
        volatile uint32_t MPU_RBAR_A3;  ///< Offset: 0xDB4 - MPU Alias 3 Region Base Address register
        volatile uint32_t MPU_RASR_A3;  ///< Offset: 0xDB8 - MPU Alias 3 Region Attribute and Size register
        volatile uint32_t DHCSR;  ///< Offset: 0xDF0 - Debug Halting Control and Status Register
        volatile uint32_t DCRSR;  ///< Offset: 0xDF4 - Deubg Core Register Selector Register
        volatile uint32_t DCRDR;  ///< Offset: 0xDF8 - Debug Core Register Data Register
        volatile uint32_t DEMCR;  ///< Offset: 0xDFC - Debug Exception and Monitor Control Register
        volatile uint32_t ICTR;  ///< Offset: 0x04 - Interrupt Control Type Register
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register
        volatile uint32_t ISER0;  ///< Offset: 0x100 - Irq 0 to 31 Set Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x104 - Irq 32 to 63 Set Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x180 - Irq 0 to 31 Clear Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x184 - Irq 32 to 63 Clear Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x200 - Irq 0 to 31 Set Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x204 - Irq 32 to 63 Set Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x280 - Irq 0 to 31 Clear Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x284 - Irq 32 to 63 Clear Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x300 - Irq 0 to 31 Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x304 - Irq 32 to 63 Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x400 - Irq 0 to 3 Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x404 - Irq 4 to 7 Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x408 - Irq 8 to 11 Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x40C - Irq 12 to 15 Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x410 - Irq 16 to 19 Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x414 - Irq 20 to 23 Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x418 - Irq 24 to 27 Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x41C - Irq 28 to 31 Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x420 - Irq 32 to 35 Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x424 - Irq 36 to 39 Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x428 - Irq 40 to 43 Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x42C - Irq 44 to 47 Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x430 - Irq 48 to 51 Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x434 - Irq 52 to 55 Priority Register
        volatile uint32_t IPR14;  ///< Offset: 0x438 - Irq 56 to 59 Priority Register
        volatile uint32_t IPR15;  ///< Offset: 0x43C - Irq 60 to 63 Priority Register
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Software Trigger Interrupt Register
        volatile uint32_t STCSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t STRVR;  ///< Offset: 0x14 - SysTick Reload Value Register
        volatile uint32_t STCVR;  ///< Offset: 0x18 - SysTick Current Value Register
        volatile uint32_t STCR;  ///< Offset: 0x1C - SysTick Calibration Value Register
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt/Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handlers 4-7 Priority Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handlers 8-11 Priority Register
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handlers 12-15 Priority Register
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Registers
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - Hard Fault Status Register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - Mem Manage Fault Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - Bus Fault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
        volatile uint32_t PFR0;  ///< Offset: 0xD40 - Processor Feature register0
        volatile uint32_t PFR1;  ///< Offset: 0xD44 - Processor Feature register1
        volatile uint32_t DFR0;  ///< Offset: 0xD48 - Debug Feature register0
        volatile uint32_t AFR0;  ///< Offset: 0xD4C - Auxiliary Feature register0
        volatile uint32_t MMFR0;  ///< Offset: 0xD50 - Memory Model Feature register0
        volatile uint32_t MMFR1;  ///< Offset: 0xD54 - Memory Model Feature register1
        volatile uint32_t MMFR2;  ///< Offset: 0xD58 - Memory Model Feature register2
        volatile uint32_t MMFR3;  ///< Offset: 0xD5C - Memory Model Feature register3
        volatile uint32_t ISAR0;  ///< Offset: 0xD60 - ISA Feature register0
        volatile uint32_t ISAR1;  ///< Offset: 0xD64 - ISA Feature register1
        volatile uint32_t ISAR2;  ///< Offset: 0xD68 - ISA Feature register2
        volatile uint32_t ISAR3;  ///< Offset: 0xD6C - ISA Feature register3
        volatile uint32_t ISAR4;  ///< Offset: 0xD70 - ISA Feature register4
        volatile uint32_t CPACR;  ///< Offset: 0xD88 - Coprocessor Access Control Register
    };

    /// Peripheral instances
    inline Registers* SystemControlSpace = reinterpret_cast<Registers*>(SystemControlSpace_BASE);

    // Bit definitions
    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t ASPEN = (1U << 31);  ///< Automatic State Preservation ENable. When this bit is set is will cause bit [2] of the Special CONTROL register to be set (FPCA) on execution of a floating point instruction which results in the floating point state automatically being preserved on exception entry.
        constexpr uint32_t LSPEN = (1U << 30);  ///< Lazy State Preservation ENable. When the processor performs a context save, space on the stack is reserved for the floating point state but it is not stacked until the new context performs a floating point operation.
        constexpr uint32_t MONRDY = (1U << 8);  ///< Indicates whether the the software executing when the processor allocated the FP stack frame was able to set the DebugMonitor exception to pending.
        constexpr uint32_t BFRDY = (1U << 6);  ///< Indicates whether the software executing when the processor allocated the FP stack frame was able to set the BusFault exception to pending.
        constexpr uint32_t MMRDY = (1U << 5);  ///< Indicates whether the software executing when the processor allocated the FP stack frame was able to set the MemManage exception to pending.
        constexpr uint32_t HFRDY = (1U << 4);  ///< Indicates whether the software executing when the processor allocated the FP stack frame was able to set the HardFault exception to pending.
        constexpr uint32_t THREAD = (1U << 3);  ///< Indicates the processor mode was Thread when it allocated the FP stack frame.
        constexpr uint32_t USER = (1U << 1);  ///< Indicates the privilege level of the software executing was User (Unpriviledged) when the processor allocated the FP stack frame.
        constexpr uint32_t LSPACT = (1U << 0);  ///< Indicates whether Lazy preservation of the FP state is active.
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 2);  ///< Holds the (double-word-aligned) location of the unpopulated floating-point register space allocated on an exception stack frame.
    }

    /// FPDSCR Register bits
    namespace fpdscr_bits {
        constexpr uint32_t AHP = (1U << 26);  ///< Default value for Alternative Half Precision bit. (If this bit is set to 1 then Alternative half-precision format is selected).
        constexpr uint32_t DN = (1U << 25);  ///< Default value for Default NaN mode bit. (If this bit is set to 1 then any operation involving one or more NaNs returns the Default NaN).
        constexpr uint32_t FZ = (1U << 24);  ///< Default value for Flush-to-Zero mode bit. (If this bit is set to 1 then Flush-to-zero mode is enabled).
        constexpr uint32_t RMODE = (2 << 22);  ///< Default value for Rounding Mode control field. (The encoding for this field is: 0b00 Round to Nearest (RN) mode, 0b01 Round towards Plus Infinity (RP) mode, 0b10 Round towards Minus Infinity (RM) mode, 0b11 Round towards Zero (RZ) mode. The specified rounding mode is used by almost all floating-point instructions).
    }

    /// MVFR0 Register bits
    namespace mvfr0_bits {
        constexpr uint32_t FP_ROUNDING_MODES = (4 << 28);  ///< Indicates the rounding modes supported by the FP floating-point hardware. The value of this field is: 0b0001 - all rounding modes supported.
        constexpr uint32_t SHORT_VECTORS = (4 << 24);  ///< Indicates the hardware support for FP short vectors. The value of this field is: 0b0000 - not supported in ARMv7-M.
        constexpr uint32_t SQUARE_ROOT = (4 << 20);  ///< Indicates the hardware support for FP square root operations. The value of this field is: 0b0001 - supported.
        constexpr uint32_t DIVIDE = (4 << 16);  ///< Indicates the hardware support for FP divide operations. The value of this field is: 0b0001 - supported.
        constexpr uint32_t FP_EXCEPTION_TRAPPING = (4 << 12);  ///< Indicates whether the FP hardware implementation supports exception trapping. The value of this field is: 0b0000 - not supported in ARMv7-M.
        constexpr uint32_t DOUBLE_PRECISION = (4 << 8);  ///< Indicates the hardware support for FP double-precision operations. The value of this field is: 0b0000 - not supported in ARMv7-M.
        constexpr uint32_t SINGLE_PRECISION = (4 << 4);  ///< Indicates the hardware support for FP single-precision operations. The value of this field is: 0b0010 - supported.
        constexpr uint32_t A_SIMD_REGISTERS = (4 << 0);  ///< Indicates the size of the FP register bank. The value of this field is: 0b0001 - supported, 16 x 64-bit registers.
    }

    /// MVFR1 Register bits
    namespace mvfr1_bits {
        constexpr uint32_t FP_FUSED_MAC = (4 << 28);  ///< Indicates whether the FP supports fused multiply accumulate operations. The value of this field is: 0b0001 - supported.
        constexpr uint32_t FP_HPFP = (4 << 24);  ///< Indicates whether the FP supports half-precision floating-point conversion operations. The value of this field is: 0b0001 - supported.
        constexpr uint32_t D_NAN_MODE = (4 << 4);  ///< Indicates whether the FP hardware implementation supports only the Default NaN mode. The value of this field is: 0b0001 - hardware supports propagation of NaN values.
        constexpr uint32_t FTZ_MODE = (4 << 0);  ///< Indicates whether the FP hardware implementation supports only the Flush-to-Zero mode of operation. The value of this field is: 0b0001 - hardware supports full denormalized number arithmetic.
    }

    /// MPU_TYPE Register bits
    namespace mpu_type_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Because the processor core uses only a unified MPU, SEPARATE is always 0.
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of supported MPU regions field. DREGION contains 0x08 if the implementation contains an MPU indicating eight MPU regions, otherwise it contains 0x00.
        constexpr uint32_t IREGION = (8 << 16);  ///< Because the processor core uses only a unified MPU, IREGION always contains 0x00.
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< MPU enable bit. Reset clears the ENABLE bit.
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< This bit enables the MPU when in Hard Fault, NMI, and FAULTMASK escalated handlers. If this bit = 1 and the ENABLE bit = 1, the MPU is enabled when in these handlers. If this bit = 0, the MPU is disabled when in these handlers, regardless of the value of ENABLE. If this bit =1 and ENABLE = 0, behavior is Unpredictable. Reset clears the HFNMIENA bit.
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< This bit enables the default memory map for privileged access, as a background region, when the MPU is enabled. The background region acts as if it was region number 1 before any settable regions. Any region that is set up overlays this default map, and overrides it. If this bit = 0, the default memory map is disabled, and memory not covered by a region faults. This applies to memory type, Execute Never (XN), cache and shareable rules. However, this only applies to privileged mode (fetch and data access). User mode code faults unless a region has been set up for its code and data. When the MPU is disabled, the default map acts on both privileged and user mode code. XN and SO rules always apply to the System partition whether this enable is set or not. If the MPU is disabled, this bit is ignored. Reset clears the PRIVDEFENA bit.
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< Region select field. Selects the region to operate on when using the Region Attribute and Size Register and the Region Base Address Register. It must be written first except when the address VALID + REGION fields are written, which overwrites this.
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region override field.
        constexpr uint32_t VALID = (1U << 4);  ///< MPU Region Number valid bit.
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field. The position of the LSB depends on the region size, so that the base address is aligned according to an even multiple of size. The power of 2 size specified by the SZENABLE field of the MPU Region Attribute and Size Register defines how many bits of base address are used.
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< MPU Protection Region Size Field.
        constexpr uint32_t SRD = (8 << 8);  ///< Sub-Region Disable (SRD) field. Setting an SRD bit disables the corresponding sub-region. Regions are split into eight equal-sized sub-regions. Sub-regions are not supported for region sizes of 128 bytes and less.
        constexpr uint32_t B = (1U << 16);  ///< Bufferable bit
        constexpr uint32_t C = (1U << 17);  ///< Cacheable bit
        constexpr uint32_t S = (1U << 18);  ///< Shareable bit
        constexpr uint32_t TEX = (3 << 19);  ///< Type extension field
        constexpr uint32_t AP = (3 << 24);  ///< Data access permission field
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

    /// DHCSR Register bits
    namespace dhcsr_bits {
        constexpr uint32_t C_DEBUGEN = (1U << 0);  ///< Enables debug. This can only be written by AHB-AP and not by the core. It is ignored when written by the core, which cannot set or clear it. The core must write a 1 to it when writing C_HALT to halt itself.
        constexpr uint32_t C_HALT = (1U << 1);  ///< Halts the core. This bit is set automatically when the core Halts. For example Breakpoint. This bit clears on core reset. This bit can only be written if C_DEBUGEN is 1, otherwise it is ignored. When setting this bit to 1, C_DEBUGEN must also be written to 1 in the same value (value[1:0] is 2'b11). The core can halt itself, but only if C_DEBUGEN is already 1 and only if it writes with b11).
        constexpr uint32_t C_STEP = (1U << 2);  ///< Steps the core in halted debug. When C_DEBUGEN = 0, this bit has no effect. Must only be modified when the processor is halted (S_HALT == 1).
        constexpr uint32_t C_MASKINTS = (1U << 3);  ///< Mask interrupts when stepping or running in halted debug. Does not affect NMI, which is not maskable. Must only be modified when the processor is halted (S_HALT == 1). Also does not affect fault exceptions and SVC caused by execution of the instructions. CMASKINTS must be set or cleared before halt is released. This means that the writes to set or clear C_MASKINTS and to set or clear C_HALT must be separate.
        constexpr uint32_t C_SNAPSTALL = (1U << 5);  ///< If the core is stalled on a load/store operation the stall ceases and the instruction is forced to complete. This enables Halting debug to gain control of the core. It can only be set if: C_DEBUGEN = 1 and C_HALT = 1. The core reads S_RETIRE_ST as 0. This indicates that no instruction has advanced. This prevents misuse. The bus state is Unpredictable when this is used. S_RETIRE can detect core stalls on load/store operations.
        constexpr uint32_t S_REGRDY = (1U << 16);  ///< Register Read/Write on the Debug Core Register Selector register is available. Last transfer is complete.
        constexpr uint32_t S_HALT = (1U << 17);  ///< The core is in debug state when S_HALT is set.
        constexpr uint32_t S_SLEEP = (1U << 18);  ///< Indicates that the core is sleeping (WFI, WFE, or SLEEP-ON-EXIT). Must use C_HALT to gain control or wait for interrupt to wake-up.
        constexpr uint32_t S_LOCKUP = (1U << 19);  ///< Reads as one if the core is running (not halted) and a lockup condition is present.
        constexpr uint32_t S_RETIRE_ST = (1U << 24);  ///< Indicates that an instruction has completed since last read. This is a sticky bit that clears on read. This determines if the core is stalled on a load/store or fetch.
        constexpr uint32_t S_RESET_ST = (1U << 25);  ///< Indicates that the core has been reset, or is now being reset, since the last time this bit was read. This a sticky bit that clears on read. So, reading twice and getting 1 then 0 means it was reset in the past. Reading twice and getting 1 both times means that it is being reset now (held in reset still).
    }

    /// DCRSR Register bits
    namespace dcrsr_bits {
        constexpr uint32_t REGSEL = (5 << 0);  ///< Register select
        constexpr uint32_t REGWNR = (1U << 16);  ///< Write = 1, Read = 0
    }

    /// DEMCR Register bits
    namespace demcr_bits {
        constexpr uint32_t VC_CORERESET = (1U << 0);  ///< Reset Vector Catch. Halt running system if Core reset occurs.
        constexpr uint32_t VC_MMERR = (1U << 4);  ///< Debug trap on Memory Management faults.
        constexpr uint32_t VC_NOCPERR = (1U << 5);  ///< Debug trap on Usage Fault access to Coprocessor that is not present or marked as not present in CAR register.
        constexpr uint32_t VC_CHKERR = (1U << 6);  ///< Debug trap on Usage Fault enabled checking errors.
        constexpr uint32_t VC_STATERR = (1U << 7);  ///< Debug trap on Usage Fault state errors.
        constexpr uint32_t VC_BUSERR = (1U << 8);  ///< Debug Trap on normal Bus error.
        constexpr uint32_t VC_INTERR = (1U << 9);  ///< Debug Trap on interrupt/exception service errors. These are a subset of other faults and catches before BUSERR or HARDERR.
        constexpr uint32_t VC_HARDERR = (1U << 10);  ///< Debug trap on Hard Fault.
        constexpr uint32_t MON_EN = (1U << 16);  ///< Enable the debug monitor. When enabled, the System handler priority register controls its priority level. If disabled, then all debug events go to Hard fault. C_DEBUGEN in the Debug Halting Control and Statue register overrides this bit. Vector catching is semi-synchronous. When a matching event is seen, a Halt is requested. Because the processor can only halt on an instruction boundary, it must wait until the next instruction boundary. As a result, it stops on the first instruction of the exception handler. However, two special cases exist when a vector catch has triggered: 1. If a fault is taken during vectoring, vector read or stack push error, the halt occurs on the corresponding fault handler, for the vector error or stack push. 2. If a late arriving interrupt comes in during vectoring, it is not taken. That is, an implementation that supports the late arrival optimization must suppress it in this case.
        constexpr uint32_t MON_PEND = (1U << 17);  ///< Pend the monitor to activate when priority permits. This can wake up the monitor through the AHB-AP port. It is the equivalent to C_HALT for Monitor debug. This register does not reset on a system reset. It is only reset by a POR reset. Software in the reset handler or later, or by the DAP must enable the debug monitor.
        constexpr uint32_t MON_STEP = (1U << 18);  ///< When MON_EN = 1, this steps the core. When MON_EN = 0, this bit is ignored. This is the equivalent to C_STEP. Interrupts are only stepped according to the priority of the monitor and settings of PRIMASK, FAULTMASK, or BASEPRI.
        constexpr uint32_t MON_REQ = (1U << 19);  ///< This enables the monitor to identify how it wakes up. This bit clears on a Core Reset.
        constexpr uint32_t TRCENA = (1U << 24);  ///< This bit must be set to 1 to enable use of the trace and debug blocks: Data Watchpoint and Trace (DWT), Instrumentation Trace Macrocell (ITM), Embedded Trace Macrocell (ETM), Trace Port Interface Unit (TPIU). This enables control of power usage unless tracing is required. The application can enable this, for ITM use, or use by a debugger. Note that if no debug or trace components are present in the implementation then it is not possible to set TRCENA.
    }

    /// ICTR Register bits
    namespace ictr_bits {
        constexpr uint32_t INTLINESNUM = (5 << 0);  ///< Total number of interrupt lines in groups of 32.
    }

    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disables interruption of multi-cycle instructions. This increases the interrupt latency of the processor becuase LDM/STM completes before interrupt stacking occurs.
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disables write buffer us during default memorty map accesses. This causes all bus faults to be precise bus faults but decreases the performance of the processor because the stores to memory have to complete before the next instruction can be executed.
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disables IT folding.
        constexpr uint32_t DISFPCA = (1U << 8);  ///< Disable automatic update of CONTROL.FPCA
        constexpr uint32_t DISOOFP = (1U << 9);  ///< Disables floating point instructions completing out of order with respect to integer instructions.
    }

    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Writing 0 to a SETENA bit has no effect, writing 1 to a bit enables the corresponding interrupt. Reading the bit returns its current enable state. Reset clears the SETENA fields.
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Writing 0 to a SETENA bit has no effect, writing 1 to a bit enables the corresponding interrupt. Reading the bit returns its current enable state. Reset clears the SETENA fields.
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Writing 0 to a CLRENA bit has no effect, writing 1 to a bit disables the corresponding interrupt. Reading the bit returns its current enable state. Reset clears the CLRENA field.
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Writing 0 to a CLRENA bit has no effect, writing 1 to a bit disables the corresponding interrupt. Reading the bit returns its current enable state. Reset clears the CLRENA field.
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Writing 0 to a SETPEND bit has no effect, writing 1 to a bit pends the corresponding interrupt. Reading the bit returns its current state.
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Writing 0 to a SETPEND bit has no effect, writing 1 to a bit pends the corresponding interrupt. Reading the bit returns its current state.
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Writing 0 to a CLRPEND bit has no effect, writing 1 to a bit clears the corresponding pending interrupt. Reading the bit returns its current state.
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Writing 0 to a CLRPEND bit has no effect, writing 1 to a bit clears the corresponding pending interrupt. Reading the bit returns its current state.
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags. Reading 0 implies the interrupt is not active or stacked. Reading 1 implies the interrupt is active or pre-empted and stacked.
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags. Reading 0 implies the interrupt is not active or stacked. Reading 1 implies the interrupt is active or pre-empted and stacked.
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< Priority of interrupt 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< Priority of interrupt 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< Priority of interrupt 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< Priority of interrupt 3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of interrupt 4
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of interrupt 5
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of interrupt 6
        constexpr uint32_t PRI_7 = (8 << 24);  ///< Priority of interrupt 7
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t PRI_8 = (8 << 0);  ///< Priority of interrupt 8
        constexpr uint32_t PRI_9 = (8 << 8);  ///< Priority of interrupt 9
        constexpr uint32_t PRI_10 = (8 << 16);  ///< Priority of interrupt 10
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of interrupt 11
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t PRI_12 = (8 << 0);  ///< Priority of interrupt 12
        constexpr uint32_t PRI_13 = (8 << 8);  ///< Priority of interrupt 13
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of interrupt 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of interrupt 15
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t PRI_16 = (8 << 0);  ///< Priority of interrupt 16
        constexpr uint32_t PRI_17 = (8 << 8);  ///< Priority of interrupt 17
        constexpr uint32_t PRI_18 = (8 << 16);  ///< Priority of interrupt 18
        constexpr uint32_t PRI_19 = (8 << 24);  ///< Priority of interrupt 19
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t PRI_20 = (8 << 0);  ///< Priority of interrupt 20
        constexpr uint32_t PRI_21 = (8 << 8);  ///< Priority of interrupt 21
        constexpr uint32_t PRI_22 = (8 << 16);  ///< Priority of interrupt 22
        constexpr uint32_t PRI_23 = (8 << 24);  ///< Priority of interrupt 23
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t PRI_24 = (8 << 0);  ///< Priority of interrupt 24
        constexpr uint32_t PRI_25 = (8 << 8);  ///< Priority of interrupt 25
        constexpr uint32_t PRI_26 = (8 << 16);  ///< Priority of interrupt 26
        constexpr uint32_t PRI_27 = (8 << 24);  ///< Priority of interrupt 27
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t PRI_28 = (8 << 0);  ///< Priority of interrupt 28
        constexpr uint32_t PRI_29 = (8 << 8);  ///< Priority of interrupt 29
        constexpr uint32_t PRI_30 = (8 << 16);  ///< Priority of interrupt 30
        constexpr uint32_t PRI_31 = (8 << 24);  ///< Priority of interrupt 31
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t PRI_32 = (8 << 0);  ///< Priority of interrupt 32
        constexpr uint32_t PRI_33 = (8 << 8);  ///< Priority of interrupt 33
        constexpr uint32_t PRI_34 = (8 << 16);  ///< Priority of interrupt 34
        constexpr uint32_t PRI_35 = (8 << 24);  ///< Priority of interrupt 35
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t PRI_36 = (8 << 0);  ///< Priority of interrupt 36
        constexpr uint32_t PRI_37 = (8 << 8);  ///< Priority of interrupt 37
        constexpr uint32_t PRI_38 = (8 << 16);  ///< Priority of interrupt 38
        constexpr uint32_t PRI_39 = (8 << 24);  ///< Priority of interrupt 39
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t PRI_40 = (8 << 0);  ///< Priority of interrupt 40
        constexpr uint32_t PRI_41 = (8 << 8);  ///< Priority of interrupt 41
        constexpr uint32_t PRI_42 = (8 << 16);  ///< Priority of interrupt 42
        constexpr uint32_t PRI_43 = (8 << 24);  ///< Priority of interrupt 43
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t PRI_44 = (8 << 0);  ///< Priority of interrupt 44
        constexpr uint32_t PRI_45 = (8 << 8);  ///< Priority of interrupt 45
        constexpr uint32_t PRI_46 = (8 << 16);  ///< Priority of interrupt 46
        constexpr uint32_t PRI_47 = (8 << 24);  ///< Priority of interrupt 47
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t PRI_48 = (8 << 0);  ///< Priority of interrupt 48
        constexpr uint32_t PRI_49 = (8 << 8);  ///< Priority of interrupt 49
        constexpr uint32_t PRI_50 = (8 << 16);  ///< Priority of interrupt 50
        constexpr uint32_t PRI_51 = (8 << 24);  ///< Priority of interrupt 51
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t PRI_52 = (8 << 0);  ///< Priority of interrupt 52
        constexpr uint32_t PRI_53 = (8 << 8);  ///< Priority of interrupt 53
        constexpr uint32_t PRI_54 = (8 << 16);  ///< Priority of interrupt 54
        constexpr uint32_t PRI_55 = (8 << 24);  ///< Priority of interrupt 55
    }

    /// IPR14 Register bits
    namespace ipr14_bits {
        constexpr uint32_t PRI_56 = (8 << 0);  ///< Priority of interrupt 56
        constexpr uint32_t PRI_57 = (8 << 8);  ///< Priority of interrupt 57
        constexpr uint32_t PRI_58 = (8 << 16);  ///< Priority of interrupt 58
        constexpr uint32_t PRI_59 = (8 << 24);  ///< Priority of interrupt 59
    }

    /// IPR15 Register bits
    namespace ipr15_bits {
        constexpr uint32_t PRI_60 = (8 << 0);  ///< Priority of interrupt 60
        constexpr uint32_t PRI_61 = (8 << 8);  ///< Priority of interrupt 61
        constexpr uint32_t PRI_62 = (8 << 16);  ///< Priority of interrupt 62
        constexpr uint32_t PRI_63 = (8 << 24);  ///< Priority of interrupt 63
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID field. Writing a value to the INTID field is the same as manually pending an interrupt by setting the corresponding interrupt bit in an Interrupt Set Pending Register.
    }

    /// STCSR Register bits
    namespace stcsr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable SysTick counter
        constexpr uint32_t TICKINT = (1U << 1);  ///< Counting down to zero does not pend the SysTick handler. Software can use COUNTFLAG to determine if the SysTick handler has ever counted to zero.
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source.
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Returns 1 if timer counted to 0 since last time this was read. Clears on read by application of any part of the SysTick Control and Status Register. If read by the debugger using the DAP, this bit is cleared on read-only if the MasterType bit in the AHB-AP Control Register is set to 0. Otherwise, the COUNTFLAG bit is not changed by the debugger read.
    }

    /// STRVR Register bits
    namespace strvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the SysTick Current Value Register when the counter reaches 0.
    }

    /// STCVR Register bits
    namespace stcvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current value at the time the register is accessed. No read-modify-write protection is provided, so change with care. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.
    }

    /// STCR Register bits
    namespace stcr_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Reads as zero. Indicates calibration value is not known.
        constexpr uint32_t SKEW = (1U << 30);  ///< Reads as one. The calibration value is not exactly 10ms because of clock frequency. This could affect its suitability as a software real time clock.
        constexpr uint32_t NOREF = (1U << 31);  ///< Reads as one. Indicates that no separate reference clock is provided.
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Implementation defined revision number.
        constexpr uint32_t PARTNO = (12 << 4);  ///< Number of processor within family.
        constexpr uint32_t CONSTANT = (4 << 16);  ///< Reads as 0xC
        constexpr uint32_t VARIANT = (4 << 20);  ///< Implementation defined variant number.
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementor code.
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active ISR number field. Reset clears the VECTACTIVE field.
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< This bit is 1 when the set of all active exceptions minus the IPSR_current_exception yields the empty set.
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Pending ISR number field. VECTPENDING contains the interrupt number of the highest priority pending ISR.
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag. Excludes NMI and faults.
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< You must only use this at debug time. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced.
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< Clear pending SysTick bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< Set a pending SysTick bit.
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< Clear pending pendSV bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< Set pending pendSV bit.
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< Set pending NMI bit. NMIPENDSET pends and activates an NMI. Because NMI is the highest-priority interrupt, it takes effect as soon as it registers.
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (22 << 7);  ///< Vector table base offset field. Contains the offset of the table base from the bottom of the SRAM or CODE space.
        constexpr uint32_t TBLBASE = (1U << 29);  ///< Table base is in Code (0) or RAM (1).
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< System Reset bit. Resets the system, with the exception of debug components. The VECTRESET bit self-clears. Reset clears the VECTRESET bit. For debugging, only write this bit when the core is halted.
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Clears all active state information for active NMI, fault, and interrupts. It is the responsibility of the application to reinitialize the stack. The VECTCLRACTIVE bit is for returning to a known state during debug. The VECTCLRACTIVE bit self-clears. IPSR is not cleared by this operation. So, if used by an application, it must only be used at the base level of activation, or within a system handler whose active bit can be set.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< Causes a signal to be asserted to the outer system that indicates a reset is requested. Intended to force a large system reset of all major components except for debug. Setting this bit does not prevent Halting Debug from running.
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field. The PRIGROUP field is a binary point position indicator for creating subpriorities for exceptions that share the same pre-emption level. It divides the PRI_n field in the Interrupt Priority Register into a pre-emption level and a subpriority level. The binary point is a left-of value. This means that the PRIGROUP value represents a point starting at the left of the Least Significant Bit (LSB). This is bit [0] of 7:0. The lowest value might not be 0 depending on the number of bits allocated for priorities, and implementation choices
        constexpr uint32_t ENDIANESS = (1U << 15);  ///< Data endianness bit. ENDIANNESS is sampled from the BIGEND input port during reset. You cannot change ENDIANNESS outside of reset.
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key. Writing to this register requires 0x5FA in the VECTKEY field. Otherwise the write value is ignored.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< Sleep on exit when returning from Handler mode to Thread mode. Enables interrupt driven applications to avoid returning to empty main application.
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< Sleep deep bit.
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< When enabled, this causes WFE to wake up when an interrupt moves from inactive to pended. Otherwise, WFE only wakes up from an event signal, external and SEV instruction generated. The event input, RXEV, is registered even when not waiting for an event, and so effects the next WFE.
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHREDENA = (1U << 0);  ///< When 0, default, It is only possible to enter Thread mode when returning from the last exception. When set to 1, Thread mode can be entered from any level in Handler mode by controlled return value.
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< If written as 1, enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception, which is one associated with the Main stack pointer.
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Trap for unaligned access. This enables faulting/halting on any unaligned half or full word access. Unaligned load-store multiples always fault. The relevant Usage Fault Status Register bit is UNALIGNED.
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Trap on Divide by 0. This enables faulting/halting when an attempt is made to divide by 0. The relevant Usage Fault Status Register bit is DIVBYZERO.
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< When enabled, this causes handlers running at priority -1 and -2 (Hard Fault, NMI, and FAULTMASK escalated handlers) to ignore Data Bus faults caused by load and store instructions. When disabled, these bus faults cause a lock-up. You must only use this enable with extreme caution. All data bus faults are ignored therefore you must only use it when the handler and its data are in absolutely safe memory. Its normal use is to probe system devices and bridges to detect control path problems and fix them.
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Stack alignment bit.
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4.
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5.
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6.
        constexpr uint32_t PRI_7 = (8 << 24);  ///< Priority of system handler 7.
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_8 = (8 << 0);  ///< Priority of system handler 8.
        constexpr uint32_t PRI_9 = (8 << 8);  ///< Priority of system handler 9.
        constexpr uint32_t PRI_10 = (8 << 16);  ///< Priority of system handler 10.
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11.
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_12 = (8 << 0);  ///< Priority of system handler 12.
        constexpr uint32_t PRI_13 = (8 << 8);  ///< Priority of system handler 13.
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14.
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15.
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< MemManage active flag.
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< BusFault active flag.
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< UsageFault active flag.
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVCall active flag.
        constexpr uint32_t MONITORACT = (1U << 8);  ///< the Monitor active flag.
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV active flag.
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick active flag.
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< usage fault pended flag.
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< MemManage pended flag.
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< BusFault pended flag.
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVCall pended flag.
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< MemManage fault system handler enable
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< Bus fault system handler enable
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< Usage fault system handler enable
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< Instruction access violation flag. Attempting to fetch an instruction from a location that does not permit execution sets the IACCVIOL flag. This occurs on any access to an XN region, even when the MPU is disabled or not present. The return PC points to the faulting instruction. The MMAR is not written.
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< Data access violation flag. Attempting to load or store at a location that does not permit the operation sets the DACCVIOL flag. The return PC points to the faulting instruction. This error loads MMAR with the address of the attempted access.
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< Unstack from exception return has caused one or more access violations. This is chained to the handler, so that the original return stack is still present. SP is not adjusted from failing return and new save is not performed. The MMAR is not written.
        constexpr uint32_t MSTKERR = (1U << 4);  ///< Stacking from exception has caused one or more access violations. The SP is still adjusted and the values in the context area on the stack might be incorrect. The MMAR is not written.
        constexpr uint32_t MMARVALID = (1U << 7);  ///< Memory Manage Address Register (MMAR) address valid flag. A later-arriving fault, such as a bus fault, can clear a memory manage fault.. If a MemManage fault occurs that is escalated to a Hard Fault because of priority, the Hard Fault handler must clear this bit. This prevents problems on return to a stacked active MemManage handler whose MMAR value has been overwritten.
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error flag. The IBUSERR flag is set by a prefetch error. The fault stops on the instruction, so if the error occurs under a branch shadow, no fault occurs. The BFAR is not written.
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error return.
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error. It is a BusFault, but the Return PC is not related to the causing instruction. This is not a synchronous fault. So, if detected when the priority of the current activation is higher than the Bus Fault, it only pends. Bus fault activates when returning to a lower priority activation. If a precise fault occurs before returning to a lower priority exception, the handler detects both IMPRECISERR set and one of the precise fault status bits set at the same time. The BFAR is not written.
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< Unstack from exception return has caused one or more bus faults. This is chained to the handler, so that the original return stack is still present. SP is not adjusted from failing return and new save is not performed. The BFAR is not written.
        constexpr uint32_t STKERR = (1U << 12);  ///< Stacking from exception has caused one or more bus faults. The SP is still adjusted and the values in the context area on the stack might be incorrect. The BFAR is not written.
        constexpr uint32_t BFARVALID = (1U << 15);  ///< This bit is set if the Bus Fault Address Register (BFAR) contains a valid address. This is true after a bus fault where the address is known. Other faults can clear this bit, such as a Mem Manage fault occurring later. If a Bus fault occurs that is escalated to a Hard Fault because of priority, the Hard Fault handler must clear this bit. This prevents problems if returning to a stacked active Bus fault handler whose BFAR value has been overwritten.
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< The UNDEFINSTR flag is set when the processor attempts to execute an undefined instruction. This is an instruction that the processor cannot decode. The return PC points to the undefined instruction.
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid combination of EPSR and instruction, for reasons other than UNDEFINED instruction. Return PC points to faulting instruction, with the invalid state.
        constexpr uint32_t INVPC = (1U << 18);  ///< Attempt to load EXC_RETURN into PC illegally. Invalid instruction, invalid context, invalid value. The return PC points to the instruction that tried to set the PC.
        constexpr uint32_t NOCP = (1U << 19);  ///< Attempt to use a coprocessor instruction. The processor does not support coprocessor instructions.
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< When UNALIGN_TRP is enabled (see Configuration Control Register on page 8-26), and there is an attempt to make an unaligned memory access, then this fault occurs. Unaligned LDM/STM/LDRD/STRD instructions always fault irrespective of the setting of UNALIGN_TRP.
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< When DIV_0_TRP (see Configuration Control Register on page 8-26) is enabled and an SDIV or UDIV instruction is used with a divisor of 0, this fault occurs The instruction is executed and the return PC points to it. If DIV_0_TRP is not set, then the divide returns a quotient of 0.
        constexpr uint32_t MLSPERR = (1U << 5);  ///< Indicates if MemManage fault occurred during FP lazy state preservation.
        constexpr uint32_t LSPERR = (1U << 13);  ///< Indicates if bus fault occurred during FP lazy state preservation.
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< This bit is set if there is a fault because of vector table read on exception processing (Bus Fault). This case is always a Hard Fault. The return PC points to the pre-empted instruction.
        constexpr uint32_t FORCED = (1U << 30);  ///< Hard Fault activated because a Configurable Fault was received and cannot activate because of priority or because the Configurable Fault is disabled. The Hard Fault handler then has to read the other fault status registers to determine cause.
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< This bit is set if there is a fault related to debug. This is only possible when halting debug is not enabled. For monitor enabled debug, it only happens for BKPT when the current priority is higher than the monitor. When both halting and monitor debug are disabled, it only happens for debug events that are not ignored (minimally, BKPT). The Debug Fault Status Register is updated.
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< Halt request flag. The processor is halted on the next instruction.
        constexpr uint32_t BKPT = (1U << 1);  ///< BKPT flag. The BKPT flag is set by a BKPT instruction in flash patch code, and also by normal code. Return PC points to breakpoint containing instruction.
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< Data Watchpoint and Trace (DWT) flag. The processor stops at the current instruction or at the next instruction.
        constexpr uint32_t VCATCH = (1U << 3);  ///< Vector catch flag. When the VCATCH flag is set, a flag in one of the local fault status registers is also set to indicate the type of fault.
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< External debug request flag. The processor stops on next instruction boundary.
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Mem Manage fault address field. ADDRESS is the data address of a faulted load or store attempt. When an unaligned access faults, the address is the actual address that faulted. Because an access can be split into multiple parts, each aligned, this address can be any offset in the range of the requested size. Flags in the Memory Manage Fault Status Register indicate the cause of the fault
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Bus fault address field. ADDRESS is the data address of a faulted load or store attempt. When an unaligned access faults, the address is the address requested by the instruction, even if that is not the address that faulted. Flags in the Bus Fault Status Register indicate the cause of the fault
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t IMPDEF = (32 << 0);  ///< Implementation defined. The bits map directly onto the signal assignment to the AUXFAULT inputs.
    }

    /// PFR0 Register bits
    namespace pfr0_bits {
        constexpr uint32_t STATE0 = (4 << 0);  ///< State0 (T-bit == 0)
        constexpr uint32_t STATE1 = (4 << 4);  ///< State1 (T-bit == 1)
    }

    /// PFR1 Register bits
    namespace pfr1_bits {
        constexpr uint32_t MICROCONTROLLER_PROGRAMMERS_MODEL = (4 << 8);  ///< Microcontroller programmer's model
    }

    /// DFR0 Register bits
    namespace dfr0_bits {
        constexpr uint32_t MICROCONTROLLER_DEBUG_MODEL = (4 << 20);  ///< Microcontroller Debug Model - memory mapped
    }

    /// MMFR0 Register bits
    namespace mmfr0_bits {
        constexpr uint32_t PMSA_SUPPORT = (4 << 4);  ///< PMSA support
        constexpr uint32_t CACHE_COHERENCE_SUPPORT = (4 << 8);  ///< Cache coherence support
        constexpr uint32_t OUTER_NON_SHARABLE_SUPPORT = (4 << 12);  ///< Outer non-sharable support
        constexpr uint32_t AUXILIARY_REGISTER_SUPPORT = (4 << 20);  ///< Auxiliary register support
    }

    /// MMFR2 Register bits
    namespace mmfr2_bits {
        constexpr uint32_t WAIT_FOR_INTERRUPT_STALLING = (4 << 24);  ///< wait for interrupt stalling
    }

    /// ISAR0 Register bits
    namespace isar0_bits {
        constexpr uint32_t BITCOUNT_INSTRS = (4 << 4);  ///< BitCount instructions
        constexpr uint32_t BITFIELD_INSTRS = (4 << 8);  ///< BitField instructions
        constexpr uint32_t CMPBRANCH_INSTRS = (4 << 12);  ///< CmpBranch instructions
        constexpr uint32_t COPROC_INSTRS = (4 << 16);  ///< Coprocessor instructions
        constexpr uint32_t DEBUG_INSTRS = (4 << 20);  ///< Debug instructions
        constexpr uint32_t DIVIDE_INSTRS = (4 << 24);  ///< Divide instructions
    }

    /// ISAR1 Register bits
    namespace isar1_bits {
        constexpr uint32_t EXTEND_INSRS = (4 << 12);  ///< Extend instructions. Note that the shift options on these instructions are also controlled by the WithShifts_instrs attribute.
        constexpr uint32_t IFTHEN_INSTRS = (4 << 16);  ///< IfThen instructions
        constexpr uint32_t IMMEDIATE_INSTRS = (4 << 20);  ///< Immediate instructions
        constexpr uint32_t INTERWORK_INSTRS = (4 << 24);  ///< Interwork instructions
    }

    /// ISAR2 Register bits
    namespace isar2_bits {
        constexpr uint32_t LOADSTORE_INSTRS = (4 << 0);  ///< LoadStore instructions
        constexpr uint32_t MEMHINT_INSTRS = (4 << 4);  ///< MemoryHint instructions
        constexpr uint32_t MULTIACCESSINT_INSTRS = (4 << 8);  ///< Multi-Access interruptible instructions
        constexpr uint32_t MULT_INSTRS = (4 << 12);  ///< Multiply instructions
        constexpr uint32_t MULTS_INSTRS = (4 << 16);  ///< Multiply instructions (advanced, signed)
        constexpr uint32_t MULTU_INSTRS = (4 << 20);  ///< Multiply instructions (advanced, unsigned)
        constexpr uint32_t REVERSAL_INSTRS = (4 << 28);  ///< Reversal instructions
    }

    /// ISAR3 Register bits
    namespace isar3_bits {
        constexpr uint32_t SATRUATE_INSTRS = (4 << 0);  ///< Saturate instructions
        constexpr uint32_t SIMD_INSTRS = (4 << 4);  ///< SIMD instructions
        constexpr uint32_t SVC_INSTRS = (4 << 8);  ///< SVC instructions
        constexpr uint32_t SYNCPRIM_INSTRS = (4 << 12);  ///< SyncPrim instructions. Note there are no LDREXD or STREXD in ARMv7-M. This attribute is used in conjunction with the SyncPrim_instrs_frac attribute in ID_ISAR4[23:20].
        constexpr uint32_t TABBRANCH_INSTRS = (4 << 16);  ///< TableBranch instructions
        constexpr uint32_t THUMBCOPY_INSTRS = (4 << 20);  ///< ThumbCopy instructions
        constexpr uint32_t TRUENOP_INSTRS = (4 << 24);  ///< TrueNOP instructions
    }

    /// ISAR4 Register bits
    namespace isar4_bits {
        constexpr uint32_t UNPRIV_INSTRS = (4 << 0);  ///< Unprivileged instructions
        constexpr uint32_t WITHSHIFTS_INSTRS = (4 << 4);  ///< WithShift instructions. Note that all additions only apply in cases where the encoding supports them - e.g. there is no difference between levels 3 and 4 in the Thumb-2 instruction set. Also note that MOV instructions with shift options should instead be treated as ASR, LSL, LSR, ROR or RRX instructions.
        constexpr uint32_t WRITEBACK_INSTRS = (4 << 8);  ///< Writeback instructions
        constexpr uint32_t BARRIER_INSTRS = (4 << 16);  ///< Barrier instructions
        constexpr uint32_t SYNCPRIM_INSTRS_FRAC = (4 << 20);  ///< SyncPrim_instrs_frac
        constexpr uint32_t PSR_M_INSTRS = (4 << 24);  ///< PSR_M_instrs
    }

    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP11 = (2 << 22);  ///< Access privileges for coprocessor 11. The possible values of each field are: 0b00 = Access denied. Any attempted access generates a NOCP UsageFault. 0b01 = Privileged access only. An unprivileged access generates a NOCP UsageFault. 0b10 = Reserved. 0b11 = Full access. Used in conjunction with the control for CP10, this controls access to the Floating Point Coprocessor.
        constexpr uint32_t CP10 = (2 << 20);  ///< Access privileges for coprocessor 10. The possible values of each field are: 0b00 = Access denied. Any attempted access generates a NOCP UsageFault. 0b01 = Privileged access only. An unprivileged access generates a NOCP UsageFault. 0b10 = Reserved. 0b11 = Full access. Used in conjunction with the control for CP11, this controls access to the Floating Point Coprocessor.
    }

}

// ============================================================================
// RSTCTL Peripheral
// ============================================================================

namespace rstctl {
    /// Base addresses
    constexpr uint32_t RSTCTL_BASE = 0xE0042000;

    /// RSTCTL Register structure
    struct Registers {
        volatile uint32_t RSTCTL_RESET_REQ;  ///< Offset: 0x00 - Reset Request Register
        volatile uint32_t RSTCTL_HARDRESET_STAT;  ///< Offset: 0x04 - Hard Reset Status Register
        volatile uint32_t RSTCTL_HARDRESET_CLR;  ///< Offset: 0x08 - Hard Reset Status Clear Register
        volatile uint32_t RSTCTL_HARDRESET_SET;  ///< Offset: 0x0C - Hard Reset Status Set Register
        volatile uint32_t RSTCTL_SOFTRESET_STAT;  ///< Offset: 0x10 - Soft Reset Status Register
        volatile uint32_t RSTCTL_SOFTRESET_CLR;  ///< Offset: 0x14 - Soft Reset Status Clear Register
        volatile uint32_t RSTCTL_SOFTRESET_SET;  ///< Offset: 0x18 - Soft Reset Status Set Register
        volatile uint32_t RSTCTL_PSSRESET_STAT;  ///< Offset: 0x100 - PSS Reset Status Register
        volatile uint32_t RSTCTL_PSSRESET_CLR;  ///< Offset: 0x104 - PSS Reset Status Clear Register
        volatile uint32_t RSTCTL_PCMRESET_STAT;  ///< Offset: 0x108 - PCM Reset Status Register
        volatile uint32_t RSTCTL_PCMRESET_CLR;  ///< Offset: 0x10C - PCM Reset Status Clear Register
        volatile uint32_t RSTCTL_PINRESET_STAT;  ///< Offset: 0x110 - Pin Reset Status Register
        volatile uint32_t RSTCTL_PINRESET_CLR;  ///< Offset: 0x114 - Pin Reset Status Clear Register
        volatile uint32_t RSTCTL_REBOOTRESET_STAT;  ///< Offset: 0x118 - Reboot Reset Status Register
        volatile uint32_t RSTCTL_REBOOTRESET_CLR;  ///< Offset: 0x11C - Reboot Reset Status Clear Register
        volatile uint32_t RSTCTL_CSRESET_STAT;  ///< Offset: 0x120 - CS Reset Status Register
        volatile uint32_t RSTCTL_CSRESET_CLR;  ///< Offset: 0x124 - CS Reset Status Clear Register
    };

    /// Peripheral instances
    inline Registers* RSTCTL = reinterpret_cast<Registers*>(RSTCTL_BASE);

    // Bit definitions
    /// RSTCTL_RESET_REQ Register bits
    namespace rstctl_reset_req_bits {
        constexpr uint32_t SOFT_REQ = (1U << 0);  ///< Soft Reset request
        constexpr uint32_t HARD_REQ = (1U << 1);  ///< Hard Reset request
        constexpr uint32_t RSTKEY = (8 << 8);  ///< Write key to unlock reset request bits
    }

    /// RSTCTL_HARDRESET_STAT Register bits
    namespace rstctl_hardreset_stat_bits {
        constexpr uint32_t SRC0 = (1U << 0);  ///< Indicates that SRC0 was the source of the Hard Reset
        constexpr uint32_t SRC1 = (1U << 1);  ///< Indicates that SRC1 was the source of the Hard Reset
        constexpr uint32_t SRC2 = (1U << 2);  ///< Indicates that SRC2 was the source of the Hard Reset
        constexpr uint32_t SRC3 = (1U << 3);  ///< Indicates that SRC3 was the source of the Hard Reset
        constexpr uint32_t SRC4 = (1U << 4);  ///< Indicates that SRC4 was the source of the Hard Reset
        constexpr uint32_t SRC5 = (1U << 5);  ///< Indicates that SRC5 was the source of the Hard Reset
        constexpr uint32_t SRC6 = (1U << 6);  ///< Indicates that SRC6 was the source of the Hard Reset
        constexpr uint32_t SRC7 = (1U << 7);  ///< Indicates that SRC7 was the source of the Hard Reset
        constexpr uint32_t SRC8 = (1U << 8);  ///< Indicates that SRC8 was the source of the Hard Reset
        constexpr uint32_t SRC9 = (1U << 9);  ///< Indicates that SRC9 was the source of the Hard Reset
        constexpr uint32_t SRC10 = (1U << 10);  ///< Indicates that SRC10 was the source of the Hard Reset
        constexpr uint32_t SRC11 = (1U << 11);  ///< Indicates that SRC11 was the source of the Hard Reset
        constexpr uint32_t SRC12 = (1U << 12);  ///< Indicates that SRC12 was the source of the Hard Reset
        constexpr uint32_t SRC13 = (1U << 13);  ///< Indicates that SRC13 was the source of the Hard Reset
        constexpr uint32_t SRC14 = (1U << 14);  ///< Indicates that SRC14 was the source of the Hard Reset
        constexpr uint32_t SRC15 = (1U << 15);  ///< Indicates that SRC15 was the source of the Hard Reset
    }

    /// RSTCTL_HARDRESET_CLR Register bits
    namespace rstctl_hardreset_clr_bits {
        constexpr uint32_t SRC0 = (1U << 0);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC1 = (1U << 1);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC2 = (1U << 2);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC3 = (1U << 3);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC4 = (1U << 4);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC5 = (1U << 5);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC6 = (1U << 6);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC7 = (1U << 7);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC8 = (1U << 8);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC9 = (1U << 9);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC10 = (1U << 10);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC11 = (1U << 11);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC12 = (1U << 12);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC13 = (1U << 13);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC14 = (1U << 14);  ///< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT
        constexpr uint32_t SRC15 = (1U << 15);  ///< Write 1 clears the corresponding bit in the RSTCTL_HRDRESETSTAT_REG
    }

    /// RSTCTL_HARDRESET_SET Register bits
    namespace rstctl_hardreset_set_bits {
        constexpr uint32_t SRC0 = (1U << 0);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC1 = (1U << 1);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC2 = (1U << 2);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC3 = (1U << 3);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC4 = (1U << 4);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC5 = (1U << 5);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC6 = (1U << 6);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC7 = (1U << 7);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC8 = (1U << 8);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC9 = (1U << 9);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC10 = (1U << 10);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC11 = (1U << 11);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC12 = (1U << 12);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC13 = (1U << 13);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC14 = (1U << 14);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
        constexpr uint32_t SRC15 = (1U << 15);  ///< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and initiates a Hard Reset)
    }

    /// RSTCTL_SOFTRESET_STAT Register bits
    namespace rstctl_softreset_stat_bits {
        constexpr uint32_t SRC0 = (1U << 0);  ///< If 1, indicates that SRC0 was the source of the Soft Reset
        constexpr uint32_t SRC1 = (1U << 1);  ///< If 1, indicates that SRC1 was the source of the Soft Reset
        constexpr uint32_t SRC2 = (1U << 2);  ///< If 1, indicates that SRC2 was the source of the Soft Reset
        constexpr uint32_t SRC3 = (1U << 3);  ///< If 1, indicates that SRC3 was the source of the Soft Reset
        constexpr uint32_t SRC4 = (1U << 4);  ///< If 1, indicates that SRC4 was the source of the Soft Reset
        constexpr uint32_t SRC5 = (1U << 5);  ///< If 1, indicates that SRC5 was the source of the Soft Reset
        constexpr uint32_t SRC6 = (1U << 6);  ///< If 1, indicates that SRC6 was the source of the Soft Reset
        constexpr uint32_t SRC7 = (1U << 7);  ///< If 1, indicates that SRC7 was the source of the Soft Reset
        constexpr uint32_t SRC8 = (1U << 8);  ///< If 1, indicates that SRC8 was the source of the Soft Reset
        constexpr uint32_t SRC9 = (1U << 9);  ///< If 1, indicates that SRC9 was the source of the Soft Reset
        constexpr uint32_t SRC10 = (1U << 10);  ///< If 1, indicates that SRC10 was the source of the Soft Reset
        constexpr uint32_t SRC11 = (1U << 11);  ///< If 1, indicates that SRC11 was the source of the Soft Reset
        constexpr uint32_t SRC12 = (1U << 12);  ///< If 1, indicates that SRC12 was the source of the Soft Reset
        constexpr uint32_t SRC13 = (1U << 13);  ///< If 1, indicates that SRC13 was the source of the Soft Reset
        constexpr uint32_t SRC14 = (1U << 14);  ///< If 1, indicates that SRC14 was the source of the Soft Reset
        constexpr uint32_t SRC15 = (1U << 15);  ///< If 1, indicates that SRC15 was the source of the Soft Reset
    }

    /// RSTCTL_SOFTRESET_CLR Register bits
    namespace rstctl_softreset_clr_bits {
        constexpr uint32_t SRC0 = (1U << 0);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC1 = (1U << 1);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC2 = (1U << 2);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC3 = (1U << 3);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC4 = (1U << 4);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC5 = (1U << 5);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC6 = (1U << 6);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC7 = (1U << 7);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC8 = (1U << 8);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC9 = (1U << 9);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC10 = (1U << 10);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC11 = (1U << 11);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC12 = (1U << 12);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC13 = (1U << 13);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC14 = (1U << 14);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
        constexpr uint32_t SRC15 = (1U << 15);  ///< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT
    }

    /// RSTCTL_SOFTRESET_SET Register bits
    namespace rstctl_softreset_set_bits {
        constexpr uint32_t SRC0 = (1U << 0);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC1 = (1U << 1);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC2 = (1U << 2);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC3 = (1U << 3);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC4 = (1U << 4);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC5 = (1U << 5);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC6 = (1U << 6);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC7 = (1U << 7);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC8 = (1U << 8);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC9 = (1U << 9);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC10 = (1U << 10);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC11 = (1U << 11);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC12 = (1U << 12);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC13 = (1U << 13);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC14 = (1U << 14);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
        constexpr uint32_t SRC15 = (1U << 15);  ///< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and initiates a Soft Reset)
    }

    /// RSTCTL_PSSRESET_STAT Register bits
    namespace rstctl_pssreset_stat_bits {
        constexpr uint32_t SVSMH = (1U << 1);  ///< Indicates if POR was caused by an SVSMH trip condition int the PSS
        constexpr uint32_t BGREF = (1U << 2);  ///< Indicates if POR was caused by a BGREF not okay condition in the PSS
        constexpr uint32_t VCCDET = (1U << 3);  ///< Indicates if POR was caused by a VCCDET trip condition in the PSS
        constexpr uint32_t SVSL = (1U << 0);  ///< Indicates if POR was caused by an SVSL trip condition in the PSS
    }

    /// RSTCTL_PSSRESET_CLR Register bits
    namespace rstctl_pssreset_clr_bits {
        constexpr uint32_t CLR = (1U << 0);  ///< Write 1 clears all PSS Reset Flags in the RSTCTL_PSSRESET_STAT
    }

    /// RSTCTL_PCMRESET_STAT Register bits
    namespace rstctl_pcmreset_stat_bits {
        constexpr uint32_t LPM35 = (1U << 0);  ///< Indicates if POR was caused by PCM due to an exit from LPM3.5
        constexpr uint32_t LPM45 = (1U << 1);  ///< Indicates if POR was caused by PCM due to an exit from LPM4.5
    }

    /// RSTCTL_PCMRESET_CLR Register bits
    namespace rstctl_pcmreset_clr_bits {
        constexpr uint32_t CLR = (1U << 0);  ///< Write 1 clears all PCM Reset Flags in the RSTCTL_PCMRESET_STAT
    }

    /// RSTCTL_PINRESET_STAT Register bits
    namespace rstctl_pinreset_stat_bits {
        constexpr uint32_t RSTNMI = (1U << 0);  ///< POR was caused by RSTn/NMI pin based reset event
    }

    /// RSTCTL_PINRESET_CLR Register bits
    namespace rstctl_pinreset_clr_bits {
        constexpr uint32_t CLR = (1U << 0);  ///< Write 1 clears the RSTn/NMI Pin Reset Flag in RSTCTL_PINRESET_STAT
    }

    /// RSTCTL_REBOOTRESET_STAT Register bits
    namespace rstctl_rebootreset_stat_bits {
        constexpr uint32_t REBOOT = (1U << 0);  ///< Indicates if Reboot reset was caused by the SYSCTL module.
    }

    /// RSTCTL_REBOOTRESET_CLR Register bits
    namespace rstctl_rebootreset_clr_bits {
        constexpr uint32_t CLR = (1U << 0);  ///< Write 1 clears the Reboot Reset Flag in RSTCTL_REBOOTRESET_STAT
    }

    /// RSTCTL_CSRESET_STAT Register bits
    namespace rstctl_csreset_stat_bits {
        constexpr uint32_t DCOR_SHT = (1U << 0);  ///< Indicates if POR was caused by DCO short circuit fault in the external resistor mode
    }

    /// RSTCTL_CSRESET_CLR Register bits
    namespace rstctl_csreset_clr_bits {
        constexpr uint32_t CLR = (1U << 0);  ///< Write 1 clears the DCOR_SHT Flag in RSTCTL_CSRESET_STAT as well as DCOR_SHTIFG flag in CSIFG register of clock system
    }

}

// ============================================================================
// SYSCTL Peripheral
// ============================================================================

namespace sysctl {
    /// Base addresses
    constexpr uint32_t SYSCTL_A_BASE = 0xE0043000;

    /// SYSCTL Register structure
    struct Registers {
        volatile uint32_t SYS_REBOOT_CTL;  ///< Offset: 0x00 - Reboot Control Register
        volatile uint32_t SYS_NMI_CTLSTAT;  ///< Offset: 0x04 - NMI Control and Status Register
        volatile uint32_t SYS_WDTRESET_CTL;  ///< Offset: 0x08 - Watchdog Reset Control Register
        volatile uint32_t SYS_PERIHALT_CTL;  ///< Offset: 0x0C - Peripheral Halt Control Register
        volatile uint32_t SYS_SRAM_SIZE;  ///< Offset: 0x10 - SRAM Size Register
        volatile uint32_t SYS_SRAM_NUMBANKS;  ///< Offset: 0x14 - SRAM Number of Banks Register
        volatile uint32_t SYS_SRAM_NUMBLOCKS;  ///< Offset: 0x18 - SRAM Number of Blocks Register
        volatile uint32_t SYS_MAINFLASH_SIZE;  ///< Offset: 0x20 - Flash Main Memory Size Register
        volatile uint32_t SYS_INFOFLASH_SIZE;  ///< Offset: 0x24 - Flash Information Memory Size Register
        volatile uint32_t SYS_DIO_GLTFLT_CTL;  ///< Offset: 0x30 - Digital I/O Glitch Filter Control Register
        volatile uint32_t SYS_SECDATA_UNLOCK;  ///< Offset: 0x40 - IP Protected Secure Zone Data Access Unlock Register
        volatile uint32_t SYS_SRAM_BANKEN_CTL0;  ///< Offset: 0x50 - SRAM Bank Enable Control Register 0
        volatile uint32_t SYS_SRAM_BANKEN_CTL1;  ///< Offset: 0x54 - SRAM Bank Enable Control Register 1
        volatile uint32_t SYS_SRAM_BANKEN_CTL2;  ///< Offset: 0x58 - SRAM Bank Enable Control Register 2
        volatile uint32_t SYS_SRAM_BANKEN_CTL3;  ///< Offset: 0x5C - SRAM Bank Enable Control Register 3
        volatile uint32_t SYS_SRAM_BLKRET_CTL0;  ///< Offset: 0x70 - SRAM Block Retention Control Register 0
        volatile uint32_t SYS_SRAM_BLKRET_CTL1;  ///< Offset: 0x74 - SRAM Block Retention Control Register 1
        volatile uint32_t SYS_SRAM_BLKRET_CTL2;  ///< Offset: 0x78 - SRAM Block Retention Control Register 2
        volatile uint32_t SYS_SRAM_BLKRET_CTL3;  ///< Offset: 0x7C - SRAM Block Retention Control Register 3
        volatile uint32_t SYS_SRAM_STAT;  ///< Offset: 0x90 - SRAM Status Register
        volatile uint32_t SYS_MASTER_UNLOCK;  ///< Offset: 0x1000 - Master Unlock Register
        volatile uint32_t SYS_BOOTOVER_REQ__;  ///< Offset: 0x1004 - Boot Override Request Register (renamed from SYS_BOOTOVER_REQ__)
        volatile uint32_t SYS_BOOTOVER_ACK;  ///< Offset: 0x100C - Boot Override Acknowledge Register
        volatile uint32_t SYS_RESET_REQ;  ///< Offset: 0x1010 - Reset Request Register
        volatile uint32_t SYS_RESET_STATOVER;  ///< Offset: 0x1014 - Reset Status and Override Register
        volatile uint32_t SYS_SYSTEM_STAT;  ///< Offset: 0x1020 - System Status Register
    };

    /// Peripheral instances
    inline Registers* SYSCTL_A = reinterpret_cast<Registers*>(SYSCTL_A_BASE);

    // Bit definitions
    /// SYS_REBOOT_CTL Register bits
    namespace sys_reboot_ctl_bits {
        constexpr uint32_t REBOOT = (1U << 0);  ///< Write 1 initiates a Reboot of the device
        constexpr uint32_t WKEY = (8 << 8);  ///< Key to enable writes to bit 0
    }

    /// SYS_NMI_CTLSTAT Register bits
    namespace sys_nmi_ctlstat_bits {
        constexpr uint32_t CS_SRC = (1U << 0);  ///< CS interrupt as a source of NMI
        constexpr uint32_t PSS_SRC = (1U << 1);  ///< PSS interrupt as a source of NMI
        constexpr uint32_t PCM_SRC = (1U << 2);  ///< PCM interrupt as a source of NMI
        constexpr uint32_t PIN_SRC = (1U << 3);  ///< RSTn/NMI pin configuration Note: When the device enters LPM3/LPM4 modes of operation, the functionality selected by this bit is retained. If selected as an NMI, activity on this pin in LPM3/LPM4 wakes the device and processes the interrupt, without causing a POR. If selected as a Reset, activity on this pin in LPM3/LPM4 causes a device-level POR When the device enters LPM3.5/LPM4.5 modes of operation, this bit is always cleared to 0. In other words, the RSTn/NMI pin always assumes a reset functionality in LPM3.5/LPM4.5 modes.
        constexpr uint32_t CS_FLG = (1U << 16);  ///< CS interrupt was the source of NMI
        constexpr uint32_t PSS_FLG = (1U << 17);  ///< PSS interrupt was the source of NMI
        constexpr uint32_t PCM_FLG = (1U << 18);  ///< PCM interrupt was the source of NMI
        constexpr uint32_t PIN_FLG = (1U << 19);  ///< RSTn/NMI pin was the source of NMI
    }

    /// SYS_WDTRESET_CTL Register bits
    namespace sys_wdtreset_ctl_bits {
        constexpr uint32_t TIMEOUT = (1U << 0);  ///< WDT timeout reset type
        constexpr uint32_t VIOLATION = (1U << 1);  ///< WDT password violation reset type
    }

    /// SYS_PERIHALT_CTL Register bits
    namespace sys_perihalt_ctl_bits {
        constexpr uint32_t HALT_T16_0 = (1U << 0);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_T16_1 = (1U << 1);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_T16_2 = (1U << 2);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_T16_3 = (1U << 3);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_T32_0 = (1U << 4);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUA0 = (1U << 5);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUA1 = (1U << 6);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUA2 = (1U << 7);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUA3 = (1U << 8);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUB0 = (1U << 9);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUB1 = (1U << 10);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUB2 = (1U << 11);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_eUB3 = (1U << 12);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_ADC = (1U << 13);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_WDT = (1U << 14);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_DMA = (1U << 15);  ///< Freezes IP operation when CPU is halted
        constexpr uint32_t HALT_LCD = (1U << 16);  ///< Freezes IP operation when CPU is halted
    }

    /// SYS_SRAM_SIZE Register bits
    namespace sys_sram_size_bits {
        constexpr uint32_t SIZE = (32 << 0);  ///< Indicates the size of SRAM on the device
    }

    /// SYS_SRAM_NUMBANKS Register bits
    namespace sys_sram_numbanks_bits {
        constexpr uint32_t NUM = (32 << 0);  ///< Indicates the number of SRAM banks on the device.
    }

    /// SYS_SRAM_NUMBLOCKS Register bits
    namespace sys_sram_numblocks_bits {
        constexpr uint32_t NUM = (32 << 0);  ///< Indicates the number of SRAM blocks on the device.
    }

    /// SYS_MAINFLASH_SIZE Register bits
    namespace sys_mainflash_size_bits {
        constexpr uint32_t SIZE = (32 << 0);  ///< Flash main memory size
    }

    /// SYS_INFOFLASH_SIZE Register bits
    namespace sys_infoflash_size_bits {
        constexpr uint32_t SIZE = (32 << 0);  ///< Flash information memory size
    }

    /// SYS_DIO_GLTFLT_CTL Register bits
    namespace sys_dio_gltflt_ctl_bits {
        constexpr uint32_t GLTCH_EN = (1U << 0);  ///< Glitch filter enable
    }

    /// SYS_SECDATA_UNLOCK Register bits
    namespace sys_secdata_unlock_bits {
        constexpr uint32_t UNLKEY = (16 << 0);  ///< Unlock key
    }

    /// SYS_SRAM_BANKEN_CTL0 Register bits
    namespace sys_sram_banken_ctl0_bits {
        constexpr uint32_t BNK0_EN = (1U << 0);  ///< When 1, enables Bank0 of the SRAM
        constexpr uint32_t BNK1_EN = (1U << 1);  ///< When 1, enables Bank1 of the SRAM
        constexpr uint32_t BNK2_EN = (1U << 2);  ///< When 1, enables Bank2 of the SRAM
        constexpr uint32_t BNK3_EN = (1U << 3);  ///< When 1, enables Bank3 of the SRAM
        constexpr uint32_t BNK4_EN = (1U << 4);  ///< When 1, enables Bank4 of the SRAM
        constexpr uint32_t BNK5_EN = (1U << 5);  ///< When 1, enables Bank5 of the SRAM
        constexpr uint32_t BNK6_EN = (1U << 6);  ///< When 1, enables Bank6 of the SRAM
        constexpr uint32_t BNK7_EN = (1U << 7);  ///< When 1, enables Bank7 of the SRAM
        constexpr uint32_t BNK8_EN = (1U << 8);  ///< When 1, enables Bank8 of the SRAM
        constexpr uint32_t BNK9_EN = (1U << 9);  ///< When 1, enables Bank9 of the SRAM
        constexpr uint32_t BNK10_EN = (1U << 10);  ///< When 1, enables Bank10 of the SRAM
        constexpr uint32_t BNK11_EN = (1U << 11);  ///< When 1, enables Bank11 of the SRAM
        constexpr uint32_t BNK12_EN = (1U << 12);  ///< When 1, enables Bank12 of the SRAM
        constexpr uint32_t BNK13_EN = (1U << 13);  ///< When 1, enables Bank13 of the SRAM
        constexpr uint32_t BNK14_EN = (1U << 14);  ///< When 1, enables Bank14 of the SRAM
        constexpr uint32_t BNK15_EN = (1U << 15);  ///< When 1, enables Bank15 of the SRAM
        constexpr uint32_t BNK16_EN = (1U << 16);  ///< When 1, enables Bank16 of the SRAM
        constexpr uint32_t BNK17_EN = (1U << 17);  ///< When 1, enables Bank17 of the SRAM
        constexpr uint32_t BNK18_EN = (1U << 18);  ///< When 1, enables Bank18 of the SRAM
        constexpr uint32_t BNK19_EN = (1U << 19);  ///< When 1, enables Bank19 of the SRAM
        constexpr uint32_t BNK20_EN = (1U << 20);  ///< When 1, enables Bank20 of the SRAM
        constexpr uint32_t BNK21_EN = (1U << 21);  ///< When 1, enables Bank21 of the SRAM
        constexpr uint32_t BNK22_EN = (1U << 22);  ///< When 1, enables Bank22 of the SRAM
        constexpr uint32_t BNK23_EN = (1U << 23);  ///< When 1, enables Bank23 of the SRAM
        constexpr uint32_t BNK24_EN = (1U << 24);  ///< When 1, enables Bank24 of the SRAM
        constexpr uint32_t BNK25_EN = (1U << 25);  ///< When 1, enables Bank25 of the SRAM
        constexpr uint32_t BNK26_EN = (1U << 26);  ///< When 1, enables Bank26 of the SRAM
        constexpr uint32_t BNK27_EN = (1U << 27);  ///< When 1, enables Bank27 of the SRAM
        constexpr uint32_t BNK28_EN = (1U << 28);  ///< When 1, enables Bank28 of the SRAM
        constexpr uint32_t BNK29_EN = (1U << 29);  ///< When 1, enables Bank29 of the SRAM
        constexpr uint32_t BNK30_EN = (1U << 30);  ///< When 1, enables Bank30 of the SRAM
        constexpr uint32_t BNK31_EN = (1U << 31);  ///< When 1, enables Bank31 of the SRAM
    }

    /// SYS_SRAM_BANKEN_CTL1 Register bits
    namespace sys_sram_banken_ctl1_bits {
        constexpr uint32_t BNK32_EN = (1U << 0);  ///< When 1, enables Bank32 of the SRAM
        constexpr uint32_t BNK33_EN = (1U << 1);  ///< When 1, enables Bank33 of the SRAM
        constexpr uint32_t BNK34_EN = (1U << 2);  ///< When 1, enables Bank34 of the SRAM
        constexpr uint32_t BNK35_EN = (1U << 3);  ///< When 1, enables Bank35 of the SRAM
        constexpr uint32_t BNK36_EN = (1U << 4);  ///< When 1, enables Bank36 of the SRAM
        constexpr uint32_t BNK37_EN = (1U << 5);  ///< When 1, enables Bank37 of the SRAM
        constexpr uint32_t BNK38_EN = (1U << 6);  ///< When 1, enables Bank38 of the SRAM
        constexpr uint32_t BNK39_EN = (1U << 7);  ///< When 1, enables Bank39 of the SRAM
        constexpr uint32_t BNK40_EN = (1U << 8);  ///< When 1, enables Bank40 of the SRAM
        constexpr uint32_t BNK41_EN = (1U << 9);  ///< When 1, enables Bank41 of the SRAM
        constexpr uint32_t BNK42_EN = (1U << 10);  ///< When 1, enables Bank42 of the SRAM
        constexpr uint32_t BNK43_EN = (1U << 11);  ///< When 1, enables Bank43 of the SRAM
        constexpr uint32_t BNK44_EN = (1U << 12);  ///< When 1, enables Bank44 of the SRAM
        constexpr uint32_t BNK45_EN = (1U << 13);  ///< When 1, enables Bank45 of the SRAM
        constexpr uint32_t BNK46_EN = (1U << 14);  ///< When 1, enables Bank46 of the SRAM
        constexpr uint32_t BNK47_EN = (1U << 15);  ///< When 1, enables Bank47 of the SRAM
        constexpr uint32_t BNK48_EN = (1U << 16);  ///< When 1, enables Bank48 of the SRAM
        constexpr uint32_t BNK49_EN = (1U << 17);  ///< When 1, enables Bank49 of the SRAM
        constexpr uint32_t BNK50_EN = (1U << 18);  ///< When 1, enables Bank50 of the SRAM
        constexpr uint32_t BNK51_EN = (1U << 19);  ///< When 1, enables Bank51 of the SRAM
        constexpr uint32_t BNK52_EN = (1U << 20);  ///< When 1, enables Bank52 of the SRAM
        constexpr uint32_t BNK53_EN = (1U << 21);  ///< When 1, enables Bank53 of the SRAM
        constexpr uint32_t BNK54_EN = (1U << 22);  ///< When 1, enables Bank54 of the SRAM
        constexpr uint32_t BNK55_EN = (1U << 23);  ///< When 1, enables Bank55 of the SRAM
        constexpr uint32_t BNK56_EN = (1U << 24);  ///< When 1, enables Bank56 of the SRAM
        constexpr uint32_t BNK57_EN = (1U << 25);  ///< When 1, enables Bank57 of the SRAM
        constexpr uint32_t BNK58_EN = (1U << 26);  ///< When 1, enables Bank58 of the SRAM
        constexpr uint32_t BNK59_EN = (1U << 27);  ///< When 1, enables Bank59 of the SRAM
        constexpr uint32_t BNK60_EN = (1U << 28);  ///< When 1, enables Bank60 of the SRAM
        constexpr uint32_t BNK61_EN = (1U << 29);  ///< When 1, enables Bank61 of the SRAM
        constexpr uint32_t BNK62_EN = (1U << 30);  ///< When 1, enables Bank62 of the SRAM
        constexpr uint32_t BNK63_EN = (1U << 31);  ///< When 1, enables Bank63 of the SRAM
    }

    /// SYS_SRAM_BANKEN_CTL2 Register bits
    namespace sys_sram_banken_ctl2_bits {
        constexpr uint32_t BNK64_EN = (1U << 0);  ///< When 1, enables Bank64 of the SRAM
        constexpr uint32_t BNK65_EN = (1U << 1);  ///< When 1, enables Bank65 of the SRAM
        constexpr uint32_t BNK66_EN = (1U << 2);  ///< When 1, enables Bank66 of the SRAM
        constexpr uint32_t BNK67_EN = (1U << 3);  ///< When 1, enables Bank67 of the SRAM
        constexpr uint32_t BNK68_EN = (1U << 4);  ///< When 1, enables Bank68 of the SRAM
        constexpr uint32_t BNK69_EN = (1U << 5);  ///< When 1, enables Bank69 of the SRAM
        constexpr uint32_t BNK70_EN = (1U << 6);  ///< When 1, enables Bank70 of the SRAM
        constexpr uint32_t BNK71_EN = (1U << 7);  ///< When 1, enables Bank71 of the SRAM
        constexpr uint32_t BNK72_EN = (1U << 8);  ///< When 1, enables Bank72 of the SRAM
        constexpr uint32_t BNK73_EN = (1U << 9);  ///< When 1, enables Bank73 of the SRAM
        constexpr uint32_t BNK74_EN = (1U << 10);  ///< When 1, enables Bank74 of the SRAM
        constexpr uint32_t BNK75_EN = (1U << 11);  ///< When 1, enables Bank75 of the SRAM
        constexpr uint32_t BNK76_EN = (1U << 12);  ///< When 1, enables Bank76 of the SRAM
        constexpr uint32_t BNK77_EN = (1U << 13);  ///< When 1, enables Bank77 of the SRAM
        constexpr uint32_t BNK78_EN = (1U << 14);  ///< When 1, enables Bank78 of the SRAM
        constexpr uint32_t BNK79_EN = (1U << 15);  ///< When 1, enables Bank79 of the SRAM
        constexpr uint32_t BNK80_EN = (1U << 16);  ///< When 1, enables Bank80 of the SRAM
        constexpr uint32_t BNK81_EN = (1U << 17);  ///< When 1, enables Bank81 of the SRAM
        constexpr uint32_t BNK82_EN = (1U << 18);  ///< When 1, enables Bank82 of the SRAM
        constexpr uint32_t BNK83_EN = (1U << 19);  ///< When 1, enables Bank83 of the SRAM
        constexpr uint32_t BNK84_EN = (1U << 20);  ///< When 1, enables Bank84 of the SRAM
        constexpr uint32_t BNK85_EN = (1U << 21);  ///< When 1, enables Bank85 of the SRAM
        constexpr uint32_t BNK86_EN = (1U << 22);  ///< When 1, enables Bank86 of the SRAM
        constexpr uint32_t BNK87_EN = (1U << 23);  ///< When 1, enables Bank87 of the SRAM
        constexpr uint32_t BNK88_EN = (1U << 24);  ///< When 1, enables Bank88 of the SRAM
        constexpr uint32_t BNK89_EN = (1U << 25);  ///< When 1, enables Bank89 of the SRAM
        constexpr uint32_t BNK90_EN = (1U << 26);  ///< When 1, enables Bank90 of the SRAM
        constexpr uint32_t BNK91_EN = (1U << 27);  ///< When 1, enables Bank91 of the SRAM
        constexpr uint32_t BNK92_EN = (1U << 28);  ///< When 1, enables Bank92 of the SRAM
        constexpr uint32_t BNK93_EN = (1U << 29);  ///< When 1, enables Bank93 of the SRAM
        constexpr uint32_t BNK94_EN = (1U << 30);  ///< When 1, enables Bank94 of the SRAM
        constexpr uint32_t BNK95_EN = (1U << 31);  ///< When 1, enables Bank95 of the SRAM
    }

    /// SYS_SRAM_BANKEN_CTL3 Register bits
    namespace sys_sram_banken_ctl3_bits {
        constexpr uint32_t BNK96_EN = (1U << 0);  ///< When 1, enables Bank96 of the SRAM
        constexpr uint32_t BNK97_EN = (1U << 1);  ///< When 1, enables Bank97 of the SRAM
        constexpr uint32_t BNK98_EN = (1U << 2);  ///< When 1, enables Bank98 of the SRAM
        constexpr uint32_t BNK99_EN = (1U << 3);  ///< When 1, enables Bank99 of the SRAM
        constexpr uint32_t BNK100_EN = (1U << 4);  ///< When 1, enables Bank100 of the SRAM
        constexpr uint32_t BNK101_EN = (1U << 5);  ///< When 1, enables Bank101 of the SRAM
        constexpr uint32_t BNK102_EN = (1U << 6);  ///< When 1, enables Bank102 of the SRAM
        constexpr uint32_t BNK103_EN = (1U << 7);  ///< When 1, enables Bank103 of the SRAM
        constexpr uint32_t BNK104_EN = (1U << 8);  ///< When 1, enables Bank104 of the SRAM
        constexpr uint32_t BNK105_EN = (1U << 9);  ///< When 1, enables Bank105 of the SRAM
        constexpr uint32_t BNK106_EN = (1U << 10);  ///< When 1, enables Bank106 of the SRAM
        constexpr uint32_t BNK107_EN = (1U << 11);  ///< When 1, enables Bank107 of the SRAM
        constexpr uint32_t BNK108_EN = (1U << 12);  ///< When 1, enables Bank108 of the SRAM
        constexpr uint32_t BNK109_EN = (1U << 13);  ///< When 1, enables Bank109 of the SRAM
        constexpr uint32_t BNK110_EN = (1U << 14);  ///< When 1, enables Bank110 of the SRAM
        constexpr uint32_t BNK111_EN = (1U << 15);  ///< When 1, enables Bank111 of the SRAM
        constexpr uint32_t BNK112_EN = (1U << 16);  ///< When 1, enables Bank112 of the SRAM
        constexpr uint32_t BNK113_EN = (1U << 17);  ///< When 1, enables Bank113 of the SRAM
        constexpr uint32_t BNK114_EN = (1U << 18);  ///< When 1, enables Bank114 of the SRAM
        constexpr uint32_t BNK115_EN = (1U << 19);  ///< When 1, enables Bank115 of the SRAM
        constexpr uint32_t BNK116_EN = (1U << 20);  ///< When 1, enables Bank116 of the SRAM
        constexpr uint32_t BNK117_EN = (1U << 21);  ///< When 1, enables Bank117 of the SRAM
        constexpr uint32_t BNK118_EN = (1U << 22);  ///< When 1, enables Bank118 of the SRAM
        constexpr uint32_t BNK119_EN = (1U << 23);  ///< When 1, enables Bank119 of the SRAM
        constexpr uint32_t BNK120_EN = (1U << 24);  ///< When 1, enables Bank120 of the SRAM
        constexpr uint32_t BNK121_EN = (1U << 25);  ///< When 1, enables Bank121 of the SRAM
        constexpr uint32_t BNK122_EN = (1U << 26);  ///< When 1, enables Bank122 of the SRAM
        constexpr uint32_t BNK123_EN = (1U << 27);  ///< When 1, enables Bank123 of the SRAM
        constexpr uint32_t BNK124_EN = (1U << 28);  ///< When 1, enables Bank124 of the SRAM
        constexpr uint32_t BNK125_EN = (1U << 29);  ///< When 1, enables Bank125 of the SRAM
        constexpr uint32_t BNK126_EN = (1U << 30);  ///< When 1, enables Bank126 of the SRAM
        constexpr uint32_t BNK127_EN = (1U << 31);  ///< When 1, enables Bank127 of the SRAM
    }

    /// SYS_SRAM_BLKRET_CTL0 Register bits
    namespace sys_sram_blkret_ctl0_bits {
        constexpr uint32_t BLK0_EN = (1U << 0);  ///< Block0 is always retained in LPM3, LPM4 and LPM3.5 modes of operation
        constexpr uint32_t BLK1_EN = (1U << 1);  ///< When 1, Block1 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK2_EN = (1U << 2);  ///< When 1, Block2 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK3_EN = (1U << 3);  ///< When 1, Block3 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK4_EN = (1U << 4);  ///< When 1, Block4 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK5_EN = (1U << 5);  ///< When 1, Block5 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK6_EN = (1U << 6);  ///< When 1, Block6 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK7_EN = (1U << 7);  ///< When 1, Block7 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK8_EN = (1U << 8);  ///< When 1, Block8 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK9_EN = (1U << 9);  ///< When 1, Block9 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK10_EN = (1U << 10);  ///< When 1, Block10 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK11_EN = (1U << 11);  ///< When 1, Block11 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK12_EN = (1U << 12);  ///< When 1, Block12 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK13_EN = (1U << 13);  ///< When 1, Block13 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK14_EN = (1U << 14);  ///< When 1, Block14 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK15_EN = (1U << 15);  ///< When 1, Block15 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK16_EN = (1U << 16);  ///< When 1, Block16 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK17_EN = (1U << 17);  ///< When 1, Block17 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK18_EN = (1U << 18);  ///< When 1, Block18 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK19_EN = (1U << 19);  ///< When 1, Block19 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK20_EN = (1U << 20);  ///< When 1, Block20 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK21_EN = (1U << 21);  ///< When 1, Block21 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK22_EN = (1U << 22);  ///< When 1, Block22 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK23_EN = (1U << 23);  ///< When 1, Block23 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK24_EN = (1U << 24);  ///< When 1, Block24 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK25_EN = (1U << 25);  ///< When 1, Block25 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK26_EN = (1U << 26);  ///< When 1, Block26 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK27_EN = (1U << 27);  ///< When 1, Block27 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK28_EN = (1U << 28);  ///< When 1, Block28 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK29_EN = (1U << 29);  ///< When 1, Block29 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK30_EN = (1U << 30);  ///< When 1, Block30 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK31_EN = (1U << 31);  ///< When 1, Block31 of the SRAM is retained in LPM3 and LPM4
    }

    /// SYS_SRAM_BLKRET_CTL1 Register bits
    namespace sys_sram_blkret_ctl1_bits {
        constexpr uint32_t BLK32_EN = (1U << 0);  ///< When 1, Block32 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK33_EN = (1U << 1);  ///< When 1, Block33 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK34_EN = (1U << 2);  ///< When 1, Block34 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK35_EN = (1U << 3);  ///< When 1, Block35 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK36_EN = (1U << 4);  ///< When 1, Block36 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK37_EN = (1U << 5);  ///< When 1, Block37 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK38_EN = (1U << 6);  ///< When 1, Block38 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK39_EN = (1U << 7);  ///< When 1, Block39 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK40_EN = (1U << 8);  ///< When 1, Block40 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK41_EN = (1U << 9);  ///< When 1, Block41 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK42_EN = (1U << 10);  ///< When 1, Block42 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK43_EN = (1U << 11);  ///< When 1, Block43 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK44_EN = (1U << 12);  ///< When 1, Block44 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK45_EN = (1U << 13);  ///< When 1, Block45 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK46_EN = (1U << 14);  ///< When 1, Block46 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK47_EN = (1U << 15);  ///< When 1, Block47 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK48_EN = (1U << 16);  ///< When 1, Block48 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK49_EN = (1U << 17);  ///< When 1, Block49 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK50_EN = (1U << 18);  ///< When 1, Block50 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK51_EN = (1U << 19);  ///< When 1, Block51 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK52_EN = (1U << 20);  ///< When 1, Block52 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK53_EN = (1U << 21);  ///< When 1, Block53 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK54_EN = (1U << 22);  ///< When 1, Block54 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK55_EN = (1U << 23);  ///< When 1, Block55 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK56_EN = (1U << 24);  ///< When 1, Block56 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK57_EN = (1U << 25);  ///< When 1, Block57 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK58_EN = (1U << 26);  ///< When 1, Block58 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK59_EN = (1U << 27);  ///< When 1, Block59 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK60_EN = (1U << 28);  ///< When 1, Block60 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK61_EN = (1U << 29);  ///< When 1, Block61 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK62_EN = (1U << 30);  ///< When 1, Block62 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK63_EN = (1U << 31);  ///< When 1, Block63 of the SRAM is retained in LPM3 and LPM4
    }

    /// SYS_SRAM_BLKRET_CTL2 Register bits
    namespace sys_sram_blkret_ctl2_bits {
        constexpr uint32_t BLK64_EN = (1U << 0);  ///< When 1, Block64 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK65_EN = (1U << 1);  ///< When 1, Block65 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK66_EN = (1U << 2);  ///< When 1, Block66 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK67_EN = (1U << 3);  ///< When 1, Block67 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK68_EN = (1U << 4);  ///< When 1, Block68 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK69_EN = (1U << 5);  ///< When 1, Block69 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK70_EN = (1U << 6);  ///< When 1, Block70 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK71_EN = (1U << 7);  ///< When 1, Block71 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK72_EN = (1U << 8);  ///< When 1, Block72 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK73_EN = (1U << 9);  ///< When 1, Block73 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK74_EN = (1U << 10);  ///< When 1, Block74 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK75_EN = (1U << 11);  ///< When 1, Block75 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK76_EN = (1U << 12);  ///< When 1, Block76 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK77_EN = (1U << 13);  ///< When 1, Block77 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK78_EN = (1U << 14);  ///< When 1, Block78 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK79_EN = (1U << 15);  ///< When 1, Block79 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK80_EN = (1U << 16);  ///< When 1, Block80 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK81_EN = (1U << 17);  ///< When 1, Block81 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK82_EN = (1U << 18);  ///< When 1, Block82 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK83_EN = (1U << 19);  ///< When 1, Block83 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK84_EN = (1U << 20);  ///< When 1, Block84 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK85_EN = (1U << 21);  ///< When 1, Block85 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK86_EN = (1U << 22);  ///< When 1, Block86 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK87_EN = (1U << 23);  ///< When 1, Block87 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK88_EN = (1U << 24);  ///< When 1, Block88 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK89_EN = (1U << 25);  ///< When 1, Block89 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK90_EN = (1U << 26);  ///< When 1, Block90 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK91_EN = (1U << 27);  ///< When 1, Block91 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK92_EN = (1U << 28);  ///< When 1, Block92 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK93_EN = (1U << 29);  ///< When 1, Block93 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK94_EN = (1U << 30);  ///< When 1, Block94 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK95_EN = (1U << 31);  ///< When 1, Block95 of the SRAM is retained in LPM3 and LPM4
    }

    /// SYS_SRAM_BLKRET_CTL3 Register bits
    namespace sys_sram_blkret_ctl3_bits {
        constexpr uint32_t BLK96_EN = (1U << 0);  ///< When 1, Block96 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK97_EN = (1U << 1);  ///< When 1, Block97 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK98_EN = (1U << 2);  ///< When 1, Block98 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK99_EN = (1U << 3);  ///< When 1, Block99 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK100_EN = (1U << 4);  ///< When 1, Block100 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK101_EN = (1U << 5);  ///< When 1, Block101 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK102_EN = (1U << 6);  ///< When 1, Block102 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK103_EN = (1U << 7);  ///< When 1, Block103 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK104_EN = (1U << 8);  ///< When 1, Block104 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK105_EN = (1U << 9);  ///< When 1, Block105 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK106_EN = (1U << 10);  ///< When 1, Block106 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK107_EN = (1U << 11);  ///< When 1, Block107 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK108_EN = (1U << 12);  ///< When 1, Block108 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK109_EN = (1U << 13);  ///< When 1, Block109 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK110_EN = (1U << 14);  ///< When 1, Block110 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK111_EN = (1U << 15);  ///< When 1, Block111 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK112_EN = (1U << 16);  ///< When 1, Block112 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK113_EN = (1U << 17);  ///< When 1, Block113 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK114_EN = (1U << 18);  ///< When 1, Block114 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK115_EN = (1U << 19);  ///< When 1, Block115 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK116_EN = (1U << 20);  ///< When 1, Block116 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK117_EN = (1U << 21);  ///< When 1, Block117 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK118_EN = (1U << 22);  ///< When 1, Block118 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK119_EN = (1U << 23);  ///< When 1, Block119 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK120_EN = (1U << 24);  ///< When 1, Block120 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK121_EN = (1U << 25);  ///< When 1, Block121 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK122_EN = (1U << 26);  ///< When 1, Block122 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK123_EN = (1U << 27);  ///< When 1, Block123 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK124_EN = (1U << 28);  ///< When 1, Block124 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK125_EN = (1U << 29);  ///< When 1, Block125 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK126_EN = (1U << 30);  ///< When 1, Block126 of the SRAM is retained in LPM3 and LPM4
        constexpr uint32_t BLK127_EN = (1U << 31);  ///< When 1, Block127 of the SRAM is retained in LPM3 and LPM4
    }

    /// SYS_SRAM_STAT Register bits
    namespace sys_sram_stat_bits {
        constexpr uint32_t BNKEN_RDY = (1U << 0);  ///< When 1, indicates SRAM is ready for access and banks can be enabled/disabled.
        constexpr uint32_t BLKRET_RDY = (1U << 1);  ///< When 1, indicates SRAM is ready for access and blocks can be enabled/disabled for retention.
    }

    /// SYS_MASTER_UNLOCK Register bits
    namespace sys_master_unlock_bits {
        constexpr uint32_t UNLKEY = (16 << 0);  ///< Unlock Key
    }

    /// SYS_BOOTOVER_REQ__ Register bits
    namespace sys_bootover_req___bits {
        constexpr uint32_t REGVAL = (32 << 0);  ///< Value set by debugger, read and clear by the CPU
    }

    /// SYS_BOOTOVER_ACK Register bits
    namespace sys_bootover_ack_bits {
        constexpr uint32_t REGVAL = (32 << 0);  ///< Value set by CPU, read/clear by the debugger
    }

    /// SYS_RESET_REQ Register bits
    namespace sys_reset_req_bits {
        constexpr uint32_t POR = (1U << 0);  ///< Generate POR
        constexpr uint32_t REBOOT = (1U << 1);  ///< Generate Reboot_Reset
        constexpr uint32_t WKEY = (8 << 8);  ///< Write key
    }

    /// SYS_RESET_STATOVER Register bits
    namespace sys_reset_statover_bits {
        constexpr uint32_t SOFT = (1U << 0);  ///< Indicates if SOFT Reset is active
        constexpr uint32_t HARD = (1U << 1);  ///< Indicates if HARD Reset is active
        constexpr uint32_t REBOOT = (1U << 2);  ///< Indicates if Reboot Reset is active
        constexpr uint32_t SOFT_OVER = (1U << 8);  ///< SOFT_Reset overwrite request
        constexpr uint32_t HARD_OVER = (1U << 9);  ///< HARD_Reset overwrite request
        constexpr uint32_t RBT_OVER = (1U << 10);  ///< Reboot Reset overwrite request
    }

    /// SYS_SYSTEM_STAT Register bits
    namespace sys_system_stat_bits {
        constexpr uint32_t DBG_SEC_ACT = (1U << 3);  ///< Debug Security active
        constexpr uint32_t JTAG_SWD_LOCK_ACT = (1U << 4);  ///< Indicates if JTAG and SWD Lock is active
        constexpr uint32_t IP_PROT_ACT = (1U << 5);  ///< Indicates if IP protection is active
    }

}


} // namespace alloy::generated::msp432p411v

#endif // ALLOY_GENERATED_MSP432P411V_PERIPHERALS_HPP