/// Auto-generated code for TM4C1232D5PM
/// Generated by Alloy Code Generator
/// Source: texasinstruments_tm4c1232d5.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:01
#ifndef ALLOY_GENERATED_TM4C1232D5PM_PERIPHERALS_HPP
#define ALLOY_GENERATED_TM4C1232D5PM_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::tm4c1232d5pm {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_watchdog0 = true;
    constexpr uint32_t num_watchdog0_instances = 1;
    constexpr bool has_watchdog1 = true;
    constexpr uint32_t num_watchdog1_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 14;
    constexpr bool has_ssi0 = true;
    constexpr uint32_t num_ssi0_instances = 1;
    constexpr bool has_ssi1 = true;
    constexpr uint32_t num_ssi1_instances = 1;
    constexpr bool has_ssi2 = true;
    constexpr uint32_t num_ssi2_instances = 1;
    constexpr bool has_ssi3 = true;
    constexpr uint32_t num_ssi3_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 8;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 6;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 12;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_eeprom = true;
    constexpr uint32_t num_eeprom_instances = 1;
    constexpr bool has_sysexc = true;
    constexpr uint32_t num_sysexc_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_sysctl = true;
    constexpr uint32_t num_sysctl_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct watchdog0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct watchdog1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 14;
    };
    template<>
    struct peripheral_count<struct ssi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssi1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssi2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssi3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 12;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eeprom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sysexc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sysctl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 14;
    constexpr uint32_t max_gpio_pins = 224;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_uart6 = true;
    constexpr bool has_uart7 = true;
}

// ============================================================================
// WATCHDOG0 Peripheral
// ============================================================================

namespace watchdog0 {
    /// Base addresses
    constexpr uint32_t WATCHDOG0_BASE = 0x40000000;

    /// WATCHDOG0 Register structure
    struct Registers {
        volatile uint32_t LOAD;  ///< Offset: 0x00 - Watchdog Load
        volatile uint32_t VALUE;  ///< Offset: 0x04 - Watchdog Value
        volatile uint32_t CTL;  ///< Offset: 0x08 - Watchdog Control
        volatile uint32_t ICR;  ///< Offset: 0x0C - Watchdog Interrupt Clear
        volatile uint32_t RIS;  ///< Offset: 0x10 - Watchdog Raw Interrupt Status
        volatile uint32_t MIS;  ///< Offset: 0x14 - Watchdog Masked Interrupt Status
        volatile uint32_t TEST;  ///< Offset: 0x418 - Watchdog Test
        volatile uint32_t LOCK;  ///< Offset: 0xC00 - Watchdog Lock
    };

    /// Peripheral instances
    inline Registers* WATCHDOG0 = reinterpret_cast<Registers*>(WATCHDOG0_BASE);

}

// ============================================================================
// WATCHDOG1 Peripheral
// ============================================================================

namespace watchdog1 {
    /// Base addresses
    constexpr uint32_t WATCHDOG1_BASE = 0x40001000;

    /// WATCHDOG1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* WATCHDOG1 = reinterpret_cast<Registers*>(WATCHDOG1_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x40004000;
    constexpr uint32_t GPIOB_BASE = 0x40005000;
    constexpr uint32_t GPIOC_BASE = 0x40006000;
    constexpr uint32_t GPIOD_BASE = 0x40007000;
    constexpr uint32_t GPIOE_BASE = 0x40024000;
    constexpr uint32_t GPIOF_BASE = 0x40025000;
    constexpr uint32_t GPIOG_BASE = 0x40026000;
    constexpr uint32_t GPIOA_AHB_BASE = 0x40058000;
    constexpr uint32_t GPIOB_AHB_BASE = 0x40059000;
    constexpr uint32_t GPIOC_AHB_BASE = 0x4005A000;
    constexpr uint32_t GPIOD_AHB_BASE = 0x4005B000;
    constexpr uint32_t GPIOE_AHB_BASE = 0x4005C000;
    constexpr uint32_t GPIOF_AHB_BASE = 0x4005D000;
    constexpr uint32_t GPIOG_AHB_BASE = 0x4005E000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x3FC - GPIO Data
        volatile uint32_t DIR;  ///< Offset: 0x400 - GPIO Direction
        volatile uint32_t IS;  ///< Offset: 0x404 - GPIO Interrupt Sense
        volatile uint32_t IBE;  ///< Offset: 0x408 - GPIO Interrupt Both Edges
        volatile uint32_t IEV;  ///< Offset: 0x40C - GPIO Interrupt Event
        volatile uint32_t IM;  ///< Offset: 0x410 - GPIO Interrupt Mask
        volatile uint32_t RIS;  ///< Offset: 0x414 - GPIO Raw Interrupt Status
        volatile uint32_t MIS;  ///< Offset: 0x418 - GPIO Masked Interrupt Status
        volatile uint32_t ICR;  ///< Offset: 0x41C - GPIO Interrupt Clear
        volatile uint32_t AFSEL;  ///< Offset: 0x420 - GPIO Alternate Function Select
        volatile uint32_t DR2R;  ///< Offset: 0x500 - GPIO 2-mA Drive Select
        volatile uint32_t DR4R;  ///< Offset: 0x504 - GPIO 4-mA Drive Select
        volatile uint32_t DR8R;  ///< Offset: 0x508 - GPIO 8-mA Drive Select
        volatile uint32_t ODR;  ///< Offset: 0x50C - GPIO Open Drain Select
        volatile uint32_t PUR;  ///< Offset: 0x510 - GPIO Pull-Up Select
        volatile uint32_t PDR;  ///< Offset: 0x514 - GPIO Pull-Down Select
        volatile uint32_t SLR;  ///< Offset: 0x518 - GPIO Slew Rate Control Select
        volatile uint32_t DEN;  ///< Offset: 0x51C - GPIO Digital Enable
        volatile uint32_t LOCK;  ///< Offset: 0x520 - GPIO Lock
        volatile uint32_t CR;  ///< Offset: 0x524 - GPIO Commit
        volatile uint32_t AMSEL;  ///< Offset: 0x528 - GPIO Analog Mode Select
        volatile uint32_t PCTL;  ///< Offset: 0x52C - GPIO Port Control
        volatile uint32_t ADCCTL;  ///< Offset: 0x530 - GPIO ADC Control
        volatile uint32_t DMACTL;  ///< Offset: 0x534 - GPIO DMA Control
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* GPIOA_AHB = reinterpret_cast<Registers*>(GPIOA_AHB_BASE);
    inline Registers* GPIOB_AHB = reinterpret_cast<Registers*>(GPIOB_AHB_BASE);
    inline Registers* GPIOC_AHB = reinterpret_cast<Registers*>(GPIOC_AHB_BASE);
    inline Registers* GPIOD_AHB = reinterpret_cast<Registers*>(GPIOD_AHB_BASE);
    inline Registers* GPIOE_AHB = reinterpret_cast<Registers*>(GPIOE_AHB_BASE);
    inline Registers* GPIOF_AHB = reinterpret_cast<Registers*>(GPIOF_AHB_BASE);
    inline Registers* GPIOG_AHB = reinterpret_cast<Registers*>(GPIOG_AHB_BASE);

}

// ============================================================================
// SSI0 Peripheral
// ============================================================================

namespace ssi0 {
    /// Base addresses
    constexpr uint32_t SSI0_BASE = 0x40008000;

    /// SSI0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - SSI Control 0
        volatile uint32_t CR1;  ///< Offset: 0x04 - SSI Control 1
        volatile uint32_t DR;  ///< Offset: 0x08 - SSI Data
        volatile uint32_t SR;  ///< Offset: 0x0C - SSI Status
        volatile uint32_t CPSR;  ///< Offset: 0x10 - SSI Clock Prescale
        volatile uint32_t IM;  ///< Offset: 0x14 - SSI Interrupt Mask
        volatile uint32_t RIS;  ///< Offset: 0x18 - SSI Raw Interrupt Status
        volatile uint32_t MIS;  ///< Offset: 0x1C - SSI Masked Interrupt Status
        volatile uint32_t ICR;  ///< Offset: 0x20 - SSI Interrupt Clear
        volatile uint32_t DMACTL;  ///< Offset: 0x24 - SSI DMA Control
        volatile uint32_t CC;  ///< Offset: 0xFC8 - SSI Clock Configuration
    };

    /// Peripheral instances
    inline Registers* SSI0 = reinterpret_cast<Registers*>(SSI0_BASE);

}

// ============================================================================
// SSI1 Peripheral
// ============================================================================

namespace ssi1 {
    /// Base addresses
    constexpr uint32_t SSI1_BASE = 0x40009000;

    /// SSI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSI1 = reinterpret_cast<Registers*>(SSI1_BASE);

}

// ============================================================================
// SSI2 Peripheral
// ============================================================================

namespace ssi2 {
    /// Base addresses
    constexpr uint32_t SSI2_BASE = 0x4000A000;

    /// SSI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSI2 = reinterpret_cast<Registers*>(SSI2_BASE);

}

// ============================================================================
// SSI3 Peripheral
// ============================================================================

namespace ssi3 {
    /// Base addresses
    constexpr uint32_t SSI3_BASE = 0x4000B000;

    /// SSI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSI3 = reinterpret_cast<Registers*>(SSI3_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4000C000;
    constexpr uint32_t UART1_BASE = 0x4000D000;
    constexpr uint32_t UART2_BASE = 0x4000E000;
    constexpr uint32_t UART3_BASE = 0x4000F000;
    constexpr uint32_t UART4_BASE = 0x40010000;
    constexpr uint32_t UART5_BASE = 0x40011000;
    constexpr uint32_t UART6_BASE = 0x40012000;
    constexpr uint32_t UART7_BASE = 0x40013000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - UART Data
        volatile uint32_t RSR;  ///< Offset: 0x04 - UART Receive Status/Error Clear
        volatile uint32_t ECR;  ///< Offset: 0x04 - UART Receive Status/Error Clear
        volatile uint32_t FR;  ///< Offset: 0x18 - UART Flag
        volatile uint32_t ILPR;  ///< Offset: 0x20 - UART IrDA Low-Power Register
        volatile uint32_t IBRD;  ///< Offset: 0x24 - UART Integer Baud-Rate Divisor
        volatile uint32_t FBRD;  ///< Offset: 0x28 - UART Fractional Baud-Rate Divisor
        volatile uint32_t LCRH;  ///< Offset: 0x2C - UART Line Control
        volatile uint32_t CTL;  ///< Offset: 0x30 - UART Control
        volatile uint32_t IFLS;  ///< Offset: 0x34 - UART Interrupt FIFO Level Select
        volatile uint32_t IM;  ///< Offset: 0x38 - UART Interrupt Mask
        volatile uint32_t RIS;  ///< Offset: 0x3C - UART Raw Interrupt Status
        volatile uint32_t MIS;  ///< Offset: 0x40 - UART Masked Interrupt Status
        volatile uint32_t ICR;  ///< Offset: 0x44 - UART Interrupt Clear
        volatile uint32_t DMACTL;  ///< Offset: 0x48 - UART DMA Control
        volatile uint32_t _9BITADDR;  ///< Offset: 0xA4 - UART 9-Bit Self Address
        volatile uint32_t _9BITAMASK;  ///< Offset: 0xA8 - UART 9-Bit Self Address Mask
        volatile uint32_t PP;  ///< Offset: 0xFC0 - UART Peripheral Properties
        volatile uint32_t CC;  ///< Offset: 0xFC8 - UART Clock Configuration
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* UART6 = reinterpret_cast<Registers*>(UART6_BASE);
    inline Registers* UART7 = reinterpret_cast<Registers*>(UART7_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40020000;
    constexpr uint32_t I2C1_BASE = 0x40021000;
    constexpr uint32_t I2C2_BASE = 0x40022000;
    constexpr uint32_t I2C3_BASE = 0x40023000;
    constexpr uint32_t I2C4_BASE = 0x400C0000;
    constexpr uint32_t I2C5_BASE = 0x400C1000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t MSA;  ///< Offset: 0x00 - I2C Master Slave Address
        volatile uint32_t MCS;  ///< Offset: 0x04 - I2C Master Control/Status
        volatile uint32_t MDR;  ///< Offset: 0x08 - I2C Master Data
        volatile uint32_t MTPR;  ///< Offset: 0x0C - I2C Master Timer Period
        volatile uint32_t MIMR;  ///< Offset: 0x10 - I2C Master Interrupt Mask
        volatile uint32_t MRIS;  ///< Offset: 0x14 - I2C Master Raw Interrupt Status
        volatile uint32_t MMIS;  ///< Offset: 0x18 - I2C Master Masked Interrupt Status
        volatile uint32_t MICR;  ///< Offset: 0x1C - I2C Master Interrupt Clear
        volatile uint32_t MCR;  ///< Offset: 0x20 - I2C Master Configuration
        volatile uint32_t MCLKOCNT;  ///< Offset: 0x24 - I2C Master Clock Low Timeout Count
        volatile uint32_t MBMON;  ///< Offset: 0x2C - I2C Master Bus Monitor
        volatile uint32_t MCR2;  ///< Offset: 0x38 - I2C Master Configuration 2
        volatile uint32_t SOAR;  ///< Offset: 0x800 - I2C Slave Own Address
        volatile uint32_t SCSR;  ///< Offset: 0x804 - I2C Slave Control/Status
        volatile uint32_t SDR;  ///< Offset: 0x808 - I2C Slave Data
        volatile uint32_t SIMR;  ///< Offset: 0x80C - I2C Slave Interrupt Mask
        volatile uint32_t SRIS;  ///< Offset: 0x810 - I2C Slave Raw Interrupt Status
        volatile uint32_t SMIS;  ///< Offset: 0x814 - I2C Slave Masked Interrupt Status
        volatile uint32_t SICR;  ///< Offset: 0x818 - I2C Slave Interrupt Clear
        volatile uint32_t SOAR2;  ///< Offset: 0x81C - I2C Slave Own Address 2
        volatile uint32_t SACKCTL;  ///< Offset: 0x820 - I2C Slave ACK Control
        volatile uint32_t PP;  ///< Offset: 0xFC0 - I2C Peripheral Properties
        volatile uint32_t PC;  ///< Offset: 0xFC4 - I2C Peripheral Configuration
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);
    inline Registers* I2C5 = reinterpret_cast<Registers*>(I2C5_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40030000;
    constexpr uint32_t TIMER1_BASE = 0x40031000;
    constexpr uint32_t TIMER2_BASE = 0x40032000;
    constexpr uint32_t TIMER3_BASE = 0x40033000;
    constexpr uint32_t TIMER4_BASE = 0x40034000;
    constexpr uint32_t TIMER5_BASE = 0x40035000;
    constexpr uint32_t WTIMER0_BASE = 0x40036000;
    constexpr uint32_t WTIMER1_BASE = 0x40037000;
    constexpr uint32_t WTIMER2_BASE = 0x4004C000;
    constexpr uint32_t WTIMER3_BASE = 0x4004D000;
    constexpr uint32_t WTIMER4_BASE = 0x4004E000;
    constexpr uint32_t WTIMER5_BASE = 0x4004F000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - GPTM Configuration
        volatile uint32_t TAMR;  ///< Offset: 0x04 - GPTM Timer A Mode
        volatile uint32_t TBMR;  ///< Offset: 0x08 - GPTM Timer B Mode
        volatile uint32_t CTL;  ///< Offset: 0x0C - GPTM Control
        volatile uint32_t SYNC;  ///< Offset: 0x10 - GPTM Synchronize
        volatile uint32_t IMR;  ///< Offset: 0x18 - GPTM Interrupt Mask
        volatile uint32_t RIS;  ///< Offset: 0x1C - GPTM Raw Interrupt Status
        volatile uint32_t MIS;  ///< Offset: 0x20 - GPTM Masked Interrupt Status
        volatile uint32_t ICR;  ///< Offset: 0x24 - GPTM Interrupt Clear
        volatile uint32_t TAILR;  ///< Offset: 0x28 - GPTM Timer A Interval Load
        volatile uint32_t TBILR;  ///< Offset: 0x2C - GPTM Timer B Interval Load
        volatile uint32_t TAMATCHR;  ///< Offset: 0x30 - GPTM Timer A Match
        volatile uint32_t TBMATCHR;  ///< Offset: 0x34 - GPTM Timer B Match
        volatile uint32_t TAPR;  ///< Offset: 0x38 - GPTM Timer A Prescale
        volatile uint32_t TBPR;  ///< Offset: 0x3C - GPTM Timer B Prescale
        volatile uint32_t TAPMR;  ///< Offset: 0x40 - GPTM TimerA Prescale Match
        volatile uint32_t TBPMR;  ///< Offset: 0x44 - GPTM TimerB Prescale Match
        volatile uint32_t TAR;  ///< Offset: 0x48 - GPTM Timer A
        volatile uint32_t TBR;  ///< Offset: 0x4C - GPTM Timer B
        volatile uint32_t TAV;  ///< Offset: 0x50 - GPTM Timer A Value
        volatile uint32_t TBV;  ///< Offset: 0x54 - GPTM Timer B Value
        volatile uint32_t RTCPD;  ///< Offset: 0x58 - GPTM RTC Predivide
        volatile uint32_t TAPS;  ///< Offset: 0x5C - GPTM Timer A Prescale Snapshot
        volatile uint32_t TBPS;  ///< Offset: 0x60 - GPTM Timer B Prescale Snapshot
        volatile uint32_t TAPV;  ///< Offset: 0x64 - GPTM Timer A Prescale Value
        volatile uint32_t TBPV;  ///< Offset: 0x68 - GPTM Timer B Prescale Value
        volatile uint32_t PP;  ///< Offset: 0xFC0 - GPTM Peripheral Properties
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER3 = reinterpret_cast<Registers*>(TIMER3_BASE);
    inline Registers* TIMER4 = reinterpret_cast<Registers*>(TIMER4_BASE);
    inline Registers* TIMER5 = reinterpret_cast<Registers*>(TIMER5_BASE);
    inline Registers* WTIMER0 = reinterpret_cast<Registers*>(WTIMER0_BASE);
    inline Registers* WTIMER1 = reinterpret_cast<Registers*>(WTIMER1_BASE);
    inline Registers* WTIMER2 = reinterpret_cast<Registers*>(WTIMER2_BASE);
    inline Registers* WTIMER3 = reinterpret_cast<Registers*>(WTIMER3_BASE);
    inline Registers* WTIMER4 = reinterpret_cast<Registers*>(WTIMER4_BASE);
    inline Registers* WTIMER5 = reinterpret_cast<Registers*>(WTIMER5_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x40038000;
    constexpr uint32_t ADC1_BASE = 0x40039000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ACTSS;  ///< Offset: 0x00 - ADC Active Sample Sequencer
        volatile uint32_t RIS;  ///< Offset: 0x04 - ADC Raw Interrupt Status
        volatile uint32_t IM;  ///< Offset: 0x08 - ADC Interrupt Mask
        volatile uint32_t ISC;  ///< Offset: 0x0C - ADC Interrupt Status and Clear
        volatile uint32_t OSTAT;  ///< Offset: 0x10 - ADC Overflow Status
        volatile uint32_t EMUX;  ///< Offset: 0x14 - ADC Event Multiplexer Select
        volatile uint32_t USTAT;  ///< Offset: 0x18 - ADC Underflow Status
        volatile uint32_t SSPRI;  ///< Offset: 0x20 - ADC Sample Sequencer Priority
        volatile uint32_t SPC;  ///< Offset: 0x24 - ADC Sample Phase Control
        volatile uint32_t PSSI;  ///< Offset: 0x28 - ADC Processor Sample Sequence Initiate
        volatile uint32_t SAC;  ///< Offset: 0x30 - ADC Sample Averaging Control
        volatile uint32_t DCISC;  ///< Offset: 0x34 - ADC Digital Comparator Interrupt Status and Clear
        volatile uint32_t CTL;  ///< Offset: 0x38 - ADC Control
        volatile uint32_t SSMUX0;  ///< Offset: 0x40 - ADC Sample Sequence Input Multiplexer Select 0
        volatile uint32_t SSCTL0;  ///< Offset: 0x44 - ADC Sample Sequence Control 0
        volatile uint32_t SSFIFO0;  ///< Offset: 0x48 - ADC Sample Sequence Result FIFO 0
        volatile uint32_t SSFSTAT0;  ///< Offset: 0x4C - ADC Sample Sequence FIFO 0 Status
        volatile uint32_t SSOP0;  ///< Offset: 0x50 - ADC Sample Sequence 0 Operation
        volatile uint32_t SSDC0;  ///< Offset: 0x54 - ADC Sample Sequence 0 Digital Comparator Select
        volatile uint32_t SSMUX1;  ///< Offset: 0x60 - ADC Sample Sequence Input Multiplexer Select 1
        volatile uint32_t SSCTL1;  ///< Offset: 0x64 - ADC Sample Sequence Control 1
        volatile uint32_t SSFIFO1;  ///< Offset: 0x68 - ADC Sample Sequence Result FIFO 1
        volatile uint32_t SSFSTAT1;  ///< Offset: 0x6C - ADC Sample Sequence FIFO 1 Status
        volatile uint32_t SSOP1;  ///< Offset: 0x70 - ADC Sample Sequence 1 Operation
        volatile uint32_t SSDC1;  ///< Offset: 0x74 - ADC Sample Sequence 1 Digital Comparator Select
        volatile uint32_t SSMUX2;  ///< Offset: 0x80 - ADC Sample Sequence Input Multiplexer Select 2
        volatile uint32_t SSCTL2;  ///< Offset: 0x84 - ADC Sample Sequence Control 2
        volatile uint32_t SSFIFO2;  ///< Offset: 0x88 - ADC Sample Sequence Result FIFO 2
        volatile uint32_t SSFSTAT2;  ///< Offset: 0x8C - ADC Sample Sequence FIFO 2 Status
        volatile uint32_t SSOP2;  ///< Offset: 0x90 - ADC Sample Sequence 2 Operation
        volatile uint32_t SSDC2;  ///< Offset: 0x94 - ADC Sample Sequence 2 Digital Comparator Select
        volatile uint32_t SSMUX3;  ///< Offset: 0xA0 - ADC Sample Sequence Input Multiplexer Select 3
        volatile uint32_t SSCTL3;  ///< Offset: 0xA4 - ADC Sample Sequence Control 3
        volatile uint32_t SSFIFO3;  ///< Offset: 0xA8 - ADC Sample Sequence Result FIFO 3
        volatile uint32_t SSFSTAT3;  ///< Offset: 0xAC - ADC Sample Sequence FIFO 3 Status
        volatile uint32_t SSOP3;  ///< Offset: 0xB0 - ADC Sample Sequence 3 Operation
        volatile uint32_t SSDC3;  ///< Offset: 0xB4 - ADC Sample Sequence 3 Digital Comparator Select
        volatile uint32_t DCRIC;  ///< Offset: 0xD00 - ADC Digital Comparator Reset Initial Conditions
        volatile uint32_t DCCTL0;  ///< Offset: 0xE00 - ADC Digital Comparator Control 0
        volatile uint32_t DCCTL1;  ///< Offset: 0xE04 - ADC Digital Comparator Control 1
        volatile uint32_t DCCTL2;  ///< Offset: 0xE08 - ADC Digital Comparator Control 2
        volatile uint32_t DCCTL3;  ///< Offset: 0xE0C - ADC Digital Comparator Control 3
        volatile uint32_t DCCTL4;  ///< Offset: 0xE10 - ADC Digital Comparator Control 4
        volatile uint32_t DCCTL5;  ///< Offset: 0xE14 - ADC Digital Comparator Control 5
        volatile uint32_t DCCTL6;  ///< Offset: 0xE18 - ADC Digital Comparator Control 6
        volatile uint32_t DCCTL7;  ///< Offset: 0xE1C - ADC Digital Comparator Control 7
        volatile uint32_t DCCMP0;  ///< Offset: 0xE40 - ADC Digital Comparator Range 0
        volatile uint32_t DCCMP1;  ///< Offset: 0xE44 - ADC Digital Comparator Range 1
        volatile uint32_t DCCMP2;  ///< Offset: 0xE48 - ADC Digital Comparator Range 2
        volatile uint32_t DCCMP3;  ///< Offset: 0xE4C - ADC Digital Comparator Range 3
        volatile uint32_t DCCMP4;  ///< Offset: 0xE50 - ADC Digital Comparator Range 4
        volatile uint32_t DCCMP5;  ///< Offset: 0xE54 - ADC Digital Comparator Range 5
        volatile uint32_t DCCMP6;  ///< Offset: 0xE58 - ADC Digital Comparator Range 6
        volatile uint32_t DCCMP7;  ///< Offset: 0xE5C - ADC Digital Comparator Range 7
        volatile uint32_t PP;  ///< Offset: 0xFC0 - ADC Peripheral Properties
        volatile uint32_t PC;  ///< Offset: 0xFC4 - ADC Peripheral Configuration
        volatile uint32_t CC;  ///< Offset: 0xFC8 - ADC Clock Configuration
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x4003C000;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t ACMIS;  ///< Offset: 0x00 - Analog Comparator Masked Interrupt Status
        volatile uint32_t ACRIS;  ///< Offset: 0x04 - Analog Comparator Raw Interrupt Status
        volatile uint32_t ACINTEN;  ///< Offset: 0x08 - Analog Comparator Interrupt Enable
        volatile uint32_t ACREFCTL;  ///< Offset: 0x10 - Analog Comparator Reference Voltage Control
        volatile uint32_t ACSTAT0;  ///< Offset: 0x20 - Analog Comparator Status 0
        volatile uint32_t ACCTL0;  ///< Offset: 0x24 - Analog Comparator Control 0
        volatile uint32_t ACSTAT1;  ///< Offset: 0x40 - Analog Comparator Status 1
        volatile uint32_t ACCTL1;  ///< Offset: 0x44 - Analog Comparator Control 1
        volatile uint32_t PP;  ///< Offset: 0xFC0 - Analog Comparator Peripheral Properties
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40040000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - CAN Control
        volatile uint32_t STS;  ///< Offset: 0x04 - CAN Status
        volatile uint32_t ERR;  ///< Offset: 0x08 - CAN Error Counter
        volatile uint32_t BIT;  ///< Offset: 0x0C - CAN Bit Timing
        volatile uint32_t INT_;  ///< Offset: 0x10 - CAN Interrupt (renamed from INT_)
        volatile uint32_t TST;  ///< Offset: 0x14 - CAN Test
        volatile uint32_t BRPE;  ///< Offset: 0x18 - CAN Baud Rate Prescaler Extension
        volatile uint32_t IF1CRQ;  ///< Offset: 0x20 - CAN IF1 Command Request
        volatile uint32_t IF1CMSK;  ///< Offset: 0x24 - CAN IF1 Command Mask
        volatile uint32_t IF1MSK1;  ///< Offset: 0x28 - CAN IF1 Mask 1
        volatile uint32_t IF1MSK2;  ///< Offset: 0x2C - CAN IF1 Mask 2
        volatile uint32_t IF1ARB1;  ///< Offset: 0x30 - CAN IF1 Arbitration 1
        volatile uint32_t IF1ARB2;  ///< Offset: 0x34 - CAN IF1 Arbitration 2
        volatile uint32_t IF1MCTL;  ///< Offset: 0x38 - CAN IF1 Message Control
        volatile uint32_t IF1DA1;  ///< Offset: 0x3C - CAN IF1 Data A1
        volatile uint32_t IF1DA2;  ///< Offset: 0x40 - CAN IF1 Data A2
        volatile uint32_t IF1DB1;  ///< Offset: 0x44 - CAN IF1 Data B1
        volatile uint32_t IF1DB2;  ///< Offset: 0x48 - CAN IF1 Data B2
        volatile uint32_t IF2CRQ;  ///< Offset: 0x80 - CAN IF2 Command Request
        volatile uint32_t IF2CMSK;  ///< Offset: 0x84 - CAN IF2 Command Mask
        volatile uint32_t IF2MSK1;  ///< Offset: 0x88 - CAN IF2 Mask 1
        volatile uint32_t IF2MSK2;  ///< Offset: 0x8C - CAN IF2 Mask 2
        volatile uint32_t IF2ARB1;  ///< Offset: 0x90 - CAN IF2 Arbitration 1
        volatile uint32_t IF2ARB2;  ///< Offset: 0x94 - CAN IF2 Arbitration 2
        volatile uint32_t IF2MCTL;  ///< Offset: 0x98 - CAN IF2 Message Control
        volatile uint32_t IF2DA1;  ///< Offset: 0x9C - CAN IF2 Data A1
        volatile uint32_t IF2DA2;  ///< Offset: 0xA0 - CAN IF2 Data A2
        volatile uint32_t IF2DB1;  ///< Offset: 0xA4 - CAN IF2 Data B1
        volatile uint32_t IF2DB2;  ///< Offset: 0xA8 - CAN IF2 Data B2
        volatile uint32_t TXRQ1;  ///< Offset: 0x100 - CAN Transmission Request 1
        volatile uint32_t TXRQ2;  ///< Offset: 0x104 - CAN Transmission Request 2
        volatile uint32_t NWDA1;  ///< Offset: 0x120 - CAN New Data 1
        volatile uint32_t NWDA2;  ///< Offset: 0x124 - CAN New Data 2
        volatile uint32_t MSG1INT;  ///< Offset: 0x140 - CAN Message 1 Interrupt Pending
        volatile uint32_t MSG2INT;  ///< Offset: 0x144 - CAN Message 2 Interrupt Pending
        volatile uint32_t MSG1VAL;  ///< Offset: 0x160 - CAN Message 1 Valid
        volatile uint32_t MSG2VAL;  ///< Offset: 0x164 - CAN Message 2 Valid
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x40050000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t FADDR;  ///< Offset: 0x00 - USB Device Functional Address
        volatile uint32_t POWER;  ///< Offset: 0x01 - USB Power
        volatile uint32_t TXIS;  ///< Offset: 0x02 - USB Transmit Interrupt Status
        volatile uint32_t RXIS;  ///< Offset: 0x04 - USB Receive Interrupt Status
        volatile uint32_t TXIE;  ///< Offset: 0x06 - USB Transmit Interrupt Enable
        volatile uint32_t RXIE;  ///< Offset: 0x08 - USB Receive Interrupt Enable
        volatile uint32_t IS;  ///< Offset: 0x0A - USB General Interrupt Status
        volatile uint32_t IE;  ///< Offset: 0x0B - USB Interrupt Enable
        volatile uint32_t FRAME;  ///< Offset: 0x0C - USB Frame Value
        volatile uint32_t EPIDX;  ///< Offset: 0x0E - USB Endpoint Index
        volatile uint32_t TEST;  ///< Offset: 0x0F - USB Test Mode
        volatile uint32_t FIFO0;  ///< Offset: 0x20 - USB FIFO Endpoint 0
        volatile uint32_t FIFO1;  ///< Offset: 0x24 - USB FIFO Endpoint 1
        volatile uint32_t FIFO2;  ///< Offset: 0x28 - USB FIFO Endpoint 2
        volatile uint32_t FIFO3;  ///< Offset: 0x2C - USB FIFO Endpoint 3
        volatile uint32_t FIFO4;  ///< Offset: 0x30 - USB FIFO Endpoint 4
        volatile uint32_t FIFO5;  ///< Offset: 0x34 - USB FIFO Endpoint 5
        volatile uint32_t FIFO6;  ///< Offset: 0x38 - USB FIFO Endpoint 6
        volatile uint32_t FIFO7;  ///< Offset: 0x3C - USB FIFO Endpoint 7
        volatile uint32_t TXFIFOSZ;  ///< Offset: 0x62 - USB Transmit Dynamic FIFO Sizing
        volatile uint32_t RXFIFOSZ;  ///< Offset: 0x63 - USB Receive Dynamic FIFO Sizing
        volatile uint32_t TXFIFOADD;  ///< Offset: 0x64 - USB Transmit FIFO Start Address
        volatile uint32_t RXFIFOADD;  ///< Offset: 0x66 - USB Receive FIFO Start Address
        volatile uint32_t CONTIM;  ///< Offset: 0x7A - USB Connect Timing
        volatile uint32_t FSEOF;  ///< Offset: 0x7D - USB Full-Speed Last Transaction to End of Frame Timing
        volatile uint32_t LSEOF;  ///< Offset: 0x7E - USB Low-Speed Last Transaction to End of Frame Timing
        volatile uint32_t CSRL0;  ///< Offset: 0x102 - USB Control and Status Endpoint 0 Low
        volatile uint32_t CSRH0;  ///< Offset: 0x103 - USB Control and Status Endpoint 0 High
        volatile uint32_t COUNT0;  ///< Offset: 0x108 - USB Receive Byte Count Endpoint 0
        volatile uint32_t TXMAXP1;  ///< Offset: 0x110 - USB Maximum Transmit Data Endpoint 1
        volatile uint32_t TXCSRL1;  ///< Offset: 0x112 - USB Transmit Control and Status Endpoint 1 Low
        volatile uint32_t TXCSRH1;  ///< Offset: 0x113 - USB Transmit Control and Status Endpoint 1 High
        volatile uint32_t RXMAXP1;  ///< Offset: 0x114 - USB Maximum Receive Data Endpoint 1
        volatile uint32_t RXCSRL1;  ///< Offset: 0x116 - USB Receive Control and Status Endpoint 1 Low
        volatile uint32_t RXCSRH1;  ///< Offset: 0x117 - USB Receive Control and Status Endpoint 1 High
        volatile uint32_t RXCOUNT1;  ///< Offset: 0x118 - USB Receive Byte Count Endpoint 1
        volatile uint32_t TXMAXP2;  ///< Offset: 0x120 - USB Maximum Transmit Data Endpoint 2
        volatile uint32_t TXCSRL2;  ///< Offset: 0x122 - USB Transmit Control and Status Endpoint 2 Low
        volatile uint32_t TXCSRH2;  ///< Offset: 0x123 - USB Transmit Control and Status Endpoint 2 High
        volatile uint32_t RXMAXP2;  ///< Offset: 0x124 - USB Maximum Receive Data Endpoint 2
        volatile uint32_t RXCSRL2;  ///< Offset: 0x126 - USB Receive Control and Status Endpoint 2 Low
        volatile uint32_t RXCSRH2;  ///< Offset: 0x127 - USB Receive Control and Status Endpoint 2 High
        volatile uint32_t RXCOUNT2;  ///< Offset: 0x128 - USB Receive Byte Count Endpoint 2
        volatile uint32_t TXMAXP3;  ///< Offset: 0x130 - USB Maximum Transmit Data Endpoint 3
        volatile uint32_t TXCSRL3;  ///< Offset: 0x132 - USB Transmit Control and Status Endpoint 3 Low
        volatile uint32_t TXCSRH3;  ///< Offset: 0x133 - USB Transmit Control and Status Endpoint 3 High
        volatile uint32_t RXMAXP3;  ///< Offset: 0x134 - USB Maximum Receive Data Endpoint 3
        volatile uint32_t RXCSRL3;  ///< Offset: 0x136 - USB Receive Control and Status Endpoint 3 Low
        volatile uint32_t RXCSRH3;  ///< Offset: 0x137 - USB Receive Control and Status Endpoint 3 High
        volatile uint32_t RXCOUNT3;  ///< Offset: 0x138 - USB Receive Byte Count Endpoint 3
        volatile uint32_t TXMAXP4;  ///< Offset: 0x140 - USB Maximum Transmit Data Endpoint 4
        volatile uint32_t TXCSRL4;  ///< Offset: 0x142 - USB Transmit Control and Status Endpoint 4 Low
        volatile uint32_t TXCSRH4;  ///< Offset: 0x143 - USB Transmit Control and Status Endpoint 4 High
        volatile uint32_t RXMAXP4;  ///< Offset: 0x144 - USB Maximum Receive Data Endpoint 4
        volatile uint32_t RXCSRL4;  ///< Offset: 0x146 - USB Receive Control and Status Endpoint 4 Low
        volatile uint32_t RXCSRH4;  ///< Offset: 0x147 - USB Receive Control and Status Endpoint 4 High
        volatile uint32_t RXCOUNT4;  ///< Offset: 0x148 - USB Receive Byte Count Endpoint 4
        volatile uint32_t TXMAXP5;  ///< Offset: 0x150 - USB Maximum Transmit Data Endpoint 5
        volatile uint32_t TXCSRL5;  ///< Offset: 0x152 - USB Transmit Control and Status Endpoint 5 Low
        volatile uint32_t TXCSRH5;  ///< Offset: 0x153 - USB Transmit Control and Status Endpoint 5 High
        volatile uint32_t RXMAXP5;  ///< Offset: 0x154 - USB Maximum Receive Data Endpoint 5
        volatile uint32_t RXCSRL5;  ///< Offset: 0x156 - USB Receive Control and Status Endpoint 5 Low
        volatile uint32_t RXCSRH5;  ///< Offset: 0x157 - USB Receive Control and Status Endpoint 5 High
        volatile uint32_t RXCOUNT5;  ///< Offset: 0x158 - USB Receive Byte Count Endpoint 5
        volatile uint32_t TXMAXP6;  ///< Offset: 0x160 - USB Maximum Transmit Data Endpoint 6
        volatile uint32_t TXCSRL6;  ///< Offset: 0x162 - USB Transmit Control and Status Endpoint 6 Low
        volatile uint32_t TXCSRH6;  ///< Offset: 0x163 - USB Transmit Control and Status Endpoint 6 High
        volatile uint32_t RXMAXP6;  ///< Offset: 0x164 - USB Maximum Receive Data Endpoint 6
        volatile uint32_t RXCSRL6;  ///< Offset: 0x166 - USB Receive Control and Status Endpoint 6 Low
        volatile uint32_t RXCSRH6;  ///< Offset: 0x167 - USB Receive Control and Status Endpoint 6 High
        volatile uint32_t RXCOUNT6;  ///< Offset: 0x168 - USB Receive Byte Count Endpoint 6
        volatile uint32_t TXMAXP7;  ///< Offset: 0x170 - USB Maximum Transmit Data Endpoint 7
        volatile uint32_t TXCSRL7;  ///< Offset: 0x172 - USB Transmit Control and Status Endpoint 7 Low
        volatile uint32_t TXCSRH7;  ///< Offset: 0x173 - USB Transmit Control and Status Endpoint 7 High
        volatile uint32_t RXMAXP7;  ///< Offset: 0x174 - USB Maximum Receive Data Endpoint 7
        volatile uint32_t RXCSRL7;  ///< Offset: 0x176 - USB Receive Control and Status Endpoint 7 Low
        volatile uint32_t RXCSRH7;  ///< Offset: 0x177 - USB Receive Control and Status Endpoint 7 High
        volatile uint32_t RXCOUNT7;  ///< Offset: 0x178 - USB Receive Byte Count Endpoint 7
        volatile uint32_t RXDPKTBUFDIS;  ///< Offset: 0x340 - USB Receive Double Packet Buffer Disable
        volatile uint32_t TXDPKTBUFDIS;  ///< Offset: 0x342 - USB Transmit Double Packet Buffer Disable
        volatile uint32_t DRRIS;  ///< Offset: 0x410 - USB Device RESUME Raw Interrupt Status
        volatile uint32_t DRIM;  ///< Offset: 0x414 - USB Device RESUME Interrupt Mask
        volatile uint32_t DRISC;  ///< Offset: 0x418 - USB Device RESUME Interrupt Status and Clear
        volatile uint32_t DMASEL;  ///< Offset: 0x450 - USB DMA Select
        volatile uint32_t PP;  ///< Offset: 0xFC0 - USB Peripheral Properties
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

}

// ============================================================================
// EEPROM Peripheral
// ============================================================================

namespace eeprom {
    /// Base addresses
    constexpr uint32_t EEPROM_BASE = 0x400AF000;

    /// EEPROM Register structure
    struct Registers {
        volatile uint32_t EESIZE;  ///< Offset: 0x00 - EEPROM Size Information
        volatile uint32_t EEBLOCK;  ///< Offset: 0x04 - EEPROM Current Block
        volatile uint32_t EEOFFSET;  ///< Offset: 0x08 - EEPROM Current Offset
        volatile uint32_t EERDWR;  ///< Offset: 0x10 - EEPROM Read-Write
        volatile uint32_t EERDWRINC;  ///< Offset: 0x14 - EEPROM Read-Write with Increment
        volatile uint32_t EEDONE;  ///< Offset: 0x18 - EEPROM Done Status
        volatile uint32_t EESUPP;  ///< Offset: 0x1C - EEPROM Support Control and Status
        volatile uint32_t EEUNLOCK;  ///< Offset: 0x20 - EEPROM Unlock
        volatile uint32_t EEPROT;  ///< Offset: 0x30 - EEPROM Protection
        volatile uint32_t EEPASS0;  ///< Offset: 0x34 - EEPROM Password
        volatile uint32_t EEPASS1;  ///< Offset: 0x38 - EEPROM Password
        volatile uint32_t EEPASS2;  ///< Offset: 0x3C - EEPROM Password
        volatile uint32_t EEINT;  ///< Offset: 0x40 - EEPROM Interrupt
        volatile uint32_t EEHIDE;  ///< Offset: 0x50 - EEPROM Block Hide
        volatile uint32_t EEDBGME;  ///< Offset: 0x80 - EEPROM Debug Mass Erase
        volatile uint32_t PP;  ///< Offset: 0xFC0 - EEPROM Peripheral Properties
    };

    /// Peripheral instances
    inline Registers* EEPROM = reinterpret_cast<Registers*>(EEPROM_BASE);

}

// ============================================================================
// SYSEXC Peripheral
// ============================================================================

namespace sysexc {
    /// Base addresses
    constexpr uint32_t SYSEXC_BASE = 0x400F9000;

    /// SYSEXC Register structure
    struct Registers {
        volatile uint32_t RIS;  ///< Offset: 0x00 - System Exception Raw Interrupt Status
        volatile uint32_t IM;  ///< Offset: 0x04 - System Exception Interrupt Mask
        volatile uint32_t MIS;  ///< Offset: 0x08 - System Exception Masked Interrupt Status
        volatile uint32_t IC;  ///< Offset: 0x0C - System Exception Interrupt Clear
    };

    /// Peripheral instances
    inline Registers* SYSEXC = reinterpret_cast<Registers*>(SYSEXC_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_CTRL_BASE = 0x400FD000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FMA;  ///< Offset: 0x00 - Flash Memory Address
        volatile uint32_t FMD;  ///< Offset: 0x04 - Flash Memory Data
        volatile uint32_t FMC;  ///< Offset: 0x08 - Flash Memory Control
        volatile uint32_t FCRIS;  ///< Offset: 0x0C - Flash Controller Raw Interrupt Status
        volatile uint32_t FCIM;  ///< Offset: 0x10 - Flash Controller Interrupt Mask
        volatile uint32_t FCMISC;  ///< Offset: 0x14 - Flash Controller Masked Interrupt Status and Clear
        volatile uint32_t FMC2;  ///< Offset: 0x20 - Flash Memory Control 2
        volatile uint32_t FWBVAL;  ///< Offset: 0x30 - Flash Write Buffer Valid
        volatile uint32_t FWBN;  ///< Offset: 0x100 - Flash Write Buffer n
        volatile uint32_t FSIZE;  ///< Offset: 0xFC0 - Flash Size
        volatile uint32_t SSIZE;  ///< Offset: 0xFC4 - SRAM Size
        volatile uint32_t ROMSWMAP;  ///< Offset: 0xFCC - ROM Software Map
        volatile uint32_t RMCTL;  ///< Offset: 0x10F0 - ROM Control
        volatile uint32_t BOOTCFG;  ///< Offset: 0x11D0 - Boot Configuration
        volatile uint32_t USERREG0;  ///< Offset: 0x11E0 - User Register 0
        volatile uint32_t USERREG1;  ///< Offset: 0x11E4 - User Register 1
        volatile uint32_t USERREG2;  ///< Offset: 0x11E8 - User Register 2
        volatile uint32_t USERREG3;  ///< Offset: 0x11EC - User Register 3
        volatile uint32_t FMPRE0;  ///< Offset: 0x1200 - Flash Memory Protection Read Enable 0
        volatile uint32_t FMPPE0;  ///< Offset: 0x1400 - Flash Memory Protection Program Enable 0
    };

    /// Peripheral instances
    inline Registers* FLASH_CTRL = reinterpret_cast<Registers*>(FLASH_CTRL_BASE);

}

// ============================================================================
// SYSCTL Peripheral
// ============================================================================

namespace sysctl {
    /// Base addresses
    constexpr uint32_t SYSCTL_BASE = 0x400FE000;

    /// SYSCTL Register structure
    struct Registers {
        volatile uint32_t DID0;  ///< Offset: 0x00 - Device Identification 0
        volatile uint32_t DID1;  ///< Offset: 0x04 - Device Identification 1
        volatile uint32_t DC0;  ///< Offset: 0x08 - Device Capabilities 0
        volatile uint32_t DC1;  ///< Offset: 0x10 - Device Capabilities 1
        volatile uint32_t DC2;  ///< Offset: 0x14 - Device Capabilities 2
        volatile uint32_t DC3;  ///< Offset: 0x18 - Device Capabilities 3
        volatile uint32_t DC4;  ///< Offset: 0x1C - Device Capabilities 4
        volatile uint32_t DC5;  ///< Offset: 0x20 - Device Capabilities 5
        volatile uint32_t DC6;  ///< Offset: 0x24 - Device Capabilities 6
        volatile uint32_t DC7;  ///< Offset: 0x28 - Device Capabilities 7
        volatile uint32_t DC8;  ///< Offset: 0x2C - Device Capabilities 8 ADC Channels
        volatile uint32_t PBORCTL;  ///< Offset: 0x30 - Brown-Out Reset Control
        volatile uint32_t SRCR0;  ///< Offset: 0x40 - Software Reset Control 0
        volatile uint32_t SRCR1;  ///< Offset: 0x44 - Software Reset Control 1
        volatile uint32_t SRCR2;  ///< Offset: 0x48 - Software Reset Control 2
        volatile uint32_t RIS;  ///< Offset: 0x50 - Raw Interrupt Status
        volatile uint32_t IMC;  ///< Offset: 0x54 - Interrupt Mask Control
        volatile uint32_t MISC;  ///< Offset: 0x58 - Masked Interrupt Status and Clear
        volatile uint32_t RESC;  ///< Offset: 0x5C - Reset Cause
        volatile uint32_t RCC;  ///< Offset: 0x60 - Run-Mode Clock Configuration
        volatile uint32_t GPIOHBCTL;  ///< Offset: 0x6C - GPIO High-Performance Bus Control
        volatile uint32_t RCC2;  ///< Offset: 0x70 - Run-Mode Clock Configuration 2
        volatile uint32_t MOSCCTL;  ///< Offset: 0x7C - Main Oscillator Control
        volatile uint32_t RCGC0;  ///< Offset: 0x100 - Run Mode Clock Gating Control Register 0
        volatile uint32_t RCGC1;  ///< Offset: 0x104 - Run Mode Clock Gating Control Register 1
        volatile uint32_t RCGC2;  ///< Offset: 0x108 - Run Mode Clock Gating Control Register 2
        volatile uint32_t SCGC0;  ///< Offset: 0x110 - Sleep Mode Clock Gating Control Register 0
        volatile uint32_t SCGC1;  ///< Offset: 0x114 - Sleep Mode Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x118 - Sleep Mode Clock Gating Control Register 2
        volatile uint32_t DCGC0;  ///< Offset: 0x120 - Deep Sleep Mode Clock Gating Control Register 0
        volatile uint32_t DCGC1;  ///< Offset: 0x124 - Deep-Sleep Mode Clock Gating Control Register 1
        volatile uint32_t DCGC2;  ///< Offset: 0x128 - Deep Sleep Mode Clock Gating Control Register 2
        volatile uint32_t DSLPCLKCFG;  ///< Offset: 0x144 - Deep Sleep Clock Configuration
        volatile uint32_t SYSPROP;  ///< Offset: 0x14C - System Properties
        volatile uint32_t PIOSCCAL;  ///< Offset: 0x150 - Precision Internal Oscillator Calibration
        volatile uint32_t PLLFREQ0;  ///< Offset: 0x160 - PLL Frequency 0
        volatile uint32_t PLLFREQ1;  ///< Offset: 0x164 - PLL Frequency 1
        volatile uint32_t PLLSTAT;  ///< Offset: 0x168 - PLL Status
        volatile uint32_t DC9;  ///< Offset: 0x190 - Device Capabilities 9 ADC Digital Comparators
        volatile uint32_t NVMSTAT;  ///< Offset: 0x1A0 - Non-Volatile Memory Information
        volatile uint32_t PPWD;  ///< Offset: 0x300 - Watchdog Timer Peripheral Present
        volatile uint32_t PPTIMER;  ///< Offset: 0x304 - Timer Peripheral Present
        volatile uint32_t PPGPIO;  ///< Offset: 0x308 - General-Purpose Input/Output Peripheral Present
        volatile uint32_t PPDMA;  ///< Offset: 0x30C - Micro Direct Memory Access Peripheral Present
        volatile uint32_t PPHIB;  ///< Offset: 0x314 - Hibernation Peripheral Present
        volatile uint32_t PPUART;  ///< Offset: 0x318 - Universal Asynchronous Receiver/Transmitter Peripheral Present
        volatile uint32_t PPSSI;  ///< Offset: 0x31C - Synchronous Serial Interface Peripheral Present
        volatile uint32_t PPI2C;  ///< Offset: 0x320 - Inter-Integrated Circuit Peripheral Present
        volatile uint32_t PPUSB;  ///< Offset: 0x328 - Universal Serial Bus Peripheral Present
        volatile uint32_t PPCAN;  ///< Offset: 0x334 - Controller Area Network Peripheral Present
        volatile uint32_t PPADC;  ///< Offset: 0x338 - Analog-to-Digital Converter Peripheral Present
        volatile uint32_t PPACMP;  ///< Offset: 0x33C - Analog Comparator Peripheral Present
        volatile uint32_t PPPWM;  ///< Offset: 0x340 - Pulse Width Modulator Peripheral Present
        volatile uint32_t PPQEI;  ///< Offset: 0x344 - Quadrature Encoder Interface Peripheral Present
        volatile uint32_t PPEEPROM;  ///< Offset: 0x358 - EEPROM Peripheral Present
        volatile uint32_t PPWTIMER;  ///< Offset: 0x35C - Wide Timer Peripheral Present
        volatile uint32_t SRWD;  ///< Offset: 0x500 - Watchdog Timer Software Reset
        volatile uint32_t SRTIMER;  ///< Offset: 0x504 - Timer Software Reset
        volatile uint32_t SRGPIO;  ///< Offset: 0x508 - General-Purpose Input/Output Software Reset
        volatile uint32_t SRDMA;  ///< Offset: 0x50C - Micro Direct Memory Access Software Reset
        volatile uint32_t SRUART;  ///< Offset: 0x518 - Universal Asynchronous Receiver/Transmitter Software Reset
        volatile uint32_t SRSSI;  ///< Offset: 0x51C - Synchronous Serial Interface Software Reset
        volatile uint32_t SRI2C;  ///< Offset: 0x520 - Inter-Integrated Circuit Software Reset
        volatile uint32_t SRUSB;  ///< Offset: 0x528 - Universal Serial Bus Software Reset
        volatile uint32_t SRCAN;  ///< Offset: 0x534 - Controller Area Network Software Reset
        volatile uint32_t SRADC;  ///< Offset: 0x538 - Analog-to-Digital Converter Software Reset
        volatile uint32_t SRACMP;  ///< Offset: 0x53C - Analog Comparator Software Reset
        volatile uint32_t SREEPROM;  ///< Offset: 0x558 - EEPROM Software Reset
        volatile uint32_t SRWTIMER;  ///< Offset: 0x55C - Wide Timer Software Reset
        volatile uint32_t RCGCWD;  ///< Offset: 0x600 - Watchdog Timer Run Mode Clock Gating Control
        volatile uint32_t RCGCTIMER;  ///< Offset: 0x604 - Timer Run Mode Clock Gating Control
        volatile uint32_t RCGCGPIO;  ///< Offset: 0x608 - General-Purpose Input/Output Run Mode Clock Gating Control
        volatile uint32_t RCGCDMA;  ///< Offset: 0x60C - Micro Direct Memory Access Run Mode Clock Gating Control
        volatile uint32_t RCGCUART;  ///< Offset: 0x618 - Universal Asynchronous Receiver/Transmitter Run Mode...
        volatile uint32_t RCGCSSI;  ///< Offset: 0x61C - Synchronous Serial Interface Run Mode Clock Gating Control
        volatile uint32_t RCGCI2C;  ///< Offset: 0x620 - Inter-Integrated Circuit Run Mode Clock Gating Control
        volatile uint32_t RCGCUSB;  ///< Offset: 0x628 - Universal Serial Bus Run Mode Clock Gating Control
        volatile uint32_t RCGCCAN;  ///< Offset: 0x634 - Controller Area Network Run Mode Clock Gating Control
        volatile uint32_t RCGCADC;  ///< Offset: 0x638 - Analog-to-Digital Converter Run Mode Clock Gating Control
        volatile uint32_t RCGCACMP;  ///< Offset: 0x63C - Analog Comparator Run Mode Clock Gating Control
        volatile uint32_t RCGCEEPROM;  ///< Offset: 0x658 - EEPROM Run Mode Clock Gating Control
        volatile uint32_t RCGCWTIMER;  ///< Offset: 0x65C - Wide Timer Run Mode Clock Gating Control
        volatile uint32_t SCGCWD;  ///< Offset: 0x700 - Watchdog Timer Sleep Mode Clock Gating Control
        volatile uint32_t SCGCTIMER;  ///< Offset: 0x704 - Timer Sleep Mode Clock Gating Control
        volatile uint32_t SCGCGPIO;  ///< Offset: 0x708 - General-Purpose Input/Output Sleep Mode Clock Gating Control
        volatile uint32_t SCGCDMA;  ///< Offset: 0x70C - Micro Direct Memory Access Sleep Mode Clock Gating Control
        volatile uint32_t SCGCUART;  ///< Offset: 0x718 - Universal Asynchronous Receiver/Transmitter Sleep Mode...
        volatile uint32_t SCGCSSI;  ///< Offset: 0x71C - Synchronous Serial Interface Sleep Mode Clock Gating Control
        volatile uint32_t SCGCI2C;  ///< Offset: 0x720 - Inter-Integrated Circuit Sleep Mode Clock Gating Control
        volatile uint32_t SCGCUSB;  ///< Offset: 0x728 - Universal Serial Bus Sleep Mode Clock Gating Control
        volatile uint32_t SCGCCAN;  ///< Offset: 0x734 - Controller Area Network Sleep Mode Clock Gating Control
        volatile uint32_t SCGCADC;  ///< Offset: 0x738 - Analog-to-Digital Converter Sleep Mode Clock Gating Control
        volatile uint32_t SCGCACMP;  ///< Offset: 0x73C - Analog Comparator Sleep Mode Clock Gating Control
        volatile uint32_t SCGCEEPROM;  ///< Offset: 0x758 - EEPROM Sleep Mode Clock Gating Control
        volatile uint32_t SCGCWTIMER;  ///< Offset: 0x75C - Wide Timer Sleep Mode Clock Gating Control
        volatile uint32_t DCGCWD;  ///< Offset: 0x800 - Watchdog Timer Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCTIMER;  ///< Offset: 0x804 - Timer Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCGPIO;  ///< Offset: 0x808 - General-Purpose Input/Output Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCDMA;  ///< Offset: 0x80C - Micro Direct Memory Access Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCUART;  ///< Offset: 0x818 - Universal Asynchronous Receiver/Transmitter Deep-Sleep...
        volatile uint32_t DCGCSSI;  ///< Offset: 0x81C - Synchronous Serial Interface Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCI2C;  ///< Offset: 0x820 - Inter-Integrated Circuit Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCUSB;  ///< Offset: 0x828 - Universal Serial Bus Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCCAN;  ///< Offset: 0x834 - Controller Area Network Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCADC;  ///< Offset: 0x838 - Analog-to-Digital Converter Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCACMP;  ///< Offset: 0x83C - Analog Comparator Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCEEPROM;  ///< Offset: 0x858 - EEPROM Deep-Sleep Mode Clock Gating Control
        volatile uint32_t DCGCWTIMER;  ///< Offset: 0x85C - Wide Timer Deep-Sleep Mode Clock Gating Control
        volatile uint32_t PRWD;  ///< Offset: 0xA00 - Watchdog Timer Peripheral Ready
        volatile uint32_t PRTIMER;  ///< Offset: 0xA04 - Timer Peripheral Ready
        volatile uint32_t PRGPIO;  ///< Offset: 0xA08 - General-Purpose Input/Output Peripheral Ready
        volatile uint32_t PRDMA;  ///< Offset: 0xA0C - Micro Direct Memory Access Peripheral Ready
        volatile uint32_t PRUART;  ///< Offset: 0xA18 - Universal Asynchronous Receiver/Transmitter Peripheral Ready
        volatile uint32_t PRSSI;  ///< Offset: 0xA1C - Synchronous Serial Interface Peripheral Ready
        volatile uint32_t PRI2C;  ///< Offset: 0xA20 - Inter-Integrated Circuit Peripheral Ready
        volatile uint32_t PRUSB;  ///< Offset: 0xA28 - Universal Serial Bus Peripheral Ready
        volatile uint32_t PRCAN;  ///< Offset: 0xA34 - Controller Area Network Peripheral Ready
        volatile uint32_t PRADC;  ///< Offset: 0xA38 - Analog-to-Digital Converter Peripheral Ready
        volatile uint32_t PRACMP;  ///< Offset: 0xA3C - Analog Comparator Peripheral Ready
        volatile uint32_t PREEPROM;  ///< Offset: 0xA58 - EEPROM Peripheral Ready
        volatile uint32_t PRWTIMER;  ///< Offset: 0xA5C - Wide Timer Peripheral Ready
    };

    /// Peripheral instances
    inline Registers* SYSCTL = reinterpret_cast<Registers*>(SYSCTL_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t UDMA_BASE = 0x400FF000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t STAT;  ///< Offset: 0x00 - DMA Status
        volatile uint32_t CFG;  ///< Offset: 0x04 - DMA Configuration
        volatile uint32_t CTLBASE;  ///< Offset: 0x08 - DMA Channel Control Base Pointer
        volatile uint32_t ALTBASE;  ///< Offset: 0x0C - DMA Alternate Channel Control Base Pointer
        volatile uint32_t WAITSTAT;  ///< Offset: 0x10 - DMA Channel Wait-on-Request Status
        volatile uint32_t SWREQ;  ///< Offset: 0x14 - DMA Channel Software Request
        volatile uint32_t USEBURSTSET;  ///< Offset: 0x18 - DMA Channel Useburst Set
        volatile uint32_t USEBURSTCLR;  ///< Offset: 0x1C - DMA Channel Useburst Clear
        volatile uint32_t REQMASKSET;  ///< Offset: 0x20 - DMA Channel Request Mask Set
        volatile uint32_t REQMASKCLR;  ///< Offset: 0x24 - DMA Channel Request Mask Clear
        volatile uint32_t ENASET;  ///< Offset: 0x28 - DMA Channel Enable Set
        volatile uint32_t ENACLR;  ///< Offset: 0x2C - DMA Channel Enable Clear
        volatile uint32_t ALTSET;  ///< Offset: 0x30 - DMA Channel Primary Alternate Set
        volatile uint32_t ALTCLR;  ///< Offset: 0x34 - DMA Channel Primary Alternate Clear
        volatile uint32_t PRIOSET;  ///< Offset: 0x38 - DMA Channel Priority Set
        volatile uint32_t PRIOCLR;  ///< Offset: 0x3C - DMA Channel Priority Clear
        volatile uint32_t ERRCLR;  ///< Offset: 0x4C - DMA Bus Error Clear
        volatile uint32_t CHASGN;  ///< Offset: 0x500 - DMA Channel Assignment
        volatile uint32_t CHIS;  ///< Offset: 0x504 - DMA Channel Interrupt Status
        volatile uint32_t CHMAP0;  ///< Offset: 0x510 - DMA Channel Map Select 0
        volatile uint32_t CHMAP1;  ///< Offset: 0x514 - DMA Channel Map Select 1
        volatile uint32_t CHMAP2;  ///< Offset: 0x518 - DMA Channel Map Select 2
        volatile uint32_t CHMAP3;  ///< Offset: 0x51C - DMA Channel Map Select 3
    };

    /// Peripheral instances
    inline Registers* UDMA = reinterpret_cast<Registers*>(UDMA_BASE);

}


} // namespace alloy::generated::tm4c1232d5pm

#endif // ALLOY_GENERATED_TM4C1232D5PM_PERIPHERALS_HPP