/// Auto-generated code for esp8266
/// Generated by Alloy Code Generator
/// Source: espressif_community_esp8266.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:28
#ifndef ALLOY_GENERATED_ESP8266_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP8266_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp8266 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_slc = true;
    constexpr uint32_t num_slc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_watchdog = true;
    constexpr uint32_t num_watchdog_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct slc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct watchdog_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t DPORT_BASE = 0x3FF00000;
    constexpr uint32_t GPIO_BASE = 0x60000300;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t EDGE_INT_ENABLE;  ///< Offset: 0x04 - EDGE_INT_ENABLE
        volatile uint32_t DPORT_CTL;  ///< Offset: 0x14 - DPORT_CTL
    };

    /// Peripheral instances
    inline Registers* DPORT = reinterpret_cast<Registers*>(DPORT_BASE);
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// EDGE_INT_ENABLE Register bits
    namespace edge_int_enable_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t wdt_edge_int_enable = (1U << 0);  ///< Enable the watchdog timer edge interrupt
        constexpr uint32_t timer1_edge_int_enable = (1U << 1);  ///< Enable the timer1 edge interrupt
    }

    /// DPORT_CTL Register bits
    namespace dport_ctl_bits {
        constexpr uint32_t DPORT_CTL_DOUBLE_CLK = (1U << 0);  ///< DPORT_CTL_DOUBLE_CLK
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x3FF00050;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t EFUSE_DATA0;  ///< Offset: 0x00 - EFUSE_DATA0
        volatile uint32_t EFUSE_DATA1;  ///< Offset: 0x04 - EFUSE_DATA1
        volatile uint32_t EFUSE_DATA2;  ///< Offset: 0x08 - EFUSE_DATA2
        volatile uint32_t EFUSE_DATA3;  ///< Offset: 0x0C - EFUSE_DATA3
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// EFUSE_DATA0 Register bits
    namespace efuse_data0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// EFUSE_DATA1 Register bits
    namespace efuse_data1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// EFUSE_DATA2 Register bits
    namespace efuse_data2_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// EFUSE_DATA3 Register bits
    namespace efuse_data3_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_BASE = 0x60000E00;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t I2STXFIFO;  ///< Offset: 0x00 - I2STXFIFO
        volatile uint32_t I2SRXFIFO;  ///< Offset: 0x04 - I2SRXFIFO
        volatile uint32_t I2SCONF;  ///< Offset: 0x08 - I2SCONF
        volatile uint32_t I2SINT_RAW;  ///< Offset: 0x0C - I2SINT_RAW
        volatile uint32_t I2SINT_ST;  ///< Offset: 0x10 - I2SINT_ST
        volatile uint32_t I2SINT_ENA;  ///< Offset: 0x14 - I2SINT_ENA
        volatile uint32_t I2SINT_CLR;  ///< Offset: 0x18 - I2SINT_CLR
        volatile uint32_t I2STIMING;  ///< Offset: 0x1C - I2STIMING
        volatile uint32_t I2S_FIFO_CONF;  ///< Offset: 0x20 - I2S_FIFO_CONF
        volatile uint32_t I2SRXEOF_NUM;  ///< Offset: 0x24 - I2SRXEOF_NUM
        volatile uint32_t I2SCONF_SIGLE_DATA;  ///< Offset: 0x28 - I2SCONF_SIGLE_DATA
    };

    /// Peripheral instances
    inline Registers* I2S = reinterpret_cast<Registers*>(I2S_BASE);

    // Bit definitions
    /// I2STXFIFO Register bits
    namespace i2stxfifo_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// I2SRXFIFO Register bits
    namespace i2srxfifo_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// I2SCONF Register bits
    namespace i2sconf_bits {
        constexpr uint32_t I2S_BCK_DIV_NUM = (6 << 22);  ///< I2S_BCK_DIV_NUM
        constexpr uint32_t I2S_CLKM_DIV_NUM = (6 << 16);  ///< I2S_CLKM_DIV_NUM
        constexpr uint32_t I2S_BITS_MOD = (4 << 12);  ///< I2S_BITS_MOD
        constexpr uint32_t I2S_RECE_MSB_SHIFT = (1U << 11);  ///< I2S_RECE_MSB_SHIFT
        constexpr uint32_t I2S_TRANS_MSB_SHIFT = (1U << 10);  ///< I2S_TRANS_MSB_SHIFT
        constexpr uint32_t I2S_I2S_RX_START = (1U << 9);  ///< I2S_I2S_RX_START
        constexpr uint32_t I2S_I2S_TX_START = (1U << 8);  ///< I2S_I2S_TX_START
        constexpr uint32_t I2S_MSB_RIGHT = (1U << 7);  ///< I2S_MSB_RIGHT
        constexpr uint32_t I2S_RIGHT_FIRST = (1U << 6);  ///< I2S_RIGHT_FIRST
        constexpr uint32_t I2S_RECE_SLAVE_MOD = (1U << 5);  ///< I2S_RECE_SLAVE_MOD
        constexpr uint32_t I2S_TRANS_SLAVE_MOD = (1U << 4);  ///< I2S_TRANS_SLAVE_MOD
        constexpr uint32_t I2S_I2S_RX_FIFO_RESET = (1U << 3);  ///< I2S_I2S_RX_FIFO_RESET
        constexpr uint32_t I2S_I2S_TX_FIFO_RESET = (1U << 2);  ///< I2S_I2S_TX_FIFO_RESET
        constexpr uint32_t I2S_I2S_RX_RESET = (1U << 1);  ///< I2S_I2S_RX_RESET
        constexpr uint32_t I2S_I2S_TX_RESET = (1U << 0);  ///< I2S_I2S_TX_RESET
    }

    /// I2SINT_RAW Register bits
    namespace i2sint_raw_bits {
        constexpr uint32_t I2S_I2S_TX_REMPTY_INT_RAW = (1U << 5);  ///< I2S_I2S_TX_REMPTY_INT_RAW
        constexpr uint32_t I2S_I2S_TX_WFULL_INT_RAW = (1U << 4);  ///< I2S_I2S_TX_WFULL_INT_RAW
        constexpr uint32_t I2S_I2S_RX_REMPTY_INT_RAW = (1U << 3);  ///< I2S_I2S_RX_REMPTY_INT_RAW
        constexpr uint32_t I2S_I2S_RX_WFULL_INT_RAW = (1U << 2);  ///< I2S_I2S_RX_WFULL_INT_RAW
        constexpr uint32_t I2S_I2S_TX_PUT_DATA_INT_RAW = (1U << 1);  ///< I2S_I2S_TX_PUT_DATA_INT_RAW
        constexpr uint32_t I2S_I2S_RX_TAKE_DATA_INT_RAW = (1U << 0);  ///< I2S_I2S_RX_TAKE_DATA_INT_RAW
    }

    /// I2SINT_ST Register bits
    namespace i2sint_st_bits {
        constexpr uint32_t I2S_I2S_TX_REMPTY_INT_ST = (1U << 5);  ///< I2S_I2S_TX_REMPTY_INT_ST
        constexpr uint32_t I2S_I2S_TX_WFULL_INT_ST = (1U << 4);  ///< I2S_I2S_TX_WFULL_INT_ST
        constexpr uint32_t I2S_I2S_RX_REMPTY_INT_ST = (1U << 3);  ///< I2S_I2S_RX_REMPTY_INT_ST
        constexpr uint32_t I2S_I2S_RX_WFULL_INT_ST = (1U << 2);  ///< I2S_I2S_RX_WFULL_INT_ST
        constexpr uint32_t I2S_I2S_TX_PUT_DATA_INT_ST = (1U << 1);  ///< I2S_I2S_TX_PUT_DATA_INT_ST
        constexpr uint32_t I2S_I2S_RX_TAKE_DATA_INT_ST = (1U << 0);  ///< I2S_I2S_RX_TAKE_DATA_INT_ST
    }

    /// I2SINT_ENA Register bits
    namespace i2sint_ena_bits {
        constexpr uint32_t I2S_I2S_TX_REMPTY_INT_ENA = (1U << 5);  ///< I2S_I2S_TX_REMPTY_INT_ENA
        constexpr uint32_t I2S_I2S_TX_WFULL_INT_ENA = (1U << 4);  ///< I2S_I2S_TX_WFULL_INT_ENA
        constexpr uint32_t I2S_I2S_RX_REMPTY_INT_ENA = (1U << 3);  ///< I2S_I2S_RX_REMPTY_INT_ENA
        constexpr uint32_t I2S_I2S_RX_WFULL_INT_ENA = (1U << 2);  ///< I2S_I2S_RX_WFULL_INT_ENA
        constexpr uint32_t I2S_I2S_TX_PUT_DATA_INT_ENA = (1U << 1);  ///< I2S_I2S_TX_PUT_DATA_INT_ENA
        constexpr uint32_t I2S_I2S_RX_TAKE_DATA_INT_ENA = (1U << 0);  ///< I2S_I2S_RX_TAKE_DATA_INT_ENA
    }

    /// I2SINT_CLR Register bits
    namespace i2sint_clr_bits {
        constexpr uint32_t I2S_I2S_TX_REMPTY_INT_CLR = (1U << 5);  ///< I2S_I2S_TX_REMPTY_INT_CLR
        constexpr uint32_t I2S_I2S_TX_WFULL_INT_CLR = (1U << 4);  ///< I2S_I2S_TX_WFULL_INT_CLR
        constexpr uint32_t I2S_I2S_RX_REMPTY_INT_CLR = (1U << 3);  ///< I2S_I2S_RX_REMPTY_INT_CLR
        constexpr uint32_t I2S_I2S_RX_WFULL_INT_CLR = (1U << 2);  ///< I2S_I2S_RX_WFULL_INT_CLR
        constexpr uint32_t I2S_I2S_PUT_DATA_INT_CLR = (1U << 1);  ///< I2S_I2S_PUT_DATA_INT_CLR
        constexpr uint32_t I2S_I2S_TAKE_DATA_INT_CLR = (1U << 0);  ///< I2S_I2S_TAKE_DATA_INT_CLR
    }

    /// I2STIMING Register bits
    namespace i2stiming_bits {
        constexpr uint32_t I2S_TRANS_BCK_IN_INV = (1U << 22);  ///< I2S_TRANS_BCK_IN_INV
        constexpr uint32_t I2S_RECE_DSYNC_SW = (1U << 21);  ///< I2S_RECE_DSYNC_SW
        constexpr uint32_t I2S_TRANS_DSYNC_SW = (1U << 20);  ///< I2S_TRANS_DSYNC_SW
        constexpr uint32_t I2S_RECE_BCK_OUT_DELAY = (2 << 18);  ///< I2S_RECE_BCK_OUT_DELAY
        constexpr uint32_t I2S_RECE_WS_OUT_DELAY = (2 << 16);  ///< I2S_RECE_WS_OUT_DELAY
        constexpr uint32_t I2S_TRANS_SD_OUT_DELAY = (2 << 14);  ///< I2S_TRANS_SD_OUT_DELAY
        constexpr uint32_t I2S_TRANS_WS_OUT_DELAY = (2 << 12);  ///< I2S_TRANS_WS_OUT_DELAY
        constexpr uint32_t I2S_TRANS_BCK_OUT_DELAY = (2 << 10);  ///< I2S_TRANS_BCK_OUT_DELAY
        constexpr uint32_t I2S_RECE_SD_IN_DELAY = (2 << 8);  ///< I2S_RECE_SD_IN_DELAY
        constexpr uint32_t I2S_RECE_WS_IN_DELAY = (2 << 6);  ///< I2S_RECE_WS_IN_DELAY
        constexpr uint32_t I2S_RECE_BCK_IN_DELAY = (2 << 4);  ///< I2S_RECE_BCK_IN_DELAY
        constexpr uint32_t I2S_TRANS_WS_IN_DELAY = (2 << 2);  ///< I2S_TRANS_WS_IN_DELAY
        constexpr uint32_t I2S_TRANS_BCK_IN_DELAY = (2 << 0);  ///< I2S_TRANS_BCK_IN_DELAY
    }

    /// I2S_FIFO_CONF Register bits
    namespace i2s_fifo_conf_bits {
        constexpr uint32_t I2S_I2S_RX_FIFO_MOD = (3 << 16);  ///< I2S_I2S_RX_FIFO_MOD
        constexpr uint32_t I2S_I2S_TX_FIFO_MOD = (3 << 13);  ///< I2S_I2S_TX_FIFO_MOD
        constexpr uint32_t I2S_I2S_DSCR_EN = (1U << 12);  ///< I2S_I2S_DSCR_EN
        constexpr uint32_t I2S_I2S_TX_DATA_NUM = (6 << 6);  ///< I2S_I2S_TX_DATA_NUM
        constexpr uint32_t I2S_I2S_RX_DATA_NUM = (6 << 0);  ///< I2S_I2S_RX_DATA_NUM
    }

    /// I2SRXEOF_NUM Register bits
    namespace i2srxeof_num_bits {
        constexpr uint32_t I2S_I2S_RX_EOF_NUM = (32 << 0);  ///< I2S_I2S_RX_EOF_NUM
    }

    /// I2SCONF_SIGLE_DATA Register bits
    namespace i2sconf_sigle_data_bits {
        constexpr uint32_t I2S_I2S_SIGLE_DATA = (32 << 0);  ///< I2S_I2S_SIGLE_DATA
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x60000800;

    /// IO Register structure
    struct Registers {
        volatile uint32_t IO_MUX_CONF;  ///< Offset: 0x00 - IO_MUX_CONF
        volatile uint32_t IO_MUX_MTDI;  ///< Offset: 0x04 - IO_MUX_MTDI
        volatile uint32_t IO_MUX_MTCK;  ///< Offset: 0x08 - IO_MUX_MTCK
        volatile uint32_t IO_MUX_MTMS;  ///< Offset: 0x0C - IO_MUX_MTMS
        volatile uint32_t IO_MUX_MTDO;  ///< Offset: 0x10 - IO_MUX_MTDO
        volatile uint32_t IO_MUX_U0RXD;  ///< Offset: 0x14 - IO_MUX_U0RXD
        volatile uint32_t IO_MUX_U0TXD;  ///< Offset: 0x18 - IO_MUX_U0TXD
        volatile uint32_t IO_MUX_SD_CLK;  ///< Offset: 0x1C - IO_MUX_SD_CLK
        volatile uint32_t IO_MUX_SD_DATA0;  ///< Offset: 0x20 - IO_MUX_SD_DATA0
        volatile uint32_t IO_MUX_SD_DATA1;  ///< Offset: 0x24 - IO_MUX_SD_DATA1
        volatile uint32_t IO_MUX_SD_DATA2;  ///< Offset: 0x28 - IO_MUX_SD_DATA2
        volatile uint32_t IO_MUX_SD_DATA3;  ///< Offset: 0x2C - IO_MUX_SD_DATA3
        volatile uint32_t IO_MUX_SD_CMD;  ///< Offset: 0x30 - IO_MUX_SD_CMD
        volatile uint32_t IO_MUX_GPIO0;  ///< Offset: 0x34 - IO_MUX_GPIO0
        volatile uint32_t IO_MUX_GPIO2;  ///< Offset: 0x38 - IO_MUX_GPIO2
        volatile uint32_t IO_MUX_GPIO4;  ///< Offset: 0x3C - IO_MUX_GPIO4
        volatile uint32_t IO_MUX_GPIO5;  ///< Offset: 0x40 - IO_MUX_GPIO5
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// IO_MUX_CONF Register bits
    namespace io_mux_conf_bits {
        constexpr uint32_t SPI0_CLK_EQU_SYS_CLK = (1U << 8);  ///< SPI0_CLK_EQU_SYS_CLK
        constexpr uint32_t SPI1_CLK_EQU_SYS_CLK = (1U << 9);  ///< SPI1_CLK_EQU_SYS_CLK
    }

    /// IO_MUX_MTDI Register bits
    namespace io_mux_mtdi_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_MTCK Register bits
    namespace io_mux_mtck_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_MTMS Register bits
    namespace io_mux_mtms_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_MTDO Register bits
    namespace io_mux_mtdo_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_U0RXD Register bits
    namespace io_mux_u0rxd_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_U0TXD Register bits
    namespace io_mux_u0txd_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_SD_CLK Register bits
    namespace io_mux_sd_clk_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_SD_DATA0 Register bits
    namespace io_mux_sd_data0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_SD_DATA1 Register bits
    namespace io_mux_sd_data1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_SD_DATA2 Register bits
    namespace io_mux_sd_data2_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_SD_DATA3 Register bits
    namespace io_mux_sd_data3_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_SD_CMD Register bits
    namespace io_mux_sd_cmd_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_GPIO0 Register bits
    namespace io_mux_gpio0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_GPIO2 Register bits
    namespace io_mux_gpio2_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_GPIO4 Register bits
    namespace io_mux_gpio4_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

    /// IO_MUX_GPIO5 Register bits
    namespace io_mux_gpio5_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
        constexpr uint32_t FUNCTION_SELECT_LOW_BITS = (2 << 4);  ///< configures IO_MUX function, bottom 2 bits
        constexpr uint32_t FUNCTION_SELECT_HIGH_BIT = (1U << 8);  ///< configures IO_MUX function, upper bit
        constexpr uint32_t PULLUP = (1U << 7);  ///< configures pull up
        constexpr uint32_t SLEEP_PULLUP = (1U << 3);  ///< configures pull up during sleep mode
        constexpr uint32_t SLEEP_ENABLE = (1U << 0);  ///< configures output enable during sleep mode
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x60000700;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_STORE0;  ///< Offset: 0x30 - RTC_STORE0
        volatile uint32_t RTC_STATE1;  ///< Offset: 0x14 - RTC_STATE1
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// RTC_STORE0 Register bits
    namespace rtc_store0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// RTC_STATE1 Register bits
    namespace rtc_state1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

}

// ============================================================================
// SLC Peripheral
// ============================================================================

namespace slc {
    /// Base addresses
    constexpr uint32_t SLC_BASE = 0x60000B00;

    /// SLC Register structure
    struct Registers {
        volatile uint32_t SLC_CONF0;  ///< Offset: 0x00 - SLC_CONF0
        volatile uint32_t SLC_INT_RAW;  ///< Offset: 0x04 - SLC_INT_RAW
        volatile uint32_t SLC_INT_STATUS;  ///< Offset: 0x08 - SLC_INT_STATUS
        volatile uint32_t SLC_INT_ENA;  ///< Offset: 0x0C - SLC_INT_ENA
        volatile uint32_t SLC_INT_CLR;  ///< Offset: 0x10 - SLC_INT_CLR
        volatile uint32_t SLC_RX_STATUS;  ///< Offset: 0x14 - SLC_RX_STATUS
        volatile uint32_t SLC_RX_FIFO_PUSH;  ///< Offset: 0x18 - SLC_RX_FIFO_PUSH
        volatile uint32_t SLC_TX_STATUS;  ///< Offset: 0x1C - SLC_TX_STATUS
        volatile uint32_t SLC_TX_FIFO_POP;  ///< Offset: 0x20 - SLC_TX_FIFO_POP
        volatile uint32_t SLC_RX_LINK;  ///< Offset: 0x24 - SLC_RX_LINK
        volatile uint32_t SLC_TX_LINK;  ///< Offset: 0x28 - SLC_TX_LINK
        volatile uint32_t SLC_INTVEC_TOHOST;  ///< Offset: 0x2C - SLC_INTVEC_TOHOST
        volatile uint32_t SLC_TOKEN0;  ///< Offset: 0x30 - SLC_TOKEN0
        volatile uint32_t SLC_TOKEN1;  ///< Offset: 0x34 - SLC_TOKEN1
        volatile uint32_t SLC_CONF1;  ///< Offset: 0x38 - SLC_CONF1
        volatile uint32_t SLC_STATE0;  ///< Offset: 0x3C - SLC_STATE0
        volatile uint32_t SLC_STATE1;  ///< Offset: 0x40 - SLC_STATE1
        volatile uint32_t SLC_BRIDGE_CONF;  ///< Offset: 0x44 - SLC_BRIDGE_CONF
        volatile uint32_t SLC_RX_EOF_DES_ADDR;  ///< Offset: 0x48 - SLC_RX_EOF_DES_ADDR
        volatile uint32_t SLC_TX_EOF_DES_ADDR;  ///< Offset: 0x4C - SLC_TX_EOF_DES_ADDR
        volatile uint32_t SLC_RX_EOF_BFR_DES_ADDR;  ///< Offset: 0x50 - SLC_RX_EOF_BFR_DES_ADDR
        volatile uint32_t SLC_AHB_TEST;  ///< Offset: 0x54 - SLC_AHB_TEST
        volatile uint32_t SLC_SDIO_ST;  ///< Offset: 0x58 - SLC_SDIO_ST
        volatile uint32_t SLC_RX_DSCR_CONF;  ///< Offset: 0x5C - SLC_RX_DSCR_CONF
        volatile uint32_t SLC_TXLINK_DSCR;  ///< Offset: 0x60 - SLC_TXLINK_DSCR
        volatile uint32_t SLC_TXLINK_DSCR_BF0;  ///< Offset: 0x64 - SLC_TXLINK_DSCR_BF0
        volatile uint32_t SLC_TXLINK_DSCR_BF1;  ///< Offset: 0x68 - SLC_TXLINK_DSCR_BF1
        volatile uint32_t SLC_RXLINK_DSCR;  ///< Offset: 0x6C - SLC_RXLINK_DSCR
        volatile uint32_t SLC_RXLINK_DSCR_BF0;  ///< Offset: 0x70 - SLC_RXLINK_DSCR_BF0
        volatile uint32_t SLC_RXLINK_DSCR_BF1;  ///< Offset: 0x74 - SLC_RXLINK_DSCR_BF1
        volatile uint32_t SLC_DATE;  ///< Offset: 0x78 - SLC_DATE
        volatile uint32_t SLC_ID;  ///< Offset: 0x7C - SLC_ID
    };

    /// Peripheral instances
    inline Registers* SLC = reinterpret_cast<Registers*>(SLC_BASE);

    // Bit definitions
    /// SLC_CONF0 Register bits
    namespace slc_conf0_bits {
        constexpr uint32_t SLC_MODE = (2 << 12);  ///< SLC_MODE
        constexpr uint32_t SLC_DATA_BURST_EN = (1U << 9);  ///< SLC_DATA_BURST_EN
        constexpr uint32_t SLC_DSCR_BURST_EN = (1U << 8);  ///< SLC_DSCR_BURST_EN
        constexpr uint32_t SLC_RX_NO_RESTART_CLR = (1U << 7);  ///< SLC_RX_NO_RESTART_CLR
        constexpr uint32_t SLC_RX_AUTO_WRBACK = (1U << 6);  ///< SLC_RX_AUTO_WRBACK
        constexpr uint32_t SLC_RX_LOOP_TEST = (1U << 5);  ///< SLC_RX_LOOP_TEST
        constexpr uint32_t SLC_TX_LOOP_TEST = (1U << 4);  ///< SLC_TX_LOOP_TEST
        constexpr uint32_t SLC_AHBM_RST = (1U << 3);  ///< SLC_AHBM_RST
        constexpr uint32_t SLC_AHBM_FIFO_RST = (1U << 2);  ///< SLC_AHBM_FIFO_RST
        constexpr uint32_t SLC_RXLINK_RST = (1U << 1);  ///< SLC_RXLINK_RST
        constexpr uint32_t SLC_TXLINK_RST = (1U << 0);  ///< SLC_TXLINK_RST
    }

    /// SLC_INT_RAW Register bits
    namespace slc_int_raw_bits {
        constexpr uint32_t SLC_TX_DSCR_EMPTY_INT_RAW = (1U << 21);  ///< SLC_TX_DSCR_EMPTY_INT_RAW
        constexpr uint32_t SLC_RX_DSCR_ERR_INT_RAW = (1U << 20);  ///< SLC_RX_DSCR_ERR_INT_RAW
        constexpr uint32_t SLC_TX_DSCR_ERR_INT_RAW = (1U << 19);  ///< SLC_TX_DSCR_ERR_INT_RAW
        constexpr uint32_t SLC_TOHOST_INT_RAW = (1U << 18);  ///< SLC_TOHOST_INT_RAW
        constexpr uint32_t SLC_RX_EOF_INT_RAW = (1U << 17);  ///< SLC_RX_EOF_INT_RAW
        constexpr uint32_t SLC_RX_DONE_INT_RAW = (1U << 16);  ///< SLC_RX_DONE_INT_RAW
        constexpr uint32_t SLC_TX_EOF_INT_RAW = (1U << 15);  ///< SLC_TX_EOF_INT_RAW
        constexpr uint32_t SLC_TX_DONE_INT_RAW = (1U << 14);  ///< SLC_TX_DONE_INT_RAW
        constexpr uint32_t SLC_TOKEN1_1TO0_INT_RAW = (1U << 13);  ///< SLC_TOKEN1_1TO0_INT_RAW
        constexpr uint32_t SLC_TOKEN0_1TO0_INT_RAW = (1U << 12);  ///< SLC_TOKEN0_1TO0_INT_RAW
        constexpr uint32_t SLC_TX_OVF_INT_RAW = (1U << 11);  ///< SLC_TX_OVF_INT_RAW
        constexpr uint32_t SLC_RX_UDF_INT_RAW = (1U << 10);  ///< SLC_RX_UDF_INT_RAW
        constexpr uint32_t SLC_TX_START_INT_RAW = (1U << 9);  ///< SLC_TX_START_INT_RAW
        constexpr uint32_t SLC_RX_START_INT_RAW = (1U << 8);  ///< SLC_RX_START_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT7_INT_RAW = (1U << 7);  ///< SLC_FRHOST_BIT7_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT6_INT_RAW = (1U << 6);  ///< SLC_FRHOST_BIT6_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT5_INT_RAW = (1U << 5);  ///< SLC_FRHOST_BIT5_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT4_INT_RAW = (1U << 4);  ///< SLC_FRHOST_BIT4_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT3_INT_RAW = (1U << 3);  ///< SLC_FRHOST_BIT3_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT2_INT_RAW = (1U << 2);  ///< SLC_FRHOST_BIT2_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT1_INT_RAW = (1U << 1);  ///< SLC_FRHOST_BIT1_INT_RAW
        constexpr uint32_t SLC_FRHOST_BIT0_INT_RAW = (1U << 0);  ///< SLC_FRHOST_BIT0_INT_RAW
    }

    /// SLC_INT_STATUS Register bits
    namespace slc_int_status_bits {
        constexpr uint32_t SLC_TX_DSCR_EMPTY_INT_ST = (1U << 21);  ///< SLC_TX_DSCR_EMPTY_INT_ST
        constexpr uint32_t SLC_RX_DSCR_ERR_INT_ST = (1U << 20);  ///< SLC_RX_DSCR_ERR_INT_ST
        constexpr uint32_t SLC_TX_DSCR_ERR_INT_ST = (1U << 19);  ///< SLC_TX_DSCR_ERR_INT_ST
        constexpr uint32_t SLC_TOHOST_INT_ST = (1U << 18);  ///< SLC_TOHOST_INT_ST
        constexpr uint32_t SLC_RX_EOF_INT_ST = (1U << 17);  ///< SLC_RX_EOF_INT_ST
        constexpr uint32_t SLC_RX_DONE_INT_ST = (1U << 16);  ///< SLC_RX_DONE_INT_ST
        constexpr uint32_t SLC_TX_EOF_INT_ST = (1U << 15);  ///< SLC_TX_EOF_INT_ST
        constexpr uint32_t SLC_TX_DONE_INT_ST = (1U << 14);  ///< SLC_TX_DONE_INT_ST
        constexpr uint32_t SLC_TOKEN1_1TO0_INT_ST = (1U << 13);  ///< SLC_TOKEN1_1TO0_INT_ST
        constexpr uint32_t SLC_TOKEN0_1TO0_INT_ST = (1U << 12);  ///< SLC_TOKEN0_1TO0_INT_ST
        constexpr uint32_t SLC_TX_OVF_INT_ST = (1U << 11);  ///< SLC_TX_OVF_INT_ST
        constexpr uint32_t SLC_RX_UDF_INT_ST = (1U << 10);  ///< SLC_RX_UDF_INT_ST
        constexpr uint32_t SLC_TX_START_INT_ST = (1U << 9);  ///< SLC_TX_START_INT_ST
        constexpr uint32_t SLC_RX_START_INT_ST = (1U << 8);  ///< SLC_RX_START_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT7_INT_ST = (1U << 7);  ///< SLC_FRHOST_BIT7_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT6_INT_ST = (1U << 6);  ///< SLC_FRHOST_BIT6_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT5_INT_ST = (1U << 5);  ///< SLC_FRHOST_BIT5_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT4_INT_ST = (1U << 4);  ///< SLC_FRHOST_BIT4_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT3_INT_ST = (1U << 3);  ///< SLC_FRHOST_BIT3_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT2_INT_ST = (1U << 2);  ///< SLC_FRHOST_BIT2_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT1_INT_ST = (1U << 1);  ///< SLC_FRHOST_BIT1_INT_ST
        constexpr uint32_t SLC_FRHOST_BIT0_INT_ST = (1U << 0);  ///< SLC_FRHOST_BIT0_INT_ST
    }

    /// SLC_INT_ENA Register bits
    namespace slc_int_ena_bits {
        constexpr uint32_t SLC_TX_DSCR_EMPTY_INT_ENA = (1U << 21);  ///< SLC_TX_DSCR_EMPTY_INT_ENA
        constexpr uint32_t SLC_RX_DSCR_ERR_INT_ENA = (1U << 20);  ///< SLC_RX_DSCR_ERR_INT_ENA
        constexpr uint32_t SLC_TX_DSCR_ERR_INT_ENA = (1U << 19);  ///< SLC_TX_DSCR_ERR_INT_ENA
        constexpr uint32_t SLC_TOHOST_INT_ENA = (1U << 18);  ///< SLC_TOHOST_INT_ENA
        constexpr uint32_t SLC_RX_EOF_INT_ENA = (1U << 17);  ///< SLC_RX_EOF_INT_ENA
        constexpr uint32_t SLC_RX_DONE_INT_ENA = (1U << 16);  ///< SLC_RX_DONE_INT_ENA
        constexpr uint32_t SLC_TX_EOF_INT_ENA = (1U << 15);  ///< SLC_TX_EOF_INT_ENA
        constexpr uint32_t SLC_TX_DONE_INT_ENA = (1U << 14);  ///< SLC_TX_DONE_INT_ENA
        constexpr uint32_t SLC_TOKEN1_1TO0_INT_ENA = (1U << 13);  ///< SLC_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t SLC_TOKEN0_1TO0_INT_ENA = (1U << 12);  ///< SLC_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t SLC_TX_OVF_INT_ENA = (1U << 11);  ///< SLC_TX_OVF_INT_ENA
        constexpr uint32_t SLC_RX_UDF_INT_ENA = (1U << 10);  ///< SLC_RX_UDF_INT_ENA
        constexpr uint32_t SLC_TX_START_INT_ENA = (1U << 9);  ///< SLC_TX_START_INT_ENA
        constexpr uint32_t SLC_RX_START_INT_ENA = (1U << 8);  ///< SLC_RX_START_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT7_INT_ENA = (1U << 7);  ///< SLC_FRHOST_BIT7_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT6_INT_ENA = (1U << 6);  ///< SLC_FRHOST_BIT6_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT5_INT_ENA = (1U << 5);  ///< SLC_FRHOST_BIT5_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT4_INT_ENA = (1U << 4);  ///< SLC_FRHOST_BIT4_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT3_INT_ENA = (1U << 3);  ///< SLC_FRHOST_BIT3_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT2_INT_ENA = (1U << 2);  ///< SLC_FRHOST_BIT2_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT1_INT_ENA = (1U << 1);  ///< SLC_FRHOST_BIT1_INT_ENA
        constexpr uint32_t SLC_FRHOST_BIT0_INT_ENA = (1U << 0);  ///< SLC_FRHOST_BIT0_INT_ENA
    }

    /// SLC_INT_CLR Register bits
    namespace slc_int_clr_bits {
        constexpr uint32_t SLC_TX_DSCR_EMPTY_INT_CLR = (1U << 21);  ///< SLC_TX_DSCR_EMPTY_INT_CLR
        constexpr uint32_t SLC_RX_DSCR_ERR_INT_CLR = (1U << 20);  ///< SLC_RX_DSCR_ERR_INT_CLR
        constexpr uint32_t SLC_TX_DSCR_ERR_INT_CLR = (1U << 19);  ///< SLC_TX_DSCR_ERR_INT_CLR
        constexpr uint32_t SLC_TOHOST_INT_CLR = (1U << 18);  ///< SLC_TOHOST_INT_CLR
        constexpr uint32_t SLC_RX_EOF_INT_CLR = (1U << 17);  ///< SLC_RX_EOF_INT_CLR
        constexpr uint32_t SLC_RX_DONE_INT_CLR = (1U << 16);  ///< SLC_RX_DONE_INT_CLR
        constexpr uint32_t SLC_TX_EOF_INT_CLR = (1U << 15);  ///< SLC_TX_EOF_INT_CLR
        constexpr uint32_t SLC_TX_DONE_INT_CLR = (1U << 14);  ///< SLC_TX_DONE_INT_CLR
        constexpr uint32_t SLC_TOKEN1_1TO0_INT_CLR = (1U << 13);  ///< SLC_TOKEN1_1TO0_INT_CLR
        constexpr uint32_t SLC_TOKEN0_1TO0_INT_CLR = (1U << 12);  ///< SLC_TOKEN0_1TO0_INT_CLR
        constexpr uint32_t SLC_TX_OVF_INT_CLR = (1U << 11);  ///< SLC_TX_OVF_INT_CLR
        constexpr uint32_t SLC_RX_UDF_INT_CLR = (1U << 10);  ///< SLC_RX_UDF_INT_CLR
        constexpr uint32_t SLC_TX_START_INT_CLR = (1U << 9);  ///< SLC_TX_START_INT_CLR
        constexpr uint32_t SLC_RX_START_INT_CLR = (1U << 8);  ///< SLC_RX_START_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT7_INT_CLR = (1U << 7);  ///< SLC_FRHOST_BIT7_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT6_INT_CLR = (1U << 6);  ///< SLC_FRHOST_BIT6_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT5_INT_CLR = (1U << 5);  ///< SLC_FRHOST_BIT5_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT4_INT_CLR = (1U << 4);  ///< SLC_FRHOST_BIT4_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT3_INT_CLR = (1U << 3);  ///< SLC_FRHOST_BIT3_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT2_INT_CLR = (1U << 2);  ///< SLC_FRHOST_BIT2_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT1_INT_CLR = (1U << 1);  ///< SLC_FRHOST_BIT1_INT_CLR
        constexpr uint32_t SLC_FRHOST_BIT0_INT_CLR = (1U << 0);  ///< SLC_FRHOST_BIT0_INT_CLR
    }

    /// SLC_RX_STATUS Register bits
    namespace slc_rx_status_bits {
        constexpr uint32_t SLC_RX_EMPTY = (1U << 1);  ///< SLC_RX_EMPTY
        constexpr uint32_t SLC_RX_FULL = (1U << 0);  ///< SLC_RX_FULL
    }

    /// SLC_RX_FIFO_PUSH Register bits
    namespace slc_rx_fifo_push_bits {
        constexpr uint32_t SLC_RXFIFO_PUSH = (1U << 16);  ///< SLC_RXFIFO_PUSH
        constexpr uint32_t SLC_RXFIFO_WDATA = (9 << 0);  ///< SLC_RXFIFO_WDATA
    }

    /// SLC_TX_STATUS Register bits
    namespace slc_tx_status_bits {
        constexpr uint32_t SLC_TX_EMPTY = (1U << 1);  ///< SLC_TX_EMPTY
        constexpr uint32_t SLC_TX_FULL = (1U << 0);  ///< SLC_TX_FULL
    }

    /// SLC_TX_FIFO_POP Register bits
    namespace slc_tx_fifo_pop_bits {
        constexpr uint32_t SLC_TXFIFO_POP = (1U << 16);  ///< SLC_TXFIFO_POP
        constexpr uint32_t SLC_TXFIFO_RDATA = (11 << 0);  ///< SLC_TXFIFO_RDATA
    }

    /// SLC_RX_LINK Register bits
    namespace slc_rx_link_bits {
        constexpr uint32_t SLC_RXLINK_PARK = (1U << 31);  ///< SLC_RXLINK_PARK
        constexpr uint32_t SLC_RXLINK_RESTART = (1U << 30);  ///< SLC_RXLINK_RESTART
        constexpr uint32_t SLC_RXLINK_START = (1U << 29);  ///< SLC_RXLINK_START
        constexpr uint32_t SLC_RXLINK_STOP = (1U << 28);  ///< SLC_RXLINK_STOP
        constexpr uint32_t SLC_RXLINK_ADDR = (20 << 0);  ///< SLC_RXLINK_ADDR
    }

    /// SLC_TX_LINK Register bits
    namespace slc_tx_link_bits {
        constexpr uint32_t SLC_TXLINK_PARK = (1U << 31);  ///< SLC_TXLINK_PARK
        constexpr uint32_t SLC_TXLINK_RESTART = (1U << 30);  ///< SLC_TXLINK_RESTART
        constexpr uint32_t SLC_TXLINK_START = (1U << 29);  ///< SLC_TXLINK_START
        constexpr uint32_t SLC_TXLINK_STOP = (1U << 28);  ///< SLC_TXLINK_STOP
        constexpr uint32_t SLC_TXLINK_ADDR = (20 << 0);  ///< SLC_TXLINK_ADDR
    }

    /// SLC_INTVEC_TOHOST Register bits
    namespace slc_intvec_tohost_bits {
        constexpr uint32_t SLC_TOHOST_INTVEC = (8 << 0);  ///< SLC_TOHOST_INTVEC
    }

    /// SLC_TOKEN0 Register bits
    namespace slc_token0_bits {
        constexpr uint32_t SLC_TOKEN0 = (12 << 16);  ///< SLC_TOKEN0
        constexpr uint32_t SLC_TOKEN0_LOCAL_INC_MORE = (1U << 14);  ///< SLC_TOKEN0_LOCAL_INC_MORE
        constexpr uint32_t SLC_TOKEN0_LOCAL_INC = (1U << 13);  ///< SLC_TOKEN0_LOCAL_INC
        constexpr uint32_t SLC_TOKEN0_LOCAL_WR = (1U << 12);  ///< SLC_TOKEN0_LOCAL_WR
        constexpr uint32_t SLC_TOKEN0_LOCAL_WDATA = (12 << 0);  ///< SLC_TOKEN0_LOCAL_WDATA
    }

    /// SLC_TOKEN1 Register bits
    namespace slc_token1_bits {
        constexpr uint32_t SLC_TOKEN1 = (12 << 16);  ///< SLC_TOKEN1
        constexpr uint32_t SLC_TOKEN1_LOCAL_INC_MORE = (1U << 14);  ///< SLC_TOKEN1_LOCAL_INC_MORE
        constexpr uint32_t SLC_TOKEN1_LOCAL_INC = (1U << 13);  ///< SLC_TOKEN1_LOCAL_INC
        constexpr uint32_t SLC_TOKEN1_LOCAL_WR = (1U << 12);  ///< SLC_TOKEN1_LOCAL_WR
        constexpr uint32_t SLC_TOKEN1_LOCAL_WDATA = (12 << 0);  ///< SLC_TOKEN1_LOCAL_WDATA
    }

    /// SLC_CONF1 Register bits
    namespace slc_conf1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_STATE0 Register bits
    namespace slc_state0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_STATE1 Register bits
    namespace slc_state1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_BRIDGE_CONF Register bits
    namespace slc_bridge_conf_bits {
        constexpr uint32_t SLC_TX_PUSH_IDLE_NUM = (16 << 16);  ///< SLC_TX_PUSH_IDLE_NUM
        constexpr uint32_t SLC_TX_DUMMY_MODE = (1U << 12);  ///< SLC_TX_DUMMY_MODE
        constexpr uint32_t SLC_FIFO_MAP_ENA = (4 << 8);  ///< SLC_FIFO_MAP_ENA
        constexpr uint32_t SLC_TXEOF_ENA = (6 << 0);  ///< SLC_TXEOF_ENA
    }

    /// SLC_RX_EOF_DES_ADDR Register bits
    namespace slc_rx_eof_des_addr_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_TX_EOF_DES_ADDR Register bits
    namespace slc_tx_eof_des_addr_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_RX_EOF_BFR_DES_ADDR Register bits
    namespace slc_rx_eof_bfr_des_addr_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_AHB_TEST Register bits
    namespace slc_ahb_test_bits {
        constexpr uint32_t SLC_AHB_TESTADDR = (2 << 4);  ///< SLC_AHB_TESTADDR
        constexpr uint32_t SLC_AHB_TESTMODE = (3 << 0);  ///< SLC_AHB_TESTMODE
    }

    /// SLC_SDIO_ST Register bits
    namespace slc_sdio_st_bits {
        constexpr uint32_t SLC_BUS_ST = (3 << 12);  ///< SLC_BUS_ST
        constexpr uint32_t SLC_SDIO_WAKEUP = (1U << 8);  ///< SLC_SDIO_WAKEUP
        constexpr uint32_t SLC_FUNC_ST = (4 << 4);  ///< SLC_FUNC_ST
        constexpr uint32_t SLC_CMD_ST = (3 << 0);  ///< SLC_CMD_ST
    }

    /// SLC_RX_DSCR_CONF Register bits
    namespace slc_rx_dscr_conf_bits {
        constexpr uint32_t SLC_INFOR_NO_REPLACE = (1U << 9);  ///< SLC_INFOR_NO_REPLACE
        constexpr uint32_t SLC_TOKEN_NO_REPLACE = (1U << 8);  ///< SLC_TOKEN_NO_REPLACE
    }

    /// SLC_TXLINK_DSCR Register bits
    namespace slc_txlink_dscr_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_TXLINK_DSCR_BF0 Register bits
    namespace slc_txlink_dscr_bf0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_TXLINK_DSCR_BF1 Register bits
    namespace slc_txlink_dscr_bf1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_RXLINK_DSCR Register bits
    namespace slc_rxlink_dscr_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_RXLINK_DSCR_BF0 Register bits
    namespace slc_rxlink_dscr_bf0_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_RXLINK_DSCR_BF1 Register bits
    namespace slc_rxlink_dscr_bf1_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_DATE Register bits
    namespace slc_date_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// SLC_ID Register bits
    namespace slc_id_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x60000200;
    constexpr uint32_t SPI1_BASE = 0x60000100;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CMD;  ///< Offset: 0x00 - In the master mode, it is the start bit of a single...
        volatile uint32_t SPI_ADDR;  ///< Offset: 0x04 - In the master mode, it is the value of address in...
        volatile uint32_t SPI_CTRL;  ///< Offset: 0x08 - SPI_CTRL
        volatile uint32_t SPI_RD_STATUS;  ///< Offset: 0x10 - In the slave mode, this register are the status register...
        volatile uint32_t SPI_CTRL2;  ///< Offset: 0x14 - spi_cs signal is delayed by 80MHz clock cycles
        volatile uint32_t SPI_CLOCK;  ///< Offset: 0x18 - In the master mode, 1: spi_clk is eqaul to 80MHz, 0:...
        volatile uint32_t SPI_USER;  ///< Offset: 0x1C - This bit enable the "command" phase of an operation.
        volatile uint32_t SPI_USER1;  ///< Offset: 0x20 - The length in bits of "address" phase. The register...
        volatile uint32_t SPI_USER2;  ///< Offset: 0x24 - The length in bits of "command" phase. The register...
        volatile uint32_t SPI_WR_STATUS;  ///< Offset: 0x28 - In the slave mode, this register are the status register...
        volatile uint32_t SPI_PIN;  ///< Offset: 0x2C - 1: disable CS2; 0: spi_cs signal is from/to CS2 pin
        volatile uint32_t SPI_SLAVE;  ///< Offset: 0x30 - It is the synchronous reset signal of the module. This...
        volatile uint32_t SPI_SLAVE1;  ///< Offset: 0x34 - In the slave mode, it is the length in bits for...
        volatile uint32_t SPI_SLAVE2;  ///< Offset: 0x38 - In the slave mode, it is the length in spi_clk cycles...
        volatile uint32_t SPI_SLAVE3;  ///< Offset: 0x3C - In slave mode, it is the value of "write-status" command
        volatile uint32_t SPI_EXT3;  ///< Offset: 0xFC - This register is for two SPI masters to share the same...
        volatile uint32_t SPI_W0;  ///< Offset: 0x40 - the data inside the buffer of the SPI module, byte 0
        volatile uint32_t SPI_W1;  ///< Offset: 0x60 - the data inside the buffer of the SPI module, byte 1
        volatile uint32_t SPI_W2;  ///< Offset: 0x80 - the data inside the buffer of the SPI module, byte 2
        volatile uint32_t SPI_W3;  ///< Offset: 0xA0 - the data inside the buffer of the SPI module, byte 3
        volatile uint32_t SPI_W4;  ///< Offset: 0xC0 - the data inside the buffer of the SPI module, byte 4
        volatile uint32_t SPI_W5;  ///< Offset: 0xE0 - the data inside the buffer of the SPI module, byte 5
        volatile uint32_t SPI_W6;  ///< Offset: 0x100 - the data inside the buffer of the SPI module, byte 6
        volatile uint32_t SPI_W7;  ///< Offset: 0x120 - the data inside the buffer of the SPI module, byte 7
        volatile uint32_t SPI_W8;  ///< Offset: 0x140 - the data inside the buffer of the SPI module, byte 8
        volatile uint32_t SPI_W9;  ///< Offset: 0x160 - the data inside the buffer of the SPI module, byte 9
        volatile uint32_t SPI_W10;  ///< Offset: 0x180 - the data inside the buffer of the SPI module, byte 10
        volatile uint32_t SPI_W11;  ///< Offset: 0x1A0 - the data inside the buffer of the SPI module, byte 11
        volatile uint32_t SPI_W12;  ///< Offset: 0x1C0 - the data inside the buffer of the SPI module, byte 12
        volatile uint32_t SPI_W13;  ///< Offset: 0x1E0 - the data inside the buffer of the SPI module, byte 13
        volatile uint32_t SPI_W14;  ///< Offset: 0x200 - the data inside the buffer of the SPI module, byte 14
        volatile uint32_t SPI_W15;  ///< Offset: 0x220 - the data inside the buffer of the SPI module, byte 15
        volatile uint32_t SPI_CTRL1;  ///< Offset: 0x0C - In the slave mode, it is the status for master to read out.
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// SPI_CMD Register bits
    namespace spi_cmd_bits {
        constexpr uint32_t spi_usr = (1U << 18);  ///< In the master mode, it is the start bit of a single operation. Self-clear by  hardware
        constexpr uint32_t spi_read = (1U << 31);  ///< spi_read
        constexpr uint32_t spi_write_enable = (1U << 30);  ///< spi_write_enable
        constexpr uint32_t spi_write_disable = (1U << 29);  ///< spi_write_disable
        constexpr uint32_t spi_read_id = (1U << 28);  ///< spi_read_id
        constexpr uint32_t spi_read_sr = (1U << 27);  ///< spi_read_sr
        constexpr uint32_t spi_write_sr = (1U << 26);  ///< spi_write_sr
        constexpr uint32_t spi_pp = (1U << 25);  ///< spi_pp
        constexpr uint32_t spi_se = (1U << 24);  ///< spi_se
        constexpr uint32_t spi_be = (1U << 23);  ///< spi_be
        constexpr uint32_t spi_ce = (1U << 22);  ///< spi_ce
        constexpr uint32_t spi_dp = (1U << 21);  ///< spi_dp
        constexpr uint32_t spi_res = (1U << 20);  ///< spi_res
        constexpr uint32_t spi_hpm = (1U << 19);  ///< spi_hpm
    }

    /// SPI_ADDR Register bits
    namespace spi_addr_bits {
        constexpr uint32_t iodata_start_addr = (32 << 0);  ///< In the master mode, it is the value of address in "address" phase.
        constexpr uint32_t address = (24 << 0);  ///< address
        constexpr uint32_t size = (8 << 24);  ///< size
    }

    /// SPI_CTRL Register bits
    namespace spi_ctrl_bits {
        constexpr uint32_t spi_wr_bit_order = (1U << 26);  ///< In "command", "address", "write-data" (MOSI) phases, 1: LSB first; 0: MSB  first
        constexpr uint32_t spi_rd_bit_order = (1U << 25);  ///< In "read-data" (MISO) phase, 1: LSB first; 0: MSB first
        constexpr uint32_t spi_qio_mode = (1U << 24);  ///< In the read operations, "address" phase and "read-data" phase apply 4 signals
        constexpr uint32_t spi_dio_mode = (1U << 23);  ///< In the read operations, "address" phase and "read-data" phase apply 2 signals
        constexpr uint32_t spi_qout_mode = (1U << 20);  ///< In the read operations, "read-data" phase apply 4 signals
        constexpr uint32_t spi_dout_mode = (1U << 14);  ///< In the read operations, "read-data" phase apply 2 signals
        constexpr uint32_t spi_fastrd_mode = (1U << 13);  ///< this bit enable the bits: spi_qio_mode, spi_dio_mode, spi_qout_mode and  spi_dout_mode
    }

    /// SPI_RD_STATUS Register bits
    namespace spi_rd_status_bits {
        constexpr uint32_t slv_rd_status = (32 << 0);  ///< In the slave mode, this register are the status register for the master to read  out.
    }

    /// SPI_CTRL2 Register bits
    namespace spi_ctrl2_bits {
        constexpr uint32_t spi_cs_delay_num = (4 << 28);  ///< spi_cs signal is delayed by 80MHz clock cycles
        constexpr uint32_t spi_cs_delay_mode = (2 << 26);  ///< spi_cs signal is delayed by spi_clk. 0: zero; 1: half cycle; 2: one cycle
        constexpr uint32_t spi_mosi_delay_num = (3 << 23);  ///< MOSI signals are delayed by 80MHz clock cycles
        constexpr uint32_t spi_mosi_delay_mode = (2 << 21);  ///< MOSI signals are delayed by spi_clk. 0: zero; 1: half cycle; 2: one cycle
        constexpr uint32_t spi_miso_delay_num = (3 << 18);  ///< MISO signals are delayed by 80MHz clock cycles
        constexpr uint32_t spi_miso_delay_mode = (2 << 16);  ///< MISO signals are delayed by spi_clk. 0: zero; 1: half cycle; 2: one cycle
    }

    /// SPI_CLOCK Register bits
    namespace spi_clock_bits {
        constexpr uint32_t spi_clk_equ_sysclk = (1U << 31);  ///< In the master mode, 1: spi_clk is eqaul to 80MHz, 0: spi_clk is divided from 80  MHz clock.
        constexpr uint32_t spi_clkdiv_pre = (13 << 18);  ///< In the master mode, it is pre-divider of spi_clk.
        constexpr uint32_t spi_clkcnt_N = (6 << 12);  ///< In the master mode, it is the divider of spi_clk. So spi_clk frequency is  80MHz/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1)
        constexpr uint32_t spi_clkcnt_H = (6 << 6);  ///< In the master mode, it must be floor((spi_clkcnt_N+1)/2-1). In the slave mode,  it must be 0.
        constexpr uint32_t spi_clkcnt_L = (6 << 0);  ///< In the master mode, it must be eqaul to spi_clkcnt_N. In the slave mode, it  must be 0.
    }

    /// SPI_USER Register bits
    namespace spi_user_bits {
        constexpr uint32_t spi_usr_command = (1U << 31);  ///< This bit enable the "command" phase of an operation.
        constexpr uint32_t spi_usr_addr = (1U << 30);  ///< This bit enable the "address" phase of an operation.
        constexpr uint32_t spi_usr_dummy = (1U << 29);  ///< This bit enable the "dummy" phase of an operation.
        constexpr uint32_t spi_usr_miso = (1U << 28);  ///< This bit enable the "read-data" phase of an operation.
        constexpr uint32_t spi_usr_mosi = (1U << 27);  ///< This bit enable the "write-data" phase of an operation.
        constexpr uint32_t reg_usr_mosi_highpart = (1U << 25);  ///< 1: "write-data" phase only access to high-part of the buffer spi_w8~spi_w15
        constexpr uint32_t reg_usr_miso_highpart = (1U << 24);  ///< 1: "read-data" phase only access to high-part of the buffer spi_w8~spi_w15
        constexpr uint32_t spi_sio = (1U << 16);  ///< 1: mosi and miso signals share the same pin
        constexpr uint32_t spi_fwrite_qio = (1U << 15);  ///< In the write operations, "address" phase and "read-data" phase apply 4  signals
        constexpr uint32_t spi_fwrite_dio = (1U << 14);  ///< In the write operations, "address" phase and "read-data" phase apply 2  signals
        constexpr uint32_t spi_fwrite_quad = (1U << 13);  ///< In the write operations, "read-data" phase apply 4 signals
        constexpr uint32_t spi_fwrite_dual = (1U << 12);  ///< In the write operations, "read-data" phase apply 2 signals
        constexpr uint32_t spi_wr_byte_order = (1U << 11);  ///< In "command", "address", "write-data" (MOSI) phases, 1: little-endian; 0:  big_endian
        constexpr uint32_t spi_rd_byte_order = (1U << 10);  ///< In "read-data" (MISO) phase, 1: little-endian; 0: big_endian
        constexpr uint32_t spi_ck_i_edge = (1U << 6);  ///< In the slave mode, 1: rising-edge; 0: falling-edge
        constexpr uint32_t spi_ck_o_edge = (1U << 7);  ///< In the master mode, 1: rising-edge; 0: falling-edge
        constexpr uint32_t spi_cs_setup = (1U << 5);  ///< spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t spi_cs_hold = (1U << 4);  ///< spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t spi_ahb_user_command = (1U << 3);  ///< reserved
        constexpr uint32_t spi_flash_mode = (1U << 2);  ///< spi_flash_mode
        constexpr uint32_t spi_ahb_user_command_4byte = (1U << 1);  ///< reserved
        constexpr uint32_t spi_duplex = (1U << 0);  ///< set spi in full duplex mode
    }

    /// SPI_USER1 Register bits
    namespace spi_user1_bits {
        constexpr uint32_t reg_usr_addr_bitlen = (6 << 26);  ///< The length in bits of "address" phase. The register value shall be  (bit_num-1)
        constexpr uint32_t reg_usr_mosi_bitlen = (9 << 17);  ///< The length in bits of "write-data" phase. The register value shall be  (bit_num-1)
        constexpr uint32_t reg_usr_miso_bitlen = (9 << 8);  ///< The length in bits of "read-data" phase. The register value shall be  (bit_num-1)
        constexpr uint32_t reg_usr_dummy_cyclelen = (8 << 0);  ///< The length in spi_clk cycles of "dummy" phase. The register value shall be  (cycle_num-1)
    }

    /// SPI_USER2 Register bits
    namespace spi_user2_bits {
        constexpr uint32_t reg_usr_command_bitlen = (4 << 28);  ///< The length in bits of "command" phase. The register value shall be  (bit_num-1)
        constexpr uint32_t reg_usr_command_value = (16 << 0);  ///< The value of "command" phase
    }

    /// SPI_WR_STATUS Register bits
    namespace spi_wr_status_bits {
        constexpr uint32_t slv_wr_status = (32 << 0);  ///< In the slave mode, this register are the status register for the master to  write into.
    }

    /// SPI_PIN Register bits
    namespace spi_pin_bits {
        constexpr uint32_t spi_cs2_dis = (1U << 2);  ///< 1: disable CS2; 0: spi_cs signal is from/to CS2 pin
        constexpr uint32_t spi_cs1_dis = (1U << 1);  ///< 1: disable CS1; 0: spi_cs signal is from/to CS1 pin
        constexpr uint32_t spi_cs0_dis = (1U << 0);  ///< 1: disable CS0; 0: spi_cs signal is from/to CS0 pin
        constexpr uint32_t spi_idle_edge = (1U << 29);  ///< In the master mode, 1: high when idle; 0: low when idle
    }

    /// SPI_SLAVE Register bits
    namespace spi_slave_bits {
        constexpr uint32_t spi_sync_reset = (1U << 31);  ///< It is the synchronous reset signal of the module. This bit is self-cleared by  hardware.
        constexpr uint32_t spi_slave_mode = (1U << 30);  ///< 1: slave mode, 0: master mode.
        constexpr uint32_t slv_cmd_define = (1U << 27);  ///< 1: slave mode commands are defined in SPI_SLAVE3. 0: slave mode commands are  fixed as 1: "write-status"; 4: "read-status"; 2: "write-buffer" and 3: "read-buffer".
        constexpr uint32_t spi_trans_cnt = (4 << 23);  ///< The operations counter in both the master mode and the slave mode.
        constexpr uint32_t spi_int_en = (5 << 5);  ///< Interrupt enable bits for the below 5 sources
        constexpr uint32_t spi_trans_done = (1U << 4);  ///< The interrupt raw bit for the completement of any operation in both the master  mode and the slave mode.
        constexpr uint32_t slv_wr_sta_done = (1U << 3);  ///< The interrupt raw bit for the completement of "write-status" operation in the  slave mode.
        constexpr uint32_t slv_rd_sta_done = (1U << 2);  ///< The interrupt raw bit for the completement of "read-status" operation in the  slave mode.
        constexpr uint32_t slv_wr_buf_done = (1U << 1);  ///< The interrupt raw bit for the completement of "write-buffer" operation in the  slave mode.
        constexpr uint32_t slv_rd_buf_done = (1U << 0);  ///< The interrupt raw bit for the completement of "read-buffer" operation in the  slave mode.
    }

    /// SPI_SLAVE1 Register bits
    namespace spi_slave1_bits {
        constexpr uint32_t slv_status_bitlen = (5 << 27);  ///< In the slave mode, it is the length in bits for "write-status" and  "read-status" operations. The register valueshall be (bit_num-1)
        constexpr uint32_t slv_buf_bitlen = (9 << 16);  ///< In the slave mode, it is the length in bits for "write-buffer" and  "read-buffer" operations. The register value shallbe (bit_num-1)
        constexpr uint32_t slv_rd_addr_bitlen = (6 << 10);  ///< In the slave mode, it is the address length in bits for "read-buffer"  operation. The register value shall be(bit_num-1)
        constexpr uint32_t slv_wr_addr_bitlen = (6 << 4);  ///< In the slave mode, it is the address length in bits for "write-buffer"  operation. The register value shall be(bit_num-1)
        constexpr uint32_t slv_wrsta_dummy_en = (1U << 3);  ///< In the slave mode, it is the enable bit of "dummy" phase for "write-status"  operations.
        constexpr uint32_t slv_rdsta_dummy_en = (1U << 2);  ///< In the slave mode, it is the enable bit of "dummy" phase for "read-status"  operations.
        constexpr uint32_t slv_wrbuf_dummy_en = (1U << 1);  ///< In the slave mode, it is the enable bit of "dummy" phase for "write-buffer"  operations.
        constexpr uint32_t slv_rdbuf_dummy_en = (1U << 0);  ///< In the slave mode, it is the enable bit of "dummy" phase for "read-buffer"  operations.
    }

    /// SPI_SLAVE2 Register bits
    namespace spi_slave2_bits {
        constexpr uint32_t slv_wrbuf_dummy_cyclelen = (8 << 24);  ///< In the slave mode, it is the length in spi_clk cycles "dummy" phase for  "write-buffer" operations. The registervalue shall be (cycle_num-1)
        constexpr uint32_t slv_rdbuf_dummy_cyclelen = (8 << 16);  ///< In the slave mode, it is the length in spi_clk cycles of "dummy" phase for  "read-buffer" operations. The registervalue shall be (cycle_num-1)
        constexpr uint32_t slv_wrsta_dummy_cyclelen = (8 << 8);  ///< In the slave mode, it is the length in spi_clk cycles of "dummy" phase for  "write-status" operations. Theregister value shall be (cycle_num-1)
        constexpr uint32_t slv_rdsta_dummy_cyclelen = (8 << 0);  ///< In the slave mode, it is the length in spi_clk cycles of "dummy" phase for  "read-status" operations. Theregister value shall be (cycle_num-1)
    }

    /// SPI_SLAVE3 Register bits
    namespace spi_slave3_bits {
        constexpr uint32_t slv_wrsta_cmd_value = (8 << 24);  ///< In slave mode, it is the value of "write-status" command
        constexpr uint32_t slv_rdsta_cmd_value = (8 << 16);  ///< In slave mode, it is the value of "read-status" command
        constexpr uint32_t slv_wrbuf_cmd_value = (8 << 8);  ///< In slave mode, it is the value of "write-buffer" command
        constexpr uint32_t slv_rdbuf_cmd_value = (8 << 0);  ///< In slave mode, it is the value of "read-buffer" command
    }

    /// SPI_EXT3 Register bits
    namespace spi_ext3_bits {
        constexpr uint32_t reg_int_hold_ena = (2 << 0);  ///< This register is for two SPI masters to share the same cs, clock and data  signals.
    }

    /// SPI_W0 Register bits
    namespace spi_w0_bits {
        constexpr uint32_t spi_w0 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 0
    }

    /// SPI_W1 Register bits
    namespace spi_w1_bits {
        constexpr uint32_t spi_w1 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 1
    }

    /// SPI_W2 Register bits
    namespace spi_w2_bits {
        constexpr uint32_t spi_w2 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 2
    }

    /// SPI_W3 Register bits
    namespace spi_w3_bits {
        constexpr uint32_t spi_w3 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 3
    }

    /// SPI_W4 Register bits
    namespace spi_w4_bits {
        constexpr uint32_t spi_w4 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 4
    }

    /// SPI_W5 Register bits
    namespace spi_w5_bits {
        constexpr uint32_t spi_w5 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 5
    }

    /// SPI_W6 Register bits
    namespace spi_w6_bits {
        constexpr uint32_t spi_w6 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 6
    }

    /// SPI_W7 Register bits
    namespace spi_w7_bits {
        constexpr uint32_t spi_w7 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 7
    }

    /// SPI_W8 Register bits
    namespace spi_w8_bits {
        constexpr uint32_t spi_w8 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 8
    }

    /// SPI_W9 Register bits
    namespace spi_w9_bits {
        constexpr uint32_t spi_w9 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 9
    }

    /// SPI_W10 Register bits
    namespace spi_w10_bits {
        constexpr uint32_t spi_w10 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 10
    }

    /// SPI_W11 Register bits
    namespace spi_w11_bits {
        constexpr uint32_t spi_w11 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 11
    }

    /// SPI_W12 Register bits
    namespace spi_w12_bits {
        constexpr uint32_t spi_w12 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 12
    }

    /// SPI_W13 Register bits
    namespace spi_w13_bits {
        constexpr uint32_t spi_w13 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 13
    }

    /// SPI_W14 Register bits
    namespace spi_w14_bits {
        constexpr uint32_t spi_w14 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 14
    }

    /// SPI_W15 Register bits
    namespace spi_w15_bits {
        constexpr uint32_t spi_w15 = (32 << 0);  ///< the data inside the buffer of the SPI module, byte 15
    }

    /// SPI_CTRL1 Register bits
    namespace spi_ctrl1_bits {
        constexpr uint32_t status = (16 << 0);  ///< In the slave mode, it is the status for master to read out.
        constexpr uint32_t wb_mode = (8 << 16);  ///< Mode bits in the flash fast read mode, it is combined with spi_fastrd_mode bit.
        constexpr uint32_t status_ext = (8 << 24);  ///< In the slave mode,it is the status for master to read out.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER_BASE = 0x60000600;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t FRC1_LOAD;  ///< Offset: 0x00 - the load value into the counter
        volatile uint32_t FRC1_COUNT;  ///< Offset: 0x04 - the current value of the counter. It is a decreasingcounter.
        volatile uint32_t FRC1_CTRL;  ///< Offset: 0x08 - FRC1_CTRL
        volatile uint32_t FRC1_INT;  ///< Offset: 0x0C - FRC1_INT
        volatile uint32_t FRC2_LOAD;  ///< Offset: 0x20 - the load value into the counter
        volatile uint32_t FRC2_COUNT;  ///< Offset: 0x24 - the current value of the counter. It is a increasingcounter.
        volatile uint32_t FRC2_CTRL;  ///< Offset: 0x28 - FRC2_CTRL
        volatile uint32_t FRC2_INT;  ///< Offset: 0x2C - FRC2_INT
        volatile uint32_t FRC2_ALARM;  ///< Offset: 0x30 - the alarm value for the counter
    };

    /// Peripheral instances
    inline Registers* TIMER = reinterpret_cast<Registers*>(TIMER_BASE);

    // Bit definitions
    /// FRC1_LOAD Register bits
    namespace frc1_load_bits {
        constexpr uint32_t frc1_load_value = (23 << 0);  ///< the load value into the counter
    }

    /// FRC1_COUNT Register bits
    namespace frc1_count_bits {
        constexpr uint32_t frc1_count = (23 << 0);  ///< the current value of the counter. It is a decreasingcounter.
    }

    /// FRC1_CTRL Register bits
    namespace frc1_ctrl_bits {
        constexpr uint32_t frc1_int = (1U << 8);  ///< the status of the interrupt, when the count isdereased to zero
        constexpr uint32_t frc1_ctrl = (8 << 0);  ///< bit[7]: timer enable, bit[6]: automatically reload, when the counter isequal to  zero, bit[3:2]: prescale-divider, 0: divided by 1, 1: dividedby 16, 2 or 3: divided by  256, bit[0]: interrupt type, 0:edge, 1:level
        constexpr uint32_t timer_enable = (1U << 7);  ///< Enable or disable the timer
        constexpr uint32_t rollover = (1U << 6);  ///< Automatically reload when the counter hits zero
        constexpr uint32_t prescale_divider = (2 << 2);  ///< Pre-scale divider for the timer
        constexpr uint32_t interrupt_type = (1U << 0);  ///< Configure the interrupt type
    }

    /// FRC1_INT Register bits
    namespace frc1_int_bits {
        constexpr uint32_t frc1_int_clr_mask = (1U << 0);  ///< write to clear the status of the interrupt, if theinterrupt type is "level"
    }

    /// FRC2_LOAD Register bits
    namespace frc2_load_bits {
        constexpr uint32_t frc2_load_value = (32 << 0);  ///< the load value into the counter
    }

    /// FRC2_COUNT Register bits
    namespace frc2_count_bits {
        constexpr uint32_t frc2_count = (32 << 0);  ///< the current value of the counter. It is a increasingcounter.
    }

    /// FRC2_CTRL Register bits
    namespace frc2_ctrl_bits {
        constexpr uint32_t frc2_int = (1U << 8);  ///< the status of the interrupt, when the count is equal tothe alarm value
        constexpr uint32_t frc2_ctrl = (8 << 0);  ///< bit[7]: timer enable, bit[6]: automatically reload, when the counter isequal to  zero, bit[3:2]: prescale-divider, 0: divided by 1, 1: dividedby 16, 2 or 3: divided by  256, bit[0]: interrupt type, 0:edge, 1:level
        constexpr uint32_t timer_enable = (1U << 7);  ///< Enable or disable the timer
        constexpr uint32_t rollover = (1U << 6);  ///< Automatically reload when the counter hits zero
        constexpr uint32_t prescale_divider = (2 << 2);  ///< Pre-scale divider for the timer
        constexpr uint32_t interrupt_type = (1U << 0);  ///< Configure the interrupt type
    }

    /// FRC2_INT Register bits
    namespace frc2_int_bits {
        constexpr uint32_t frc2_int_clr_mask = (1U << 0);  ///< write to clear the status of the interrupt, if theinterrupt type is "level"
    }

    /// FRC2_ALARM Register bits
    namespace frc2_alarm_bits {
        constexpr uint32_t frc2_alarm = (32 << 0);  ///< the alarm value for the counter
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x60000000;
    constexpr uint32_t UART1_BASE = 0x60000F00;

    /// USART Register structure
    struct Registers {
        volatile uint32_t UART_FIFO;  ///< Offset: 0x00 - UART FIFO,length 128
        volatile uint32_t UART_INT_RAW;  ///< Offset: 0x04 - UART INTERRUPT RAW STATE
        volatile uint32_t UART_INT_ST;  ///< Offset: 0x08 - UART INTERRUPT STATEREGISTERUART_INT_RAW&UART_INT_ENA
        volatile uint32_t UART_INT_ENA;  ///< Offset: 0x0C - UART INTERRUPT ENABLE REGISTER
        volatile uint32_t UART_INT_CLR;  ///< Offset: 0x10 - UART INTERRUPT CLEAR REGISTER
        volatile uint32_t UART_CLKDIV;  ///< Offset: 0x14 - UART CLK DIV REGISTER
        volatile uint32_t UART_AUTOBAUD;  ///< Offset: 0x18 - UART BAUDRATE DETECT REGISTER
        volatile uint32_t UART_STATUS;  ///< Offset: 0x1C - UART STATUS REGISTER
        volatile uint32_t UART_CONF0;  ///< Offset: 0x20 - UART CONFIG0(UART0 and UART1)
        volatile uint32_t UART_CONF1;  ///< Offset: 0x24 - Set this bit to enable rx time-out function
        volatile uint32_t UART_LOWPULSE;  ///< Offset: 0x28 - UART_LOWPULSE
        volatile uint32_t UART_HIGHPULSE;  ///< Offset: 0x2C - UART_HIGHPULSE
        volatile uint32_t UART_RXD_CNT;  ///< Offset: 0x30 - UART_RXD_CNT
        volatile uint32_t UART_DATE;  ///< Offset: 0x78 - UART HW INFO
        volatile uint32_t UART_ID;  ///< Offset: 0x7C - UART_ID
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

    // Bit definitions
    /// UART_FIFO Register bits
    namespace uart_fifo_bits {
        constexpr uint32_t rxfifo_rd_byte = (8 << 0);  ///< R/W share the same address
        constexpr uint32_t rxfifo_write_byte = (8 << 0);  ///< R/W share the same address
    }

    /// UART_INT_RAW Register bits
    namespace uart_int_raw_bits {
        constexpr uint32_t rxfifo_tout_int_raw = (1U << 8);  ///< The interrupt raw bit for Rx time-out interrupt(depands on  theUART_RX_TOUT_THRHD)
        constexpr uint32_t brk_det_int_raw = (1U << 7);  ///< The interrupt raw bit for Rx byte start error
        constexpr uint32_t cts_chg_int_raw = (1U << 6);  ///< The interrupt raw bit for CTS changing level
        constexpr uint32_t dsr_chg_int_raw = (1U << 5);  ///< The interrupt raw bit for DSR changing level
        constexpr uint32_t rxfifo_ovf_int_raw = (1U << 4);  ///< The interrupt raw bit for rx fifo overflow
        constexpr uint32_t frm_err_int_raw = (1U << 3);  ///< The interrupt raw bit for other rx error
        constexpr uint32_t parity_err_int_raw = (1U << 2);  ///< The interrupt raw bit for parity check error
        constexpr uint32_t txfifo_empty_int_raw = (1U << 1);  ///< The interrupt raw bit for tx fifo empty interrupt(depands  onUART_TXFIFO_EMPTY_THRHD bits)
        constexpr uint32_t rxfifo_full_int_raw = (1U << 0);  ///< The interrupt raw bit for rx fifo full interrupt(depands  onUART_RXFIFO_FULL_THRHD bits)
    }

    /// UART_INT_ST Register bits
    namespace uart_int_st_bits {
        constexpr uint32_t rxfifo_tout_int_st = (1U << 8);  ///< The interrupt state bit for Rx time-out event
        constexpr uint32_t brk_det_int_st = (1U << 7);  ///< The interrupt state bit for rx byte start error
        constexpr uint32_t cts_chg_int_st = (1U << 6);  ///< The interrupt state bit for CTS changing level
        constexpr uint32_t dsr_chg_int_st = (1U << 5);  ///< The interrupt state bit for DSR changing level
        constexpr uint32_t rxfifo_ovf_int_st = (1U << 4);  ///< The interrupt state bit for RX fifo overflow
        constexpr uint32_t frm_err_int_st = (1U << 3);  ///< The interrupt state for other rx error
        constexpr uint32_t parity_err_int_st = (1U << 2);  ///< The interrupt state bit for rx parity error
        constexpr uint32_t txfifo_empty_int_st = (1U << 1);  ///< The interrupt state bit for TX fifo empty
        constexpr uint32_t rxfifo_full_int_st = (1U << 0);  ///< The interrupt state bit for RX fifo full event
    }

    /// UART_INT_ENA Register bits
    namespace uart_int_ena_bits {
        constexpr uint32_t rxfifo_tout_int_ena = (1U << 8);  ///< The interrupt enable bit for rx time-out interrupt
        constexpr uint32_t brk_det_int_ena = (1U << 7);  ///< The interrupt enable bit for rx byte start error
        constexpr uint32_t cts_chg_int_ena = (1U << 6);  ///< The interrupt enable bit for CTS changing level
        constexpr uint32_t dsr_chg_int_ena = (1U << 5);  ///< The interrupt enable bit for DSR changing level
        constexpr uint32_t rxfifo_ovf_int_ena = (1U << 4);  ///< The interrupt enable bit for rx fifo overflow
        constexpr uint32_t frm_err_int_ena = (1U << 3);  ///< The interrupt enable bit for other rx error
        constexpr uint32_t parity_err_int_ena = (1U << 2);  ///< The interrupt enable bit for parity error
        constexpr uint32_t txfifo_empty_int_ena = (1U << 1);  ///< The interrupt enable bit for tx fifo empty event
        constexpr uint32_t rxfifo_full_int_ena = (1U << 0);  ///< The interrupt enable bit for rx fifo full event
    }

    /// UART_INT_CLR Register bits
    namespace uart_int_clr_bits {
        constexpr uint32_t rxfifo_tout_int_clr = (1U << 8);  ///< Set this bit to clear the rx time-out interrupt
        constexpr uint32_t brk_det_int_clr = (1U << 7);  ///< Set this bit to clear the rx byte start interrupt
        constexpr uint32_t cts_chg_int_clr = (1U << 6);  ///< Set this bit to clear the CTS changing interrupt
        constexpr uint32_t dsr_chg_int_clr = (1U << 5);  ///< Set this bit to clear the DSR changing interrupt
        constexpr uint32_t rxfifo_ovf_int_clr = (1U << 4);  ///< Set this bit to clear the rx fifo over-flow interrupt
        constexpr uint32_t frm_err_int_clr = (1U << 3);  ///< Set this bit to clear other rx error interrupt
        constexpr uint32_t parity_err_int_clr = (1U << 2);  ///< Set this bit to clear the parity error interrupt
        constexpr uint32_t txfifo_empty_int_clr = (1U << 1);  ///< Set this bit to clear the tx fifo empty interrupt
        constexpr uint32_t rxfifo_full_int_clr = (1U << 0);  ///< Set this bit to clear the rx fifo full interrupt
    }

    /// UART_CLKDIV Register bits
    namespace uart_clkdiv_bits {
        constexpr uint32_t uart_clkdiv = (20 << 0);  ///< BAUDRATE = UART_CLK_FREQ / UART_CLKDIV
    }

    /// UART_AUTOBAUD Register bits
    namespace uart_autobaud_bits {
        constexpr uint32_t glitch_filt = (8 << 8);  ///< glitch_filt
        constexpr uint32_t autobaud_en = (1U << 0);  ///< Set this bit to enable baudrate detect
    }

    /// UART_STATUS Register bits
    namespace uart_status_bits {
        constexpr uint32_t txd = (1U << 31);  ///< The level of the uart txd pin
        constexpr uint32_t rtsn = (1U << 30);  ///< The level of uart rts pin
        constexpr uint32_t dtrn = (1U << 29);  ///< The level of uart dtr pin
        constexpr uint32_t txfifo_cnt = (8 << 16);  ///< Number of data in UART TX fifo
        constexpr uint32_t rxd = (1U << 15);  ///< The level of uart rxd pin
        constexpr uint32_t ctsn = (1U << 14);  ///< The level of uart cts pin
        constexpr uint32_t dsrn = (1U << 13);  ///< The level of uart dsr pin
        constexpr uint32_t rxfifo_cnt = (8 << 0);  ///< Number of data in uart rx fifo
    }

    /// UART_CONF0 Register bits
    namespace uart_conf0_bits {
        constexpr uint32_t uart_dtr_inv = (1U << 24);  ///< Set this bit to inverse uart dtr level
        constexpr uint32_t uart_rts_inv = (1U << 23);  ///< Set this bit to inverse uart rts level
        constexpr uint32_t uart_txd_inv = (1U << 22);  ///< Set this bit to inverse uart txd level
        constexpr uint32_t uart_dsr_inv = (1U << 21);  ///< Set this bit to inverse uart dsr level
        constexpr uint32_t uart_cts_inv = (1U << 20);  ///< Set this bit to inverse uart cts level
        constexpr uint32_t uart_rxd_inv = (1U << 19);  ///< Set this bit to inverse uart rxd level
        constexpr uint32_t txfifo_rst = (1U << 18);  ///< Set this bit to reset uart tx fifo
        constexpr uint32_t rxfifo_rst = (1U << 17);  ///< Set this bit to reset uart rx fifo
        constexpr uint32_t tx_flow_en = (1U << 15);  ///< Set this bit to enable uart tx hardware flow control
        constexpr uint32_t uart_loopback = (1U << 14);  ///< Set this bit to enable uart loopback test mode
        constexpr uint32_t txd_brk = (1U << 8);  ///< RESERVED, DO NOT CHANGE THIS BIT
        constexpr uint32_t sw_dtr = (1U << 7);  ///< sw dtr
        constexpr uint32_t sw_rts = (1U << 6);  ///< sw rts
        constexpr uint32_t stop_bit_num = (2 << 4);  ///< Set stop bit: 1:1bit 2:1.5bits 3:2bits
        constexpr uint32_t bit_num = (2 << 2);  ///< Set bit num: 0:5bits 1:6bits 2:7bits 3:8bits
        constexpr uint32_t parity_en = (1U << 1);  ///< Set this bit to enable uart parity check
        constexpr uint32_t parity = (1U << 0);  ///< Set parity check: 0:even 1:odd, UART CONFIG1
    }

    /// UART_CONF1 Register bits
    namespace uart_conf1_bits {
        constexpr uint32_t rx_tout_en = (1U << 31);  ///< Set this bit to enable rx time-out function
        constexpr uint32_t rx_tout_thrhd = (7 << 24);  ///< Config bits for rx time-out threshold,uint: byte,0-127
        constexpr uint32_t rx_flow_en = (1U << 23);  ///< Set this bit to enable rx hardware flow control
        constexpr uint32_t rx_flow_thrhd = (7 << 16);  ///< The config bits for rx flow control threshold,0-127
        constexpr uint32_t txfifo_empty_thrhd = (7 << 8);  ///< The config bits for tx fifo empty threshold,0-127
        constexpr uint32_t rxfifo_full_thrhd = (7 << 0);  ///< The config bits for rx fifo full threshold,0-127
    }

    /// UART_LOWPULSE Register bits
    namespace uart_lowpulse_bits {
        constexpr uint32_t lowpulse_min_cnt = (20 << 0);  ///< used in baudrate detect
    }

    /// UART_HIGHPULSE Register bits
    namespace uart_highpulse_bits {
        constexpr uint32_t highpulse_min_cnt = (20 << 0);  ///< used in baudrate detect
    }

    /// UART_RXD_CNT Register bits
    namespace uart_rxd_cnt_bits {
        constexpr uint32_t rxd_edge_cnt = (10 << 0);  ///< used in baudrate detect
    }

    /// UART_DATE Register bits
    namespace uart_date_bits {
        constexpr uint32_t uart_date = (32 << 0);  ///< UART HW INFO
    }

    /// UART_ID Register bits
    namespace uart_id_bits {
        constexpr uint32_t uart_id = (32 << 0);  ///< uart_id
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x60000900;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDT_CTL;  ///< Offset: 0x00 - WDT_CTL
        volatile uint32_t WDT_OP;  ///< Offset: 0x04 - WDT_OP
        volatile uint32_t WDT_OP_ND;  ///< Offset: 0x08 - WDT_OP_ND
        volatile uint32_t WDT_RST;  ///< Offset: 0x14 - WDT_RST
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// WDT_CTL Register bits
    namespace wdt_ctl_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// WDT_OP Register bits
    namespace wdt_op_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// WDT_OP_ND Register bits
    namespace wdt_op_nd_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

    /// WDT_RST Register bits
    namespace wdt_rst_bits {
        constexpr uint32_t Register_ = (32 << 0);  ///< Register (renamed from Register_)
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x3FF20E44;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t rng;  ///< Offset: 0x00 - RNG register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// WATCHDOG Peripheral
// ============================================================================

namespace watchdog {
    /// Base addresses
    constexpr uint32_t WATCHDOG_BASE = 0x60000900;

    /// WATCHDOG Register structure
    struct Registers {
        volatile uint32_t ctl;  ///< Offset: 0x00 - Enable the watchdog timer.
        volatile uint32_t reload_stage0;  ///< Offset: 0x04 - Reload value for stage 0
        volatile uint32_t reload_stage1;  ///< Offset: 0x08 - Reload value for stage 1
        volatile uint32_t count;  ///< Offset: 0x0C - Watchdog clock cycle count
        volatile uint32_t stage;  ///< Offset: 0x10 - The current watchdog stage
        volatile uint32_t reset;  ///< Offset: 0x14 - Watchdog reset
        volatile uint32_t reset_stage;  ///< Offset: 0x18 - Watchdog stage reset
    };

    /// Peripheral instances
    inline Registers* WATCHDOG = reinterpret_cast<Registers*>(WATCHDOG_BASE);

    // Bit definitions
    /// ctl Register bits
    namespace ctl_bits {
        constexpr uint32_t enable = (1U << 0);  ///< Enable the watchdog timer.
        constexpr uint32_t stage_1_no_reset = (1U << 1);  ///< When set to 1, and running in two-stage mode, it turns the watchdog into a single shot timer that doesn't reset the device.
        constexpr uint32_t stage_1_disable = (1U << 2);  ///< Set to 1 to disable the stage 1 of the watchdog timer
        constexpr uint32_t unknown_3 = (1U << 3);  ///< unknown_3
        constexpr uint32_t unknown_4 = (1U << 4);  ///< unknown_4
        constexpr uint32_t unknown_5 = (1U << 5);  ///< unknown_5
    }

}


} // namespace alloy::generated::esp8266

#endif // ALLOY_GENERATED_ESP8266_PERIPHERALS_HPP