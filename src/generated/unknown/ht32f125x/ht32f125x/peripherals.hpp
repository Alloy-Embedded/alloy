/// Auto-generated code for HT32F125x
/// Generated by Alloy Code Generator
/// Source: holtek_ht32f125x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:06
#ifndef ALLOY_GENERATED_HT32F125X_PERIPHERALS_HPP
#define ALLOY_GENERATED_HT32F125X_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::ht32f125x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_scb = true;
    constexpr uint32_t num_scb_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_fault = true;
    constexpr uint32_t num_fault_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_ckcu = true;
    constexpr uint32_t num_ckcu_instances = 1;
    constexpr bool has_rstcu = true;
    constexpr uint32_t num_rstcu_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_afio = true;
    constexpr uint32_t num_afio_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_opacmp = true;
    constexpr uint32_t num_opacmp_instances = 1;
    constexpr bool has_gptm0 = true;
    constexpr uint32_t num_gptm0_instances = 1;
    constexpr bool has_gptm1 = true;
    constexpr uint32_t num_gptm1_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fault_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ckcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rstcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct afio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct opacmp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gptm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gptm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart = true;
}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E000;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ICTR;  ///< Offset: 0x04 - ICTR
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - ACTLR
        volatile uint32_t ISER0;  ///< Offset: 0x100 - ISER0
        volatile uint32_t ISER1;  ///< Offset: 0x104 - ISER1
        volatile uint32_t ICER0;  ///< Offset: 0x180 - ICER0
        volatile uint32_t ICER1;  ///< Offset: 0x184 - ICER1
        volatile uint32_t ISPR0;  ///< Offset: 0x200 - ISPR0
        volatile uint32_t ISPR1;  ///< Offset: 0x204 - ISPR1
        volatile uint32_t ICPR0;  ///< Offset: 0x280 - ICPR0
        volatile uint32_t ICPR1;  ///< Offset: 0x284 - ICPR1
        volatile uint32_t IABR0;  ///< Offset: 0x300 - IABR0
        volatile uint32_t IABR1;  ///< Offset: 0x304 - IABR1
        volatile uint32_t IP0;  ///< Offset: 0x400 - IP0
        volatile uint32_t IP1;  ///< Offset: 0x404 - IP1
        volatile uint32_t IP2;  ///< Offset: 0x408 - IP2
        volatile uint32_t IP3;  ///< Offset: 0x40C - IP3
        volatile uint32_t IP4;  ///< Offset: 0x410 - IP4
        volatile uint32_t IP5;  ///< Offset: 0x414 - IP5
        volatile uint32_t IP6;  ///< Offset: 0x418 - IP6
        volatile uint32_t IP7;  ///< Offset: 0x41C - IP7
        volatile uint32_t IP8;  ///< Offset: 0x420 - IP8
        volatile uint32_t IP9;  ///< Offset: 0x424 - IP9
        volatile uint32_t IP10;  ///< Offset: 0x428 - IP10
        volatile uint32_t IP11;  ///< Offset: 0x42C - IP11
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - ICSR
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - VTOR
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - AIRCR
        volatile uint32_t SHP0;  ///< Offset: 0xD18 - SHP0
        volatile uint32_t SHP1;  ///< Offset: 0xD1C - SHP1
        volatile uint32_t SHP2;  ///< Offset: 0xD20 - SHP2
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - SHCSR
        volatile uint32_t STIR;  ///< Offset: 0xF00 - STIR
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED10;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t SCR;  ///< Offset: 0x00 - SCR
        volatile uint32_t CCR;  ///< Offset: 0x04 - CCR
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - CTRL
        volatile uint32_t LOAD;  ///< Offset: 0x04 - LOAD
        volatile uint32_t VAL;  ///< Offset: 0x08 - VAL
        volatile uint32_t CALIB;  ///< Offset: 0x0C - CALIB
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

}

// ============================================================================
// Fault Peripheral
// ============================================================================

namespace fault {
    /// Base addresses
    constexpr uint32_t Fault_Reports_BASE = 0xE000ED28;

    /// Fault Register structure
    struct Registers {
        volatile uint32_t CFSR;  ///< Offset: 0x00 - CFSR
        volatile uint32_t MFSR;  ///< Offset: 0x00 - MFSR
        volatile uint32_t MMFAR;  ///< Offset: 0x0C - MMFAR
        volatile uint32_t BFSR;  ///< Offset: 0x01 - BFSR
        volatile uint32_t BFAR;  ///< Offset: 0x10 - BFAR
        volatile uint32_t UFSR;  ///< Offset: 0x02 - UFSR
        volatile uint32_t HFSR;  ///< Offset: 0x04 - HFSR
        volatile uint32_t DFSR;  ///< Offset: 0x08 - DFSR
        volatile uint32_t AFSR;  ///< Offset: 0x14 - AFSR
    };

    /// Peripheral instances
    inline Registers* Fault_Reports = reinterpret_cast<Registers*>(Fault_Reports_BASE);

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x40080000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t FMC_TADR;  ///< Offset: 0x00 - FMC_TADR
        volatile uint32_t FMC_WRDR;  ///< Offset: 0x04 - FMC_WRDR
        volatile uint32_t FMC_OCMR;  ///< Offset: 0x0C - FMC_OCMR
        volatile uint32_t FMC_OPCR;  ///< Offset: 0x10 - FMC_OPCR
        volatile uint32_t FMC_OIER;  ///< Offset: 0x14 - FMC_OIER
        volatile uint32_t FMC_OISR;  ///< Offset: 0x18 - FMC_OISR
        volatile uint32_t FMC_PPSR0;  ///< Offset: 0x20 - FMC_PPSR0
        volatile uint32_t FMC_PPSR1;  ///< Offset: 0x24 - FMC_PPSR1
        volatile uint32_t FMC_PPSR2;  ///< Offset: 0x28 - FMC_PPSR2
        volatile uint32_t FMC_PPSR3;  ///< Offset: 0x2C - FMC_PPSR3
        volatile uint32_t FMC_CPSR;  ///< Offset: 0x30 - FMC_CPSR
        volatile uint32_t FMC_VMCR;  ///< Offset: 0x100 - FMC_VMCR
        volatile uint32_t FMC_CFCR;  ///< Offset: 0x200 - FMC_CFCR
        volatile uint32_t FMC_SBVT0;  ///< Offset: 0x300 - FMC_SBVT0
        volatile uint32_t FMC_SBVT1;  ///< Offset: 0x304 - FMC_SBVT1
        volatile uint32_t FMC_SBVT2;  ///< Offset: 0x308 - FMC_SBVT2
        volatile uint32_t FMC_SBVT3;  ///< Offset: 0x30C - FMC_SBVT3
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWRCU_BASE = 0x4006A100;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWRCU_BAKSR;  ///< Offset: 0x00 - PWRCU_BAKSR
        volatile uint32_t PWRCU_BAKCR;  ///< Offset: 0x04 - PWRCU_BAKCR
        volatile uint32_t PWRCU_BAKTEST;  ///< Offset: 0x08 - PWRCU_BAKTEST
        volatile uint32_t PWRCU_HSIRCR;  ///< Offset: 0x0C - PWRCU_HSIRCR
        volatile uint32_t PWRCU_LVDCSR;  ///< Offset: 0x10 - PWRCU_LVDCSR
        volatile uint32_t PWRCU_BAKREG0;  ///< Offset: 0x100 - PWRCU_BAKREG0
        volatile uint32_t PWRCU_BAKREG1;  ///< Offset: 0x104 - PWRCU_BAKREG1
        volatile uint32_t PWRCU_BAKREG2;  ///< Offset: 0x108 - PWRCU_BAKREG2
        volatile uint32_t PWRCU_BAKREG3;  ///< Offset: 0x10C - PWRCU_BAKREG3
        volatile uint32_t PWRCU_BAKREG4;  ///< Offset: 0x110 - PWRCU_BAKREG4
        volatile uint32_t PWRCU_BAKREG5;  ///< Offset: 0x114 - PWRCU_BAKREG5
        volatile uint32_t PWRCU_BAKREG6;  ///< Offset: 0x118 - PWRCU_BAKREG6
        volatile uint32_t PWRCU_BAKREG7;  ///< Offset: 0x11C - PWRCU_BAKREG7
        volatile uint32_t PWRCU_BAKREG8;  ///< Offset: 0x120 - PWRCU_BAKREG8
        volatile uint32_t PWRCU_BAKREG9;  ///< Offset: 0x124 - PWRCU_BAKREG9
    };

    /// Peripheral instances
    inline Registers* PWRCU = reinterpret_cast<Registers*>(PWRCU_BASE);

}

// ============================================================================
// CKCU Peripheral
// ============================================================================

namespace ckcu {
    /// Base addresses
    constexpr uint32_t CKCU_BASE = 0x40088000;

    /// CKCU Register structure
    struct Registers {
        volatile uint32_t CKCU_GCFGR;  ///< Offset: 0x00 - CKCU_GCFGR
        volatile uint32_t CKCU_GCCR;  ///< Offset: 0x04 - CKCU_GCCR
        volatile uint32_t CKCU_GCSR;  ///< Offset: 0x08 - CKCU_GCSR
        volatile uint32_t CKCU_GCIR;  ///< Offset: 0x0C - CKCU_GCIR
        volatile uint32_t CKCU_PLLCFGR;  ///< Offset: 0x18 - CKCU_PLLCFGR
        volatile uint32_t CKCU_PLLCR;  ///< Offset: 0x1C - CKCU_PLLCR
        volatile uint32_t CKCU_AHBCFGR;  ///< Offset: 0x20 - CKCU_AHBCFGR
        volatile uint32_t CKCU_AHBCCR;  ///< Offset: 0x24 - CKCU_AHBCCR
        volatile uint32_t CKCU_APBCFGR;  ///< Offset: 0x28 - CKCU_APBCFGR
        volatile uint32_t CKCU_APBCCR0;  ///< Offset: 0x2C - CKCU_APBCCR0
        volatile uint32_t CKCU_APBCCR1;  ///< Offset: 0x30 - CKCU_APBCCR1
        volatile uint32_t CKCU_CKST;  ///< Offset: 0x34 - CKCU_CKST
        volatile uint32_t CKCU_LPCR;  ///< Offset: 0x300 - CKCU_LPCR
        volatile uint32_t CKCU_MCUDBGCR;  ///< Offset: 0x304 - CKCU_MCUDBGCR
    };

    /// Peripheral instances
    inline Registers* CKCU = reinterpret_cast<Registers*>(CKCU_BASE);

}

// ============================================================================
// RSTCU Peripheral
// ============================================================================

namespace rstcu {
    /// Base addresses
    constexpr uint32_t RSTCU_BASE = 0x40088100;

    /// RSTCU Register structure
    struct Registers {
        volatile uint32_t RSTCU_GRSR;  ///< Offset: 0x00 - RSTCU_GRSR
        volatile uint32_t RSTCU_APBPRSTR0;  ///< Offset: 0x08 - RSTCU_APBPRSTR0
        volatile uint32_t RSTCU_APBPRSTR1;  ///< Offset: 0x0C - RSTCU_APBPRSTR1
    };

    /// Peripheral instances
    inline Registers* RSTCU = reinterpret_cast<Registers*>(RSTCU_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x4001A000;
    constexpr uint32_t GPIOB_BASE = 0x4001B000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIOA_DIRCR;  ///< Offset: 0x00 - GPIOA_DIRCR
        volatile uint32_t GPIOA_INER;  ///< Offset: 0x04 - GPIOA_INER
        volatile uint32_t GPIOA_PUR;  ///< Offset: 0x08 - GPIOA_PUR
        volatile uint32_t GPIOA_PDR;  ///< Offset: 0x0C - GPIOA_PDR
        volatile uint32_t GPIOA_ODR;  ///< Offset: 0x10 - GPIOA_ODR
        volatile uint32_t GPIOA_DRVR;  ///< Offset: 0x14 - GPIOA_DRVR
        volatile uint32_t GPIOA_LOCKR;  ///< Offset: 0x18 - GPIOA_LOCKR
        volatile uint32_t GPIOA_DINR;  ///< Offset: 0x1C - GPIOA_DINR
        volatile uint32_t GPIOA_DOUTR;  ///< Offset: 0x20 - GPIOA_DOUTR
        volatile uint32_t GPIOA_SRR;  ///< Offset: 0x24 - GPIOA_SRR
        volatile uint32_t GPIOA_RR;  ///< Offset: 0x28 - GPIOA_RR
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);

}

// ============================================================================
// AFIO Peripheral
// ============================================================================

namespace afio {
    /// Base addresses
    constexpr uint32_t AFIO_BASE = 0x40022000;

    /// AFIO Register structure
    struct Registers {
        volatile uint32_t AFIO_ESSR0;  ///< Offset: 0x00 - AFIO_ESSR0
        volatile uint32_t AFIO_ESSR1;  ///< Offset: 0x04 - AFIO_ESSR1
        volatile uint32_t AFIO_GPACFGR;  ///< Offset: 0x08 - AFIO_GPACFGR
        volatile uint32_t AFIO_GPBCFGR;  ///< Offset: 0x0C - AFIO_GPBCFGR
    };

    /// Peripheral instances
    inline Registers* AFIO = reinterpret_cast<Registers*>(AFIO_BASE);

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40024000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_CFGR0;  ///< Offset: 0x00 - EXTI_CFGR0
        volatile uint32_t EXTI_CFGR1;  ///< Offset: 0x04 - EXTI_CFGR1
        volatile uint32_t EXTI_CFGR2;  ///< Offset: 0x08 - EXTI_CFGR2
        volatile uint32_t EXTI_CFGR3;  ///< Offset: 0x0C - EXTI_CFGR3
        volatile uint32_t EXTI_CFGR4;  ///< Offset: 0x10 - EXTI_CFGR4
        volatile uint32_t EXTI_CFGR5;  ///< Offset: 0x14 - EXTI_CFGR5
        volatile uint32_t EXTI_CFGR6;  ///< Offset: 0x18 - EXTI_CFGR6
        volatile uint32_t EXTI_CFGR7;  ///< Offset: 0x1C - EXTI_CFGR7
        volatile uint32_t EXTI_CFGR8;  ///< Offset: 0x20 - EXTI_CFGR8
        volatile uint32_t EXTI_CFGR9;  ///< Offset: 0x24 - EXTI_CFGR9
        volatile uint32_t EXTI_CFGR10;  ///< Offset: 0x28 - EXTI_CFGR10
        volatile uint32_t EXTI_CFGR11;  ///< Offset: 0x2C - EXTI_CFGR11
        volatile uint32_t EXTI_CFGR12;  ///< Offset: 0x30 - EXTI_CFGR12
        volatile uint32_t EXTI_CFGR13;  ///< Offset: 0x34 - EXTI_CFGR13
        volatile uint32_t EXTI_CFGR14;  ///< Offset: 0x38 - EXTI_CFGR14
        volatile uint32_t EXTI_CFGR15;  ///< Offset: 0x3C - EXTI_CFGR15
        volatile uint32_t EXTI_CR;  ///< Offset: 0x40 - EXTI_CR
        volatile uint32_t EXTI_EDGEFLGR;  ///< Offset: 0x44 - EXTI_EDGEFLGR
        volatile uint32_t EXTI_EDGESR;  ///< Offset: 0x48 - EXTI_EDGESR
        volatile uint32_t EXTI_SSCR;  ///< Offset: 0x4C - EXTI_SSCR
        volatile uint32_t EXTI_WAKUPCR;  ///< Offset: 0x50 - EXTI_WAKUPCR
        volatile uint32_t EXTI_WAKUPPOLR;  ///< Offset: 0x54 - EXTI_WAKUPPOLR
        volatile uint32_t EXTI_WAKUPFLG;  ///< Offset: 0x58 - EXTI_WAKUPFLG
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40010000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_RST;  ///< Offset: 0x04 - ADC_RST
        volatile uint32_t ADC_CONV;  ///< Offset: 0x08 - ADC_CONV
        volatile uint32_t ADC_LST0;  ///< Offset: 0x10 - ADC_LST0
        volatile uint32_t ADC_LST1;  ///< Offset: 0x14 - ADC_LST1
        volatile uint32_t ADC_STR0;  ///< Offset: 0x70 - ADC_STR0
        volatile uint32_t ADC_STR1;  ///< Offset: 0x74 - ADC_STR1
        volatile uint32_t ADC_STR2;  ///< Offset: 0x78 - ADC_STR2
        volatile uint32_t ADC_STR3;  ///< Offset: 0x7C - ADC_STR3
        volatile uint32_t ADC_STR4;  ///< Offset: 0x80 - ADC_STR4
        volatile uint32_t ADC_STR5;  ///< Offset: 0x84 - ADC_STR5
        volatile uint32_t ADC_STR6;  ///< Offset: 0x88 - ADC_STR6
        volatile uint32_t ADC_STR7;  ///< Offset: 0x8C - ADC_STR7
        volatile uint32_t ADC_DR0;  ///< Offset: 0xB0 - ADC_DR0
        volatile uint32_t ADC_DR1;  ///< Offset: 0xB4 - ADC_DR1
        volatile uint32_t ADC_DR2;  ///< Offset: 0xB8 - ADC_DR2
        volatile uint32_t ADC_DR3;  ///< Offset: 0xBC - ADC_DR3
        volatile uint32_t ADC_DR4;  ///< Offset: 0xC0 - ADC_DR4
        volatile uint32_t ADC_DR5;  ///< Offset: 0xC4 - ADC_DR5
        volatile uint32_t ADC_DR6;  ///< Offset: 0xC8 - ADC_DR6
        volatile uint32_t ADC_DR7;  ///< Offset: 0xCC - ADC_DR7
        volatile uint32_t ADC_TCR;  ///< Offset: 0x100 - ADC_TCR
        volatile uint32_t ADC_TSR;  ///< Offset: 0x104 - ADC_TSR
        volatile uint32_t ADC_WCR;  ///< Offset: 0x120 - ADC_WCR
        volatile uint32_t ADC_LTR;  ///< Offset: 0x124 - ADC_LTR
        volatile uint32_t ADC_UTR;  ///< Offset: 0x128 - ADC_UTR
        volatile uint32_t ADC_IMR;  ///< Offset: 0x130 - ADC_IMR
        volatile uint32_t ADC_IRAW;  ///< Offset: 0x134 - ADC_IRAW
        volatile uint32_t ADC_IMASK;  ///< Offset: 0x138 - ADC_IMASK
        volatile uint32_t ADC_ICLR;  ///< Offset: 0x13C - ADC_ICLR
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

}

// ============================================================================
// OPACMP Peripheral
// ============================================================================

namespace opacmp {
    /// Base addresses
    constexpr uint32_t OPACMP_BASE = 0x40018000;

    /// OPACMP Register structure
    struct Registers {
        volatile uint32_t OPACR0;  ///< Offset: 0x00 - OPACR0
        volatile uint32_t OFVCR0;  ///< Offset: 0x04 - OFVCR0
        volatile uint32_t CMPIER0;  ///< Offset: 0x08 - CMPIER0
        volatile uint32_t CMPRSR0;  ///< Offset: 0x0C - CMPRSR0
        volatile uint32_t CMPISR0;  ///< Offset: 0x10 - CMPISR0
        volatile uint32_t CMPICLR0;  ///< Offset: 0x14 - CMPICLR0
        volatile uint32_t OPACR1;  ///< Offset: 0x100 - OPACR1
        volatile uint32_t OFVCR1;  ///< Offset: 0x104 - OFVCR1
        volatile uint32_t CMPIER1;  ///< Offset: 0x108 - CMPIER1
        volatile uint32_t CMPRSR1;  ///< Offset: 0x10C - CMPRSR1
        volatile uint32_t CMPISR1;  ///< Offset: 0x110 - CMPISR1
        volatile uint32_t CMPICLR1;  ///< Offset: 0x114 - CMPICLR1
    };

    /// Peripheral instances
    inline Registers* OPACMP = reinterpret_cast<Registers*>(OPACMP_BASE);

}

// ============================================================================
// GPTM0 Peripheral
// ============================================================================

namespace gptm0 {
    /// Base addresses
    constexpr uint32_t GPTM0_BASE = 0x4006E000;

    /// GPTM0 Register structure
    struct Registers {
        volatile uint32_t GPTM0_CNTCFR;  ///< Offset: 0x00 - GPTM0_CNTCFR
        volatile uint32_t GPTM0_MDCFR;  ///< Offset: 0x04 - GPTM0_MDCFR
        volatile uint32_t GPTM0_TRCFR;  ///< Offset: 0x08 - GPTM0_TRCFR
        volatile uint32_t GPTM0_CTR;  ///< Offset: 0x10 - GPTM0_CTR
        volatile uint32_t GPTM0_CH0ICFR;  ///< Offset: 0x20 - GPTM0_CH0ICFR
        volatile uint32_t GPTM0_CH1ICFR;  ///< Offset: 0x24 - GPTM0_CH1ICFR
        volatile uint32_t GPTM0_CH2ICFR;  ///< Offset: 0x28 - GPTM0_CH2ICFR
        volatile uint32_t GPTM0_CH3ICFR;  ///< Offset: 0x2C - GPTM0_CH3ICFR
        volatile uint32_t GPTM0_CH0OCFR;  ///< Offset: 0x40 - GPTM0_CH0OCFR
        volatile uint32_t GPTM0_CH1OCFR;  ///< Offset: 0x44 - GPTM0_CH1OCFR
        volatile uint32_t GPTM0_CH2OCFR;  ///< Offset: 0x48 - GPTM0_CH2OCFR
        volatile uint32_t GPTM0_CH3OCFR;  ///< Offset: 0x4C - GPTM0_CH3OCFR
        volatile uint32_t GPTM0_CHCTR;  ///< Offset: 0x50 - GPTM0_CHCTR
        volatile uint32_t GPTM0_CHPOLR;  ///< Offset: 0x54 - GPTM0_CHPOLR
        volatile uint32_t GPTM0_ICTR;  ///< Offset: 0x74 - GPTM0_ICTR
        volatile uint32_t GPTM0_EVGR;  ///< Offset: 0x78 - GPTM0_EVGR
        volatile uint32_t GPTM0_INTSR;  ///< Offset: 0x7C - GPTM0_INTSR
        volatile uint32_t GPTM0_CNTR;  ///< Offset: 0x80 - GPTM0_CNTR
        volatile uint32_t GPTM0_PSCR;  ///< Offset: 0x84 - GPTM0_PSCR
        volatile uint32_t GPTM0_CRR;  ///< Offset: 0x88 - GPTM0_CRR
        volatile uint32_t GPTM0_CH0CCR;  ///< Offset: 0x90 - GPTM0_CH0CCR
        volatile uint32_t GPTM0_CH1CCR;  ///< Offset: 0x94 - GPTM0_CH1CCR
        volatile uint32_t GPTM0_CH2CCR;  ///< Offset: 0x98 - GPTM0_CH2CCR
        volatile uint32_t GPTM0_CH3CCR;  ///< Offset: 0x9C - GPTM0_CH3CCR
    };

    /// Peripheral instances
    inline Registers* GPTM0 = reinterpret_cast<Registers*>(GPTM0_BASE);

}

// ============================================================================
// GPTM1 Peripheral
// ============================================================================

namespace gptm1 {
    /// Base addresses
    constexpr uint32_t GPTM1_BASE = 0x4006F000;

    /// GPTM1 Register structure
    struct Registers {
        volatile uint32_t GPTM1_CNTCFR;  ///< Offset: 0x00 - GPTM1_CNTCFR
        volatile uint32_t GPTM1_MDCFR;  ///< Offset: 0x04 - GPTM1_MDCFR
        volatile uint32_t GPTM1_TRCFR;  ///< Offset: 0x08 - GPTM1_TRCFR
        volatile uint32_t GPTM1_CTR;  ///< Offset: 0x10 - GPTM1_CTR
        volatile uint32_t GPTM1_CH0ICFR;  ///< Offset: 0x20 - GPTM1_CH0ICFR
        volatile uint32_t GPTM1_CH1ICFR;  ///< Offset: 0x24 - GPTM1_CH1ICFR
        volatile uint32_t GPTM1_CH2ICFR;  ///< Offset: 0x28 - GPTM1_CH2ICFR
        volatile uint32_t GPTM1_CH3ICFR;  ///< Offset: 0x2C - GPTM1_CH3ICFR
        volatile uint32_t GPTM1_CH0OCFR;  ///< Offset: 0x40 - GPTM1_CH0OCFR
        volatile uint32_t GPTM1_CH1OCFR;  ///< Offset: 0x44 - GPTM1_CH1OCFR
        volatile uint32_t GPTM1_CH2OCFR;  ///< Offset: 0x48 - GPTM1_CH2OCFR
        volatile uint32_t GPTM1_CH3OCFR;  ///< Offset: 0x4C - GPTM1_CH3OCFR
        volatile uint32_t GPTM1_CHCTR;  ///< Offset: 0x50 - GPTM1_CHCTR
        volatile uint32_t GPTM1_CHPOLR;  ///< Offset: 0x54 - GPTM1_CHPOLR
        volatile uint32_t GPTM1_ICTR;  ///< Offset: 0x74 - GPTM1_ICTR
        volatile uint32_t GPTM1_EVGR;  ///< Offset: 0x78 - GPTM1_EVGR
        volatile uint32_t GPTM1_INTSR;  ///< Offset: 0x7C - GPTM1_INTSR
        volatile uint32_t GPTM1_CNTR;  ///< Offset: 0x80 - GPTM1_CNTR
        volatile uint32_t GPTM1_PSCR;  ///< Offset: 0x84 - GPTM1_PSCR
        volatile uint32_t GPTM1_CRR;  ///< Offset: 0x88 - GPTM1_CRR
        volatile uint32_t GPTM1_CH0CCR;  ///< Offset: 0x90 - GPTM1_CH0CCR
        volatile uint32_t GPTM1_CH1CCR;  ///< Offset: 0x94 - GPTM1_CH1CCR
        volatile uint32_t GPTM1_CH2CCR;  ///< Offset: 0x98 - GPTM1_CH2CCR
        volatile uint32_t GPTM1_CH3CCR;  ///< Offset: 0x9C - GPTM1_CH3CCR
    };

    /// Peripheral instances
    inline Registers* GPTM1 = reinterpret_cast<Registers*>(GPTM1_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4006A000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_CNT;  ///< Offset: 0x00 - RTC_CNT
        volatile uint32_t RTC_CMP;  ///< Offset: 0x04 - RTC_CMP
        volatile uint32_t RTC_CR;  ///< Offset: 0x08 - RTC_CR
        volatile uint32_t RTC_SR;  ///< Offset: 0x0C - RTC_SR
        volatile uint32_t RTC_IWEN;  ///< Offset: 0x10 - RTC_IWEN
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40068000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDT_CR;  ///< Offset: 0x00 - WDT_CR
        volatile uint32_t WDT_MR0;  ///< Offset: 0x04 - WDT_MR0
        volatile uint32_t WDT_MR1;  ///< Offset: 0x08 - WDT_MR1
        volatile uint32_t WDT_SR;  ///< Offset: 0x0C - WDT_SR
        volatile uint32_t WDT_PR;  ///< Offset: 0x10 - WDT_PR
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C_BASE = 0x40048000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2C_CR;  ///< Offset: 0x00 - I2C_CR
        volatile uint32_t I2C_IER;  ///< Offset: 0x04 - I2C_IER
        volatile uint32_t I2C_ADDR;  ///< Offset: 0x08 - I2C_ADDR
        volatile uint32_t I2C_SR;  ///< Offset: 0x0C - I2C_SR
        volatile uint32_t I2C_SHPGR;  ///< Offset: 0x10 - I2C_SHPGR
        volatile uint32_t I2C_SLPGR;  ///< Offset: 0x14 - I2C_SLPGR
        volatile uint32_t I2C_DR;  ///< Offset: 0x18 - I2C_DR
        volatile uint32_t I2C_TAR;  ///< Offset: 0x1C - I2C_TAR
    };

    /// Peripheral instances
    inline Registers* I2C = reinterpret_cast<Registers*>(I2C_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI_BASE = 0x40004000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CR0;  ///< Offset: 0x00 - SPI_CR0
        volatile uint32_t SPI_CR1;  ///< Offset: 0x04 - SPI_CR1
        volatile uint32_t SPI_IER;  ///< Offset: 0x08 - SPI_IER
        volatile uint32_t SPI_CPR;  ///< Offset: 0x0C - SPI_CPR
        volatile uint32_t SPI_DR;  ///< Offset: 0x10 - SPI_DR
        volatile uint32_t SPI_SR;  ///< Offset: 0x14 - SPI_SR
        volatile uint32_t SPI_FCR;  ///< Offset: 0x18 - SPI_FCR
        volatile uint32_t SPI_FSR;  ///< Offset: 0x1C - SPI_FSR
        volatile uint32_t SPI_FTOCR;  ///< Offset: 0x20 - SPI_FTOCR
    };

    /// Peripheral instances
    inline Registers* SPI = reinterpret_cast<Registers*>(SPI_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART_BASE = 0x40000000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t USART_RBR;  ///< Offset: 0x00 - USART_RBR
        volatile uint32_t USART_TBR;  ///< Offset: 0x00 - USART_TBR
        volatile uint32_t USART_IER;  ///< Offset: 0x04 - USART_IER
        volatile uint32_t USART_IIR;  ///< Offset: 0x08 - USART_IIR
        volatile uint32_t USART_FCR;  ///< Offset: 0x0C - USART_FCR
        volatile uint32_t USART_LCR;  ///< Offset: 0x10 - USART_LCR
        volatile uint32_t USART_MODCR;  ///< Offset: 0x14 - USART_MODCR
        volatile uint32_t USART_LSR;  ///< Offset: 0x18 - USART_LSR
        volatile uint32_t USART_MODSR;  ///< Offset: 0x1C - USART_MODSR
        volatile uint32_t USART_TPR;  ///< Offset: 0x20 - USART_TPR
        volatile uint32_t USART_MDR;  ///< Offset: 0x24 - USART_MDR
        volatile uint32_t USART_IrDACR;  ///< Offset: 0x28 - USART_IrDACR
        volatile uint32_t USART_RS485CR;  ///< Offset: 0x2C - USART_RS485CR
        volatile uint32_t USART_SYNCR;  ///< Offset: 0x30 - USART_SYNCR
        volatile uint32_t USART_DEGTSTR;  ///< Offset: 0x34 - USART_DEGTSTR
        volatile uint32_t USART_DLR;  ///< Offset: 0x38 - USART_DLR
    };

    /// Peripheral instances
    inline Registers* USART = reinterpret_cast<Registers*>(USART_BASE);

}


} // namespace alloy::generated::ht32f125x

#endif // ALLOY_GENERATED_HT32F125X_PERIPHERALS_HPP