/// Auto-generated code for HT32F275x
/// Generated by Alloy Code Generator
/// Source: holtek_ht32f275x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:12
#ifndef ALLOY_GENERATED_HT32F275X_PERIPHERALS_HPP
#define ALLOY_GENERATED_HT32F275X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::ht32f275x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_scb = true;
    constexpr uint32_t num_scb_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_fault = true;
    constexpr uint32_t num_fault_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_ckcu = true;
    constexpr uint32_t num_ckcu_instances = 1;
    constexpr bool has_rstcu = true;
    constexpr uint32_t num_rstcu_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_afio = true;
    constexpr uint32_t num_afio_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_opacmp = true;
    constexpr uint32_t num_opacmp_instances = 1;
    constexpr bool has_mctm = true;
    constexpr uint32_t num_mctm_instances = 1;
    constexpr bool has_gptm0 = true;
    constexpr uint32_t num_gptm0_instances = 1;
    constexpr bool has_gptm1 = true;
    constexpr uint32_t num_gptm1_instances = 1;
    constexpr bool has_bftm0 = true;
    constexpr uint32_t num_bftm0_instances = 1;
    constexpr bool has_bftm1 = true;
    constexpr uint32_t num_bftm1_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_sci = true;
    constexpr uint32_t num_sci_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_csif = true;
    constexpr uint32_t num_csif_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fault_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ckcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rstcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct afio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct opacmp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mctm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gptm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gptm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sci_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct csif_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart0 = true;
    constexpr bool has_usart1 = true;
}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E000;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ICTR;  ///< Offset: 0x04 - ICTR
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - ACTLR
        volatile uint32_t ISER0;  ///< Offset: 0x100 - ISER0
        volatile uint32_t ISER1;  ///< Offset: 0x104 - ISER1
        volatile uint32_t ISER2;  ///< Offset: 0x108 - ISER2
        volatile uint32_t ICER0;  ///< Offset: 0x180 - ICER0
        volatile uint32_t ICER1;  ///< Offset: 0x184 - ICER1
        volatile uint32_t ICER2;  ///< Offset: 0x188 - ICER2
        volatile uint32_t ISPR0;  ///< Offset: 0x200 - ISPR0
        volatile uint32_t ISPR1;  ///< Offset: 0x204 - ISPR1
        volatile uint32_t ISPR2;  ///< Offset: 0x208 - ISPR2
        volatile uint32_t ICPR0;  ///< Offset: 0x280 - ICPR0
        volatile uint32_t ICPR1;  ///< Offset: 0x284 - ICPR1
        volatile uint32_t ICPR2;  ///< Offset: 0x288 - ICPR2
        volatile uint32_t IABR0;  ///< Offset: 0x300 - IABR0
        volatile uint32_t IABR1;  ///< Offset: 0x304 - IABR1
        volatile uint32_t IABR2;  ///< Offset: 0x308 - IABR2
        volatile uint32_t IP0;  ///< Offset: 0x400 - IP0
        volatile uint32_t IP1;  ///< Offset: 0x404 - IP1
        volatile uint32_t IP2;  ///< Offset: 0x408 - IP2
        volatile uint32_t IP3;  ///< Offset: 0x40C - IP3
        volatile uint32_t IP4;  ///< Offset: 0x410 - IP4
        volatile uint32_t IP5;  ///< Offset: 0x414 - IP5
        volatile uint32_t IP6;  ///< Offset: 0x418 - IP6
        volatile uint32_t IP7;  ///< Offset: 0x41C - IP7
        volatile uint32_t IP8;  ///< Offset: 0x420 - IP8
        volatile uint32_t IP9;  ///< Offset: 0x424 - IP9
        volatile uint32_t IP10;  ///< Offset: 0x428 - IP10
        volatile uint32_t IP11;  ///< Offset: 0x42C - IP11
        volatile uint32_t IP12;  ///< Offset: 0x430 - IP12
        volatile uint32_t IP13;  ///< Offset: 0x434 - IP13
        volatile uint32_t IP14;  ///< Offset: 0x438 - IP14
        volatile uint32_t IP15;  ///< Offset: 0x43C - IP15
        volatile uint32_t IP16;  ///< Offset: 0x440 - IP16
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - ICSR
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - VTOR
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - AIRCR
        volatile uint32_t SHP0;  ///< Offset: 0xD18 - SHP0
        volatile uint32_t SHP1;  ///< Offset: 0xD1C - SHP1
        volatile uint32_t SHP2;  ///< Offset: 0xD20 - SHP2
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - SHCSR
        volatile uint32_t STIR;  ///< Offset: 0xF00 - STIR
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED10;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t SCR;  ///< Offset: 0x00 - SCR
        volatile uint32_t CCR;  ///< Offset: 0x04 - CCR
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - CTRL
        volatile uint32_t LOAD;  ///< Offset: 0x04 - LOAD
        volatile uint32_t VAL;  ///< Offset: 0x08 - VAL
        volatile uint32_t CALIB;  ///< Offset: 0x0C - CALIB
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

}

// ============================================================================
// Fault Peripheral
// ============================================================================

namespace fault {
    /// Base addresses
    constexpr uint32_t Fault_Reports_BASE = 0xE000ED28;

    /// Fault Register structure
    struct Registers {
        volatile uint32_t CFSR;  ///< Offset: 0x00 - CFSR
        volatile uint32_t MFSR;  ///< Offset: 0x00 - MFSR
        volatile uint32_t MMFAR;  ///< Offset: 0x0C - MMFAR
        volatile uint32_t BFSR;  ///< Offset: 0x01 - BFSR
        volatile uint32_t BFAR;  ///< Offset: 0x10 - BFAR
        volatile uint32_t UFSR;  ///< Offset: 0x02 - UFSR
        volatile uint32_t HFSR;  ///< Offset: 0x04 - HFSR
        volatile uint32_t DFSR;  ///< Offset: 0x08 - DFSR
        volatile uint32_t AFSR;  ///< Offset: 0x14 - AFSR
    };

    /// Peripheral instances
    inline Registers* Fault_Reports = reinterpret_cast<Registers*>(Fault_Reports_BASE);

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x40080000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t FMC_TADR;  ///< Offset: 0x00 - FMC_TADR
        volatile uint32_t FMC_WRDR;  ///< Offset: 0x04 - FMC_WRDR
        volatile uint32_t FMC_OCMR;  ///< Offset: 0x0C - FMC_OCMR
        volatile uint32_t FMC_OPCR;  ///< Offset: 0x10 - FMC_OPCR
        volatile uint32_t FMC_OIER;  ///< Offset: 0x14 - FMC_OIER
        volatile uint32_t FMC_OISR;  ///< Offset: 0x18 - FMC_OISR
        volatile uint32_t FMC_PPSR0;  ///< Offset: 0x20 - FMC_PPSR0
        volatile uint32_t FMC_PPSR1;  ///< Offset: 0x24 - FMC_PPSR1
        volatile uint32_t FMC_PPSR2;  ///< Offset: 0x28 - FMC_PPSR2
        volatile uint32_t FMC_PPSR3;  ///< Offset: 0x2C - FMC_PPSR3
        volatile uint32_t FMC_CPSR;  ///< Offset: 0x30 - FMC_CPSR
        volatile uint32_t FMC_VMCR;  ///< Offset: 0x100 - FMC_VMCR
        volatile uint32_t FMC_CFCR;  ///< Offset: 0x200 - FMC_CFCR
        volatile uint32_t FMC_SBVT0;  ///< Offset: 0x300 - FMC_SBVT0
        volatile uint32_t FMC_SBVT1;  ///< Offset: 0x304 - FMC_SBVT1
        volatile uint32_t FMC_SBVT2;  ///< Offset: 0x308 - FMC_SBVT2
        volatile uint32_t FMC_SBVT3;  ///< Offset: 0x30C - FMC_SBVT3
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWRCU_BASE = 0x4006A100;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWRCU_BAKSR;  ///< Offset: 0x00 - PWRCU_BAKSR
        volatile uint32_t PWRCU_BAKCR;  ///< Offset: 0x04 - PWRCU_BAKCR
        volatile uint32_t PWRCU_BAKTEST;  ///< Offset: 0x08 - PWRCU_BAKTEST
        volatile uint32_t PWRCU_HSIRCR;  ///< Offset: 0x0C - PWRCU_HSIRCR
        volatile uint32_t PWRCU_LVDCSR;  ///< Offset: 0x10 - PWRCU_LVDCSR
        volatile uint32_t PWRCU_BAKREG0;  ///< Offset: 0x100 - PWRCU_BAKREG0
        volatile uint32_t PWRCU_BAKREG1;  ///< Offset: 0x104 - PWRCU_BAKREG1
        volatile uint32_t PWRCU_BAKREG2;  ///< Offset: 0x108 - PWRCU_BAKREG2
        volatile uint32_t PWRCU_BAKREG3;  ///< Offset: 0x10C - PWRCU_BAKREG3
        volatile uint32_t PWRCU_BAKREG4;  ///< Offset: 0x110 - PWRCU_BAKREG4
        volatile uint32_t PWRCU_BAKREG5;  ///< Offset: 0x114 - PWRCU_BAKREG5
        volatile uint32_t PWRCU_BAKREG6;  ///< Offset: 0x118 - PWRCU_BAKREG6
        volatile uint32_t PWRCU_BAKREG7;  ///< Offset: 0x11C - PWRCU_BAKREG7
        volatile uint32_t PWRCU_BAKREG8;  ///< Offset: 0x120 - PWRCU_BAKREG8
        volatile uint32_t PWRCU_BAKREG9;  ///< Offset: 0x124 - PWRCU_BAKREG9
    };

    /// Peripheral instances
    inline Registers* PWRCU = reinterpret_cast<Registers*>(PWRCU_BASE);

}

// ============================================================================
// CKCU Peripheral
// ============================================================================

namespace ckcu {
    /// Base addresses
    constexpr uint32_t CKCU_BASE = 0x40088000;

    /// CKCU Register structure
    struct Registers {
        volatile uint32_t CKCU_GCFGR;  ///< Offset: 0x00 - CKCU_GCFGR
        volatile uint32_t CKCU_GCCR;  ///< Offset: 0x04 - CKCU_GCCR
        volatile uint32_t CKCU_GCSR;  ///< Offset: 0x08 - CKCU_GCSR
        volatile uint32_t CKCU_GCIR;  ///< Offset: 0x0C - CKCU_GCIR
        volatile uint32_t CKCU_PLLCFGR;  ///< Offset: 0x18 - CKCU_PLLCFGR
        volatile uint32_t CKCU_PLLCR;  ///< Offset: 0x1C - CKCU_PLLCR
        volatile uint32_t CKCU_AHBCFGR;  ///< Offset: 0x20 - CKCU_AHBCFGR
        volatile uint32_t CKCU_AHBCCR;  ///< Offset: 0x24 - CKCU_AHBCCR
        volatile uint32_t CKCU_APBCFGR;  ///< Offset: 0x28 - CKCU_APBCFGR
        volatile uint32_t CKCU_APBCCR0;  ///< Offset: 0x2C - CKCU_APBCCR0
        volatile uint32_t CKCU_APBCCR1;  ///< Offset: 0x30 - CKCU_APBCCR1
        volatile uint32_t CKCU_CKST;  ///< Offset: 0x34 - CKCU_CKST
        volatile uint32_t CKCU_LPCR;  ///< Offset: 0x300 - CKCU_LPCR
        volatile uint32_t CKCU_MCUDBGCR;  ///< Offset: 0x304 - CKCU_MCUDBGCR
    };

    /// Peripheral instances
    inline Registers* CKCU = reinterpret_cast<Registers*>(CKCU_BASE);

}

// ============================================================================
// RSTCU Peripheral
// ============================================================================

namespace rstcu {
    /// Base addresses
    constexpr uint32_t RSTCU_BASE = 0x40088100;

    /// RSTCU Register structure
    struct Registers {
        volatile uint32_t RSTCU_GRSR;  ///< Offset: 0x00 - RSTCU_GRSR
        volatile uint32_t RSTCU_AHBPRSTR;  ///< Offset: 0x04 - RSTCU_AHBPRSTR
        volatile uint32_t RSTCU_APBPRSTR0;  ///< Offset: 0x08 - RSTCU_APBPRSTR0
        volatile uint32_t RSTCU_APBPRSTR1;  ///< Offset: 0x0C - RSTCU_APBPRSTR1
    };

    /// Peripheral instances
    inline Registers* RSTCU = reinterpret_cast<Registers*>(RSTCU_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x4001A000;
    constexpr uint32_t GPIOB_BASE = 0x4001B000;
    constexpr uint32_t GPIOC_BASE = 0x4001C000;
    constexpr uint32_t GPIOD_BASE = 0x4001D000;
    constexpr uint32_t GPIOE_BASE = 0x4001E000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIOA_DIRCR;  ///< Offset: 0x00 - GPIOA_DIRCR
        volatile uint32_t GPIOA_INER;  ///< Offset: 0x04 - GPIOA_INER
        volatile uint32_t GPIOA_PUR;  ///< Offset: 0x08 - GPIOA_PUR
        volatile uint32_t GPIOA_PDR;  ///< Offset: 0x0C - GPIOA_PDR
        volatile uint32_t GPIOA_ODR;  ///< Offset: 0x10 - GPIOA_ODR
        volatile uint32_t GPIOA_DRVR;  ///< Offset: 0x14 - GPIOA_DRVR
        volatile uint32_t GPIOA_LOCKR;  ///< Offset: 0x18 - GPIOA_LOCKR
        volatile uint32_t GPIOA_DINR;  ///< Offset: 0x1C - GPIOA_DINR
        volatile uint32_t GPIOA_DOUTR;  ///< Offset: 0x20 - GPIOA_DOUTR
        volatile uint32_t GPIOA_SRR;  ///< Offset: 0x24 - GPIOA_SRR
        volatile uint32_t GPIOA_RR;  ///< Offset: 0x28 - GPIOA_RR
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

}

// ============================================================================
// AFIO Peripheral
// ============================================================================

namespace afio {
    /// Base addresses
    constexpr uint32_t AFIO_BASE = 0x40022000;

    /// AFIO Register structure
    struct Registers {
        volatile uint32_t AFIO_ESSR0;  ///< Offset: 0x00 - AFIO_ESSR0
        volatile uint32_t AFIO_ESSR1;  ///< Offset: 0x04 - AFIO_ESSR1
        volatile uint32_t AFIO_GPACFGR;  ///< Offset: 0x08 - AFIO_GPACFGR
        volatile uint32_t AFIO_GPBCFGR;  ///< Offset: 0x0C - AFIO_GPBCFGR
        volatile uint32_t AFIO_GPCCFGR;  ///< Offset: 0x10 - AFIO_GPCCFGR
        volatile uint32_t AFIO_GPDCFGR;  ///< Offset: 0x14 - AFIO_GPDCFGR
        volatile uint32_t AFIO_GPECFGR;  ///< Offset: 0x18 - AFIO_GPECFGR
    };

    /// Peripheral instances
    inline Registers* AFIO = reinterpret_cast<Registers*>(AFIO_BASE);

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40024000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_CFGR0;  ///< Offset: 0x00 - EXTI_CFGR0
        volatile uint32_t EXTI_CFGR1;  ///< Offset: 0x04 - EXTI_CFGR1
        volatile uint32_t EXTI_CFGR2;  ///< Offset: 0x08 - EXTI_CFGR2
        volatile uint32_t EXTI_CFGR3;  ///< Offset: 0x0C - EXTI_CFGR3
        volatile uint32_t EXTI_CFGR4;  ///< Offset: 0x10 - EXTI_CFGR4
        volatile uint32_t EXTI_CFGR5;  ///< Offset: 0x14 - EXTI_CFGR5
        volatile uint32_t EXTI_CFGR6;  ///< Offset: 0x18 - EXTI_CFGR6
        volatile uint32_t EXTI_CFGR7;  ///< Offset: 0x1C - EXTI_CFGR7
        volatile uint32_t EXTI_CFGR8;  ///< Offset: 0x20 - EXTI_CFGR8
        volatile uint32_t EXTI_CFGR9;  ///< Offset: 0x24 - EXTI_CFGR9
        volatile uint32_t EXTI_CFGR10;  ///< Offset: 0x28 - EXTI_CFGR10
        volatile uint32_t EXTI_CFGR11;  ///< Offset: 0x2C - EXTI_CFGR11
        volatile uint32_t EXTI_CFGR12;  ///< Offset: 0x30 - EXTI_CFGR12
        volatile uint32_t EXTI_CFGR13;  ///< Offset: 0x34 - EXTI_CFGR13
        volatile uint32_t EXTI_CFGR14;  ///< Offset: 0x38 - EXTI_CFGR14
        volatile uint32_t EXTI_CFGR15;  ///< Offset: 0x3C - EXTI_CFGR15
        volatile uint32_t EXTI_CR;  ///< Offset: 0x40 - EXTI_CR
        volatile uint32_t EXTI_EDGEFLGR;  ///< Offset: 0x44 - EXTI_EDGEFLGR
        volatile uint32_t EXTI_EDGESR;  ///< Offset: 0x48 - EXTI_EDGESR
        volatile uint32_t EXTI_SSCR;  ///< Offset: 0x4C - EXTI_SSCR
        volatile uint32_t EXTI_WAKUPCR;  ///< Offset: 0x50 - EXTI_WAKUPCR
        volatile uint32_t EXTI_WAKUPPOLR;  ///< Offset: 0x54 - EXTI_WAKUPPOLR
        volatile uint32_t EXTI_WAKUPFLG;  ///< Offset: 0x58 - EXTI_WAKUPFLG
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40010000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_RST;  ///< Offset: 0x04 - ADC_RST
        volatile uint32_t ADC_CONV;  ///< Offset: 0x08 - ADC_CONV
        volatile uint32_t ADC_LST0;  ///< Offset: 0x10 - ADC_LST0
        volatile uint32_t ADC_LST1;  ///< Offset: 0x14 - ADC_LST1
        volatile uint32_t ADC_OFR0;  ///< Offset: 0x30 - ADC_OFR0
        volatile uint32_t ADC_OFR1;  ///< Offset: 0x34 - ADC_OFR1
        volatile uint32_t ADC_OFR2;  ///< Offset: 0x38 - ADC_OFR2
        volatile uint32_t ADC_OFR3;  ///< Offset: 0x3C - ADC_OFR3
        volatile uint32_t ADC_OFR4;  ///< Offset: 0x40 - ADC_OFR4
        volatile uint32_t ADC_OFR5;  ///< Offset: 0x44 - ADC_OFR5
        volatile uint32_t ADC_OFR6;  ///< Offset: 0x48 - ADC_OFR6
        volatile uint32_t ADC_OFR7;  ///< Offset: 0x4C - ADC_OFR7
        volatile uint32_t ADC_STR0;  ///< Offset: 0x70 - ADC_STR0
        volatile uint32_t ADC_STR1;  ///< Offset: 0x74 - ADC_STR1
        volatile uint32_t ADC_STR2;  ///< Offset: 0x78 - ADC_STR2
        volatile uint32_t ADC_STR3;  ///< Offset: 0x7C - ADC_STR3
        volatile uint32_t ADC_STR4;  ///< Offset: 0x80 - ADC_STR4
        volatile uint32_t ADC_STR5;  ///< Offset: 0x84 - ADC_STR5
        volatile uint32_t ADC_STR6;  ///< Offset: 0x88 - ADC_STR6
        volatile uint32_t ADC_STR7;  ///< Offset: 0x8C - ADC_STR7
        volatile uint32_t ADC_DR0;  ///< Offset: 0xB0 - ADC_DR0
        volatile uint32_t ADC_DR1;  ///< Offset: 0xB4 - ADC_DR1
        volatile uint32_t ADC_DR2;  ///< Offset: 0xB8 - ADC_DR2
        volatile uint32_t ADC_DR3;  ///< Offset: 0xBC - ADC_DR3
        volatile uint32_t ADC_DR4;  ///< Offset: 0xC0 - ADC_DR4
        volatile uint32_t ADC_DR5;  ///< Offset: 0xC4 - ADC_DR5
        volatile uint32_t ADC_DR6;  ///< Offset: 0xC8 - ADC_DR6
        volatile uint32_t ADC_DR7;  ///< Offset: 0xCC - ADC_DR7
        volatile uint32_t ADC_TCR;  ///< Offset: 0x100 - ADC_TCR
        volatile uint32_t ADC_TSR;  ///< Offset: 0x104 - ADC_TSR
        volatile uint32_t ADC_WCR;  ///< Offset: 0x120 - ADC_WCR
        volatile uint32_t ADC_LTR;  ///< Offset: 0x124 - ADC_LTR
        volatile uint32_t ADC_UTR;  ///< Offset: 0x128 - ADC_UTR
        volatile uint32_t ADC_IMR;  ///< Offset: 0x130 - ADC_IMR
        volatile uint32_t ADC_IRAW;  ///< Offset: 0x134 - ADC_IRAW
        volatile uint32_t ADC_IMASK;  ///< Offset: 0x138 - ADC_IMASK
        volatile uint32_t ADC_ICLR;  ///< Offset: 0x13C - ADC_ICLR
        volatile uint32_t ADC_DMAR;  ///< Offset: 0x140 - ADC_DMAR
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

}

// ============================================================================
// OPACMP Peripheral
// ============================================================================

namespace opacmp {
    /// Base addresses
    constexpr uint32_t OPACMP_BASE = 0x40018000;

    /// OPACMP Register structure
    struct Registers {
        volatile uint32_t OPACR0;  ///< Offset: 0x00 - OPACR0
        volatile uint32_t OFVCR0;  ///< Offset: 0x04 - OFVCR0
        volatile uint32_t CMPIER0;  ///< Offset: 0x08 - CMPIER0
        volatile uint32_t CMPRSR0;  ///< Offset: 0x0C - CMPRSR0
        volatile uint32_t CMPISR0;  ///< Offset: 0x10 - CMPISR0
        volatile uint32_t CMPICLR0;  ///< Offset: 0x14 - CMPICLR0
        volatile uint32_t OPACR1;  ///< Offset: 0x100 - OPACR1
        volatile uint32_t OFVCR1;  ///< Offset: 0x104 - OFVCR1
        volatile uint32_t CMPIER1;  ///< Offset: 0x108 - CMPIER1
        volatile uint32_t CMPRSR1;  ///< Offset: 0x10C - CMPRSR1
        volatile uint32_t CMPISR1;  ///< Offset: 0x110 - CMPISR1
        volatile uint32_t CMPICLR1;  ///< Offset: 0x114 - CMPICLR1
    };

    /// Peripheral instances
    inline Registers* OPACMP = reinterpret_cast<Registers*>(OPACMP_BASE);

}

// ============================================================================
// MCTM Peripheral
// ============================================================================

namespace mctm {
    /// Base addresses
    constexpr uint32_t MCTM_BASE = 0x4002C000;

    /// MCTM Register structure
    struct Registers {
        volatile uint32_t MCTM_CNTCFR;  ///< Offset: 0x00 - MCTM_CNTCFR
        volatile uint32_t MCTM_MDCFR;  ///< Offset: 0x04 - MCTM_MDCFR
        volatile uint32_t MCTM_TRCFR;  ///< Offset: 0x08 - MCTM_TRCFR
        volatile uint32_t MCTM_CTR;  ///< Offset: 0x10 - MCTM_CTR
        volatile uint32_t MCTM_CH0ICFR;  ///< Offset: 0x20 - MCTM_CH0ICFR
        volatile uint32_t MCTM_CH1ICFR;  ///< Offset: 0x24 - MCTM_CH1ICFR
        volatile uint32_t MCTM_CH2ICFR;  ///< Offset: 0x28 - MCTM_CH2ICFR
        volatile uint32_t MCTM_CH3ICFR;  ///< Offset: 0x2C - MCTM_CH3ICFR
        volatile uint32_t MCTM_CH0OCFR;  ///< Offset: 0x40 - MCTM_CH0OCFR
        volatile uint32_t MCTM_CH1OCFR;  ///< Offset: 0x44 - MCTM_CH1OCFR
        volatile uint32_t MCTM_CH2OCFR;  ///< Offset: 0x48 - MCTM_CH2OCFR
        volatile uint32_t MCTM_CH3OCFR;  ///< Offset: 0x4C - MCTM_CH3OCFR
        volatile uint32_t MCTM_CHCTR;  ///< Offset: 0x50 - MCTM_CHCTR
        volatile uint32_t MCTM_CHPOLR;  ///< Offset: 0x54 - MCTM_CHPOLR
        volatile uint32_t MCTM_CHBRKCFR;  ///< Offset: 0x6C - MCTM_CHBRKCFR
        volatile uint32_t MCTM_CHBRKCTR;  ///< Offset: 0x70 - MCTM_CHBRKCTR
        volatile uint32_t MCTM_DICTR;  ///< Offset: 0x74 - MCTM_DICTR
        volatile uint32_t MCTM_EVGR;  ///< Offset: 0x78 - MCTM_EVGR
        volatile uint32_t MCTM_INTSR;  ///< Offset: 0x7C - MCTM_INTSR
        volatile uint32_t MCTM_CNTR;  ///< Offset: 0x80 - MCTM_CNTR
        volatile uint32_t MCTM_PSCR;  ///< Offset: 0x84 - MCTM_PSCR
        volatile uint32_t MCTM_CRR;  ///< Offset: 0x88 - MCTM_CRR
        volatile uint32_t MCTM_REPR;  ///< Offset: 0x8C - MCTM_REPR
        volatile uint32_t MCTM_CH0CCR;  ///< Offset: 0x90 - MCTM_CH0CCR
        volatile uint32_t MCTM_CH1CCR;  ///< Offset: 0x94 - MCTM_CH1CCR
        volatile uint32_t MCTM_CH2CCR;  ///< Offset: 0x98 - MCTM_CH2CCR
        volatile uint32_t MCTM_CH3CCR;  ///< Offset: 0x9C - MCTM_CH3CCR
    };

    /// Peripheral instances
    inline Registers* MCTM = reinterpret_cast<Registers*>(MCTM_BASE);

}

// ============================================================================
// GPTM0 Peripheral
// ============================================================================

namespace gptm0 {
    /// Base addresses
    constexpr uint32_t GPTM0_BASE = 0x4006E000;

    /// GPTM0 Register structure
    struct Registers {
        volatile uint32_t GPTM0_CNTCFR;  ///< Offset: 0x00 - GPTM0_CNTCFR
        volatile uint32_t GPTM0_MDCFR;  ///< Offset: 0x04 - GPTM0_MDCFR
        volatile uint32_t GPTM0_TRCFR;  ///< Offset: 0x08 - GPTM0_TRCFR
        volatile uint32_t GPTM0_CTR;  ///< Offset: 0x10 - GPTM0_CTR
        volatile uint32_t GPTM0_CH0ICFR;  ///< Offset: 0x20 - GPTM0_CH0ICFR
        volatile uint32_t GPTM0_CH1ICFR;  ///< Offset: 0x24 - GPTM0_CH1ICFR
        volatile uint32_t GPTM0_CH2ICFR;  ///< Offset: 0x28 - GPTM0_CH2ICFR
        volatile uint32_t GPTM0_CH3ICFR;  ///< Offset: 0x2C - GPTM0_CH3ICFR
        volatile uint32_t GPTM0_CH0OCFR;  ///< Offset: 0x40 - GPTM0_CH0OCFR
        volatile uint32_t GPTM0_CH1OCFR;  ///< Offset: 0x44 - GPTM0_CH1OCFR
        volatile uint32_t GPTM0_CH2OCFR;  ///< Offset: 0x48 - GPTM0_CH2OCFR
        volatile uint32_t GPTM0_CH3OCFR;  ///< Offset: 0x4C - GPTM0_CH3OCFR
        volatile uint32_t GPTM0_CHCTR;  ///< Offset: 0x50 - GPTM0_CHCTR
        volatile uint32_t GPTM0_CHPOLR;  ///< Offset: 0x54 - GPTM0_CHPOLR
        volatile uint32_t GPTM0_DICTR;  ///< Offset: 0x74 - GPTM0_DICTR
        volatile uint32_t GPTM0_EVGR;  ///< Offset: 0x78 - GPTM0_EVGR
        volatile uint32_t GPTM0_INTSR;  ///< Offset: 0x7C - GPTM0_INTSR
        volatile uint32_t GPTM0_CNTR;  ///< Offset: 0x80 - GPTM0_CNTR
        volatile uint32_t GPTM0_PSCR;  ///< Offset: 0x84 - GPTM0_PSCR
        volatile uint32_t GPTM0_CRR;  ///< Offset: 0x88 - GPTM0_CRR
        volatile uint32_t GPTM0_CH0CCR;  ///< Offset: 0x90 - GPTM0_CH0CCR
        volatile uint32_t GPTM0_CH1CCR;  ///< Offset: 0x94 - GPTM0_CH1CCR
        volatile uint32_t GPTM0_CH2CCR;  ///< Offset: 0x98 - GPTM0_CH2CCR
        volatile uint32_t GPTM0_CH3CCR;  ///< Offset: 0x9C - GPTM0_CH3CCR
    };

    /// Peripheral instances
    inline Registers* GPTM0 = reinterpret_cast<Registers*>(GPTM0_BASE);

}

// ============================================================================
// GPTM1 Peripheral
// ============================================================================

namespace gptm1 {
    /// Base addresses
    constexpr uint32_t GPTM1_BASE = 0x4006F000;

    /// GPTM1 Register structure
    struct Registers {
        volatile uint32_t GPTM1_CNTCFR;  ///< Offset: 0x00 - GPTM1_CNTCFR
        volatile uint32_t GPTM1_MDCFR;  ///< Offset: 0x04 - GPTM1_MDCFR
        volatile uint32_t GPTM1_TRCFR;  ///< Offset: 0x08 - GPTM1_TRCFR
        volatile uint32_t GPTM1_CTR;  ///< Offset: 0x10 - GPTM1_CTR
        volatile uint32_t GPTM1_CH0ICFR;  ///< Offset: 0x20 - GPTM1_CH0ICFR
        volatile uint32_t GPTM1_CH1ICFR;  ///< Offset: 0x24 - GPTM1_CH1ICFR
        volatile uint32_t GPTM1_CH2ICFR;  ///< Offset: 0x28 - GPTM1_CH2ICFR
        volatile uint32_t GPTM1_CH3ICFR;  ///< Offset: 0x2C - GPTM1_CH3ICFR
        volatile uint32_t GPTM1_CH0OCFR;  ///< Offset: 0x40 - GPTM1_CH0OCFR
        volatile uint32_t GPTM1_CH1OCFR;  ///< Offset: 0x44 - GPTM1_CH1OCFR
        volatile uint32_t GPTM1_CH2OCFR;  ///< Offset: 0x48 - GPTM1_CH2OCFR
        volatile uint32_t GPTM1_CH3OCFR;  ///< Offset: 0x4C - GPTM1_CH3OCFR
        volatile uint32_t GPTM1_CHCTR;  ///< Offset: 0x50 - GPTM1_CHCTR
        volatile uint32_t GPTM1_CHPOLR;  ///< Offset: 0x54 - GPTM1_CHPOLR
        volatile uint32_t GPTM1_DICTR;  ///< Offset: 0x74 - GPTM1_DICTR
        volatile uint32_t GPTM1_EVGR;  ///< Offset: 0x78 - GPTM1_EVGR
        volatile uint32_t GPTM1_INTSR;  ///< Offset: 0x7C - GPTM1_INTSR
        volatile uint32_t GPTM1_CNTR;  ///< Offset: 0x80 - GPTM1_CNTR
        volatile uint32_t GPTM1_PSCR;  ///< Offset: 0x84 - GPTM1_PSCR
        volatile uint32_t GPTM1_CRR;  ///< Offset: 0x88 - GPTM1_CRR
        volatile uint32_t GPTM1_CH0CCR;  ///< Offset: 0x90 - GPTM1_CH0CCR
        volatile uint32_t GPTM1_CH1CCR;  ///< Offset: 0x94 - GPTM1_CH1CCR
        volatile uint32_t GPTM1_CH2CCR;  ///< Offset: 0x98 - GPTM1_CH2CCR
        volatile uint32_t GPTM1_CH3CCR;  ///< Offset: 0x9C - GPTM1_CH3CCR
    };

    /// Peripheral instances
    inline Registers* GPTM1 = reinterpret_cast<Registers*>(GPTM1_BASE);

}

// ============================================================================
// BFTM0 Peripheral
// ============================================================================

namespace bftm0 {
    /// Base addresses
    constexpr uint32_t BFTM0_BASE = 0x40076000;

    /// BFTM0 Register structure
    struct Registers {
        volatile uint32_t BFTM0_CR;  ///< Offset: 0x00 - BFTM0_CR
        volatile uint32_t BFTM0_SR;  ///< Offset: 0x04 - BFTM0_SR
        volatile uint32_t BFTM0_CNTR;  ///< Offset: 0x08 - BFTM0_CNTR
        volatile uint32_t BFTM0_CMPR;  ///< Offset: 0x0C - BFTM0_CMPR
    };

    /// Peripheral instances
    inline Registers* BFTM0 = reinterpret_cast<Registers*>(BFTM0_BASE);

}

// ============================================================================
// BFTM1 Peripheral
// ============================================================================

namespace bftm1 {
    /// Base addresses
    constexpr uint32_t BFTM1_BASE = 0x40077000;

    /// BFTM1 Register structure
    struct Registers {
        volatile uint32_t BFTM1_CR;  ///< Offset: 0x00 - BFTM1_CR
        volatile uint32_t BFTM1_SR;  ///< Offset: 0x04 - BFTM1_SR
        volatile uint32_t BFTM1_CNTR;  ///< Offset: 0x08 - BFTM1_CNTR
        volatile uint32_t BFTM1_CMPR;  ///< Offset: 0x0C - BFTM1_CMPR
    };

    /// Peripheral instances
    inline Registers* BFTM1 = reinterpret_cast<Registers*>(BFTM1_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4006A000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_CNT;  ///< Offset: 0x00 - RTC_CNT
        volatile uint32_t RTC_CMP;  ///< Offset: 0x04 - RTC_CMP
        volatile uint32_t RTC_CR;  ///< Offset: 0x08 - RTC_CR
        volatile uint32_t RTC_SR;  ///< Offset: 0x0C - RTC_SR
        volatile uint32_t RTC_IWEN;  ///< Offset: 0x10 - RTC_IWEN
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40068000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDT_CR;  ///< Offset: 0x00 - WDT_CR
        volatile uint32_t WDT_MR0;  ///< Offset: 0x04 - WDT_MR0
        volatile uint32_t WDT_MR1;  ///< Offset: 0x08 - WDT_MR1
        volatile uint32_t WDT_SR;  ///< Offset: 0x0C - WDT_SR
        volatile uint32_t WDT_PR;  ///< Offset: 0x10 - WDT_PR
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40048000;
    constexpr uint32_t I2C1_BASE = 0x40049000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2C0_CR;  ///< Offset: 0x00 - I2C0_CR
        volatile uint32_t I2C0_IER;  ///< Offset: 0x04 - I2C0_IER
        volatile uint32_t I2C0_ADDR;  ///< Offset: 0x08 - I2C0_ADDR
        volatile uint32_t I2C0_SR;  ///< Offset: 0x0C - I2C0_SR
        volatile uint32_t I2C0_SHPGR;  ///< Offset: 0x10 - I2C0_SHPGR
        volatile uint32_t I2C0_SLPGR;  ///< Offset: 0x14 - I2C0_SLPGR
        volatile uint32_t I2C0_DR;  ///< Offset: 0x18 - I2C0_DR
        volatile uint32_t I2C0_TAR;  ///< Offset: 0x1C - I2C0_TAR
        volatile uint32_t I2C0_ADDMR;  ///< Offset: 0x20 - I2C0_ADDMR
        volatile uint32_t I2C0_ADDSR;  ///< Offset: 0x24 - I2C0_ADDSR
        volatile uint32_t I2C0_TOUT;  ///< Offset: 0x28 - I2C0_TOUT
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40004000;
    constexpr uint32_t SPI1_BASE = 0x40044000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI0_CR0;  ///< Offset: 0x00 - SPI0_CR0
        volatile uint32_t SPI0_CR1;  ///< Offset: 0x04 - SPI0_CR1
        volatile uint32_t SPI0_IER;  ///< Offset: 0x08 - SPI0_IER
        volatile uint32_t SPI0_CPR;  ///< Offset: 0x0C - SPI0_CPR
        volatile uint32_t SPI0_DR;  ///< Offset: 0x10 - SPI0_DR
        volatile uint32_t SPI0_SR;  ///< Offset: 0x14 - SPI0_SR
        volatile uint32_t SPI0_FCR;  ///< Offset: 0x18 - SPI0_FCR
        volatile uint32_t SPI0_FSR;  ///< Offset: 0x1C - SPI0_FSR
        volatile uint32_t SPI0_FTOCR;  ///< Offset: 0x20 - SPI0_FTOCR
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40000000;
    constexpr uint32_t USART1_BASE = 0x40040000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t USART0_RBR;  ///< Offset: 0x00 - USART0_RBR
        volatile uint32_t USART0_TBR;  ///< Offset: 0x00 - USART0_TBR
        volatile uint32_t USART0_IER;  ///< Offset: 0x04 - USART0_IER
        volatile uint32_t USART0_IIR;  ///< Offset: 0x08 - USART0_IIR
        volatile uint32_t USART0_FCR;  ///< Offset: 0x0C - USART0_FCR
        volatile uint32_t USART0_LCR;  ///< Offset: 0x10 - USART0_LCR
        volatile uint32_t USART0_MODCR;  ///< Offset: 0x14 - USART0_MODCR
        volatile uint32_t USART0_LSR;  ///< Offset: 0x18 - USART0_LSR
        volatile uint32_t USART0_MODSR;  ///< Offset: 0x1C - USART0_MODSR
        volatile uint32_t USART0_TPR;  ///< Offset: 0x20 - USART0_TPR
        volatile uint32_t USART0_MDR;  ///< Offset: 0x24 - USART0_MDR
        volatile uint32_t USART0_IrDACR;  ///< Offset: 0x28 - USART0_IrDACR
        volatile uint32_t USART0_RS485CR;  ///< Offset: 0x2C - USART0_RS485CR
        volatile uint32_t USART0_SYNCR;  ///< Offset: 0x30 - USART0_SYNCR
        volatile uint32_t USART0_FSR;  ///< Offset: 0x34 - USART0_FSR
        volatile uint32_t USART0_DLR;  ///< Offset: 0x38 - USART0_DLR
        volatile uint32_t USART0_DEGTSTR;  ///< Offset: 0x40 - USART0_DEGTSTR
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);

}

// ============================================================================
// SCI Peripheral
// ============================================================================

namespace sci {
    /// Base addresses
    constexpr uint32_t SCI_BASE = 0x40043000;

    /// SCI Register structure
    struct Registers {
        volatile uint32_t SCI_CR;  ///< Offset: 0x00 - SCI_CR
        volatile uint32_t SCI_SR;  ///< Offset: 0x04 - SCI_SR
        volatile uint32_t SCI_CCR;  ///< Offset: 0x08 - SCI_CCR
        volatile uint32_t SCI_ETU;  ///< Offset: 0x0C - SCI_ETU
        volatile uint32_t SCI_GT;  ///< Offset: 0x10 - SCI_GT
        volatile uint32_t SCI_WT;  ///< Offset: 0x14 - SCI_WT
        volatile uint32_t SCI_IER;  ///< Offset: 0x18 - SCI_IER
        volatile uint32_t SCI_IPR;  ///< Offset: 0x1C - SCI_IPR
        volatile uint32_t SCI_TXB;  ///< Offset: 0x20 - SCI_TXB
        volatile uint32_t SCI_RXB;  ///< Offset: 0x24 - SCI_RXB
        volatile uint32_t SCI_PSC;  ///< Offset: 0x28 - SCI_PSC
    };

    /// Peripheral instances
    inline Registers* SCI = reinterpret_cast<Registers*>(SCI_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x4004E000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t USB_CSR;  ///< Offset: 0x00 - USB_CSR
        volatile uint32_t USB_IER;  ///< Offset: 0x04 - USB_IER
        volatile uint32_t USB_ISR;  ///< Offset: 0x08 - USB_ISR
        volatile uint32_t USB_FCR;  ///< Offset: 0x0C - USB_FCR
        volatile uint32_t USB_DEVAR;  ///< Offset: 0x10 - USB_DEVAR
        volatile uint32_t USB_EP0CSR;  ///< Offset: 0x14 - USB_EP0CSR
        volatile uint32_t USB_EP0IER;  ///< Offset: 0x18 - USB_EP0IER
        volatile uint32_t USB_EP0ISR;  ///< Offset: 0x1C - USB_EP0ISR
        volatile uint32_t USB_EP0TCR;  ///< Offset: 0x20 - USB_EP0TCR
        volatile uint32_t USB_EP0CFGR;  ///< Offset: 0x24 - USB_EP0CFGR
        volatile uint32_t USB_EP1CSR;  ///< Offset: 0x28 - USB_EP1CSR
        volatile uint32_t USB_EP1IER;  ///< Offset: 0x2C - USB_EP1IER
        volatile uint32_t USB_EP1ISR;  ///< Offset: 0x30 - USB_EP1ISR
        volatile uint32_t USB_EP1TCR;  ///< Offset: 0x34 - USB_EP1TCR
        volatile uint32_t USB_EP1CFGR;  ///< Offset: 0x38 - USB_EP1CFGR
        volatile uint32_t USB_EP2CSR;  ///< Offset: 0x3C - USB_EP2CSR
        volatile uint32_t USB_EP2IER;  ///< Offset: 0x40 - USB_EP2IER
        volatile uint32_t USB_EP2ISR;  ///< Offset: 0x44 - USB_EP2ISR
        volatile uint32_t USB_EP2TCR;  ///< Offset: 0x48 - USB_EP2TCR
        volatile uint32_t USB_EP2CFGR;  ///< Offset: 0x4C - USB_EP2CFGR
        volatile uint32_t USB_EP3CSR;  ///< Offset: 0x50 - USB_EP3CSR
        volatile uint32_t USB_EP3IER;  ///< Offset: 0x54 - USB_EP3IER
        volatile uint32_t USB_EP3ISR;  ///< Offset: 0x58 - USB_EP3ISR
        volatile uint32_t USB_EP3TCR;  ///< Offset: 0x5C - USB_EP3TCR
        volatile uint32_t USB_EP3CFGR;  ///< Offset: 0x60 - USB_EP3CFGR
        volatile uint32_t USB_EP4CSR;  ///< Offset: 0x64 - USB_EP4CSR
        volatile uint32_t USB_EP4IER;  ///< Offset: 0x68 - USB_EP4IER
        volatile uint32_t USB_EP4ISR;  ///< Offset: 0x6C - USB_EP4ISR
        volatile uint32_t USB_EP4TCR;  ///< Offset: 0x70 - USB_EP4TCR
        volatile uint32_t USB_EP4CFGR;  ///< Offset: 0x74 - USB_EP4CFGR
        volatile uint32_t USB_EP5CSR;  ///< Offset: 0x78 - USB_EP5CSR
        volatile uint32_t USB_EP5IER;  ///< Offset: 0x7C - USB_EP5IER
        volatile uint32_t USB_EP5ISR;  ///< Offset: 0x80 - USB_EP5ISR
        volatile uint32_t USB_EP5TCR;  ///< Offset: 0x84 - USB_EP5TCR
        volatile uint32_t USB_EP5CFGR;  ///< Offset: 0x88 - USB_EP5CFGR
        volatile uint32_t USB_EP6CSR;  ///< Offset: 0x8C - USB_EP6CSR
        volatile uint32_t USB_EP6IER;  ///< Offset: 0x90 - USB_EP6IER
        volatile uint32_t USB_EP6ISR;  ///< Offset: 0x94 - USB_EP6ISR
        volatile uint32_t USB_EP6TCR;  ///< Offset: 0x98 - USB_EP6TCR
        volatile uint32_t USB_EP6CFGR;  ///< Offset: 0x9C - USB_EP6CFGR
        volatile uint32_t USB_EP7CSR;  ///< Offset: 0xA0 - USB_EP7CSR
        volatile uint32_t USB_EP7IER;  ///< Offset: 0xA4 - USB_EP7IER
        volatile uint32_t USB_EP7ISR;  ///< Offset: 0xA8 - USB_EP7ISR
        volatile uint32_t USB_EP7TCR;  ///< Offset: 0xAC - USB_EP7TCR
        volatile uint32_t USB_EP7CFGR;  ///< Offset: 0xB0 - USB_EP7CFGR
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t PDMA_BASE = 0x40090000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t PDMA_CH0CR;  ///< Offset: 0x00 - PDMA_CH0CR
        volatile uint32_t PDMA_CH0SADR;  ///< Offset: 0x04 - PDMA_CH0SADR
        volatile uint32_t PDMA_CH0DADR;  ///< Offset: 0x08 - PDMA_CH0DADR
        volatile uint32_t PDMA_CH0CADR;  ///< Offset: 0x0C - PDMA_CH0CADR
        volatile uint32_t PDMA_CH0TSR;  ///< Offset: 0x10 - PDMA_CH0TSR
        volatile uint32_t PDMA_CH0CTSR;  ///< Offset: 0x14 - PDMA_CH0CTSR
        volatile uint32_t PDMA_CH1CR;  ///< Offset: 0x18 - PDMA_CH1CR
        volatile uint32_t PDMA_CH1SADR;  ///< Offset: 0x1C - PDMA_CH1SADR
        volatile uint32_t PDMA_CH1DADR;  ///< Offset: 0x20 - PDMA_CH1DADR
        volatile uint32_t PDMA_CH1CADR;  ///< Offset: 0x24 - PDMA_CH1CADR
        volatile uint32_t PDMA_CH1TSR;  ///< Offset: 0x28 - PDMA_CH1TSR
        volatile uint32_t PDMA_CH1CTSR;  ///< Offset: 0x2C - PDMA_CH1CTSR
        volatile uint32_t PDMA_CH2CR;  ///< Offset: 0x30 - PDMA_CH2CR
        volatile uint32_t PDMA_CH2SADR;  ///< Offset: 0x34 - PDMA_CH2SADR
        volatile uint32_t PDMA_CH2DADR;  ///< Offset: 0x38 - PDMA_CH2DADR
        volatile uint32_t PDMA_CH2CADR;  ///< Offset: 0x3C - PDMA_CH2CADR
        volatile uint32_t PDMA_CH2TSR;  ///< Offset: 0x40 - PDMA_CH2TSR
        volatile uint32_t PDMA_CH2CTSR;  ///< Offset: 0x44 - PDMA_CH2CTSR
        volatile uint32_t PDMA_CH3CR;  ///< Offset: 0x48 - PDMA_CH3CR
        volatile uint32_t PDMA_CH3SADR;  ///< Offset: 0x4C - PDMA_CH3SADR
        volatile uint32_t PDMA_CH3DADR;  ///< Offset: 0x50 - PDMA_CH3DADR
        volatile uint32_t PDMA_CH3CADR;  ///< Offset: 0x54 - PDMA_CH3CADR
        volatile uint32_t PDMA_CH3TSR;  ///< Offset: 0x58 - PDMA_CH3TSR
        volatile uint32_t PDMA_CH3CTSR;  ///< Offset: 0x5C - PDMA_CH3CTSR
        volatile uint32_t PDMA_CH4CR;  ///< Offset: 0x60 - PDMA_CH4CR
        volatile uint32_t PDMA_CH4SADR;  ///< Offset: 0x64 - PDMA_CH4SADR
        volatile uint32_t PDMA_CH4DADR;  ///< Offset: 0x68 - PDMA_CH4DADR
        volatile uint32_t PDMA_CH4CADR;  ///< Offset: 0x6C - PDMA_CH4CADR
        volatile uint32_t PDMA_CH4TSR;  ///< Offset: 0x70 - PDMA_CH4TSR
        volatile uint32_t PDMA_CH4CTSR;  ///< Offset: 0x74 - PDMA_CH4CTSR
        volatile uint32_t PDMA_CH5CR;  ///< Offset: 0x78 - PDMA_CH5CR
        volatile uint32_t PDMA_CH5SADR;  ///< Offset: 0x7C - PDMA_CH5SADR
        volatile uint32_t PDMA_CH5DADR;  ///< Offset: 0x80 - PDMA_CH5DADR
        volatile uint32_t PDMA_CH5CADR;  ///< Offset: 0x84 - PDMA_CH5CADR
        volatile uint32_t PDMA_CH5TSR;  ///< Offset: 0x88 - PDMA_CH5TSR
        volatile uint32_t PDMA_CH5CTSR;  ///< Offset: 0x8C - PDMA_CH5CTSR
        volatile uint32_t PDMA_CH6CR;  ///< Offset: 0x90 - PDMA_CH6CR
        volatile uint32_t PDMA_CH6SADR;  ///< Offset: 0x94 - PDMA_CH6SADR
        volatile uint32_t PDMA_CH6DADR;  ///< Offset: 0x98 - PDMA_CH6DADR
        volatile uint32_t PDMA_CH6CADR;  ///< Offset: 0x9C - PDMA_CH6CADR
        volatile uint32_t PDMA_CH6TSR;  ///< Offset: 0xA0 - PDMA_CH6TSR
        volatile uint32_t PDMA_CH6CTSR;  ///< Offset: 0xA4 - PDMA_CH6CTSR
        volatile uint32_t PDMA_CH7CR;  ///< Offset: 0xA8 - PDMA_CH7CR
        volatile uint32_t PDMA_CH7SADR;  ///< Offset: 0xAC - PDMA_CH7SADR
        volatile uint32_t PDMA_CH7DADR;  ///< Offset: 0xB0 - PDMA_CH7DADR
        volatile uint32_t PDMA_CH7CADR;  ///< Offset: 0xB4 - PDMA_CH7CADR
        volatile uint32_t PDMA_CH7TSR;  ///< Offset: 0xB8 - PDMA_CH7TSR
        volatile uint32_t PDMA_CH7CTSR;  ///< Offset: 0xBC - PDMA_CH7CTSR
        volatile uint32_t PDMA_CH8CR;  ///< Offset: 0xC0 - PDMA_CH8CR
        volatile uint32_t PDMA_CH8SADR;  ///< Offset: 0xC4 - PDMA_CH8SADR
        volatile uint32_t PDMA_CH8DADR;  ///< Offset: 0xC8 - PDMA_CH8DADR
        volatile uint32_t PDMA_CH8CADR;  ///< Offset: 0xCC - PDMA_CH8CADR
        volatile uint32_t PDMA_CH8TSR;  ///< Offset: 0xD0 - PDMA_CH8TSR
        volatile uint32_t PDMA_CH8CTSR;  ///< Offset: 0xD4 - PDMA_CH8CTSR
        volatile uint32_t PDMA_CH9CR;  ///< Offset: 0xD8 - PDMA_CH9CR
        volatile uint32_t PDMA_CH9SADR;  ///< Offset: 0xDC - PDMA_CH9SADR
        volatile uint32_t PDMA_CH9DADR;  ///< Offset: 0xE0 - PDMA_CH9DADR
        volatile uint32_t PDMA_CH9CADR;  ///< Offset: 0xE4 - PDMA_CH9CADR
        volatile uint32_t PDMA_CH9TSR;  ///< Offset: 0xE8 - PDMA_CH9TSR
        volatile uint32_t PDMA_CH9CTSR;  ///< Offset: 0xEC - PDMA_CH9CTSR
        volatile uint32_t PDMA_CH10CR;  ///< Offset: 0xF0 - PDMA_CH10CR
        volatile uint32_t PDMA_CH10SADR;  ///< Offset: 0xF4 - PDMA_CH10SADR
        volatile uint32_t PDMA_CH10DADR;  ///< Offset: 0xF8 - PDMA_CH10DADR
        volatile uint32_t PDMA_CH10CADR;  ///< Offset: 0xFC - PDMA_CH10CADR
        volatile uint32_t PDMA_CH10TSR;  ///< Offset: 0x100 - PDMA_CH10TSR
        volatile uint32_t PDMA_CH10CTSR;  ///< Offset: 0x104 - PDMA_CH10CTSR
        volatile uint32_t PDMA_CH11CR;  ///< Offset: 0x108 - PDMA_CH11CR
        volatile uint32_t PDMA_CH11SADR;  ///< Offset: 0x10C - PDMA_CH11SADR
        volatile uint32_t PDMA_CH11DADR;  ///< Offset: 0x110 - PDMA_CH11DADR
        volatile uint32_t PDMA_CH11CADR;  ///< Offset: 0x114 - PDMA_CH11CADR
        volatile uint32_t PDMA_CH11TSR;  ///< Offset: 0x118 - PDMA_CH11TSR
        volatile uint32_t PDMA_CH11CTSR;  ///< Offset: 0x11C - PDMA_CH11CTSR
        volatile uint32_t PDMA_ISR0;  ///< Offset: 0x120 - PDMA_ISR0
        volatile uint32_t PDMA_ISR1;  ///< Offset: 0x124 - PDMA_ISR1
        volatile uint32_t PDMA_ISCR0;  ///< Offset: 0x128 - PDMA_ISCR0
        volatile uint32_t PDMA_ISCR1;  ///< Offset: 0x12C - PDMA_ISCR1
        volatile uint32_t PDMA_IER0;  ///< Offset: 0x130 - PDMA_IER0
        volatile uint32_t PDMA_IER1;  ///< Offset: 0x134 - PDMA_IER1
    };

    /// Peripheral instances
    inline Registers* PDMA = reinterpret_cast<Registers*>(PDMA_BASE);

}

// ============================================================================
// CSIF Peripheral
// ============================================================================

namespace csif {
    /// Base addresses
    constexpr uint32_t CSIF_BASE = 0x400CC000;

    /// CSIF Register structure
    struct Registers {
        volatile uint32_t CSIF_ENR;  ///< Offset: 0x00 - CSIF_ENR
        volatile uint32_t CSIF_CR;  ///< Offset: 0x04 - CSIF_CR
        volatile uint32_t CSIF_IMGWH;  ///< Offset: 0x08 - CSIF_IMGWH
        volatile uint32_t CSIF_WCR0;  ///< Offset: 0x0C - CSIF_WCR0
        volatile uint32_t CSIF_WCR1;  ///< Offset: 0x10 - CSIF_WCR1
        volatile uint32_t CSIF_SMP;  ///< Offset: 0x14 - CSIF_SMP
        volatile uint32_t CSIF_SMPCOL;  ///< Offset: 0x18 - CSIF_SMPCOL
        volatile uint32_t CSIF_SMPROW;  ///< Offset: 0x1C - CSIF_SMPROW
        volatile uint32_t CSIF_FIFO0;  ///< Offset: 0x20 - CSIF_FIFO0
        volatile uint32_t CSIF_FIFO1;  ///< Offset: 0x24 - CSIF_FIFO1
        volatile uint32_t CSIF_FIFO2;  ///< Offset: 0x28 - CSIF_FIFO2
        volatile uint32_t CSIF_FIFO3;  ///< Offset: 0x2C - CSIF_FIFO3
        volatile uint32_t CSIF_FIFO4;  ///< Offset: 0x30 - CSIF_FIFO4
        volatile uint32_t CSIF_FIFO5;  ///< Offset: 0x34 - CSIF_FIFO5
        volatile uint32_t CSIF_FIFO6;  ///< Offset: 0x38 - CSIF_FIFO6
        volatile uint32_t CSIF_FIFO7;  ///< Offset: 0x3C - CSIF_FIFO7
        volatile uint32_t CSIF_IER;  ///< Offset: 0x40 - CSIF_IER
        volatile uint32_t CSIF_SR;  ///< Offset: 0x44 - CSIF_SR
    };

    /// Peripheral instances
    inline Registers* CSIF = reinterpret_cast<Registers*>(CSIF_BASE);

}


} // namespace alloy::generated::ht32f275x

#endif // ALLOY_GENERATED_HT32F275X_PERIPHERALS_HPP