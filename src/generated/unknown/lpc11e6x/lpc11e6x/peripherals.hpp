/// Auto-generated code for LPC11E6x
/// Generated by Alloy Code Generator
/// Source: nxp_lpc11e6x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:28
#ifndef ALLOY_GENERATED_LPC11E6X_PERIPHERALS_HPP
#define ALLOY_GENERATED_LPC11E6X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::lpc11e6x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 5;
    constexpr bool has_ct16b0 = true;
    constexpr uint32_t num_ct16b0_instances = 1;
    constexpr bool has_ct16b1 = true;
    constexpr uint32_t num_ct16b1_instances = 1;
    constexpr bool has_ct32b0 = true;
    constexpr uint32_t num_ct32b0_instances = 1;
    constexpr bool has_ct32b1 = true;
    constexpr uint32_t num_ct32b1_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_ssp0 = true;
    constexpr uint32_t num_ssp0_instances = 1;
    constexpr bool has_iocon = true;
    constexpr uint32_t num_iocon_instances = 1;
    constexpr bool has_syscon = true;
    constexpr uint32_t num_syscon_instances = 1;
    constexpr bool has_ssp1 = true;
    constexpr uint32_t num_ssp1_instances = 1;
    constexpr bool has_gint0 = true;
    constexpr uint32_t num_gint0_instances = 1;
    constexpr bool has_gint1 = true;
    constexpr uint32_t num_gint1_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_sct0 = true;
    constexpr uint32_t num_sct0_instances = 1;
    constexpr bool has_sct1 = true;
    constexpr uint32_t num_sct1_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_pint = true;
    constexpr uint32_t num_pint_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ct16b0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ct16b1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ct32b0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ct32b1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iocon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct syscon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gint0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gint1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sct0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sct1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pint_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart0 = true;
    constexpr bool has_usart4 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart3 = true;
}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40000000;
    constexpr uint32_t I2C1_BASE = 0x40020000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CONSET;  ///< Offset: 0x00 - I2C Control Set Register. When a one is written to a bit...
        volatile uint32_t STAT;  ///< Offset: 0x04 - I2C Status Register. During I2C operation, this register...
        volatile uint32_t DAT;  ///< Offset: 0x08 - I2C Data Register. During master or slave transmit mode,...
        volatile uint32_t ADR0;  ///< Offset: 0x0C - I2C Slave Address Register 0. Contains the 7-bit slave...
        volatile uint32_t SCLH;  ///< Offset: 0x10 - SCH Duty Cycle Register High Half Word. Determines the...
        volatile uint32_t SCLL;  ///< Offset: 0x14 - SCL Duty Cycle Register Low Half Word. Determines the...
        volatile uint32_t CONCLR;  ///< Offset: 0x18 - I2C Control Clear Register. When a one is written to a...
        volatile uint32_t MMCTRL;  ///< Offset: 0x1C - Monitor mode control register.
        volatile uint32_t ADR%s;  ///< Offset: 0x20 - I2C Slave Address Register. Contains the 7-bit slave...
        volatile uint32_t DATA_BUFFER;  ///< Offset: 0x2C - Data buffer register. The contents of the 8 MSBs of the...
        volatile uint32_t MASK%s;  ///< Offset: 0x30 - I2C Slave address mask register. This mask register is...
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WWDT_BASE = 0x40004000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register contains the basic...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. This 24-bit register...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This 24-bit register...
        volatile uint32_t CLKSEL;  ///< Offset: 0x10 - Watchdog clock select register.
        volatile uint32_t WARNINT;  ///< Offset: 0x14 - Watchdog Warning Interrupt compare value.
        volatile uint32_t WINDOW;  ///< Offset: 0x18 - Watchdog Window compare value.
    };

    /// Peripheral instances
    inline Registers* WWDT = reinterpret_cast<Registers*>(WWDT_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40008000;
    constexpr uint32_t USART4_BASE = 0x4004C000;
    constexpr uint32_t USART1_BASE = 0x4006C000;
    constexpr uint32_t USART2_BASE = 0x40070000;
    constexpr uint32_t USART3_BASE = 0x40074000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t RBR;  ///< Offset: 0x00 - Receiver Buffer Register. Contains the next received...
        volatile uint32_t THR;  ///< Offset: 0x00 - Transmit Holding Register. The next character to be...
        volatile uint32_t DLL;  ///< Offset: 0x00 - Divisor Latch LSB. Least significant byte of the baud...
        volatile uint32_t DLM;  ///< Offset: 0x04 - Divisor Latch MSB. Most significant byte of the baud...
        volatile uint32_t IER;  ///< Offset: 0x04 - Interrupt Enable Register. Contains individual interrupt...
        volatile uint32_t IIR;  ///< Offset: 0x08 - Interrupt ID Register. Identifies which interrupt(s) are pending.
        volatile uint32_t FCR;  ///< Offset: 0x08 - FIFO Control Register. Controls USART FIFO usage and modes.
        volatile uint32_t LCR;  ///< Offset: 0x0C - Line Control Register. Contains controls for frame...
        volatile uint32_t MCR;  ///< Offset: 0x10 - Modem Control Register.
        volatile uint32_t LSR;  ///< Offset: 0x14 - Line Status Register. Contains flags for transmit and...
        volatile uint32_t MSR;  ///< Offset: 0x18 - Modem Status Register.
        volatile uint32_t SCR;  ///< Offset: 0x1C - Scratch Pad Register. Eight-bit temporary storage for software.
        volatile uint32_t ACR;  ///< Offset: 0x20 - Auto-baud Control Register. Contains controls for the...
        volatile uint32_t ICR;  ///< Offset: 0x24 - IrDA Control Register. Enables and configures the IrDA...
        volatile uint32_t FDR;  ///< Offset: 0x28 - Fractional Divider Register. Generates a clock input for...
        volatile uint32_t OSR;  ///< Offset: 0x2C - Oversampling Register. Controls the degree of...
        volatile uint32_t TER;  ///< Offset: 0x30 - Transmit Enable Register. Turns off USART transmitter...
        volatile uint32_t HDEN;  ///< Offset: 0x40 - Half duplex enable register.
        volatile uint32_t SCICTRL;  ///< Offset: 0x48 - Smart Card Interface Control register. Enables and...
        volatile uint32_t RS485CTRL;  ///< Offset: 0x4C - RS-485/EIA-485 Control. Contains controls to configure...
        volatile uint32_t RS485ADRMATCH;  ///< Offset: 0x50 - RS-485/EIA-485 address match. Contains the address match...
        volatile uint32_t RS485DLY;  ///< Offset: 0x54 - RS-485/EIA-485 direction control delay.
        volatile uint32_t SYNCCTRL;  ///< Offset: 0x58 - Synchronous mode control register.
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART4 = reinterpret_cast<Registers*>(USART4_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);

}

// ============================================================================
// CT16B0 Peripheral
// ============================================================================

namespace ct16b0 {
    /// Base addresses
    constexpr uint32_t CT16B0_BASE = 0x4000C000;

    /// CT16B0 Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 16-bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. When the Prescale Counter (below) is...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. The 16-bit PC is a counter which is...
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control if an...
        volatile uint32_t MR%s;  ///< Offset: 0x18 - Match Register. MR can be enabled through the MCR to...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR%s;  ///< Offset: 0x2C - Capture Register. CR is loaded with the value of TC when...
        volatile uint32_t EMR;  ///< Offset: 0x3C - External Match Register. The EMR controls the match...
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
        volatile uint32_t PWMC;  ///< Offset: 0x74 - PWM Control Register. The PWMCON enables PWM mode for...
    };

    /// Peripheral instances
    inline Registers* CT16B0 = reinterpret_cast<Registers*>(CT16B0_BASE);

}

// ============================================================================
// CT16B1 Peripheral
// ============================================================================

namespace ct16b1 {
    /// Base addresses
    constexpr uint32_t CT16B1_BASE = 0x40010000;

    /// CT16B1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CT16B1 = reinterpret_cast<Registers*>(CT16B1_BASE);

}

// ============================================================================
// CT32B0 Peripheral
// ============================================================================

namespace ct32b0 {
    /// Base addresses
    constexpr uint32_t CT32B0_BASE = 0x40014000;

    /// CT32B0 Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32-bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. When the Prescale Counter (below) is...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. The 32-bit PC is a counter which is...
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control if an...
        volatile uint32_t MR%s;  ///< Offset: 0x18 - Match Register. MR can be enabled through the MCR to...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR%s;  ///< Offset: 0x2C - Capture Register. CR is loaded with the value of TC when...
        volatile uint32_t EMR;  ///< Offset: 0x3C - External Match Register. The EMR controls the match...
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
        volatile uint32_t PWMC;  ///< Offset: 0x74 - PWM Control Register. The PWMCON enables PWM mode for...
    };

    /// Peripheral instances
    inline Registers* CT32B0 = reinterpret_cast<Registers*>(CT32B0_BASE);

}

// ============================================================================
// CT32B1 Peripheral
// ============================================================================

namespace ct32b1 {
    /// Base addresses
    constexpr uint32_t CT32B1_BASE = 0x40018000;

    /// CT32B1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CT32B1 = reinterpret_cast<Registers*>(CT32B1_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x4001C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - A/D Control Register. Contains the clock divide value,...
        volatile uint32_t SEQA_CTRL;  ///< Offset: 0x08 - A/D Conversion Sequence-A control Register: Controls...
        volatile uint32_t SEQB_CTRL;  ///< Offset: 0x0C - A/D Conversion Sequence-B Control Register: Controls...
        volatile uint32_t SEQA_GDAT;  ///< Offset: 0x10 - A/D Sequence-A Global Data Register. This register...
        volatile uint32_t SEQB_GDAT;  ///< Offset: 0x14 - A/D Sequence-B Global Data Register. This register...
        volatile uint32_t DAT[%s];  ///< Offset: 0x20 - A/D Channel 0 Data Register. This register contains the...
        volatile uint32_t THR0_LOW;  ///< Offset: 0x50 - A/D Low Compare Threshold Register 0 : Contains the...
        volatile uint32_t THR1_LOW;  ///< Offset: 0x54 - A/D Low Compare Threshold Register 1: Contains the lower...
        volatile uint32_t THR0_HIGH;  ///< Offset: 0x58 - A/D High Compare Threshold Register 0: Contains the...
        volatile uint32_t THR1_HIGH;  ///< Offset: 0x5C - A/D High Compare Threshold Register 1: Contains the...
        volatile uint32_t CHAN_THRSEL;  ///< Offset: 0x60 - A/D Channel-Threshold Select Register. Specifies which...
        volatile uint32_t INTEN;  ///< Offset: 0x64 - A/D Interrupt Enable Register. This register contains...
        volatile uint32_t FLAGS;  ///< Offset: 0x68 - A/D Flags Register. Contains the four interrupt request...
        volatile uint32_t TRM;  ///< Offset: 0x6C - ADC trim register.
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40024000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - RTC control register
        volatile uint32_t MATCH;  ///< Offset: 0x04 - RTC match register
        volatile uint32_t COUNT;  ///< Offset: 0x08 - RTC counter register
        volatile uint32_t WAKE;  ///< Offset: 0x0C - RTC high-resolution/wake-up timer control register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMATRIGMUX_BASE = 0x40028000;
    constexpr uint32_t DMA_BASE = 0x50004000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMA_ITRIG_PINMUX[%s];  ///< Offset: 0x00 - Trigger input select register for DMA channel 0.
    };

    /// Peripheral instances
    inline Registers* DMATRIGMUX = reinterpret_cast<Registers*>(DMATRIGMUX_BASE);
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x40038000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t PCON;  ///< Offset: 0x00 - Power control register
        volatile uint32_t GPREG%s;  ///< Offset: 0x04 - General purpose register 0
        volatile uint32_t GPREG4;  ///< Offset: 0x14 - Deep power down control register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASHCTRL_BASE = 0x4003C000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASHCFG;  ///< Offset: 0x10 - Flash configuration register
        volatile uint32_t FMSSTART;  ///< Offset: 0x20 - Signature start address register
        volatile uint32_t FMSSTOP;  ///< Offset: 0x24 - Signature stop-address register
        volatile uint32_t FMSW0;  ///< Offset: 0x2C - Signature Word
    };

    /// Peripheral instances
    inline Registers* FLASHCTRL = reinterpret_cast<Registers*>(FLASHCTRL_BASE);

}

// ============================================================================
// SSP0 Peripheral
// ============================================================================

namespace ssp0 {
    /// Base addresses
    constexpr uint32_t SSP0_BASE = 0x40040000;

    /// SSP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - Control Register 0. Selects the serial clock rate, bus...
        volatile uint32_t CR1;  ///< Offset: 0x04 - Control Register 1. Selects master/slave and other modes.
        volatile uint32_t DR;  ///< Offset: 0x08 - Data Register. Writes fill the transmit FIFO, and reads...
        volatile uint32_t SR;  ///< Offset: 0x0C - Status Register
        volatile uint32_t CPSR;  ///< Offset: 0x10 - Clock Prescale Register
        volatile uint32_t IMSC;  ///< Offset: 0x14 - Interrupt Mask Set and Clear Register
        volatile uint32_t RIS;  ///< Offset: 0x18 - Raw Interrupt Status Register
        volatile uint32_t MIS;  ///< Offset: 0x1C - Masked Interrupt Status Register
        volatile uint32_t ICR;  ///< Offset: 0x20 - SSPICR Interrupt Clear Register
    };

    /// Peripheral instances
    inline Registers* SSP0 = reinterpret_cast<Registers*>(SSP0_BASE);

}

// ============================================================================
// IOCON Peripheral
// ============================================================================

namespace iocon {
    /// Base addresses
    constexpr uint32_t IOCON_BASE = 0x40044000;

    /// IOCON Register structure
    struct Registers {
        volatile uint32_t PIO0_%s;  ///< Offset: 0x18 - I/O configuration for port PIO0
        volatile uint32_t PIO0_4;  ///< Offset: 0x10 - I/O configuration for open-drain pin PIO0_4
        volatile uint32_t PIO0_5;  ///< Offset: 0x14 - I/O configuration for open-drain pin PIO0_5
        volatile uint32_t PIO1_%s;  ///< Offset: 0x60 - I/O configuration for port PIO1
        volatile uint32_t PIO2_%s;  ///< Offset: 0xFC - I/O configuration for port PIO2
    };

    /// Peripheral instances
    inline Registers* IOCON = reinterpret_cast<Registers*>(IOCON_BASE);

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x40048000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t SYSMEMREMAP;  ///< Offset: 0x00 - System memory remap
        volatile uint32_t PRESETCTRL;  ///< Offset: 0x04 - Peripheral reset control
        volatile uint32_t SYSPLLCTRL;  ///< Offset: 0x08 - System PLL control
        volatile uint32_t SYSPLLSTAT;  ///< Offset: 0x0C - System PLL status
        volatile uint32_t RTCOSCCTRL;  ///< Offset: 0x1C - RTC oscillator 32 kHz output control
        volatile uint32_t SYSOSCCTRL;  ///< Offset: 0x20 - System oscillator control
        volatile uint32_t WDTOSCCTRL;  ///< Offset: 0x24 - Watchdog oscillator control
        volatile uint32_t IRCCTRL;  ///< Offset: 0x28 - IRC control
        volatile uint32_t SYSRSTSTAT;  ///< Offset: 0x30 - System reset status register
        volatile uint32_t SYSPLLCLKSEL;  ///< Offset: 0x40 - System PLL clock source select
        volatile uint32_t SYSPLLCLKUEN;  ///< Offset: 0x44 - System PLL clock source update enable
        volatile uint32_t MAINCLKSEL;  ///< Offset: 0x70 - Main clock source select
        volatile uint32_t MAINCLKUEN;  ///< Offset: 0x74 - Main clock source update enable
        volatile uint32_t SYSAHBCLKDIV;  ///< Offset: 0x78 - System clock divider
        volatile uint32_t SYSAHBCLKCTRL;  ///< Offset: 0x80 - System clock control
        volatile uint32_t SSP0CLKDIV;  ///< Offset: 0x94 - SSP0 clock divider
        volatile uint32_t USART0CLKDIV;  ///< Offset: 0x98 - USART0 clock divider
        volatile uint32_t SSP1CLKDIV;  ///< Offset: 0x9C - SSP1 clock divider
        volatile uint32_t FRGCLKDIV;  ///< Offset: 0xA0 - Clock divider for the common fractional baud rate...
        volatile uint32_t CLKOUTSEL;  ///< Offset: 0xE0 - CLKOUT clock source select
        volatile uint32_t CLKOUTUEN;  ///< Offset: 0xE4 - CLKOUT clock source update enable
        volatile uint32_t CLKOUTDIV;  ///< Offset: 0xE8 - CLKOUT clock divider
        volatile uint32_t UARTFRGDIV;  ///< Offset: 0xF0 - USART fractional generator divider value
        volatile uint32_t UARTFRGMULT;  ///< Offset: 0xF4 - USART fractional generator multiplier value
        volatile uint32_t EXTTRACECMD;  ///< Offset: 0xFC - External trace buffer command register
        volatile uint32_t PIOPORCAP0;  ///< Offset: 0x100 - POR captured PIO status 0
        volatile uint32_t PIOPORCAP1;  ///< Offset: 0x104 - POR captured PIO status 1
        volatile uint32_t PIOPORCAP2;  ///< Offset: 0x108 - POR captured PIO status 1
        volatile uint32_t IOCONCLKDIV6;  ///< Offset: 0x134 - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV5;  ///< Offset: 0x138 - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV4;  ///< Offset: 0x13C - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV3;  ///< Offset: 0x140 - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV2;  ///< Offset: 0x144 - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV1;  ///< Offset: 0x148 - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV0;  ///< Offset: 0x14C - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t BODCTRL;  ///< Offset: 0x150 - Brown-Out Detect
        volatile uint32_t SYSTCKCAL;  ///< Offset: 0x154 - System tick counter calibration
        volatile uint32_t IRQLATENCY;  ///< Offset: 0x170 - IRQ delay. Allows trade-off between interrupt latency...
        volatile uint32_t NMISRC;  ///< Offset: 0x174 - NMI Source Control
        volatile uint32_t PINTSEL%s;  ///< Offset: 0x178 - GPIO Pin Interrupt Select register 0
        volatile uint32_t STARTERP0;  ///< Offset: 0x204 - Start logic 0 interrupt wake-up enable register 0
        volatile uint32_t STARTERP1;  ///< Offset: 0x214 - Start logic 1 interrupt wake-up enable register 1
        volatile uint32_t PDSLEEPCFG;  ///< Offset: 0x230 - Power-down states in deep-sleep mode
        volatile uint32_t PDAWAKECFG;  ///< Offset: 0x234 - Power-down states for wake-up from deep-sleep
        volatile uint32_t PDRUNCFG;  ///< Offset: 0x238 - Power configuration register
        volatile uint32_t DEVICE_ID;  ///< Offset: 0x3F4 - Device ID
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

}

// ============================================================================
// SSP1 Peripheral
// ============================================================================

namespace ssp1 {
    /// Base addresses
    constexpr uint32_t SSP1_BASE = 0x40058000;

    /// SSP1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSP1 = reinterpret_cast<Registers*>(SSP1_BASE);

}

// ============================================================================
// GINT0 Peripheral
// ============================================================================

namespace gint0 {
    /// Base addresses
    constexpr uint32_t GINT0_BASE = 0x4005C000;

    /// GINT0 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - GPIO grouped interrupt control register
        volatile uint32_t PORT_POL[%s];  ///< Offset: 0x20 - GPIO grouped interrupt port 0 polarity register
        volatile uint32_t PORT_ENA[%s];  ///< Offset: 0x40 - GPIO grouped interrupt port enable register
    };

    /// Peripheral instances
    inline Registers* GINT0 = reinterpret_cast<Registers*>(GINT0_BASE);

}

// ============================================================================
// GINT1 Peripheral
// ============================================================================

namespace gint1 {
    /// Base addresses
    constexpr uint32_t GINT1_BASE = 0x40060000;

    /// GINT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GINT1 = reinterpret_cast<Registers*>(GINT1_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x50000000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - CRC mode register
        volatile uint32_t SEED;  ///< Offset: 0x04 - CRC seed register
        volatile uint32_t SUM;  ///< Offset: 0x08 - CRC checksum register
        volatile uint32_t WR_DATA;  ///< Offset: 0x08 - CRC data register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

}

// ============================================================================
// SCT0 Peripheral
// ============================================================================

namespace sct0 {
    /// Base addresses
    constexpr uint32_t SCT0_BASE = 0x5000C000;

    /// SCT0 Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT control register
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt condition register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop condition register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start condition register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x44 - SCT state register
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture registers mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t DMAREQ0;  ///< Offset: 0x5C - SCT DMA request 0 register
        volatile uint32_t DMAREQ1;  ///< Offset: 0x60 - SCT DMA request 1 register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t MATCH%s;  ///< Offset: 0x100 - SCT match value register of match channels 0 to 4;...
        volatile uint32_t CAP%s;  ///< Offset: 0x100 - SCT capture register of capture channel 0 to 4; REGMOD0...
        volatile uint32_t MATCHREL%s;  ///< Offset: 0x200 - SCT match reload value register 0 to 4; REGMOD0 = 0 to...
        volatile uint32_t CAPCTRL%s;  ///< Offset: 0x200 - SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1
        volatile uint32_t EV%s_STATE;  ///< Offset: 0x300 - SCT event state register 0
        volatile uint32_t EV%s_CTRL;  ///< Offset: 0x304 - SCT event control register 0
        volatile uint32_t OUT%s_SET;  ///< Offset: 0x500 - SCT output 0 set register
        volatile uint32_t OUT%s_CLR;  ///< Offset: 0x504 - SCT output 0 clear register
    };

    /// Peripheral instances
    inline Registers* SCT0 = reinterpret_cast<Registers*>(SCT0_BASE);

}

// ============================================================================
// SCT1 Peripheral
// ============================================================================

namespace sct1 {
    /// Base addresses
    constexpr uint32_t SCT1_BASE = 0x5000E000;

    /// SCT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCT1 = reinterpret_cast<Registers*>(SCT1_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_PORT_BASE = 0xA0000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t B[%s];  ///< Offset: 0x00 - Byte pin registers
        volatile uint32_t W[%s];  ///< Offset: 0x1000 - Word pin registers
        volatile uint32_t DIR[%s];  ///< Offset: 0x2000 - Port Direction registers
        volatile uint32_t MASK[%s];  ///< Offset: 0x2080 - Port Mask register
        volatile uint32_t PIN[%s];  ///< Offset: 0x2100 - Port pin register
        volatile uint32_t MPIN[%s];  ///< Offset: 0x2180 - Masked port register
        volatile uint32_t SET[%s];  ///< Offset: 0x2200 - Write: Set port register Read: port output bits
        volatile uint32_t CLR[%s];  ///< Offset: 0x2280 - Clear port
        volatile uint32_t NOT[%s];  ///< Offset: 0x2300 - Toggle port
    };

    /// Peripheral instances
    inline Registers* GPIO_PORT = reinterpret_cast<Registers*>(GPIO_PORT_BASE);

}

// ============================================================================
// PINT Peripheral
// ============================================================================

namespace pint {
    /// Base addresses
    constexpr uint32_t PINT_BASE = 0xA0004000;

    /// PINT Register structure
    struct Registers {
        volatile uint32_t ISEL;  ///< Offset: 0x00 - Pin Interrupt Mode register
        volatile uint32_t IENR;  ///< Offset: 0x04 - Pin interrupt level or rising edge interrupt enable register
        volatile uint32_t SIENR;  ///< Offset: 0x08 - Pin interrupt level or rising edge interrupt set register
        volatile uint32_t CIENR;  ///< Offset: 0x0C - Pin interrupt level (rising edge interrupt) clear register
        volatile uint32_t IENF;  ///< Offset: 0x10 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t SIENF;  ///< Offset: 0x14 - Pin interrupt active level or falling edge interrupt set register
        volatile uint32_t CIENF;  ///< Offset: 0x18 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t RISE;  ///< Offset: 0x1C - Pin interrupt rising edge register
        volatile uint32_t FALL;  ///< Offset: 0x20 - Pin interrupt falling edge register
        volatile uint32_t IST;  ///< Offset: 0x24 - Pin interrupt status register
        volatile uint32_t PMCTRL;  ///< Offset: 0x28 - Pattern match interrupt control register
        volatile uint32_t PMSRC;  ///< Offset: 0x2C - Pattern match interrupt bit-slice source register
        volatile uint32_t PMCFG;  ///< Offset: 0x30 - Pattern match interrupt bit slice configuration register
    };

    /// Peripheral instances
    inline Registers* PINT = reinterpret_cast<Registers*>(PINT_BASE);

}


} // namespace alloy::generated::lpc11e6x

#endif // ALLOY_GENERATED_LPC11E6X_PERIPHERALS_HPP