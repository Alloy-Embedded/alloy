/// Auto-generated code for LPC15xx
/// Generated by Alloy Code Generator
/// Source: nxp_lpc15xx.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:48
#ifndef ALLOY_GENERATED_LPC15XX_PERIPHERALS_HPP
#define ALLOY_GENERATED_LPC15XX_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::lpc15xx {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_sct0 = true;
    constexpr uint32_t num_sct0_instances = 1;
    constexpr bool has_sct1 = true;
    constexpr uint32_t num_sct1_instances = 1;
    constexpr bool has_sct2 = true;
    constexpr uint32_t num_sct2_instances = 1;
    constexpr bool has_sct3 = true;
    constexpr uint32_t num_sct3_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_acmp = true;
    constexpr uint32_t num_acmp_instances = 1;
    constexpr bool has_inmux = true;
    constexpr uint32_t num_inmux_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_swm = true;
    constexpr uint32_t num_swm_instances = 1;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 1;
    constexpr bool has_qei = true;
    constexpr uint32_t num_qei_instances = 1;
    constexpr bool has_syscon = true;
    constexpr uint32_t num_syscon_instances = 1;
    constexpr bool has_mrt = true;
    constexpr uint32_t num_mrt_instances = 1;
    constexpr bool has_pint = true;
    constexpr uint32_t num_pint_instances = 1;
    constexpr bool has_gint0 = true;
    constexpr uint32_t num_gint0_instances = 1;
    constexpr bool has_gint1 = true;
    constexpr uint32_t num_gint1_instances = 1;
    constexpr bool has_rit = true;
    constexpr uint32_t num_rit_instances = 1;
    constexpr bool has_sctipu = true;
    constexpr uint32_t num_sctipu_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_iocon = true;
    constexpr uint32_t num_iocon_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sct0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sct1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sct2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sct3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct acmp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct inmux_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct qei_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct syscon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mrt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pint_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gint0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gint1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rit_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sctipu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iocon_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart0 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_PORT_BASE = 0x1C000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t B[%s];  ///< Offset: 0x00 - Byte pin registers
        volatile uint32_t W[%s];  ///< Offset: 0x1000 - Word pin registers
        volatile uint32_t DIR[%s];  ///< Offset: 0x2000 - Port Direction registers
        volatile uint32_t MASK[%s];  ///< Offset: 0x2080 - Port Mask register
        volatile uint32_t PIN[%s];  ///< Offset: 0x2100 - Port pin register
        volatile uint32_t MPIN[%s];  ///< Offset: 0x2180 - Masked port register
        volatile uint32_t SET[%s];  ///< Offset: 0x2200 - Write: Set port register Read: port output bits
        volatile uint32_t CLR[%s];  ///< Offset: 0x2280 - Clear port
        volatile uint32_t NOT[%s];  ///< Offset: 0x2300 - Toggle port
    };

    /// Peripheral instances
    inline Registers* GPIO_PORT = reinterpret_cast<Registers*>(GPIO_PORT_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x1C004000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - DMA control.
        volatile uint32_t INTSTAT;  ///< Offset: 0x04 - Interrupt status.
        volatile uint32_t SRAMBASE;  ///< Offset: 0x08 - SRAM address of the channel configuration table.
        volatile uint32_t ENABLESET0;  ///< Offset: 0x20 - Channel Enable read and Set for all DMA channels.
        volatile uint32_t ENABLECLR0;  ///< Offset: 0x28 - Channel Enable Clear for all DMA channels.
        volatile uint32_t ACTIVE0;  ///< Offset: 0x30 - Channel Active status for all DMA channels.
        volatile uint32_t BUSY0;  ///< Offset: 0x38 - Channel Busy status for all DMA channels.
        volatile uint32_t ERRINT0;  ///< Offset: 0x40 - Error Interrupt status for all DMA channels.
        volatile uint32_t INTENSET0;  ///< Offset: 0x48 - Interrupt Enable read and Set for all DMA channels.
        volatile uint32_t INTENCLR0;  ///< Offset: 0x50 - Interrupt Enable Clear for all DMA channels.
        volatile uint32_t INTA0;  ///< Offset: 0x58 - Interrupt A status for all DMA channels.
        volatile uint32_t INTB0;  ///< Offset: 0x60 - Interrupt B status for all DMA channels.
        volatile uint32_t SETVALID0;  ///< Offset: 0x68 - Set ValidPending control bits for all DMA channels.
        volatile uint32_t SETTRIG0;  ///< Offset: 0x70 - Set Trigger control bits for all DMA channels.
        volatile uint32_t ABORT0;  ///< Offset: 0x78 - Channel Abort control for all DMA channels.
        volatile uint32_t CFG%s;  ///< Offset: 0x400 - Configuration register for DMA channel 0.
        volatile uint32_t CTLSTAT%s;  ///< Offset: 0x404 - Control and status register for DMA channel 0.
        volatile uint32_t XFERCFG%s;  ///< Offset: 0x408 - Transfer configuration register for DMA channel 0.
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x1C00C000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t DEVCMDSTAT;  ///< Offset: 0x00 - USB Device Command/Status register
        volatile uint32_t INFO;  ///< Offset: 0x04 - USB Info register
        volatile uint32_t EPLISTSTART;  ///< Offset: 0x08 - USB EP Command/Status List start address
        volatile uint32_t DATABUFSTART;  ///< Offset: 0x0C - USB Data buffer start address
        volatile uint32_t LPM;  ///< Offset: 0x10 - Link Power Management register
        volatile uint32_t EPSKIP;  ///< Offset: 0x14 - USB Endpoint skip
        volatile uint32_t EPINUSE;  ///< Offset: 0x18 - USB Endpoint Buffer in use
        volatile uint32_t EPBUFCFG;  ///< Offset: 0x1C - USB Endpoint Buffer Configuration register
        volatile uint32_t INTSTAT;  ///< Offset: 0x20 - USB interrupt status register
        volatile uint32_t INTEN;  ///< Offset: 0x24 - USB interrupt enable register
        volatile uint32_t INTSETSTAT;  ///< Offset: 0x28 - USB set interrupt status register
        volatile uint32_t INTROUTING;  ///< Offset: 0x2C - USB interrupt routing register
        volatile uint32_t EPTOGGLE;  ///< Offset: 0x34 - USB Endpoint toggle register
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x1C010000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - CRC mode register
        volatile uint32_t SEED;  ///< Offset: 0x04 - CRC seed register
        volatile uint32_t SUM;  ///< Offset: 0x08 - CRC checksum register
        volatile uint32_t WR_DATA;  ///< Offset: 0x08 - CRC data register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

}

// ============================================================================
// SCT0 Peripheral
// ============================================================================

namespace sct0 {
    /// Base addresses
    constexpr uint32_t SCT0_BASE = 0x1C018000;

    /// SCT0 Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT control register
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt condition register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop condition register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start condition register
        volatile uint32_t DITHER;  ///< Offset: 0x18 - SCT dither condition register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x44 - SCT state register
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture registers mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t DMAREQ0;  ///< Offset: 0x5C - SCT DMA request 0 register
        volatile uint32_t DMAREQ1;  ///< Offset: 0x60 - SCT DMA request 1 register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t MATCH%s;  ///< Offset: 0x100 - SCT match value register of match channels 0 to 15;...
        volatile uint32_t FRACMAT%s;  ///< Offset: 0x140 - Fractional match registers 0 to 5 for SCT match value...
        volatile uint32_t CAP%s;  ///< Offset: 0x100 - SCT capture register of capture channel 0 to 15; REGMOD0...
        volatile uint32_t MATCHREL%s;  ///< Offset: 0x200 - SCT match reload value register 0 to 15; REGMOD0 = 0 to...
        volatile uint32_t FRACMATREL%s;  ///< Offset: 0x240 - Fractional match reload registers 0 to 5 for SCT match...
        volatile uint32_t CAPCTRL%s;  ///< Offset: 0x200 - SCT capture control register 0 to 15; REGMOD0 = 1 to...
        volatile uint32_t EV%s_STATE;  ///< Offset: 0x300 - SCT event state register 0
        volatile uint32_t EV%s_CTRL;  ///< Offset: 0x304 - SCT event control register 0
        volatile uint32_t OUT%s_SET;  ///< Offset: 0x500 - SCT output 0 set register
        volatile uint32_t OUT%s_CLR;  ///< Offset: 0x504 - SCT output 0 clear register
    };

    /// Peripheral instances
    inline Registers* SCT0 = reinterpret_cast<Registers*>(SCT0_BASE);

}

// ============================================================================
// SCT1 Peripheral
// ============================================================================

namespace sct1 {
    /// Base addresses
    constexpr uint32_t SCT1_BASE = 0x1C01C000;

    /// SCT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCT1 = reinterpret_cast<Registers*>(SCT1_BASE);

}

// ============================================================================
// SCT2 Peripheral
// ============================================================================

namespace sct2 {
    /// Base addresses
    constexpr uint32_t SCT2_BASE = 0x1C020000;

    /// SCT2 Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT control register
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt condition register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop condition register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start condition register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x44 - SCT state register
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture registers mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t DMAREQ0;  ///< Offset: 0x5C - SCT DMA request 0 register
        volatile uint32_t DMAREQ1;  ///< Offset: 0x60 - SCT DMA request 1 register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t MATCH%s;  ///< Offset: 0x100 - SCT match value register of match channels 0 to 7;...
        volatile uint32_t CAP%s;  ///< Offset: 0x100 - SCT capture register of capture channel 0 to 7; REGMOD0...
        volatile uint32_t MATCHREL%s;  ///< Offset: 0x200 - SCT match reload value register 0 to 7; REGMOD0 = 0 to...
        volatile uint32_t CAPCTRL%s;  ///< Offset: 0x200 - SCT capture control register 0 to 7; REGMOD0 = 1 to REGMODE7 = 1
        volatile uint32_t EV%s_STATE;  ///< Offset: 0x300 - SCT event state register 0
        volatile uint32_t EV%s_CTRL;  ///< Offset: 0x304 - SCT event control register 0
        volatile uint32_t OUT%s_SET;  ///< Offset: 0x500 - SCT output 0 set register
        volatile uint32_t OUT%s_CLR;  ///< Offset: 0x504 - SCT output 0 clear register
    };

    /// Peripheral instances
    inline Registers* SCT2 = reinterpret_cast<Registers*>(SCT2_BASE);

}

// ============================================================================
// SCT3 Peripheral
// ============================================================================

namespace sct3 {
    /// Base addresses
    constexpr uint32_t SCT3_BASE = 0x1C024000;

    /// SCT3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCT3 = reinterpret_cast<Registers*>(SCT3_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x40000000;
    constexpr uint32_t ADC1_BASE = 0x40080000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - A/D Control Register. Contains the clock divide value,...
        volatile uint32_t INSEL;  ///< Offset: 0x04 - A/D Input Select Register: Selects between external pin...
        volatile uint32_t SEQA_CTRL;  ///< Offset: 0x08 - A/D Conversion Sequence-A control Register: Controls...
        volatile uint32_t SEQB_CTRL;  ///< Offset: 0x0C - A/D Conversion Sequence-B Control Register: Controls...
        volatile uint32_t SEQA_GDAT;  ///< Offset: 0x10 - A/D Sequence-A Global Data Register. This register...
        volatile uint32_t SEQB_GDAT;  ///< Offset: 0x14 - A/D Sequence-B Global Data Register. This register...
        volatile uint32_t DAT[%s];  ///< Offset: 0x20 - A/D Channel 0 Data Register. This register contains the...
        volatile uint32_t THR0_LOW;  ///< Offset: 0x50 - A/D Low Compare Threshold Register 0 : Contains the...
        volatile uint32_t THR1_LOW;  ///< Offset: 0x54 - A/D Low Compare Threshold Register 1: Contains the lower...
        volatile uint32_t THR0_HIGH;  ///< Offset: 0x58 - A/D High Compare Threshold Register 0: Contains the...
        volatile uint32_t THR1_HIGH;  ///< Offset: 0x5C - A/D High Compare Threshold Register 1: Contains the...
        volatile uint32_t CHAN_THRSEL;  ///< Offset: 0x60 - A/D Channel-Threshold Select Register. Specifies which...
        volatile uint32_t INTEN;  ///< Offset: 0x64 - A/D Interrupt Enable Register. This register contains...
        volatile uint32_t FLAGS;  ///< Offset: 0x68 - A/D Flags Register. Contains the four interrupt request...
        volatile uint32_t TRM;  ///< Offset: 0x6C - ADC trim register.
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40004000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t VAL;  ///< Offset: 0x00 - D/A Converter Value Register. This register contains the...
        volatile uint32_t CTRL;  ///< Offset: 0x04 - DAC Control register. This register contains bits to...
        volatile uint32_t CNTVAL;  ///< Offset: 0x08 - DAC Counter Value register. This register contains the...
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

}

// ============================================================================
// ACMP Peripheral
// ============================================================================

namespace acmp {
    /// Base addresses
    constexpr uint32_t ACMP_BASE = 0x40008000;

    /// ACMP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Comparator block control register
        volatile uint32_t CMP0;  ///< Offset: 0x04 - Comparator 0 source control
        volatile uint32_t CMP1;  ///< Offset: 0x0C - Comparator 1 source control
        volatile uint32_t CMP2;  ///< Offset: 0x14 - Comparator 2 source control
        volatile uint32_t CMP3;  ///< Offset: 0x1C - Comparator 3 source control
        volatile uint32_t CMPFILTR%s;  ///< Offset: 0x08 - Comparator 0 pin filter set-up
    };

    /// Peripheral instances
    inline Registers* ACMP = reinterpret_cast<Registers*>(ACMP_BASE);

}

// ============================================================================
// INMUX Peripheral
// ============================================================================

namespace inmux {
    /// Base addresses
    constexpr uint32_t INMUX_BASE = 0x40014000;

    /// INMUX Register structure
    struct Registers {
        volatile uint32_t SCT0_INMUX[%s];  ///< Offset: 0x00 - Pinmux register for SCT0 input 0
        volatile uint32_t SCT1_INMUX[%s];  ///< Offset: 0x20 - Pinmux register for SCT1 input 0
        volatile uint32_t SCT2_INMUX[%s];  ///< Offset: 0x40 - Pinmux register for SCT2 input 0
        volatile uint32_t SCT3_INMUX[%s];  ///< Offset: 0x60 - Pinmux register for SCT3 input 0
        volatile uint32_t PINTSEL[%s];  ///< Offset: 0xC0 - Pin interrupt select register 0
        volatile uint32_t DMA_ITRIG_INMUX[%s];  ///< Offset: 0xE0 - Trigger input for DMA channel 0 select register.
        volatile uint32_t DMA_INMUX_INMUX[%s];  ///< Offset: 0x140 - DMA trigger input select register.
        volatile uint32_t FREQMEAS_REF;  ///< Offset: 0x160 - Clock selection for frequency measurement function...
        volatile uint32_t FREQMEAS_TARGET;  ///< Offset: 0x164 - Clock selection for frequency measurement function target clock
    };

    /// Peripheral instances
    inline Registers* INMUX = reinterpret_cast<Registers*>(INMUX_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40028000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - RTC control register
        volatile uint32_t MATCH;  ///< Offset: 0x04 - RTC match register
        volatile uint32_t COUNT;  ///< Offset: 0x08 - RTC counter register
        volatile uint32_t WAKE;  ///< Offset: 0x0C - RTC high-resolution/wake-up timer control register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WWDT_BASE = 0x4002C000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register contains the basic...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. This 24-bit register...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This 24-bit register...
        volatile uint32_t WARNINT;  ///< Offset: 0x14 - Watchdog Warning Interrupt compare value.
        volatile uint32_t WINDOW;  ///< Offset: 0x18 - Watchdog Window compare value.
    };

    /// Peripheral instances
    inline Registers* WWDT = reinterpret_cast<Registers*>(WWDT_BASE);

}

// ============================================================================
// SWM Peripheral
// ============================================================================

namespace swm {
    /// Base addresses
    constexpr uint32_t SWM_BASE = 0x40038000;

    /// SWM Register structure
    struct Registers {
        volatile uint32_t PINASSIGN0;  ///< Offset: 0x00 - Pin assign register 0. Assign movable functions U0_TXD,...
        volatile uint32_t PINASSIGN1;  ///< Offset: 0x04 - Pin assign register 1. Assign movable functions U0_SCLK,...
        volatile uint32_t PINASSIGN2;  ///< Offset: 0x08 - Pin assign register 2. Assign movable functions U1_CTS,...
        volatile uint32_t PINASSIGN3;  ///< Offset: 0x0C - Pin assign register 3. Assign movable function .
        volatile uint32_t PINASSIGN4;  ///< Offset: 0x10 - Pin assign register 4. Assign movable functions
        volatile uint32_t PINASSIGN5;  ///< Offset: 0x14 - Pin assign register 5. Assign movable functions
        volatile uint32_t PINASSIGN6;  ///< Offset: 0x18 - Pin assign register 6. Assign movable functions
        volatile uint32_t PINASSIGN7;  ///< Offset: 0x1C - Pin assign register 7. Assign movable functions
        volatile uint32_t PINASSIGN8;  ///< Offset: 0x20 - Pin assign register 8. Assign movable functions
        volatile uint32_t PINASSIGN9;  ///< Offset: 0x24 - Pin assign register 9. Assign movable functions
        volatile uint32_t PINASSIGN10;  ///< Offset: 0x28 - Pin assign register 10. Assign movable functions
        volatile uint32_t PINASSIGN11;  ///< Offset: 0x2C - Pin assign register 11. Assign movable functions
        volatile uint32_t PINASSIGN12;  ///< Offset: 0x30 - Pin assign register 12. Assign movable functions
        volatile uint32_t PINASSIGN13;  ///< Offset: 0x34 - Pin assign register 13. Assign movable functions
        volatile uint32_t PINASSIGN14;  ///< Offset: 0x38 - Pin assign register 14. Assign movable functions
        volatile uint32_t PINASSIGN15;  ///< Offset: 0x3C - Pin assign register 15. Assign movable functions
        volatile uint32_t PINENABLE0;  ///< Offset: 0x1C0 - Pin enable register 0. Enables fixed-pin functions
        volatile uint32_t PINENABLE1;  ///< Offset: 0x1C4 - Pin enable register 0. Enables fixed-pin functions
    };

    /// Peripheral instances
    inline Registers* SWM = reinterpret_cast<Registers*>(SWM_BASE);

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x4003C000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t PCON;  ///< Offset: 0x00 - Power control register
        volatile uint32_t GPREG%s;  ///< Offset: 0x04 - General purpose register 0
        volatile uint32_t DPDCTRL;  ///< Offset: 0x14 - Deep power-down control register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40040000;
    constexpr uint32_t USART1_BASE = 0x40044000;
    constexpr uint32_t USART2_BASE = 0x400C0000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - USART Configuration register. Basic USART configuration...
        volatile uint32_t CTL;  ///< Offset: 0x04 - USART Control register. USART control settings that are...
        volatile uint32_t STAT;  ///< Offset: 0x08 - USART Status register. The complete status value can be...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - Interrupt Enable read and Set register. Contains an...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - Interrupt Enable Clear register. Allows clearing any...
        volatile uint32_t RXDAT;  ///< Offset: 0x14 - Receiver Data register. Contains the last character received.
        volatile uint32_t RXDATSTAT;  ///< Offset: 0x18 - Receiver Data with Status register. Combines the last...
        volatile uint32_t TXDAT;  ///< Offset: 0x1C - Transmit Data register. Data to be transmitted is written here.
        volatile uint32_t BRG;  ///< Offset: 0x20 - Baud Rate Generator register. 16-bit integer baud rate...
        volatile uint32_t INTSTAT;  ///< Offset: 0x24 - Interrupt status register. Reflects interrupts that are...
        volatile uint32_t OSR;  ///< Offset: 0x28 - Oversample selection register for asynchronous communication.
        volatile uint32_t ADDR;  ///< Offset: 0x2C - Address register for automatic address matching.
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40048000;
    constexpr uint32_t SPI1_BASE = 0x4004C000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - SPI Configuration register
        volatile uint32_t DLY;  ///< Offset: 0x04 - SPI Delay register
        volatile uint32_t STAT;  ///< Offset: 0x08 - SPI Status. Some status flags can be cleared by writing...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - SPI Interrupt Enable read and Set. A complete value may...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - SPI Interrupt Enable Clear. Writing a 1 to any...
        volatile uint32_t RXDAT;  ///< Offset: 0x14 - SPI Receive Data
        volatile uint32_t TXDATCTL;  ///< Offset: 0x18 - SPI Transmit Data with Control
        volatile uint32_t TXDAT;  ///< Offset: 0x1C - SPI Transmit Data with Control
        volatile uint32_t TXCTL;  ///< Offset: 0x20 - SPI Transmit Control
        volatile uint32_t DIV;  ///< Offset: 0x24 - SPI clock Divider
        volatile uint32_t INTSTAT;  ///< Offset: 0x28 - SPI Interrupt Status
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40050000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - Configuration for shared functions.
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register for Master, Slave, and Monitor functions.
        volatile uint32_t INTENSET;  ///< Offset: 0x08 - Interrupt Enable Set and read register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear register.
        volatile uint32_t TIMEOUT;  ///< Offset: 0x10 - Time-out value register.
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock pre-divider for the entire I2C block. This...
        volatile uint32_t INTSTAT;  ///< Offset: 0x18 - Interrupt Status register for Master, Slave, and Monitor...
        volatile uint32_t MSTCTL;  ///< Offset: 0x20 - Master control register.
        volatile uint32_t MSTTIME;  ///< Offset: 0x24 - Master timing configuration.
        volatile uint32_t MSTDAT;  ///< Offset: 0x28 - Combined Master receiver and transmitter data register.
        volatile uint32_t SLVCTL;  ///< Offset: 0x40 - Slave control register.
        volatile uint32_t SLVDAT;  ///< Offset: 0x44 - Combined Slave receiver and transmitter data register.
        volatile uint32_t SLVADR%s;  ///< Offset: 0x48 - Slave address 0.
        volatile uint32_t SLVQUAL0;  ///< Offset: 0x58 - Slave Qualification for address 0.
        volatile uint32_t MONRXDAT;  ///< Offset: 0x80 - Monitor receiver data register.
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);

}

// ============================================================================
// QEI Peripheral
// ============================================================================

namespace qei {
    /// Base addresses
    constexpr uint32_t QEI_BASE = 0x40058000;

    /// QEI Register structure
    struct Registers {
        volatile uint32_t CON;  ///< Offset: 0x00 - Control register
        volatile uint32_t STAT;  ///< Offset: 0x04 - Encoder status register
        volatile uint32_t CONF;  ///< Offset: 0x08 - Configuration register
        volatile uint32_t POS;  ///< Offset: 0x0C - Position register
        volatile uint32_t MAXPOS;  ///< Offset: 0x10 - Maximum position register
        volatile uint32_t CMPOS0;  ///< Offset: 0x14 - position compare register 0
        volatile uint32_t CMPOS1;  ///< Offset: 0x18 - position compare register 1
        volatile uint32_t CMPOS2;  ///< Offset: 0x1C - position compare register 2
        volatile uint32_t INXCNT;  ///< Offset: 0x20 - Index count register
        volatile uint32_t INXCMP0;  ///< Offset: 0x24 - Index compare register 0
        volatile uint32_t LOAD;  ///< Offset: 0x28 - Velocity timer reload register
        volatile uint32_t TIME;  ///< Offset: 0x2C - Velocity timer register
        volatile uint32_t VEL;  ///< Offset: 0x30 - Velocity counter register
        volatile uint32_t CAP;  ///< Offset: 0x34 - Velocity capture register
        volatile uint32_t VELCOMP;  ///< Offset: 0x38 - Velocity compare register
        volatile uint32_t FILTERPHA;  ///< Offset: 0x3C - Digital filter register on input phase A (QEI_A)
        volatile uint32_t FILTERPHB;  ///< Offset: 0x40 - Digital filter register on input phase B (QEI_B)
        volatile uint32_t FILTERINX;  ///< Offset: 0x44 - Digital filter register on input index (QEI_IDX)
        volatile uint32_t WINDOW;  ///< Offset: 0x48 - Index acceptance window register
        volatile uint32_t INXCMP1;  ///< Offset: 0x4C - Index compare register 1
        volatile uint32_t INXCMP2;  ///< Offset: 0x50 - Index compare register 2
        volatile uint32_t IEC;  ///< Offset: 0xFD8 - Interrupt enable clear register
        volatile uint32_t IES;  ///< Offset: 0xFDC - Interrupt enable set register
        volatile uint32_t INTSTAT;  ///< Offset: 0xFE0 - Interrupt status register
        volatile uint32_t IE;  ///< Offset: 0xFE4 - Interrupt enable clear register
        volatile uint32_t CLR;  ///< Offset: 0xFE8 - Interrupt status clear register
        volatile uint32_t SET;  ///< Offset: 0xFEC - Interrupt status set register
    };

    /// Peripheral instances
    inline Registers* QEI = reinterpret_cast<Registers*>(QEI_BASE);

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x40074000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t SYSMEMREMAP;  ///< Offset: 0x00 - System memory remap
        volatile uint32_t SYSTCKCAL;  ///< Offset: 0x14 - System tick counter calibration
        volatile uint32_t NMISRC;  ///< Offset: 0x1C - NMI Source Control
        volatile uint32_t SYSRSTSTAT;  ///< Offset: 0x40 - System reset status register
        volatile uint32_t PRESETCTRL0;  ///< Offset: 0x44 - Peripheral reset control 0
        volatile uint32_t PRESETCTRL1;  ///< Offset: 0x48 - Peripheral reset control 1
        volatile uint32_t PIOPORCAP0;  ///< Offset: 0x4C - POR captured PIO status 0
        volatile uint32_t PIOPORCAP1;  ///< Offset: 0x50 - POR captured PIO status 1
        volatile uint32_t PIOPORCAP2;  ///< Offset: 0x54 - POR captured PIO status 2
        volatile uint32_t MAINCLKSELA;  ///< Offset: 0x80 - Main clock source select A
        volatile uint32_t MAINCLKSELB;  ///< Offset: 0x84 - Main clock source select B
        volatile uint32_t USBCLKSEL;  ///< Offset: 0x88 - USB clock source select
        volatile uint32_t ADCASYNCCLKSEL;  ///< Offset: 0x8C - ADC asynchronous clock source select
        volatile uint32_t CLKOUTSELA;  ///< Offset: 0x94 - CLKOUT clock source select A
        volatile uint32_t CLKOUTSELB;  ///< Offset: 0x98 - CLKOUT clock source select B
        volatile uint32_t SYSPLLCLKSEL;  ///< Offset: 0xA0 - System PLL clock source select
        volatile uint32_t USBPLLCLKSEL;  ///< Offset: 0xA4 - USB PLL clock source select
        volatile uint32_t SCTPLLCLKSEL;  ///< Offset: 0xA8 - SCT PLL clock source select
        volatile uint32_t SYSAHBCLKDIV;  ///< Offset: 0xC0 - System clock divider
        volatile uint32_t SYSAHBCLKCTRL0;  ///< Offset: 0xC4 - System clock control 0
        volatile uint32_t SYSAHBCLKCTRL1;  ///< Offset: 0xC8 - System clock control 1
        volatile uint32_t SYSTICKCLKDIV;  ///< Offset: 0xCC - SYSTICK clock divider
        volatile uint32_t UARTCLKDIV;  ///< Offset: 0xD0 - USART clock divider. Clock divider for the USART...
        volatile uint32_t IOCONCLKDIV;  ///< Offset: 0xD4 - Peripheral clock to the IOCON block for programmable...
        volatile uint32_t TRACECLKDIV;  ///< Offset: 0xD8 - ARM trace clock divider
        volatile uint32_t USBCLKDIV;  ///< Offset: 0xEC - USB clock divider
        volatile uint32_t ADCASYNCCLKDIV;  ///< Offset: 0xF0 - Asynchronous ADC clock divider
        volatile uint32_t CLKOUTDIV;  ///< Offset: 0xF8 - CLKOUT clock divider
        volatile uint32_t FRGCTRL;  ///< Offset: 0x128 - USART fractional baud rate generator control
        volatile uint32_t USBCLKCTRL;  ///< Offset: 0x12C - USB clock control
        volatile uint32_t USBCLKST;  ///< Offset: 0x130 - USB clock status
        volatile uint32_t BODCTRL;  ///< Offset: 0x180 - Brown-Out Detect
        volatile uint32_t SYSOSCCTRL;  ///< Offset: 0x188 - System oscillator control
        volatile uint32_t RTCOSCCTRL;  ///< Offset: 0x190 - RTC oscillator control
        volatile uint32_t SYSPLLCTRL;  ///< Offset: 0x198 - System PLL control
        volatile uint32_t SYSPLLSTAT;  ///< Offset: 0x19C - System PLL status
        volatile uint32_t USBPLLCTRL;  ///< Offset: 0x1A0 - USB PLL control
        volatile uint32_t USBPLLSTAT;  ///< Offset: 0x1A4 - USB PLL status
        volatile uint32_t SCTPLLCTRL;  ///< Offset: 0x1A8 - SCT PLL control
        volatile uint32_t SCTPLLSTAT;  ///< Offset: 0x1AC - SCT PLL status
        volatile uint32_t PDAWAKECFG;  ///< Offset: 0x204 - Power-down states for wake-up from deep-sleep
        volatile uint32_t PDRUNCFG;  ///< Offset: 0x208 - Power configuration register
        volatile uint32_t STARTERP0;  ///< Offset: 0x218 - Start logic 0 wake-up enable register
        volatile uint32_t STARTERP1;  ///< Offset: 0x21C - Start logic 1 wake-up enable register
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

}

// ============================================================================
// MRT Peripheral
// ============================================================================

namespace mrt {
    /// Base addresses
    constexpr uint32_t MRT_BASE = 0x400A0000;

    /// MRT Register structure
    struct Registers {
        volatile uint32_t INTVAL%s;  ///< Offset: 0x00 - MRT0 Time interval value register. This value is loaded...
        volatile uint32_t TIMER%s;  ///< Offset: 0x04 - MRT0 Timer register. This register reads the value of...
        volatile uint32_t CTRL%s;  ///< Offset: 0x08 - MRT0 Control register. This register controls the MRT0 modes.
        volatile uint32_t STAT%s;  ///< Offset: 0x0C - MRT0 Status register.
        volatile uint32_t IDLE_CH;  ///< Offset: 0xF4 - Idle channel register. This register returns the number...
        volatile uint32_t IRQ_FLAG;  ///< Offset: 0xF8 - Global interrupt flag register
    };

    /// Peripheral instances
    inline Registers* MRT = reinterpret_cast<Registers*>(MRT_BASE);

}

// ============================================================================
// PINT Peripheral
// ============================================================================

namespace pint {
    /// Base addresses
    constexpr uint32_t PINT_BASE = 0x400A4000;

    /// PINT Register structure
    struct Registers {
        volatile uint32_t ISEL;  ///< Offset: 0x00 - Pin Interrupt Mode register
        volatile uint32_t IENR;  ///< Offset: 0x04 - Pin interrupt level or rising edge interrupt enable register
        volatile uint32_t SIENR;  ///< Offset: 0x08 - Pin interrupt level or rising edge interrupt set register
        volatile uint32_t CIENR;  ///< Offset: 0x0C - Pin interrupt level (rising edge interrupt) clear register
        volatile uint32_t IENF;  ///< Offset: 0x10 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t SIENF;  ///< Offset: 0x14 - Pin interrupt active level or falling edge interrupt set register
        volatile uint32_t CIENF;  ///< Offset: 0x18 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t RISE;  ///< Offset: 0x1C - Pin interrupt rising edge register
        volatile uint32_t FALL;  ///< Offset: 0x20 - Pin interrupt falling edge register
        volatile uint32_t IST;  ///< Offset: 0x24 - Pin interrupt status register
        volatile uint32_t PMCTRL;  ///< Offset: 0x28 - Pattern match interrupt control register
        volatile uint32_t PMSRC;  ///< Offset: 0x2C - Pattern match interrupt bit-slice source register
        volatile uint32_t PMCFG;  ///< Offset: 0x30 - Pattern match interrupt bit slice configuration register
    };

    /// Peripheral instances
    inline Registers* PINT = reinterpret_cast<Registers*>(PINT_BASE);

}

// ============================================================================
// GINT0 Peripheral
// ============================================================================

namespace gint0 {
    /// Base addresses
    constexpr uint32_t GINT0_BASE = 0x400A8000;

    /// GINT0 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - GPIO grouped interrupt control register
        volatile uint32_t PORT_POL[%s];  ///< Offset: 0x20 - GPIO grouped interrupt port 0 polarity register
        volatile uint32_t PORT_ENA[%s];  ///< Offset: 0x40 - GPIO grouped interrupt port 0 enable register
    };

    /// Peripheral instances
    inline Registers* GINT0 = reinterpret_cast<Registers*>(GINT0_BASE);

}

// ============================================================================
// GINT1 Peripheral
// ============================================================================

namespace gint1 {
    /// Base addresses
    constexpr uint32_t GINT1_BASE = 0x400AC000;

    /// GINT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GINT1 = reinterpret_cast<Registers*>(GINT1_BASE);

}

// ============================================================================
// RIT Peripheral
// ============================================================================

namespace rit {
    /// Base addresses
    constexpr uint32_t RIT_BASE = 0x400B4000;

    /// RIT Register structure
    struct Registers {
        volatile uint32_t COMPVAL;  ///< Offset: 0x00 - Compare value LSB register. Holds the 32 LSBs of the...
        volatile uint32_t MASK;  ///< Offset: 0x04 - Mask LSB register. This register holds the 32 LSB s of...
        volatile uint32_t CTRL;  ///< Offset: 0x08 - Control register.
        volatile uint32_t COUNTER;  ///< Offset: 0x0C - Counter LSB register. 32 LSBs of the counter.
        volatile uint32_t COMPVAL_H;  ///< Offset: 0x10 - Compare value MSB register. Holds the 16 MSBs of the...
        volatile uint32_t MASK_H;  ///< Offset: 0x14 - Mask MSB register. This register holds the 16 MSBs of...
        volatile uint32_t COUNTER_H;  ///< Offset: 0x1C - Counter MSB register. 16 MSBs of the counter.
    };

    /// Peripheral instances
    inline Registers* RIT = reinterpret_cast<Registers*>(RIT_BASE);

}

// ============================================================================
// SCTIPU Peripheral
// ============================================================================

namespace sctipu {
    /// Base addresses
    constexpr uint32_t SCTIPU_BASE = 0x400B8000;

    /// SCTIPU Register structure
    struct Registers {
        volatile uint32_t SAMPLE_CTRL;  ///< Offset: 0x00 - SCT IPU sample control register. Contains the input mux...
        volatile uint32_t ABORT_ENABLE%s;  ///< Offset: 0x20 - SCT IPU abort enable register: Selects which input...
        volatile uint32_t ABORT_SOURCE%s;  ///< Offset: 0x24 - SCT IPU abort source register: Status register...
    };

    /// Peripheral instances
    inline Registers* SCTIPU = reinterpret_cast<Registers*>(SCTIPU_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASHCTRL_BASE = 0x400BC000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FMSSTART;  ///< Offset: 0x20 - Signature start address register
        volatile uint32_t FMSSTOP;  ///< Offset: 0x24 - Signature stop-address register
        volatile uint32_t FMSW0;  ///< Offset: 0x2C - Signature word
    };

    /// Peripheral instances
    inline Registers* FLASHCTRL = reinterpret_cast<Registers*>(FLASHCTRL_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t C_CAN0_BASE = 0x400F0000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CNTL;  ///< Offset: 0x00 - CAN control
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register
        volatile uint32_t EC;  ///< Offset: 0x08 - Error counter
        volatile uint32_t BT;  ///< Offset: 0x0C - Bit timing register
        volatile uint32_t INT;  ///< Offset: 0x10 - Interrupt register
        volatile uint32_t TEST;  ///< Offset: 0x14 - Test register
        volatile uint32_t BRPE;  ///< Offset: 0x18 - Baud rate prescaler extension register
        volatile uint32_t IF%s_CMDREQ;  ///< Offset: 0x20 - Message interface command request
        volatile uint32_t IF%s_CMDMSK_W;  ///< Offset: 0x24 - Message interface command mask (write direction)
        volatile uint32_t IF%s_CMDMSK_R;  ///< Offset: 0x24 - Message interface command mask (read direction)
        volatile uint32_t IF%s_MSK1;  ///< Offset: 0x28 - Message interface mask 1
        volatile uint32_t IF%s_MSK2;  ///< Offset: 0x2C - Message interface mask 2
        volatile uint32_t IF%s_ARB1;  ///< Offset: 0x30 - Message interface arbitration 1
        volatile uint32_t IF%s_ARB2;  ///< Offset: 0x34 - Message interface arbitration 2
        volatile uint32_t IF%s_MCTRL;  ///< Offset: 0x38 - Message interface message control
        volatile uint32_t IF%s_DA1;  ///< Offset: 0x3C - Message interface data A1
        volatile uint32_t IF%s_DA2;  ///< Offset: 0x40 - Message interface 1 data A2
        volatile uint32_t IF%s_DB1;  ///< Offset: 0x44 - Message interface 1 data B1
        volatile uint32_t IF%s_DB2;  ///< Offset: 0x48 - Message interface 1 data B2
        volatile uint32_t TXREQ1;  ///< Offset: 0x100 - Transmission request 1
        volatile uint32_t TXREQ2;  ///< Offset: 0x104 - Transmission request 2
        volatile uint32_t ND1;  ///< Offset: 0x120 - New data 1
        volatile uint32_t ND2;  ///< Offset: 0x124 - New data 2
        volatile uint32_t IR1;  ///< Offset: 0x140 - Interrupt pending 1
        volatile uint32_t IR2;  ///< Offset: 0x144 - Interrupt pending 2
        volatile uint32_t MSGV1;  ///< Offset: 0x160 - Message valid 1
        volatile uint32_t MSGV2;  ///< Offset: 0x164 - Message valid 2
        volatile uint32_t CLKDIV;  ///< Offset: 0x180 - CAN clock divider register
    };

    /// Peripheral instances
    inline Registers* C_CAN0 = reinterpret_cast<Registers*>(C_CAN0_BASE);

}

// ============================================================================
// IOCON Peripheral
// ============================================================================

namespace iocon {
    /// Base addresses
    constexpr uint32_t IOCON_BASE = 0x400F8000;

    /// IOCON Register structure
    struct Registers {
        volatile uint32_t PIO0_%s;  ///< Offset: 0x64 - Digital I/O control for port 0 pins PIO0_25 to PIO0_31....
        volatile uint32_t PIO1_%s;  ///< Offset: 0xAC - Digital I/O control for port 1 pins PIO1_11 to PIO1_31....
        volatile uint32_t PIO2_%s;  ///< Offset: 0x100 - Digital I/O control for port 2 pins PIO2_0 to PIO2_13....
    };

    /// Peripheral instances
    inline Registers* IOCON = reinterpret_cast<Registers*>(IOCON_BASE);

}


} // namespace alloy::generated::lpc15xx

#endif // ALLOY_GENERATED_LPC15XX_PERIPHERALS_HPP