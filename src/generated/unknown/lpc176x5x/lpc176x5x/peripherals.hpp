/// Auto-generated code for LPC176x5x
/// Generated by Alloy Code Generator
/// Source: nxp_lpc176x5x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:40
#ifndef ALLOY_GENERATED_LPC176X5X_PERIPHERALS_HPP
#define ALLOY_GENERATED_LPC176X5X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::lpc176x5x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40000000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register determines the...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. The value in this...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This register reads out...
        volatile uint32_t CLKSEL;  ///< Offset: 0x10 - Watchdog clock select register.
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40004000;
    constexpr uint32_t TIMER1_BASE = 0x40008000;
    constexpr uint32_t TIMER2_BASE = 0x40090000;
    constexpr uint32_t TIMER3_BASE = 0x40094000;
    constexpr uint32_t RITIMER_BASE = 0x400B0000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32 bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. When the Prescale Counter (PC) is...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. The 32 bit PC is a counter which is...
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control if an...
        volatile uint32_t MR[%s];  ///< Offset: 0x18 - Match Register 0. MR0 can be enabled through the MCR to...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR[%s];  ///< Offset: 0x2C - Capture Register 0. CR0 is loaded with the value of TC...
        volatile uint32_t EMR;  ///< Offset: 0x3C - External Match Register. The EMR controls the external...
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER3 = reinterpret_cast<Registers*>(TIMER3_BASE);
    inline Registers* RITIMER = reinterpret_cast<Registers*>(RITIMER_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4000C000;
    constexpr uint32_t UART1_BASE = 0x40010000;
    constexpr uint32_t UART2_BASE = 0x40098000;
    constexpr uint32_t UART3_BASE = 0x4009C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t RBR;  ///< Offset: 0x00 - Receiver Buffer Register. Contains the next received...
        volatile uint32_t THR;  ///< Offset: 0x00 - Transmit Holding Regiter. The next character to be...
        volatile uint32_t DLL;  ///< Offset: 0x00 - Divisor Latch LSB. Least significant byte of the baud...
        volatile uint32_t DLM;  ///< Offset: 0x04 - Divisor Latch MSB. Most significant byte of the baud...
        volatile uint32_t IER;  ///< Offset: 0x04 - Interrupt Enable Register. Contains individual interrupt...
        volatile uint32_t IIR;  ///< Offset: 0x08 - Interrupt ID Register. Identifies which interrupt(s) are pending.
        volatile uint32_t FCR;  ///< Offset: 0x08 - FIFO Control Register. Controls UART FIFO usage and modes.
        volatile uint32_t LCR;  ///< Offset: 0x0C - Line Control Register. Contains controls for frame...
        volatile uint32_t LSR;  ///< Offset: 0x14 - Line Status Register. Contains flags for transmit and...
        volatile uint32_t SCR;  ///< Offset: 0x1C - Scratch Pad Register. 8-bit temporary storage for software.
        volatile uint32_t ACR;  ///< Offset: 0x20 - Auto-baud Control Register. Contains controls for the...
        volatile uint32_t FDR;  ///< Offset: 0x28 - Fractional Divider Register. Generates a clock input for...
        volatile uint32_t TER;  ///< Offset: 0x30 - Transmit Enable Register. Turns off UART transmitter for...
        volatile uint32_t RS485CTRL;  ///< Offset: 0x4C - RS-485/EIA-485 Control. Contains controls to configure...
        volatile uint32_t RS485ADRMATCH;  ///< Offset: 0x50 - RS-485/EIA-485 address match. Contains the address match...
        volatile uint32_t RS485DLY;  ///< Offset: 0x54 - RS-485/EIA-485 direction control delay.
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM1_BASE = 0x40018000;
    constexpr uint32_t MCPWM_BASE = 0x400B8000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32 bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. Determines how often the PWM counter...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. Prescaler for the main PWM counter.
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control...
        volatile uint32_t MR%s;  ///< Offset: 0x40 - Match Register. Match registers are continuously...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR[%s];  ///< Offset: 0x2C - PWM Control Register. Enables PWM outputs and selects...
        volatile uint32_t PCR;  ///< Offset: 0x4C - PWM Control Register. Enables PWM outputs and selects...
        volatile uint32_t LER;  ///< Offset: 0x50 - Load Enable Register. Enables use of updated PWM match values.
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
    };

    /// Peripheral instances
    inline Registers* PWM1 = reinterpret_cast<Registers*>(PWM1_BASE);
    inline Registers* MCPWM = reinterpret_cast<Registers*>(MCPWM_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x4001C000;
    constexpr uint32_t I2C1_BASE = 0x4005C000;
    constexpr uint32_t I2C2_BASE = 0x400A0000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CONSET;  ///< Offset: 0x00 - I2C Control Set Register. When a one is written to a bit...
        volatile uint32_t STAT;  ///< Offset: 0x04 - I2C Status Register. During I2C operation, this register...
        volatile uint32_t DAT;  ///< Offset: 0x08 - I2C Data Register. During master or slave transmit mode,...
        volatile uint32_t ADR0;  ///< Offset: 0x0C - I2C Slave Address Register 0. Contains the 7-bit slave...
        volatile uint32_t SCLH;  ///< Offset: 0x10 - SCH Duty Cycle Register High Half Word. Determines the...
        volatile uint32_t SCLL;  ///< Offset: 0x14 - SCL Duty Cycle Register Low Half Word. Determines the...
        volatile uint32_t CONCLR;  ///< Offset: 0x18 - I2C Control Clear Register. When a one is written to a...
        volatile uint32_t MMCTRL;  ///< Offset: 0x1C - Monitor mode control register.
        volatile uint32_t ADR%s;  ///< Offset: 0x20 - I2C Slave Address Register. Contains the 7-bit slave...
        volatile uint32_t DATA_BUFFER;  ///< Offset: 0x2C - Data buffer register. The contents of the 8 MSBs of the...
        volatile uint32_t MASK[%s];  ///< Offset: 0x30 - I2C Slave address mask register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI_BASE = 0x40020000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - SPI Control Register. This register controls the...
        volatile uint32_t SR;  ///< Offset: 0x04 - SPI Status Register. This register shows the status of the SPI.
        volatile uint32_t DR;  ///< Offset: 0x08 - SPI Data Register. This bi-directional register provides...
        volatile uint32_t CCR;  ///< Offset: 0x0C - SPI Clock Counter Register. This register controls the...
        volatile uint32_t INT;  ///< Offset: 0x1C - SPI Interrupt Flag. This register contains the interrupt...
    };

    /// Peripheral instances
    inline Registers* SPI = reinterpret_cast<Registers*>(SPI_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40024000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ILR;  ///< Offset: 0x00 - Interrupt Location Register
        volatile uint32_t CCR;  ///< Offset: 0x08 - Clock Control Register
        volatile uint32_t CIIR;  ///< Offset: 0x0C - Counter Increment Interrupt Register
        volatile uint32_t AMR;  ///< Offset: 0x10 - Alarm Mask Register
        volatile uint32_t CTIME0;  ///< Offset: 0x14 - Consolidated Time Register 0
        volatile uint32_t CTIME1;  ///< Offset: 0x18 - Consolidated Time Register 1
        volatile uint32_t CTIME2;  ///< Offset: 0x1C - Consolidated Time Register 2
        volatile uint32_t SEC;  ///< Offset: 0x20 - Seconds Counter
        volatile uint32_t MIN;  ///< Offset: 0x24 - Minutes Register
        volatile uint32_t HRS;  ///< Offset: 0x28 - Hours Register
        volatile uint32_t DOM;  ///< Offset: 0x2C - Day of Month Register
        volatile uint32_t DOW;  ///< Offset: 0x30 - Day of Week Register
        volatile uint32_t DOY;  ///< Offset: 0x34 - Day of Year Register
        volatile uint32_t MONTH;  ///< Offset: 0x38 - Months Register
        volatile uint32_t YEAR;  ///< Offset: 0x3C - Years Register
        volatile uint32_t CALIBRATION;  ///< Offset: 0x40 - Calibration Value Register
        volatile uint32_t GPREG%s;  ///< Offset: 0x44 - General Purpose Register 0
        volatile uint32_t RTC_AUX;  ///< Offset: 0x5C - RTC Auxiliary control register
        volatile uint32_t RTC_AUXEN;  ///< Offset: 0x58 - RTC Auxiliary Enable register
        volatile uint32_t ASEC;  ///< Offset: 0x60 - Alarm value for Seconds
        volatile uint32_t AMIN;  ///< Offset: 0x64 - Alarm value for Minutes
        volatile uint32_t AHRS;  ///< Offset: 0x68 - Alarm value for Hours
        volatile uint32_t ADOM;  ///< Offset: 0x6C - Alarm value for Day of Month
        volatile uint32_t ADOW;  ///< Offset: 0x70 - Alarm value for Day of Week
        volatile uint32_t ADOY;  ///< Offset: 0x74 - Alarm value for Day of Year
        volatile uint32_t AMON;  ///< Offset: 0x78 - Alarm value for Months
        volatile uint32_t AYRS;  ///< Offset: 0x7C - Alarm value for Year
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOINT_BASE = 0x40028080;
    constexpr uint32_t GPIO_BASE = 0x2009C000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t STATUS;  ///< Offset: 0x00 - GPIO overall Interrupt Status.
        volatile uint32_t STATR0;  ///< Offset: 0x04 - GPIO Interrupt Status for Rising edge for Port 0.
        volatile uint32_t STATF0;  ///< Offset: 0x08 - GPIO Interrupt Status for Falling edge for Port 0.
        volatile uint32_t CLR0;  ///< Offset: 0x0C - GPIO Interrupt Clear.
        volatile uint32_t ENR0;  ///< Offset: 0x10 - GPIO Interrupt Enable for Rising edge for Port 0.
        volatile uint32_t ENF0;  ///< Offset: 0x14 - GPIO Interrupt Enable for Falling edge for Port 0.
        volatile uint32_t STATR2;  ///< Offset: 0x24 - GPIO Interrupt Status for Rising edge for Port 0.
        volatile uint32_t STATF2;  ///< Offset: 0x28 - GPIO Interrupt Status for Falling edge for Port 0.
        volatile uint32_t CLR2;  ///< Offset: 0x2C - GPIO Interrupt Clear.
        volatile uint32_t ENR2;  ///< Offset: 0x30 - GPIO Interrupt Enable for Rising edge for Port 0.
        volatile uint32_t ENF2;  ///< Offset: 0x34 - GPIO Interrupt Enable for Falling edge for Port 0.
    };

    /// Peripheral instances
    inline Registers* GPIOINT = reinterpret_cast<Registers*>(GPIOINT_BASE);
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

}

// ============================================================================
// PINCONNECT Peripheral
// ============================================================================

namespace pinconnect {
    /// Base addresses
    constexpr uint32_t PINCONNECT_BASE = 0x4002C000;

    /// PINCONNECT Register structure
    struct Registers {
        volatile uint32_t PINSEL0;  ///< Offset: 0x00 - Pin function select register 0.
        volatile uint32_t PINSEL1;  ///< Offset: 0x04 - Pin function select register 1.
        volatile uint32_t PINSEL2;  ///< Offset: 0x08 - Pin function select register 2.
        volatile uint32_t PINSEL3;  ///< Offset: 0x0C - Pin function select register 3.
        volatile uint32_t PINSEL4;  ///< Offset: 0x10 - Pin function select register 4
        volatile uint32_t PINSEL7;  ///< Offset: 0x1C - Pin function select register 7
        volatile uint32_t PINSEL9;  ///< Offset: 0x24 - Pin function select register 9
        volatile uint32_t PINSEL10;  ///< Offset: 0x28 - Pin function select register 10
        volatile uint32_t PINMODE0;  ///< Offset: 0x40 - Pin mode select register 0
        volatile uint32_t PINMODE1;  ///< Offset: 0x44 - Pin mode select register 1
        volatile uint32_t PINMODE2;  ///< Offset: 0x48 - Pin mode select register 2
        volatile uint32_t PINMODE3;  ///< Offset: 0x4C - Pin mode select register 3.
        volatile uint32_t PINMODE4;  ///< Offset: 0x50 - Pin mode select register 4
        volatile uint32_t PINMODE7;  ///< Offset: 0x5C - Pin mode select register 7
        volatile uint32_t PINMODE9;  ///< Offset: 0x64 - Pin mode select register 9
        volatile uint32_t PINMODE_OD0;  ///< Offset: 0x68 - Open drain mode control register 0
        volatile uint32_t PINMODE_OD1;  ///< Offset: 0x6C - Open drain mode control register 1
        volatile uint32_t PINMODE_OD2;  ///< Offset: 0x70 - Open drain mode control register 2
        volatile uint32_t PINMODE_OD3;  ///< Offset: 0x74 - Open drain mode control register 3
        volatile uint32_t PINMODE_OD4;  ///< Offset: 0x78 - Open drain mode control register 4
        volatile uint32_t I2CPADCFG;  ///< Offset: 0x7C - I2C Pin Configuration register
    };

    /// Peripheral instances
    inline Registers* PINCONNECT = reinterpret_cast<Registers*>(PINCONNECT_BASE);

}

// ============================================================================
// SSP1 Peripheral
// ============================================================================

namespace ssp1 {
    /// Base addresses
    constexpr uint32_t SSP1_BASE = 0x40030000;

    /// SSP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - Control Register 0. Selects the serial clock rate, bus...
        volatile uint32_t CR1;  ///< Offset: 0x04 - Control Register 1. Selects master/slave and other modes.
        volatile uint32_t DR;  ///< Offset: 0x08 - Data Register. Writes fill the transmit FIFO, and reads...
        volatile uint32_t SR;  ///< Offset: 0x0C - Status Register
        volatile uint32_t CPSR;  ///< Offset: 0x10 - Clock Prescale Register
        volatile uint32_t IMSC;  ///< Offset: 0x14 - Interrupt Mask Set and Clear Register
        volatile uint32_t RIS;  ///< Offset: 0x18 - Raw Interrupt Status Register
        volatile uint32_t MIS;  ///< Offset: 0x1C - Masked Interrupt Status Register
        volatile uint32_t ICR;  ///< Offset: 0x20 - SSPICR Interrupt Clear Register
        volatile uint32_t DMACR;  ///< Offset: 0x24 - SSP0 DMA control register
    };

    /// Peripheral instances
    inline Registers* SSP1 = reinterpret_cast<Registers*>(SSP1_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40034000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - A/D Control Register. The ADCR register must be written...
        volatile uint32_t GDR;  ///< Offset: 0x04 - A/D Global Data Register. This register contains the...
        volatile uint32_t INTEN;  ///< Offset: 0x0C - A/D Interrupt Enable Register. This register contains...
        volatile uint32_t DR[%s];  ///< Offset: 0x10 - A/D Channel 0 Data Register. This register contains the...
        volatile uint32_t STAT;  ///< Offset: 0x30 - A/D Status Register. This register contains DONE and...
        volatile uint32_t TRM;  ///< Offset: 0x34 - ADC trim register.
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CANAFRAM_BASE = 0x40038000;
    constexpr uint32_t CANAF_BASE = 0x4003C000;
    constexpr uint32_t CCAN_BASE = 0x40040000;
    constexpr uint32_t CAN1_BASE = 0x40044000;
    constexpr uint32_t CAN2_BASE = 0x40048000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MASK[%s];  ///< Offset: 0x00 - CAN AF ram access register
    };

    /// Peripheral instances
    inline Registers* CANAFRAM = reinterpret_cast<Registers*>(CANAFRAM_BASE);
    inline Registers* CANAF = reinterpret_cast<Registers*>(CANAF_BASE);
    inline Registers* CCAN = reinterpret_cast<Registers*>(CCAN_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);
    inline Registers* CAN2 = reinterpret_cast<Registers*>(CAN2_BASE);

}

// ============================================================================
// SSP0 Peripheral
// ============================================================================

namespace ssp0 {
    /// Base addresses
    constexpr uint32_t SSP0_BASE = 0x40088000;

    /// SSP0 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSP0 = reinterpret_cast<Registers*>(SSP0_BASE);

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x4008C000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - D/A Converter Register. This register contains the...
        volatile uint32_t CTRL;  ///< Offset: 0x04 - DAC Control register. This register controls DMA and...
        volatile uint32_t CNTVAL;  ///< Offset: 0x08 - DAC Counter Value register. This register contains the...
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_BASE = 0x400A8000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t DAO;  ///< Offset: 0x00 - I2S Digital Audio Output Register. Contains control bits...
        volatile uint32_t DAI;  ///< Offset: 0x04 - I2S Digital Audio Input Register. Contains control bits...
        volatile uint32_t TXFIFO;  ///< Offset: 0x08 - I2S Transmit FIFO. Access register for the 8 x 32-bit...
        volatile uint32_t RXFIFO;  ///< Offset: 0x0C - I2S Receive FIFO. Access register for the 8 x 32-bit...
        volatile uint32_t STATE;  ///< Offset: 0x10 - I2S Status Feedback Register. Contains status...
        volatile uint32_t DMA1;  ///< Offset: 0x14 - I2S DMA Configuration Register 1. Contains control...
        volatile uint32_t DMA2;  ///< Offset: 0x18 - I2S DMA Configuration Register 2. Contains control...
        volatile uint32_t IRQ;  ///< Offset: 0x1C - I2S Interrupt Request Control Register. Contains bits...
        volatile uint32_t TXRATE;  ///< Offset: 0x20 - I2S Transmit MCLK divider. This register determines the...
        volatile uint32_t RXRATE;  ///< Offset: 0x24 - I2S Receive MCLK divider. This register determines the...
        volatile uint32_t TXBITRATE;  ///< Offset: 0x28 - I2S Transmit bit rate divider. This register determines...
        volatile uint32_t RXBITRATE;  ///< Offset: 0x2C - I2S Receive bit rate divider. This register determines...
        volatile uint32_t TXMODE;  ///< Offset: 0x30 - I2S Transmit mode control.
        volatile uint32_t RXMODE;  ///< Offset: 0x34 - I2S Receive mode control.
    };

    /// Peripheral instances
    inline Registers* I2S = reinterpret_cast<Registers*>(I2S_BASE);

}

// ============================================================================
// QEI Peripheral
// ============================================================================

namespace qei {
    /// Base addresses
    constexpr uint32_t QEI_BASE = 0x400BC000;

    /// QEI Register structure
    struct Registers {
        volatile uint32_t CON;  ///< Offset: 0x00 - Control register
        volatile uint32_t CONF;  ///< Offset: 0x08 - Configuration register
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register
        volatile uint32_t POS;  ///< Offset: 0x0C - Position register
        volatile uint32_t MAXPOS;  ///< Offset: 0x10 - Maximum position register
        volatile uint32_t CMPOS0;  ///< Offset: 0x14 - Position compare register 0
        volatile uint32_t CMPOS1;  ///< Offset: 0x18 - Position compare register 1
        volatile uint32_t CMPOS2;  ///< Offset: 0x1C - Position compare register 2
        volatile uint32_t INXCNT;  ///< Offset: 0x20 - Index count register 0
        volatile uint32_t INXCMP0;  ///< Offset: 0x24 - Index compare register 0
        volatile uint32_t LOAD;  ///< Offset: 0x28 - Velocity timer reload register
        volatile uint32_t TIME;  ///< Offset: 0x2C - Velocity timer register
        volatile uint32_t VEL;  ///< Offset: 0x30 - Velocity counter register
        volatile uint32_t CAP;  ///< Offset: 0x34 - Velocity capture register
        volatile uint32_t VELCOMP;  ///< Offset: 0x38 - Velocity compare register
        volatile uint32_t FILTER;  ///< Offset: 0x3C - Digital filter register
        volatile uint32_t INTSTAT;  ///< Offset: 0xFE0 - Interrupt status register
        volatile uint32_t SET;  ///< Offset: 0xFEC - Interrupt status set register
        volatile uint32_t CLR;  ///< Offset: 0xFE8 - Interrupt status clear register
        volatile uint32_t IE;  ///< Offset: 0xFE4 - Interrupt enable register
        volatile uint32_t IES;  ///< Offset: 0xFDC - Interrupt enable set register
        volatile uint32_t IEC;  ///< Offset: 0xFD8 - Interrupt enable clear register
    };

    /// Peripheral instances
    inline Registers* QEI = reinterpret_cast<Registers*>(QEI_BASE);

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x400FC000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t FLASHCFG;  ///< Offset: 0x00 - Flash Accelerator Configuration Register. Controls flash...
        volatile uint32_t PLL0CON;  ///< Offset: 0x80 - PLL0 Control Register
        volatile uint32_t PLL0CFG;  ///< Offset: 0x84 - PLL0 Configuration Register
        volatile uint32_t PLL0STAT;  ///< Offset: 0x88 - PLL0 Status Register
        volatile uint32_t PLL0FEED;  ///< Offset: 0x8C - PLL0 Feed Register
        volatile uint32_t PLL1CON;  ///< Offset: 0xA0 - PLL1 Control Register
        volatile uint32_t PLL1CFG;  ///< Offset: 0xA4 - PLL1 Configuration Register
        volatile uint32_t PLL1STAT;  ///< Offset: 0xA8 - PLL1 Status Register
        volatile uint32_t PLL1FEED;  ///< Offset: 0xAC - PLL1 Feed Register
        volatile uint32_t PCON;  ///< Offset: 0xC0 - Power Control Register
        volatile uint32_t PCONP;  ///< Offset: 0xC4 - Power Control for Peripherals Register
        volatile uint32_t CCLKCFG;  ///< Offset: 0x104 - CPU Clock Configuration Register
        volatile uint32_t USBCLKCFG;  ///< Offset: 0x108 - USB Clock Configuration Register
        volatile uint32_t CLKSRCSEL;  ///< Offset: 0x10C - Clock Source Select Register
        volatile uint32_t CANSLEEPCLR;  ///< Offset: 0x110 - Allows clearing the current CAN channel sleep state as...
        volatile uint32_t CANWAKEFLAGS;  ///< Offset: 0x114 - Allows reading the wake-up state of the CAN channels.
        volatile uint32_t EXTINT;  ///< Offset: 0x140 - External Interrupt Flag Register
        volatile uint32_t EXTMODE;  ///< Offset: 0x148 - External Interrupt Mode register
        volatile uint32_t EXTPOLAR;  ///< Offset: 0x14C - External Interrupt Polarity Register
        volatile uint32_t RSID;  ///< Offset: 0x180 - Reset Source Identification Register
        volatile uint32_t SCS;  ///< Offset: 0x1A0 - System control and status
        volatile uint32_t PCLKSEL0;  ///< Offset: 0x1A8 - Peripheral Clock Selection register 0.
        volatile uint32_t PCLKSEL1;  ///< Offset: 0x1AC - Peripheral Clock Selection register 1.
        volatile uint32_t USBINTST;  ///< Offset: 0x1C0 - USB Interrupt Status
        volatile uint32_t DMACREQSEL;  ///< Offset: 0x1C4 - Selects between alternative requests on DMA channels 0...
        volatile uint32_t CLKOUTCFG;  ///< Offset: 0x1C8 - Clock Output Configuration Register
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t EMAC_BASE = 0x50000000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t MAC1;  ///< Offset: 0x00 - MAC configuration register 1.
        volatile uint32_t MAC2;  ///< Offset: 0x04 - MAC configuration register 2.
        volatile uint32_t IPGT;  ///< Offset: 0x08 - Back-to-Back Inter-Packet-Gap register.
        volatile uint32_t IPGR;  ///< Offset: 0x0C - Non Back-to-Back Inter-Packet-Gap register.
        volatile uint32_t CLRT;  ///< Offset: 0x10 - Collision window / Retry register.
        volatile uint32_t MAXF;  ///< Offset: 0x14 - Maximum Frame register.
        volatile uint32_t SUPP;  ///< Offset: 0x18 - PHY Support register.
        volatile uint32_t TEST;  ///< Offset: 0x1C - Test register.
        volatile uint32_t MCFG;  ///< Offset: 0x20 - MII Mgmt Configuration register.
        volatile uint32_t MCMD;  ///< Offset: 0x24 - MII Mgmt Command register.
        volatile uint32_t MADR;  ///< Offset: 0x28 - MII Mgmt Address register.
        volatile uint32_t MWTD;  ///< Offset: 0x2C - MII Mgmt Write Data register.
        volatile uint32_t MRDD;  ///< Offset: 0x30 - MII Mgmt Read Data register.
        volatile uint32_t MIND;  ///< Offset: 0x34 - MII Mgmt Indicators register.
        volatile uint32_t SA0;  ///< Offset: 0x40 - Station Address 0 register.
        volatile uint32_t SA1;  ///< Offset: 0x44 - Station Address 1 register.
        volatile uint32_t SA2;  ///< Offset: 0x48 - Station Address 2 register.
        volatile uint32_t COMMAND;  ///< Offset: 0x100 - Command register.
        volatile uint32_t STATUS;  ///< Offset: 0x104 - Status register.
        volatile uint32_t RXDESCRIPTOR;  ///< Offset: 0x108 - Receive descriptor base address register.
        volatile uint32_t RXSTATUS;  ///< Offset: 0x10C - Receive status base address register.
        volatile uint32_t RXDESCRIPTORNUMBER;  ///< Offset: 0x110 - Receive number of descriptors register.
        volatile uint32_t RXPRODUCEINDEX;  ///< Offset: 0x114 - Receive produce index register.
        volatile uint32_t RXCONSUMEINDEX;  ///< Offset: 0x118 - Receive consume index register.
        volatile uint32_t TXDESCRIPTOR;  ///< Offset: 0x11C - Transmit descriptor base address register.
        volatile uint32_t TXSTATUS;  ///< Offset: 0x120 - Transmit status base address register.
        volatile uint32_t TXDESCRIPTORNUMBER;  ///< Offset: 0x124 - Transmit number of descriptors register.
        volatile uint32_t TXPRODUCEINDEX;  ///< Offset: 0x128 - Transmit produce index register.
        volatile uint32_t TXCONSUMEINDEX;  ///< Offset: 0x12C - Transmit consume index register.
        volatile uint32_t TSV0;  ///< Offset: 0x158 - Transmit status vector 0 register.
        volatile uint32_t TSV1;  ///< Offset: 0x15C - Transmit status vector 1 register.
        volatile uint32_t RSV;  ///< Offset: 0x160 - Receive status vector register.
        volatile uint32_t FLOWCONTROLCOUNTER;  ///< Offset: 0x170 - Flow control counter register.
        volatile uint32_t FLOWCONTROLSTATUS;  ///< Offset: 0x174 - Flow control status register.
        volatile uint32_t RXFILTERCTRL;  ///< Offset: 0x200 - Receive filter control register.
        volatile uint32_t RXFILTERWOLSTATUS;  ///< Offset: 0x204 - Receive filter WoL status register.
        volatile uint32_t RXFILTERWOLCLEAR;  ///< Offset: 0x208 - Receive filter WoL clear register.
        volatile uint32_t HASHFILTERL;  ///< Offset: 0x210 - Hash filter table LSBs register.
        volatile uint32_t HASHFILTERH;  ///< Offset: 0x214 - Hash filter table MSBs register.
        volatile uint32_t INTSTATUS;  ///< Offset: 0xFE0 - Interrupt status register.
        volatile uint32_t INTENABLE;  ///< Offset: 0xFE4 - Interrupt enable register.
        volatile uint32_t INTCLEAR;  ///< Offset: 0xFE8 - Interrupt clear register.
        volatile uint32_t INTSET;  ///< Offset: 0xFEC - Interrupt set register.
        volatile uint32_t POWERDOWN;  ///< Offset: 0xFF4 - Power-down register.
    };

    /// Peripheral instances
    inline Registers* EMAC = reinterpret_cast<Registers*>(EMAC_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA_BASE = 0x50004000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t INTSTAT;  ///< Offset: 0x00 - DMA Interrupt Status Register
        volatile uint32_t INTTCSTAT;  ///< Offset: 0x04 - DMA Interrupt Terminal Count Request Status Register
        volatile uint32_t INTTCCLEAR;  ///< Offset: 0x08 - DMA Interrupt Terminal Count Request Clear Register
        volatile uint32_t INTERRSTAT;  ///< Offset: 0x0C - DMA Interrupt Error Status Register
        volatile uint32_t INTERRCLR;  ///< Offset: 0x10 - DMA Interrupt Error Clear Register
        volatile uint32_t RAWINTTCSTAT;  ///< Offset: 0x14 - DMA Raw Interrupt Terminal Count Status Register
        volatile uint32_t RAWINTERRSTAT;  ///< Offset: 0x18 - DMA Raw Error Interrupt Status Register
        volatile uint32_t ENBLDCHNS;  ///< Offset: 0x1C - DMA Enabled Channel Register
        volatile uint32_t SOFTBREQ;  ///< Offset: 0x20 - DMA Software Burst Request Register
        volatile uint32_t SOFTSREQ;  ///< Offset: 0x24 - DMA Software Single Request Register
        volatile uint32_t SOFTLBREQ;  ///< Offset: 0x28 - DMA Software Last Burst Request Register
        volatile uint32_t SOFTLSREQ;  ///< Offset: 0x2C - DMA Software Last Single Request Register
        volatile uint32_t CONFIG;  ///< Offset: 0x30 - DMA Configuration Register
        volatile uint32_t SYNC;  ///< Offset: 0x34 - DMA Synchronization Register
        volatile uint32_t SRCADDR%s;  ///< Offset: 0x100 - DMA Channel 0 Source Address Register
        volatile uint32_t DESTADDR%s;  ///< Offset: 0x104 - DMA Channel 0 Destination Address Register
        volatile uint32_t LLI%s;  ///< Offset: 0x108 - DMA Channel 0 Linked List Item Register
        volatile uint32_t CONTROL%s;  ///< Offset: 0x10C - DMA Channel 0 Control Register
        volatile uint32_t CONFIG%s;  ///< Offset: 0x110 - DMA Channel 0 Configuration Register[1]
    };

    /// Peripheral instances
    inline Registers* GPDMA = reinterpret_cast<Registers*>(GPDMA_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x50008000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t INTST;  ///< Offset: 0x100 - OTG Interrupt Status
        volatile uint32_t INTEN;  ///< Offset: 0x104 - OTG Interrupt Enable
        volatile uint32_t INTSET;  ///< Offset: 0x108 - OTG Interrupt Set
        volatile uint32_t INTCLR;  ///< Offset: 0x10C - OTG Interrupt Clear
        volatile uint32_t STCTRL;  ///< Offset: 0x110 - OTG Status and Control and USB port select
        volatile uint32_t TMR;  ///< Offset: 0x114 - OTG Timer
        volatile uint32_t DEVINTST;  ///< Offset: 0x200 - USB Device Interrupt Status
        volatile uint32_t DEVINTEN;  ///< Offset: 0x204 - USB Device Interrupt Enable
        volatile uint32_t DEVINTCLR;  ///< Offset: 0x208 - USB Device Interrupt Clear
        volatile uint32_t DEVINTSET;  ///< Offset: 0x20C - USB Device Interrupt Set
        volatile uint32_t CMDCODE;  ///< Offset: 0x210 - USB Command Code
        volatile uint32_t CMDDATA;  ///< Offset: 0x214 - USB Command Data
        volatile uint32_t RXDATA;  ///< Offset: 0x218 - USB Receive Data
        volatile uint32_t TXDATA;  ///< Offset: 0x21C - USB Transmit Data
        volatile uint32_t RXPLEN;  ///< Offset: 0xDC - USB Receive Packet Length
        volatile uint32_t TXPLEN;  ///< Offset: 0x224 - USB Transmit Packet Length
        volatile uint32_t CTRL;  ///< Offset: 0x228 - USB Control
        volatile uint32_t DEVINTPRI;  ///< Offset: 0x22C - USB Device Interrupt Priority
        volatile uint32_t EPINTST;  ///< Offset: 0x230 - USB Endpoint Interrupt Status
        volatile uint32_t EPINTEN;  ///< Offset: 0x234 - USB Endpoint Interrupt Enable
        volatile uint32_t EPINTCLR;  ///< Offset: 0x238 - USB Endpoint Interrupt Clear
        volatile uint32_t EPINTSET;  ///< Offset: 0x23C - USB Endpoint Interrupt Set
        volatile uint32_t EPINTPRI;  ///< Offset: 0x240 - USB Endpoint Priority
        volatile uint32_t REEP;  ///< Offset: 0x244 - USB Realize Endpoint
        volatile uint32_t EPIND;  ///< Offset: 0x248 - USB Endpoint Index
        volatile uint32_t MAXPSIZE;  ///< Offset: 0x24C - USB MaxPacketSize
        volatile uint32_t DMARST;  ///< Offset: 0x250 - USB DMA Request Status
        volatile uint32_t DMARCLR;  ///< Offset: 0x254 - USB DMA Request Clear
        volatile uint32_t DMARSET;  ///< Offset: 0x258 - USB DMA Request Set
        volatile uint32_t UDCAH;  ///< Offset: 0x280 - USB UDCA Head
        volatile uint32_t EPDMAST;  ///< Offset: 0x284 - USB Endpoint DMA Status
        volatile uint32_t EPDMAEN;  ///< Offset: 0x288 - USB Endpoint DMA Enable
        volatile uint32_t EPDMADIS;  ///< Offset: 0x28C - USB Endpoint DMA Disable
        volatile uint32_t DMAINTST;  ///< Offset: 0x290 - USB DMA Interrupt Status
        volatile uint32_t DMAINTEN;  ///< Offset: 0x294 - USB DMA Interrupt Enable
        volatile uint32_t EOTINTST;  ///< Offset: 0x2A0 - USB End of Transfer Interrupt Status
        volatile uint32_t EOTINTCLR;  ///< Offset: 0x2A4 - USB End of Transfer Interrupt Clear
        volatile uint32_t EOTINTSET;  ///< Offset: 0x2A8 - USB End of Transfer Interrupt Set
        volatile uint32_t NDDRINTST;  ///< Offset: 0x2AC - USB New DD Request Interrupt Status
        volatile uint32_t NDDRINTCLR;  ///< Offset: 0x2B0 - USB New DD Request Interrupt Clear
        volatile uint32_t NDDRINTSET;  ///< Offset: 0x2B4 - USB New DD Request Interrupt Set
        volatile uint32_t SYSERRINTST;  ///< Offset: 0x2B8 - USB System Error Interrupt Status
        volatile uint32_t SYSERRINTCLR;  ///< Offset: 0x2BC - USB System Error Interrupt Clear
        volatile uint32_t SYSERRINTSET;  ///< Offset: 0x2C0 - USB System Error Interrupt Set
        volatile uint32_t I2C_RX;  ///< Offset: 0x300 - I2C Receive
        volatile uint32_t I2C_WO;  ///< Offset: 0x300 - I2C Transmit
        volatile uint32_t I2C_STS;  ///< Offset: 0x304 - I2C Status
        volatile uint32_t I2C_CTL;  ///< Offset: 0x308 - I2C Control
        volatile uint32_t I2C_CLKHI;  ///< Offset: 0x30C - I2C Clock High
        volatile uint32_t I2C_CLKLO;  ///< Offset: 0x310 - I2C Clock Low
        volatile uint32_t USBCLKCTRL;  ///< Offset: 0xFF4 - USB Clock Control
        volatile uint32_t OTGCLKCTRL;  ///< Offset: 0xFF4 - OTG clock controller
        volatile uint32_t USBCLKST;  ///< Offset: 0xFF8 - USB Clock Status
        volatile uint32_t OTGCLKST;  ///< Offset: 0xFF8 - OTG clock status
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

}


} // namespace alloy::generated::lpc176x5x

#endif // ALLOY_GENERATED_LPC176X5X_PERIPHERALS_HPP