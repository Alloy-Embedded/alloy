/// Auto-generated code for LPC43xx
/// Generated by Alloy Code Generator
/// Source: nxp_lpc43xx.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:14
#ifndef ALLOY_GENERATED_LPC43XX_PERIPHERALS_HPP
#define ALLOY_GENERATED_LPC43XX_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::lpc43xx {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_sct = true;
    constexpr uint32_t num_sct_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 1;
    constexpr bool has_emc = true;
    constexpr uint32_t num_emc_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_eeprom = true;
    constexpr uint32_t num_eeprom_instances = 1;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 6;
    constexpr bool has_regfile = true;
    constexpr uint32_t num_regfile_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_creg = true;
    constexpr uint32_t num_creg_instances = 1;
    constexpr bool has_eventrouter = true;
    constexpr uint32_t num_eventrouter_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_cgu = true;
    constexpr uint32_t num_cgu_instances = 1;
    constexpr bool has_ccu1 = true;
    constexpr uint32_t num_ccu1_instances = 1;
    constexpr bool has_ccu2 = true;
    constexpr uint32_t num_ccu2_instances = 1;
    constexpr bool has_rgu = true;
    constexpr uint32_t num_rgu_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 4;
    constexpr bool has_ssp0 = true;
    constexpr uint32_t num_ssp0_instances = 1;
    constexpr bool has_ssp1 = true;
    constexpr uint32_t num_ssp1_instances = 1;
    constexpr bool has_scu = true;
    constexpr uint32_t num_scu_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 2;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_qei = true;
    constexpr uint32_t num_qei_instances = 1;
    constexpr bool has_gima = true;
    constexpr uint32_t num_gima_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 3;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct sct_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct emc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eeprom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct regfile_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct creg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eventrouter_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cgu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccu1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ccu2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rgu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct ssp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct qei_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gima_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 3;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart0 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// SCT Peripheral
// ============================================================================

namespace sct {
    /// Base addresses
    constexpr uint32_t SCT_BASE = 0x40000000;

    /// SCT Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT control register
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt condition register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop condition register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start condition register
        volatile uint32_t DITHER;  ///< Offset: 0x18 - SCT dither condition register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x44 - SCT state register
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture registers mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t DMAREQ0;  ///< Offset: 0x5C - SCT DMA request 0 register
        volatile uint32_t DMAREQ1;  ///< Offset: 0x60 - SCT DMA request 1 register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t MATCH%s;  ///< Offset: 0x100 - SCT match value register of match channels 0 to 15;...
        volatile uint32_t FRACMAT%s;  ///< Offset: 0x140 - Fractional match registers 0 to 5 for SCT match value...
        volatile uint32_t CAP%s;  ///< Offset: 0x100 - SCT capture register of capture channel 0 to 15; REGMOD0...
        volatile uint32_t MATCHREL%s;  ///< Offset: 0x200 - SCT match reload value register 0 to 15; REGMOD0 = 0 to...
        volatile uint32_t FRACMATREL%s;  ///< Offset: 0x240 - Fractional match reload registers 0 to 5 for SCT match...
        volatile uint32_t CAPCTRL%s;  ///< Offset: 0x200 - SCT capture control register 0 to 15; REGMOD0 = 1 to...
        volatile uint32_t EV%s_STATE;  ///< Offset: 0x300 - SCT event state register 0
        volatile uint32_t EV%s_CTRL;  ///< Offset: 0x304 - SCT event control register 0
        volatile uint32_t OUT%s_SET;  ///< Offset: 0x500 - SCT output 0 set register
        volatile uint32_t OUT%s_CLR;  ///< Offset: 0x504 - SCT output 0 clear register
    };

    /// Peripheral instances
    inline Registers* SCT = reinterpret_cast<Registers*>(SCT_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA_BASE = 0x40002000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t INTSTAT;  ///< Offset: 0x00 - DMA Interrupt Status Register
        volatile uint32_t INTTCSTAT;  ///< Offset: 0x04 - DMA Interrupt Terminal Count Request Status Register
        volatile uint32_t INTTCCLEAR;  ///< Offset: 0x08 - DMA Interrupt Terminal Count Request Clear Register
        volatile uint32_t INTERRSTAT;  ///< Offset: 0x0C - DMA Interrupt Error Status Register
        volatile uint32_t INTERRCLR;  ///< Offset: 0x10 - DMA Interrupt Error Clear Register
        volatile uint32_t RAWINTTCSTAT;  ///< Offset: 0x14 - DMA Raw Interrupt Terminal Count Status Register
        volatile uint32_t RAWINTERRSTAT;  ///< Offset: 0x18 - DMA Raw Error Interrupt Status Register
        volatile uint32_t ENBLDCHNS;  ///< Offset: 0x1C - DMA Enabled Channel Register
        volatile uint32_t SOFTBREQ;  ///< Offset: 0x20 - DMA Software Burst Request Register
        volatile uint32_t SOFTSREQ;  ///< Offset: 0x24 - DMA Software Single Request Register
        volatile uint32_t SOFTLBREQ;  ///< Offset: 0x28 - DMA Software Last Burst Request Register
        volatile uint32_t SOFTLSREQ;  ///< Offset: 0x2C - DMA Software Last Single Request Register
        volatile uint32_t CONFIG;  ///< Offset: 0x30 - DMA Configuration Register
        volatile uint32_t SYNC;  ///< Offset: 0x34 - DMA Synchronization Register
        volatile uint32_t C%sSRCADDR;  ///< Offset: 0x100 - DMA Channel Source Address Register
        volatile uint32_t C%sDESTADDR;  ///< Offset: 0x104 - DMA Channel Destination Address Register
        volatile uint32_t C%sLLI;  ///< Offset: 0x108 - DMA Channel Linked List Item Register
        volatile uint32_t C%sCONTROL;  ///< Offset: 0x10C - DMA Channel Control Register
        volatile uint32_t C%sCONFIG;  ///< Offset: 0x110 - DMA Channel Configuration Register
    };

    /// Peripheral instances
    inline Registers* GPDMA = reinterpret_cast<Registers*>(GPDMA_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPIFI_BASE = 0x40003000;
    constexpr uint32_t SPI_BASE = 0x40100000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - SPIFI control register
        volatile uint32_t CMD;  ///< Offset: 0x04 - SPIFI command register
        volatile uint32_t ADDR;  ///< Offset: 0x08 - SPIFI address register
        volatile uint32_t IDATA;  ///< Offset: 0x0C - SPIFI intermediate data register
        volatile uint32_t CLIMIT;  ///< Offset: 0x10 - SPIFI cache limit register
        volatile uint32_t DATA;  ///< Offset: 0x14 - SPIFI data register
        volatile uint32_t MCMD;  ///< Offset: 0x18 - SPIFI memory command register
        volatile uint32_t STAT;  ///< Offset: 0x1C - SPIFI status register
    };

    /// Peripheral instances
    inline Registers* SPIFI = reinterpret_cast<Registers*>(SPIFI_BASE);
    inline Registers* SPI = reinterpret_cast<Registers*>(SPI_BASE);

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_BASE = 0x40004000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t PWREN;  ///< Offset: 0x04 - Power Enable Register
        volatile uint32_t CLKDIV;  ///< Offset: 0x08 - Clock Divider Register
        volatile uint32_t CLKSRC;  ///< Offset: 0x0C - SD Clock Source Register
        volatile uint32_t CLKENA;  ///< Offset: 0x10 - Clock Enable Register
        volatile uint32_t TMOUT;  ///< Offset: 0x14 - Time-out Register
        volatile uint32_t CTYPE;  ///< Offset: 0x18 - Card Type Register
        volatile uint32_t BLKSIZ;  ///< Offset: 0x1C - Block Size Register
        volatile uint32_t BYTCNT;  ///< Offset: 0x20 - Byte Count Register
        volatile uint32_t INTMASK;  ///< Offset: 0x24 - Interrupt Mask Register
        volatile uint32_t CMDARG;  ///< Offset: 0x28 - Command Argument Register
        volatile uint32_t CMD;  ///< Offset: 0x2C - Command Register
        volatile uint32_t RESP0;  ///< Offset: 0x30 - Response Register 0
        volatile uint32_t RESP1;  ///< Offset: 0x34 - Response Register 1
        volatile uint32_t RESP2;  ///< Offset: 0x38 - Response Register 2
        volatile uint32_t RESP3;  ///< Offset: 0x3C - Response Register 3
        volatile uint32_t MINTSTS;  ///< Offset: 0x40 - Masked Interrupt Status Register
        volatile uint32_t RINTSTS;  ///< Offset: 0x44 - Raw Interrupt Status Register
        volatile uint32_t STATUS;  ///< Offset: 0x48 - Status Register
        volatile uint32_t FIFOTH;  ///< Offset: 0x4C - FIFO Threshold Watermark Register
        volatile uint32_t CDETECT;  ///< Offset: 0x50 - Card Detect Register
        volatile uint32_t WRTPRT;  ///< Offset: 0x54 - Write Protect Register
        volatile uint32_t TCBCNT;  ///< Offset: 0x5C - Transferred CIU Card Byte Count Register
        volatile uint32_t TBBCNT;  ///< Offset: 0x60 - Transferred Host to BIU-FIFO Byte Count Register
        volatile uint32_t DEBNCE;  ///< Offset: 0x64 - Debounce Count Register
        volatile uint32_t RST_N;  ///< Offset: 0x78 - Hardware Reset
        volatile uint32_t BMOD;  ///< Offset: 0x80 - Bus Mode Register
        volatile uint32_t PLDMND;  ///< Offset: 0x84 - Poll Demand Register
        volatile uint32_t DBADDR;  ///< Offset: 0x88 - Descriptor List Base Address Register
        volatile uint32_t IDSTS;  ///< Offset: 0x8C - Internal DMAC Status Register
        volatile uint32_t IDINTEN;  ///< Offset: 0x90 - Internal DMAC Interrupt Enable Register
        volatile uint32_t DSCADDR;  ///< Offset: 0x94 - Current Host Descriptor Address Register
        volatile uint32_t BUFADDR;  ///< Offset: 0x98 - Current Buffer Descriptor Address Register
    };

    /// Peripheral instances
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);

}

// ============================================================================
// EMC Peripheral
// ============================================================================

namespace emc {
    /// Base addresses
    constexpr uint32_t EMC_BASE = 0x40005000;

    /// EMC Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Controls operation of the memory controller.
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Provides EMC status information.
        volatile uint32_t CONFIG;  ///< Offset: 0x08 - Configures operation of the memory controller.
        volatile uint32_t DYNAMICCONTROL;  ///< Offset: 0x20 - Controls dynamic memory operation.
        volatile uint32_t DYNAMICREFRESH;  ///< Offset: 0x24 - Configures dynamic memory refresh operation.
        volatile uint32_t DYNAMICREADCONFIG;  ///< Offset: 0x28 - Configures the dynamic memory read strategy.
        volatile uint32_t DYNAMICRP;  ///< Offset: 0x30 - Selects the precharge command period.
        volatile uint32_t DYNAMICRAS;  ///< Offset: 0x34 - Selects the active to precharge command period.
        volatile uint32_t DYNAMICSREX;  ///< Offset: 0x38 - Selects the self-refresh exit time.
        volatile uint32_t DYNAMICAPR;  ///< Offset: 0x3C - Selects the last-data-out to active command time.
        volatile uint32_t DYNAMICDAL;  ///< Offset: 0x40 - Selects the data-in to active command time.
        volatile uint32_t DYNAMICWR;  ///< Offset: 0x44 - Selects the write recovery time.
        volatile uint32_t DYNAMICRC;  ///< Offset: 0x48 - Selects the active to active command period.
        volatile uint32_t DYNAMICRFC;  ///< Offset: 0x4C - Selects the auto-refresh period.
        volatile uint32_t DYNAMICXSR;  ///< Offset: 0x50 - Selects the exit self-refresh to active command time.
        volatile uint32_t DYNAMICRRD;  ///< Offset: 0x54 - Selects the active bank A to active bank B latency.
        volatile uint32_t DYNAMICMRD;  ///< Offset: 0x58 - Selects the load mode register to active command time.
        volatile uint32_t STATICEXTENDEDWAIT;  ///< Offset: 0x80 - Selects time for long static memory read and write transfers.
        volatile uint32_t DYNAMICCONFIG%s;  ///< Offset: 0x100 - Selects the configuration information for dynamic memory...
        volatile uint32_t DYNAMICRASCAS%s;  ///< Offset: 0x104 - Selects the RAS and CAS latencies for dynamic memory...
        volatile uint32_t STATICCONFIG%s;  ///< Offset: 0x200 - Selects the memory configuration for static chip select 0.
        volatile uint32_t STATICWAITWEN%s;  ///< Offset: 0x204 - Selects the delay from chip select 0 to write enable.
        volatile uint32_t STATICWAITOEN%s;  ///< Offset: 0x208 - Selects the delay from chip select 0 or address change,...
        volatile uint32_t STATICWAITRD%s;  ///< Offset: 0x20C - Selects the delay from chip select 0 to a read access.
        volatile uint32_t STATICWAITPAGE%s;  ///< Offset: 0x210 - Selects the delay for asynchronous page mode sequential...
        volatile uint32_t STATICWAITWR%s;  ///< Offset: 0x214 - Selects the delay from chip select 0 to a write access.
        volatile uint32_t STATICWAITTURN%s;  ///< Offset: 0x218 - Selects the number of bus turnaround cycles for chip select 0.
    };

    /// Peripheral instances
    inline Registers* EMC = reinterpret_cast<Registers*>(EMC_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x40006000;
    constexpr uint32_t USB1_BASE = 0x40007000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CAPLENGTH;  ///< Offset: 0x100 - Capability register length
        volatile uint32_t HCSPARAMS;  ///< Offset: 0x104 - Host controller structural parameters
        volatile uint32_t HCCPARAMS;  ///< Offset: 0x108 - Host controller capability parameters
        volatile uint32_t DCIVERSION;  ///< Offset: 0x120 - Device interface version number
        volatile uint32_t USBCMD_D;  ///< Offset: 0x140 - USB command (device mode)
        volatile uint32_t USBCMD_H;  ///< Offset: 0x140 - USB command (host mode)
        volatile uint32_t USBSTS_D;  ///< Offset: 0x144 - USB status (device mode)
        volatile uint32_t USBSTS_H;  ///< Offset: 0x144 - USB status (host mode)
        volatile uint32_t USBINTR_D;  ///< Offset: 0x148 - USB interrupt enable (device mode)
        volatile uint32_t USBINTR_H;  ///< Offset: 0x148 - USB interrupt enable (host mode)
        volatile uint32_t FRINDEX_D;  ///< Offset: 0x14C - USB frame index (device mode)
        volatile uint32_t FRINDEX_H;  ///< Offset: 0x14C - USB frame index (host mode)
        volatile uint32_t DEVICEADDR;  ///< Offset: 0x154 - USB device address (device mode)
        volatile uint32_t PERIODICLISTBASE;  ///< Offset: 0x154 - Frame list base address (host mode)
        volatile uint32_t ENDPOINTLISTADDR;  ///< Offset: 0x158 - Address of endpoint list in memory
        volatile uint32_t ASYNCLISTADDR;  ///< Offset: 0x158 - Address of endpoint list in memory
        volatile uint32_t TTCTRL;  ///< Offset: 0x15C - Asynchronous buffer status for embedded TT (host mode)
        volatile uint32_t BURSTSIZE;  ///< Offset: 0x160 - Programmable burst size
        volatile uint32_t TXFILLTUNING;  ///< Offset: 0x164 - Host transmit pre-buffer packet tuning (host mode)
        volatile uint32_t BINTERVAL;  ///< Offset: 0x174 - Length of virtual frame
        volatile uint32_t ENDPTNAK;  ///< Offset: 0x178 - Endpoint NAK (device mode)
        volatile uint32_t ENDPTNAKEN;  ///< Offset: 0x17C - Endpoint NAK Enable (device mode)
        volatile uint32_t PORTSC1_D;  ///< Offset: 0x184 - Port 1 status/control (device mode)
        volatile uint32_t PORTSC1_H;  ///< Offset: 0x184 - Port 1 status/control (host mode)
        volatile uint32_t OTGSC;  ///< Offset: 0x1A4 - OTG status and control
        volatile uint32_t USBMODE_D;  ///< Offset: 0x1A8 - USB device mode (device mode)
        volatile uint32_t USBMODE_H;  ///< Offset: 0x1A8 - USB mode (host mode)
        volatile uint32_t ENDPTSETUPSTAT;  ///< Offset: 0x1AC - Endpoint setup status
        volatile uint32_t ENDPTPRIME;  ///< Offset: 0x1B0 - Endpoint initialization
        volatile uint32_t ENDPTFLUSH;  ///< Offset: 0x1B4 - Endpoint de-initialization
        volatile uint32_t ENDPTSTAT;  ///< Offset: 0x1B8 - Endpoint status
        volatile uint32_t ENDPTCOMPLETE;  ///< Offset: 0x1BC - Endpoint complete
        volatile uint32_t ENDPTCTRL0;  ///< Offset: 0x1C0 - Endpoint control 0
        volatile uint32_t ENDPTCTRL%s;  ///< Offset: 0x1C4 - Endpoint control
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);
    inline Registers* USB1 = reinterpret_cast<Registers*>(USB1_BASE);

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x40008000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t TIMH;  ///< Offset: 0x00 - Horizontal Timing Control register
        volatile uint32_t TIMV;  ///< Offset: 0x04 - Vertical Timing Control register
        volatile uint32_t POL;  ///< Offset: 0x08 - Clock and Signal Polarity Control register
        volatile uint32_t LE;  ///< Offset: 0x0C - Line End Control register
        volatile uint32_t UPBASE;  ///< Offset: 0x10 - Upper Panel Frame Base Address register
        volatile uint32_t LPBASE;  ///< Offset: 0x14 - Lower Panel Frame Base Address register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LCD Control register
        volatile uint32_t INTMSK;  ///< Offset: 0x1C - Interrupt Mask register
        volatile uint32_t INTRAW;  ///< Offset: 0x20 - Raw Interrupt Status register
        volatile uint32_t INTSTAT;  ///< Offset: 0x24 - Masked Interrupt Status register
        volatile uint32_t INTCLR;  ///< Offset: 0x28 - Interrupt Clear register
        volatile uint32_t UPCURR;  ///< Offset: 0x2C - Upper Panel Current Address Value register
        volatile uint32_t LPCURR;  ///< Offset: 0x30 - Lower Panel Current Address Value register
        volatile uint32_t PAL[%s];  ///< Offset: 0x200 - 256x16-bit Color Palette registers
        volatile uint32_t CRSR_IMG[%s];  ///< Offset: 0x800 - Cursor Image registers
        volatile uint32_t CRSR_CTRL;  ///< Offset: 0xC00 - Cursor Control register
        volatile uint32_t CRSR_CFG;  ///< Offset: 0xC04 - Cursor Configuration register
        volatile uint32_t CRSR_PAL0;  ///< Offset: 0xC08 - Cursor Palette register 0
        volatile uint32_t CRSR_PAL1;  ///< Offset: 0xC0C - Cursor Palette register 1
        volatile uint32_t CRSR_XY;  ///< Offset: 0xC10 - Cursor XY Position register
        volatile uint32_t CRSR_CLIP;  ///< Offset: 0xC14 - Cursor Clip Position register
        volatile uint32_t CRSR_INTMSK;  ///< Offset: 0xC20 - Cursor Interrupt Mask register
        volatile uint32_t CRSR_INTCLR;  ///< Offset: 0xC24 - Cursor Interrupt Clear register
        volatile uint32_t CRSR_INTRAW;  ///< Offset: 0xC28 - Cursor Raw Interrupt Status register
        volatile uint32_t CRSR_INTSTAT;  ///< Offset: 0xC2C - Cursor Masked Interrupt Status register
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

}

// ============================================================================
// EEPROM Peripheral
// ============================================================================

namespace eeprom {
    /// Base addresses
    constexpr uint32_t EEPROM_BASE = 0x4000E000;

    /// EEPROM Register structure
    struct Registers {
        volatile uint32_t CMD;  ///< Offset: 0x00 - EEPROM command register
        volatile uint32_t RWSTATE;  ///< Offset: 0x08 - EEPROM read wait state register
        volatile uint32_t AUTOPROG;  ///< Offset: 0x0C - EEPROM auto programming register
        volatile uint32_t WSTATE;  ///< Offset: 0x10 - EEPROM wait state register
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - EEPROM clock divider register
        volatile uint32_t PWRDWN;  ///< Offset: 0x18 - EEPROM power-down register
        volatile uint32_t INTENCLR;  ///< Offset: 0xFD8 - EEPROM interrupt enable clear
        volatile uint32_t INTENSET;  ///< Offset: 0xFDC - EEPROM interrupt enable set
        volatile uint32_t INTSTAT;  ///< Offset: 0xFE0 - EEPROM interrupt status
        volatile uint32_t INTEN;  ///< Offset: 0xFE4 - EEPROM interrupt enable
        volatile uint32_t INTSTATCLR;  ///< Offset: 0xFE8 - EEPROM interrupt status clear
    };

    /// Peripheral instances
    inline Registers* EEPROM = reinterpret_cast<Registers*>(EEPROM_BASE);

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETHERNET_BASE = 0x40010000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t MAC_CONFIG;  ///< Offset: 0x00 - MAC configuration register
        volatile uint32_t MAC_FRAME_FILTER;  ///< Offset: 0x04 - MAC frame filter
        volatile uint32_t MAC_HASHTABLE_HIGH;  ///< Offset: 0x08 - Hash table high register
        volatile uint32_t MAC_HASHTABLE_LOW;  ///< Offset: 0x0C - Hash table low register
        volatile uint32_t MAC_MII_ADDR;  ///< Offset: 0x10 - MII address register
        volatile uint32_t MAC_MII_DATA;  ///< Offset: 0x14 - MII data register
        volatile uint32_t MAC_FLOW_CTRL;  ///< Offset: 0x18 - Flow control register
        volatile uint32_t MAC_VLAN_TAG;  ///< Offset: 0x1C - VLAN tag register
        volatile uint32_t MAC_DEBUG;  ///< Offset: 0x24 - Debug register
        volatile uint32_t MAC_RWAKE_FRFLT;  ///< Offset: 0x28 - Remote wake-up frame filter
        volatile uint32_t MAC_PMT_CTRL_STAT;  ///< Offset: 0x2C - PMT control and status
        volatile uint32_t MAC_INTR;  ///< Offset: 0x38 - Interrupt status register
        volatile uint32_t MAC_INTR_MASK;  ///< Offset: 0x3C - Interrupt mask register
        volatile uint32_t MAC_ADDR0_HIGH;  ///< Offset: 0x40 - MAC address 0 high register
        volatile uint32_t MAC_ADDR0_LOW;  ///< Offset: 0x44 - MAC address 0 low register
        volatile uint32_t MAC_TIMESTP_CTRL;  ///< Offset: 0x700 - Time stamp control register
        volatile uint32_t SUBSECOND_INCR;  ///< Offset: 0x704 - Sub-second increment register
        volatile uint32_t SECONDS;  ///< Offset: 0x708 - System time seconds register
        volatile uint32_t NANOSECONDS;  ///< Offset: 0x70C - System time nanoseconds register
        volatile uint32_t SECONDSUPDATE;  ///< Offset: 0x710 - System time seconds update register
        volatile uint32_t NANOSECONDSUPDATE;  ///< Offset: 0x714 - System time nanoseconds update register
        volatile uint32_t ADDEND;  ///< Offset: 0x718 - Time stamp addend register
        volatile uint32_t TARGETSECONDS;  ///< Offset: 0x71C - Target time seconds register
        volatile uint32_t TARGETNANOSECONDS;  ///< Offset: 0x720 - Target time nanoseconds register
        volatile uint32_t HIGHWORD;  ///< Offset: 0x724 - System time higher word seconds register
        volatile uint32_t TIMESTAMPSTAT;  ///< Offset: 0x728 - Time stamp status register
        volatile uint32_t DMA_BUS_MODE;  ///< Offset: 0x1000 - Bus Mode Register
        volatile uint32_t DMA_TRANS_POLL_DEMAND;  ///< Offset: 0x1004 - Transmit poll demand register
        volatile uint32_t DMA_REC_POLL_DEMAND;  ///< Offset: 0x1008 - Receive poll demand register
        volatile uint32_t DMA_REC_DES_ADDR;  ///< Offset: 0x100C - Receive descriptor list address register
        volatile uint32_t DMA_TRANS_DES_ADDR;  ///< Offset: 0x1010 - Transmit descriptor list address register
        volatile uint32_t DMA_STAT;  ///< Offset: 0x1014 - Status register
        volatile uint32_t DMA_OP_MODE;  ///< Offset: 0x1018 - Operation mode register
        volatile uint32_t DMA_INT_EN;  ///< Offset: 0x101C - Interrupt enable register
        volatile uint32_t DMA_MFRM_BUFOF;  ///< Offset: 0x1020 - Missed frame and buffer overflow register
        volatile uint32_t DMA_REC_INT_WDT;  ///< Offset: 0x1024 - Receive interrupt watchdog timer register
        volatile uint32_t DMA_CURHOST_TRANS_DES;  ///< Offset: 0x1048 - Current host transmit descriptor register
        volatile uint32_t DMA_CURHOST_REC_DES;  ///< Offset: 0x104C - Current host receive descriptor register
        volatile uint32_t DMA_CURHOST_TRANS_BUF;  ///< Offset: 0x1050 - Current host transmit buffer address register
        volatile uint32_t DMA_CURHOST_REC_BUF;  ///< Offset: 0x1054 - Current host receive buffer address register
    };

    /// Peripheral instances
    inline Registers* ETHERNET = reinterpret_cast<Registers*>(ETHERNET_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t ATIMER_BASE = 0x40040000;
    constexpr uint32_t TIMER0_BASE = 0x40084000;
    constexpr uint32_t TIMER1_BASE = 0x40085000;
    constexpr uint32_t TIMER2_BASE = 0x400C3000;
    constexpr uint32_t TIMER3_BASE = 0x400C4000;
    constexpr uint32_t RITIMER_BASE = 0x400C0000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t DOWNCOUNTER;  ///< Offset: 0x00 - Downcounter register
        volatile uint32_t PRESET;  ///< Offset: 0x04 - Preset value register
        volatile uint32_t CLR_EN;  ///< Offset: 0xFD8 - Interrupt clear enable register
        volatile uint32_t SET_EN;  ///< Offset: 0xFDC - Interrupt set enable register
        volatile uint32_t STATUS;  ///< Offset: 0xFE0 - Status register
        volatile uint32_t ENABLE;  ///< Offset: 0xFE4 - Enable register
        volatile uint32_t CLR_STAT;  ///< Offset: 0xFE8 - Clear register
        volatile uint32_t SET_STAT;  ///< Offset: 0xFEC - Set register
    };

    /// Peripheral instances
    inline Registers* ATIMER = reinterpret_cast<Registers*>(ATIMER_BASE);
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER3 = reinterpret_cast<Registers*>(TIMER3_BASE);
    inline Registers* RITIMER = reinterpret_cast<Registers*>(RITIMER_BASE);

}

// ============================================================================
// REGFILE Peripheral
// ============================================================================

namespace regfile {
    /// Base addresses
    constexpr uint32_t REGFILE_BASE = 0x40041000;

    /// REGFILE Register structure
    struct Registers {
        volatile uint32_t REGFILE[%s];  ///< Offset: 0x00 - General purpose storage register
    };

    /// Peripheral instances
    inline Registers* REGFILE = reinterpret_cast<Registers*>(REGFILE_BASE);

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x40042000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t PD0_SLEEP0_HW_ENA;  ///< Offset: 0x00 - Hardware sleep event enable register
        volatile uint32_t PD0_SLEEP0_MODE;  ///< Offset: 0x1C - Sleep power mode register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

}

// ============================================================================
// CREG Peripheral
// ============================================================================

namespace creg {
    /// Base addresses
    constexpr uint32_t CREG_BASE = 0x40043000;

    /// CREG Register structure
    struct Registers {
        volatile uint32_t CREG0;  ///< Offset: 0x04 - Chip configuration register 32 kHz oscillator output and...
        volatile uint32_t M4MEMMAP;  ///< Offset: 0x100 - ARM Cortex-M4 memory mapping
        volatile uint32_t CREG5;  ///< Offset: 0x118 - Chip configuration register 5. Controls JTAG access.
        volatile uint32_t DMAMUX;  ///< Offset: 0x11C - DMA mux control
        volatile uint32_t FLASHCFGA;  ///< Offset: 0x120 - Flash accelerator configuration register for flash bank A
        volatile uint32_t FLASHCFGB;  ///< Offset: 0x124 - Flash accelerator configuration register for flash bank B
        volatile uint32_t ETBCFG;  ///< Offset: 0x128 - ETB RAM configuration
        volatile uint32_t CREG6;  ///< Offset: 0x12C - Chip configuration register 6. Controls multiple...
        volatile uint32_t M4TXEVENT;  ///< Offset: 0x130 - Cortex-M4 TXEV event clear
        volatile uint32_t CHIPID;  ///< Offset: 0x200 - Part ID
        volatile uint32_t M0SUBMEMMAP;  ///< Offset: 0x308 - ARM Cortex-M0SUB memory mapping
        volatile uint32_t M0SUBTXEVENT;  ///< Offset: 0x314 - Cortex-M0SUB TXEV event clear
        volatile uint32_t M0APPTXEVENT;  ///< Offset: 0x400 - Cortex-M0APP TXEV event clear
        volatile uint32_t M0APPMEMMAP;  ///< Offset: 0x404 - ARM Cortex-M0APP memory mapping
        volatile uint32_t USB0FLADJ;  ///< Offset: 0x500 - USB0 frame length adjust register
        volatile uint32_t USB1FLADJ;  ///< Offset: 0x600 - USB1 frame length adjust register
    };

    /// Peripheral instances
    inline Registers* CREG = reinterpret_cast<Registers*>(CREG_BASE);

}

// ============================================================================
// EVENTROUTER Peripheral
// ============================================================================

namespace eventrouter {
    /// Base addresses
    constexpr uint32_t EVENTROUTER_BASE = 0x40044000;

    /// EVENTROUTER Register structure
    struct Registers {
        volatile uint32_t HILO;  ///< Offset: 0x00 - Level configuration register
        volatile uint32_t EDGE;  ///< Offset: 0x04 - Edge configuration
        volatile uint32_t CLR_EN;  ///< Offset: 0xFD8 - Clear event enable register
        volatile uint32_t SET_EN;  ///< Offset: 0xFDC - Set event enable register
        volatile uint32_t STATUS;  ///< Offset: 0xFE0 - Event Status register
        volatile uint32_t ENABLE;  ///< Offset: 0xFE4 - Event Enable register
        volatile uint32_t CLR_STAT;  ///< Offset: 0xFE8 - Clear event status register
        volatile uint32_t SET_STAT;  ///< Offset: 0xFEC - Set event status register
    };

    /// Peripheral instances
    inline Registers* EVENTROUTER = reinterpret_cast<Registers*>(EVENTROUTER_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40046000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ILR;  ///< Offset: 0x00 - Interrupt Location Register
        volatile uint32_t CCR;  ///< Offset: 0x08 - Clock Control Register
        volatile uint32_t CIIR;  ///< Offset: 0x0C - Counter Increment Interrupt Register
        volatile uint32_t AMR;  ///< Offset: 0x10 - Alarm Mask Register
        volatile uint32_t CTIME0;  ///< Offset: 0x14 - Consolidated Time Register 0
        volatile uint32_t CTIME1;  ///< Offset: 0x18 - Consolidated Time Register 1
        volatile uint32_t CTIME2;  ///< Offset: 0x1C - Consolidated Time Register 2
        volatile uint32_t SEC;  ///< Offset: 0x20 - Seconds Register
        volatile uint32_t MIN;  ///< Offset: 0x24 - Minutes Register
        volatile uint32_t HRS;  ///< Offset: 0x28 - Hours Register
        volatile uint32_t DOM;  ///< Offset: 0x2C - Day of Month Register
        volatile uint32_t DOW;  ///< Offset: 0x30 - Day of Week Register
        volatile uint32_t DOY;  ///< Offset: 0x34 - Day of Year Register
        volatile uint32_t MONTH;  ///< Offset: 0x38 - Months Register
        volatile uint32_t YEAR;  ///< Offset: 0x3C - Years Register
        volatile uint32_t CALIBRATION;  ///< Offset: 0x40 - Calibration Value Register
        volatile uint32_t ASEC;  ///< Offset: 0x60 - Alarm value for Seconds
        volatile uint32_t AMIN;  ///< Offset: 0x64 - Alarm value for Minutes
        volatile uint32_t AHRS;  ///< Offset: 0x68 - Alarm value for Hours
        volatile uint32_t ADOM;  ///< Offset: 0x6C - Alarm value for Day of Month
        volatile uint32_t ADOW;  ///< Offset: 0x70 - Alarm value for Day of Week
        volatile uint32_t ADOY;  ///< Offset: 0x74 - Alarm value for Day of Year
        volatile uint32_t AMON;  ///< Offset: 0x78 - Alarm value for Months
        volatile uint32_t AYRS;  ///< Offset: 0x7C - Alarm value for Year
        volatile uint32_t ERCONTRO;  ///< Offset: 0x84 - Event Monitor/Recorder Control register. Contains bits...
        volatile uint32_t ERSTATUS;  ///< Offset: 0x80 - Event Monitor/Recorder Status register. Contains status...
        volatile uint32_t ERCOUNTERS;  ///< Offset: 0x88 - Event Monitor/Recorder Counters register. Allows reading...
        volatile uint32_t ERFIRSTSTAMP%s;  ///< Offset: 0x90 - Event Monitor/Recorder First Stamp register for channel...
        volatile uint32_t ERLASTSTAMP%s;  ///< Offset: 0xA0 - Event Monitor/Recorder Last Stamp register for channel...
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// CGU Peripheral
// ============================================================================

namespace cgu {
    /// Base addresses
    constexpr uint32_t CGU_BASE = 0x40050000;

    /// CGU Register structure
    struct Registers {
        volatile uint32_t FREQ_MON;  ///< Offset: 0x14 - Frequency monitor register
        volatile uint32_t XTAL_OSC_CTRL;  ///< Offset: 0x18 - Crystal oscillator control register
        volatile uint32_t PLL0USB_STAT;  ///< Offset: 0x1C - PLL0USB status register
        volatile uint32_t PLL0USB_CTRL;  ///< Offset: 0x20 - PLL0USB control register
        volatile uint32_t PLL0USB_MDIV;  ///< Offset: 0x24 - PLL0USB M-divider register
        volatile uint32_t PLL0USB_NP_DIV;  ///< Offset: 0x28 - PLL0USB N/P-divider register
        volatile uint32_t PLL0AUDIO_STAT;  ///< Offset: 0x2C - PLL0AUDIO status register
        volatile uint32_t PLL0AUDIO_CTRL;  ///< Offset: 0x30 - PLL0AUDIO control register
        volatile uint32_t PLL0AUDIO_MDIV;  ///< Offset: 0x34 - PLL0AUDIO M-divider register
        volatile uint32_t PLL0AUDIO_NP_DIV;  ///< Offset: 0x38 - PLL0AUDIO N/P-divider register
        volatile uint32_t PLL0AUDIO_FRAC;  ///< Offset: 0x3C - PLL0AUDIO fractional divider register
        volatile uint32_t PLL1_STAT;  ///< Offset: 0x40 - PLL1 status register
        volatile uint32_t PLL1_CTRL;  ///< Offset: 0x44 - PLL1 control register
        volatile uint32_t IDIVA_CTRL;  ///< Offset: 0x48 - Integer divider A control register
        volatile uint32_t IDIVB_CTRL;  ///< Offset: 0x4C - Integer divider B control register
        volatile uint32_t IDIVC_CTRL;  ///< Offset: 0x50 - Integer divider C control register
        volatile uint32_t IDIVD_CTRL;  ///< Offset: 0x54 - Integer divider D control register
        volatile uint32_t IDIVE_CTRL;  ///< Offset: 0x58 - Integer divider E control register
        volatile uint32_t BASE_SAFE_CLK;  ///< Offset: 0x5C - Output stage 0 control register for base clock BASE_SAFE_CLK
        volatile uint32_t BASE_USB0_CLK;  ///< Offset: 0x60 - Output stage 1 control register for base clock BASE_USB0_CLK
        volatile uint32_t BASE_PERIPH_CLK;  ///< Offset: 0x64 - Output stage 2 control register for base clock BASE_PERIPH_CLK
        volatile uint32_t BASE_USB1_CLK;  ///< Offset: 0x68 - Output stage 3 control register for base clock BASE_USB1_CLK
        volatile uint32_t BASE_M4_CLK;  ///< Offset: 0x6C - Output stage BASE_M4_CLK control register
        volatile uint32_t BASE_SPIFI_CLK;  ///< Offset: 0x70 - Output stage BASE_SPIFI_CLK control register
        volatile uint32_t BASE_SPI_CLK;  ///< Offset: 0x74 - Output stage BASE_SPI_CLK control register
        volatile uint32_t BASE_PHY_RX_CLK;  ///< Offset: 0x78 - Output stage BASE_PHY_RX_CLK control register
        volatile uint32_t BASE_PHY_TX_CLK;  ///< Offset: 0x7C - Output stage BASE_PHY_TX_CLK control register
        volatile uint32_t BASE_APB1_CLK;  ///< Offset: 0x80 - Output stage BASE_APB1_CLK control register
        volatile uint32_t BASE_APB3_CLK;  ///< Offset: 0x84 - Output stage BASE_APB3_CLK control register
        volatile uint32_t BASE_LCD_CLK;  ///< Offset: 0x88 - Output stage BASE_LCD_CLK control register
        volatile uint32_t BASE_SDIO_CLK;  ///< Offset: 0x90 - Output stage BASE_SDIO_CLK control register
        volatile uint32_t BASE_SSP0_CLK;  ///< Offset: 0x94 - Output stage BASE_SSP0_CLK control register
        volatile uint32_t BASE_SSP1_CLK;  ///< Offset: 0x98 - Output stage BASE_SSP1_CLK control register
        volatile uint32_t BASE_UART0_CLK;  ///< Offset: 0x9C - Output stage BASE_UART0_CLK control register
        volatile uint32_t BASE_UART1_CLK;  ///< Offset: 0xA0 - Output stage BASE_UART1_CLK control register
        volatile uint32_t BASE_UART2_CLK;  ///< Offset: 0xA4 - Output stage BASE_UART2_CLK control register
        volatile uint32_t BASE_UART3_CLK;  ///< Offset: 0xA8 - Output stage BASE_UART3_CLK control register
        volatile uint32_t BASE_OUT_CLK;  ///< Offset: 0xAC - Output stage 20 control register for base clock BASE_OUT_CLK
        volatile uint32_t BASE_AUDIO_CLK;  ///< Offset: 0xC0 - Output stage 25 control register for base clock BASE_AUDIO_CLK
        volatile uint32_t BASE_CGU_OUT0_CLK;  ///< Offset: 0xC4 - Output stage 25 control register for base clock BASE_CGU_OUT0_CLK
        volatile uint32_t BASE_CGU_OUT1_CLK;  ///< Offset: 0xC8 - Output stage 25 control register for base clock BASE_CGU_OUT1_CLK
    };

    /// Peripheral instances
    inline Registers* CGU = reinterpret_cast<Registers*>(CGU_BASE);

}

// ============================================================================
// CCU1 Peripheral
// ============================================================================

namespace ccu1 {
    /// Base addresses
    constexpr uint32_t CCU1_BASE = 0x40051000;

    /// CCU1 Register structure
    struct Registers {
        volatile uint32_t PM;  ///< Offset: 0x00 - CCU1 power mode register
        volatile uint32_t BASE_STAT;  ///< Offset: 0x04 - CCU1 base clocks status register
        volatile uint32_t CLK_APB3_BUS_CFG;  ///< Offset: 0x100 - CLK_APB3_BUS clock configuration register
        volatile uint32_t CLK_APB3_I2C1_CFG;  ///< Offset: 0x108 - CLK_APB3_I2C1 clock configuration register
        volatile uint32_t CLK_APB3_DAC_CFG;  ///< Offset: 0x110 - CLK_APB3_DAC clock configuration register
        volatile uint32_t CLK_APB3_ADC0_CFG;  ///< Offset: 0x118 - CLK_APB3_ADC0 clock configuration register
        volatile uint32_t CLK_APB3_ADC1_CFG;  ///< Offset: 0x120 - CLK_APB3_ADC1 clock configuration register
        volatile uint32_t CLK_APB3_CAN0_CFG;  ///< Offset: 0x128 - CLK_APB3_CAN0 clock configuration register
        volatile uint32_t CLK_APB1_BUS_CFG;  ///< Offset: 0x200 - CLK_APB1_BUS clock configuration register
        volatile uint32_t CLK_APB1_MOTOCONPWM_CFG;  ///< Offset: 0x208 - CLK_APB1_MOTOCONPWM clock configuration register
        volatile uint32_t CLK_APB1_I2C0_CFG;  ///< Offset: 0x210 - CLK_ABP1_I2C0 clock configuration register
        volatile uint32_t CLK_APB1_I2S_CFG;  ///< Offset: 0x218 - CLK_APB1_I2S clock configuration register
        volatile uint32_t CLK_APB1_CAN1_CFG;  ///< Offset: 0x220 - CLK_APB1_CAN1 clock configuration register
        volatile uint32_t CLK_SPIFI_CFG;  ///< Offset: 0x300 - CLK_SPIFI clock configuration register
        volatile uint32_t CLK_M4_BUS_CFG;  ///< Offset: 0x400 - CLK_M4_BUS clock configuration register
        volatile uint32_t CLK_M4_SPIFI_CFG;  ///< Offset: 0x408 - CLK_M4_SPIFI clock configuration register
        volatile uint32_t CLK_M4_GPIO_CFG;  ///< Offset: 0x410 - CLK_M4_GPIO clock configuration register
        volatile uint32_t CLK_M4_LCD_CFG;  ///< Offset: 0x418 - CLK_M4_LCD clock configuration register
        volatile uint32_t CLK_M4_ETHERNET_CFG;  ///< Offset: 0x420 - CLK_M4_ETHERNET clock configuration register
        volatile uint32_t CLK_M4_USB0_CFG;  ///< Offset: 0x428 - CLK_M4_USB0 clock configuration register
        volatile uint32_t CLK_M4_EMC_CFG;  ///< Offset: 0x430 - CLK_M4_EMC clock configuration register
        volatile uint32_t CLK_M4_SDIO_CFG;  ///< Offset: 0x438 - CLK_M4_SDIO clock configuration register
        volatile uint32_t CLK_M4_DMA_CFG;  ///< Offset: 0x440 - CLK_M4_DMA clock configuration register
        volatile uint32_t CLK_M4_M4CORE_CFG;  ///< Offset: 0x448 - CLK_M4_M4CORE clock configuration register
        volatile uint32_t CLK_M4_SCT_CFG;  ///< Offset: 0x468 - CLK_M4_SCT clock configuration register
        volatile uint32_t CLK_M4_USB1_CFG;  ///< Offset: 0x470 - CLK_M4_USB1 clock configuration register
        volatile uint32_t CLK_M4_EMCDIV_CFG;  ///< Offset: 0x478 - CLK_M4_EMCDIV clock configuration register
        volatile uint32_t CLK_M4_FLASHA_CFG;  ///< Offset: 0x480 - CLK_M4_FLASHA clock configuration register
        volatile uint32_t CLK_M4_FLASHB_CFG;  ///< Offset: 0x488 - CLK_M4_FLASHB clock configuration register
        volatile uint32_t CLK_M4_M0APP_CFG;  ///< Offset: 0x490 - CLK_M0APP_CFG clock configuration register
        volatile uint32_t CLK_M4_ADCHS_CFG;  ///< Offset: 0x498 - CLK_ADCHS_CFG clock configuration register
        volatile uint32_t CLK_M4_EEPROM_CFG;  ///< Offset: 0x4A0 - CLK_EEPROM_CFG clock configuration register
        volatile uint32_t CLK_M4_WWDT_CFG;  ///< Offset: 0x500 - CLK_M4_WWDT clock configuration register
        volatile uint32_t CLK_M4_USART0_CFG;  ///< Offset: 0x508 - CLK_M4_USART0 clock configuration register
        volatile uint32_t CLK_M4_UART1_CFG;  ///< Offset: 0x510 - CLK_M4_UART1 clock configuration register
        volatile uint32_t CLK_M4_SSP0_CFG;  ///< Offset: 0x518 - CLK_M4_SSP0 clock configuration register
        volatile uint32_t CLK_M4_TIMER0_CFG;  ///< Offset: 0x520 - CLK_M4_TIMER0 clock configuration register
        volatile uint32_t CLK_M4_TIMER1_CFG;  ///< Offset: 0x528 - CLK_M4_TIMER1clock configuration register
        volatile uint32_t CLK_M4_SCU_CFG;  ///< Offset: 0x530 - CLK_M4_SCU clock configuration register
        volatile uint32_t CLK_M4_CREG_CFG;  ///< Offset: 0x538 - CLK_M4_CREGclock configuration register
        volatile uint32_t CLK_M4_RITIMER_CFG;  ///< Offset: 0x600 - CLK_M4_RITIMER clock configuration register
        volatile uint32_t CLK_M4_USART2_CFG;  ///< Offset: 0x608 - CLK_M4_USART2 clock configuration register
        volatile uint32_t CLK_M4_USART3_CFG;  ///< Offset: 0x610 - CLK_M4_USART3 clock configuration register
        volatile uint32_t CLK_M4_TIMER2_CFG;  ///< Offset: 0x618 - CLK_M4_TIMER2 clock configuration register
        volatile uint32_t CLK_M4_TIMER3_CFG;  ///< Offset: 0x620 - CLK_M4_TIMER3 clock configuration register
        volatile uint32_t CLK_M4_SSP1_CFG;  ///< Offset: 0x628 - CLK_M4_SSP1 clock configuration register
        volatile uint32_t CLK_M4_QEI_CFG;  ///< Offset: 0x630 - CLK_M4_QEIclock configuration register
        volatile uint32_t CLK_PERIPH_BUS_CFG;  ///< Offset: 0x700 - CLK_PERIPH_BUS_CFG clock configuration register
        volatile uint32_t CLK_PERIPH_CORE_CFG;  ///< Offset: 0x710 - CLK_PERIPH_CORE_CFG clock configuration register
        volatile uint32_t CLK_PERIPH_SGPIO_CFG;  ///< Offset: 0x718 - CLK_PERIPH_SGPIO_CFG clock configuration register
        volatile uint32_t CLK_USB0_CFG;  ///< Offset: 0x800 - CLK_M4_USB0 clock configuration register
        volatile uint32_t CLK_USB1_CFG;  ///< Offset: 0x900 - CLK_USB1 clock configuration register
        volatile uint32_t CLK_SPI_CFG;  ///< Offset: 0xA00 - CLK_SPI clock configuration register
        volatile uint32_t CLK_ADCHS_CFG;  ///< Offset: 0xB00 - CLK_ADCHS clock configuration register
        volatile uint32_t CLK_APB3_BUS_STAT;  ///< Offset: 0x104 - CLK_APB3_BUS clock status register
        volatile uint32_t CLK_APB3_I2C1_STAT;  ///< Offset: 0x10C - CLK_APB3_I2C1 clock status register
        volatile uint32_t CLK_APB3_DAC_STAT;  ///< Offset: 0x114 - CLK_APB3_DAC clock status register
        volatile uint32_t CLK_APB3_ADC0_STAT;  ///< Offset: 0x11C - CLK_APB3_ADC0 clock status register
        volatile uint32_t CLK_APB3_ADC1_STAT;  ///< Offset: 0x124 - CLK_APB3_ADC1 clock status register
        volatile uint32_t CLK_APB3_CAN0_STAT;  ///< Offset: 0x12C - CLK_APB3_CAN0 clock status register
        volatile uint32_t CLK_APB1_BUS_STAT;  ///< Offset: 0x204 - CLK_APB1_BUS clock status register
        volatile uint32_t CLK_APB1_MOTOCONPWM_STAT;  ///< Offset: 0x20C - CLK_APB1_MOTOCONPWM clock status register
        volatile uint32_t CLK_APB1_I2C0_STAT;  ///< Offset: 0x214 - CLK_APB1_I2C0 clock status register
        volatile uint32_t CLK_APB1_I2S_STAT;  ///< Offset: 0x21C - CLK_APB1_I2S clock status register
        volatile uint32_t CLK_APB1_CAN1_STAT;  ///< Offset: 0x224 - CLK_APB1_CAN1 clock status register
        volatile uint32_t CLK_SPIFI_STAT;  ///< Offset: 0x304 - CLK_APB1_SPIFI clock status register
        volatile uint32_t CLK_M4_BUS_STAT;  ///< Offset: 0x404 - CLK_M4_BUSclock status register
        volatile uint32_t CLK_M4_SPIFI_STAT;  ///< Offset: 0x40C - CLK_M4_SPIFI clock status register
        volatile uint32_t CLK_M4_GPIO_STAT;  ///< Offset: 0x414 - CLK_M4_GPIO clock status register
        volatile uint32_t CLK_M4_LCD_STAT;  ///< Offset: 0x41C - CLK_M4_LCD clock status register
        volatile uint32_t CLK_M4_ETHERNET_STAT;  ///< Offset: 0x424 - CLK_M4_ETHERNET clock status register
        volatile uint32_t CLK_M4_USB0_STAT;  ///< Offset: 0x42C - CLK_M4_USB0 clock status register
        volatile uint32_t CLK_M4_EMC_STAT;  ///< Offset: 0x434 - CLK_M4_EMC clock status register
        volatile uint32_t CLK_M4_SDIO_STAT;  ///< Offset: 0x43C - CLK_M4_SDIO clock status register
        volatile uint32_t CLK_M4_DMA_STAT;  ///< Offset: 0x444 - CLK_M4_DMA clock status register
        volatile uint32_t CLK_M4_M4CORE_STAT;  ///< Offset: 0x44C - CLK_M4_M3CORE clock status register
        volatile uint32_t CLK_M4_SCT_STAT;  ///< Offset: 0x46C - CLK_M4_SCT clock status register
        volatile uint32_t CLK_M4_USB1_STAT;  ///< Offset: 0x474 - CLK_M4_USB1 clock status register
        volatile uint32_t CLK_M4_EMCDIV_STAT;  ///< Offset: 0x47C - CLK_M4_EMCDIV clock status register
        volatile uint32_t CLK_M4_FLASHA_STAT;  ///< Offset: 0x484 - CLK_M4_FLASHA clock status register
        volatile uint32_t CLK_M4_FLASHB_STAT;  ///< Offset: 0x48C - CLK_M4_FLASHB clock status register
        volatile uint32_t CLK_M4_M0APP_STAT;  ///< Offset: 0x494 - CLK_M4_MOAPP clock status register
        volatile uint32_t CLK_M4_ADCHS_STAT;  ///< Offset: 0x49C - CLK_M4_ADCHS clock status register
        volatile uint32_t CLK_M4_EEPROM_STAT;  ///< Offset: 0x4A4 - CLK_M4_EEPROM clock status register
        volatile uint32_t CLK_M4_WWDT_STAT;  ///< Offset: 0x504 - CLK_M4_WWDT clock status register
        volatile uint32_t CLK_M4_USART0_STAT;  ///< Offset: 0x50C - CLK_M4_USART0 clock status register
        volatile uint32_t CLK_M4_UART1_STAT;  ///< Offset: 0x514 - CLK_M4_UART1 clock status register
        volatile uint32_t CLK_M4_SSP0_STAT;  ///< Offset: 0x51C - CLK_M4_SSP0 clock status register
        volatile uint32_t CLK_M4_TIMER0_STAT;  ///< Offset: 0x524 - CLK_M4_TIMER0 clock status register
        volatile uint32_t CLK_M4_TIMER1_STAT;  ///< Offset: 0x52C - CLK_M4_TIMER1 clock status register
        volatile uint32_t CLK_M4_SCU_STAT;  ///< Offset: 0x534 - CLK_SCU_XXX clock status register
        volatile uint32_t CLK_M4_CREG_STAT;  ///< Offset: 0x53C - CLK_M4_CREG clock status register
        volatile uint32_t CLK_M4_RITIMER_STAT;  ///< Offset: 0x604 - CLK_M4_RITIMER clock status register
        volatile uint32_t CLK_M4_USART2_STAT;  ///< Offset: 0x60C - CLK_M4_USART2 clock status register
        volatile uint32_t CLK_M4_USART3_STAT;  ///< Offset: 0x614 - CLK_M4_USART3 clock status register
        volatile uint32_t CLK_M4_TIMER2_STAT;  ///< Offset: 0x61C - CLK_M4_TIMER2 clock status register
        volatile uint32_t CLK_M4_TIMER3_STAT;  ///< Offset: 0x624 - CLK_M4_TIMER3 clock status register
        volatile uint32_t CLK_M4_SSP1_STAT;  ///< Offset: 0x62C - CLK_M4_SSP1 clock status register
        volatile uint32_t CLK_M4_QEI_STAT;  ///< Offset: 0x634 - CLK_M4_QEI clock status register
        volatile uint32_t CLK_PERIPH_BUS_STAT;  ///< Offset: 0x704 - CLK_PERIPH_BUS_STAT clock status register
        volatile uint32_t CLK_PERIPH_CORE_STAT;  ///< Offset: 0x714 - CLK_CORE_BUS_STAT clock status register
        volatile uint32_t CLK_PERIPH_SGPIO_STAT;  ///< Offset: 0x71C - CLK_CORE_SGPIO_STAT clock status register
        volatile uint32_t CLK_USB0_STAT;  ///< Offset: 0x804 - CLK_USB0 clock status register
        volatile uint32_t CLK_USB1_STAT;  ///< Offset: 0x904 - CLK_USB1 clock status register
        volatile uint32_t CLK_SPI_STAT;  ///< Offset: 0xA04 - CLK_SPI clock status register
        volatile uint32_t CLK_ADCHS_STAT;  ///< Offset: 0xB04 - CLK_ADCHS clock status register
    };

    /// Peripheral instances
    inline Registers* CCU1 = reinterpret_cast<Registers*>(CCU1_BASE);

}

// ============================================================================
// CCU2 Peripheral
// ============================================================================

namespace ccu2 {
    /// Base addresses
    constexpr uint32_t CCU2_BASE = 0x40052000;

    /// CCU2 Register structure
    struct Registers {
        volatile uint32_t PM;  ///< Offset: 0x00 - Power mode register
        volatile uint32_t BASE_STAT;  ///< Offset: 0x04 - CCU base clocks status register
        volatile uint32_t CLK_AUDIO_CFG;  ///< Offset: 0x100 - CLK_AUDIO clock configuration register
        volatile uint32_t CLK_APB2_USART3_CFG;  ///< Offset: 0x200 - CLK_APB2_USART3 clock configuration register
        volatile uint32_t CLK_APB2_USART2_CFG;  ///< Offset: 0x300 - CLK_APB2_USART2 clock configuration register
        volatile uint32_t CLK_APB0_UART1_BUS_CFG;  ///< Offset: 0x400 - CLK_APB2_UART1 clock configuration register
        volatile uint32_t CLK_APB0_USART0_CFG;  ///< Offset: 0x500 - CLK_APB2_USART0 clock configuration register
        volatile uint32_t CLK_APB0_SSP0_CFG;  ///< Offset: 0x700 - CLK_APB0_SSP0 clock configuration register
        volatile uint32_t CLK_APB2_SSP1_CFG;  ///< Offset: 0x600 - CLK_APB2_SSP1 clock configuration register
        volatile uint32_t CLK_SDIO_CFG;  ///< Offset: 0x800 - CLK_SDIO clock configuration register
        volatile uint32_t CLK_AUDIO_STAT;  ///< Offset: 0x104 - CLK_AUDIO clock status register
        volatile uint32_t CLK_APB2_USART3_STAT;  ///< Offset: 0x204 - CLK_APB2_USART3 clock status register
        volatile uint32_t CLK_APB2_USART2_STAT;  ///< Offset: 0x304 - CLK_APB2_USART clock status register
        volatile uint32_t CLK_APB0_UART1_STAT;  ///< Offset: 0x404 - CLK_APB0_UART1 clock status register
        volatile uint32_t CLK_APB0_USART0_STAT;  ///< Offset: 0x504 - CLK_APB0_USART0 clock status register
        volatile uint32_t CLK_APB2_SSP1_STAT;  ///< Offset: 0x604 - CLK_APB2_SSP1 clock status register
        volatile uint32_t CLK_APB0_SSP0_STAT;  ///< Offset: 0x704 - CLK_APB0_SSP0 clock status register
        volatile uint32_t CLK_SDIO_STAT;  ///< Offset: 0x804 - CLK_SDIO clock status register
    };

    /// Peripheral instances
    inline Registers* CCU2 = reinterpret_cast<Registers*>(CCU2_BASE);

}

// ============================================================================
// RGU Peripheral
// ============================================================================

namespace rgu {
    /// Base addresses
    constexpr uint32_t RGU_BASE = 0x40053000;

    /// RGU Register structure
    struct Registers {
        volatile uint32_t RESET_CTRL0;  ///< Offset: 0x100 - Reset control register 0
        volatile uint32_t RESET_CTRL1;  ///< Offset: 0x104 - Reset control register 1
        volatile uint32_t RESET_STATUS0;  ///< Offset: 0x110 - Reset status register 0
        volatile uint32_t RESET_STATUS1;  ///< Offset: 0x114 - Reset status register 1
        volatile uint32_t RESET_STATUS2;  ///< Offset: 0x118 - Reset status register 2
        volatile uint32_t RESET_STATUS3;  ///< Offset: 0x11C - Reset status register 3
        volatile uint32_t RESET_ACTIVE_STATUS0;  ///< Offset: 0x150 - Reset active status register 0
        volatile uint32_t RESET_ACTIVE_STATUS1;  ///< Offset: 0x154 - Reset active status register 1
        volatile uint32_t RESET_EXT_STAT1;  ///< Offset: 0x404 - Reset external status register 1 for PERIPH_RST
        volatile uint32_t RESET_EXT_STAT2;  ///< Offset: 0x408 - Reset external status register 2 for MASTER_RST
        volatile uint32_t RESET_EXT_STAT5;  ///< Offset: 0x414 - Reset external status register 5 for CREG_RST
        volatile uint32_t RESET_EXT_STAT8;  ///< Offset: 0x420 - Reset external status register
        volatile uint32_t RESET_EXT_STAT9;  ///< Offset: 0x424 - Reset external status register
        volatile uint32_t RESET_EXT_STAT12;  ///< Offset: 0x430 - Reset external status register
        volatile uint32_t RESET_EXT_STAT13;  ///< Offset: 0x434 - Reset external status register
        volatile uint32_t RESET_EXT_STAT16;  ///< Offset: 0x440 - Reset external status register
        volatile uint32_t RESET_EXT_STAT17;  ///< Offset: 0x444 - Reset external status register
        volatile uint32_t RESET_EXT_STAT18;  ///< Offset: 0x448 - Reset external status register
        volatile uint32_t RESET_EXT_STAT19;  ///< Offset: 0x44C - Reset external status register
        volatile uint32_t RESET_EXT_STAT20;  ///< Offset: 0x450 - Reset external status register
        volatile uint32_t RESET_EXT_STAT21;  ///< Offset: 0x454 - Reset external status register
        volatile uint32_t RESET_EXT_STAT22;  ///< Offset: 0x458 - Reset external status register
        volatile uint32_t RESET_EXT_STAT25;  ///< Offset: 0x464 - Reset external status register
        volatile uint32_t RESET_EXT_STAT27;  ///< Offset: 0x46C - Reset external status register
        volatile uint32_t RESET_EXT_STAT28;  ///< Offset: 0x470 - Reset external status register
        volatile uint32_t RESET_EXT_STAT29;  ///< Offset: 0x474 - Reset external status register
        volatile uint32_t RESET_EXT_STAT32;  ///< Offset: 0x480 - Reset external status register
        volatile uint32_t RESET_EXT_STAT33;  ///< Offset: 0x484 - Reset external status register
        volatile uint32_t RESET_EXT_STAT34;  ///< Offset: 0x488 - Reset external status register
        volatile uint32_t RESET_EXT_STAT35;  ///< Offset: 0x48C - Reset external status register
        volatile uint32_t RESET_EXT_STAT36;  ///< Offset: 0x490 - Reset external status register
        volatile uint32_t RESET_EXT_STAT37;  ///< Offset: 0x494 - Reset external status register
        volatile uint32_t RESET_EXT_STAT38;  ///< Offset: 0x498 - Reset external status register
        volatile uint32_t RESET_EXT_STAT39;  ///< Offset: 0x49C - Reset external status register
        volatile uint32_t RESET_EXT_STAT40;  ///< Offset: 0x4A0 - Reset external status register
        volatile uint32_t RESET_EXT_STAT41;  ///< Offset: 0x4A4 - Reset external status register
        volatile uint32_t RESET_EXT_STAT42;  ///< Offset: 0x4A8 - Reset external status register
        volatile uint32_t RESET_EXT_STAT44;  ///< Offset: 0x4B0 - Reset external status register
        volatile uint32_t RESET_EXT_STAT45;  ///< Offset: 0x4B4 - Reset external status register
        volatile uint32_t RESET_EXT_STAT46;  ///< Offset: 0x4B8 - Reset external status register
        volatile uint32_t RESET_EXT_STAT47;  ///< Offset: 0x4BC - Reset external status register
        volatile uint32_t RESET_EXT_STAT48;  ///< Offset: 0x4C0 - Reset external status register
        volatile uint32_t RESET_EXT_STAT49;  ///< Offset: 0x4C4 - Reset external status register
        volatile uint32_t RESET_EXT_STAT50;  ///< Offset: 0x4C8 - Reset external status register
        volatile uint32_t RESET_EXT_STAT51;  ///< Offset: 0x4CC - Reset external status register
        volatile uint32_t RESET_EXT_STAT52;  ///< Offset: 0x4D0 - Reset external status register
        volatile uint32_t RESET_EXT_STAT53;  ///< Offset: 0x4D4 - Reset external status register
        volatile uint32_t RESET_EXT_STAT54;  ///< Offset: 0x4D8 - Reset external status register
        volatile uint32_t RESET_EXT_STAT55;  ///< Offset: 0x4DC - Reset external status register
        volatile uint32_t RESET_EXT_STAT56;  ///< Offset: 0x4E0 - Reset external status register
        volatile uint32_t RESET_EXT_STAT57;  ///< Offset: 0x4E4 - Reset external status register
        volatile uint32_t RESET_EXT_STAT58;  ///< Offset: 0x4E8 - Reset external status register
        volatile uint32_t RESET_EXT_STAT60;  ///< Offset: 0x4F0 - Reset external status register
    };

    /// Peripheral instances
    inline Registers* RGU = reinterpret_cast<Registers*>(RGU_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WWDT_BASE = 0x40080000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register contains the basic...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. This register...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This register reads out...
        volatile uint32_t WARNINT;  ///< Offset: 0x14 - Watchdog warning interrupt register. This register...
        volatile uint32_t WINDOW;  ///< Offset: 0x18 - Watchdog timer window register. This register contains...
    };

    /// Peripheral instances
    inline Registers* WWDT = reinterpret_cast<Registers*>(WWDT_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40081000;
    constexpr uint32_t USART2_BASE = 0x400C1000;
    constexpr uint32_t USART3_BASE = 0x400C2000;
    constexpr uint32_t UART1_BASE = 0x40082000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t RBR;  ///< Offset: 0x00 - Receiver Buffer Register. Contains the next received...
        volatile uint32_t THR;  ///< Offset: 0x00 - Transmit Holding Register. The next character to be...
        volatile uint32_t DLL;  ///< Offset: 0x00 - Divisor Latch LSB. Least significant byte of the baud...
        volatile uint32_t DLM;  ///< Offset: 0x04 - Divisor Latch MSB. Most significant byte of the baud...
        volatile uint32_t IER;  ///< Offset: 0x04 - Interrupt Enable Register. Contains individual interrupt...
        volatile uint32_t IIR;  ///< Offset: 0x08 - Interrupt ID Register. Identifies which interrupt(s) are pending.
        volatile uint32_t FCR;  ///< Offset: 0x08 - FIFO Control Register. Controls USART FIFO usage and modes.
        volatile uint32_t LCR;  ///< Offset: 0x0C - Line Control Register. Contains controls for frame...
        volatile uint32_t LSR;  ///< Offset: 0x14 - Line Status Register. Contains flags for transmit and...
        volatile uint32_t SCR;  ///< Offset: 0x1C - Scratch Pad Register. Eight-bit temporary storage for software.
        volatile uint32_t ACR;  ///< Offset: 0x20 - Auto-baud Control Register. Contains controls for the...
        volatile uint32_t ICR;  ///< Offset: 0x24 - IrDA control register (USART3 only)
        volatile uint32_t FDR;  ///< Offset: 0x28 - Fractional Divider Register. Generates a clock input for...
        volatile uint32_t OSR;  ///< Offset: 0x2C - Oversampling Register. Controls the degree of...
        volatile uint32_t HDEN;  ///< Offset: 0x40 - Half-duplex enable Register
        volatile uint32_t SCICTRL;  ///< Offset: 0x48 - Smart card interface control register
        volatile uint32_t RS485CTRL;  ///< Offset: 0x4C - RS-485/EIA-485 Control. Contains controls to configure...
        volatile uint32_t RS485ADRMATCH;  ///< Offset: 0x50 - RS-485/EIA-485 address match. Contains the address match...
        volatile uint32_t RS485DLY;  ///< Offset: 0x54 - RS-485/EIA-485 direction control delay.
        volatile uint32_t SYNCCTRL;  ///< Offset: 0x58 - Synchronous mode control register.
        volatile uint32_t TER;  ///< Offset: 0x5C - Transmit Enable Register. Turns off USART transmitter...
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

}

// ============================================================================
// SSP0 Peripheral
// ============================================================================

namespace ssp0 {
    /// Base addresses
    constexpr uint32_t SSP0_BASE = 0x40083000;

    /// SSP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - Control Register 0. Selects the serial clock rate, bus...
        volatile uint32_t CR1;  ///< Offset: 0x04 - Control Register 1. Selects master/slave and other modes.
        volatile uint32_t DR;  ///< Offset: 0x08 - Data Register. Writes fill the transmit FIFO, and reads...
        volatile uint32_t SR;  ///< Offset: 0x0C - Status Register
        volatile uint32_t CPSR;  ///< Offset: 0x10 - Clock Prescale Register
        volatile uint32_t IMSC;  ///< Offset: 0x14 - Interrupt Mask Set and Clear Register
        volatile uint32_t RIS;  ///< Offset: 0x18 - Raw Interrupt Status Register
        volatile uint32_t MIS;  ///< Offset: 0x1C - Masked Interrupt Status Register
        volatile uint32_t ICR;  ///< Offset: 0x20 - SSPICR Interrupt Clear Register
        volatile uint32_t DMACR;  ///< Offset: 0x24 - SSP0 DMA control register
    };

    /// Peripheral instances
    inline Registers* SSP0 = reinterpret_cast<Registers*>(SSP0_BASE);

}

// ============================================================================
// SSP1 Peripheral
// ============================================================================

namespace ssp1 {
    /// Base addresses
    constexpr uint32_t SSP1_BASE = 0x400C5000;

    /// SSP1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSP1 = reinterpret_cast<Registers*>(SSP1_BASE);

}

// ============================================================================
// SCU Peripheral
// ============================================================================

namespace scu {
    /// Base addresses
    constexpr uint32_t SCU_BASE = 0x40086000;

    /// SCU Register structure
    struct Registers {
        volatile uint32_t SFSP0_%s;  ///< Offset: 0x00 - Pin configuration register for pins P0
        volatile uint32_t SFSP1_%s;  ///< Offset: 0xC8 - Pin configuration register for pins P1
        volatile uint32_t SFSP1_17;  ///< Offset: 0xC4 - Pin configuration register for pins P1_17
        volatile uint32_t SFSP2_%s;  ///< Offset: 0x118 - Pin configuration register for pins P2
        volatile uint32_t SFSP3_%s;  ///< Offset: 0x190 - Pin configuration register for pins P3
        volatile uint32_t SFSP3_3;  ///< Offset: 0x18C - Pin configuration register for pins P3
        volatile uint32_t SFSP4_%s;  ///< Offset: 0x200 - Pin configuration register for pins P4
        volatile uint32_t SFSP5_%s;  ///< Offset: 0x280 - Pin configuration register for pins P5
        volatile uint32_t SFSP6_%s;  ///< Offset: 0x300 - Pin configuration register for pins P6
        volatile uint32_t SFSP7_%s;  ///< Offset: 0x380 - Pin configuration register for pins P7
        volatile uint32_t SFSP8_%s;  ///< Offset: 0x40C - Pin configuration register for pins P8
        volatile uint32_t SFSP9_%s;  ///< Offset: 0x480 - Pin configuration register for pins P9
        volatile uint32_t SFSPA_0;  ///< Offset: 0x500 - Pin configuration register for pins PA
        volatile uint32_t SFSPA_%s;  ///< Offset: 0x504 - Pin configuration register for pins PA
        volatile uint32_t SFSPA_4;  ///< Offset: 0x510 - Pin configuration register for pins PA
        volatile uint32_t SFSPB_%s;  ///< Offset: 0x580 - Pin configuration register for pins PB
        volatile uint32_t SFSPC_%s;  ///< Offset: 0x600 - Pin configuration register for pins PC
        volatile uint32_t SFSPD_%s;  ///< Offset: 0x680 - Pin configuration register for pins PD
        volatile uint32_t SFSPE_%s;  ///< Offset: 0x700 - Pin configuration register for pins PE
        volatile uint32_t SFSPF_%s;  ///< Offset: 0x780 - Pin configuration register for pins PF
        volatile uint32_t SFSCLK_%s;  ///< Offset: 0xC00 - Pin configuration register for pins CLK
        volatile uint32_t SFSUSB;  ///< Offset: 0xC80 - Pin configuration register for pins USB1_DM and USB1_DP
        volatile uint32_t SFSI2C0;  ///< Offset: 0xC84 - Pin configuration register for I2C0-bus pins
        volatile uint32_t ENAIO0;  ///< Offset: 0xC88 - ADC0 function select register
        volatile uint32_t ENAIO1;  ///< Offset: 0xC8C - ADC1 function select register
        volatile uint32_t ENAIO2;  ///< Offset: 0xC90 - Analog function select register
        volatile uint32_t EMCDELAYCLK;  ///< Offset: 0xD00 - EMC clock delay register
        volatile uint32_t SDDELAY;  ///< Offset: 0xD80 - SD/MMC sample and drive delay register
        volatile uint32_t PINTSEL0;  ///< Offset: 0xE00 - Pin interrupt select register for pin interrupts 0 to 3.
        volatile uint32_t PINTSEL1;  ///< Offset: 0xE04 - Pin interrupt select register for pin interrupts 4 to 7.
    };

    /// Peripheral instances
    inline Registers* SCU = reinterpret_cast<Registers*>(SCU_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_PIN_INT_BASE = 0x40087000;
    constexpr uint32_t GPIO_GROUP_INT0_BASE = 0x40088000;
    constexpr uint32_t GPIO_GROUP_INT1_BASE = 0x40089000;
    constexpr uint32_t GPIO_PORT_BASE = 0x400F4000;
    constexpr uint32_t SGPIO_BASE = 0x40101000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t ISEL;  ///< Offset: 0x00 - Pin Interrupt Mode register
        volatile uint32_t IENR;  ///< Offset: 0x04 - Pin Interrupt Enable (Rising) register
        volatile uint32_t SIENR;  ///< Offset: 0x08 - Set Pin Interrupt Enable (Rising) register
        volatile uint32_t CIENR;  ///< Offset: 0x0C - Clear Pin Interrupt Enable (Rising) register
        volatile uint32_t IENF;  ///< Offset: 0x10 - Pin Interrupt Enable Falling Edge / Active Level register
        volatile uint32_t SIENF;  ///< Offset: 0x14 - Set Pin Interrupt Enable Falling Edge / Active Level register
        volatile uint32_t CIENF;  ///< Offset: 0x18 - Clear Pin Interrupt Enable Falling Edge / Active Level address
        volatile uint32_t RISE;  ///< Offset: 0x1C - Pin Interrupt Rising Edge register
        volatile uint32_t FALL;  ///< Offset: 0x20 - Pin Interrupt Falling Edge register
        volatile uint32_t IST;  ///< Offset: 0x24 - Pin Interrupt Status register
    };

    /// Peripheral instances
    inline Registers* GPIO_PIN_INT = reinterpret_cast<Registers*>(GPIO_PIN_INT_BASE);
    inline Registers* GPIO_GROUP_INT0 = reinterpret_cast<Registers*>(GPIO_GROUP_INT0_BASE);
    inline Registers* GPIO_GROUP_INT1 = reinterpret_cast<Registers*>(GPIO_GROUP_INT1_BASE);
    inline Registers* GPIO_PORT = reinterpret_cast<Registers*>(GPIO_PORT_BASE);
    inline Registers* SGPIO = reinterpret_cast<Registers*>(SGPIO_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t MCPWM_BASE = 0x400A0000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CON;  ///< Offset: 0x00 - PWM Control read address
        volatile uint32_t CON_SET;  ///< Offset: 0x04 - PWM Control set address
        volatile uint32_t CON_CLR;  ///< Offset: 0x08 - PWM Control clear address
        volatile uint32_t CAPCON;  ///< Offset: 0x0C - Capture Control read address
        volatile uint32_t CAPCON_SET;  ///< Offset: 0x10 - Capture Control set address
        volatile uint32_t CAPCON_CLR;  ///< Offset: 0x14 - Event Control clear address
        volatile uint32_t TC%s;  ///< Offset: 0x18 - Timer Counter register
        volatile uint32_t LIM%s;  ///< Offset: 0x24 - Limit register
        volatile uint32_t MAT%s;  ///< Offset: 0x30 - Match register
        volatile uint32_t DT;  ///< Offset: 0x3C - Dead time register
        volatile uint32_t CCP;  ///< Offset: 0x40 - Communication Pattern register
        volatile uint32_t CAP%s;  ///< Offset: 0x44 - Capture register
        volatile uint32_t INTEN;  ///< Offset: 0x50 - Interrupt Enable read address
        volatile uint32_t INTEN_SET;  ///< Offset: 0x54 - Interrupt Enable set address
        volatile uint32_t INTEN_CLR;  ///< Offset: 0x58 - Interrupt Enable clear address
        volatile uint32_t INTF;  ///< Offset: 0x68 - Interrupt flags read address
        volatile uint32_t INTF_SET;  ///< Offset: 0x6C - Interrupt flags set address
        volatile uint32_t INTF_CLR;  ///< Offset: 0x70 - Interrupt flags clear address
        volatile uint32_t CNTCON;  ///< Offset: 0x5C - Count Control read address
        volatile uint32_t CNTCON_SET;  ///< Offset: 0x60 - Count Control set address
        volatile uint32_t CNTCON_CLR;  ///< Offset: 0x64 - Count Control clear address
        volatile uint32_t CAP_CLR;  ///< Offset: 0x74 - Capture clear address
    };

    /// Peripheral instances
    inline Registers* MCPWM = reinterpret_cast<Registers*>(MCPWM_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x400A1000;
    constexpr uint32_t I2C1_BASE = 0x400E0000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CONSET;  ///< Offset: 0x00 - I2C Control Set Register. When a one is written to a bit...
        volatile uint32_t STAT;  ///< Offset: 0x04 - I2C Status Register. During I2C operation, this register...
        volatile uint32_t DAT;  ///< Offset: 0x08 - I2C Data Register. During master or slave transmit mode,...
        volatile uint32_t ADR0;  ///< Offset: 0x0C - I2C Slave Address Register 0. Contains the 7-bit slave...
        volatile uint32_t SCLH;  ///< Offset: 0x10 - SCH Duty Cycle Register High Half Word. Determines the...
        volatile uint32_t SCLL;  ///< Offset: 0x14 - SCL Duty Cycle Register Low Half Word. Determines the...
        volatile uint32_t CONCLR;  ///< Offset: 0x18 - I2C Control Clear Register. When a one is written to a...
        volatile uint32_t MMCTRL;  ///< Offset: 0x1C - Monitor mode control register.
        volatile uint32_t ADR%s;  ///< Offset: 0x20 - I2C Slave Address Register. Contains the 7-bit slave...
        volatile uint32_t DATA_BUFFER;  ///< Offset: 0x2C - Data buffer register. The contents of the 8 MSBs of the...
        volatile uint32_t MASK%s;  ///< Offset: 0x30 - I2C Slave address mask register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x400A2000;
    constexpr uint32_t I2S1_BASE = 0x400A3000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t DAO;  ///< Offset: 0x00 - I2S Digital Audio Output Register. Contains control bits...
        volatile uint32_t DAI;  ///< Offset: 0x04 - I2S Digital Audio Input Register. Contains control bits...
        volatile uint32_t TXFIFO;  ///< Offset: 0x08 - I2S Transmit FIFO. Access register for the 8 x 32-bit...
        volatile uint32_t RXFIFO;  ///< Offset: 0x0C - I2S Receive FIFO. Access register for the 8 x 32-bit...
        volatile uint32_t STATE;  ///< Offset: 0x10 - I2S Status Feedback Register. Contains status...
        volatile uint32_t DMA1;  ///< Offset: 0x14 - I2S DMA Configuration Register 1. Contains control...
        volatile uint32_t DMA2;  ///< Offset: 0x18 - I2S DMA Configuration Register 2. Contains control...
        volatile uint32_t IRQ;  ///< Offset: 0x1C - I2S Interrupt Request Control Register. Contains bits...
        volatile uint32_t TXRATE;  ///< Offset: 0x20 - I2S Transmit MCLK divider. This register determines the...
        volatile uint32_t RXRATE;  ///< Offset: 0x24 - I2S Receive MCLK divider. This register determines the...
        volatile uint32_t TXBITRATE;  ///< Offset: 0x28 - I2S Transmit bit rate divider. This register determines...
        volatile uint32_t RXBITRATE;  ///< Offset: 0x2C - I2S Receive bit rate divider. This register determines...
        volatile uint32_t TXMODE;  ///< Offset: 0x30 - I2S Transmit mode control.
        volatile uint32_t RXMODE;  ///< Offset: 0x34 - I2S Receive mode control.
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t C_CAN1_BASE = 0x400A4000;
    constexpr uint32_t C_CAN0_BASE = 0x400E2000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CNTL;  ///< Offset: 0x00 - CAN control
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register
        volatile uint32_t EC;  ///< Offset: 0x08 - Error counter
        volatile uint32_t BT;  ///< Offset: 0x0C - Bit timing register
        volatile uint32_t INT;  ///< Offset: 0x10 - Interrupt register
        volatile uint32_t TEST;  ///< Offset: 0x14 - Test register
        volatile uint32_t BRPE;  ///< Offset: 0x18 - Baud rate prescaler extension register
        volatile uint32_t IF%s_CMDREQ;  ///< Offset: 0x20 - Message interface command request
        volatile uint32_t IF%s_CMDMSK_W;  ///< Offset: 0x24 - Message interface command mask (write direction)
        volatile uint32_t IF%s_CMDMSK_R;  ///< Offset: 0x24 - Message interface command mask (read direction)
        volatile uint32_t IF%s_MSK1;  ///< Offset: 0x28 - Message interface mask 1
        volatile uint32_t IF%s_MSK2;  ///< Offset: 0x2C - Message interface 1 mask 2
        volatile uint32_t IF%s_ARB1;  ///< Offset: 0x30 - Message interface 1 arbitration 1
        volatile uint32_t IF%s_ARB2;  ///< Offset: 0x34 - Message interface 1 arbitration 2
        volatile uint32_t IF%s_MCTRL;  ///< Offset: 0x38 - Message interface 1 message control
        volatile uint32_t IF%s_DA1;  ///< Offset: 0x3C - Message interface data A1
        volatile uint32_t IF%s_DA2;  ///< Offset: 0x40 - Message interface 1 data A2
        volatile uint32_t IF%s_DB1;  ///< Offset: 0x44 - Message interface 1 data B1
        volatile uint32_t IF%s_DB2;  ///< Offset: 0x48 - Message interface 1 data B2
        volatile uint32_t TXREQ1;  ///< Offset: 0x100 - Transmission request 1
        volatile uint32_t TXREQ2;  ///< Offset: 0x104 - Transmission request 2
        volatile uint32_t ND1;  ///< Offset: 0x120 - New data 1
        volatile uint32_t ND2;  ///< Offset: 0x124 - New data 2
        volatile uint32_t IR1;  ///< Offset: 0x140 - Interrupt pending 1
        volatile uint32_t IR2;  ///< Offset: 0x144 - Interrupt pending 2
        volatile uint32_t MSGV1;  ///< Offset: 0x160 - Message valid 1
        volatile uint32_t MSGV2;  ///< Offset: 0x164 - Message valid 2
        volatile uint32_t CLKDIV;  ///< Offset: 0x180 - CAN clock divider register
    };

    /// Peripheral instances
    inline Registers* C_CAN1 = reinterpret_cast<Registers*>(C_CAN1_BASE);
    inline Registers* C_CAN0 = reinterpret_cast<Registers*>(C_CAN0_BASE);

}

// ============================================================================
// QEI Peripheral
// ============================================================================

namespace qei {
    /// Base addresses
    constexpr uint32_t QEI_BASE = 0x400C6000;

    /// QEI Register structure
    struct Registers {
        volatile uint32_t CON;  ///< Offset: 0x00 - Control register
        volatile uint32_t CONF;  ///< Offset: 0x08 - Configuration register
        volatile uint32_t STAT;  ///< Offset: 0x04 - Encoder status register
        volatile uint32_t POS;  ///< Offset: 0x0C - Position register
        volatile uint32_t MAXPOS;  ///< Offset: 0x10 - Maximum position register
        volatile uint32_t CMPOS0;  ///< Offset: 0x14 - position compare register 0
        volatile uint32_t CMPOS1;  ///< Offset: 0x18 - position compare register 1
        volatile uint32_t CMPOS2;  ///< Offset: 0x1C - position compare register 2
        volatile uint32_t INXCNT;  ///< Offset: 0x20 - Index count register
        volatile uint32_t INXCMP0;  ///< Offset: 0x24 - Index compare register 0
        volatile uint32_t LOAD;  ///< Offset: 0x28 - Velocity timer reload register
        volatile uint32_t TIME;  ///< Offset: 0x2C - Velocity timer register
        volatile uint32_t VEL;  ///< Offset: 0x30 - Velocity counter register
        volatile uint32_t CAP;  ///< Offset: 0x34 - Velocity capture register
        volatile uint32_t VELCOMP;  ///< Offset: 0x38 - Velocity compare register
        volatile uint32_t FILTERPHA;  ///< Offset: 0x3C - Digital filter register on input phase A (QEI_A)
        volatile uint32_t FILTERPHB;  ///< Offset: 0x40 - Digital filter register on input phase B (QEI_B)
        volatile uint32_t FILTERINX;  ///< Offset: 0x44 - Digital filter register on input index (QEI_IDX)
        volatile uint32_t WINDOW;  ///< Offset: 0x48 - Index acceptance window register
        volatile uint32_t INXCMP1;  ///< Offset: 0x4C - Index compare register 1
        volatile uint32_t INXCMP2;  ///< Offset: 0x50 - Index compare register 2
        volatile uint32_t IEC;  ///< Offset: 0xFD8 - Interrupt enable clear register
        volatile uint32_t IES;  ///< Offset: 0xFDC - Interrupt enable set register
        volatile uint32_t INTSTAT;  ///< Offset: 0xFE0 - Interrupt status register
        volatile uint32_t IE;  ///< Offset: 0xFE4 - Interrupt enable register
        volatile uint32_t CLR;  ///< Offset: 0xFE8 - Interrupt status clear register
        volatile uint32_t SET;  ///< Offset: 0xFEC - Interrupt status set register
    };

    /// Peripheral instances
    inline Registers* QEI = reinterpret_cast<Registers*>(QEI_BASE);

}

// ============================================================================
// GIMA Peripheral
// ============================================================================

namespace gima {
    /// Base addresses
    constexpr uint32_t GIMA_BASE = 0x400C7000;

    /// GIMA Register structure
    struct Registers {
        volatile uint32_t CAP0_0_IN;  ///< Offset: 0x00 - Timer 0 CAP0_0 capture input multiplexer (GIMA output 0)
        volatile uint32_t CAP0_1_IN;  ///< Offset: 0x04 - Timer 0 CAP0_1 capture input multiplexer (GIMA output 1)
        volatile uint32_t CAP0_2_IN;  ///< Offset: 0x08 - Timer 0 CAP0_2 capture input multiplexer (GIMA output 2)
        volatile uint32_t CAP0_3_IN;  ///< Offset: 0x0C - Timer 0 CAP0_3 capture input multiplexer (GIMA output 3)
        volatile uint32_t CAP1_0_IN;  ///< Offset: 0x10 - Timer 1 CAP1_0 capture input multiplexer (GIMA output 4)
        volatile uint32_t CAP1_1_IN;  ///< Offset: 0x14 - Timer 1 CAP1_1 capture input multiplexer (GIMA output 5)
        volatile uint32_t CAP1_2_IN;  ///< Offset: 0x18 - Timer 1 CAP1_2 capture input multiplexer (GIMA output 6)
        volatile uint32_t CAP1_3_IN;  ///< Offset: 0x1C - Timer 1 CAP1_3 capture input multiplexer (GIMA output 7)
        volatile uint32_t CAP2_0_IN;  ///< Offset: 0x20 - Timer 2 CAP2_0 capture input multiplexer (GIMA output 8)
        volatile uint32_t CAP2_1_IN;  ///< Offset: 0x24 - Timer 2 CAP2_1 capture input multiplexer (GIMA output 9)
        volatile uint32_t CAP2_2_IN;  ///< Offset: 0x28 - Timer 2 CAP2_2 capture input multiplexer (GIMA output 10)
        volatile uint32_t CAP2_3_IN;  ///< Offset: 0x2C - Timer 2 CAP2_3 capture input multiplexer (GIMA output 11)
        volatile uint32_t CAP3_0_IN;  ///< Offset: 0x30 - Timer 3 CAP3_0 capture input multiplexer (GIMA output 12)
        volatile uint32_t CAP3_1_IN;  ///< Offset: 0x34 - Timer 3 CAP3_1 capture input multiplexer (GIMA output 13)
        volatile uint32_t CAP3_2_IN;  ///< Offset: 0x38 - Timer 3 CAP3_2 capture input multiplexer (GIMA output 14)
        volatile uint32_t CAP3_3_IN;  ///< Offset: 0x3C - Timer 3 CAP3_3 capture input multiplexer (GIMA output 15)
        volatile uint32_t CTIN_0_IN;  ///< Offset: 0x40 - SCT CTIN_0 capture input multiplexer (GIMA output 16)
        volatile uint32_t CTIN_1_IN;  ///< Offset: 0x44 - SCT CTIN_1 capture input multiplexer (GIMA output 17)
        volatile uint32_t CTIN_2_IN;  ///< Offset: 0x48 - SCT CTIN_2 capture input multiplexer (GIMA output 18)
        volatile uint32_t CTIN_3_IN;  ///< Offset: 0x4C - SCT CTIN_3 capture input multiplexer (GIMA output 19)
        volatile uint32_t CTIN_4_IN;  ///< Offset: 0x50 - SCT CTIN_4 capture input multiplexer (GIMA output 20)
        volatile uint32_t CTIN_5_IN;  ///< Offset: 0x54 - SCT CTIN_5 capture input multiplexer (GIMA output 21)
        volatile uint32_t CTIN_6_IN;  ///< Offset: 0x58 - SCT CTIN_6 capture input multiplexer (GIMA output 22)
        volatile uint32_t CTIN_7_IN;  ///< Offset: 0x5C - SCT CTIN_7 capture input multiplexer (GIMA output 23)
        volatile uint32_t ADCHS_TRIGGER_IN;  ///< Offset: 0x60 - ADCHS trigger input multiplexer (GIMA output 24)
        volatile uint32_t EVENTROUTER_13_IN;  ///< Offset: 0x64 - Event router input 13 multiplexer (GIMA output 25)
        volatile uint32_t EVENTROUTER_14_IN;  ///< Offset: 0x68 - Event router input 14 multiplexer (GIMA output 26)
        volatile uint32_t EVENTROUTER_16_IN;  ///< Offset: 0x6C - Event router input 16 multiplexer (GIMA output 27)
        volatile uint32_t ADCSTART0_IN;  ///< Offset: 0x70 - ADC start0 input multiplexer (GIMA output 28)
        volatile uint32_t ADCSTART1_IN;  ///< Offset: 0x74 - ADC start1 input multiplexer (GIMA output 29)
    };

    /// Peripheral instances
    inline Registers* GIMA = reinterpret_cast<Registers*>(GIMA_BASE);

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x400E1000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - DAC register. Holds the conversion data.
        volatile uint32_t CTRL;  ///< Offset: 0x04 - DAC control register.
        volatile uint32_t CNTVAL;  ///< Offset: 0x08 - DAC counter value register.
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x400E3000;
    constexpr uint32_t ADC1_BASE = 0x400E4000;
    constexpr uint32_t ADCHS_BASE = 0x400F0000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - A/D Control Register. The AD0CR register must be written...
        volatile uint32_t GDR;  ///< Offset: 0x04 - A/D Global Data Register. Contains the result of the...
        volatile uint32_t INTEN;  ///< Offset: 0x0C - A/D Interrupt Enable Register. This register contains...
        volatile uint32_t DR[%s];  ///< Offset: 0x10 - A/D Channel Data Register. This register contains the...
        volatile uint32_t STAT;  ///< Offset: 0x30 - A/D Status Register. This register contains DONE and...
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADCHS = reinterpret_cast<Registers*>(ADCHS_BASE);

}


} // namespace alloy::generated::lpc43xx

#endif // ALLOY_GENERATED_LPC43XX_PERIPHERALS_HPP