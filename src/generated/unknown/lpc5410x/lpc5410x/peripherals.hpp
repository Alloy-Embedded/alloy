/// Auto-generated code for LPC5410x
/// Generated by Alloy Code Generator
/// Source: nxp_lpc5410x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:45
#ifndef ALLOY_GENERATED_LPC5410X_PERIPHERALS_HPP
#define ALLOY_GENERATED_LPC5410X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::lpc5410x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x1C000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t B%s;  ///< Offset: 0x00 - Byte pin registers port 0/1; pins PIO0_0 to PIO1_8
        volatile uint32_t W%s;  ///< Offset: 0x1000 - Word pin registers port 0/1; pins PIO0_0 to PIO1_8
        volatile uint32_t DIR%s;  ///< Offset: 0x2000 - Direction registers port 0/1
        volatile uint32_t MASK%s;  ///< Offset: 0x2080 - Mask register port 0/1
        volatile uint32_t PIN%s;  ///< Offset: 0x2100 - Port pin register port 0/1
        volatile uint32_t MPIN%s;  ///< Offset: 0x2180 - Masked port register port 0/1
        volatile uint32_t SET%s;  ///< Offset: 0x2200 - Write: Set register for port 0/1 Read: output bits for...
        volatile uint32_t CLR%s;  ///< Offset: 0x2280 - Clear port 0/1
        volatile uint32_t NOT%s;  ///< Offset: 0x2300 - Toggle port 0/1
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x1C004000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - DMA control.
        volatile uint32_t INTSTAT;  ///< Offset: 0x04 - Interrupt status.
        volatile uint32_t SRAMBASE;  ///< Offset: 0x08 - SRAM address of the channel configuration table.
        volatile uint32_t ENABLESET0;  ///< Offset: 0x20 - Channel Enable read and Set for all DMA channels.
        volatile uint32_t ENABLECLR0;  ///< Offset: 0x28 - Channel Enable Clear for all DMA channels.
        volatile uint32_t ACTIVE0;  ///< Offset: 0x30 - Channel Active status for all DMA channels.
        volatile uint32_t BUSY0;  ///< Offset: 0x38 - Channel Busy status for all DMA channels.
        volatile uint32_t ERRINT0;  ///< Offset: 0x40 - Error Interrupt status for all DMA channels.
        volatile uint32_t INTENSET0;  ///< Offset: 0x48 - Interrupt Enable read and Set for all DMA channels.
        volatile uint32_t INTENCLR0;  ///< Offset: 0x50 - Interrupt Enable Clear for all DMA channels.
        volatile uint32_t INTA0;  ///< Offset: 0x58 - Interrupt A status for all DMA channels.
        volatile uint32_t INTB0;  ///< Offset: 0x60 - Interrupt B status for all DMA channels.
        volatile uint32_t SETVALID0;  ///< Offset: 0x68 - Set ValidPending control bits for all DMA channels.
        volatile uint32_t SETTRIG0;  ///< Offset: 0x70 - Set Trigger control bits for all DMA channels.
        volatile uint32_t ABORT0;  ///< Offset: 0x78 - Channel Abort control for all DMA channels.
        volatile uint32_t CFG%s;  ///< Offset: 0x400 - Configuration register for DMA channel 0.
        volatile uint32_t CTLSTAT%s;  ///< Offset: 0x404 - Control and status register for DMA channel 0.
        volatile uint32_t XFERCFG%s;  ///< Offset: 0x408 - Transfer configuration register for DMA channel 0.
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x1C010000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - CRC mode register
        volatile uint32_t SEED;  ///< Offset: 0x04 - CRC seed register
        volatile uint32_t SUM;  ///< Offset: 0x08 - CRC checksum register
        volatile uint32_t WR_DATA;  ///< Offset: 0x08 - CRC data register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

}

// ============================================================================
// SCT0 Peripheral
// ============================================================================

namespace sct0 {
    /// Base addresses
    constexpr uint32_t SCT0_BASE = 0x1C018000;

    /// SCT0 Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT control register
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt condition register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop condition register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start condition register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x44 - SCT state register
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture registers mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t DMAREQ0;  ///< Offset: 0x5C - SCT DMA request 0 register
        volatile uint32_t DMAREQ1;  ///< Offset: 0x60 - SCT DMA request 1 register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t MATCH%s;  ///< Offset: 0x100 - SCT match value register of match channels 0 to 12;...
        volatile uint32_t CAP%s;  ///< Offset: 0x100 - SCT capture register of capture channel 0 to 12; REGMOD0...
        volatile uint32_t MATCHREL%s;  ///< Offset: 0x200 - SCT match reload value register 0 to 12; REGMOD0 = 0 to...
        volatile uint32_t CAPCTRL%s;  ///< Offset: 0x200 - SCT capture control register 0 to 12; REGMOD0 = 1 to...
        volatile uint32_t EV%s_STATE;  ///< Offset: 0x300 - SCT event state register 0
        volatile uint32_t EV%s_CTRL;  ///< Offset: 0x304 - SCT event control register 0
        volatile uint32_t OUT%s_SET;  ///< Offset: 0x500 - SCT output 0 set register
        volatile uint32_t OUT%s_CLR;  ///< Offset: 0x504 - SCT output 0 clear register
    };

    /// Peripheral instances
    inline Registers* SCT0 = reinterpret_cast<Registers*>(SCT0_BASE);

}

// ============================================================================
// MAILBOX Peripheral
// ============================================================================

namespace mailbox {
    /// Base addresses
    constexpr uint32_t MAILBOX_BASE = 0x1C02C000;

    /// MAILBOX Register structure
    struct Registers {
        volatile uint32_t IRQ0;  ///< Offset: 0x00 - Interrupt request register for the Cortex-M0+ CPU.
        volatile uint32_t IRQ0SET;  ///< Offset: 0x04 - Set bits in IRQ0
        volatile uint32_t IRQ0CLR;  ///< Offset: 0x08 - Clear bits in IRQ0
        volatile uint32_t IRQ1;  ///< Offset: 0x10 - Interrupt request register for the Cortex M4 CPU.
        volatile uint32_t IRQ1SET;  ///< Offset: 0x14 - Set bits in IRQ1
        volatile uint32_t IRQ1CLR;  ///< Offset: 0x18 - Clear bits in IRQ1
        volatile uint32_t MUTEX;  ///< Offset: 0xF8 - Mutual exclusion register
    };

    /// Peripheral instances
    inline Registers* MAILBOX = reinterpret_cast<Registers*>(MAILBOX_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x1C034000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - ADC Control Register. Contains the clock divide value,...
        volatile uint32_t SEQA_CTRL;  ///< Offset: 0x08 - ADC Conversion Sequence-A control Register: Controls...
        volatile uint32_t SEQB_CTRL;  ///< Offset: 0x0C - ADC Conversion Sequence-B Control Register: Controls...
        volatile uint32_t SEQA_GDAT;  ///< Offset: 0x10 - ADC Sequence-A Global Data Register. This register...
        volatile uint32_t SEQB_GDAT;  ///< Offset: 0x14 - ADC Sequence-B Global Data Register. This register...
        volatile uint32_t DAT%s;  ///< Offset: 0x20 - ADC Channel 0 Data Register. This register contains the...
        volatile uint32_t THR0_LOW;  ///< Offset: 0x50 - ADC Low Compare Threshold Register 0: Contains the lower...
        volatile uint32_t THR1_LOW;  ///< Offset: 0x54 - ADC Low Compare Threshold Register 1: Contains the lower...
        volatile uint32_t THR0_HIGH;  ///< Offset: 0x58 - ADC High Compare Threshold Register 0: Contains the...
        volatile uint32_t THR1_HIGH;  ///< Offset: 0x5C - ADC High Compare Threshold Register 1: Contains the...
        volatile uint32_t CHAN_THRSEL;  ///< Offset: 0x60 - ADC Channel-Threshold Select Register. Specifies which...
        volatile uint32_t INTEN;  ///< Offset: 0x64 - ADC Interrupt Enable Register. This register contains...
        volatile uint32_t FLAGS;  ///< Offset: 0x68 - ADC Flags Register. Contains the four interrupt/DMA...
        volatile uint32_t STARTUP;  ///< Offset: 0x6C - ADC Startup Register (typically only used by the ADC 						API).
        volatile uint32_t CALIB;  ///< Offset: 0x70 - ADC Calibration Register.
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

}

// ============================================================================
// VFIFO Peripheral
// ============================================================================

namespace vfifo {
    /// Base addresses
    constexpr uint32_t VFIFO_BASE = 0x1C038000;

    /// VFIFO Register structure
    struct Registers {
        volatile uint32_t FIFOCTLUSART;  ///< Offset: 0x100 - USART FIFO global control register. These registers are...
        volatile uint32_t FIFOUPDATEUSART;  ///< Offset: 0x104 - USART FIFO global update register
        volatile uint32_t FIFOCFGUSART%s;  ///< Offset: 0x110 - FIFO configuration register for USART0
        volatile uint32_t FIFOCTLSPI;  ///< Offset: 0x200 - SPI FIFO global control register. These registers are...
        volatile uint32_t FIFOUPDATESPI;  ///< Offset: 0x204 - SPI FIFO global update register
        volatile uint32_t FIFOCFGSPI%s;  ///< Offset: 0x210 - FIFO configuration register for SPI0
        volatile uint32_t CFGUSART%s;  ///< Offset: 0x1000 - USART0 configuration
        volatile uint32_t STATUSART%s;  ///< Offset: 0x1004 - USART0 status
        volatile uint32_t INTSTATUSART%s;  ///< Offset: 0x1008 - USART0 interrupt status
        volatile uint32_t CTLSETUSART%s;  ///< Offset: 0x100C - USART0 control read and set register. A complete value...
        volatile uint32_t CTLCLRUSART%s;  ///< Offset: 0x1010 - USART0 control clear register. Writing a 1 to any...
        volatile uint32_t RXDATUSART%s;  ///< Offset: 0x1014 - USART0 received data
        volatile uint32_t RXDATSTATUSART%s;  ///< Offset: 0x1018 - USART0 received data with status
        volatile uint32_t TXDATUSART%s;  ///< Offset: 0x101C - USART0 transmit data
        volatile uint32_t CFGSPI%s;  ///< Offset: 0x2000 - SPI0 configuration
        volatile uint32_t STATSPI%s;  ///< Offset: 0x2004 - SPI0 status
        volatile uint32_t INTSTATSPI%s;  ///< Offset: 0x2008 - SPI0 interrupt status
        volatile uint32_t CTLSETSPI%s;  ///< Offset: 0x200C - SPI0 control read and set register. A complete value may...
        volatile uint32_t CTLCLRSPI%s;  ///< Offset: 0x2010 - SPI0 control clear register. Writing a 1 to any...
        volatile uint32_t RXDATSPI%s;  ///< Offset: 0x2014 - SPI0 received data. These registers are half word...
        volatile uint32_t TXDATSPI%s;  ///< Offset: 0x2018 - SPI0 transmit data. These registers are half word...
    };

    /// Peripheral instances
    inline Registers* VFIFO = reinterpret_cast<Registers*>(VFIFO_BASE);

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x40000000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t SYSMEMREMAP;  ///< Offset: 0x00 - System memory remap
        volatile uint32_t AHBMATPRIO;  ///< Offset: 0x04 - AHB multilayer matrix priority control
        volatile uint32_t SYSTCKCAL;  ///< Offset: 0x14 - System tick counter calibration
        volatile uint32_t NMISRC;  ///< Offset: 0x1C - NMI Source Select
        volatile uint32_t ASYNCAPBCTRL;  ///< Offset: 0x20 - Asynchronous APB Control
        volatile uint32_t SYSRSTSTAT;  ///< Offset: 0x40 - System reset status register
        volatile uint32_t PRESETCTRL0;  ///< Offset: 0x44 - Peripheral reset control 0
        volatile uint32_t PRESETCTRL1;  ///< Offset: 0x48 - Peripheral reset control 1
        volatile uint32_t PRESETCTRLSET0;  ///< Offset: 0x4C - Set bits in PRESETCTRL0
        volatile uint32_t PRESETCTRLSET1;  ///< Offset: 0x50 - Set bits in PRESETCTRL1
        volatile uint32_t PRESETCTRLCLR0;  ///< Offset: 0x54 - Clear bits in PRESETCTRL0
        volatile uint32_t PRESETCTRLCLR1;  ///< Offset: 0x58 - Clear bits in PRESETCTRL1
        volatile uint32_t PIOPORCAP0;  ///< Offset: 0x5C - POR captured PIO status 0
        volatile uint32_t PIOPORCAP1;  ///< Offset: 0x60 - POR captured PIO status 1
        volatile uint32_t PIORESCAP0;  ///< Offset: 0x68 - Reset captured PIO status 0
        volatile uint32_t PIORESCAP1;  ///< Offset: 0x6C - Reset captured PIO status 1
        volatile uint32_t MAINCLKSELA;  ///< Offset: 0x80 - Main clock source select A
        volatile uint32_t MAINCLKSELB;  ///< Offset: 0x84 - Main clock source select B
        volatile uint32_t ADCCLKSEL;  ///< Offset: 0x8C - ADC clock source select
        volatile uint32_t CLKOUTSELA;  ///< Offset: 0x94 - CLKOUT clock source select A
        volatile uint32_t CLKOUTSELB;  ///< Offset: 0x98 - CLKOUT clock source select B
        volatile uint32_t SYSPLLCLKSEL;  ///< Offset: 0xA0 - PLL clock source select
        volatile uint32_t AHBCLKCTRL0;  ///< Offset: 0xC0 - AHB Clock control 0
        volatile uint32_t AHBCLKCTRL1;  ///< Offset: 0xC4 - AHB Clock control 1
        volatile uint32_t AHBCLKCTRLSET0;  ///< Offset: 0xC8 - Set bits in AHBCLKCTRL0
        volatile uint32_t AHBCLKCTRLSET1;  ///< Offset: 0xCC - Set bits in AHBCLKCTRL1
        volatile uint32_t AHBCLKCTRLCLR0;  ///< Offset: 0xD0 - Clear bits in AHBCLKCTRL0
        volatile uint32_t AHBCLKCTRLCLR1;  ///< Offset: 0xD4 - Clear bits in AHBCLKCTRL1
        volatile uint32_t SYSTICKCLKDIV;  ///< Offset: 0xE0 - SYSTICK clock divider
        volatile uint32_t AHBCLKDIV;  ///< Offset: 0x100 - System clock divider
        volatile uint32_t ADCCLKDIV;  ///< Offset: 0x108 - ADC clock divider
        volatile uint32_t CLKOUTDIV;  ///< Offset: 0x10C - CLKOUT clock divider
        volatile uint32_t FREQMECTRL;  ///< Offset: 0x120 - Frequency measure register
        volatile uint32_t FLASHCFG;  ///< Offset: 0x124 - Flash wait states configuration
        volatile uint32_t FIFOCTRL;  ///< Offset: 0x148 - Serial interface FIFO enables
        volatile uint32_t IRCCTRL;  ///< Offset: 0x184 - IRC oscillator control
        volatile uint32_t RTCOSCCTRL;  ///< Offset: 0x190 - RTC oscillator 32 kHz output control
        volatile uint32_t SYSPLLCTRL;  ///< Offset: 0x1B0 - PLL control
        volatile uint32_t SYSPLLSTAT;  ///< Offset: 0x1B4 - PLL status
        volatile uint32_t SYSPLLNDEC;  ///< Offset: 0x1B8 - PLL N decoder
        volatile uint32_t SYSPLLPDEC;  ///< Offset: 0x1BC - PLL P decoder
        volatile uint32_t SYSPLLSSCTRL0;  ///< Offset: 0x1C0 - PLL spread spectrum control 0
        volatile uint32_t SYSPLLSSCTRL1;  ///< Offset: 0x1C4 - PLL spread spectrum control 1
        volatile uint32_t PDRUNCFG;  ///< Offset: 0x210 - Power configuration register
        volatile uint32_t PDRUNCFGSET;  ///< Offset: 0x214 - Set bits in PDRUNCFG
        volatile uint32_t PDRUNCFGCLR;  ///< Offset: 0x218 - Clear bits in PDRUNCFG
        volatile uint32_t STARTERP0;  ///< Offset: 0x240 - Start logic 0 wake-up enable register
        volatile uint32_t STARTERP1;  ///< Offset: 0x244 - Start logic 1 wake-up enable register
        volatile uint32_t STARTERPSET0;  ///< Offset: 0x248 - Set bits in STARTERP0
        volatile uint32_t STARTERPSET1;  ///< Offset: 0x24C - Set bits in STARTERP1
        volatile uint32_t STARTERPCLR0;  ///< Offset: 0x250 - Clear bits in STARTERP0
        volatile uint32_t STARTERPCLR1;  ///< Offset: 0x254 - Clear bits in STARTERP1
        volatile uint32_t CPUCTRL;  ///< Offset: 0x300 - CPU Control for multiple processors
        volatile uint32_t CPBOOT;  ///< Offset: 0x304 - Coprocessor Boot Address
        volatile uint32_t CPSTACK;  ///< Offset: 0x308 - Coprocessor Stack Address
        volatile uint32_t JTAGIDCODE;  ///< Offset: 0x3F4 - JTAG ID code register
        volatile uint32_t DEVICE_ID0;  ///< Offset: 0x3F8 - Part ID register
        volatile uint32_t DEVICE_ID1;  ///< Offset: 0x3FC - Boot ROM and die revision register
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

}

// ============================================================================
// CT32B2 Peripheral
// ============================================================================

namespace ct32b2 {
    /// Base addresses
    constexpr uint32_t CT32B2_BASE = 0x40004000;

    /// CT32B2 Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32 bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. When the Prescale Counter (PC) is...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. The 32 bit PC is a counter which is...
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control if an...
        volatile uint32_t MR%s;  ///< Offset: 0x18 - Match Register 0. MR0 can be enabled through the MCR to...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR%s;  ///< Offset: 0x2C - Capture Register 0. CR0 is loaded with the value of TC...
        volatile uint32_t EMR;  ///< Offset: 0x3C - External Match Register. The EMR controls the match...
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
        volatile uint32_t PWMC;  ///< Offset: 0x74 - PWM Control Register. The PWMCON enables PWM mode for...
    };

    /// Peripheral instances
    inline Registers* CT32B2 = reinterpret_cast<Registers*>(CT32B2_BASE);

}

// ============================================================================
// CT32B3 Peripheral
// ============================================================================

namespace ct32b3 {
    /// Base addresses
    constexpr uint32_t CT32B3_BASE = 0x40008000;

    /// CT32B3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CT32B3 = reinterpret_cast<Registers*>(CT32B3_BASE);

}

// ============================================================================
// CT32B4 Peripheral
// ============================================================================

namespace ct32b4 {
    /// Base addresses
    constexpr uint32_t CT32B4_BASE = 0x4000C000;

    /// CT32B4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CT32B4 = reinterpret_cast<Registers*>(CT32B4_BASE);

}

// ============================================================================
// GINT0 Peripheral
// ============================================================================

namespace gint0 {
    /// Base addresses
    constexpr uint32_t GINT0_BASE = 0x40010000;

    /// GINT0 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - GPIO grouped interrupt control register
        volatile uint32_t PORT_POL%s;  ///< Offset: 0x20 - GPIO grouped interrupt port 0 polarity register
        volatile uint32_t PORT_ENA%s;  ///< Offset: 0x40 - GPIO grouped interrupt port 0 enable register
    };

    /// Peripheral instances
    inline Registers* GINT0 = reinterpret_cast<Registers*>(GINT0_BASE);

}

// ============================================================================
// GINT1 Peripheral
// ============================================================================

namespace gint1 {
    /// Base addresses
    constexpr uint32_t GINT1_BASE = 0x40014000;

    /// GINT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GINT1 = reinterpret_cast<Registers*>(GINT1_BASE);

}

// ============================================================================
// PINT Peripheral
// ============================================================================

namespace pint {
    /// Base addresses
    constexpr uint32_t PINT_BASE = 0x40018000;

    /// PINT Register structure
    struct Registers {
        volatile uint32_t ISEL;  ///< Offset: 0x00 - Pin Interrupt Mode register
        volatile uint32_t IENR;  ///< Offset: 0x04 - Pin interrupt level or rising edge interrupt enable...
        volatile uint32_t SIENR;  ///< Offset: 0x08 - Pin interrupt level or rising edge interrupt set 						register
        volatile uint32_t CIENR;  ///< Offset: 0x0C - Pin interrupt level (rising edge interrupt) clear 						register
        volatile uint32_t IENF;  ///< Offset: 0x10 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t SIENF;  ///< Offset: 0x14 - Pin interrupt active level or falling edge interrupt set...
        volatile uint32_t CIENF;  ///< Offset: 0x18 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t RISE;  ///< Offset: 0x1C - Pin interrupt rising edge register
        volatile uint32_t FALL;  ///< Offset: 0x20 - Pin interrupt falling edge register
        volatile uint32_t IST;  ///< Offset: 0x24 - Pin interrupt status register
        volatile uint32_t PMCTRL;  ///< Offset: 0x28 - Pattern match interrupt control register
        volatile uint32_t PMSRC;  ///< Offset: 0x2C - Pattern match interrupt bit-slice source register
        volatile uint32_t PMCFG;  ///< Offset: 0x30 - Pattern match interrupt bit slice configuration 						register
    };

    /// Peripheral instances
    inline Registers* PINT = reinterpret_cast<Registers*>(PINT_BASE);

}

// ============================================================================
// IOCON Peripheral
// ============================================================================

namespace iocon {
    /// Base addresses
    constexpr uint32_t IOCON_BASE = 0x4001C000;

    /// IOCON Register structure
    struct Registers {
        volatile uint32_t PIO0_%s;  ///< Offset: 0x74 - Digital I/O control for port 0 pins PIO0_29 to PIO0_31....
        volatile uint32_t PIO1_%s;  ///< Offset: 0xA4 - Digital I/O control for port 1 pins PIO1_9 to 						PIO1_17.
    };

    /// Peripheral instances
    inline Registers* IOCON = reinterpret_cast<Registers*>(IOCON_BASE);

}

// ============================================================================
// UTICK Peripheral
// ============================================================================

namespace utick {
    /// Base addresses
    constexpr uint32_t UTICK_BASE = 0x40020000;

    /// UTICK Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control register.
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register.
    };

    /// Peripheral instances
    inline Registers* UTICK = reinterpret_cast<Registers*>(UTICK_BASE);

}

// ============================================================================
// ADVSYSCON Peripheral
// ============================================================================

namespace advsyscon {
    /// Base addresses
    constexpr uint32_t ADVSYSCON_BASE = 0x4002C000;

    /// ADVSYSCON Register structure
    struct Registers {
        volatile uint32_t BODCTRL;  ///< Offset: 0x44 - Brown-Out Detect control
    };

    /// Peripheral instances
    inline Registers* ADVSYSCON = reinterpret_cast<Registers*>(ADVSYSCON_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WWDT_BASE = 0x40038000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register contains the basic...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. This 24-bit register...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This 24-bit register...
        volatile uint32_t WARNINT;  ///< Offset: 0x14 - Watchdog Warning Interrupt compare value.
        volatile uint32_t WINDOW;  ///< Offset: 0x18 - Watchdog Window compare value.
    };

    /// Peripheral instances
    inline Registers* WWDT = reinterpret_cast<Registers*>(WWDT_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003C000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - RTC control register
        volatile uint32_t MATCH;  ///< Offset: 0x04 - RTC match register
        volatile uint32_t COUNT;  ///< Offset: 0x08 - RTC counter register
        volatile uint32_t WAKE;  ///< Offset: 0x0C - RTC high-resolution/wake-up timer control register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// INPUTMUX Peripheral
// ============================================================================

namespace inputmux {
    /// Base addresses
    constexpr uint32_t INPUTMUX_BASE = 0x40050000;

    /// INPUTMUX Register structure
    struct Registers {
        volatile uint32_t PINTSEL%s;  ///< Offset: 0xC0 - Pin interrupt select register 0
        volatile uint32_t DMA_ITRIG_INMUX%s;  ///< Offset: 0xE0 - Trigger select register for DMA channel 0
        volatile uint32_t DMA_OTRIG_INMUX%s;  ///< Offset: 0x140 - DMA output trigger selection to become DMA trigger 16
        volatile uint32_t FREQMEAS_REF;  ///< Offset: 0x160 - Clock selection for frequency measurement function...
        volatile uint32_t FREQMEAS_TARGET;  ///< Offset: 0x164 - Clock selection for frequency measurement function...
    };

    /// Peripheral instances
    inline Registers* INPUTMUX = reinterpret_cast<Registers*>(INPUTMUX_BASE);

}

// ============================================================================
// RIT Peripheral
// ============================================================================

namespace rit {
    /// Base addresses
    constexpr uint32_t RIT_BASE = 0x40070000;

    /// RIT Register structure
    struct Registers {
        volatile uint32_t COMPVAL;  ///< Offset: 0x00 - Compare value LSB register. Holds the 32 LSBs of the...
        volatile uint32_t MASK;  ///< Offset: 0x04 - Mask LSB register. This register holds the 32 LSB s of...
        volatile uint32_t CTRL;  ///< Offset: 0x08 - Control register.
        volatile uint32_t COUNTER;  ///< Offset: 0x0C - Counter LSB register. 32 LSBs of the counter.
        volatile uint32_t COMPVAL_H;  ///< Offset: 0x10 - Compare value MSB register. Holds the 16 MSBs of the...
        volatile uint32_t MASK_H;  ///< Offset: 0x14 - Mask MSB register. This register holds the 16 MSBs of...
        volatile uint32_t COUNTER_H;  ///< Offset: 0x1C - Counter MSB register. 16 MSBs of the counter.
    };

    /// Peripheral instances
    inline Registers* RIT = reinterpret_cast<Registers*>(RIT_BASE);

}

// ============================================================================
// MRT Peripheral
// ============================================================================

namespace mrt {
    /// Base addresses
    constexpr uint32_t MRT_BASE = 0x40074000;

    /// MRT Register structure
    struct Registers {
        volatile uint32_t INTVAL%s;  ///< Offset: 0x00 - MRTn Time interval value register. This value is loaded...
        volatile uint32_t TIMER%s;  ///< Offset: 0x04 - MRTn Timer register. This register reads the value of...
        volatile uint32_t CTRL%s;  ///< Offset: 0x08 - MRTn Control register. This register controls the MRTn...
        volatile uint32_t STAT%s;  ///< Offset: 0x0C - MRTn Status register.
        volatile uint32_t MODCFG;  ///< Offset: 0xF0 - Module Configuration register. This register provides...
        volatile uint32_t IDLE_CH;  ///< Offset: 0xF4 - Idle channel register. This register returns the number...
        volatile uint32_t IRQ_FLAG;  ///< Offset: 0xF8 - Global interrupt flag register
    };

    /// Peripheral instances
    inline Registers* MRT = reinterpret_cast<Registers*>(MRT_BASE);

}

// ============================================================================
// ASYNCSYSCON Peripheral
// ============================================================================

namespace asyncsyscon {
    /// Base addresses
    constexpr uint32_t ASYNCSYSCON_BASE = 0x40080000;

    /// ASYNCSYSCON Register structure
    struct Registers {
        volatile uint32_t AYSNCPRESETCTRL;  ///< Offset: 0x00 - Async peripheral reset control
        volatile uint32_t AYSNCPRESETCTRLSET;  ///< Offset: 0x04 - Set bits in AYSNCPRESETCTRL
        volatile uint32_t AYSNCPRESETCTRLCLR;  ///< Offset: 0x08 - Clear bits in AYSNCPRESETCTRL
        volatile uint32_t ASYNCAPBCLKCTRL;  ///< Offset: 0x10 - Async peripheral clock control
        volatile uint32_t ASYNCAPBCLKCTRLSET;  ///< Offset: 0x14 - Set bits in ASYNCAPBCLKCTRL
        volatile uint32_t ASYNCAPBCLKCTRLCLR;  ///< Offset: 0x18 - Clear bits in ASYNCAPBCLKCTRL
        volatile uint32_t ASYNCAPBCLKSELA;  ///< Offset: 0x20 - Async APB clock source select A
        volatile uint32_t ASYNCAPBCLKSELB;  ///< Offset: 0x24 - Async APB clock source select B
        volatile uint32_t ASYNCCLKDIV;  ///< Offset: 0x28 - Async APB clock divider
        volatile uint32_t FRGCTRL;  ///< Offset: 0x30 - USART fractional rate generator control
        volatile uint32_t BODCTRL;  ///< Offset: 0x44 - Brown-Out Detect control
    };

    /// Peripheral instances
    inline Registers* ASYNCSYSCON = reinterpret_cast<Registers*>(ASYNCSYSCON_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40084000;
    constexpr uint32_t USART1_BASE = 0x40088000;
    constexpr uint32_t USART2_BASE = 0x4008C000;
    constexpr uint32_t USART3_BASE = 0x40090000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - USART Configuration register. Basic USART configuration...
        volatile uint32_t CTL;  ///< Offset: 0x04 - USART Control register. USART control settings that are...
        volatile uint32_t STAT;  ///< Offset: 0x08 - USART Status register. The complete status value can be...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - Interrupt Enable read and Set register. Contains an...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - Interrupt Enable Clear register. Allows clearing any...
        volatile uint32_t RXDAT;  ///< Offset: 0x14 - Receiver Data register. Contains the last character...
        volatile uint32_t RXDATSTAT;  ///< Offset: 0x18 - Receiver Data with Status register. Combines the last...
        volatile uint32_t TXDAT;  ///< Offset: 0x1C - Transmit Data register. Data to be transmitted is...
        volatile uint32_t BRG;  ///< Offset: 0x20 - Baud Rate Generator register. 16-bit integer baud rate...
        volatile uint32_t INTSTAT;  ///< Offset: 0x24 - Interrupt status register. Reflects interrupts that are...
        volatile uint32_t OSR;  ///< Offset: 0x28 - Oversample selection register for asynchronous...
        volatile uint32_t ADDR;  ///< Offset: 0x2C - Address register for automatic address matching.
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40094000;
    constexpr uint32_t I2C1_BASE = 0x40098000;
    constexpr uint32_t I2C2_BASE = 0x4009C000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - Configuration for shared functions.
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register for Master, Slave, and Monitor 						functions.
        volatile uint32_t INTENSET;  ///< Offset: 0x08 - Interrupt Enable Set and read register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear register.
        volatile uint32_t TIMEOUT;  ///< Offset: 0x10 - Time-out value register.
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock pre-divider for the entire I2C block. This...
        volatile uint32_t INTSTAT;  ///< Offset: 0x18 - Interrupt Status register for Master, Slave, and Monitor...
        volatile uint32_t MSTCTL;  ///< Offset: 0x20 - Master control register.
        volatile uint32_t MSTTIME;  ///< Offset: 0x24 - Master timing configuration.
        volatile uint32_t MSTDAT;  ///< Offset: 0x28 - Combined Master receiver and transmitter data 						register.
        volatile uint32_t SLVCTL;  ///< Offset: 0x40 - Slave control register.
        volatile uint32_t SLVDAT;  ///< Offset: 0x44 - Combined Slave receiver and transmitter data 						register.
        volatile uint32_t SLVADR%s;  ///< Offset: 0x48 - Slave address 0.
        volatile uint32_t SLVQUAL0;  ///< Offset: 0x58 - Slave Qualification for address 0.
        volatile uint32_t MONRXDAT;  ///< Offset: 0x80 - Monitor receiver data register.
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x400A4000;
    constexpr uint32_t SPI1_BASE = 0x400A8000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - SPI Configuration register
        volatile uint32_t DLY;  ///< Offset: 0x04 - SPI Delay register
        volatile uint32_t STAT;  ///< Offset: 0x08 - SPI Status. Some status flags can be cleared by writing...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - SPI Interrupt Enable read and Set. A complete value may...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - SPI Interrupt Enable Clear. Writing a 1 to any...
        volatile uint32_t RXDAT;  ///< Offset: 0x14 - SPI Receive Data
        volatile uint32_t TXDATCTL;  ///< Offset: 0x18 - SPI Transmit Data with Control
        volatile uint32_t TXDAT;  ///< Offset: 0x1C - SPI Transmit Data
        volatile uint32_t TXCTL;  ///< Offset: 0x20 - SPI Transmit Control
        volatile uint32_t DIV;  ///< Offset: 0x24 - SPI clock Divider
        volatile uint32_t INTSTAT;  ///< Offset: 0x28 - SPI Interrupt Status
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

}

// ============================================================================
// CT32B0 Peripheral
// ============================================================================

namespace ct32b0 {
    /// Base addresses
    constexpr uint32_t CT32B0_BASE = 0x400B4000;

    /// CT32B0 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CT32B0 = reinterpret_cast<Registers*>(CT32B0_BASE);

}

// ============================================================================
// CT32B1 Peripheral
// ============================================================================

namespace ct32b1 {
    /// Base addresses
    constexpr uint32_t CT32B1_BASE = 0x400B8000;

    /// CT32B1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CT32B1 = reinterpret_cast<Registers*>(CT32B1_BASE);

}


} // namespace alloy::generated::lpc5410x

#endif // ALLOY_GENERATED_LPC5410X_PERIPHERALS_HPP