/// Auto-generated code for LPC800
/// Generated by Alloy Code Generator
/// Source: nxp_lpc800.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:02
#ifndef ALLOY_GENERATED_LPC800_PERIPHERALS_HPP
#define ALLOY_GENERATED_LPC800_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::lpc800 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WWDT_BASE = 0x40000000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register contains the basic...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. This 24-bit register...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This 24-bit register...
        volatile uint32_t WARNINT;  ///< Offset: 0x14 - Watchdog Warning Interrupt compare value.
        volatile uint32_t WINDOW;  ///< Offset: 0x18 - Watchdog Window compare value.
    };

    /// Peripheral instances
    inline Registers* WWDT = reinterpret_cast<Registers*>(WWDT_BASE);

}

// ============================================================================
// MRT Peripheral
// ============================================================================

namespace mrt {
    /// Base addresses
    constexpr uint32_t MRT_BASE = 0x40004000;

    /// MRT Register structure
    struct Registers {
        volatile uint32_t INTVAL%s;  ///< Offset: 0x00 - MRT0 Time interval value register. This value is loaded...
        volatile uint32_t TIMER%s;  ///< Offset: 0x04 - MRT0 Timer register. This register reads the value of...
        volatile uint32_t CTRL%s;  ///< Offset: 0x08 - MRT0 Control register. This register controls the MRT0 modes.
        volatile uint32_t STAT%s;  ///< Offset: 0x0C - MRT0 Status register.
        volatile uint32_t IDLE_CH;  ///< Offset: 0xF4 - Idle channel register. This register returns the number...
        volatile uint32_t IRQ_FLAG;  ///< Offset: 0xF8 - Global interrupt flag register
    };

    /// Peripheral instances
    inline Registers* MRT = reinterpret_cast<Registers*>(MRT_BASE);

}

// ============================================================================
// WKT Peripheral
// ============================================================================

namespace wkt {
    /// Base addresses
    constexpr uint32_t WKT_BASE = 0x40008000;

    /// WKT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Self wake-up timer control register.
        volatile uint32_t COUNT;  ///< Offset: 0x0C - Counter register.
    };

    /// Peripheral instances
    inline Registers* WKT = reinterpret_cast<Registers*>(WKT_BASE);

}

// ============================================================================
// SWM Peripheral
// ============================================================================

namespace swm {
    /// Base addresses
    constexpr uint32_t SWM_BASE = 0x4000C000;

    /// SWM Register structure
    struct Registers {
        volatile uint32_t PINASSIGN0;  ///< Offset: 0x00 - Pin assign register 0. Assign movable functions U0_TXD,...
        volatile uint32_t PINASSIGN1;  ///< Offset: 0x04 - Pin assign register 1. Assign movable functions U0_SCLC,...
        volatile uint32_t PINASSIGN2;  ///< Offset: 0x08 - Pin assign register 2. Assign movable functions U2_TXD, U2_RXD
        volatile uint32_t PINASSIGN3;  ///< Offset: 0x0C - Pin assignregister 3. Assign movable function SPI0_SCK
        volatile uint32_t PINASSIGN4;  ///< Offset: 0x10 - Pin assign register 4. Assign movable functions...
        volatile uint32_t PINASSIGN5;  ///< Offset: 0x14 - Pin assign register 5. Assign movable functions...
        volatile uint32_t PINASSIGN6;  ///< Offset: 0x18 - Pin assign register 6. Assign movable functions CTIN_1,...
        volatile uint32_t PINASSIGN7;  ///< Offset: 0x1C - Pin assign egister 7. Assign movable functions CTOUT_1,...
        volatile uint32_t PINASSIGN8;  ///< Offset: 0x20 - Pin assign register 8. Assign movable functions I2C_SCL,...
        volatile uint32_t PINENABLE0;  ///< Offset: 0x1C0 - Pin enable register 0. Enables fixed-pin functions...
    };

    /// Peripheral instances
    inline Registers* SWM = reinterpret_cast<Registers*>(SWM_BASE);

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x40020000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t PCON;  ///< Offset: 0x00 - Power control register
        volatile uint32_t GPREG%s;  ///< Offset: 0x04 - General purpose register 0
        volatile uint32_t DPDCTRL;  ///< Offset: 0x14 - Deep power-down control register
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

}

// ============================================================================
// CMP Peripheral
// ============================================================================

namespace cmp {
    /// Base addresses
    constexpr uint32_t CMP_BASE = 0x40024000;

    /// CMP Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Comparator control register
        volatile uint32_t LAD;  ///< Offset: 0x04 - Voltage ladder register
    };

    /// Peripheral instances
    inline Registers* CMP = reinterpret_cast<Registers*>(CMP_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASHCTRL_BASE = 0x40040000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASHCFG;  ///< Offset: 0x10 - Flash configuration register
        volatile uint32_t FMSSTART;  ///< Offset: 0x20 - Signature start address register
        volatile uint32_t FMSSTOP;  ///< Offset: 0x24 - Signature stop-address register
        volatile uint32_t FMSW0;  ///< Offset: 0x2C - Signature Word
    };

    /// Peripheral instances
    inline Registers* FLASHCTRL = reinterpret_cast<Registers*>(FLASHCTRL_BASE);

}

// ============================================================================
// IOCON Peripheral
// ============================================================================

namespace iocon {
    /// Base addresses
    constexpr uint32_t IOCON_BASE = 0x40044000;

    /// IOCON Register structure
    struct Registers {
        volatile uint32_t PIO0_17;  ///< Offset: 0x00 - I/O configuration for pin PIO0_17
        volatile uint32_t PIO0_13;  ///< Offset: 0x04 - I/O configuration for pin PIO0_13
        volatile uint32_t PIO0_12;  ///< Offset: 0x08 - I/O configuration for pin PIO0_12
        volatile uint32_t PIO0_5;  ///< Offset: 0x0C - I/O configuration for pin PIO0_5/RESET
        volatile uint32_t PIO0_4;  ///< Offset: 0x10 - I/O configuration for pin PIO0_4
        volatile uint32_t PIO0_3;  ///< Offset: 0x14 - I/O configuration for pin PIO0_3/SWCLK
        volatile uint32_t PIO0_2;  ///< Offset: 0x18 - I/O configuration for pin PIO0_2/SWDIO
        volatile uint32_t PIO0_11;  ///< Offset: 0x1C - I/O configuration for pin PIO0_11. This is the pin...
        volatile uint32_t PIO0_10;  ///< Offset: 0x20 - I/O configuration for pin PIO0_10. This is the pin...
        volatile uint32_t PIO0_16;  ///< Offset: 0x24 - I/O configuration for pin PIO0_16
        volatile uint32_t PIO0_15;  ///< Offset: 0x28 - I/O configuration for pin PIO0_15
        volatile uint32_t PIO0_1;  ///< Offset: 0x2C - I/O configuration for pin PIO0_1/ACMP_I1/CLKIN
        volatile uint32_t PIO0_9;  ///< Offset: 0x34 - I/O configuration for pin PIO0_9/XTALOUT
        volatile uint32_t PIO0_8;  ///< Offset: 0x38 - I/O configuration for pin PIO0_8/XTALIN
        volatile uint32_t PIO0_7;  ///< Offset: 0x3C - I/O configuration for pin PIO0_7
        volatile uint32_t PIO0_6;  ///< Offset: 0x40 - I/O configuration for pin PIO0_6/VDDCMP
        volatile uint32_t PIO0_0;  ///< Offset: 0x44 - I/O configuration for pin PIO0_0/ACMP_I0
        volatile uint32_t PIO0_14;  ///< Offset: 0x48 - I/O configuration for pin PIO0_14
    };

    /// Peripheral instances
    inline Registers* IOCON = reinterpret_cast<Registers*>(IOCON_BASE);

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x40048000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t SYSMEMREMAP;  ///< Offset: 0x00 - System memory remap
        volatile uint32_t PRESETCTRL;  ///< Offset: 0x04 - Peripheral reset control
        volatile uint32_t SYSPLLCTRL;  ///< Offset: 0x08 - System PLL control
        volatile uint32_t SYSPLLSTAT;  ///< Offset: 0x0C - System PLL status
        volatile uint32_t SYSOSCCTRL;  ///< Offset: 0x20 - System oscillator control
        volatile uint32_t WDTOSCCTRL;  ///< Offset: 0x24 - Watchdog oscillator control
        volatile uint32_t SYSRSTSTAT;  ///< Offset: 0x30 - System reset status register
        volatile uint32_t SYSPLLCLKSEL;  ///< Offset: 0x40 - System PLL clock source select
        volatile uint32_t SYSPLLCLKUEN;  ///< Offset: 0x44 - System PLL clock source update enable
        volatile uint32_t MAINCLKSEL;  ///< Offset: 0x70 - Main clock source select
        volatile uint32_t MAINCLKUEN;  ///< Offset: 0x74 - Main clock source update enable
        volatile uint32_t SYSAHBCLKDIV;  ///< Offset: 0x78 - System clock divider
        volatile uint32_t SYSAHBCLKCTRL;  ///< Offset: 0x80 - System clock control
        volatile uint32_t UARTCLKDIV;  ///< Offset: 0x94 - UART clock divider
        volatile uint32_t CLKOUTSEL;  ///< Offset: 0xE0 - CLKOUT clock source select
        volatile uint32_t CLKOUTUEN;  ///< Offset: 0xE4 - CLKOUT clock source update enable
        volatile uint32_t CLKOUTDIV;  ///< Offset: 0xE8 - CLKOUT clock divider
        volatile uint32_t UARTFRGDIV;  ///< Offset: 0xF0 - UART fractional generator divider value
        volatile uint32_t UARTFRGMULT;  ///< Offset: 0xF4 - UART fractional generator multiplier value
        volatile uint32_t EXTTRACECMD;  ///< Offset: 0xFC - External trace buffer command register
        volatile uint32_t PIOPORCAP0;  ///< Offset: 0x100 - POR captured PIO status 0
        volatile uint32_t IOCONCLKDIV6;  ///< Offset: 0x134 - Peripheral clock 6 to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV5;  ///< Offset: 0x138 - Peripheral clock 5 to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV4;  ///< Offset: 0x13C - Peripheral clock 4 to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV3;  ///< Offset: 0x140 - Peripheral clock 3 to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV2;  ///< Offset: 0x144 - Peripheral clock 2 to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV1;  ///< Offset: 0x148 - Peripheral clock 1 to the IOCON block for programmable...
        volatile uint32_t IOCONCLKDIV0;  ///< Offset: 0x14C - Peripheral clock 0 to the IOCON block for programmable...
        volatile uint32_t BODCTRL;  ///< Offset: 0x150 - Brown-Out Detect
        volatile uint32_t SYSTCKCAL;  ///< Offset: 0x154 - System tick counter calibration
        volatile uint32_t IRQLATENCY;  ///< Offset: 0x170 - IQR delay. Allows trade-off between interrupt latency...
        volatile uint32_t NMISRC;  ///< Offset: 0x174 - NMI Source Control
        volatile uint32_t PINTSEL%s;  ///< Offset: 0x178 - GPIO Pin Interrupt Select register 0
        volatile uint32_t STARTERP0;  ///< Offset: 0x204 - Start logic 0 pin wake-up enable register
        volatile uint32_t STARTERP1;  ///< Offset: 0x214 - Start logic 1 interrupt wake-up enable register
        volatile uint32_t PDSLEEPCFG;  ///< Offset: 0x230 - Power-down states in deep-sleep mode
        volatile uint32_t PDAWAKECFG;  ///< Offset: 0x234 - Power-down states for wake-up from deep-sleep
        volatile uint32_t PDRUNCFG;  ///< Offset: 0x238 - Power configuration register
        volatile uint32_t DEVICE_ID;  ///< Offset: 0x3F4 - Device ID
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C_BASE = 0x40050000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - Configuration for shared functions.
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register for Master, Slave, and Monitor functions.
        volatile uint32_t INTENSET;  ///< Offset: 0x08 - Interrupt Enable Set and read register.
        volatile uint32_t INTENCLR;  ///< Offset: 0x0C - Interrupt Enable Clear register.
        volatile uint32_t TIMEOUT;  ///< Offset: 0x10 - Time-out value register.
        volatile uint32_t DIV;  ///< Offset: 0x14 - Clock pre-divider for the entire I2C block. This...
        volatile uint32_t INTSTAT;  ///< Offset: 0x18 - Interrupt Status register for Master, Slave, and Monitor...
        volatile uint32_t MSTCTL;  ///< Offset: 0x20 - Master control register.
        volatile uint32_t MSTTIME;  ///< Offset: 0x24 - Master timing configuration.
        volatile uint32_t MSTDAT;  ///< Offset: 0x28 - Combined Master receiver and transmitter data register.
        volatile uint32_t SLVCTL;  ///< Offset: 0x40 - Slave control register.
        volatile uint32_t SLVDAT;  ///< Offset: 0x44 - Combined Slave receiver and transmitter data register.
        volatile uint32_t SLVADR%s;  ///< Offset: 0x48 - Slave address 0.
        volatile uint32_t SLVQUAL0;  ///< Offset: 0x58 - Slave Qualification for address 0.
        volatile uint32_t MONRXDAT;  ///< Offset: 0x80 - Monitor receiver data register.
    };

    /// Peripheral instances
    inline Registers* I2C = reinterpret_cast<Registers*>(I2C_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40058000;
    constexpr uint32_t SPI1_BASE = 0x4005C000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - SPI Configuration register
        volatile uint32_t DLY;  ///< Offset: 0x04 - SPI Delay register
        volatile uint32_t STAT;  ///< Offset: 0x08 - SPI Status. Some status flags can be cleared by writing...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - SPI Interrupt Enable read and Set. A complete value may...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - SPI Interrupt Enable Clear. Writing a 1 to any...
        volatile uint32_t RXDAT;  ///< Offset: 0x14 - SPI Receive Data
        volatile uint32_t TXDATCTL;  ///< Offset: 0x18 - SPI Transmit Data with Control
        volatile uint32_t TXDAT;  ///< Offset: 0x1C - SPI Transmit Data
        volatile uint32_t TXCTL;  ///< Offset: 0x20 - SPI Transmit Control
        volatile uint32_t DIV;  ///< Offset: 0x24 - SPI clock Divider
        volatile uint32_t INTSTAT;  ///< Offset: 0x28 - SPI Interrupt Status
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART0_BASE = 0x40064000;
    constexpr uint32_t USART1_BASE = 0x40068000;
    constexpr uint32_t USART2_BASE = 0x4006C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CFG;  ///< Offset: 0x00 - USART Configuration register. Basic USART configuration...
        volatile uint32_t CTRL;  ///< Offset: 0x04 - USART Control register. USART control settings that are...
        volatile uint32_t STAT;  ///< Offset: 0x08 - USART Status register. The complete status value can be...
        volatile uint32_t INTENSET;  ///< Offset: 0x0C - Interrupt Enable read and Set register. Contains an...
        volatile uint32_t INTENCLR;  ///< Offset: 0x10 - Interrupt Enable Clear register. Allows clearing any...
        volatile uint32_t RXDATA;  ///< Offset: 0x14 - Receiver Data register. Contains the last character received.
        volatile uint32_t RXDATASTAT;  ///< Offset: 0x18 - Receiver Data with Status register. Combines the last...
        volatile uint32_t TXDATA;  ///< Offset: 0x1C - Transmit Data register. Data to be transmitted is written here.
        volatile uint32_t BRG;  ///< Offset: 0x20 - Baud Rate Generator register. 16-bit integer baud rate...
        volatile uint32_t INTSTAT;  ///< Offset: 0x24 - Interrupt status register. Reflects interrupts that are...
    };

    /// Peripheral instances
    inline Registers* USART0 = reinterpret_cast<Registers*>(USART0_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x50000000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - CRC mode register
        volatile uint32_t SEED;  ///< Offset: 0x04 - CRC seed register
        volatile uint32_t SUM;  ///< Offset: 0x08 - CRC checksum register
        volatile uint32_t WR_DATA;  ///< Offset: 0x08 - CRC data register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

}

// ============================================================================
// SCT Peripheral
// ============================================================================

namespace sct {
    /// Base addresses
    constexpr uint32_t SCT_BASE = 0x50004000;

    /// SCT Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - SCT configuration register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - SCT control register
        volatile uint32_t LIMIT;  ///< Offset: 0x08 - SCT limit register
        volatile uint32_t HALT;  ///< Offset: 0x0C - SCT halt condition register
        volatile uint32_t STOP;  ///< Offset: 0x10 - SCT stop condition register
        volatile uint32_t START;  ///< Offset: 0x14 - SCT start condition register
        volatile uint32_t COUNT;  ///< Offset: 0x40 - SCT counter register
        volatile uint32_t STATE;  ///< Offset: 0x44 - SCT state register
        volatile uint32_t INPUT;  ///< Offset: 0x48 - SCT input register
        volatile uint32_t REGMODE;  ///< Offset: 0x4C - SCT match/capture registers mode register
        volatile uint32_t OUTPUT;  ///< Offset: 0x50 - SCT output register
        volatile uint32_t OUTPUTDIRCTRL;  ///< Offset: 0x54 - SCT output counter direction control register
        volatile uint32_t RES;  ///< Offset: 0x58 - SCT conflict resolution register
        volatile uint32_t EVEN;  ///< Offset: 0xF0 - SCT event enable register
        volatile uint32_t EVFLAG;  ///< Offset: 0xF4 - SCT event flag register
        volatile uint32_t CONEN;  ///< Offset: 0xF8 - SCT conflict enable register
        volatile uint32_t CONFLAG;  ///< Offset: 0xFC - SCT conflict flag register
        volatile uint32_t MATCH%s;  ///< Offset: 0x100 - SCT match value register of match channels 0 to 4;...
        volatile uint32_t CAP%s;  ///< Offset: 0x100 - SCT capture register of capture channel 0 to 4; REGMOD0...
        volatile uint32_t MATCHREL%s;  ///< Offset: 0x200 - SCT match reload value register 0 to 4 REGMOD0 = 0 to...
        volatile uint32_t CAPCTRL%s;  ///< Offset: 0x200 - SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1
        volatile uint32_t EV0_STATE;  ///< Offset: 0x300 - SCT event state register 0
        volatile uint32_t EV0_CTRL;  ///< Offset: 0x304 - SCT event control register 0
        volatile uint32_t EV1_STATE;  ///< Offset: 0x308 - SCT event state register 1
        volatile uint32_t EV1_CTRL;  ///< Offset: 0x30C - SCT event control register 1
        volatile uint32_t EV2_STATE;  ///< Offset: 0x310 - SCT event state register 2
        volatile uint32_t EV2_CTRL;  ///< Offset: 0x314 - SCT event control register 2
        volatile uint32_t EV3_STATE;  ///< Offset: 0x318 - SCT event state register 3
        volatile uint32_t EV3_CTRL;  ///< Offset: 0x31C - SCT event control register 3
        volatile uint32_t EV4_STATE;  ///< Offset: 0x320 - SCT event state register 4
        volatile uint32_t EV4_CTRL;  ///< Offset: 0x324 - SCT event control register 4
        volatile uint32_t EV5_STATE;  ///< Offset: 0x328 - SCT event state register 5
        volatile uint32_t EV5_CTRL;  ///< Offset: 0x32C - SCT event control register 5
        volatile uint32_t OUT0_SET;  ///< Offset: 0x500 - SCT output 0 set register
        volatile uint32_t OUT0_CLR;  ///< Offset: 0x504 - SCT output 0 clear register
        volatile uint32_t OUT1_SET;  ///< Offset: 0x508 - SCT output 1 set register
        volatile uint32_t OUT1_CLR;  ///< Offset: 0x50C - SCT output 1 clear register
        volatile uint32_t OUT2_SET;  ///< Offset: 0x510 - SCT output 2 set register
        volatile uint32_t OUT2_CLR;  ///< Offset: 0x514 - SCT output 2 clear register
        volatile uint32_t OUT3_SET;  ///< Offset: 0x518 - SCT output 3 set register
        volatile uint32_t OUT3_CLR;  ///< Offset: 0x51C - SCT output 3 clear register
    };

    /// Peripheral instances
    inline Registers* SCT = reinterpret_cast<Registers*>(SCT_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_PORT_BASE = 0xA0000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t B%s;  ///< Offset: 0x00 - Byte pin registers port 0; pins PIO0_0 to PIO0_17
        volatile uint32_t W%s;  ///< Offset: 0x1000 - Word pin registers port 0
        volatile uint32_t DIR0;  ///< Offset: 0x2000 - Direction registers port 0
        volatile uint32_t MASK0;  ///< Offset: 0x2080 - Mask register port 0
        volatile uint32_t PIN0;  ///< Offset: 0x2100 - Port pin register port 0
        volatile uint32_t MPIN0;  ///< Offset: 0x2180 - Masked port register port 0
        volatile uint32_t SET0;  ///< Offset: 0x2200 - Write: Set register for port 0 Read: output bits for port 0
        volatile uint32_t CLR0;  ///< Offset: 0x2280 - Clear port 0
        volatile uint32_t NOT0;  ///< Offset: 0x2300 - Toggle port 0
    };

    /// Peripheral instances
    inline Registers* GPIO_PORT = reinterpret_cast<Registers*>(GPIO_PORT_BASE);

}

// ============================================================================
// PIN Peripheral
// ============================================================================

namespace pin {
    /// Base addresses
    constexpr uint32_t PIN_INT_BASE = 0xA0004000;

    /// PIN Register structure
    struct Registers {
        volatile uint32_t ISEL;  ///< Offset: 0x00 - Pin Interrupt Mode register
        volatile uint32_t IENR;  ///< Offset: 0x04 - Pin interrupt level or rising edge interrupt enable register
        volatile uint32_t SIENR;  ///< Offset: 0x08 - Pin interrupt level (rising edge) interrupt set register
        volatile uint32_t CIENR;  ///< Offset: 0x0C - Pin interrupt level or rising edge interrupt clear register
        volatile uint32_t IENF;  ///< Offset: 0x10 - Pin interrupt active level or falling edge interrupt...
        volatile uint32_t SIENF;  ///< Offset: 0x14 - Pin interrupt active level or falling edge interrupt set register
        volatile uint32_t CIENF;  ///< Offset: 0x18 - Pin interrupt active level (falling edge) interrupt...
        volatile uint32_t RISE;  ///< Offset: 0x1C - Pin interrupt rising edge register
        volatile uint32_t FALL;  ///< Offset: 0x20 - Pin interrupt falling edge register
        volatile uint32_t IST;  ///< Offset: 0x24 - Pin interrupt status register
        volatile uint32_t PMCTRL;  ///< Offset: 0x28 - GPIO pattern match interrupt control register
        volatile uint32_t PMSRC;  ///< Offset: 0x2C - GPIO pattern match interrupt bit-slice source register
        volatile uint32_t PMCFG;  ///< Offset: 0x30 - GPIO pattern match interrupt bit slice configuration register
    };

    /// Peripheral instances
    inline Registers* PIN_INT = reinterpret_cast<Registers*>(PIN_INT_BASE);

}


} // namespace alloy::generated::lpc800

#endif // ALLOY_GENERATED_LPC800_PERIPHERALS_HPP