/// Auto-generated code for M05x_registers
/// Generated by Alloy Code Generator
/// Source: nuvoton_m051.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:51
#ifndef ALLOY_GENERATED_M05X_REGISTERS_PERIPHERALS_HPP
#define ALLOY_GENERATED_M05X_REGISTERS_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::m05x_registers {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x400E0000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADDR0;  ///< Offset: 0x00 - A/D Data Register 0
        volatile uint32_t ADDR1;  ///< Offset: 0x04 - A/D Data Register 1
        volatile uint32_t ADDR2;  ///< Offset: 0x08 - A/D Data Register 2
        volatile uint32_t ADDR3;  ///< Offset: 0x0C - A/D Data Register 3
        volatile uint32_t ADDR4;  ///< Offset: 0x10 - A/D Data Register 4
        volatile uint32_t ADDR5;  ///< Offset: 0x14 - A/D Data Register 5
        volatile uint32_t ADDR6;  ///< Offset: 0x18 - A/D Data Register 6
        volatile uint32_t ADDR7;  ///< Offset: 0x1C - A/D Data Register 7
        volatile uint32_t ADCR;  ///< Offset: 0x20 - A/D Control Register
        volatile uint32_t ADCHER;  ///< Offset: 0x24 - A/D Channel Enable Register
        volatile uint32_t ADCMPR0;  ///< Offset: 0x28 - A/D Compare Register 0
        volatile uint32_t ADCMPR1;  ///< Offset: 0x2C - A/D Compare Register 1
        volatile uint32_t ADSR;  ///< Offset: 0x30 - A/D Status Register
        volatile uint32_t ADCALR;  ///< Offset: 0x34 - A/D Calibration Register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ADDR0 Register bits
    namespace addr0_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR1 Register bits
    namespace addr1_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR2 Register bits
    namespace addr2_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR3 Register bits
    namespace addr3_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR4 Register bits
    namespace addr4_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR5 Register bits
    namespace addr5_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR6 Register bits
    namespace addr6_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADDR7 Register bits
    namespace addr7_bits {
        constexpr uint32_t RSLT = (12 << 0);  ///< A/D Conversion Result This field contains 12 bits conversion result.
        constexpr uint32_t OVERRUN = (1U << 16);  ///< Over Run Flag 1 = Data in RSLT[11:0] is overwrite. 0 = Data in RSLT[11:0] is recent conversion result. If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.
        constexpr uint32_t VALID = (1U << 17);  ///< Valid Flag 1 = Data in RSLT[11:0] bits is valid. 0 = Data in RSLT[11:0] bits is not valid. This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
    }

    /// ADCR Register bits
    namespace adcr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< A/D Converter Enable 1 = Enable 0 = Disable Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.
        constexpr uint32_t ADIE = (1U << 1);  ///< A/D Interrupt Enable 1 = Enable A/D interrupt function 0 = Disable A/D interrupt function A/D conversion end interrupt request is generated if ADIE bit is set to 1.
        constexpr uint32_t ADMD = (2 << 2);  ///< A/D Converter Operation Mode 00 = Single conversion 01 = Burst conversion 10 = Single-cycle scan 11 = Continuous scan When changing the operation mode, software should disable ADST bit firstly. Note: In Burst Mode, the A/D result data always at Data Register 0.
        constexpr uint32_t TRGS = (2 << 4);  ///< Hardware Trigger Source 00 = A/D conversion is started by external STADC pin. Others = Reserved Software should disable TRGE and ADST before change TRGS. In hardware trigger mode, the ADST bit is set by the external trigger from STADC.
        constexpr uint32_t TRGCOND = (2 << 6);  ///< External Trigger Condition These two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state. 00 = Low level 01 = High level 10 = Falling edge 11 = Rising edge
        constexpr uint32_t TRGE = (1U << 8);  ///< External Trigger Enable Enable or disable triggering of A/D conversion by external STADC pin. 1= Enable 0= Disable
        constexpr uint32_t DIFFEN = (1U << 10);  ///< A/D Differential Input Mode Enable 1 = A/D is in differential analog input mode 0 = A/D is in single-end analog input mode Differential input voltage (Vdiff) = Vplus - Vminus The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin. The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin. The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin. The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin. In differential input mode, only one of the two corresponding channels needs to be enabled in ADCHER. The conversion result will be placed to the corresponding data register of the enabled channel. If both channels of a differential input paired channel are enabled, the ADC will convert it twice in scan mode. And then write the conversion result to the two corresponding data registers.
        constexpr uint32_t ADST = (1U << 11);  ///< A/D Conversion Start 1 = Conversion start. 0 = Conversion stopped and A/D converter enter idle state. ADST bit can be controlled by two sources: software write and external pin STADC. ADST is cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode on specified channels. In continuous scan mode, A/D conversion is continuously performed sequentially until this bit is cleared to 0 or chip reset.
    }

    /// ADCHER Register bits
    namespace adcher_bits {
        constexpr uint32_t CHEN0 = (1U << 0);  ///< Analog Input Channel 0 Enable 1 = Enable 0 = Disable This channel is the default enabled channel if CHEN0~7 are set as 0s.
        constexpr uint32_t CHEN1 = (1U << 1);  ///< Analog Input Channel 1 Enable 1 = Enable 0 = Disable
        constexpr uint32_t CHEN2 = (1U << 2);  ///< Analog Input Channel 2 Enable 1 = Enable 0 = Disable
        constexpr uint32_t CHEN3 = (1U << 3);  ///< Analog Input Channel 3 Enable 1 = Enable 0 = Disable
        constexpr uint32_t CHEN4 = (1U << 4);  ///< Analog Input Channel 4 Enable 1 = Enable 0 = Disable
        constexpr uint32_t CHEN5 = (1U << 5);  ///< Analog Input Channel 5 Enable 1 = Enable 0 = Disable
        constexpr uint32_t CHEN6 = (1U << 6);  ///< Analog Input Channel 6 Enable 1 = Enable 0 = Disable
        constexpr uint32_t CHEN7 = (1U << 7);  ///< Analog Input Channel 7 Enable 1 = Enable 0 = Disable
        constexpr uint32_t PRESEL = (2 << 8);  ///< Analog Input Channel 7 select 00: External analog input 01: Internal bandgap voltage 1x: Reserved
    }

    /// ADCMPR0 Register bits
    namespace adcmpr0_bits {
        constexpr uint32_t CMPEN = (1U << 0);  ///< Compare Enable 1 = Enable compare. 0 = Disable compare. Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.
        constexpr uint32_t CMPIE = (1U << 1);  ///< Compare Interrupt Enable 1 = Enable compare function interrupt. 0 = Disable compare function interrupt. If the compare function is enabled and the compare condition matches the settings of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted. If CMPIE is set to 1, a compare interrupt request is generated.
        constexpr uint32_t CMPCOND = (1U << 2);  ///< Compare Condition 1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will increase one. 0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will increase one. Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit will be set.
        constexpr uint32_t CMPCH = (3 << 3);  ///< Compare Channel Selection 000 = Channel 0 conversion result is selected to be compared. 001 = Channel 1 conversion result is selected to be compared. 010 = Channel 2 conversion result is selected to be compared. 011 = Channel 3 conversion result is selected to be compared. 100 = Channel 4 conversion result is selected to be compared. 101 = Channel 5 conversion result is selected to be compared. 110 = Channel 6 conversion result is selected to be compared. 111 = Channel 7 conversion result is selected to be compared.
        constexpr uint32_t CMPMATCNT = (4 << 8);  ///< Compare Match Count When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit will be set.
        constexpr uint32_t CMPD = (12 << 16);  ///< Comparison Data The 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.
    }

    /// ADCMPR1 Register bits
    namespace adcmpr1_bits {
        constexpr uint32_t CMPEN = (1U << 0);  ///< Compare Enable 1 = Enable compare. 0 = Disable compare. Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.
        constexpr uint32_t CMPIE = (1U << 1);  ///< Compare Interrupt Enable 1 = Enable compare function interrupt. 0 = Disable compare function interrupt. If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF1 bit will be asserted. If CMPIE is set to 1, a compare interrupt request is generated.
        constexpr uint32_t CMPCOND = (1U << 2);  ///< Compare Condition 1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD(ADCMPR1[27:16]), the internal match counter will increase one. 0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD(ADCMPR1[27:16]), the internal match counter will increase one. Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF1 bit will be set.
        constexpr uint32_t CMPCH = (3 << 3);  ///< Compare Channel Selection 000 = Channel 0 conversion result is selected to be compared. 001 = Channel 1 conversion result is selected to be compared. 010 = Channel 2 conversion result is selected to be compared. 011 = Channel 3 conversion result is selected to be compared. 100 = Channel 4 conversion result is selected to be compared. 101 = Channel 5 conversion result is selected to be compared. 110 = Channel 6 conversion result is selected to be compared. 111 = Channel 7 conversion result is selected to be compared.
        constexpr uint32_t CMPMATCNT = (4 << 8);  ///< Compare Match Count When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF1 bit will be set.
        constexpr uint32_t CMPD = (12 << 16);  ///< Comparison Data The 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.
    }

    /// ADSR Register bits
    namespace adsr_bits {
        constexpr uint32_t ADF = (1U << 0);  ///< A/D Conversion End Flag A status flag that indicates the end of A/D conversion. ADF is set to 1 at these two conditions: When A/D conversion ends in single mode When A/D conversion ends on all specified channels in scan mode. When more than 4 samples in FIFO in Burst mode. This bit can be cleared by writing 1 to itself.
        constexpr uint32_t CMPF0 = (1U << 1);  ///< Compare Flag When the selected channel A/D conversion result meets the setting conditions of ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself. 1 = Conversion result in ADDR meets ADCMPR0 setting 0 = Conversion result in ADDR does not meet ADCMPR0 setting
        constexpr uint32_t CMPF1 = (1U << 2);  ///< Compare Flag When the selected channel A/D conversion result meets the setting conditions of ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself. 1 = Conversion result in ADDR meets ADCMPR1 setting 0 = Conversion result in ADDR does not meet ADCMPR1 setting
        constexpr uint32_t BUSY = (1U << 3);  ///< BUSY/IDLE 1 = A/D converter is busy at conversion. 0 = A/D converter is in idle state. This bit is mirror of as ADST bit in ADCR. It is read only.
        constexpr uint32_t CHANNEL = (3 << 4);  ///< Current Conversion Channel This filed reflects current conversion channel when BUSY=1. When BUSY=0, it shows the next channel will be converted. It is read only.
        constexpr uint32_t VALID = (8 << 8);  ///< Data Valid flag It is a mirror of VALID bit in ADDRx When ADC is in Burst Mode, and there is at least one valid conversion result in buffer, VALID[7:0] will all set to 1.
        constexpr uint32_t OVERRUN = (8 << 16);  ///< Over Run flag It is a mirror to OVERRUN bit in ADDRx When ADC is in Burst Mode, and the buffer is overrun, OVERRUN[7:0] will all set to 1.
    }

    /// ADCALR Register bits
    namespace adcalr_bits {
        constexpr uint32_t CALEN = (1U << 0);  ///< Self Calibration Enable 1 = Enable self calibration 0 = Disable self calibration Software can set this bit to 1 enables A/D converter to do self calibration function. It needs 127 ADC clocks to complete calibration. This bit must be kept at 1 after CALDONE asserted. Clearing this bit will disable self calibration function.
        constexpr uint32_t CALDONE = (1U << 1);  ///< Calibration is Done 1 = A/D converter self calibration is done. 0 = A/D converter has not been calibrated or calibration is in progress if CALEN bit is set. When 0 is written to CALEN bit, CALDONE bit is cleared by hardware immediately. It is a read only bit.
    }

}

// ============================================================================
// CLK Peripheral
// ============================================================================

namespace clk {
    /// Base addresses
    constexpr uint32_t CLK_BASE = 0x50000200;

    /// CLK Register structure
    struct Registers {
        volatile uint32_t PWRCON;  ///< Offset: 0x00 - System Power Down Control Register
        volatile uint32_t AHBCLK;  ///< Offset: 0x04 - AHB Devices Clock Enable Control Register
        volatile uint32_t APBCLK;  ///< Offset: 0x08 - APB Devices Clock Enable Control Register
        volatile uint32_t CLKSTATUS;  ///< Offset: 0x0C - Clock status monitor Register
        volatile uint32_t CLKSEL0;  ///< Offset: 0x10 - Clock Source Select Control Register 0
        volatile uint32_t CLKSEL1;  ///< Offset: 0x14 - Clock Source Select Control Register 1
        volatile uint32_t CLKDIV;  ///< Offset: 0x18 - Clock Divider Number Register
        volatile uint32_t CLKSEL2;  ///< Offset: 0x1C - Clock Source Select Control Register 2
        volatile uint32_t PLLCON;  ///< Offset: 0x20 - PLL Control Register
        volatile uint32_t FRQDIV;  ///< Offset: 0x24 - Frequency Divider Control Register
    };

    /// Peripheral instances
    inline Registers* CLK = reinterpret_cast<Registers*>(CLK_BASE);

    // Bit definitions
    /// PWRCON Register bits
    namespace pwrcon_bits {
        constexpr uint32_t XTL12M_EN = (1U << 0);  ///< External Crystal Oscillator Control The bit default value is set by flash controller user configuration register config0 [26:24]. When the default clock source is from external crystal. The bit is auto set to "1" 1 = Crystal oscillation enable 0 = Crystal oscillation disable
        constexpr uint32_t OSC22M_EN = (1U << 2);  ///< Internal 22.1184 MHz Oscillator Control 1 = 22.1184 MHz Oscillation enable 0 = 22.1184 MHz Oscillation disable
        constexpr uint32_t OSC10K_EN = (1U << 3);  ///< Internal 10KHz Oscillator Control 1 = 10KHz Oscillation enable 0 = 10KHz Oscillation disable
        constexpr uint32_t PD_WU_DLY = (1U << 4);  ///< Enable the wake up delay counter. When the chip wakes up from power down mode, the clock control will delay certain clock cycles to wait system clock stable. The delayed clock cycle is 4096 clock cycles when chip work at external crystal (4 ~ 24MHz), and 256 clock cycles when chip work at 22.1184 MHz oscillator. 1 = Enable the clock cycle delay 0 = Disable the clock cycle delay
        constexpr uint32_t PD_WU_INT_EN = (1U << 5);  ///< Power down mode wake Up Interrupt Enable 0 = Disable 1 = Enable. The interrupt will occur when Power down mode (Deep Sleep Mode) wakeup.
        constexpr uint32_t PD_WU_STS = (1U << 6);  ///< Chip power down wake up status flag Set by "power down wake up", it indicates that resume from power down mode The flag is set if the GPIO(P0~P4), UART wakeup Write 1 to clear the bit Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.
        constexpr uint32_t PWR_DOWN_EN = (1U << 7);  ///< System power down enable bit When set this bit "1", the chip power down mode is enabled and the chip power down active is depend on the PD_WAIT_CPU bit (a) if the PD_WAIT_CPU is "0" then the chip power down after the PWR_DOWN_EN bit set. (b) if the PD_WAIT_CPU is "1" then the chip keep active till the CPU sleep mode also active and then the chip power down When chip wake up from power down, this bit is auto cleared, user need to set this bit again for next power down. When in power down mode, external crystal (4~ 24MHz) and the 22.1184 MHz OSC will be disabled in this mode, but the 10 kHz OSC is not controlled by power down mode. When in power down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by power down mode, if the peripheral clock source is from 10 kHz oscillator. 1 = Chip enter the power down mode instant or wait CPU sleep command WFI 0 = Chip operate in normal mode or CPU in idle mode (sleep mode) because of WFI command
        constexpr uint32_t PD_WAIT_CPU = (1U << 8);  ///< This bit control the power down entry condition 1 = Chip entry power down mode when the both PWR_DOWN and CPU run WFI instruction. 0 = Chip entry power down mode when the PWR_DOWN bit is set to 1
    }

    /// AHBCLK Register bits
    namespace ahbclk_bits {
        constexpr uint32_t ISP_EN = (1U << 2);  ///< Flash ISP Controller Clock Enable Control. 1 = To enable the Flash ISP controller clock. 0 = To disable the Flash ISP controller clock.
        constexpr uint32_t EBI_EN = (1U << 3);  ///< EBI Controller Clock Enable Control. 1 = To enable the EBI Controller clock. 0 = To disable the EBI Controller clock.
    }

    /// APBCLK Register bits
    namespace apbclk_bits {
        constexpr uint32_t WDT_EN = (1U << 0);  ///< Watch Dog Timer Clock Enable. This bit is the protected bit, program this need a open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 0 = Disable Watchdog Timer Clock 1 = Enable Watchdog Timer Clock
        constexpr uint32_t TMR0_EN = (1U << 2);  ///< Timer0 Clock Enable Control 0 = Disable Timer0 Clock 1 = Enable Timer0 Clock
        constexpr uint32_t TMR1_EN = (1U << 3);  ///< Timer1 Clock Enable Control 0 = Disable Timer1 Clock 1 = Enable Timer1 Clock
        constexpr uint32_t TMR2_EN = (1U << 4);  ///< Timer2 Clock Enable Control 0 = Disable Timer2 Clock 1 = Enable Timer2 Clock
        constexpr uint32_t TMR3_EN = (1U << 5);  ///< Timer3 Clock Enable Control 0 = Disable Timer3 Clock 1 = Enable Timer3 Clock
        constexpr uint32_t FDIV_EN = (1U << 6);  ///< Clock Divider Clock Enable Control 0 = Disable FDIV Clock 1 = Enable FDIV Clock
        constexpr uint32_t I2C_EN = (1U << 8);  ///< I2C Clock Enable Control. 0 = Disable I2C Clock 1 = Enable I2C Clock
        constexpr uint32_t SPI0_EN = (1U << 12);  ///< SPI0 Clock Enable Control. 0 = Disable SPI0 Clock 1 = Enable SPI0 Clock
        constexpr uint32_t SPI1_EN = (1U << 13);  ///< SPI1 Clock Enable Control. 0 = Disable SPI1 Clock 1 = Enable SPI1 Clock
        constexpr uint32_t UART0_EN = (1U << 16);  ///< UART0 Clock Enable Control. 1 = Enable UART0 clock 0 = Disable UART0 clock
        constexpr uint32_t UART1_EN = (1U << 17);  ///< UART1 Clock Enable Control. 1 = Enable UART1 clock 0 = Disable UART1 clock
        constexpr uint32_t PWM01_EN = (1U << 20);  ///< PWM_01 Clock Enable Control. 1 = Enable PWM01 clock 0 = Disable PWM01 clock
        constexpr uint32_t PWM23_EN = (1U << 21);  ///< PWM_23 Clock Enable Control. 1 = Enable PWM23 clock 0 = Disable PWM23 clock
        constexpr uint32_t PWM45_EN = (1U << 22);  ///< PWM_45 Clock Enable Control. 1 = Enable PWM45 clock 0 = Disable PWM45 clock
        constexpr uint32_t PWM67_EN = (1U << 23);  ///< PWM_67 Clock Enable Control. 1 = Enable PWM67 clock 0 = Disable PWM67 clock
        constexpr uint32_t ADC_EN = (1U << 28);  ///< Analog-Digital-Converter (ADC) Clock Enable Control. 1 = Enable ADC clock 0 = Disable ADC clock
    }

    /// CLKSTATUS Register bits
    namespace clkstatus_bits {
        constexpr uint32_t XTL12M_STB = (1U << 0);  ///< XTL12M clock source stable flag 1 = External Crystal clock is stable 0 = External Crystal clock is not stable or not enable
        constexpr uint32_t PLL_STB = (1U << 2);  ///< PLL clock source stable flag 1 = PLL clock is stable 0 = PLL clock is not stable or not enable
        constexpr uint32_t OSC10K_STB = (1U << 3);  ///< OSC10K clock source stable flag 1 = OSC10K clock is stable 0 = OSC10K clock is not stable or not enable
        constexpr uint32_t OSC22M_STB = (1U << 4);  ///< OSC22M clock source stable flag 1 = OSC22M clock is stable 0 = OSC22M clock is not stable or not enable
        constexpr uint32_t CLK_SW_FAIL = (1U << 7);  ///< Clock switch fail flag 1 = Clock switch fail 0 = Clock switch success This bit will be set when target switch clock source is not stable. Write 1 to clear this bit to zero.
    }

    /// CLKSEL0 Register bits
    namespace clksel0_bits {
        constexpr uint32_t HCLK_S = (3 << 0);  ///< HCLK clock source select. Note: Before clock switch the related clock sources (pre-select and new-select) must be turn on The 3-bit default value is reloaded with the value of Config0.CFOSC[26:24] in user configuration register in Flash controller by any reset. Therefore the default value is either 000b or 111b. These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 000 = clock source from external crystal clock (4 ~ 24MHz) 010 = clock source from PLL clock 011 = clock source from internal 10KHz oscillator clock 111 = clock source from internal 22.1184 MHz oscillator clock others = Reserved
        constexpr uint32_t STCLK_S = (3 << 3);  ///< MCU Cortex_M0 SysTick clock source select. These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 000 = Clock source from external crystal clock (4 ~ 24MHz) 010 = Clock source from external crystal clock (4 ~ 24MHz)/2 011 = clock source from HCLK/2 1xx = clock source from internal 22.1184 MHz oscillator clock/2
    }

    /// CLKSEL1 Register bits
    namespace clksel1_bits {
        constexpr uint32_t WDT_S = (2 << 0);  ///< Watchdog Timer clock source select. These bits are protected bit, program this need a open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 00 = clock source from external crystal clock (4 ~ 24MHz). 10 = clock source from HCLK/2048 clock 11 = clock source from internal 10KHz oscillator clock
        constexpr uint32_t ADC_S = (2 << 2);  ///< ADC clock source select. 00 = clock source from external crystal clock (4 ~ 24MHz). 01 = clock source from PLL clock 1x = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t TMR0_S = (3 << 8);  ///< TIMER0 clock source select. 000 = clock source from external crystal clock (4 ~ 24MHz) 010 = clock source from HCLK 011 = clock source from external trigger 1xx = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t TMR1_S = (3 << 12);  ///< TIMER1 clock source select. 000 = clock source from external crystal clock (4 ~ 24MHz) 010 = clock source from HCLK 011 = clock source from external trigger 1xx = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t TMR2_S = (3 << 16);  ///< TIMER2 clock source select. 000 = clock source from external crystal clock (4 ~ 24MHz) 010 = clock source from HCLK 011 = clock source from external trigger 1xx = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t TMR3_S = (3 << 20);  ///< TIMER3 clock source select. 000 = clock source from external crystal clock (4 ~ 24MHz) 010 = clock source from HCLK 011 = clock source from external trigger 1xx = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t UART_S = (2 << 24);  ///< UART clock source select. 00 = clock source from external crystal clock (4 ~ 24MHz) 01 = clock source from PLL clock 1x = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t PWM01_S = (2 << 28);  ///< PWM0 and PWM1 clock source select. PWM0 and PWM1 uses the same Engine clock source, both of them with the same pre-scalar 00 = clock source from external crystal clock (4 ~ 24MHz) 10 = clock source from HCLK 11 = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t PWM23_S = (2 << 30);  ///< PWM2 and PWM3 clock source select. PWM2 and PWM3 uses the same Engine clock source, both of them with the same pre-scalar 00 = clock source from external crystal clock (4 ~ 24MHz) 10 = clock source from HCLK 11 = clock source from internal 22.1184 MHz oscillator clock
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t HCLK_N = (4 << 0);  ///< HCLK clock divide number from HCLK clock source The HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)
        constexpr uint32_t UART_N = (4 << 8);  ///< UART clock divide number from UART clock source The UART clock frequency = (UART clock source frequency ) / (UART_N + 1)
        constexpr uint32_t ADC_N = (8 << 16);  ///< ADC clock divide number from ADC clock source The ADC clock frequency = (ADC clock source frequency ) / (ADC_N + 1)
    }

    /// CLKSEL2 Register bits
    namespace clksel2_bits {
        constexpr uint32_t FRQDIV_S = (2 << 2);  ///< Clock Divider Clock Source Select 00 = clock source from external crystal clock (4 ~ 24MHz) 10 = clock source from HCLK 11 = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t PWM45_S = (2 << 4);  ///< PWM4 and PWM5 clock source select. - PWM4 and PWM5 used the same Engine clock source, both of them with the same pre-scalar 00 = clock source from external crystal clock (4 ~ 24MHz) 10 = clock source from HCLK 11 = clock source from internal 22.1184 MHz oscillator clock
        constexpr uint32_t PWM67_S = (2 << 6);  ///< PWM6 and PWM7 clock source select. - PWM6 and PWM7 used the same Engine clock source, both of them with the same pre-scalar 00 = clock source from external crystal clock (4 ~ 24MHz) 10 = clock source from HCLK 11 = clock source from internal 22.1184 MHz oscillator clock
    }

    /// PLLCON Register bits
    namespace pllcon_bits {
        constexpr uint32_t FB_DV = (9 << 0);  ///< PLL Feedback Divider Control Pins (PLL_F[8:0])
        constexpr uint32_t IN_DV = (5 << 9);  ///< PLL Input Divider Control Pins (PLL_R[4:0])
        constexpr uint32_t OUT_DV = (2 << 14);  ///< PLL Output Divider Control Pins (PLL_OD[1:0])
        constexpr uint32_t PD = (1U << 16);  ///< Power Down Mode. If set the IDLE bit "1" in PWRCON register, the PLL will enter power down mode too 0 = PLL is in normal mode (default) 1 = PLL is in power-down mode
        constexpr uint32_t BP = (1U << 17);  ///< PLL Bypass Control 0 = PLL is in normal mode (default) 1 = PLL clock output is same as clock input (XTALin)
        constexpr uint32_t OE = (1U << 18);  ///< PLL OE (FOUT enable) pin Control 0 = PLL FOUT enable 1 = PLL FOUT is fixed low
        constexpr uint32_t PLL_SRC = (1U << 19);  ///< PLL Source Clock Select 1 = PLL source clock from 22.1184 MHz oscillator 0 = PLL source clock from external crystal clock (4 ~ 24 MHz)
    }

    /// FRQDIV Register bits
    namespace frqdiv_bits {
        constexpr uint32_t FSEL = (4 << 0);  ///< Divider Output Frequency Selection Bits The formula of output frequency is Fout = Fin/2(N+1), where Fin is the input clock frequency, Fout is the frequency of divider output clock, N is the 4-bit value of FSEL[3:0].
        constexpr uint32_t DIVIDER_EN = (1U << 4);  ///< Frequency Divider Enable Bit 0 = Disable Frequency Divider 1 = Enable Frequency Divider
    }

}

// ============================================================================
// EBI Peripheral
// ============================================================================

namespace ebi {
    /// Base addresses
    constexpr uint32_t EBI_CTL_BASE = 0x50010000;

    /// EBI Register structure
    struct Registers {
        volatile uint32_t EBICON;  ///< Offset: 0x00 - External Bus Interface General Control Register
        volatile uint32_t EXTIME;  ///< Offset: 0x04 - External Bus Interface 0 Timing Control Register
    };

    /// Peripheral instances
    inline Registers* EBI_CTL = reinterpret_cast<Registers*>(EBI_CTL_BASE);

    // Bit definitions
    /// EBICON Register bits
    namespace ebicon_bits {
        constexpr uint32_t ExtEN = (1U << 0);  ///< EBI Enable This bit is the functional enable bit for EBI. 0 = EBI function is disabled 1 = EBI function is enabled
        constexpr uint32_t ExtBW16 = (1U << 1);  ///< EBI data width 16 bit This bit defines if the data bus is 8-bit or 16-bit. 0 = EBI data width is 8 bit 1 = EBI data width is 16 bit
        constexpr uint32_t MCLKDIV = (3 << 8);  ///< External Output Clock Divider The frequency of EBI output clock is controlled by MCLKDIV. MCLKDIV	Output clock (MCLK)	 000	HCLK/1	 001	HCLK/2	 010	HCLK/4	 011	HCLK/8	 100	HCLK/16	 101	HCKL/32	 11X	default	 Notice: Default value of output clock is HCLK/1
        constexpr uint32_t ExttALE = (3 << 16);  ///< Expand Time of ALE The ALE width (tALE) to latch the address can be controlled by ExttALE. tALE = (ExttALE + 1) * MCLK
    }

    /// EXTIME Register bits
    namespace extime_bits {
        constexpr uint32_t ExttACC = (5 << 3);  ///< EBI Data Accesss Time ExttACC define data access time (tACC). tACC = (ExttACC + 1) * MCLK
        constexpr uint32_t ExttAHD = (3 << 8);  ///< EBI Data Access Hold Time ExttAHD define data access hold time (tAHD). tAHD = (ExttAHD + 1) * MCLK
        constexpr uint32_t ExtIW2X = (4 << 12);  ///< Idle State Cycle After Write When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero. Idle state cycle = (ExtIW2X * MCLK)
        constexpr uint32_t ExtIR2R = (4 << 24);  ///< Idle State Cycle Between Read-Read When read action is finish and next action is going to read, idle state is inserted and nCS return to high if ExtIR2R is not zero. Idle state cycle = (ExtIR2R * MCLK)
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x5000C000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t ISPCON;  ///< Offset: 0x00 - ISP Control Register
        volatile uint32_t ISPADR;  ///< Offset: 0x04 - ISP Address Register
        volatile uint32_t ISPDAT;  ///< Offset: 0x08 - ISP Data Register
        volatile uint32_t ISPCMD;  ///< Offset: 0x0C - ISP Command Register
        volatile uint32_t ISPTRG;  ///< Offset: 0x10 - ISP Trigger Control Register
        volatile uint32_t DFBADR;  ///< Offset: 0x14 - Data Flash Base Address
        volatile uint32_t FATCON;  ///< Offset: 0x18 - Flash Access Time Control Register
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// ISPCON Register bits
    namespace ispcon_bits {
        constexpr uint32_t ISPEN = (1U << 0);  ///< ISP Enable This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function. 1 = Enable ISP function 0 = Disable ISP function
        constexpr uint32_t BS = (1U << 1);  ///< Boot Select This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as MCU booting status flag, which can be used to check where MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-on reset; It keeps the same value at other reset. 1 = boot from LDROM 0 = boot from APROM
        constexpr uint32_t CFGUEN = (1U << 4);  ///< Config Update Enable Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program code is running in APROM or LDROM. 1 = Config update enable 0 = Config update disable
        constexpr uint32_t LDUEN = (1U << 5);  ///< LDROM Update Enable LDROM update enable bit. 1 = LDROM can be updated when the MCU runs in APROM. 0 = LDROM cannot be updated
        constexpr uint32_t ISPFF = (1U << 6);  ///< ISP Fail Flag This bit is set by hardware when a triggered ISP meets any of the following conditions: (1) APROM writes to itself. (2) LDROM writes to itself. (3) Destination address is illegal, such as over an available range. Write 1 to clear.
        constexpr uint32_t SWRST = (1U << 7);  ///< Software Reset Writing 1 to this bit to start software reset. It is cleared by hardware after reset is finished.
        constexpr uint32_t PT = (3 << 8);  ///< Flash Program Time PT[2]	PT[1]	PT[0]	Program Time (us)	 0	0	0	40	 0	0	1	45	 0	1	0	50	 0	1	1	55	 1	0	0	20	 1	0	1	25	 1	1	0	30	 1	1	1	35
        constexpr uint32_t ET = (3 << 12);  ///< Flash Erase Time ET[2]	ET[1]	ET[0]	Erase Time (ms)	 0	0	0	20 (default)	 0	0	1	25	 0	1	0	30	 0	1	1	35	 1	0	0	3	 1	0	1	5	 1	1	0	10	 1	1	1	15
    }

    /// ISPADR Register bits
    namespace ispadr_bits {
        constexpr uint32_t ISPADR = (32 << 0);  ///< ISP Address NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program only. ISPARD[1:0] must be kept 2'b00 for ISP operation.
    }

    /// ISPDAT Register bits
    namespace ispdat_bits {
        constexpr uint32_t ISPDAT = (32 << 0);  ///< ISP Data Write data to this register before ISP program operation Read data from this register after ISP read operation
    }

    /// ISPCMD Register bits
    namespace ispcmd_bits {
        constexpr uint32_t FOEN_FCEN_FCTRL = (6 << 0);  ///< ISP Command ISP command table is shown below: Operation Mode	FOEN	FCEN	FCTRL[3:0]	 Read	0	0	0	0	0	0	 Program	1	0	0	0	0	1	 Page Erase	1	0	0	0	1	0
    }

    /// ISPTRG Register bits
    namespace isptrg_bits {
        constexpr uint32_t ISPGO = (1U << 0);  ///< ISP start trigger Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finish. 1 = ISP is on going 0 = ISP done
    }

    /// DFBADR Register bits
    namespace dfbadr_bits {
        constexpr uint32_t DFBA = (32 << 0);  ///< Data Flash Base Address This register indicates data flash start address. It is a read only register. For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at 0x01F000 by hardware internally.
    }

    /// FATCON Register bits
    namespace fatcon_bits {
        constexpr uint32_t FPSEN = (1U << 0);  ///< Flash Power Save Enable If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function. 1 = Enable flash power saving 0 = Disable flash power saving
        constexpr uint32_t FATS = (3 << 1);  ///< Flash Access Time Window Select These bits are used to decide flash sense amplifier active duration. FATS	Access Time window (ns)	 000	40	 001	50	 010	60	 011	70	 100	80	 101	90	 110	100	 111	Reserved
        constexpr uint32_t L_SPEED = (1U << 4);  ///< Flash Low Speed Mode Enable 1 = Flash access always no wait state (zero wait state) 0 = Insert wait state while Flash access discontinued address. Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong code and cause fail result.
    }

}

// ============================================================================
// GCR Peripheral
// ============================================================================

namespace gcr {
    /// Base addresses
    constexpr uint32_t GCR_BASE = 0x50000000;

    /// GCR Register structure
    struct Registers {
        volatile uint32_t PDID;  ///< Offset: 0x00 - Part Device Identification number Register
        volatile uint32_t RSTSRC;  ///< Offset: 0x04 - System Reset Source Register
        volatile uint32_t IPRSTC1;  ///< Offset: 0x08 - IP Reset Control Resister1
        volatile uint32_t IPRSTC2;  ///< Offset: 0x0C - IP Reset Control Resister 2
        volatile uint32_t BODCR;  ///< Offset: 0x18 - Brown Out Detector Control Register
        volatile uint32_t PORCR;  ///< Offset: 0x24 - Power-On-Reset Controller Register
        volatile uint32_t P0_MFP;  ///< Offset: 0x30 - P0 multiple function and input type control register
        volatile uint32_t P1_MFP;  ///< Offset: 0x34 - P1 multiple function and input type control register
        volatile uint32_t P2_MFP;  ///< Offset: 0x38 - P2 multiple function and input type control register
        volatile uint32_t P3_MFP;  ///< Offset: 0x3C - P3 multiple function and input type control register
        volatile uint32_t P4_MFP;  ///< Offset: 0x40 - P4 input type control register
        volatile uint32_t REGWRPROT;  ///< Offset: 0x100 - Register Lock Key address
    };

    /// Peripheral instances
    inline Registers* GCR = reinterpret_cast<Registers*>(GCR_BASE);

    // Bit definitions
    /// PDID Register bits
    namespace pdid_bits {
        constexpr uint32_t PDID = (32 << 0);  ///< This register reflects device part number code. S/W can read this register to identify which device is used.
    }

    /// RSTSRC Register bits
    namespace rstsrc_bits {
        constexpr uint32_t RSTS_POR = (1U << 0);  ///< The RSTS_POR flag is set by the "reset signal" which is from the Power-On Reset (POR) module or bit CHIP_RST (IPRSTC1[0]) is set, to indicate the previous reset source. 1= The Power-On-Reset(POR) or CHIP_RST=1 had issued the reset signal to reset the system. 0= No reset from POR This bit is cleared by writing 1 to itself.
        constexpr uint32_t RSTS_RESET = (1U << 1);  ///< The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source. 1= The Pin /RESET had issued the reset signal to reset the system. 0= No reset from Pin /RESET This bit is cleared by writing 1 to itself.
        constexpr uint32_t RSTS_WDT = (1U << 2);  ///< The RSTS_WDT flag is set by the "reset signal" from the Watch Dog Timer to indicate the previous reset source. 1= The Watch Dog Timer had issued the reset signal to reset the system. 0= No reset from Watch-Dog This bit is cleared by writing 1 to itself.
        constexpr uint32_t RSTS_LVR = (1U << 3);  ///< The RSTS_LVR flag is set by the "reset signal" from the Low-Voltage-Reset module to indicate the previous reset source. 1= The LVR module had issued the reset signal to reset the system. 0= No reset from LVR This bit is cleared by writing 1 to itself.
        constexpr uint32_t RSTS_BOD = (1U << 4);  ///< The RSTS_BOD flag is set by the "reset signal" from the Brown-Out-Detected module to indicate the previous reset source. 1= The Brown-Out-Detected module had issued the reset signal to reset the system. 0= No reset from BOD This bit is cleared by writing 1 to itself.
        constexpr uint32_t RSTS_MCU = (1U << 5);  ///< The RSTS_MCU flag is set by the "reset signal" from the MCU Cortex_M0 kernel to indicate the previous reset source. 1= The MCU Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel. 0= No reset from MCU This bit is cleared by writing 1 to itself.
        constexpr uint32_t RSTS_CPU = (1U << 7);  ///< The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) with a "1" to rest Cortex-M0 CPU kernel and Flash memory controller(FMC). 1= The Cortex-M0 CPU kernel and FMC are reset by software set CPU_RST to 1. 0= No reset from CPU This bit is cleared by writing 1 to itself.
    }

    /// IPRSTC1 Register bits
    namespace iprstc1_bits {
        constexpr uint32_t CHIP_RST = (1U << 0);  ///< CHIP one shot reset. Set this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will automatically return to "0" after the 2 clock cycles. The CHIP_RST is same as the POR reset , all the chip module is reset and the chip setting from flash are also reload This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 0= Normal 1= Reset CHIP
        constexpr uint32_t CPU_RST = (1U << 1);  ///< CPU kernel one shot reset. Set this bit will reset the Cortex-M0 CPU kernel and Flash memory controller (FMC). This bit will automatically return to "0" after the 2 clock cycles This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 0= Normal 1= Reset CPU
        constexpr uint32_t EBI_RST = (1U << 3);  ///< EBI Controller Reset Set these bit "1" will generate a reset signal to the EBI. User need to set this bit to "0" to release from the reset state This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100 0= Normal operation 1= EBI IP reset
    }

    /// IPRSTC2 Register bits
    namespace iprstc2_bits {
        constexpr uint32_t GPIO_RST = (1U << 1);  ///< GPIO (P0~P4) controller Reset 0= GPIO controller normal operation 1= GPIO controller reset
        constexpr uint32_t TMR0_RST = (1U << 2);  ///< Timer0 controller Reset 0= Timer0 controller normal operation 1= Timer0 controller reset
        constexpr uint32_t TMR1_RST = (1U << 3);  ///< Timer1 controller Reset 0= Timer1 controller normal operation 1= Timer1 controller reset
        constexpr uint32_t TMR2_RST = (1U << 4);  ///< Timer2 controller Reset 0= Timer2 controller normal operation 1= Timer2 controller reset
        constexpr uint32_t TMR3_RST = (1U << 5);  ///< Timer3 controller Reset 0= Timer3 controller normal operation 1= Timer3 controller reset
        constexpr uint32_t I2C_RST = (1U << 8);  ///< I2C controller Reset 0= I2C controller normal operation 1= I2C controller reset
        constexpr uint32_t SPI0_RST = (1U << 12);  ///< SPI0 controller Reset 0= SPI0 controller normal operation 1= SPI0 controller reset
        constexpr uint32_t SPI1_RST = (1U << 13);  ///< SPI1 controller Reset 0= SPI1 controller normal operation 1= SPI1 controller reset
        constexpr uint32_t UART0_RST = (1U << 16);  ///< UART0 controller Reset 0= UART0 controller Normal operation 1= UART0 controller reset
        constexpr uint32_t UART1_RST = (1U << 17);  ///< UART1 controller Reset 0 = UART1 controller normal operation 1 = UART1 controller reset
        constexpr uint32_t PWM03_RST = (1U << 20);  ///< PWM0~3 controller Reset 0= PWM0~3 controller normal operation 1= PWM0~3 controller reset
        constexpr uint32_t PWM47_RST = (1U << 21);  ///< PWM4~7 controller Reset 0= PWM4~7 controller normal operation 1= PWM4~7 controller reset
        constexpr uint32_t ADC_RST = (1U << 28);  ///< ADC Controller Reset 0= ADC controller normal operation 1= ADC controller reset
    }

    /// BODCR Register bits
    namespace bodcr_bits {
        constexpr uint32_t BOD_EN = (1U << 0);  ///< Brown Out Detector Enable (initiated & write-protected bit) The default value is set by flash controller user configuration register config0 bit[23] 1= Brown Out Detector function is enabled 0= Brown Out Detector function is disabled
        constexpr uint32_t BOD_VL = (2 << 1);  ///< Brown Out Detector Threshold Voltage Selection (initiated & write-protected bit) The default value is set by flash controller user configuration register config0 bit[22:21] BOV_VL[1]	BOV_VL[0]	Brown out voltage	 1	1	4.5V	 1	0	3.8V	 0	1	2.7V	 0	0	2.2V
        constexpr uint32_t BOD_RSTEN = (1U << 3);  ///< Brown Out Reset Enable (initiated & write-protected bit) 1= Enable the Brown Out "RESET" function, when the Brown Out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to reset the chip The default value is set by flash controller user configuration register config0 bit[20] 0= Enable the Brown Out "INTERRUPT" function, when the Brown Out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to interrupt the MCU Cortex-M0 When the BOD_EN is enabled and the interrupt is assert, the interrupt will keep till to the BOD_EN set to "0". The interrupt for CPU can be blocked by disable the NVIC in CPU for BOD interrupt or disable the interrupt source by disable the BOD_EN and then re-enable the BOD_EN function if the BOD function is required
        constexpr uint32_t BOD_INTF = (1U << 4);  ///< Brown Out Detector Interrupt Flag 1= When Brown Out Detector detects the VDD is dropped through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to "1" and the brown out interrupt is requested if brown out interrupt is enabled. 0= Brown Out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.
        constexpr uint32_t BOD_LPM = (1U << 5);  ///< Brown Out Detector Low power Mode (write-protected bit) 1= Enable the BOD low power mode 0= BOD operate in normal mode (default) The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
        constexpr uint32_t BOD_OUT = (1U << 6);  ///< The status for Brown Out Detector output state 1= Brown Out Detector status output is 1, the detected voltage is lower than BOD_VL setting. If the BOD_EN is "0"(disabled), this bit always response "0" 0= Brown Out Detector status output is 0, the detected voltage is higher than BOD_VL setting
        constexpr uint32_t LVR_EN = (1U << 7);  ///< Low Voltage Reset Enable (write-protected bit) The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled in default. 1= Enabled Low Voltage Reset function - After enable the bit, the LVR function will active with 100uS delay for LVR output stable.(default). 0= Disabled Low Voltage Reset function
    }

    /// PORCR Register bits
    namespace porcr_bits {
        constexpr uint32_t POR_DIS_CODE = (16 << 0);  ///< The register is used for the Power-On-Reset enable control. When power on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. If set the POR_DIS_CODE equal to 0x5AA5, the POR reset function will be disabled and the POR function will re-active till the power voltage is lower to set the POR_DIS_CODE to another value or reset by chip other reset function. Include: PIN reset, Watch dog, LVR reset BOD reset, ICE reset command and the software-chip reset function This register is the protected register, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
    }

    /// P0_MFP Register bits
    namespace p0_mfp_bits {
        constexpr uint32_t P0_MFP = (8 << 0);  ///< P0 multiple function Selection The pin function of P0 is depending on P0_MFP and P0_ALT. Refer to P0_ALT descriptions in detail.
        constexpr uint32_t P0_ALT0 = (1U << 8);  ///< P0.0 alternate function Selection The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0]. P0_ALT[0]	P0_MFP[0]	P0.0function	 0	0	P0.0	 0	1	AD0(EBI)	 1	0	CTS1(UART1)	 1	1	Reserved
        constexpr uint32_t P0_ALT1 = (1U << 9);  ///< P0.1 alternate function Selection The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1]. P0_ALT[1]	P0_MFP[1]	P0.1function	 0	0	P0.1	 0	1	AD1(EBI)	 1	0	RTS1(UART1)	 1	1	Reserved
        constexpr uint32_t P0_ALT2 = (1U << 10);  ///< P0.2 alternate function Selection The pin function of P0.2 is depend on P0_MFP[2] and P0_ALT[2]. P0_ALT[2]	P0_MFP[2]	P0.2function	 0	0	P0.2	 0	1	AD2(EBI)	 1	0	CTS0(UART0)	 1	1	Reserved
        constexpr uint32_t P0_ALT3 = (1U << 11);  ///< P0.3 alternate function Selection The pin function of P0.3 is depend on P0_MFP[3] and P0_ALT[3]. P0_ALT[3]	P0_MFP[3]	P0.3function	 0	0	P0.3	 0	1	AD3(EBI)	 1	0	RTS0(UART0)	 1	1	Reserved
        constexpr uint32_t P0_ALT4 = (1U << 12);  ///< P0.4 alternate function Selection The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4]. P0_ALT[4]	P0_MFP[4]	P0.4function	 0	0	P0.4	 0	1	AD4(EBI)	 1	0	SPISS1(SPI1)	 1	1	Reserved
        constexpr uint32_t P0_ALT5 = (1U << 13);  ///< P0.5 alternate function Selection The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5]. P0_ALT[5]	P0_MFP[5]	P0.5 function	 0	0	P0.5	 0	1	AD5(EBI)	 1	0	MOSI_1(SPI1)	 1	1	Reserved
        constexpr uint32_t P0_ALT6 = (1U << 14);  ///< P0.6 alternate function Selection The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6]. P0_ALT[6]	P0_MFP[6]	P0.6 function	 0	0	P0.6	 0	1	AD6(EBI)	 1	0	MISO_1(SPI1)	 1	1	Reserved
        constexpr uint32_t P0_ALT7 = (1U << 15);  ///< P0.7 alternate function Selection The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7]. P0_ALT[7]	P0_MFP[7]	P0.7 function	 0	0	P0.7	 0	1	AD7(EBI)	 1	0	SPICLK1(SPI1)	 1	1	Reserved
        constexpr uint32_t P0_TYPEn = (8 << 16);  ///< P0[7:0] input Schmitt Trigger function Enable 1= P0[7:0] I/O input Schmitt Trigger function enable 0= P0[7:0] I/O input Schmitt Trigger function disable
    }

    /// P1_MFP Register bits
    namespace p1_mfp_bits {
        constexpr uint32_t P1_MFP = (8 << 0);  ///< P1 multiple function Selection The pin function of P1 is depending on P1_MFP and P1_ALT. Refer to P1_ALT descriptions in detail.
        constexpr uint32_t P1_ALT0 = (1U << 8);  ///< P1.0 alternate function Selection The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0]. P1_ALT[0]	P1_MFP[0]	P1.0function	 0	0	P1.0	 0	1	AIN0(ADC)	 1	0	T2(Timer2)	 1	1	Reserved
        constexpr uint32_t P1_ALT1 = (1U << 9);  ///< P1.1 alternate function Selection The pin function of P1.1 is depend on P1_MFP[1] and P1_ALT[1]. P1_ALT[1]	P1_MFP[1]	P1.1function	 0	0	P1.1	 0	1	AIN1(ADC)	 1	0	T3(Timer3)	 1	1	Reserved
        constexpr uint32_t P1_ALT2 = (1U << 10);  ///< P1.2 alternate function Selection The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2]. P1_ALT[2]	P1_MFP[2]	P1.2function	 0	0	P1.2	 0	1	AIN2(ADC)	 1	0	RXD1(UART1)	 1	1	Reserved
        constexpr uint32_t P1_ALT3 = (1U << 11);  ///< P1.3 alternate function Selection The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3]. P1_ALT[3]	P1_MFP[3]	P1.3function	 0	0	P1.3	 0	1	AIN3(ADC)	 1	0	TXD1(UART1)	 1	1	Reserved
        constexpr uint32_t P1_ALT4 = (1U << 12);  ///< P1.4 alternate function Selection The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4]. P1_ALT[4]	P1_MFP[4]	P1.4function	 0	0	P1.4	 0	1	AIN4(ADC)	 1	0	SPISS0(SPI0)	 1	1	Reserved
        constexpr uint32_t P1_ALT5 = (1U << 13);  ///< P1.5 alternate function Selection The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5]. P1_ALT[5]	P1_MFP[5]	P1.5 function	 0	0	P1.5	 0	1	AIN5(ADC)	 1	0	MOSI_0(SPI0)	 1	1	Reserved
        constexpr uint32_t P1_ALT6 = (1U << 14);  ///< P1.6 alternate function Selection The pin function of P1.6 is depend on P1_MFP[6] and P1_ALT[6]. P1_ALT[6]	P1_MFP[6]	P1.6 function	 0	0	P1.6	 0	1	AIN6(ADC)	 1	0	MISO_0(SPI0)	 1	1	Reserved
        constexpr uint32_t P1_ALT7 = (1U << 15);  ///< P1.7 alternate function Selection The pin function of P1.7 is depend on P1_MFP[7] and P1_ALT[7]. P1_ALT[7]	P1_MFP[7]	P1.7 function	 0	0	P1.7	 0	1	AIN7(ADC)	 1	0	SPICLK0(SPI0)	 1	1	Reserved
        constexpr uint32_t P1_TYPEn = (8 << 16);  ///< P1[7:0] input Schmitt Trigger function Enable 1= P1[7:0] I/O input Schmitt Trigger function enable 0= P1[7:0] I/O input Schmitt Trigger function disable
    }

    /// P2_MFP Register bits
    namespace p2_mfp_bits {
        constexpr uint32_t P2_MFP = (8 << 0);  ///< P2 multiple function Selection The pin function of P2 is depending on P2_MFP and P2_ALT. Refer to P2_ALT descriptions in detail.
        constexpr uint32_t P2_ALT0 = (1U << 8);  ///< P2.0 alternate function Selection The pin function of P2.0 is depend on P2_MFP[0] and P2_ALT[0]. P2_ALT[0]	P2_MFP[0]	P2.0function	 0	0	P2.0	 0	1	AD8(EBI)	 1	0	PWM0(PWM generator 0)	 1	1	Reserved
        constexpr uint32_t P2_ALT1 = (1U << 9);  ///< P2.1 alternate function Selection The pin function of P2.1 is depend on P2_MFP[1] and P2_ALT[1]. P2_ALT[1]	P2_MFP[1]	P2.1function	 0	0	P2.1	 0	1	AD9(EBI)	 1	0	PWM1(PWM generator 0)	 1	1	Reserved
        constexpr uint32_t P2_ALT2 = (1U << 10);  ///< P2.2 alternate function Selection The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2]. P2_ALT[2]	P2_MFP[2]	P2.2function	 0	0	P2.2	 0	1	AD10(EBI)	 1	0	PWM2(PWM generator 2)	 1	1	Reserved
        constexpr uint32_t P2_ALT3 = (1U << 11);  ///< P2.3 alternate function Selection The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3]. P2_ALT[3]	P2_MFP[3]	P2.3function	 0	0	P2.3	 0	1	AD11(EBI)	 1	0	PWM3(PWM generator 2)	 1	1	Reserved
        constexpr uint32_t P2_ALT4 = (1U << 12);  ///< P2.4 alternate function Selection The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4]. P2_ALT[4]	P2_MFP[4]	P0.4function	 0	0	P0.4	 0	1	AD12(EBI)	 1	0	PWM4(PWM generator 4)	 1	1	Reserved
        constexpr uint32_t P2_ALT5 = (1U << 13);  ///< P2.5 alternate function Selection The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5]. P2_ALT[5]	P2_MFP[5]	P2.5 function	 0	0	P2.5	 0	1	AD13(EBI)	 1	0	PWM5(PWM generator 4)	 1	1	Reserved
        constexpr uint32_t P2_ALT6 = (1U << 14);  ///< P2.6 alternate function Selection The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6]. P2_ALT[6]	P2_MFP[6]	P2.6 function	 0	0	P2.6	 0	1	AD14(EBI)	 1	0	PWM6(PWM generator 6)	 1	1	Reserved
        constexpr uint32_t P2_ALT7 = (1U << 15);  ///< P2.7 alternate function Selection The pin function of P2.7 is depend on P2_MFP[7] and P2_ALT[7]. P2_ALT[7]	P2_MFP[7]	P2.7 function	 0	0	P2.7	 0	1	AD15(EBI)	 1	0	PWM7(PWM generator 6)	 1	1	Reserved
        constexpr uint32_t P2_TYPEn = (8 << 16);  ///< P2[7:0] input Schmitt Trigger function Enable 1= P2[7:0] I/O input Schmitt Trigger function enable 0= P2[7:0] I/O input Schmitt Trigger function disable
    }

    /// P3_MFP Register bits
    namespace p3_mfp_bits {
        constexpr uint32_t P3_MFP = (8 << 0);  ///< P3 multiple function Selection The pin function of P3 is depending on P3_MFP and P3_ALT. Refer to P3_ALT descriptions in detail.
        constexpr uint32_t P3_ALT0 = (1U << 8);  ///< P3.0 alternate function Selection The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0]. P3_ALT[0]	P3_MFP[0]	P3.0function	 0	0	P3.0	 0	1	RXD(UART0)	 1	x	Reserved
        constexpr uint32_t P3_ALT1 = (1U << 9);  ///< P3.1 alternate function Selection The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1]. P3_ALT[1]	P3_MFP[1]	P3.1function	 0	0	P3.1	 0	1	TXD(UART0)	 1	x	Reserved
        constexpr uint32_t P3_ALT2 = (1U << 10);  ///< P3.2 alternate function Selection The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2]. P3_ALT[2]	P3_MFP[2]	P3.2function	 0	0	P3.2	 0	1	/INT0	 1	1	Reserved
        constexpr uint32_t P3_ALT3 = (1U << 11);  ///< P3.3 alternate function Selection The pin function of P3.3 is depend on P3_MFP[3] and P3_ALT[3]. P3_ALT[3]	P3_MFP[3]	P3.3function	 0	0	P3.3	 0	1	/INT1	 1	0	MCLK(EBI)	 1	x	Reserved
        constexpr uint32_t P3_ALT4 = (1U << 12);  ///< P3.4 alternate function Selection The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4]. P3_ALT[4]	P3_MFP[4]	P3.4function	 0	0	P3.4	 0	1	T0(Timer0)	 1	0	SDA(I2C)	 1	1	Reserved
        constexpr uint32_t P3_ALT5 = (1U << 13);  ///< P3.5 alternate function Selection The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5]. P3_ALT[5]	P3_MFP[5]	P3.5 function	 0	0	P3.5	 0	1	T1(Timer1)	 1	0	SCL(I2C)	 1	1	Reserved
        constexpr uint32_t P3_ALT6 = (1U << 14);  ///< P3.6 alternate function Selection The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6]. P3_ALT[6]	P3_MFP[6]	P3.6 function	 0	0	P3.6	 0	1	WR(EBI)	 1	0	CKO(Clock Driver output)	 1	1	Reserved
        constexpr uint32_t P3_ALT7 = (1U << 15);  ///< P3.7 alternate function Selection The pin function of P3.7 is depend on P3_MFP[7] and P3_ALT[7]. P3_ALT[7]	P3_MFP[7]	P3.7 function	 0	0	P3.7	 0	1	RD(EBI)	 1	x	Reserved
        constexpr uint32_t P3_TYPEn = (8 << 16);  ///< P3[7:0] input Schmitt Trigger function Enable 1= P3[7:0] I/O input Schmitt Trigger function enable 0= P3[7:0] I/O input Schmitt Trigger function disable
    }

    /// P4_MFP Register bits
    namespace p4_mfp_bits {
        constexpr uint32_t P4_MFP = (8 << 0);  ///< P4 multiple function Selection The pin function of P4 is depending on P4_MFP and P4_ALT. Refer to P4_ALT descriptions in detail.
        constexpr uint32_t P4_ALT0 = (1U << 8);  ///< P4.0 alternate function Selection The pin function of P4.0 is depend on P4_MFP[0] and P4_ALT[0]. P4_ALT[0]	P4_MFP[0]	P4.0function	 0	0	P4.0	 0	1	PWM0(PWM generator 0)	 1	x	Reserved
        constexpr uint32_t P4_ALT1 = (1U << 9);  ///< P4.1 alternate function Selection The pin function of P4.1 is depend on P4_MFP[1] and P4_ALT[1]. P4_ALT[1]	P4_MFP[1]	P4.1function	 0	0	P4.1	 0	1	PWM1(PWM generator 0)	 1	x	Reserved
        constexpr uint32_t P4_ALT2 = (1U << 10);  ///< P4.2 alternate function Selection The pin function of P4.2 is depend on P4_MFP[2] and P4_ALT[2]. P4_ALT[2]	P4_MFP[2]	P4.2function	 0	0	P4.2	 0	1	PWM2(PWM generator 2)	 1	x	Reserved
        constexpr uint32_t P4_ALT3 = (1U << 11);  ///< P4.3 alternate function Selection The pin function of P4.3 is depend on P4_MFP[3] and P4_ALT[3]. P4_ALT[3]	P4_MFP[3]	P4.3function	 0	0	P4.3	 0	1	PWM3(PWM generator 2)	 1	x	Reserved
        constexpr uint32_t P4_ALT4 = (1U << 12);  ///< P4.4 alternate function Selection The pin function of P4.4 is depend on P4_MFP[4] and P4_ALT[4]. P4_ALT[4]	P4_MFP[4]	P4.4function	 0	0	P4.4	 0	1	/CS(EBI)	 1	x	Reserved
        constexpr uint32_t P4_ALT5 = (1U << 13);  ///< P4.5 alternate function Selection The pin function of P4.5 is depend on P4_MFP[5] and P4_ALT[5]. P4_ALT[5]	P4_MFP[5]	P4.5 function	 0	0	P4.5	 0	1	ALE(EBI)	 1	x	Reserved
        constexpr uint32_t P4_ALT6 = (1U << 14);  ///< P4.6 alternate function Selection The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6]. P4_ALT[6]	P4_MFP[6]	P4.6 function	 0	0	P4.6	 0	1	ICE_CLK(ICE)	 1	x	Reserved
        constexpr uint32_t P4_ALT7 = (1U << 15);  ///< P4.7 alternate function Selection The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7]. P4_ALT[7]	P4_MFP[7]	P4.7 function	 0	0	P4.7	 0	1	ICE_DAT(ICE)	 1	x	Reserved
        constexpr uint32_t P4_TYPEn = (8 << 16);  ///< P4[7:0] input Schmitt Trigger function Enable 1= P4[7:0] I/O input Schmitt Trigger function enable 0= P4[7:0] I/O input Schmitt Trigger function disable
    }

    /// REGWRPROT Register bits
    namespace regwrprot_bits {
        constexpr uint32_t REGWRPROT = (8 << 0);  ///< Register Write-Protected Code (Write Only) Some write-protected registers have to be disabled the protected function by writing the sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.
        constexpr uint32_t REGPROTDIS = (1U << 0);  ///< Register Write-Protected Disable index (Read only) 1 = Protection is disabled for writing protected registers 0 = Protection is enabled for writing protected registers. Any write to the protected register is ignored. The Write-Protected registers list are below table: Registers	Address	Note	 IPRSTC1	0x5000_0008	None	 BODCR	0x5000_0018	None	 PORCR	0x5000_001C	None	 PWRCON	0x5000_0200	bit[6] is not protected for power wake-up interrupt clear	 APBCLK bit[0]	0x5000_0208	bit[0] is watch dog clock enable	 CLKSEL0	0x5000_0210	HCLK and CPU STCLK clock source select	 CLK_SEL1 bit[1:0]	0x5000_0214	Watch dog clock source select	 ISPCON	0x5000_C000	Flash ISP Control register	 WTCR	0x4000_4000	None	 FATCON	0x5000_C018	None
    }

}

// ============================================================================
// GP0 Peripheral
// ============================================================================

namespace gp0 {
    /// Base addresses
    constexpr uint32_t GP0_BASE = 0x50004000;
    constexpr uint32_t GP0_BITS_BASE = 0x50004200;

    /// GP0 Register structure
    struct Registers {
        volatile uint32_t PMD;  ///< Offset: 0x00 - Bit Mode Control
        volatile uint32_t OFFD;  ///< Offset: 0x04 - Bit OFF Digital Enable
        volatile uint32_t DOUT;  ///< Offset: 0x08 - Data Output Value
        volatile uint32_t DMASK;  ///< Offset: 0x0C - Data Output Write Mask
        volatile uint32_t PIN;  ///< Offset: 0x10 - Pin Value
        volatile uint32_t DBEN;  ///< Offset: 0x14 - De-bounce Enable
        volatile uint32_t IMD;  ///< Offset: 0x18 - Interrupt Mode Control
        volatile uint32_t IEN;  ///< Offset: 0x1C - Interrupt Enable
        volatile uint32_t ISRC;  ///< Offset: 0x20 - Interrupt Trigger Source
    };

    /// Peripheral instances
    inline Registers* GP0 = reinterpret_cast<Registers*>(GP0_BASE);
    inline Registers* GP0_BITS = reinterpret_cast<Registers*>(GP0_BITS_BASE);

    // Bit definitions
    /// PMD Register bits
    namespace pmd_bits {
        constexpr uint32_t PMD0 = (2 << 0);  ///< P0 I/O Pin[0] Mode Control Determine each I/O type of P0 pins 00 = P0[0] pin is in INPUT mode. 01 = P0[0] pin is in OUTPUT mode. 10 = P0[0] pin is in Open-Drain mode. 11 = P0[0] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD1 = (2 << 2);  ///< P0 I/O Pin[1] Mode Control Determine each I/O type of P0 pins 00 = P0[1] pin is in INPUT mode. 01 = P0[1] pin is in OUTPUT mode. 10 = P0[1] pin is in Open-Drain mode. 11 = P0[1] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD2 = (2 << 4);  ///< P0 I/O Pin[2] Mode Control Determine each I/O type of P0 pins 00 = P0[2] pin is in INPUT mode. 01 = P0[2] pin is in OUTPUT mode. 10 = P0[2] pin is in Open-Drain mode. 11 = P0[2] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD3 = (2 << 6);  ///< P0 I/O Pin[3] Mode Control Determine each I/O type of P0 pins 00 = P0[3] pin is in INPUT mode. 01 = P0[3] pin is in OUTPUT mode. 10 = P0[3] pin is in Open-Drain mode. 11 = P0[3] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD4 = (2 << 8);  ///< P0 I/O Pin[4] Mode Control Determine each I/O type of P0 pins 00 = P0[4] pin is in INPUT mode. 01 = P0[4] pin is in OUTPUT mode. 10 = P0[4] pin is in Open-Drain mode. 11 = P0[4] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD5 = (2 << 10);  ///< P0 I/O Pin[5] Mode Control Determine each I/O type of P0 pins 00 = P0[5] pin is in INPUT mode. 01 = P0[5] pin is in OUTPUT mode. 10 = P0[5] pin is in Open-Drain mode. 11 = P0[5] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD6 = (2 << 12);  ///< P0 I/O Pin[6] Mode Control Determine each I/O type of P0 pins 00 = P0[6] pin is in INPUT mode. 01 = P0[6] pin is in OUTPUT mode. 10 = P0[6] pin is in Open-Drain mode. 11 = P0[6] pin is in Quasi-bidirectional mode.
        constexpr uint32_t PMD7 = (2 << 14);  ///< P0 I/O Pin[7] Mode Control Determine each I/O type of P0 pins 00 = P0[7] pin is in INPUT mode. 01 = P0[7] pin is in OUTPUT mode. 10 = P0[7] pin is in Open-Drain mode. 11 = P0[7] pin is in Quasi-bidirectional mode.
    }

    /// OFFD Register bits
    namespace offd_bits {
        constexpr uint32_t OFFD = (8 << 16);  ///< OFFD: P0 Pin OFF digital input path Enable 1 = Disable IO digital input path (digital input tied to low) 0 = Enable IO digital input path
    }

    /// DOUT Register bits
    namespace dout_bits {
        constexpr uint32_t DOUT0 = (1U << 0);  ///< P0 Pin[0] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT1 = (1U << 1);  ///< P0 Pin[1] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT2 = (1U << 2);  ///< P0 Pin[2] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT3 = (1U << 3);  ///< P0 Pin[3] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT4 = (1U << 4);  ///< P0 Pin[4] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT5 = (1U << 5);  ///< P0 Pin[5] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT6 = (1U << 6);  ///< P0 Pin[6] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.
        constexpr uint32_t DOUT7 = (1U << 7);  ///< P0 Pin[7] Output Value Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode. 1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set. 0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.
    }

    /// DMASK Register bits
    namespace dmask_bits {
        constexpr uint32_t DMASK0 = (1U << 0);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[0] bit can be updated 1 = The corresponding P0_DOUT[0] bit is protected
        constexpr uint32_t DMASK1 = (1U << 1);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[1] bit can be updated 1 = The corresponding P0_DOUT[1] bit is protected
        constexpr uint32_t DMASK2 = (1U << 2);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[2] bit can be updated 1 = The corresponding P0_DOUT[2] bit is protected
        constexpr uint32_t DMASK3 = (1U << 3);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[3] bit can be updated 1 = The corresponding P0_DOUT[3] bit is protected
        constexpr uint32_t DMASK4 = (1U << 4);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[4] bit can be updated 1 = The corresponding P0_DOUT[4] bit is protected
        constexpr uint32_t DMASK5 = (1U << 5);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[6] bit can be updated 1 = The corresponding P0_DOUT[6] bit is protected
        constexpr uint32_t DMASK6 = (1U << 6);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[6] bit can be updated 1 = The corresponding P0_DOUT[6] bit is protected
        constexpr uint32_t DMASK7 = (1U << 7);  ///< P0 Data Output Write Mask These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write data to the protect bit is ignored 0 = The corresponding P0_DOUT[7] bit can be updated 1 = The corresponding P0_DOUT[7] bit is protected
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PIN0 = (1U << 0);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[0].
        constexpr uint32_t PIN1 = (1U << 1);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[1].
        constexpr uint32_t PIN2 = (1U << 2);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[2].
        constexpr uint32_t PIN3 = (1U << 3);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[3].
        constexpr uint32_t PIN4 = (1U << 4);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[4].
        constexpr uint32_t PIN5 = (1U << 5);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[5].
        constexpr uint32_t PIN6 = (1U << 6);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[6].
        constexpr uint32_t PIN7 = (1U << 7);  ///< P0 Pin Values The value read from each of these bit reflects the actual status of the respective P0 Pin[7].
    }

    /// DBEN Register bits
    namespace dben_bits {
        constexpr uint32_t DBEN0 = (1U << 0);  ///< P0 Input Signal De-bounce Enable DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[0] de-bounce function is disabled 1 = The bit[0] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN1 = (1U << 1);  ///< P0 Input Signal De-bounce Enable DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[1] de-bounce function is disabled 1 = The bit[1] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN2 = (1U << 2);  ///< P0 Input Signal De-bounce Enable DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[2] de-bounce function is disabled 1 = The bit[2] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN3 = (1U << 3);  ///< P0 Input Signal De-bounce Enable DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[3] de-bounce function is disabled 1 = The bit[3] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN4 = (1U << 4);  ///< P0 Input Signal De-bounce Enable DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[4] de-bounce function is disabled 1 = The bit[4] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN5 = (1U << 5);  ///< P0 Input Signal De-bounce Enable DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[5] de-bounce function is disabled 1 = The bit[5] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN6 = (1U << 6);  ///< P0 Input Signal De-bounce Enable DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[6] de-bounce function is disabled 1 = The bit[6] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t DBEN7 = (1U << 7);  ///< P0 Input Signal De-bounce Enable DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt. The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 0 = The bit[7] de-bounce function is disabled 1 = The bit[7] de-bounce function is enabled The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
    }

    /// IMD Register bits
    namespace imd_bits {
        constexpr uint32_t IMD0 = (1U << 0);  ///< Port 0 Interrupt Mode Control IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD1 = (1U << 1);  ///< Port 0 Interrupt Mode Control IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD2 = (1U << 2);  ///< Port 0 Interrupt Mode Control IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD3 = (1U << 3);  ///< Port 0 Interrupt Mode Control IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD4 = (1U << 4);  ///< Port 0 Interrupt Mode Control IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD5 = (1U << 5);  ///< Port 0 Interrupt Mode Control IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD6 = (1U << 6);  ///< Port 0 Interrupt Mode Control IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
        constexpr uint32_t IMD7 = (1U << 7);  ///< Port 0 Interrupt Mode Control IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt 0 = Edge trigger interrupt 1 = Level trigger interrupt if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.
    }

    /// IEN Register bits
    namespace ien_bits {
        constexpr uint32_t IF_EN0 = (1U << 0);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[0] bit "1": If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[0] state low-level or high-to-low change interrupt 0 = Disable the P0[0] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN1 = (1U << 1);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[1] bit "1": If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[1] state low-level or high-to-low change interrupt 0 = Disable the P0[1] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN2 = (1U << 2);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[2] bit "1": If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[2] state low-level or high-to-low change interrupt 0 = Disable the P0[2] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN3 = (1U << 3);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[3] bit "1": If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[3] state low-level or high-to-low change interrupt 0 = Disable the P0[3] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN4 = (1U << 4);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[4] bit "1": If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[4] state low-level or high-to-low change interrupt 0 = Disable the P0[4] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN5 = (1U << 5);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[5] bit "1": If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[5] state low-level or high-to-low change interrupt 0 = Disable the P0[5] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN6 = (1U << 6);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[6] bit "1": If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[6] state low-level or high-to-low change interrupt 0 = Disable the P0[6] state low-level or high-to-low change interrupt
        constexpr uint32_t IF_EN7 = (1U << 7);  ///< Port0 Interrupt Enable by Input Falling Edge or Input Level Low IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function. When set the IF_EN[7] bit "1": If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate the interrupt. 1 = Enable the P0[7] state low-level or high-to-low change interrupt 0 = Disable the P0[7] state low-level or high-to-low change interrupt
        constexpr uint32_t IR_EN0 = (1U << 16);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[0] bit "1": If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[0] level-high or low-to-high interrupt 0 = Disable the P0[0] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN1 = (1U << 17);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[1] bit "1": If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[1] level-high or low-to-high interrupt 0 = Disable the P0[1] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN2 = (1U << 18);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[2] bit "1": If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[2] level-high or low-to-high interrupt 0 = Disable the P0[2] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN3 = (1U << 19);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[3] bit "1": If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[3] level-high or low-to-high interrupt 0 = Disable the P0[3] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN4 = (1U << 20);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[4] bit "1": If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[4] level-high or low-to-high interrupt 0 = Disable the P0[4] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN5 = (1U << 21);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[5] bit "1": If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[5] level-high or low-to-high interrupt 0 = Disable the P0[5] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN6 = (1U << 22);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[6] bit "1": If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[6] level-high or low-to-high interrupt 0 = Disable the P0[6] level-high or low-to-high interrupt
        constexpr uint32_t IR_EN7 = (1U << 23);  ///< Port 0 Interrupt Enable by Input Rising Edge or Input Level High IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function. When set the IR_EN[7] bit "1": If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt. If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate the interrupt. 1 = Enable the P0[7] level-high or low-to-high interrupt 0 = Disable the P0[7] level-high or low-to-high interrupt
    }

    /// ISRC Register bits
    namespace isrc_bits {
        constexpr uint32_t ISRC0 = (1U << 0);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[0] generate an interrupt 0 = No interrupt at P0[0] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC1 = (1U << 1);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[1] generate an interrupt 0 = No interrupt at P0[1] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC2 = (1U << 2);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[2] generate an interrupt 0 = No interrupt at P0[2] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC3 = (1U << 3);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[3] generate an interrupt 0 = No interrupt at P0[3] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC4 = (1U << 4);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[4] generate an interrupt 0 = No interrupt at P0[4] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC5 = (1U << 5);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[5] generate an interrupt 0 = No interrupt at P0[5] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC6 = (1U << 6);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[6] generate an interrupt 0 = No interrupt at P0[6] Write: 1 = Clear the correspond pending interrupt 0 = No action
        constexpr uint32_t ISRC7 = (1U << 7);  ///< Port 0 Interrupt Trigger Source Indicator Read: 1 = Indicates P0[7] generate an interrupt 0 = No interrupt at P0[7] Write: 1 = Clear the correspond pending interrupt 0 = No action
    }

}

// ============================================================================
// GP1 Peripheral
// ============================================================================

namespace gp1 {
    /// Base addresses
    constexpr uint32_t GP1_BASE = 0x50004040;
    constexpr uint32_t GP1_BITS_BASE = 0x50004220;

    /// GP1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GP1 = reinterpret_cast<Registers*>(GP1_BASE);
    inline Registers* GP1_BITS = reinterpret_cast<Registers*>(GP1_BITS_BASE);

}

// ============================================================================
// GP2 Peripheral
// ============================================================================

namespace gp2 {
    /// Base addresses
    constexpr uint32_t GP2_BASE = 0x50004080;
    constexpr uint32_t GP2_BITS_BASE = 0x50004240;

    /// GP2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GP2 = reinterpret_cast<Registers*>(GP2_BASE);
    inline Registers* GP2_BITS = reinterpret_cast<Registers*>(GP2_BITS_BASE);

}

// ============================================================================
// GP3 Peripheral
// ============================================================================

namespace gp3 {
    /// Base addresses
    constexpr uint32_t GP3_BASE = 0x500040C0;
    constexpr uint32_t GP3_BITS_BASE = 0x50004260;

    /// GP3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GP3 = reinterpret_cast<Registers*>(GP3_BASE);
    inline Registers* GP3_BITS = reinterpret_cast<Registers*>(GP3_BITS_BASE);

}

// ============================================================================
// GP4 Peripheral
// ============================================================================

namespace gp4 {
    /// Base addresses
    constexpr uint32_t GP4_BASE = 0x50004100;
    constexpr uint32_t GP4_BITS_BASE = 0x50004280;

    /// GP4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* GP4 = reinterpret_cast<Registers*>(GP4_BASE);
    inline Registers* GP4_BITS = reinterpret_cast<Registers*>(GP4_BITS_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x50004180;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DBNCECON;  ///< Offset: 0x00 - Interrupt De-bounce Cycle Control
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// DBNCECON Register bits
    namespace dbncecon_bits {
        constexpr uint32_t DBCLKSEL = (4 << 0);  ///< De-bounce sampling cycle selection DBCLKSEL	Description	 0	Sample interrupt input once per 1 clocks	 1	Sample interrupt input once per 2 clocks	 2	Sample interrupt input once per 4 clocks	 3	Sample interrupt input once per 8 clocks	 4	Sample interrupt input once per 16 clocks	 5	Sample interrupt input once per 32 clocks	 6	Sample interrupt input once per 64 clocks	 7	Sample interrupt input once per 128 clocks	 8	Sample interrupt input once per 256 clocks	 9	Sample interrupt input once per 2*256 clocks	 10	Sample interrupt input once per 4*256clocks	 11	Sample interrupt input once per 8*256 clocks	 12	Sample interrupt input once per 16*256 clocks	 13	Sample interrupt input once per 32*256 clocks	 14	Sample interrupt input once per 64*256 clocks	 15	Sample interrupt input once per 128*256 clocks
        constexpr uint32_t DBCLKSRC = (1U << 4);  ///< De-bounce counter clock source select 1 = De-bounce counter clock source is the internal 10KHz clock 0 = De-bounce counter clock source is the HCLK
        constexpr uint32_t ICLK_ON = (1U << 5);  ///< Interrupt clock On mode Set this bit "0" will disable the interrupt generate circuit clock, if the pin[n] interrupt is disabled 0 = disable the clock if the P0/1/2/3/4[n] interrupt is disabled 1 = interrupt generated circuit clock always enable n=0~7
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C_BASE = 0x40020000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2CON;  ///< Offset: 0x00 - I2C Control Register
        volatile uint32_t I2CADDR0;  ///< Offset: 0x04 - I2C slave Address Register0
        volatile uint32_t I2CDAT;  ///< Offset: 0x08 - I2C DATA Register
        volatile uint32_t I2CSTATUS;  ///< Offset: 0x0C - I2C Status Register
        volatile uint32_t I2CLK;  ///< Offset: 0x10 - I2C clock divided Register
        volatile uint32_t I2CTOC;  ///< Offset: 0x14 - I2C Time out control Register
        volatile uint32_t I2CADDR1;  ///< Offset: 0x18 - I2C slave Address Register1
        volatile uint32_t I2CADDR2;  ///< Offset: 0x1C - I2C slave Address Register2
        volatile uint32_t I2CADDR3;  ///< Offset: 0x20 - I2C slave Address Register3
        volatile uint32_t I2CADM0;  ///< Offset: 0x24 - I2C Slave address Mask Register0
        volatile uint32_t I2CADM1;  ///< Offset: 0x28 - I2C Slave address Mask Register1
        volatile uint32_t I2CADM2;  ///< Offset: 0x2C - I2C Slave address Mask Register2
        volatile uint32_t I2CADM3;  ///< Offset: 0x30 - I2C Slave address Mask Register3
    };

    /// Peripheral instances
    inline Registers* I2C = reinterpret_cast<Registers*>(I2C_BASE);

    // Bit definitions
    /// I2CON Register bits
    namespace i2con_bits {
        constexpr uint32_t AA = (1U << 2);  ///< Assert Acknowledge control bit. When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
        constexpr uint32_t SI = (1U << 3);  ///< I2C Interrupt Flag. When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one to this bit.
        constexpr uint32_t STO = (1U << 4);  ///< I2C STOP Flag. In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this flag will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
        constexpr uint32_t STA = (1U << 5);  ///< I2C START Flag. Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
        constexpr uint32_t ENSI = (1U << 6);  ///< I2C controller is enabled/disable 1 = Enable 0 = Disable Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function pin function of SDA and SCL must set to I2C function first.
        constexpr uint32_t EI = (1U << 7);  ///< Enable interrupt. 1 = Enable I2C interrupt. 0 = Disable I2C interrupt.
    }

    /// I2CADDR0 Register bits
    namespace i2caddr0_bits {
        constexpr uint32_t GC = (1U << 0);  ///< General Call Function 0 = Disable General Call Function. 1 = Enable General Call Function.
        constexpr uint32_t I2CADDR = (7 << 1);  ///< I2C Address Register The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.
    }

    /// I2CDAT Register bits
    namespace i2cdat_bits {
        constexpr uint32_t I2CDAT = (8 << 0);  ///< I2C Data Register Bit[7:0] is located with the 8-bit transferred data of I2C serial port.
    }

    /// I2CSTATUS Register bits
    namespace i2cstatus_bits {
        constexpr uint32_t I2CSTATUS = (8 << 0);  ///< I2C Status Register The status register of I2C: The three least significant bits are always 0. The five most significant bits contain the status code. There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is requested. All other I2STATUS values correspond to defined I2C states. When each of these states is entered, a status interrupt is requested (SI = 1). A valid status code is present in I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
    }

    /// I2CLK Register bits
    namespace i2clk_bits {
        constexpr uint32_t I2CLK = (8 << 0);  ///< I2C clock divided Register The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
    }

    /// I2CTOC Register bits
    namespace i2ctoc_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time-Out flag. 1 = Time-Out falg is set by H/W. It can interrupt CPU. 0 = S/W can clear the flag.
        constexpr uint32_t DIV4 = (1U << 1);  ///< Time-Out counter input clock is divider by 4 1 = Enable 0 = Disable When Enable, The time-Out period is prolong 4 times.
        constexpr uint32_t ENTI = (1U << 2);  ///< Time-out counter is enabled/disable 1 = Enable 0 = Disable When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
    }

    /// I2CADDR1 Register bits
    namespace i2caddr1_bits {
        constexpr uint32_t GC = (1U << 0);  ///< General Call Function 0 = Disable General Call Function. 1 = Enable General Call Function.
        constexpr uint32_t I2CADDR = (7 << 1);  ///< I2C Address Register The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.
    }

    /// I2CADDR2 Register bits
    namespace i2caddr2_bits {
        constexpr uint32_t GC = (1U << 0);  ///< General Call Function 0 = Disable General Call Function. 1 = Enable General Call Function.
        constexpr uint32_t I2CADDR = (7 << 1);  ///< I2C Address Register The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.
    }

    /// I2CADDR3 Register bits
    namespace i2caddr3_bits {
        constexpr uint32_t GC = (1U << 0);  ///< General Call Function 0 = Disable General Call Function. 1 = Enable General Call Function.
        constexpr uint32_t I2CADDR = (7 << 1);  ///< I2C Address Register The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.
    }

    /// I2CADM0 Register bits
    namespace i2cadm0_bits {
        constexpr uint32_t I2ADMx = (7 << 1);  ///< I2C Address Mask register 1 = Mask enable (the received corresponding address bit is don't care.) 0 = Mask disable (the received corresponding register bit should be exact the same as address register.) I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    }

    /// I2CADM1 Register bits
    namespace i2cadm1_bits {
        constexpr uint32_t I2ADMx = (7 << 1);  ///< I2C Address Mask register 1 = Mask enable (the received corresponding address bit is don't care.) 0 = Mask disable (the received corresponding register bit should be exact the same as address register.) I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    }

    /// I2CADM2 Register bits
    namespace i2cadm2_bits {
        constexpr uint32_t I2ADMx = (7 << 1);  ///< I2C Address Mask register 1 = Mask enable (the received corresponding address bit is don't care.) 0 = Mask disable (the received corresponding register bit should be exact the same as address register.) I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    }

    /// I2CADM3 Register bits
    namespace i2cadm3_bits {
        constexpr uint32_t I2ADMx = (7 << 1);  ///< I2C Address Mask register 1 = Mask enable (the received corresponding address bit is don't care.) 0 = Mask disable (the received corresponding register bit should be exact the same as address register.) I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    }

}

// ============================================================================
// INT Peripheral
// ============================================================================

namespace int {
    /// Base addresses
    constexpr uint32_t INT_BASE = 0x50000300;

    /// INT Register structure
    struct Registers {
        volatile uint32_t IRQ0_SRC;  ///< Offset: 0x00 - MCU IRQ0 (BOD) interrupt source identify
        volatile uint32_t IRQ1_SRC;  ///< Offset: 0x04 - MCU IRQ1 (WDT) interrupt source identify
        volatile uint32_t IRQ2_SRC;  ///< Offset: 0x08 - MCU IRQ2 ((EINT0) interrupt source identify
        volatile uint32_t IRQ3_SRC;  ///< Offset: 0x0C - MCU IRQ3 (EINT1) interrupt source identify
        volatile uint32_t IRQ4_SRC;  ///< Offset: 0x10 - MCU IRQ4 (P0/1) interrupt source identify
        volatile uint32_t IRQ5_SRC;  ///< Offset: 0x14 - MCU IRQ5 (P2/3/4) interrupt source identify
        volatile uint32_t IRQ6_SRC;  ///< Offset: 0x18 - MCU IRQ6 (PWMA) interrupt source identify
        volatile uint32_t IRQ7_SRC;  ///< Offset: 0x1C - MCU IRQ7 (PWMB) interrupt source identify
        volatile uint32_t IRQ8_SRC;  ///< Offset: 0x20 - MCU IRQ8 (TMR0) interrupt source identify
        volatile uint32_t IRQ9_SRC;  ///< Offset: 0x24 - MCU IRQ9 (TMR1) interrupt source identify
        volatile uint32_t IRQ10_SRC;  ///< Offset: 0x28 - MCU IRQ10 (TMR2) interrupt source identify
        volatile uint32_t IRQ11_SRC;  ///< Offset: 0x2C - MCU IRQ11 (TMR3) interrupt source identify
        volatile uint32_t IRQ12_SRC;  ///< Offset: 0x30 - MCU IRQ12 (URT0) interrupt source identify
        volatile uint32_t IRQ13_SRC;  ///< Offset: 0x34 - MCU IRQ13 (URT1) interrupt source identify
        volatile uint32_t IRQ14_SRC;  ///< Offset: 0x38 - MCU IRQ14 (SPI0) interrupt source identify
        volatile uint32_t IRQ15_SRC;  ///< Offset: 0x3C - MCU IRQ15 (SPI1) interrupt source identify
        volatile uint32_t IRQ18_SRC;  ///< Offset: 0x48 - MCU IRQ18 (I2C) interrupt source identify
        volatile uint32_t IRQ21_SRC;  ///< Offset: 0x54 - MCU IRQ21 (Reserved) interrupt source identify
        volatile uint32_t IRQ22_SRC;  ///< Offset: 0x58 - MCU IRQ22 (Reserved) interrupt source identify
        volatile uint32_t IRQ28_SRC;  ///< Offset: 0x70 - MCU IRQ28 (PWRWU) interrupt source identify
        volatile uint32_t IRQ29_SRC;  ///< Offset: 0x74 - MCU IRQ29 (ADC) interrupt source identify
        volatile uint32_t IRQ30_SRC;  ///< Offset: 0x78 - MCU IRQ30 (Reserved) interrupt source identify
        volatile uint32_t NMI_SEL;  ///< Offset: 0x80 - NMI source interrupt select control register
        volatile uint32_t MCU_IRQ;  ///< Offset: 0x84 - MCU IRQ Number identify register
    };

    /// Peripheral instances
    inline Registers* INT = reinterpret_cast<Registers*>(INT_BASE);

    // Bit definitions
    /// IRQ0_SRC Register bits
    namespace irq0_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: BOD_INT
    }

    /// IRQ1_SRC Register bits
    namespace irq1_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: WDT_INT
    }

    /// IRQ2_SRC Register bits
    namespace irq2_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: EINT0 - external interrupt 0 from P3.2
    }

    /// IRQ3_SRC Register bits
    namespace irq3_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: EINT1 - external interrupt 1 from P3.3
    }

    /// IRQ4_SRC Register bits
    namespace irq4_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1: P1_INT Bit0: P0_INT
    }

    /// IRQ5_SRC Register bits
    namespace irq5_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2: P4_INT Bit1: P3_INT Bit0: P2_INT
    }

    /// IRQ6_SRC Register bits
    namespace irq6_src_bits {
        constexpr uint32_t INT_SRC = (4 << 0);  ///< Bit3: PWM3_INT Bit2: PWM2_INT Bit1: PWM1_INT Bit0: PWM0_INT
    }

    /// IRQ7_SRC Register bits
    namespace irq7_src_bits {
        constexpr uint32_t INT_SRC = (4 << 0);  ///< Bit3: PWM7_INT Bit2: PWM6_INT Bit1: PWM5_INT Bit0: PWM4_INT
    }

    /// IRQ8_SRC Register bits
    namespace irq8_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: TMR0_INT
    }

    /// IRQ9_SRC Register bits
    namespace irq9_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: TMR1_INT
    }

    /// IRQ10_SRC Register bits
    namespace irq10_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: TMR2_INT
    }

    /// IRQ11_SRC Register bits
    namespace irq11_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: TMR3_INT
    }

    /// IRQ12_SRC Register bits
    namespace irq12_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: URT0_INT
    }

    /// IRQ13_SRC Register bits
    namespace irq13_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: URT1_INT
    }

    /// IRQ14_SRC Register bits
    namespace irq14_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: SPI0_INT
    }

    /// IRQ15_SRC Register bits
    namespace irq15_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: SPI1_INT
    }

    /// IRQ18_SRC Register bits
    namespace irq18_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: I2C_INT
    }

    /// IRQ21_SRC Register bits
    namespace irq21_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Reserved
    }

    /// IRQ22_SRC Register bits
    namespace irq22_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Reserved
    }

    /// IRQ28_SRC Register bits
    namespace irq28_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: PWRWU_INT
    }

    /// IRQ29_SRC Register bits
    namespace irq29_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Bit2 = 0 Bit1 = 0 Bit0: ADC_INT
    }

    /// IRQ30_SRC Register bits
    namespace irq30_src_bits {
        constexpr uint32_t INT_SRC = (3 << 0);  ///< Reserved
    }

    /// NMI_SEL Register bits
    namespace nmi_sel_bits {
        constexpr uint32_t NMI_SEL = (5 << 0);  ///< The NMI interrupt to Cortex-M0 can be selected from one of the interrupt[31:0] The NMI_SEL bit[4:0] used to select the NMI interrupt source
    }

    /// MCU_IRQ Register bits
    namespace mcu_irq_bits {
        constexpr uint32_t MCU_IRQ = (32 << 0);  ///< MCU IRQ Source Register The MCU_IRQ collect all the interrupts from the peripherals and generate the synchronous interrupt to MCU Cortex-M0. There are two modes to generate interrupt to MCU Cortex-M0, the normal mode and test mode. The MCU_IRQ collects all interrupts from each peripheral and synchronizes them then interrupts the Cortex-M0. When the MCU_IRQ[n] is "0": Set MCU_IRQ[n] "1" will generate an interrupt to Cortex_M0 NVIC[n]. When the MCU_IRQ[n] is "1"(mean an interrupt is assert) set 1 the MCU_bit[n] will clear the interrupt Set MCU_IRQ[n] "0": no any effect
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWMA_BASE = 0x40040000;
    constexpr uint32_t PWMB_BASE = 0x40140000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t PPR;  ///< Offset: 0x00 - PWM Pre-scalar Register
        volatile uint32_t CSR;  ///< Offset: 0x04 - PWM Clock Select Register
        volatile uint32_t PCR;  ///< Offset: 0x08 - PWM Control Register
        volatile uint32_t CNR0;  ///< Offset: 0x0C - PWM Counter Register 0
        volatile uint32_t CMR0;  ///< Offset: 0x10 - PWM Comparator Register 0
        volatile uint32_t PDR0;  ///< Offset: 0x14 - PWM Data Register 0
        volatile uint32_t CNR1;  ///< Offset: 0x18 - PWM Counter Register 1
        volatile uint32_t CMR1;  ///< Offset: 0x1C - PWM Comparator Register 1
        volatile uint32_t PDR1;  ///< Offset: 0x20 - PWM Data Register 1
        volatile uint32_t CNR2;  ///< Offset: 0x24 - PWM Counter Register 2
        volatile uint32_t CMR2;  ///< Offset: 0x28 - PWM Comparator Register 2
        volatile uint32_t PDR2;  ///< Offset: 0x2C - PWM Data Register 2
        volatile uint32_t CNR3;  ///< Offset: 0x30 - PWM Counter Register 3
        volatile uint32_t CMR3;  ///< Offset: 0x34 - PWM Comparator Register 3
        volatile uint32_t PDR3;  ///< Offset: 0x38 - PWM Data Register 3
        volatile uint32_t PIER;  ///< Offset: 0x40 - PWM Interrupt Enable Register
        volatile uint32_t PIIR;  ///< Offset: 0x44 - PWM Interrupt Indication Register
        volatile uint32_t CCR0;  ///< Offset: 0x50 - Capture Control Register
        volatile uint32_t CCR2;  ///< Offset: 0x54 - Capture Control Register
        volatile uint32_t CRLR0;  ///< Offset: 0x58 - Capture Rising Latch Register (Channel 0)
        volatile uint32_t CFLR0;  ///< Offset: 0x5C - Capture Falling Latch Register (Channel 0)
        volatile uint32_t CRLR1;  ///< Offset: 0x60 - Capture Rising Latch Register (Channel 1)
        volatile uint32_t CFLR1;  ///< Offset: 0x64 - Capture Falling Latch Register (Channel 1)
        volatile uint32_t CRLR2;  ///< Offset: 0x68 - Capture Rising Latch Register (channel 2)
        volatile uint32_t CFLR2;  ///< Offset: 0x6C - Capture Falling Latch Register (channel 2)
        volatile uint32_t CRLR3;  ///< Offset: 0x70 - Capture Rising Latch Register (channel 3)
        volatile uint32_t CFLR3;  ///< Offset: 0x74 - Capture Falling Latch Register (channel 3)
        volatile uint32_t CAPENR;  ///< Offset: 0x78 - Capture Input Enable Register
        volatile uint32_t POE;  ///< Offset: 0x7C - PWM Output Enable
    };

    /// Peripheral instances
    inline Registers* PWMA = reinterpret_cast<Registers*>(PWMA_BASE);
    inline Registers* PWMB = reinterpret_cast<Registers*>(PWMB_BASE);

    // Bit definitions
    /// PPR Register bits
    namespace ppr_bits {
        constexpr uint32_t CP01 = (8 << 0);  ///< Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B) Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM counter will be stopped also.
        constexpr uint32_t CP23 = (8 << 8);  ///< Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B) Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM counter will be stopped also.
        constexpr uint32_t DZI01 = (8 << 16);  ///< Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B) These 8 bits determine dead zone length. The unit time of dead zone length is received from corresponding CSR bits.
        constexpr uint32_t DZI23 = (8 << 24);  ///< Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B) These 8 bits determine dead zone length. The unit time of dead zone length is received from corresponding CSR bits.
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t CSR0 = (3 << 0);  ///< Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B) Select clock input for timer. (Table is the same as CSR3)
        constexpr uint32_t CSR1 = (3 << 4);  ///< Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B) Select clock input for timer. (Table is the same as CSR3)
        constexpr uint32_t CSR2 = (3 << 8);  ///< Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B) Select clock input for timer. (Table is the same as CSR3)
        constexpr uint32_t CSR3 = (3 << 12);  ///< Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B) Select clock input for timer. CSR3 [14:12]	Input clock divided by	 100	1	 011	16	 010	8	 001	4	 000	2
    }

    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t CH0EN = (1U << 0);  ///< PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for group B) 1 = Enable corresponding PWM-Timer Start Run 0 = Stop corresponding PWM-Timer Running
        constexpr uint32_t CH0INV = (1U << 2);  ///< PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for group B) 1 = Inverter ON 0 = Inverter OFF
        constexpr uint32_t CH0MOD = (1U << 3);  ///< PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 for group B) 1 = Auto-reload Mode 0 = One-Shot Mode Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
        constexpr uint32_t DZEN01 = (1U << 4);  ///< Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B) 1 = Enable 0 = Disable Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.
        constexpr uint32_t DZEN23 = (1U << 5);  ///< Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B) 1 = Enable 0 = Disable Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.
        constexpr uint32_t CH1EN = (1U << 8);  ///< PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for group B) 1 = Enable corresponding PWM-Timer Start Run 0 = Stop corresponding PWM-Timer Running
        constexpr uint32_t CH1INV = (1U << 10);  ///< PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for group B) 1 = Inverter ON 0 = Inverter OFF
        constexpr uint32_t CH1MOD = (1U << 11);  ///< PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 for group B) 1 = Auto-reload Mode 0 = One-Shot Mode Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
        constexpr uint32_t CH2EN = (1U << 16);  ///< PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for group B) 1 = Enable corresponding PWM-Timer Start Run 0 = Stop corresponding PWM-Timer Running
        constexpr uint32_t CH2INV = (1U << 18);  ///< PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for group B) 1 = Inverter ON 0 = Inverter OFF
        constexpr uint32_t CH2MOD = (1U << 19);  ///< PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 for group B) 1 = Auto-reload Mode 0 = One-Shot Mode Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
        constexpr uint32_t CH3EN = (1U << 24);  ///< PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for group B) 1 = Enable corresponding PWM-Timer Start Run 0 = Stop corresponding PWM-Timer Running
        constexpr uint32_t CH3INV = (1U << 26);  ///< PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for group B) 1 = Inverter ON 0 = Inverter OFF
        constexpr uint32_t CH3MOD = (1U << 27);  ///< PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 for group B) 1 = Auto-reload Mode 0 = One-Shot Mode Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
    }

    /// CNR0 Register bits
    namespace cnr0_bits {
        constexpr uint32_t CNR = (16 << 0);  ///< PWM Counter/Timer Loaded Value CNR determines the PWM period. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// CMR0 Register bits
    namespace cmr0_bits {
        constexpr uint32_t CMR = (16 << 0);  ///< PWM Comparator Register CNR determines the PWM duty. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// PDR0 Register bits
    namespace pdr0_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< PWM Data Register User can monitor PDR to know the current value in 16-bit down counter.
    }

    /// CNR1 Register bits
    namespace cnr1_bits {
        constexpr uint32_t CNR = (16 << 0);  ///< PWM Counter/Timer Loaded Value CNR determines the PWM period. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// CMR1 Register bits
    namespace cmr1_bits {
        constexpr uint32_t CMR = (16 << 0);  ///< PWM Comparator Register CNR determines the PWM duty. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// PDR1 Register bits
    namespace pdr1_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< PWM Data Register User can monitor PDR to know the current value in 16-bit down counter.
    }

    /// CNR2 Register bits
    namespace cnr2_bits {
        constexpr uint32_t CNR = (16 << 0);  ///< PWM Counter/Timer Loaded Value CNR determines the PWM period. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// CMR2 Register bits
    namespace cmr2_bits {
        constexpr uint32_t CMR = (16 << 0);  ///< PWM Comparator Register CNR determines the PWM duty. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// PDR2 Register bits
    namespace pdr2_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< PWM Data Register User can monitor PDR to know the current value in 16-bit down counter.
    }

    /// CNR3 Register bits
    namespace cnr3_bits {
        constexpr uint32_t CNR = (16 << 0);  ///< PWM Counter/Timer Loaded Value CNR determines the PWM period. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// CMR3 Register bits
    namespace cmr3_bits {
        constexpr uint32_t CMR = (16 << 0);  ///< PWM Comparator Register CNR determines the PWM duty. PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel. Duty ratio = (CMR+1)/(CNR+1). CMR >= CNR: PWM output is always high. CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit (Unit = one PWM clock cycle) Note: Any write to CNR will take effect in next PWM cycle.
    }

    /// PDR3 Register bits
    namespace pdr3_bits {
        constexpr uint32_t PDR = (16 << 0);  ///< PWM Data Register User can monitor PDR to know the current value in 16-bit down counter.
    }

    /// PIER Register bits
    namespace pier_bits {
        constexpr uint32_t PWMIE0 = (1U << 0);  ///< PWM channel 0 Interrupt Enable 1 = Enable 0 = Disable
        constexpr uint32_t PWMIE1 = (1U << 1);  ///< PWM channel 1 Interrupt Enable 1 = Enable 0 = Disable
        constexpr uint32_t PWMIE2 = (1U << 2);  ///< PWM channel 2 Interrupt Enable 1 = Enable 0 = Disable
        constexpr uint32_t PWMIE3 = (1U << 3);  ///< PWM channel 3 Interrupt Enable 1 = Enable 0 = Disable
    }

    /// PIIR Register bits
    namespace piir_bits {
        constexpr uint32_t PWMIF0 = (1U << 0);  ///< PWM channel 0 Interrupt Status Flag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing a one to it.
        constexpr uint32_t PWMIF1 = (1U << 1);  ///< PWM channel 1 Interrupt Status Flag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing a one to it.
        constexpr uint32_t PWMIF2 = (1U << 2);  ///< PWM channel 2 Interrupt Status Flag is set by hardware when PWM2 down counter reaches zero, software can clear this bit by writing a one to it.
        constexpr uint32_t PWMIF3 = (1U << 3);  ///< PWM channel 3 Interrupt Status Flag is set by hardware when PWM3 down counter reaches zero, software can clear this bit by writing a one to it.
    }

    /// CCR0 Register bits
    namespace ccr0_bits {
        constexpr uint32_t INV0 = (1U << 0);  ///< PWM Group Channel 0 Inverter ON/OFF 1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 0 = Inverter OFF
        constexpr uint32_t CRL_IE0 = (1U << 1);  ///< PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF 1 = Enable rising latch interrupt 0 = Disable rising latch interrupt When Enable, if Capture detects PWM group channel 0 has rising transition, Capture issues an Interrupt.
        constexpr uint32_t CFL_IE0 = (1U << 2);  ///< PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF 1 = Enable falling latch interrupt 0 = Disable falling latch interrupt When Enable, if Capture detects PWM group channel 0 has falling transition, Capture issues an Interrupt.
        constexpr uint32_t CAPCH0EN = (1U << 3);  ///< Capture Channel 0 transition Enable/Disable 1 = Enable capture function on PWM group channel 0. 0 = Disable capture function on PWM group channel 0 When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch). When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.
        constexpr uint32_t CAPIF0 = (1U << 4);  ///< Capture0 Interrupt Indication Flag If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). This flag is clear by software with a write 1 to itself.
        constexpr uint32_t CRLRI0 = (1U << 6);  ///< CRLR0 Latched Indicator Bit When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
        constexpr uint32_t CFLRI0 = (1U << 7);  ///< CFLR0 Latched Indicator Bit When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
        constexpr uint32_t INV1 = (1U << 16);  ///< PWM Group Channel 1 Inverter ON/OFF 1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 0 = Inverter OFF
        constexpr uint32_t CRL_IE1 = (1U << 17);  ///< PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF 1 = Enable rising latch interrupt 0 = Disable rising latch interrupt When Enable, if Capture detects PWM group channel 1 has rising transition, Capture issues an Interrupt.
        constexpr uint32_t CFL_IE1 = (1U << 18);  ///< PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF 1 = Enable falling latch interrupt 0 = Disable falling latch interrupt When Enable, if Capture detects PWM group channel 1 has falling transition, Capture issues an Interrupt.
        constexpr uint32_t CAPCH1EN = (1U << 19);  ///< Capture Channel 1 transition Enable/Disable 1 = Enable capture function on PWM group channel 1. 0 = Disable capture function on PWM group channel 1 When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch). When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.
        constexpr uint32_t CAPIF1 = (1U << 20);  ///< Capture1 Interrupt Indication Flag If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). This flag is clear by software with a write 1 to itself.
        constexpr uint32_t CRLRI1 = (1U << 22);  ///< CRLR1 Latched Indicator Bit When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
        constexpr uint32_t CFLRI1 = (1U << 23);  ///< CFLR1 Latched Indicator Bit When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t INV2 = (1U << 0);  ///< PWM Group Channel 2 Inverter ON/OFF 1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 0 = Inverter OFF
        constexpr uint32_t CRL_IE2 = (1U << 1);  ///< PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF 1 = Enable rising latch interrupt 0 = Disable rising latch interrupt When Enable, if Capture detects PWM group channel 2 has rising transition, Capture issues an Interrupt.
        constexpr uint32_t CFL_IE2 = (1U << 2);  ///< PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF 1 = Enable falling latch interrupt 0 = Disable falling latch interrupt When Enable, if Capture detects PWM group channel 2 has falling transition, Capture issues an Interrupt.
        constexpr uint32_t CAPCH2EN = (1U << 3);  ///< Capture Channel 2 transition Enable/Disable 1 = Enable capture function on PWM group channel 2. 0 = Disable capture function on PWM group channel 2 When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch). When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.
        constexpr uint32_t CAPIF2 = (1U << 4);  ///< Capture2 Interrupt Indication Flag If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). This flag is clear by software with a write 1 to itself.
        constexpr uint32_t CRLRI2 = (1U << 6);  ///< CRLR2 Latched Indicator Bit When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
        constexpr uint32_t CFLRI2 = (1U << 7);  ///< CFLR2 Latched Indicator Bit When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
        constexpr uint32_t INV3 = (1U << 16);  ///< PWM Group Channel 3 Inverter ON/OFF 1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 0 = Inverter OFF
        constexpr uint32_t CRL_IE3 = (1U << 17);  ///< PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF 1 = Enable rising latch interrupt 0 = Disable rising latch interrupt When Enable, if Capture detects PWM group channel 3 has rising transition, Capture issues an Interrupt.
        constexpr uint32_t CFL_IE3 = (1U << 18);  ///< PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF 1 = Enable falling latch interrupt 0 = Disable falling latch interrupt When Enable, if Capture detects PWM group channel 3 has falling transition, Capture issues an Interrupt.
        constexpr uint32_t CAPCH3EN = (1U << 19);  ///< Capture Channel 3 transition Enable/Disable 1 = Enable capture function on PWM group channel 3. 0 = Disable capture function on PWM group channel 3 When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch). When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.
        constexpr uint32_t CAPIF3 = (1U << 20);  ///< Capture3 Interrupt Indication Flag If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). This flag is clear by software with a write 1 to itself.
        constexpr uint32_t CRLRI3 = (1U << 22);  ///< CRLR3 Latched Indicator Bit When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
        constexpr uint32_t CFLRI3 = (1U << 23);  ///< CFLR3 Latched Indicator Bit When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware. Clear this bit by writing a one to it.
    }

    /// CRLR0 Register bits
    namespace crlr0_bits {
        constexpr uint32_t CRLR = (16 << 0);  ///< Capture Rising Latch Register Latch the PWM counter when Channel 0/1/2/3 has rising transition.
    }

    /// CFLR0 Register bits
    namespace cflr0_bits {
        constexpr uint32_t CFLR = (16 << 0);  ///< Capture Falling Latch Register Latch the PWM counter when Channel 01/2/3 has Falling transition.
    }

    /// CRLR1 Register bits
    namespace crlr1_bits {
        constexpr uint32_t CRLR = (16 << 0);  ///< Capture Rising Latch Register Latch the PWM counter when Channel 0/1/2/3 has rising transition.
    }

    /// CFLR1 Register bits
    namespace cflr1_bits {
        constexpr uint32_t CFLR = (16 << 0);  ///< Capture Falling Latch Register Latch the PWM counter when Channel 01/2/3 has Falling transition.
    }

    /// CRLR2 Register bits
    namespace crlr2_bits {
        constexpr uint32_t CRLR = (16 << 0);  ///< Capture Rising Latch Register Latch the PWM counter when Channel 0/1/2/3 has rising transition.
    }

    /// CFLR2 Register bits
    namespace cflr2_bits {
        constexpr uint32_t CFLR = (16 << 0);  ///< Capture Falling Latch Register Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
    }

    /// CRLR3 Register bits
    namespace crlr3_bits {
        constexpr uint32_t CRLR = (16 << 0);  ///< Capture Rising Latch Register Latch the PWM counter when Channel 0/1/2/3 has rising transition.
    }

    /// CFLR3 Register bits
    namespace cflr3_bits {
        constexpr uint32_t CFLR = (16 << 0);  ///< Capture Falling Latch Register Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
    }

    /// CAPENR Register bits
    namespace capenr_bits {
        constexpr uint32_t CAPENR = (4 << 0);  ///< Capture Input Enable Register There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or OFF. 0 = OFF (PWMx multi-function pin input does not affect input capture function.) 1 = (PWMx multi-function pin input will affect its input capture function.) CAPENR Bit 3210 for PWM group A Bit xxx1 -> Capture channel 0 is from P2 [0] Bit xx1x -> Capture channel 1 is from P2 [1] Bit x1xx -> Capture channel 2 is from P2 [2] Bit 1xxx -> Capture channel 3 is from P2 [3] Bit 3210 for PWM group B Bit xxx1 -> Capture channel 0 is from P2 [4] Bit xx1x -> Capture channel 1 is from P2 [5] Bit x1xx -> Capture channel 2 is from P2 [6] Bit 1xxx -> Capture channel 3 is from P2 [7]
    }

    /// POE Register bits
    namespace poe_bits {
        constexpr uint32_t PWM0 = (1U << 0);  ///< PWM Channel 0 Output Enable Register 1 = Enable PWM channel 0 output to pin. 0 = Disable PWM channel 0 output to pin. Note: The corresponding GPIO pin also must be switched to PWM function.
        constexpr uint32_t PWM1 = (1U << 1);  ///< PWM Channel 1 Output Enable Register 1 = Enable PWM channel 1 output to pin. 0 = Disable PWM channel 1 output to pin. Note: The corresponding GPIO pin also must be switched to PWM function.
        constexpr uint32_t PWM2 = (1U << 2);  ///< PWM Channel 2 Output Enable Register 1 = Enable PWM channel 2 output to pin. 0 = Disable PWM channel 2 output to pin. Note: The corresponding GPIO pin also must be switched to PWM function.
        constexpr uint32_t PWM3 = (1U << 3);  ///< PWM Channel 3 Output Enable Register 1 = Enable PWM channel 3 output to pin. 0 = Disable PWM channel 3 output to pin. Note: The corresponding GPIO pin also must be switched to PWM function.
    }

}

// ============================================================================
// SCS Peripheral
// ============================================================================

namespace scs {
    /// Base addresses
    constexpr uint32_t SCS_BASE = 0xE000E000;

    /// SCS Register structure
    struct Registers {
        volatile uint32_t SYST_CSR;  ///< Offset: 0x10 - SysTick Control and Status Register
        volatile uint32_t SYST_RVR;  ///< Offset: 0x14 - SysTick Reload value Register
        volatile uint32_t SYST_CVR;  ///< Offset: 0x18 - SysTick Current value Register
        volatile uint32_t NVIC_ISER;  ///< Offset: 0x100 - IRQ0 ~ IRQ31 Set-Enable Control Register
        volatile uint32_t NVIC_ICER;  ///< Offset: 0x180 - IRQ0 ~ IRQ31 Clear-Enable Control Register
        volatile uint32_t NVIC_ISPR;  ///< Offset: 0x200 - IRQ0 ~ IRQ31 Set-Pending Control Register
        volatile uint32_t NVIC_ICPR;  ///< Offset: 0x280 - IRQ0 ~ IRQ31 Clear-Pending Control Register
        volatile uint32_t NVIC_IPR0;  ///< Offset: 0x400 - IRQ0 ~ IRQ3 Priority Control Register
        volatile uint32_t NVIC_IPR1;  ///< Offset: 0x404 - IRQ4 ~ IRQ7 Priority Control Register
        volatile uint32_t NVIC_IPR2;  ///< Offset: 0x408 - IRQ8 ~ IRQ11 Priority Control Register
        volatile uint32_t NVIC_IPR3;  ///< Offset: 0x40C - IRQ12 ~ IRQ15 Priority Control Register
        volatile uint32_t NVIC_IPR4;  ///< Offset: 0x410 - IRQ16 ~ IRQ19 Priority Control Register
        volatile uint32_t NVIC_IPR5;  ///< Offset: 0x414 - IRQ20 ~ IRQ23 Priority Control Register
        volatile uint32_t NVIC_IPR6;  ///< Offset: 0x418 - IRQ24 ~ IRQ27 Priority Control Register
        volatile uint32_t NVIC_IPR7;  ///< Offset: 0x41C - IRQ28 ~ IRQ31 Priority Control Register
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control State Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
    };

    /// Peripheral instances
    inline Registers* SCS = reinterpret_cast<Registers*>(SCS_BASE);

    // Bit definitions
    /// SYST_CSR Register bits
    namespace syst_csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< 1 = The counter will operate in a multi-shot manner. 0 = The counter is disabled
        constexpr uint32_t TICKINT = (1U << 1);  ///< 1 = Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended. 0 = Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to zero has occurred.
        constexpr uint32_t CLKSRC = (1U << 2);  ///< 1 = Core clock used for SysTick. 0 = Clock source is optional, refer to STCLK_S.
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< Returns 1 if timer counted to 0 since last time this register was read. COUNTFLAG is set by a count transition from 1 to 0. COUNTFLAG is cleared on read or by a write to the Current Value register.
    }

    /// SYST_RVR Register bits
    namespace syst_rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the Current Value register when the counter reaches 0.
    }

    /// SYST_CVR Register bits
    namespace syst_cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0. Unsupported bits RAZ (see SysTick Reload Value register).
    }

    /// NVIC_ISER Register bits
    namespace nvic_iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Enable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). Writing 1 will enable the associated interrupt. Writing 0 has no effect. The register reads back with the current enable state.
    }

    /// NVIC_ICER Register bits
    namespace nvic_icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Disable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). Writing 1 will disable the associated interrupt. Writing 0 has no effect. The register reads back with the current enable state.
    }

    /// NVIC_ISPR Register bits
    namespace nvic_ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Writing 1 to a bit pends the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). Writing 0 has no effect. The register reads back with the current pending state.
    }

    /// NVIC_ICPR Register bits
    namespace nvic_icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Writing 1 to a bit un-pends the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). Writing 0 has no effect. The register reads back with the current pending state.
    }

    /// NVIC_IPR0 Register bits
    namespace nvic_ipr0_bits {
        constexpr uint32_t PRI_0 = (2 << 6);  ///< Priority of IRQ0 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_1 = (2 << 14);  ///< Priority of IRQ1 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_2 = (2 << 22);  ///< Priority of IRQ2 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_3 = (2 << 30);  ///< Priority of IRQ3 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR1 Register bits
    namespace nvic_ipr1_bits {
        constexpr uint32_t PRI_4 = (2 << 6);  ///< Priority of IRQ4 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_5 = (2 << 14);  ///< Priority of IRQ5 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_6 = (2 << 22);  ///< Priority of IRQ6 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_7 = (2 << 30);  ///< Priority of IRQ7 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR2 Register bits
    namespace nvic_ipr2_bits {
        constexpr uint32_t PRI_8 = (2 << 6);  ///< Priority of IRQ8 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_9 = (2 << 14);  ///< Priority of IRQ9 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_10 = (2 << 22);  ///< Priority of IRQ10 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_11 = (2 << 30);  ///< Priority of IRQ11 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR3 Register bits
    namespace nvic_ipr3_bits {
        constexpr uint32_t PRI_12 = (2 << 6);  ///< Priority of IRQ12 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_13 = (2 << 14);  ///< Priority of IRQ13 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_14 = (2 << 22);  ///< Priority of IRQ14 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_15 = (2 << 30);  ///< Priority of IRQ15 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR4 Register bits
    namespace nvic_ipr4_bits {
        constexpr uint32_t PRI_16 = (2 << 6);  ///< Priority of IRQ16 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_17 = (2 << 14);  ///< Priority of IRQ17 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_18 = (2 << 22);  ///< Priority of IRQ18 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_19 = (2 << 30);  ///< Priority of IRQ19 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR5 Register bits
    namespace nvic_ipr5_bits {
        constexpr uint32_t PRI_20 = (2 << 6);  ///< Priority of IRQ20 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_21 = (2 << 14);  ///< Priority of IRQ21 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_22 = (2 << 22);  ///< Priority of IRQ22 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_23 = (2 << 30);  ///< Priority of IRQ23 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR6 Register bits
    namespace nvic_ipr6_bits {
        constexpr uint32_t PRI_24 = (2 << 6);  ///< Priority of IRQ24 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_25 = (2 << 14);  ///< Priority of IRQ25 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_26 = (2 << 22);  ///< Priority of IRQ26 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_27 = (2 << 30);  ///< Priority of IRQ27 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// NVIC_IPR7 Register bits
    namespace nvic_ipr7_bits {
        constexpr uint32_t PRI_28 = (2 << 6);  ///< Priority of IRQ28 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_29 = (2 << 14);  ///< Priority of IRQ29 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_30 = (2 << 22);  ///< Priority of IRQ30 "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_31 = (2 << 30);  ///< Priority of IRQ31 "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Reads as 0x0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Reads as 0xC20.
        constexpr uint32_t PART = (4 << 16);  ///< Reads as 0xC for ARMv6-M parts
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code assigned by ARM. ( ARM = 0x41)
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< 0 = Thread mode value > 1: the exception number for the current executing exception.
        constexpr uint32_t VECTPENDING = (9 << 12);  ///< Indicates the exception number for the highest priority pending exception. The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier. A value of zero indicates no pending exceptions.
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Indicates if an external configurable (NVIC generated) interrupt is pending.
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< If set, a pending exception will be serviced on exit from the debug halt state.
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< Write 1 to clear a pending SysTick.
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< Set a pending SysTick. Reads back with current state (1 if Pending, 0 if not).
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< Write 1 to clear a pending PendSV interrupt.
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< Set a pending PendSV interrupt. This is normally used to request a context switch. Reads back with current state (1 if Pending, 0 if not).
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. Reads back with current state (1 if Pending, 0 if not).
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< Set this bit to 1 will clears all active state information for fixed and configurable exceptions. The bit is a write only bit and can only be written when the core is halted. Note: It is the debugger's responsibility to re-initialize the stack.
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< Writing this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested. The bit is a write only bit and self-clears as part of the reset sequence.
        constexpr uint32_t VECTORKEY = (16 << 16);  ///< When write this register, this field should be 0x05FA, otherwise the write action will be unpredictable.
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< When set to 1, the core can enter a sleep state on an exception return to Thread mode. This is the mode and exception level entered at reset, the base level of execution.
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< A qualifying hint that indicates waking from sleep might take longer.
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< When enabled, interrupt transitions from Inactive to Pending are included in the list of wakeup events for the WFE instruction.
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (2 << 30);  ///< Priority of system handler 11 - SVCall "0" denotes the highest priority & "3" denotes lowest priority
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (2 << 22);  ///< Priority of system handler 14 - PendSV "0" denotes the highest priority & "3" denotes lowest priority
        constexpr uint32_t PRI_15 = (2 << 30);  ///< Priority of system handler 15 - SysTick "0" denotes the highest priority & "3" denotes lowest priority
    }

}

// ============================================================================
// TMR0 Peripheral
// ============================================================================

namespace tmr0 {
    /// Base addresses
    constexpr uint32_t TMR0_BASE = 0x40010000;

    /// TMR0 Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - Timer0 Control and Status Register
        volatile uint32_t TCMPR;  ///< Offset: 0x04 - Timer0 Compare Register
        volatile uint32_t TISR;  ///< Offset: 0x08 - Timer0 Interrupt Status Register
        volatile uint32_t TDR;  ///< Offset: 0x0C - Timer0 Data Register
    };

    /// Peripheral instances
    inline Registers* TMR0 = reinterpret_cast<Registers*>(TMR0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t PRESCALE = (8 << 0);  ///< Pre-scale Counter Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.
        constexpr uint32_t TDR_EN = (1U << 16);  ///< Data Load Enable When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 1 = Timer Data Register update enable. 0 = Timer Data Register update disable.
        constexpr uint32_t CACT = (1U << 25);  ///< Timer Active Status Bit (Read only) This bit indicates the up-timer status. 0 = Timer is not active. 1 = Timer is active.
        constexpr uint32_t CRST = (1U << 26);  ///< Timer Reset Bit Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0. 0 = No effect. 1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.
        constexpr uint32_t MODE = (2 << 27);  ///< Timer Operating Mode MODE	Timer Operating Mode	 00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	 01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	 10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle.	 11	Reserved
        constexpr uint32_t IE = (1U << 29);  ///< Interrupt Enable Bit 1 = Enable timer Interrupt. 0 = Disable timer Interrupt. If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.
        constexpr uint32_t CEN = (1U << 30);  ///< Timer Enable Bit 1 = Starts counting 0 = Stops/Suspends counting Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value. Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).
    }

    /// TCMPR Register bits
    namespace tcmpr_bits {
        constexpr uint32_t TCMP = (24 << 0);  ///< Timer Compared Value TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time. Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP) NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state. NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.
    }

    /// TISR Register bits
    namespace tisr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag This bit indicates the interrupt status of Timer. TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (24 << 0);  ///< Timer Data Register When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.
    }

}

// ============================================================================
// TMR1 Peripheral
// ============================================================================

namespace tmr1 {
    /// Base addresses
    constexpr uint32_t TMR1_BASE = 0x40010020;

    /// TMR1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TMR1 = reinterpret_cast<Registers*>(TMR1_BASE);

}

// ============================================================================
// TMR2 Peripheral
// ============================================================================

namespace tmr2 {
    /// Base addresses
    constexpr uint32_t TMR2_BASE = 0x40110000;

    /// TMR2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TMR2 = reinterpret_cast<Registers*>(TMR2_BASE);

}

// ============================================================================
// TMR3 Peripheral
// ============================================================================

namespace tmr3 {
    /// Base addresses
    constexpr uint32_t TMR3_BASE = 0x40110020;

    /// TMR3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TMR3 = reinterpret_cast<Registers*>(TMR3_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40004000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WTCR;  ///< Offset: 0x00 - Watchdog Timer Control Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// WTCR Register bits
    namespace wtcr_bits {
        constexpr uint32_t WTR = (1U << 0);  ///< Clear Watchdog Timer Set this bit will clear the Watchdog timer. 0= Writing 0 to this bit has no effect 1= Reset the contents of the Watchdog timer NOTE: This bit will auto clear after few clock cycle
        constexpr uint32_t WTRE = (1U << 1);  ///< Watchdog Timer Reset Enable Setting this bit will enable the Watchdog timer reset function. 0= Disable Watchdog timer reset function 1= Enable Watchdog timer reset function
        constexpr uint32_t WTRF = (1U << 2);  ///< Watchdog Timer Reset Flag When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing 1 to it. If WTRE is disabled, then the Watchdog timer has no effect on this bit. 0= Watchdog timer reset does not occur 1= Watchdog timer reset occurs NOTE: This bit is cleared by writing 1 to this bit.
        constexpr uint32_t WTIF = (1U << 3);  ///< Watchdog Timer Interrupt Flag If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit indicates that a timeout period has elapsed. 0= Watchdog timer interrupt does not occur 1= Watchdog timer interrupt occurs NOTE: Write 1 to clear this bit to zero.
        constexpr uint32_t WTWKE = (1U << 4);  ///< Watchdog Timer Wakeup Function Enable bit 0 = Disable Watchdog timer Wakeup CPU function. 1 = Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down mode.
        constexpr uint32_t WTWKF = (1U << 5);  ///< Watchdog Timer Wakeup Flag If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit. 1 = CPU wake up from sleep or power-down mode by Watchdog timeout. 0 = Watchdog timer does not cause CPU wakeup. NOTE: Write 1 to clear this bit to zero.
        constexpr uint32_t WTIE = (1U << 6);  ///< Watchdog Timer Interrupt Enable 0= Disable the Watchdog timer interrupt 1= Enable the Watchdog timer interrupt
        constexpr uint32_t WTE = (1U << 7);  ///< Watchdog Timer Enable 0= Disable the Watchdog timer (This action will reset the internal counter) 1= Enable the Watchdog timer
        constexpr uint32_t WTIS = (3 << 8);  ///< Watchdog Timer Interval Select (write protection bit) These three bits select the timeout interval for the Watchdog timer. WTIS	Timeout Interval Selection	Interrupt Period	WTR Timeout Interval (WDT_CLK=12MHz)	 000	2^4 * WDT_CLK	(2^4 + 1024) * WDT_CLK	1.33 us ~ 86.67 us	 001	2^6 * WDT_CLK	(2^6 + 1024) * WDT_CLK	5.33 us ~ 90.67 us	 010	2^8 * WDT_CLK	(2^8 + 1024) * WDT_CLK	21.33 us ~ 106.67 us	 011	2^10 * WDT_CLK	(2^10 + 1024) * WDT_CLK	85.33 us ~ 170.67 us	 100	2^12 * WDT_CLK	(2^12 + 1024) * WDT_CLK	341.33 us ~ 426.67 us	 101	2^14 * WDT_CLK	(2^14 + 1024) * WDT_CLK	1.36 ms ~ 1.45 ms	 110	2^16 * WDT_CLK	(2^16 + 1024) * WDT_CLK	5.46 ms ~ 5.55 ms	 111	2^18 * WDT_CLK	(2^18 + 1024) * WDT_CLK	21.84 ms ~ 21.93 ms
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40030000;
    constexpr uint32_t SPI1_BASE = 0x40034000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CNTRL;  ///< Offset: 0x00 - Control and Status Register
        volatile uint32_t SPI_DIVIDER;  ///< Offset: 0x04 - Clock Divider Register
        volatile uint32_t SPI_SSR;  ///< Offset: 0x08 - Slave Select Register
        volatile uint32_t SPI_RX0;  ///< Offset: 0x10 - Data Receive Register 0
        volatile uint32_t SPI_RX1;  ///< Offset: 0x14 - Data Receive Register 1
        volatile uint32_t SPI_TX0;  ///< Offset: 0x20 - Data Transmit Register 0
        volatile uint32_t SPI_TX1;  ///< Offset: 0x24 - Data Transmit Register 1
        volatile uint32_t SPI_VARCLK;  ///< Offset: 0x34 - Variable Clock Pattern Register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// SPI_CNTRL Register bits
    namespace spi_cntrl_bits {
        constexpr uint32_t GO_BUSY = (1U << 0);  ///< Go and Busy Status 1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master. 0 = Writing 0 to this bit to stop data transfer if SPI is transferring. During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.
        constexpr uint32_t RX_NEG = (1U << 1);  ///< Receive At Negative Edge 1 = The received data input signal is latched at the falling edge of SPICLK. 0 = The received data input signal is latched at the rising edge of SPICLK.
        constexpr uint32_t TX_NEG = (1U << 2);  ///< Transmit At Negative Edge 1 = The transmitted data output signal is changed at the falling edge of SPICLK. 0 = The transmitted data output signal is changed at the rising edge of SPICLK.
        constexpr uint32_t TX_BIT_LEN = (5 << 3);  ///< Transmit Bit Length This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted. TX_BIT_LEN = 0x01 ... 1 bit TX_BIT_LEN = 0x02 ... 2 bits ...... TX_BIT_LEN = 0x1f ... 31 bits TX_BIT_LEN = 0x00 .. 32 bits
        constexpr uint32_t TX_NUM = (2 << 8);  ///< Numbers of Transmit/Receive Word This field specifies how many transmit/receive word numbers should be executed in one transfer. 00 = Only one transmit/receive word will be executed in one transfer. 01 = Two successive transmit/receive words will be executed in one transfer. (burst mode) 10 = Reserved. 11 = Reserved.
        constexpr uint32_t LSB = (1U << 10);  ///< LSB First 1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1). 0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).
        constexpr uint32_t CLKP = (1U << 11);  ///< Clock Polarity 1 = SPICLK idle high. 0 = SPICLK idle low.
        constexpr uint32_t SP_CYCLE = (4 << 12);  ///< Suspend Interval (master only) These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation: (SP_CYCLE[3:0] + 2)*period of SPI clock SP_CYCLE = 0x0 ... 2 SPICLK clock cycle SP_CYCLE = 0x1 ... 3 SPICLK clock cycle ...... SP_CYCLE = 0xe ... 16 SPICLK clock cycle SP_CYCLE = 0xf ... 17 SPICLK clock cycle
        constexpr uint32_t IF = (1U << 16);  ///< Interrupt Flag 1 = It indicates that the transfer is done. The interrupt flag is set if it was enable. 0 = It indicates that the transfer does not finish yet. NOTE: This bit can be cleared by writing 1 to itself.
        constexpr uint32_t IE = (1U << 17);  ///< Interrupt Enable 1 = Enable MICROWIRE/SPI Interrupt. 0 = Disable MICROWIRE/SPI Interrupt.
        constexpr uint32_t SLAVE = (1U << 18);  ///< SLAVE Mode Indication 1 = Slave mode. 0 = Master mode.
        constexpr uint32_t REORDER = (2 << 19);  ///< Reorder Mode Select 00 = Disable both byte reorder and byte suspend functions. 01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word). 10 = Enable byte reorder function, but disable byte suspend function. 11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word). Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.
        constexpr uint32_t VARCLK_EN = (1U << 23);  ///< Variable Clock Enable (master only) 1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2. 0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)
    }

    /// SPI_DIVIDER Register bits
    namespace spi_divider_bits {
        constexpr uint32_t DIVIDER = (16 << 0);  ///< Clock Divider Register (master only) The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation: fsclk = fpclk / ((DIVIDER+1)*2) In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.
        constexpr uint32_t DIVIDER2 = (16 << 16);  ///< Clock Divider 2 Register (master only) The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation: fsclk = fpclk / ((DIVIDER2+1)*2)
    }

    /// SPI_SSR Register bits
    namespace spi_ssr_bits {
        constexpr uint32_t SSR = (1U << 0);  ///< Slave Select Register (master only) If AUTOSS bit is cleared, writing 1 to this bit sets the SPISSx line to active state and writing 0 sets the line back to inactive state. If AUTOSS bit is set, writing 1 to this bit will select the SPISSx line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).
        constexpr uint32_t SS_LVL = (1U << 2);  ///< Slave Select Active Level It defines the active level of slave select signal (SPISSx). 1 = The slave select signal SPISSx is active at high-level/rising-edge. 0 = The slave select signal SPISSx is active at low-level/falling-edge.
        constexpr uint32_t AUTOSS = (1U << 3);  ///< Automatic Slave Select (master only) 1 = If this bit is set, SPISSx signal is generated automatically. It means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished. 0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting and clearing SSR[0].
        constexpr uint32_t SS_LTRIG = (1U << 4);  ///< Slave Select Level Trigger (slave only) 1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high. 0: The input slave select signal is edge-trigger. This is default value.
        constexpr uint32_t LTRIG_FLAG = (1U << 5);  ///< Level Trigger Flag When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not. 1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN. 0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements. Note: This bit is READ only
    }

    /// SPI_RX0 Register bits
    namespace spi_rx0_bits {
        constexpr uint32_t RX = (32 << 0);  ///< Data Receive Register The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data. NOTE: The Data Receive Registers are read only registers.
    }

    /// SPI_RX1 Register bits
    namespace spi_rx1_bits {
        constexpr uint32_t RX = (32 << 0);  ///< Data Receive Register The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data. NOTE: The Data Receive Registers are read only registers.
    }

    /// SPI_TX0 Register bits
    namespace spi_tx0_bits {
        constexpr uint32_t TX = (32 << 0);  ///< Data Transmit Register The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).
    }

    /// SPI_TX1 Register bits
    namespace spi_tx1_bits {
        constexpr uint32_t TX = (32 << 0);  ///< Data Transmit Register The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).
    }

    /// SPI_VARCLK Register bits
    namespace spi_varclk_bits {
        constexpr uint32_t VARCLK = (32 << 0);  ///< Variable Clock Pattern The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40050000;
    constexpr uint32_t UART1_BASE = 0x40150000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t UA_RBR;  ///< Offset: 0x00 - UART0 Receive Buffer Register.
        volatile uint32_t UA_THR;  ///< Offset: 0x00 - UART0 Transmit Holding Register.
        volatile uint32_t UA_IER;  ///< Offset: 0x04 - UART0 Interrupt Enable Register.
        volatile uint32_t UA_FCR;  ///< Offset: 0x08 - UART0 FIFO Control Register.
        volatile uint32_t UA_LCR;  ///< Offset: 0x0C - UART0 Line Control Register.
        volatile uint32_t UA_MCR;  ///< Offset: 0x10 - UART0 Modem Control Register.
        volatile uint32_t UA_MSR;  ///< Offset: 0x14 - UART0 Modem Status Register.
        volatile uint32_t UA_FSR;  ///< Offset: 0x18 - UART0 FIFO Status Register.
        volatile uint32_t UA_ISR;  ///< Offset: 0x1C - UART0 Interrupt Status Register.
        volatile uint32_t UA_TOR;  ///< Offset: 0x20 - UART0 Time Out Register
        volatile uint32_t UA_BAUD;  ///< Offset: 0x24 - UART0 Baud Rate Divisor Register
        volatile uint32_t UA_IRCR;  ///< Offset: 0x28 - UART0 IrDA Control Register.
        volatile uint32_t UA_ACT_CSR;  ///< Offset: 0x2C - UART0 RS485 Control State Register.
        volatile uint32_t UA_FUN_SEL;  ///< Offset: 0x30 - UART0 Function Select Register.
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

    // Bit definitions
    /// UA_RBR Register bits
    namespace ua_rbr_bits {
        constexpr uint32_t _8_bitReceivedData = (8 << 0);  ///< Receive Buffer Register By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).
    }

    /// UA_THR Register bits
    namespace ua_thr_bits {
        constexpr uint32_t _8_bitTransmittedData = (8 << 0);  ///< Transmit Holding Register By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).
    }

    /// UA_IER Register bits
    namespace ua_ier_bits {
        constexpr uint32_t RDA_IEN = (1U << 0);  ///< Receive Data Available Interrupt Enable. 0 = Mask off INT_RDA 1 = Enable INT_RDA
        constexpr uint32_t THRE_IEN = (1U << 1);  ///< Transmit Holding Register Empty Interrupt Enable 0 = Mask off INT_THRE 1 = Enable INT_THRE
        constexpr uint32_t RLS_IEN = (1U << 2);  ///< Receive Line Status Interrupt Enable 0 = Mask off INT_RLS 1 = Enable INT_RLS
        constexpr uint32_t Modem_IEN = (1U << 3);  ///< Modem Status Interrupt Enable 0 = Mask off INT_MOS 1 = Enable INT_MOS
        constexpr uint32_t RTO_IEN = (1U << 4);  ///< Rx Time out Interrupt Enable 0 = Mask off INT_tout 1 = Enable INT_tout
        constexpr uint32_t BUF_ERR_IEN = (1U << 5);  ///< Buffer Error Interrupt Enable 0 = Mask off INT_Buf_err 1 = Enable INT_Buf_err
        constexpr uint32_t Wake_EN = (1U << 6);  ///< Wake up CPU function enable 0 = Disable UART wake up CPU function 1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS change will wake up CPU from deep sleep mode.
        constexpr uint32_t Time_Out_EN = (1U << 11);  ///< Time-Out Counter Enable 1 = Enable Time-out counter. 0 = Disable Time-out counter.
        constexpr uint32_t Auto_RTS_EN = (1U << 12);  ///< RTS Auto Flow Control Enable 1 = Enable RTS auto flow control. 0 = Disable RTS auto flow control. When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR [RTS_Tri_Lev], the UART will dessert RTS signal.
        constexpr uint32_t Auto_CTS_EN = (1U << 13);  ///< CTS Auto Flow Control Enable 1 = Enable CTS auto flow control. 0 = Disable CTS auto flow control. When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
    }

    /// UA_FCR Register bits
    namespace ua_fcr_bits {
        constexpr uint32_t RFR = (1U << 1);  ///< Rx Software Reset When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are cleared. 0 = Writing 0 to this bit has no effect. 1 = Writing 1 to this bit will reset the Rx internal state machine and pointers. Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
        constexpr uint32_t TFR = (1U << 2);  ///< Tx Software Reset When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are cleared. 0 = Writing 0 to this bit has no effect. 1 = Writing 1 to this bit will reset the Tx internal state machine and pointers. Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
        constexpr uint32_t RFITL = (4 << 4);  ///< Word Length Select RFITL	INTR_RDA Tigger Level(Bytes)	 0000	01	 0001	04	 0010	08	 0011	14
        constexpr uint32_t RX_DIS = (1U << 8);  ///< Receiver Disable register. The receiver is disabled or not (set 1 is disable receiver) 1: Disable Receiver 0: Enable Receiver Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.
        constexpr uint32_t RTS_Tri_Lev = (4 << 16);  ///< Word Length Select RTS_Tri_Lev	Trigger Level(Bytes)	 0000	01	 0001	04	 0010	08	 0011	14
    }

    /// UA_LCR Register bits
    namespace ua_lcr_bits {
        constexpr uint32_t WLS = (2 << 0);  ///< Word Length Select WLS[1:0]	Character length	 00	5 bits	 01	6 bits	 10	7 bits	 11	8 bits
        constexpr uint32_t NSB = (1U << 2);  ///< Number of "STOP bit" 0= One "STOP bit" is generated in the transmitted data 1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected; Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.
        constexpr uint32_t PBE = (1U << 3);  ///< Parity Bit Enable 0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer. 1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
        constexpr uint32_t EPE = (1U << 4);  ///< Even Parity Enable 0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits. 1 = Even number of logic 1's are transmitted or checked in the data word and parity bits. This bit has effect only when bit 3 (parity bit enable) is set.
        constexpr uint32_t SPE = (1U << 5);  ///< Stick Parity Enable 0 = Disable stick parity 1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.
        constexpr uint32_t BCB = (1U << 6);  ///< Break Control Bit When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit acts only on Tx and has no effect on the transmitter logic.
    }

    /// UA_MCR Register bits
    namespace ua_mcr_bits {
        constexpr uint32_t RTS = (1U << 1);  ///< RTS (Request-To-Send) Signal 0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered). 1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered). 0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered). 1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).
        constexpr uint32_t Lev_RTS = (1U << 9);  ///< RTS Trigger Level This bit can change the RTS trigger level. 0= low level triggered 1= high level triggered
        constexpr uint32_t RTS_St = (1U << 13);  ///< RTS Pin State This bit is the pin status of RTS.
    }

    /// UA_MSR Register bits
    namespace ua_msr_bits {
        constexpr uint32_t DCTSF = (1U << 0);  ///< Detect CTS State Change Flag This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when IER [Modem_IEN]. NOTE: This bit is cleared by writing 1 to itself.
        constexpr uint32_t CTS_St = (1U << 4);  ///< CTS Pin Status This bit is the pin status of CTS.
        constexpr uint32_t Lev_CTS = (1U << 8);  ///< CTS Trigger Level This bit can change the CTS trigger level. 0= low level triggered 1= high level triggered
    }

    /// UA_FSR Register bits
    namespace ua_fsr_bits {
        constexpr uint32_t Rx_Over_IF = (1U << 0);  ///< Rx overflow Error IF (Read Only) This bit is set when Rx FIFO overflow. If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of UART0/UART1, this bit will be set. NOTE: This bit is cleared by writing 1 to itself.
        constexpr uint32_t RS_485_Add_Det = (1U << 3);  ///< RS-485 Address Byte Detection Flag This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = '1') bit", and it is reset whenever the CPU writes 1 to this bit. Note: This field is used for RS-485 mode.
        constexpr uint32_t PEF = (1U << 4);  ///< Parity Error Flag This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
        constexpr uint32_t FEF = (1U << 5);  ///< Framing Error Flag This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
        constexpr uint32_t BIF = (1U << 6);  ///< Break Interrupt Flag This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
        constexpr uint32_t Rx_Pointer = (6 << 8);  ///< Rx FIFO pointer (Read Only) This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer decreases one.
        constexpr uint32_t Rx_Empty = (1U << 14);  ///< Receiver FIFO Empty (Read Only) This bit initiate Rx FIFO empty or not. When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.
        constexpr uint32_t Rx_Full = (1U << 15);  ///< Receiver FIFO Full (Read Only) This bit initiates Rx FIFO full or not. This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by hardware.
        constexpr uint32_t Tx_Pointer = (6 << 16);  ///< TX FIFO Pointer (Read Only) This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift Register, Tx_Pointer decreases one.
        constexpr uint32_t Tx_Empty = (1U << 22);  ///< Transmitter FIFO Empty (Read Only) This bit indicates Tx FIFO empty or not. When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).
        constexpr uint32_t Tx_Full = (1U << 23);  ///< Transmitter FIFO Full (Read Only) This bit indicates Tx FIFO full or not. This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.
        constexpr uint32_t Tx_Over_IF = (1U << 24);  ///< Tx Overflow Error Interrupt Flag (Read Only) If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. NOTE: This bit is cleared by writing 1 to itself.
        constexpr uint32_t TE_Flag = (1U << 28);  ///< Transmitter Empty Flag (Read Only) Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte has been transmitted. Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed. NOTE: This bit is read only.
    }

    /// UA_ISR Register bits
    namespace ua_isr_bits {
        constexpr uint32_t RDA_IF = (1U << 0);  ///< Receive Data Available Interrupt Flag (Read Only). When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If IER[RDA_IEN] is enabled, the RDA interrupt will be generated. NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).
        constexpr uint32_t THRE_IF = (1U << 1);  ///< Transmit Holding Register Empty Interrupt Flag (Read Only). This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If IER[THRE_IEN] is enabled, the THRE interrupt will be generated. NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).
        constexpr uint32_t RLS_IF = (1U << 2);  ///< Receive Line Interrupt Flag (Read Only). In UART mode this bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated. NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det are cleared.
        constexpr uint32_t Modem_IF = (1U << 3);  ///< MODEM Interrupt Flag (Read Only) This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the Modem interrupt will be generated. NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
        constexpr uint32_t Tout_IF = (1U << 4);  ///< Time Out Interrupt Flag (Read Only) This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.
        constexpr uint32_t Buf_Err_IF = (1U << 5);  ///< Buffer Error Interrupt Flag (Read Only) This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error interrupt will be generated. NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared.
        constexpr uint32_t RDA_INT = (1U << 8);  ///< Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA). An AND output with inputs of RDA_IEN and RDA_IF
        constexpr uint32_t THRE_INT = (1U << 9);  ///< Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE). An AND output with inputs of THRE_IEN and THRE_IF
        constexpr uint32_t RLS_INT = (1U << 10);  ///< Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). An AND output with inputs of RLS_IEN and RLS_IF Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.
        constexpr uint32_t Modem_INT = (1U << 11);  ///< MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). An AND output with inputs of Modem_IEN and Modem_IF
        constexpr uint32_t Tout_INT = (1U << 12);  ///< Time Out Interrupt Indicator to Interrupt Controller (INT_Tout) An AND output with inputs of RTO_IEN and Tout_IF
        constexpr uint32_t Buf_Err_INT = (1U << 13);  ///< Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err) An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF
    }

    /// UA_TOR Register bits
    namespace ua_tor_bits {
        constexpr uint32_t TOIC = (7 << 0);  ///< Time Out Interrupt Comparator The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER [RTO_IEN]. A new incoming data word or RX FIFO empty clears INT_TOUT.
        constexpr uint32_t DLY = (8 << 8);  ///< TX Delay time value This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO and the de-assertion of by setting UA_TOR. DLY register.
    }

    /// UA_BAUD Register bits
    namespace ua_baud_bits {
        constexpr uint32_t BRD_LowByte = (8 << 0);  ///< Baud Rate Divider The low byte of the baud rate divider
        constexpr uint32_t BRD_HighByte = (8 << 8);  ///< Baud Rate Divider The high byte of the baud rate divider
        constexpr uint32_t Divider_X = (4 << 24);  ///< Divider X The baud rate divider M = X+1.
        constexpr uint32_t DIV_X_ONE = (1U << 28);  ///< Divider X equal 1 0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must > 8) 1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must > 3). Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	 0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	 1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must >= 8	 2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must >=3
        constexpr uint32_t DIV_X_EN = (1U << 29);  ///< Divider X Enable The BRD = Baud Rate Divider, and the baud rate equation is Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16. 0 = Disable divider X (the equation of M = 16) 1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must > 8). NOTE: When in IrDA mode, this bit must disable. Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	 0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	 1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must >= 8	 2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must >=3
    }

    /// UA_IRCR Register bits
    namespace ua_ircr_bits {
        constexpr uint32_t Tx_SELECT = (1U << 1);  ///< Tx_SELECT 1: Enable IrDA transmitter 0: Enable IrDA receiver
        constexpr uint32_t LB = (1U << 2);  ///< IrDA loop back mode for self test. 1: Enable IrDA loop back mode 0: Disable IrDA loop back mode
        constexpr uint32_t INV_Tx = (1U << 5);  ///< INV_Tx 1= Inverse Tx output signal 0= No inversion
        constexpr uint32_t INV_Rx = (1U << 6);  ///< INV_Rx 1= Inverse Rx input signal 0= No inversion
    }

    /// UA_ACT_CSR Register bits
    namespace ua_act_csr_bits {
        constexpr uint32_t RS_485_NMM = (1U << 8);  ///< RS-485 Normal Multi-drop Operation Mode (NMM) 1: Enable RS-485 Normal Multi-drop Operation Mode (NMM) 0: Disable RS-485 Normal Multi-drop Operation Mode (NMM) Note: It can't be active with RS-485_AAD operation mode.
        constexpr uint32_t RS_485_AAD = (1U << 9);  ///< RS-485 Auto Address Detection Operation Mode (AAD) 1: Enable RS-485 Auto Address Detection Operation Mode (AAD) 0: Disable RS-485 Auto Address Detection Operation Mode (AAD) Note: It can't be active with RS-485_NMM operation mode.
        constexpr uint32_t RS_485_AUD = (1U << 10);  ///< RS-485 Auto Direction Mode (AUD) 1: Enable RS-485 Auto Direction Mode (AUD) 0: Disable RS-485 Auto Direction Mode (AUD) Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
        constexpr uint32_t RS_485_Add_EN = (1U << 15);  ///< RS-485 Address Detection Enable This bit is use to enable RS-485 address detection mode. 1: Enable address detection mode 0: Disable address detection mode Note: This field is used for RS-485 any operation mode.
        constexpr uint32_t ADDR_MATCH = (8 << 24);  ///< Address match value register This field contains the RS-485 address match values. Note: This field is used for RS-485 auto address detection mode.
    }

    /// UA_FUN_SEL Register bits
    namespace ua_fun_sel_bits {
        constexpr uint32_t FUN_SEL = (2 << 0);  ///< Function Select Enable 00 = UART Function. 01 = Reserved. 10 = Enable IrDA Function. 11 = Enable RS-485 Function.
    }

}


} // namespace alloy::generated::m05x_registers

#endif // ALLOY_GENERATED_M05X_REGISTERS_PERIPHERALS_HPP