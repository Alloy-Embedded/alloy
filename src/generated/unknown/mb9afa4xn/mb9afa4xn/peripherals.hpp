/// Auto-generated code for MB9AFA4xN
/// Generated by Alloy Code Generator
/// Source: spansion_mb9afa4xn.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:59
#ifndef ALLOY_GENERATED_MB9AFA4XN_PERIPHERALS_HPP
#define ALLOY_GENERATED_MB9AFA4XN_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::mb9afa4xn {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_crg = true;
    constexpr uint32_t num_crg_instances = 1;
    constexpr bool has_crtrim = true;
    constexpr uint32_t num_crtrim_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_btiosel03 = true;
    constexpr uint32_t num_btiosel03_instances = 1;
    constexpr bool has_btiosel47 = true;
    constexpr uint32_t num_btiosel47_instances = 1;
    constexpr bool has_sbssr = true;
    constexpr uint32_t num_sbssr_instances = 1;
    constexpr bool has_bt0 = true;
    constexpr uint32_t num_bt0_instances = 1;
    constexpr bool has_bt1 = true;
    constexpr uint32_t num_bt1_instances = 1;
    constexpr bool has_bt2 = true;
    constexpr uint32_t num_bt2_instances = 1;
    constexpr bool has_bt3 = true;
    constexpr uint32_t num_bt3_instances = 1;
    constexpr bool has_bt4 = true;
    constexpr uint32_t num_bt4_instances = 1;
    constexpr bool has_bt5 = true;
    constexpr uint32_t num_bt5_instances = 1;
    constexpr bool has_bt6 = true;
    constexpr uint32_t num_bt6_instances = 1;
    constexpr bool has_bt7 = true;
    constexpr uint32_t num_bt7_instances = 1;
    constexpr bool has_wc = true;
    constexpr uint32_t num_wc_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_intreq = true;
    constexpr uint32_t num_intreq_instances = 1;
    constexpr bool has_lcdc = true;
    constexpr uint32_t num_lcdc_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_hdmicec0 = true;
    constexpr uint32_t num_hdmicec0_instances = 1;
    constexpr bool has_hdmicec1 = true;
    constexpr uint32_t num_hdmicec1_instances = 1;
    constexpr bool has_lvd = true;
    constexpr uint32_t num_lvd_instances = 1;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_mfs0 = true;
    constexpr uint32_t num_mfs0_instances = 1;
    constexpr bool has_mfs1 = true;
    constexpr uint32_t num_mfs1_instances = 1;
    constexpr bool has_mfs2 = true;
    constexpr uint32_t num_mfs2_instances = 1;
    constexpr bool has_mfs3 = true;
    constexpr uint32_t num_mfs3_instances = 1;
    constexpr bool has_mfs4 = true;
    constexpr uint32_t num_mfs4_instances = 1;
    constexpr bool has_mfs5 = true;
    constexpr uint32_t num_mfs5_instances = 1;
    constexpr bool has_mfs6 = true;
    constexpr uint32_t num_mfs6_instances = 1;
    constexpr bool has_mfs7 = true;
    constexpr uint32_t num_mfs7_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_exbus = true;
    constexpr uint32_t num_exbus_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crtrim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btiosel03_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btiosel47_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sbssr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct intreq_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hdmicec0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hdmicec1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lvd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exbus_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_IF_BASE = 0x40000000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FRWTR;  ///< Offset: 0x04 - Flash Read Wait Register
        volatile uint32_t FSTR;  ///< Offset: 0x08 - Flash Status Register
        volatile uint32_t FICR;  ///< Offset: 0x20 - Flash Interrupt Control Register
        volatile uint32_t FISR;  ///< Offset: 0x24 - Flash Interrupt Status Register
        volatile uint32_t FICLR;  ///< Offset: 0x28 - Flash Interrupt Clear Register
        volatile uint32_t CRTRMM;  ///< Offset: 0x100 - CR Trimming Data Mirror Register
    };

    /// Peripheral instances
    inline Registers* FLASH_IF = reinterpret_cast<Registers*>(FLASH_IF_BASE);

    // Bit definitions
    /// FRWTR Register bits
    namespace frwtr_bits {
        constexpr uint32_t RWT = (2 << 0);  ///< Read Wait Cycle
    }

    /// FSTR Register bits
    namespace fstr_bits {
        constexpr uint32_t PGMS = (1U << 5);  ///< Flash Program Status
        constexpr uint32_t SERS = (1U << 4);  ///< Flash Sector Erase Status
        constexpr uint32_t ESPS = (1U << 3);  ///< Flash Erase Suspend Status
        constexpr uint32_t CERS = (1U << 2);  ///< Flash Chip Erase Status
        constexpr uint32_t HNG = (1U << 1);  ///< Flash Hang flag
        constexpr uint32_t RDY = (1U << 0);  ///< Flash Rdy
    }

    /// FICR Register bits
    namespace ficr_bits {
        constexpr uint32_t HANGIE = (1U << 1);  ///< HANG Interrupt Enable
        constexpr uint32_t RDYIE = (1U << 0);  ///< RDY Interrupt Enable
    }

    /// FISR Register bits
    namespace fisr_bits {
        constexpr uint32_t HANGIF = (1U << 1);  ///< HANG Interrupt Flag
        constexpr uint32_t RDYIF = (1U << 0);  ///< RDY Interrupt Flag
    }

    /// FICLR Register bits
    namespace ficlr_bits {
        constexpr uint32_t HANGC = (1U << 1);  ///< HANG Interrupt Clear
        constexpr uint32_t RDYC = (1U << 0);  ///< RDY Interrupt Clear
    }

    /// CRTRMM Register bits
    namespace crtrmm_bits {
        constexpr uint32_t TRMM = (10 << 0);  ///< CR Trimming Data Mirror
    }

}

// ============================================================================
// CRG Peripheral
// ============================================================================

namespace crg {
    /// Base addresses
    constexpr uint32_t CRG_BASE = 0x40010000;

    /// CRG Register structure
    struct Registers {
        volatile uint32_t SCM_CTL;  ///< Offset: 0x00 - System Clock Mode Control Register
        volatile uint32_t SCM_STR;  ///< Offset: 0x04 - System Clock Mode Status Register
        volatile uint32_t BSC_PSR;  ///< Offset: 0x10 - Base Clock Prescaler Register
        volatile uint32_t APBC0_PSR;  ///< Offset: 0x14 - APB0 Prescaler Register
        volatile uint32_t APBC1_PSR;  ///< Offset: 0x18 - APB1 Prescaler Register
        volatile uint32_t APBC2_PSR;  ///< Offset: 0x1C - APB2 Prescaler Register
        volatile uint32_t SWC_PSR;  ///< Offset: 0x20 - Software Watchdog Clock Prescaler Register
        volatile uint32_t TTC_PSR;  ///< Offset: 0x28 - Trace Clock Prescaler Register
        volatile uint32_t CSW_TMR;  ///< Offset: 0x30 - Clock Stabilization Wait Time Register
        volatile uint32_t PSW_TMR;  ///< Offset: 0x34 - PLL Clock Stabilization Wait Time Setup Register
        volatile uint32_t PLL_CTL1;  ///< Offset: 0x38 - PLL Control Register 1
        volatile uint32_t PLL_CTL2;  ///< Offset: 0x3C - PLL Control Register 2
        volatile uint32_t DBWDT_CTL;  ///< Offset: 0x54 - Debug Break Watchdog Timer Control Register
        volatile uint32_t INT_ENR;  ///< Offset: 0x60 - Interrupt Enable Register
        volatile uint32_t INT_STR;  ///< Offset: 0x64 - Interrupt Status Register
        volatile uint32_t INT_CLR;  ///< Offset: 0x68 - Interrupt Clear Register
        volatile uint32_t RST_STR;  ///< Offset: 0x0C - Reset Cause Register
        volatile uint32_t STB_CTL;  ///< Offset: 0x08 - Standby Mode Control Register
        volatile uint32_t CSV_CTL;  ///< Offset: 0x40 - CSV control register
        volatile uint32_t CSV_STR;  ///< Offset: 0x44 - CSV status register
        volatile uint32_t FCSWH_CTL;  ///< Offset: 0x48 - Frequency detection window setting register
        volatile uint32_t FCSWL_CTL;  ///< Offset: 0x4C - Frequency detection window setting register
        volatile uint32_t FCSWD_CTL;  ///< Offset: 0x50 - Frequency detection counter register
    };

    /// Peripheral instances
    inline Registers* CRG = reinterpret_cast<Registers*>(CRG_BASE);

    // Bit definitions
    /// SCM_CTL Register bits
    namespace scm_ctl_bits {
        constexpr uint32_t RCS = (3 << 5);  ///< Master clock switch control bits
        constexpr uint32_t PLLE = (1U << 4);  ///< PLL oscillation enable bit
        constexpr uint32_t SOSCE = (1U << 3);  ///< Sub clock oscillation enable bit
        constexpr uint32_t MOSCE = (1U << 1);  ///< Main clock oscillation enable bit
    }

    /// SCM_STR Register bits
    namespace scm_str_bits {
        constexpr uint32_t RCM = (3 << 5);  ///< Master clock selection bits
        constexpr uint32_t PLRDY = (1U << 4);  ///< PLL oscillation stable bit
        constexpr uint32_t SORDY = (1U << 3);  ///< Sub clock oscillation stable bit
        constexpr uint32_t MORDY = (1U << 1);  ///< Main clock oscillation stable bit
    }

    /// BSC_PSR Register bits
    namespace bsc_psr_bits {
        constexpr uint32_t BSR = (3 << 0);  ///< Base clock frequency division ratio setting bit
    }

    /// APBC0_PSR Register bits
    namespace apbc0_psr_bits {
        constexpr uint32_t APBC0 = (2 << 0);  ///< APB0 bus clock frequency division ratio setting bit
    }

    /// APBC1_PSR Register bits
    namespace apbc1_psr_bits {
        constexpr uint32_t APBC1EN = (1U << 7);  ///< APB1 clock enable bit
        constexpr uint32_t APBC1RST = (1U << 4);  ///< APB1 bus reset control bit
        constexpr uint32_t APBC1 = (2 << 0);  ///< APB1 bus clock frequency division ratio setting bit
    }

    /// APBC2_PSR Register bits
    namespace apbc2_psr_bits {
        constexpr uint32_t APBC2EN = (1U << 7);  ///< APB2 clock enable bit
        constexpr uint32_t APBC2RST = (1U << 4);  ///< APB2 bus reset control bit
        constexpr uint32_t APBC2 = (2 << 0);  ///< APB2 bus clock frequency division ratio setting bit
    }

    /// SWC_PSR Register bits
    namespace swc_psr_bits {
        constexpr uint32_t TESTB = (1U << 7);  ///< TEST bit
        constexpr uint32_t SWDS = (2 << 0);  ///< Software watchdog clock frequency division ratio setting bit
    }

    /// TTC_PSR Register bits
    namespace ttc_psr_bits {
        constexpr uint32_t TTC = (2 << 0);  ///< Trace clock frequency division ratio setting bit
    }

    /// CSW_TMR Register bits
    namespace csw_tmr_bits {
        constexpr uint32_t SOWT = (3 << 4);  ///< Sub clock stabilization wait time setup bit
        constexpr uint32_t MOWT = (4 << 0);  ///< Main clock stabilization wait time setup bit
    }

    /// PSW_TMR Register bits
    namespace psw_tmr_bits {
        constexpr uint32_t PINC = (1U << 4);  ///< PLL input clock select bit
        constexpr uint32_t POWT = (3 << 0);  ///< PLL clock stabilization wait time setup bit
    }

    /// PLL_CTL1 Register bits
    namespace pll_ctl1_bits {
        constexpr uint32_t PLLK = (4 << 4);  ///< PLL input clock frequency division ratio setting bit
        constexpr uint32_t PLLM = (4 << 0);  ///< PLL VCO clock frequency division ratio setting bit
    }

    /// PLL_CTL2 Register bits
    namespace pll_ctl2_bits {
        constexpr uint32_t PLLN = (6 << 0);  ///< PLL feedback frequency division ratio setting bit
    }

    /// DBWDT_CTL Register bits
    namespace dbwdt_ctl_bits {
        constexpr uint32_t DPHWBE = (1U << 7);  ///< HW-WDG debug mode break bit
        constexpr uint32_t DPSWBE = (1U << 5);  ///< SW-WDG debug mode break bit
    }

    /// INT_ENR Register bits
    namespace int_enr_bits {
        constexpr uint32_t FCSE = (1U << 5);  ///< Anomalous frequency detection interrupt enable bit
        constexpr uint32_t PCSE = (1U << 2);  ///< PLL oscillation stabilization completion interrupt enable bit
        constexpr uint32_t SCSE = (1U << 1);  ///< Sub oscillation stabilization completion interrupt enable bit
        constexpr uint32_t MCSE = (1U << 0);  ///< Main oscillation stabilization completion interrupt enable bit
    }

    /// INT_STR Register bits
    namespace int_str_bits {
        constexpr uint32_t FCSI = (1U << 5);  ///< Anomalous frequency detection interrupt status bit
        constexpr uint32_t PCSI = (1U << 2);  ///< PLL oscillation stabilization completion interrupt status bit
        constexpr uint32_t SCSI = (1U << 1);  ///< Sub oscillation stabilization completion interrupt status bit
        constexpr uint32_t MCSI = (1U << 0);  ///< Main oscillation stabilization completion interrupt status bit
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t FCSC = (1U << 5);  ///< Anomalous frequency detection interrupt cause clear bit
        constexpr uint32_t PCSC = (1U << 2);  ///< PLL oscillation stabilization completion interrupt cause clear bit
        constexpr uint32_t SCSC = (1U << 1);  ///< Sub oscillation stabilization completion interrupt cause clear bit
        constexpr uint32_t MCSC = (1U << 0);  ///< Main oscillation stabilization completion interrupt cause clear bit
    }

    /// RST_STR Register bits
    namespace rst_str_bits {
        constexpr uint32_t SRST = (1U << 8);  ///< Software reset flag
        constexpr uint32_t FCSR = (1U << 7);  ///< Flag for anomalous frequency detection reset
        constexpr uint32_t CSVR = (1U << 6);  ///< Clock failure detection reset flag
        constexpr uint32_t HWDG = (1U << 5);  ///< Hardware watchdog reset flag
        constexpr uint32_t SWDG = (1U << 4);  ///< Software watchdog reset flag
        constexpr uint32_t INITX = (1U << 1);  ///< INITX pin input reset flag
        constexpr uint32_t PONR = (1U << 0);  ///< Power-on reset/low-voltage detection reset flag
    }

    /// STB_CTL Register bits
    namespace stb_ctl_bits {
        constexpr uint32_t KEY = (16 << 16);  ///< Standby mode control write control bit
        constexpr uint32_t SPL = (1U << 4);  ///< Standby pin level setting bit
        constexpr uint32_t DSTM = (1U << 2);  ///< Deep standby mode select bit
        constexpr uint32_t STM = (2 << 0);  ///< Standby mode selection bit
    }

    /// CSV_CTL Register bits
    namespace csv_ctl_bits {
        constexpr uint32_t FCD = (3 << 12);  ///< FCS count cycle setting bits
        constexpr uint32_t FCSRE = (1U << 9);  ///< FCS reset output enable bit
        constexpr uint32_t FCSDE = (1U << 8);  ///< FCS function enable bit
        constexpr uint32_t SCSVE = (1U << 1);  ///< Sub CSV function enable bit
        constexpr uint32_t MCSVE = (1U << 0);  ///< Main CSV function enable bit
    }

    /// CSV_STR Register bits
    namespace csv_str_bits {
        constexpr uint32_t SCMF = (1U << 1);  ///< Sub clock failure detection flag
        constexpr uint32_t MCMF = (1U << 0);  ///< Main clock failure detection flag
    }

}

// ============================================================================
// CRTRIM Peripheral
// ============================================================================

namespace crtrim {
    /// Base addresses
    constexpr uint32_t CRTRIM_BASE = 0x4002E000;

    /// CRTRIM Register structure
    struct Registers {
        volatile uint32_t MCR_PSR;  ///< Offset: 0x00 - High-speed CR oscillation Frequency Division Setup Register
        volatile uint32_t MCR_FTRM;  ///< Offset: 0x04 - High-speed CR oscillation Frequency Trimming Register
        volatile uint32_t MCR_RLR;  ///< Offset: 0x0C - High-Speed CR Oscillation Register Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* CRTRIM = reinterpret_cast<Registers*>(CRTRIM_BASE);

    // Bit definitions
    /// MCR_PSR Register bits
    namespace mcr_psr_bits {
        constexpr uint32_t CSR = (2 << 0);  ///< High-speed CR oscillation frequency division ratio setting bits
    }

    /// MCR_FTRM Register bits
    namespace mcr_ftrm_bits {
        constexpr uint32_t TRD = (10 << 0);  ///< Frequency trimming setup bits
    }

    /// MCR_RLR Register bits
    namespace mcr_rlr_bits {
        constexpr uint32_t TRMLCK = (32 << 0);  ///< Register write-protect bits
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t SWWDT_BASE = 0x40012000;
    constexpr uint32_t HWWDT_BASE = 0x40011000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDOGLOAD;  ///< Offset: 0x00 - Software Watchdog Timer Load Register
        volatile uint32_t WDOGVALUE;  ///< Offset: 0x04 - Software Watchdog Timer Value Register
        volatile uint32_t WDOGCONTROL;  ///< Offset: 0x08 - Software Watchdog Timer Control Register
        volatile uint32_t WDOGINTCLR;  ///< Offset: 0x0C - Software Watchdog Timer Clear Register
        volatile uint32_t WDOGRIS;  ///< Offset: 0x10 - Software Watchdog Timer Interrupt Status Register
        volatile uint32_t WDOGLOCK;  ///< Offset: 0xC00 - Software Watchdog Timer Lock Register
    };

    /// Peripheral instances
    inline Registers* SWWDT = reinterpret_cast<Registers*>(SWWDT_BASE);
    inline Registers* HWWDT = reinterpret_cast<Registers*>(HWWDT_BASE);

    // Bit definitions
    /// WDOGCONTROL Register bits
    namespace wdogcontrol_bits {
        constexpr uint32_t RESEN = (1U << 1);  ///< Reset enable bit of the software watchdog
        constexpr uint32_t INTEN = (1U << 0);  ///< Interrupt and counter enable bit of the software watchdog
    }

    /// WDOGRIS Register bits
    namespace wdogris_bits {
        constexpr uint32_t RIS = (1U << 0);  ///< Software watchdog interrupt status bit
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t DTIM_BASE = 0x40015000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIMER1LOAD;  ///< Offset: 0x00 - Load Register
        volatile uint32_t TIMER1VALUE;  ///< Offset: 0x04 - Value Register
        volatile uint32_t TIMER1CONTROL;  ///< Offset: 0x08 - Control Register
        volatile uint32_t TIMER1INTCLR;  ///< Offset: 0x0C - Interrupt Clear Register
        volatile uint32_t TIMER1RIS;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t TIMER1MIS;  ///< Offset: 0x14 - Masked Interrupt Status Register
        volatile uint32_t TIMER1BGLOAD;  ///< Offset: 0x18 - Background Load Register
        volatile uint32_t TIMER2LOAD;  ///< Offset: 0x20 - Load Register
        volatile uint32_t TIMER2VALUE;  ///< Offset: 0x24 - Value Register
        volatile uint32_t TIMER2CONTROL;  ///< Offset: 0x28 - Control Register
        volatile uint32_t TIMER2INTCLR;  ///< Offset: 0x2C - Interrupt Clear Register
        volatile uint32_t TIMER2RIS;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t TIMER2MIS;  ///< Offset: 0x34 - Masked Interrupt Status Register
        volatile uint32_t TIMER2BGLOAD;  ///< Offset: 0x38 - Background Load Register
    };

    /// Peripheral instances
    inline Registers* DTIM = reinterpret_cast<Registers*>(DTIM_BASE);

    // Bit definitions
    /// TIMER1CONTROL Register bits
    namespace timer1control_bits {
        constexpr uint32_t TimerEn = (1U << 7);  ///< Enable bit
        constexpr uint32_t TimerMode = (1U << 6);  ///< Mode bit
        constexpr uint32_t IntEnable = (1U << 5);  ///< Interrupt enable bit
        constexpr uint32_t TimerPre = (2 << 2);  ///< Prescale bits
        constexpr uint32_t TimerSize = (1U << 1);  ///< Counter size bit
        constexpr uint32_t OneShot = (1U << 0);  ///< One-shot mode bit
    }

    /// TIMER1RIS Register bits
    namespace timer1ris_bits {
        constexpr uint32_t TIMER1RIS = (1U << 0);  ///< Interrupt Status Register bit
    }

    /// TIMER1MIS Register bits
    namespace timer1mis_bits {
        constexpr uint32_t TIMER1MIS = (1U << 0);  ///< Masked Interrupt Status bit
    }

}

// ============================================================================
// BTIOSEL03 Peripheral
// ============================================================================

namespace btiosel03 {
    /// Base addresses
    constexpr uint32_t BTIOSEL03_BASE = 0x40025100;

    /// BTIOSEL03 Register structure
    struct Registers {
        volatile uint32_t BTSEL0123;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSEL03 = reinterpret_cast<Registers*>(BTIOSEL03_BASE);

    // Bit definitions
    /// BTSEL0123 Register bits
    namespace btsel0123_bits {
        constexpr uint32_t SEL23_ = (4 << 12);  ///< I/O select bits for Ch.2/Ch.3
        constexpr uint32_t SEL01_ = (4 << 8);  ///< I/O select bits for Ch.0/Ch.1
    }

}

// ============================================================================
// BTIOSEL47 Peripheral
// ============================================================================

namespace btiosel47 {
    /// Base addresses
    constexpr uint32_t BTIOSEL47_BASE = 0x40025300;

    /// BTIOSEL47 Register structure
    struct Registers {
        volatile uint32_t BTSEL4567;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSEL47 = reinterpret_cast<Registers*>(BTIOSEL47_BASE);

    // Bit definitions
    /// BTSEL4567 Register bits
    namespace btsel4567_bits {
        constexpr uint32_t SEL67_ = (4 << 12);  ///< I/O select bits for Ch.6/Ch.7
        constexpr uint32_t SEL45_ = (4 << 8);  ///< I/O select bits for Ch.4/Ch.5
    }

}

// ============================================================================
// SBSSR Peripheral
// ============================================================================

namespace sbssr {
    /// Base addresses
    constexpr uint32_t SBSSR_BASE = 0x40025F00;

    /// SBSSR Register structure
    struct Registers {
        volatile uint32_t BTSSSR;  ///< Offset: 0xFC - Software-based Simultaneous Startup Register
    };

    /// Peripheral instances
    inline Registers* SBSSR = reinterpret_cast<Registers*>(SBSSR_BASE);

    // Bit definitions
    /// BTSSSR Register bits
    namespace btsssr_bits {
        constexpr uint32_t SSSR15 = (1U << 15);  ///< Bit15 of BTSSSR
        constexpr uint32_t SSSR14 = (1U << 14);  ///< Bit14 of BTSSSR
        constexpr uint32_t SSSR13 = (1U << 13);  ///< Bit13 of BTSSSR
        constexpr uint32_t SSSR12 = (1U << 12);  ///< Bit12 of BTSSSR
        constexpr uint32_t SSSR11 = (1U << 11);  ///< Bit11 of BTSSSR
        constexpr uint32_t SSSR10 = (1U << 10);  ///< Bit10 of BTSSSR
        constexpr uint32_t SSSR9 = (1U << 9);  ///< Bit9 of BTSSSR
        constexpr uint32_t SSSR8 = (1U << 8);  ///< Bit8 of BTSSSR
        constexpr uint32_t SSSR7 = (1U << 7);  ///< Bit7 of BTSSSR
        constexpr uint32_t SSSR6 = (1U << 6);  ///< Bit6 of BTSSSR
        constexpr uint32_t SSSR5 = (1U << 5);  ///< Bit5 of BTSSSR
        constexpr uint32_t SSSR4 = (1U << 4);  ///< Bit4 of BTSSSR
        constexpr uint32_t SSSR3 = (1U << 3);  ///< Bit3 of BTSSSR
        constexpr uint32_t SSSR2 = (1U << 2);  ///< Bit2 of BTSSSR
        constexpr uint32_t SSSR1 = (1U << 1);  ///< Bit1 of BTSSSR
        constexpr uint32_t SSSR0 = (1U << 0);  ///< Bit0 of BTSSSR
    }

}

// ============================================================================
// BT0 Peripheral
// ============================================================================

namespace bt0 {
    /// Base addresses
    constexpr uint32_t BT0_BASE = 0x40025000;

    /// BT0 Register structure
    struct Registers {
        volatile uint32_t PWM_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PWM_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PWM_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PWM_PCSR;  ///< Offset: 0x00 - PWM Cycle Set Register
        volatile uint32_t PWM_PDUT;  ///< Offset: 0x04 - PWM Duty Set Register
        volatile uint32_t PWM_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t PPG_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PPG_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PPG_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PPG_PRLL;  ///< Offset: 0x00 - LOW Width Reload Register
        volatile uint32_t PPG_PRLH;  ///< Offset: 0x04 - HIGH Width Reload Register
        volatile uint32_t PPG_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t RT_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t RT_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t RT_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t RT_PCSR;  ///< Offset: 0x00 - PWM Cycle Set Register
        volatile uint32_t RT_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t PWC_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PWC_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PWC_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PWC_DTBF;  ///< Offset: 0x04 - Data Buffer Register
    };

    /// Peripheral instances
    inline Registers* BT0 = reinterpret_cast<Registers*>(BT0_BASE);

    // Bit definitions
    /// PWM_TMCR Register bits
    namespace pwm_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t RTGEN = (1U << 11);  ///< Restart enable bit
        constexpr uint32_t PMSK = (1U << 10);  ///< Pulse output mask bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Count operation enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// PWM_TMCR2 Register bits
    namespace pwm_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PWM_STC Register bits
    namespace pwm_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t DTIE = (1U << 5);  ///< Duty match interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t DTIR = (1U << 1);  ///< Duty match interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// PPG_TMCR Register bits
    namespace ppg_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t RTGEN = (1U << 11);  ///< Restart enable bit
        constexpr uint32_t PMSK = (1U << 10);  ///< Pulse output mask bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Count operation enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// PPG_TMCR2 Register bits
    namespace ppg_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 1);  ///< Count clock selection bit
    }

    /// PPG_STC Register bits
    namespace ppg_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// RT_TMCR Register bits
    namespace rt_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t T32 = (1U << 7);  ///< 32-bit timer selection bit
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Timer enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// RT_TMCR2 Register bits
    namespace rt_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// RT_STC Register bits
    namespace rt_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// PWC_TMCR Register bits
    namespace pwc_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t EGS = (3 << 8);  ///< Measurement edge selection bits
        constexpr uint32_t T32 = (1U << 7);  ///< 32-bit timer selection bit
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Timer enable bit
    }

    /// PWC_TMCR2 Register bits
    namespace pwc_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PWC_STC Register bits
    namespace pwc_stc_bits {
        constexpr uint32_t ERR = (1U << 7);  ///< Error flag bit
        constexpr uint32_t EDIE = (1U << 6);  ///< Measurement completion interrupt request enable bit
        constexpr uint32_t OVIE = (1U << 4);  ///< Overflow interrupt request enable bit
        constexpr uint32_t EDIR = (1U << 2);  ///< Measurement completion interrupt request bit
        constexpr uint32_t OVIR = (1U << 0);  ///< Overflow interrupt request bit
    }

}

// ============================================================================
// BT1 Peripheral
// ============================================================================

namespace bt1 {
    /// Base addresses
    constexpr uint32_t BT1_BASE = 0x40025040;

    /// BT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT1 = reinterpret_cast<Registers*>(BT1_BASE);

}

// ============================================================================
// BT2 Peripheral
// ============================================================================

namespace bt2 {
    /// Base addresses
    constexpr uint32_t BT2_BASE = 0x40025080;

    /// BT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT2 = reinterpret_cast<Registers*>(BT2_BASE);

}

// ============================================================================
// BT3 Peripheral
// ============================================================================

namespace bt3 {
    /// Base addresses
    constexpr uint32_t BT3_BASE = 0x400250C0;

    /// BT3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT3 = reinterpret_cast<Registers*>(BT3_BASE);

}

// ============================================================================
// BT4 Peripheral
// ============================================================================

namespace bt4 {
    /// Base addresses
    constexpr uint32_t BT4_BASE = 0x40025200;

    /// BT4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT4 = reinterpret_cast<Registers*>(BT4_BASE);

}

// ============================================================================
// BT5 Peripheral
// ============================================================================

namespace bt5 {
    /// Base addresses
    constexpr uint32_t BT5_BASE = 0x40025240;

    /// BT5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT5 = reinterpret_cast<Registers*>(BT5_BASE);

}

// ============================================================================
// BT6 Peripheral
// ============================================================================

namespace bt6 {
    /// Base addresses
    constexpr uint32_t BT6_BASE = 0x40025280;

    /// BT6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT6 = reinterpret_cast<Registers*>(BT6_BASE);

}

// ============================================================================
// BT7 Peripheral
// ============================================================================

namespace bt7 {
    /// Base addresses
    constexpr uint32_t BT7_BASE = 0x400252C0;

    /// BT7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT7 = reinterpret_cast<Registers*>(BT7_BASE);

}

// ============================================================================
// WC Peripheral
// ============================================================================

namespace wc {
    /// Base addresses
    constexpr uint32_t WC_BASE = 0x4003A000;

    /// WC Register structure
    struct Registers {
        volatile uint32_t WCRD;  ///< Offset: 0x00 - Watch Counter Read Register
        volatile uint32_t WCRL;  ///< Offset: 0x01 - Watch Counter Reload Register
        volatile uint32_t WCCR;  ///< Offset: 0x02 - Watch Counter Control Register
        volatile uint32_t CLK_SEL;  ///< Offset: 0x10 - Clock Selection Register
        volatile uint32_t CLK_EN;  ///< Offset: 0x14 - Division Clock Enable Register
    };

    /// Peripheral instances
    inline Registers* WC = reinterpret_cast<Registers*>(WC_BASE);

    // Bit definitions
    /// WCRD Register bits
    namespace wcrd_bits {
        constexpr uint32_t CTR = (6 << 0);  ///< counter value
    }

    /// WCRL Register bits
    namespace wcrl_bits {
        constexpr uint32_t RLC = (6 << 0);  ///< reload value
    }

    /// WCCR Register bits
    namespace wccr_bits {
        constexpr uint32_t WCEN = (1U << 7);  ///< Watch counter operation enable bit
        constexpr uint32_t WCOP = (1U << 6);  ///< Watch counter operating state flag
        constexpr uint32_t CS = (2 << 2);  ///< Count clock select bits
        constexpr uint32_t WCIE = (1U << 1);  ///< Interrupt request enable bit
        constexpr uint32_t WCIF = (1U << 0);  ///< Interrupt request flag bit
    }

    /// CLK_SEL Register bits
    namespace clk_sel_bits {
        constexpr uint32_t SEL_OUT = (1U << 8);  ///< Output clock selection bit
        constexpr uint32_t SEL_IN = (1U << 0);  ///< Input clock selection bit
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN_R = (1U << 1);  ///< Division clock enable read bit
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Division clock enable bit
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x40027000;
    constexpr uint32_t ADC1_BASE = 0x40027100;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCR;  ///< Offset: 0x01 - A/D Control Register
        volatile uint32_t ADSR;  ///< Offset: 0x00 - A/D Status Register
        volatile uint32_t SCCR;  ///< Offset: 0x09 - Scan Conversion Control Register
        volatile uint32_t SFNS;  ///< Offset: 0x08 - Scan Conversion FIFO Stage Count Setup Register
        volatile uint32_t SCFD;  ///< Offset: 0x0C - Scan Conversion FIFO Data Register
        volatile uint32_t SCIS3;  ///< Offset: 0x11 - Scan Conversion Input Selection Register 3
        volatile uint32_t SCIS2;  ///< Offset: 0x10 - Scan Conversion Input Selection Register 2
        volatile uint32_t SCIS1;  ///< Offset: 0x15 - Scan Conversion Input Selection Register 1
        volatile uint32_t SCIS0;  ///< Offset: 0x14 - Scan Conversion Input Selection Register 0
        volatile uint32_t PFNS;  ///< Offset: 0x18 - Priority Conversion FIFO Stage Count Setup Register
        volatile uint32_t PCCR;  ///< Offset: 0x19 - Priority Conversion Control Register
        volatile uint32_t PCFD;  ///< Offset: 0x1C - Priority Conversion FIFO Data Register
        volatile uint32_t PCIS;  ///< Offset: 0x20 - Priority Conversion Input Selection Register
        volatile uint32_t CMPCR;  ///< Offset: 0x24 - A/D Comparison Control Register
        volatile uint32_t CMPD;  ///< Offset: 0x26 - A/D Comparison Value Setup Register
        volatile uint32_t ADSS3;  ///< Offset: 0x29 - Sampling Time Selection Register 3
        volatile uint32_t ADSS2;  ///< Offset: 0x28 - Sampling Time Selection Register 2
        volatile uint32_t ADSS1;  ///< Offset: 0x2D - Sampling Time Selection Register 1
        volatile uint32_t ADSS0;  ///< Offset: 0x2C - Sampling Time Selection Register 0
        volatile uint32_t ADST1;  ///< Offset: 0x30 - Sampling Time Setup Register 1
        volatile uint32_t ADST0;  ///< Offset: 0x31 - Sampling Time Setup Register 0
        volatile uint32_t ADCT;  ///< Offset: 0x34 - Comparison Time Setup Register
        volatile uint32_t PRTSL;  ///< Offset: 0x38 - Priority Conversion Timer Trigger Selection Register
        volatile uint32_t SCTSL;  ///< Offset: 0x39 - Scan Conversion Timer Trigger Selection Register
        volatile uint32_t ADCEN;  ///< Offset: 0x3C - A/D Operation Enable Setup Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// ADCR Register bits
    namespace adcr_bits {
        constexpr uint32_t SCIF = (1U << 7);  ///< Scan conversion interrupt request bit
        constexpr uint32_t PCIF = (1U << 6);  ///< Priority conversion interrupt request bit
        constexpr uint32_t CMPIF = (1U << 5);  ///< Conversion result comparison interrupt request bit
        constexpr uint32_t SCIE = (1U << 3);  ///< Scan conversion interrupt enable bit
        constexpr uint32_t PCIE = (1U << 2);  ///< Priority conversion interrupt enable bit
        constexpr uint32_t CMPIE = (1U << 1);  ///< Conversion result comparison interrupt enable bit
        constexpr uint32_t OVRIE = (1U << 0);  ///< FIFO overrun interrupt enable bit
    }

    /// ADSR Register bits
    namespace adsr_bits {
        constexpr uint32_t ADSTP = (1U << 7);  ///< A/D conversion forced stop bit
        constexpr uint32_t FDAS = (1U << 6);  ///< FIFO data placement selection bit
        constexpr uint32_t PCNS = (1U << 2);  ///< Priority conversion pending flag
        constexpr uint32_t PCS = (1U << 1);  ///< Priority conversion status flag
        constexpr uint32_t SCS = (1U << 0);  ///< Scan conversion status flag
    }

    /// SCCR Register bits
    namespace sccr_bits {
        constexpr uint32_t SEMP = (1U << 7);  ///< Scan conversion FIFO empty bit
        constexpr uint32_t SFUL = (1U << 6);  ///< Scan conversion FIFO full bit
        constexpr uint32_t SOVR = (1U << 5);  ///< Scan conversion overrun flag
        constexpr uint32_t SFCLR = (1U << 4);  ///< Scan conversion FIFO clear bit
        constexpr uint32_t RPT = (1U << 2);  ///< Scan conversion repeat bit
        constexpr uint32_t SHEN = (1U << 1);  ///< Scan conversion timer start enable bit
        constexpr uint32_t SSTR = (1U << 0);  ///< Scan conversion start bit
    }

    /// SFNS Register bits
    namespace sfns_bits {
        constexpr uint32_t SFS = (4 << 0);  ///< Scan conversion FIFO stage count setting bit
    }

    /// SCFD Register bits
    namespace scfd_bits {
        constexpr uint32_t SD = (12 << 20);  ///< Scan conversion result
        constexpr uint32_t INVL = (1U << 12);  ///< A/D conversion result disable bit
        constexpr uint32_t RS = (2 << 8);  ///< Scan conversion start factor
        constexpr uint32_t CS = (5 << 0);  ///< Conversion input channel bits
    }

    /// SCIS3 Register bits
    namespace scis3_bits {
        constexpr uint32_t AN31 = (1U << 7);  ///< Bit7 of SCIS3
        constexpr uint32_t AN30 = (1U << 6);  ///< Bit6 of SCIS3
        constexpr uint32_t AN29 = (1U << 5);  ///< Bit5 of SCIS3
        constexpr uint32_t AN28 = (1U << 4);  ///< Bit4 of SCIS3
        constexpr uint32_t AN27 = (1U << 3);  ///< Bit3 of SCIS3
        constexpr uint32_t AN26 = (1U << 2);  ///< Bit2 of SCIS3
        constexpr uint32_t AN25 = (1U << 1);  ///< Bit1 of SCIS3
        constexpr uint32_t AN24 = (1U << 0);  ///< Bit0 of SCIS3
    }

    /// SCIS2 Register bits
    namespace scis2_bits {
        constexpr uint32_t AN23 = (1U << 7);  ///< Bit7 of SCIS2
        constexpr uint32_t AN22 = (1U << 6);  ///< Bit6 of SCIS2
        constexpr uint32_t AN21 = (1U << 5);  ///< Bit5 of SCIS2
        constexpr uint32_t AN20 = (1U << 4);  ///< Bit4 of SCIS2
        constexpr uint32_t AN19 = (1U << 3);  ///< Bit3 of SCIS2
        constexpr uint32_t AN18 = (1U << 2);  ///< Bit2 of SCIS2
        constexpr uint32_t AN17 = (1U << 1);  ///< Bit1 of SCIS2
        constexpr uint32_t AN16 = (1U << 0);  ///< Bit0 of SCIS2
    }

    /// SCIS1 Register bits
    namespace scis1_bits {
        constexpr uint32_t AN15 = (1U << 7);  ///< Bit7 of SCIS1
        constexpr uint32_t AN14 = (1U << 6);  ///< Bit6 of SCIS1
        constexpr uint32_t AN13 = (1U << 5);  ///< Bit5 of SCIS1
        constexpr uint32_t AN12 = (1U << 4);  ///< Bit4 of SCIS1
        constexpr uint32_t AN11 = (1U << 3);  ///< Bit3 of SCIS1
        constexpr uint32_t AN10 = (1U << 2);  ///< Bit2 of SCIS1
        constexpr uint32_t AN9 = (1U << 1);  ///< Bit1 of SCIS1
        constexpr uint32_t AN8 = (1U << 0);  ///< Bit0 of SCIS1
    }

    /// SCIS0 Register bits
    namespace scis0_bits {
        constexpr uint32_t AN7 = (1U << 7);  ///< Bit7 of SCIS0
        constexpr uint32_t AN6 = (1U << 6);  ///< Bit6 of SCIS0
        constexpr uint32_t AN5 = (1U << 5);  ///< Bit5 of SCIS0
        constexpr uint32_t AN4 = (1U << 4);  ///< Bit4 of SCIS0
        constexpr uint32_t AN3 = (1U << 3);  ///< Bit3 of SCIS0
        constexpr uint32_t AN2 = (1U << 2);  ///< Bit2 of SCIS0
        constexpr uint32_t AN1 = (1U << 1);  ///< Bit1 of SCIS0
        constexpr uint32_t AN0 = (1U << 0);  ///< Bit0 of SCIS0
    }

    /// PFNS Register bits
    namespace pfns_bits {
        constexpr uint32_t TEST = (2 << 4);  ///< Test bits
        constexpr uint32_t PFS = (2 << 0);  ///< Priority conversion FIFO stage count setting bits
    }

    /// PCCR Register bits
    namespace pccr_bits {
        constexpr uint32_t PEMP = (1U << 7);  ///< Priority conversion FIFO empty bit
        constexpr uint32_t PFUL = (1U << 6);  ///< Priority conversion FIFO full bit
        constexpr uint32_t POVR = (1U << 5);  ///< Priority conversion overrun flag
        constexpr uint32_t PFCLR = (1U << 4);  ///< Priority conversion FIFO clear bit
        constexpr uint32_t ESCE = (1U << 3);  ///< External trigger analog input selection bit
        constexpr uint32_t PEEN = (1U << 2);  ///< Priority conversion external start enable bit
        constexpr uint32_t PHEN = (1U << 1);  ///< Priority conversion timer start enable bit
        constexpr uint32_t PSTR = (1U << 0);  ///< Priority conversion start bit
    }

    /// PCFD Register bits
    namespace pcfd_bits {
        constexpr uint32_t PD = (12 << 20);  ///< Priority conversion result
        constexpr uint32_t INVL = (1U << 12);  ///< A/D conversion result disable bit
        constexpr uint32_t RS = (2 << 8);  ///< Scan conversion start factor
        constexpr uint32_t PC = (5 << 0);  ///< Conversion input channel bits
    }

    /// PCIS Register bits
    namespace pcis_bits {
        constexpr uint32_t P2A = (5 << 3);  ///< Priority level 2 analog input selection
        constexpr uint32_t P1A = (3 << 0);  ///< Priority level 1 analog input selection
    }

    /// CMPCR Register bits
    namespace cmpcr_bits {
        constexpr uint32_t CMPEN = (1U << 7);  ///< Conversion result comparison function operation enable bit
        constexpr uint32_t CMD = (2 << 5);  ///< Comparison mode 1
        constexpr uint32_t CCH = (5 << 0);  ///< Comparison mode 0
    }

    /// CMPD Register bits
    namespace cmpd_bits {
        constexpr uint32_t CMAD = (10 << 6);  ///< A/D conversion result value setting bits
    }

    /// ADSS3 Register bits
    namespace adss3_bits {
        constexpr uint32_t TS31 = (1U << 7);  ///< Bit7 of ADSS3
        constexpr uint32_t TS30 = (1U << 6);  ///< Bit6 of ADSS3
        constexpr uint32_t TS29 = (1U << 5);  ///< Bit5 of ADSS3
        constexpr uint32_t TS28 = (1U << 4);  ///< Bit4 of ADSS3
        constexpr uint32_t TS27 = (1U << 3);  ///< Bit3 of ADSS3
        constexpr uint32_t TS26 = (1U << 2);  ///< Bit2 of ADSS3
        constexpr uint32_t TS25 = (1U << 1);  ///< Bit1 of ADSS3
        constexpr uint32_t TS24 = (1U << 0);  ///< Bit0 of ADSS3
    }

    /// ADSS2 Register bits
    namespace adss2_bits {
        constexpr uint32_t TS23 = (1U << 7);  ///< Bit7 of ADSS2
        constexpr uint32_t TS22 = (1U << 6);  ///< Bit6 of ADSS2
        constexpr uint32_t TS21 = (1U << 5);  ///< Bit5 of ADSS2
        constexpr uint32_t TS20 = (1U << 4);  ///< Bit4 of ADSS2
        constexpr uint32_t TS19 = (1U << 3);  ///< Bit3 of ADSS2
        constexpr uint32_t TS18 = (1U << 2);  ///< Bit2 of ADSS2
        constexpr uint32_t TS17 = (1U << 1);  ///< Bit1 of ADSS2
        constexpr uint32_t TS16 = (1U << 0);  ///< Bit0 of ADSS2
    }

    /// ADSS1 Register bits
    namespace adss1_bits {
        constexpr uint32_t TS15 = (1U << 7);  ///< Bit7 of ADSS1
        constexpr uint32_t TS14 = (1U << 6);  ///< Bit6 of ADSS1
        constexpr uint32_t TS13 = (1U << 5);  ///< Bit5 of ADSS1
        constexpr uint32_t TS12 = (1U << 4);  ///< Bit4 of ADSS1
        constexpr uint32_t TS11 = (1U << 3);  ///< Bit3 of ADSS1
        constexpr uint32_t TS10 = (1U << 2);  ///< Bit2 of ADSS1
        constexpr uint32_t TS9 = (1U << 1);  ///< Bit1 of ADSS1
        constexpr uint32_t TS8 = (1U << 0);  ///< Bit0 of ADSS1
    }

    /// ADSS0 Register bits
    namespace adss0_bits {
        constexpr uint32_t TS7 = (1U << 7);  ///< Bit7 of ADSS0
        constexpr uint32_t TS6 = (1U << 6);  ///< Bit6 of ADSS0
        constexpr uint32_t TS5 = (1U << 5);  ///< Bit5 of ADSS0
        constexpr uint32_t TS4 = (1U << 4);  ///< Bit4 of ADSS0
        constexpr uint32_t TS3 = (1U << 3);  ///< Bit3 of ADSS0
        constexpr uint32_t TS2 = (1U << 2);  ///< Bit2 of ADSS0
        constexpr uint32_t TS1 = (1U << 1);  ///< Bit1 of ADSS0
        constexpr uint32_t TS0 = (1U << 0);  ///< Bit0 of ADSS0
    }

    /// ADST1 Register bits
    namespace adst1_bits {
        constexpr uint32_t STX1 = (3 << 5);  ///< Sampling time N times setting bits
        constexpr uint32_t ST = (5 << 0);  ///< Sampling time setting bits
    }

    /// ADST0 Register bits
    namespace adst0_bits {
        constexpr uint32_t STX0 = (3 << 5);  ///< Sampling time N times setting bits
        constexpr uint32_t ST = (5 << 0);  ///< Sampling time setting bits
    }

    /// ADCT Register bits
    namespace adct_bits {
        constexpr uint32_t CT = (8 << 0);  ///< Compare clock frequency division ratio setting bits
    }

    /// PRTSL Register bits
    namespace prtsl_bits {
        constexpr uint32_t PRTSL = (4 << 0);  ///< Priority conversion timer trigger selection bit
    }

    /// SCTSL Register bits
    namespace sctsl_bits {
        constexpr uint32_t SCTSL = (4 << 0);  ///< Scan conversion timer trigger selection bit
    }

    /// ADCEN Register bits
    namespace adcen_bits {
        constexpr uint32_t ENBLTIME = (8 << 8);  ///< Basic cycle selection bit
        constexpr uint32_t READY = (1U << 1);  ///< A/D operation enable state bit
        constexpr uint32_t ENBL = (1U << 0);  ///< A/D operation enable bit
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40030000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t ENIR;  ///< Offset: 0x00 - Enable Interrupt Request Register
        volatile uint32_t EIRR;  ///< Offset: 0x04 - External Interrupt Request Register
        volatile uint32_t EICL;  ///< Offset: 0x08 - External Interrupt Clear Register
        volatile uint32_t ELVR;  ///< Offset: 0x0C - External Interrupt Level Register
        volatile uint32_t NMIRR;  ///< Offset: 0x14 - Non Maskable Interrupt Request Register
        volatile uint32_t NMICL;  ///< Offset: 0x18 - Non Maskable Interrupt Clear Register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// ENIR Register bits
    namespace enir_bits {
        constexpr uint32_t EN15 = (1U << 15);  ///< Bit15 of ENIR
        constexpr uint32_t EN14 = (1U << 14);  ///< Bit14 of ENIR
        constexpr uint32_t EN13 = (1U << 13);  ///< Bit13 of ENIR
        constexpr uint32_t EN12 = (1U << 12);  ///< Bit12 of ENIR
        constexpr uint32_t EN11 = (1U << 11);  ///< Bit11 of ENIR
        constexpr uint32_t EN10 = (1U << 10);  ///< Bit10 of ENIR
        constexpr uint32_t EN9 = (1U << 9);  ///< Bit9 of ENIR
        constexpr uint32_t EN8 = (1U << 8);  ///< Bit8 of ENIR
        constexpr uint32_t EN7 = (1U << 7);  ///< Bit7 of ENIR
        constexpr uint32_t EN6 = (1U << 6);  ///< Bit6 of ENIR
        constexpr uint32_t EN5 = (1U << 5);  ///< Bit5 of ENIR
        constexpr uint32_t EN4 = (1U << 4);  ///< Bit4 of ENIR
        constexpr uint32_t EN3 = (1U << 3);  ///< Bit3 of ENIR
        constexpr uint32_t EN2 = (1U << 2);  ///< Bit2 of ENIR
        constexpr uint32_t EN1 = (1U << 1);  ///< Bit1 of ENIR
        constexpr uint32_t EN0 = (1U << 0);  ///< Bit0 of ENIR
    }

    /// EIRR Register bits
    namespace eirr_bits {
        constexpr uint32_t ER15 = (1U << 15);  ///< Bit15 of EIRR
        constexpr uint32_t ER14 = (1U << 14);  ///< Bit14 of EIRR
        constexpr uint32_t ER13 = (1U << 13);  ///< Bit13 of EIRR
        constexpr uint32_t ER12 = (1U << 12);  ///< Bit12 of EIRR
        constexpr uint32_t ER11 = (1U << 11);  ///< Bit11 of EIRR
        constexpr uint32_t ER10 = (1U << 10);  ///< Bit10 of EIRR
        constexpr uint32_t ER9 = (1U << 9);  ///< Bit9 of EIRR
        constexpr uint32_t ER8 = (1U << 8);  ///< Bit8 of EIRR
        constexpr uint32_t ER7 = (1U << 7);  ///< Bit7 of EIRR
        constexpr uint32_t ER6 = (1U << 6);  ///< Bit6 of EIRR
        constexpr uint32_t ER5 = (1U << 5);  ///< Bit5 of EIRR
        constexpr uint32_t ER4 = (1U << 4);  ///< Bit4 of EIRR
        constexpr uint32_t ER3 = (1U << 3);  ///< Bit3 of EIRR
        constexpr uint32_t ER2 = (1U << 2);  ///< Bit2 of EIRR
        constexpr uint32_t ER1 = (1U << 1);  ///< Bit1 of EIRR
        constexpr uint32_t ER0 = (1U << 0);  ///< Bit0 of EIRR
    }

    /// EICL Register bits
    namespace eicl_bits {
        constexpr uint32_t ECL15 = (1U << 15);  ///< Bit15 of EICL
        constexpr uint32_t ECL14 = (1U << 14);  ///< Bit14 of EICL
        constexpr uint32_t ECL13 = (1U << 13);  ///< Bit13 of EICL
        constexpr uint32_t ECL12 = (1U << 12);  ///< Bit12 of EICL
        constexpr uint32_t ECL11 = (1U << 11);  ///< Bit11 of EICL
        constexpr uint32_t ECL10 = (1U << 10);  ///< Bit10 of EICL
        constexpr uint32_t ECL9 = (1U << 9);  ///< Bit9 of EICL
        constexpr uint32_t ECL8 = (1U << 8);  ///< Bit8 of EICL
        constexpr uint32_t ECL7 = (1U << 7);  ///< Bit7 of EICL
        constexpr uint32_t ECL6 = (1U << 6);  ///< Bit6 of EICL
        constexpr uint32_t ECL5 = (1U << 5);  ///< Bit5 of EICL
        constexpr uint32_t ECL4 = (1U << 4);  ///< Bit4 of EICL
        constexpr uint32_t ECL3 = (1U << 3);  ///< Bit3 of EICL
        constexpr uint32_t ECL2 = (1U << 2);  ///< Bit2 of EICL
        constexpr uint32_t ECL1 = (1U << 1);  ///< Bit1 of EICL
        constexpr uint32_t ECL0 = (1U << 0);  ///< Bit0 of EICL
    }

    /// ELVR Register bits
    namespace elvr_bits {
        constexpr uint32_t LB15 = (1U << 31);  ///< Bit31 of ELVR
        constexpr uint32_t LA15 = (1U << 30);  ///< Bit30 of ELVR
        constexpr uint32_t LB14 = (1U << 29);  ///< Bit29 of ELVR
        constexpr uint32_t LA14 = (1U << 28);  ///< Bit28 of ELVR
        constexpr uint32_t LB13 = (1U << 27);  ///< Bit27 of ELVR
        constexpr uint32_t LA13 = (1U << 26);  ///< Bit26 of ELVR
        constexpr uint32_t LB12 = (1U << 25);  ///< Bit25 of ELVR
        constexpr uint32_t LA12 = (1U << 24);  ///< Bit24 of ELVR
        constexpr uint32_t LB11 = (1U << 23);  ///< Bit23 of ELVR
        constexpr uint32_t LA11 = (1U << 22);  ///< Bit22 of ELVR
        constexpr uint32_t LB10 = (1U << 21);  ///< Bit21 of ELVR
        constexpr uint32_t LA10 = (1U << 20);  ///< Bit20 of ELVR
        constexpr uint32_t LB9 = (1U << 19);  ///< Bit19 of ELVR
        constexpr uint32_t LA9 = (1U << 18);  ///< Bit18 of ELVR
        constexpr uint32_t LB8 = (1U << 17);  ///< Bit17 of ELVR
        constexpr uint32_t LA8 = (1U << 16);  ///< Bit16 of ELVR
        constexpr uint32_t LB7 = (1U << 15);  ///< Bit15 of ELVR
        constexpr uint32_t LA7 = (1U << 14);  ///< Bit14 of ELVR
        constexpr uint32_t LB6 = (1U << 13);  ///< Bit13 of ELVR
        constexpr uint32_t LA6 = (1U << 12);  ///< Bit12 of ELVR
        constexpr uint32_t LB5 = (1U << 11);  ///< Bit11 of ELVR
        constexpr uint32_t LA5 = (1U << 10);  ///< Bit10 of ELVR
        constexpr uint32_t LB4 = (1U << 9);  ///< Bit9 of ELVR
        constexpr uint32_t LA4 = (1U << 8);  ///< Bit8 of ELVR
        constexpr uint32_t LB3 = (1U << 7);  ///< Bit7 of ELVR
        constexpr uint32_t LA3 = (1U << 6);  ///< Bit6 of ELVR
        constexpr uint32_t LB2 = (1U << 5);  ///< Bit5 of ELVR
        constexpr uint32_t LA2 = (1U << 4);  ///< Bit4 of ELVR
        constexpr uint32_t LB1 = (1U << 3);  ///< Bit3 of ELVR
        constexpr uint32_t LA1 = (1U << 2);  ///< Bit2 of ELVR
        constexpr uint32_t LB0 = (1U << 1);  ///< Bit1 of ELVR
        constexpr uint32_t LA0 = (1U << 0);  ///< Bit0 of ELVR
    }

    /// NMIRR Register bits
    namespace nmirr_bits {
        constexpr uint32_t NR = (1U << 0);  ///< NMI interrupt request detection bit
    }

    /// NMICL Register bits
    namespace nmicl_bits {
        constexpr uint32_t NCL = (1U << 0);  ///< NMI interrupt cause clear bit
    }

}

// ============================================================================
// INTREQ Peripheral
// ============================================================================

namespace intreq {
    /// Base addresses
    constexpr uint32_t INTREQ_BASE = 0x40031000;

    /// INTREQ Register structure
    struct Registers {
        volatile uint32_t DRQSEL;  ///< Offset: 0x00 - DMA Request Selection Register
        volatile uint32_t IRQCMODE;  ///< Offset: 0x0C - Interrupt Factor Vector Relocate Setting Register
        volatile uint32_t EXC02MON;  ///< Offset: 0x10 - EXC02 batch read register
        volatile uint32_t IRQ00MON;  ///< Offset: 0x14 - IRQ00 Batch Read Register
        volatile uint32_t IRQ01MON;  ///< Offset: 0x18 - IRQ01 Batch Read Register
        volatile uint32_t IRQ02MON;  ///< Offset: 0x1C - IRQ02 Batch Read Register
        volatile uint32_t IRQ04MON;  ///< Offset: 0x24 - IRQ04 Batch Read Register
        volatile uint32_t IRQ05MON;  ///< Offset: 0x28 - IRQ05 Batch Read Register
        volatile uint32_t IRQ06MON;  ///< Offset: 0x2C - IRQ06 Batch Read Register
        volatile uint32_t IRQ07MON;  ///< Offset: 0x30 - IRQ07 Batch Read Register
        volatile uint32_t IRQ08MON;  ///< Offset: 0x34 - IRQ08 Batch Read Register
        volatile uint32_t IRQ09MON;  ///< Offset: 0x38 - IRQ09 Batch Read Register
        volatile uint32_t IRQ10MON;  ///< Offset: 0x3C - IRQ10 Batch Read Register
        volatile uint32_t IRQ11MON;  ///< Offset: 0x40 - IRQ11 Batch Read Register
        volatile uint32_t IRQ12MON;  ///< Offset: 0x44 - IRQ12 Batch Read Register
        volatile uint32_t IRQ13MON;  ///< Offset: 0x48 - IRQ13 Batch Read Register
        volatile uint32_t IRQ14MON;  ///< Offset: 0x4C - IRQ14 Batch Read Register
        volatile uint32_t IRQ15MON;  ///< Offset: 0x50 - IRQ15 Batch Read Register
        volatile uint32_t IRQ16MON;  ///< Offset: 0x54 - IRQ16 Batch Read Register
        volatile uint32_t IRQ17MON;  ///< Offset: 0x58 - IRQ17 Batch Read Register
        volatile uint32_t IRQ18MON;  ///< Offset: 0x5C - IRQ18 Batch Read Register
        volatile uint32_t IRQ19MON;  ///< Offset: 0x60 - IRQ19 Batch Read Register
        volatile uint32_t IRQ20MON;  ///< Offset: 0x64 - IRQ20 Batch Read Register
        volatile uint32_t IRQ21MON;  ///< Offset: 0x68 - IRQ21 Batch Read Register
        volatile uint32_t IRQ22MON;  ///< Offset: 0x6C - IRQ22 Batch Read Register
        volatile uint32_t IRQ24MON;  ///< Offset: 0x74 - IRQ24 Batch Read Register
        volatile uint32_t IRQ25MON;  ///< Offset: 0x78 - IRQ25 Batch Read Register
        volatile uint32_t IRQ26MON;  ///< Offset: 0x7C - IRQ26 Batch Read Register
        volatile uint32_t IRQ27MON;  ///< Offset: 0x80 - IRQ27 Batch Read Register
        volatile uint32_t IRQ31MON;  ///< Offset: 0x90 - IRQ31 Batch Read Register
        volatile uint32_t IRQ36MON;  ///< Offset: 0xA4 - IRQ36 Batch Read Register
        volatile uint32_t IRQ37MON;  ///< Offset: 0xA8 - IRQ37 Batch Read Register
        volatile uint32_t IRQ38MON;  ///< Offset: 0xAC - IRQ38 Batch Read Register
        volatile uint32_t IRQ39MON;  ///< Offset: 0xB0 - IRQ39 Batch Read Register
        volatile uint32_t IRQ40MON;  ///< Offset: 0xB4 - IRQ40 Batch Read Register
        volatile uint32_t IRQ41MON;  ///< Offset: 0xB8 - IRQ41 Batch Read Register
        volatile uint32_t IRQ42MON;  ///< Offset: 0xBC - IRQ42 Batch Read Register
        volatile uint32_t IRQ43MON;  ///< Offset: 0xC0 - IRQ43 Batch Read Register
        volatile uint32_t IRQ44MON;  ///< Offset: 0xC4 - IRQ44 Batch Read Register
        volatile uint32_t IRQ45MON;  ///< Offset: 0xC8 - IRQ45 Batch Read Register
        volatile uint32_t IRQ47MON;  ///< Offset: 0xD0 - IRQ47 Batch Read Register
        volatile uint32_t RCINTSEL0;  ///< Offset: 0x210 - Interrupt Factor Selection Register 0
        volatile uint32_t RCINTSEL1;  ///< Offset: 0x214 - Interrupt Factor Selection Register 1
    };

    /// Peripheral instances
    inline Registers* INTREQ = reinterpret_cast<Registers*>(INTREQ_BASE);

    // Bit definitions
    /// DRQSEL Register bits
    namespace drqsel_bits {
        constexpr uint32_t EXINT3 = (1U << 31);  ///< The interrupt signal of the external interrupt ch.3 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t EXINT2 = (1U << 30);  ///< The interrupt signal of the external interrupt ch.2 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t EXINT1 = (1U << 29);  ///< The interrupt signal of the external interrupt ch.1 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t EXINT0 = (1U << 28);  ///< The interrupt signal of the external interrupt ch.0 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS7TX = (1U << 27);  ///< The transmission interrupt signal of the MFS ch.7 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS7RX = (1U << 26);  ///< The reception interrupt signal of the MFS ch.7 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS6TX = (1U << 25);  ///< The transmission interrupt signal of the MFS ch.6 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS6RX = (1U << 24);  ///< The reception interrupt signal of the MFS ch.6 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS5TX = (1U << 23);  ///< The transmission interrupt signal of the MFS ch.5 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS5RX = (1U << 22);  ///< The reception interrupt signal of the MFS ch.5 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS4TX = (1U << 21);  ///< The transmission interrupt signal of the MFS ch.4 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS4RX = (1U << 20);  ///< The reception interrupt signal of the MFS ch.4 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS3TX = (1U << 19);  ///< The transmission interrupt signal of the MFS ch.3 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS3RX = (1U << 18);  ///< The reception interrupt signal of the MFS ch.3 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS2TX = (1U << 17);  ///< The transmission interrupt signal of the MFS ch.2 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS2RX = (1U << 16);  ///< The reception interrupt signal of the MFS ch.2 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS1TX = (1U << 15);  ///< The transmission interrupt signal of the MFS ch.1 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS1RX = (1U << 14);  ///< The reception interrupt signal of the MFS ch.1 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS0TX = (1U << 13);  ///< The transmission interrupt signal of the MFS ch.0 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t MFS0RX = (1U << 12);  ///< The reception interrupt signal of the MFS ch.0 is output as a transfer request to the DMAC (including extension).
        constexpr uint32_t IRQ0BT6 = (1U << 11);  ///< The IRQ0 interrupt signal of the base timer ch.6 is output as a transfer request to the DMAC.
        constexpr uint32_t IRQ0BT4 = (1U << 10);  ///< The IRQ0 interrupt signal of the base timer ch.4 is output as a transfer request to the DMAC.
        constexpr uint32_t IRQ0BT2 = (1U << 9);  ///< The IRQ0 interrupt signal of the base timer ch.3 is output as a transfer request to the DMAC.
        constexpr uint32_t IRQ0BT0 = (1U << 8);  ///< The IRQ0 interrupt signal of the base timer ch.0 is output as a transfer request to the DMAC.
        constexpr uint32_t ADCSCAN2 = (1U << 7);  ///< The scan conversion interrupt signal of the A/D converter unit 2 is output as a transfer request to the DMAC.
        constexpr uint32_t ADCSCAN1 = (1U << 6);  ///< The scan conversion interrupt signal of the A/D converter unit 1 is output as a transfer request to the DMAC.
        constexpr uint32_t ADCSCAN0 = (1U << 5);  ///< The scan conversion interrupt signal of the A/D converter unit 0 is output as a transfer request to the DMAC.
        constexpr uint32_t USBEP5 = (1U << 4);  ///< The EP5 DRQ interrupt signal of the USB ch.0 is output as a transfer request to the DMAC.
        constexpr uint32_t USBEP4 = (1U << 3);  ///< The EP4 DRQ interrupt signal of the USB ch.0 is output as a transfer request to the DMAC.
        constexpr uint32_t USBEP3 = (1U << 2);  ///< The EP3 DRQ interrupt signal of the USB ch.0 is output as a transfer request to the DMAC.
        constexpr uint32_t USBEP2 = (1U << 1);  ///< The EP2 DRQ interrupt signal of the USB ch.0 is output as a transfer request to the DMAC.
        constexpr uint32_t USBEP1 = (1U << 0);  ///< The EP1 DRQ interrupt signal of the USB ch.0 is output as a transfer request to the DMAC.
    }

    /// IRQCMODE Register bits
    namespace irqcmode_bits {
        constexpr uint32_t IRQCMODE = (1U << 0);  ///< Interrupt Factor Vector Relocate Setting
    }

    /// EXC02MON Register bits
    namespace exc02mon_bits {
        constexpr uint32_t HWINT = (1U << 1);  ///< Hardware watchdog timer interrupt request
        constexpr uint32_t NMI = (1U << 0);  ///< External NMIX pin interrupt request
    }

    /// IRQ00MON Register bits
    namespace irq00mon_bits {
        constexpr uint32_t FCSINT = (1U << 0);  ///< Anomalous frequency detection by CSV interrupt request
    }

    /// IRQ01MON Register bits
    namespace irq01mon_bits {
        constexpr uint32_t SWWDTINT = (1U << 0);  ///< Software watchdog timer interrupt request
    }

    /// IRQ02MON Register bits
    namespace irq02mon_bits {
        constexpr uint32_t LVDINT = (1U << 0);  ///< Low voltage detection (LVD) interrupt request
    }

    /// IRQ04MON Register bits
    namespace irq04mon_bits {
        constexpr uint32_t EXTINT7 = (1U << 7);  ///< Interrupt request on external interrupt ch.7
        constexpr uint32_t EXTINT6 = (1U << 6);  ///< Interrupt request on external interrupt ch.6
        constexpr uint32_t EXTINT5 = (1U << 5);  ///< Interrupt request on external interrupt ch.5
        constexpr uint32_t EXTINT4 = (1U << 4);  ///< Interrupt request on external interrupt ch.4
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request on external interrupt ch.3
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request on external interrupt ch.2
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request on external interrupt ch.1
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request on external interrupt ch.0
    }

    /// IRQ05MON Register bits
    namespace irq05mon_bits {
        constexpr uint32_t EXTINT7 = (1U << 7);  ///< Interrupt request on external interrupt ch.15
        constexpr uint32_t EXTINT6 = (1U << 6);  ///< Interrupt request on external interrupt ch.14
        constexpr uint32_t EXTINT5 = (1U << 5);  ///< Interrupt request on external interrupt ch.13
        constexpr uint32_t EXTINT4 = (1U << 4);  ///< Interrupt request on external interrupt ch.12
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request on external interrupt ch.11
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request on external interrupt ch.10
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request on external interrupt ch.9
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request on external interrupt ch.8
    }

    /// IRQ06MON Register bits
    namespace irq06mon_bits {
        constexpr uint32_t TIMINT2 = (1U << 1);  ///< Dual timer 2 interrupt request
        constexpr uint32_t TIMINT1 = (1U << 0);  ///< Dual timer 1 interrupt request
    }

    /// IRQ07MON Register bits
    namespace irq07mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.0
    }

    /// IRQ08MON Register bits
    namespace irq08mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.0
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.0
    }

    /// IRQ09MON Register bits
    namespace irq09mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.1
    }

    /// IRQ10MON Register bits
    namespace irq10mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.1
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.1
    }

    /// IRQ11MON Register bits
    namespace irq11mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.2
    }

    /// IRQ12MON Register bits
    namespace irq12mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.2
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.2
    }

    /// IRQ13MON Register bits
    namespace irq13mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.3
    }

    /// IRQ14MON Register bits
    namespace irq14mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.3
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.3
    }

    /// IRQ15MON Register bits
    namespace irq15mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.4
    }

    /// IRQ16MON Register bits
    namespace irq16mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.4
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.4
    }

    /// IRQ17MON Register bits
    namespace irq17mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.5
    }

    /// IRQ18MON Register bits
    namespace irq18mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.5
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.5
    }

    /// IRQ19MON Register bits
    namespace irq19mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.6
    }

    /// IRQ20MON Register bits
    namespace irq20mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.6
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.6
    }

    /// IRQ21MON Register bits
    namespace irq21mon_bits {
        constexpr uint32_t MFSINT = (1U << 0);  ///< Reception interrupt request on MFS ch.7
    }

    /// IRQ22MON Register bits
    namespace irq22mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request on MFS ch.7
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request on MFS ch.7
    }

    /// IRQ24MON Register bits
    namespace irq24mon_bits {
        constexpr uint32_t RTCINT = (1U << 5);  ///< RTC interrupt request
        constexpr uint32_t WCINT = (1U << 4);  ///< Watch counter interrupt request
        constexpr uint32_t UPLLINT = (1U << 3);  ///< Stabilization wait completion interrupt request for USB or USB/Ethernet PLL oscillation.
        constexpr uint32_t MPLLINT = (1U << 2);  ///< Stabilization wait completion interrupt request for main PLL oscillation
        constexpr uint32_t SOSCINT = (1U << 1);  ///< Stabilization wait completion interrupt request for sub-clock oscillation
        constexpr uint32_t MOSCINT = (1U << 0);  ///< Stabilization wait completion interrupt request for main clock oscillation
    }

    /// IRQ25MON Register bits
    namespace irq25mon_bits {
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request in the corresponding A/D unit 0.
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request in the corresponding A/D unit 0.
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request in the corresponding A/D unit 0.
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request in the corresponding A/D unit 0.
    }

    /// IRQ26MON Register bits
    namespace irq26mon_bits {
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request in the corresponding A/D unit 1
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request in the corresponding A/D unit 1
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request in the corresponding A/D unit 1
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request in the corresponding A/D unit 1
    }

    /// IRQ27MON Register bits
    namespace irq27mon_bits {
        constexpr uint32_t LCDCINT = (1U << 4);  ///< LCDC interrupt request for LCD controller
    }

    /// IRQ31MON Register bits
    namespace irq31mon_bits {
        constexpr uint32_t BTINT15 = (1U << 15);  ///< IRQ1 interrupt request on the base timer ch.7
        constexpr uint32_t BTINT14 = (1U << 14);  ///< IRQ0 interrupt request on the base timer ch.7
        constexpr uint32_t BTINT13 = (1U << 13);  ///< IRQ1 interrupt request on the base timer ch.6
        constexpr uint32_t BTINT12 = (1U << 12);  ///< IRQ0 interrupt request on the base timer ch.6
        constexpr uint32_t BTINT11 = (1U << 11);  ///< IRQ1 interrupt request on the base timer ch.5
        constexpr uint32_t BTINT10 = (1U << 10);  ///< IRQ0 interrupt request on the base timer ch.5
        constexpr uint32_t BTINT9 = (1U << 9);  ///< IRQ1 interrupt request on the base timer ch.4
        constexpr uint32_t BTINT8 = (1U << 8);  ///< IRQ0 interrupt request on the base timer ch.4
        constexpr uint32_t BTINT7 = (1U << 7);  ///< IRQ1 interrupt request on the base timer ch.3
        constexpr uint32_t BTINT6 = (1U << 6);  ///< IRQ0 interrupt request on the base timer ch.3
        constexpr uint32_t BTINT5 = (1U << 5);  ///< IRQ1 interrupt request on the base timer ch.2
        constexpr uint32_t BTINT4 = (1U << 4);  ///< IRQ0 interrupt request on the base timer ch.2
        constexpr uint32_t BTINT3 = (1U << 3);  ///< IRQ1 interrupt request on the base timer ch.1
        constexpr uint32_t BTINT2 = (1U << 2);  ///< IRQ0 interrupt request on the base timer ch.1
        constexpr uint32_t BTINT1 = (1U << 1);  ///< IRQ1 interrupt request on the base timer ch.0
        constexpr uint32_t BTINT0 = (1U << 0);  ///< IRQ0 interrupt request on the base timer ch.0
    }

    /// IRQ36MON Register bits
    namespace irq36mon_bits {
        constexpr uint32_t RCEC0INT = (1U << 5);  ///< Interrupt request for HDMI-CEC/Remote Control Reception ch.0
    }

    /// IRQ37MON Register bits
    namespace irq37mon_bits {
        constexpr uint32_t RCEC1INT = (1U << 6);  ///< Interrupt request for HDMI-CEC/Remote Control Reception ch.1
    }

    /// IRQ38MON Register bits
    namespace irq38mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.0.
    }

    /// IRQ39MON Register bits
    namespace irq39mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.1.
    }

    /// IRQ40MON Register bits
    namespace irq40mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.2.
    }

    /// IRQ41MON Register bits
    namespace irq41mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.3.
    }

    /// IRQ42MON Register bits
    namespace irq42mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.4.
    }

    /// IRQ43MON Register bits
    namespace irq43mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.5.
    }

    /// IRQ44MON Register bits
    namespace irq44mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.6.
    }

    /// IRQ45MON Register bits
    namespace irq45mon_bits {
        constexpr uint32_t DMAINT = (1U << 0);  ///< Interrupt request on DMA ch.7.
    }

    /// IRQ47MON Register bits
    namespace irq47mon_bits {
        constexpr uint32_t FLASHINT = (1U << 11);  ///< "RDY, HANG interrupt request for flash "
    }

    /// RCINTSEL0 Register bits
    namespace rcintsel0_bits {
        constexpr uint32_t INTSEL3 = (8 << 24);  ///< select the interrupt factor of the interrupt vector No.22.
        constexpr uint32_t INTSEL2 = (8 << 16);  ///< select the interrupt factor of the interrupt vector No.21.
        constexpr uint32_t INTSEL1 = (8 << 8);  ///< select the interrupt factor of the interrupt vector No.20.
        constexpr uint32_t INTSEL0 = (8 << 0);  ///< select the interrupt factor of the interrupt vector No.19.
    }

    /// RCINTSEL1 Register bits
    namespace rcintsel1_bits {
        constexpr uint32_t INTSEL7 = (8 << 24);  ///< select the interrupt factor of the interrupt vector No.26.
        constexpr uint32_t INTSEL6 = (8 << 16);  ///< select the interrupt factor of the interrupt vector No.25.
        constexpr uint32_t INTSEL5 = (8 << 8);  ///< select the interrupt factor of the interrupt vector No.24.
        constexpr uint32_t INTSEL4 = (8 << 0);  ///< select the interrupt factor of the interrupt vector No.23.
    }

}

// ============================================================================
// LCDC Peripheral
// ============================================================================

namespace lcdc {
    /// Base addresses
    constexpr uint32_t LCDC_BASE = 0x40032000;

    /// LCDC Register structure
    struct Registers {
        volatile uint32_t LCDCC1;  ///< Offset: 0x00 - LCDC Control Register 1
        volatile uint32_t LCDCC2;  ///< Offset: 0x01 - LCDC Control Register 2
        volatile uint32_t LCDCC3;  ///< Offset: 0x02 - LCDC Control Register 3
        volatile uint32_t LCDC_PSR;  ///< Offset: 0x04 - LCDC Clock Prescaler Register
        volatile uint32_t LCDC_COMEN;  ///< Offset: 0x08 - LCDC COM Output Enable Register
        volatile uint32_t LCDC_SEGEN1;  ///< Offset: 0x0C - LCDC SEG Output Enable Register 1
        volatile uint32_t LCDC_SEGEN2;  ///< Offset: 0x10 - LCDC SEG Output Enable Register 2
        volatile uint32_t LCDC_BLINK;  ///< Offset: 0x14 - LCDC Blink Setting Register
        volatile uint32_t LCDRAM00;  ///< Offset: 0x1C - Display Data Memory Register 00
        volatile uint32_t LCDRAM01;  ///< Offset: 0x1D - Display Data Memory Register 01
        volatile uint32_t LCDRAM02;  ///< Offset: 0x1E - Display Data Memory Register 02
        volatile uint32_t LCDRAM03;  ///< Offset: 0x1F - Display Data Memory Register 03
        volatile uint32_t LCDRAM04;  ///< Offset: 0x20 - Display Data Memory Register 04
        volatile uint32_t LCDRAM05;  ///< Offset: 0x21 - Display Data Memory Register 05
        volatile uint32_t LCDRAM06;  ///< Offset: 0x22 - Display Data Memory Register 06
        volatile uint32_t LCDRAM07;  ///< Offset: 0x23 - Display Data Memory Register 07
        volatile uint32_t LCDRAM08;  ///< Offset: 0x24 - Display Data Memory Register 08
        volatile uint32_t LCDRAM09;  ///< Offset: 0x25 - Display Data Memory Register 09
        volatile uint32_t LCDRAM10;  ///< Offset: 0x26 - Display Data Memory Register 10
        volatile uint32_t LCDRAM11;  ///< Offset: 0x27 - Display Data Memory Register 11
        volatile uint32_t LCDRAM12;  ///< Offset: 0x28 - Display Data Memory Register 12
        volatile uint32_t LCDRAM13;  ///< Offset: 0x29 - Display Data Memory Register 13
        volatile uint32_t LCDRAM14;  ///< Offset: 0x2A - Display Data Memory Register 14
        volatile uint32_t LCDRAM15;  ///< Offset: 0x2B - Display Data Memory Register 15
        volatile uint32_t LCDRAM16;  ///< Offset: 0x2C - Display Data Memory Register 16
        volatile uint32_t LCDRAM17;  ///< Offset: 0x2D - Display Data Memory Register 17
        volatile uint32_t LCDRAM18;  ///< Offset: 0x2E - Display Data Memory Register 18
        volatile uint32_t LCDRAM19;  ///< Offset: 0x2F - Display Data Memory Register 19
        volatile uint32_t LCDRAM20;  ///< Offset: 0x30 - Display Data Memory Register 20
        volatile uint32_t LCDRAM21;  ///< Offset: 0x31 - Display Data Memory Register 21
        volatile uint32_t LCDRAM22;  ///< Offset: 0x32 - Display Data Memory Register 22
        volatile uint32_t LCDRAM23;  ///< Offset: 0x33 - Display Data Memory Register 23
        volatile uint32_t LCDRAM24;  ///< Offset: 0x34 - Display Data Memory Register 24
        volatile uint32_t LCDRAM25;  ///< Offset: 0x35 - Display Data Memory Register 25
        volatile uint32_t LCDRAM26;  ///< Offset: 0x36 - Display Data Memory Register 26
        volatile uint32_t LCDRAM27;  ///< Offset: 0x37 - Display Data Memory Register 27
        volatile uint32_t LCDRAM28;  ///< Offset: 0x38 - Display Data Memory Register 28
        volatile uint32_t LCDRAM29;  ///< Offset: 0x39 - Display Data Memory Register 29
        volatile uint32_t LCDRAM30;  ///< Offset: 0x3A - Display Data Memory Register 30
        volatile uint32_t LCDRAM31;  ///< Offset: 0x3B - Display Data Memory Register 31
        volatile uint32_t LCDRAM32;  ///< Offset: 0x3C - Display Data Memory Register 32
        volatile uint32_t LCDRAM33;  ///< Offset: 0x3D - Display Data Memory Register 33
        volatile uint32_t LCDRAM34;  ///< Offset: 0x3E - Display Data Memory Register 34
        volatile uint32_t LCDRAM35;  ///< Offset: 0x3F - Display Data Memory Register 35
        volatile uint32_t LCDRAM36;  ///< Offset: 0x40 - Display Data Memory Register 36
        volatile uint32_t LCDRAM37;  ///< Offset: 0x41 - Display Data Memory Register 37
        volatile uint32_t LCDRAM38;  ///< Offset: 0x42 - Display Data Memory Register 38
        volatile uint32_t LCDRAM39;  ///< Offset: 0x43 - Display Data Memory Register 39
    };

    /// Peripheral instances
    inline Registers* LCDC = reinterpret_cast<Registers*>(LCDC_BASE);

    // Bit definitions
    /// LCDCC1 Register bits
    namespace lcdcc1_bits {
        constexpr uint32_t LCDEN = (1U << 6);  ///< Timer mode operation enable bit
        constexpr uint32_t VSEL = (1U << 5);  ///< LCD drive power control bit
        constexpr uint32_t MS = (3 << 2);  ///< LCD controller display mode selection bits
    }

    /// LCDCC2 Register bits
    namespace lcdcc2_bits {
        constexpr uint32_t RSEL = (1U << 5);  ///< Divider resistor value selection bit
        constexpr uint32_t BLS8 = (1U << 4);  ///< 8 COM mode bias selection bit
        constexpr uint32_t INV = (1U << 3);  ///< Reverse display control bit
        constexpr uint32_t BK = (1U << 2);  ///< Blank display control bit
        constexpr uint32_t LCDIEN = (1U << 1);  ///< Interrupt enable bit
        constexpr uint32_t LCDIF = (1U << 0);  ///< Interrupt request detection bit
    }

    /// LCDCC3 Register bits
    namespace lcdcc3_bits {
        constexpr uint32_t PICTL = (1U << 7);  ///< I/O port input control bit
        constexpr uint32_t BLSEL = (1U << 6);  ///< Blink interval selection bit
        constexpr uint32_t VE4 = (1U << 5);  ///< VV4 selection bit
        constexpr uint32_t VE3 = (1U << 4);  ///< VV3 selection bit
        constexpr uint32_t VE2 = (1U << 3);  ///< VV2 selection bit
        constexpr uint32_t VE1 = (1U << 2);  ///< VV1 selection bit
        constexpr uint32_t VE0 = (1U << 1);  ///< VV0 selection bit
    }

    /// LCDC_PSR Register bits
    namespace lcdc_psr_bits {
        constexpr uint32_t CLKSEL = (1U << 22);  ///< Source clock selection bit
        constexpr uint32_t CLKDIV = (22 << 0);  ///< LCDC clock division ratio setting bit
    }

    /// LCDC_COMEN Register bits
    namespace lcdc_comen_bits {
        constexpr uint32_t COM7 = (1U << 7);  ///< Dual purpose COM/SEG port control bits
        constexpr uint32_t COM6 = (1U << 6);  ///< Dual purpose COM/SEG port control bits
        constexpr uint32_t COM5 = (1U << 5);  ///< Dual purpose COM/SEG port control bits
        constexpr uint32_t COM4 = (1U << 4);  ///< Dual purpose COM/SEG port control bits
        constexpr uint32_t COM3 = (1U << 3);  ///< Dual purpose COM port control bit
        constexpr uint32_t COM2 = (1U << 2);  ///< Dual purpose COM port control bit
        constexpr uint32_t COM1 = (1U << 1);  ///< Dual purpose COM port control bit
        constexpr uint32_t COM0 = (1U << 0);  ///< Dual purpose COM port control bit
    }

    /// LCDC_SEGEN1 Register bits
    namespace lcdc_segen1_bits {
        constexpr uint32_t SEG31 = (1U << 31);  ///< Segment 31
        constexpr uint32_t SEG30 = (1U << 30);  ///< Segment 30
        constexpr uint32_t SEG29 = (1U << 29);  ///< Segment 29
        constexpr uint32_t SEG28 = (1U << 28);  ///< Segment 28
        constexpr uint32_t SEG27 = (1U << 27);  ///< Segment 27
        constexpr uint32_t SEG26 = (1U << 26);  ///< Segment 26
        constexpr uint32_t SEG25 = (1U << 25);  ///< Segment 25
        constexpr uint32_t SEG24 = (1U << 24);  ///< Segment 24
        constexpr uint32_t SEG23 = (1U << 23);  ///< Segment 23
        constexpr uint32_t SEG22 = (1U << 22);  ///< Segment 22
        constexpr uint32_t SEG21 = (1U << 21);  ///< Segment 21
        constexpr uint32_t SEG20 = (1U << 20);  ///< Segment 20
        constexpr uint32_t SEG19 = (1U << 19);  ///< Segment 19
        constexpr uint32_t SEG18 = (1U << 18);  ///< Segment 18
        constexpr uint32_t SEG17 = (1U << 17);  ///< Segment 17
        constexpr uint32_t SEG16 = (1U << 16);  ///< Segment 16
        constexpr uint32_t SEG15 = (1U << 15);  ///< Segment 15
        constexpr uint32_t SEG14 = (1U << 14);  ///< Segment 14
        constexpr uint32_t SEG13 = (1U << 13);  ///< Segment 13
        constexpr uint32_t SEG12 = (1U << 12);  ///< Segment 12
        constexpr uint32_t SEG11 = (1U << 11);  ///< Segment 11
        constexpr uint32_t SEG10 = (1U << 10);  ///< Segment 10
        constexpr uint32_t SEG09 = (1U << 9);  ///< Segment 9
        constexpr uint32_t SEG08 = (1U << 8);  ///< Segment 8
        constexpr uint32_t SEG07 = (1U << 7);  ///< Segment 7
        constexpr uint32_t SEG06 = (1U << 6);  ///< Segment 6
        constexpr uint32_t SEG05 = (1U << 5);  ///< Segment 5
        constexpr uint32_t SEG04 = (1U << 4);  ///< Segment 4
        constexpr uint32_t SEG03 = (1U << 3);  ///< Segment 3
        constexpr uint32_t SEG02 = (1U << 2);  ///< Segment 2
        constexpr uint32_t SEG01 = (1U << 1);  ///< Segment 1
        constexpr uint32_t SEG00 = (1U << 0);  ///< Segment 0
    }

    /// LCDC_SEGEN2 Register bits
    namespace lcdc_segen2_bits {
        constexpr uint32_t SEG39 = (1U << 7);  ///< Segment 39
        constexpr uint32_t SEG38 = (1U << 6);  ///< Segment 38
        constexpr uint32_t SEG37 = (1U << 5);  ///< Segment 37
        constexpr uint32_t SEG36 = (1U << 4);  ///< Segment 36
        constexpr uint32_t SEG35 = (1U << 3);  ///< Segment 35
        constexpr uint32_t SEG34 = (1U << 2);  ///< Segment 34
        constexpr uint32_t SEG33 = (1U << 1);  ///< Segment 33
        constexpr uint32_t SEG32 = (1U << 0);  ///< Segment 32
    }

    /// LCDC_BLINK Register bits
    namespace lcdc_blink_bits {
        constexpr uint32_t BLD15 = (1U << 15);  ///< Blink operation control bit 15
        constexpr uint32_t BLD14 = (1U << 14);  ///< Blink operation control bit 14
        constexpr uint32_t BLD13 = (1U << 13);  ///< Blink operation control bit 13
        constexpr uint32_t BLD12 = (1U << 12);  ///< Blink operation control bit 12
        constexpr uint32_t BLD11 = (1U << 11);  ///< Blink operation control bit 11
        constexpr uint32_t BLD10 = (1U << 10);  ///< Blink operation control bit 10
        constexpr uint32_t BLD09 = (1U << 9);  ///< Blink operation control bit 9
        constexpr uint32_t BLD08 = (1U << 8);  ///< Blink operation control bit 8
        constexpr uint32_t BLD07 = (1U << 7);  ///< Blink operation control bit 7
        constexpr uint32_t BLD06 = (1U << 6);  ///< Blink operation control bit 6
        constexpr uint32_t BLD05 = (1U << 5);  ///< Blink operation control bit 5
        constexpr uint32_t BLD04 = (1U << 4);  ///< Blink operation control bit 4
        constexpr uint32_t BLD03 = (1U << 3);  ///< Blink operation control bit 3
        constexpr uint32_t BLD02 = (1U << 2);  ///< Blink operation control bit 2
        constexpr uint32_t BLD01 = (1U << 1);  ///< Blink operation control bit 1
        constexpr uint32_t BLD00 = (1U << 0);  ///< Blink operation control bit 0
    }

    /// LCDRAM00 Register bits
    namespace lcdram00_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 00
    }

    /// LCDRAM01 Register bits
    namespace lcdram01_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 01
    }

    /// LCDRAM02 Register bits
    namespace lcdram02_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 02
    }

    /// LCDRAM03 Register bits
    namespace lcdram03_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 03
    }

    /// LCDRAM04 Register bits
    namespace lcdram04_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 04
    }

    /// LCDRAM05 Register bits
    namespace lcdram05_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 05
    }

    /// LCDRAM06 Register bits
    namespace lcdram06_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 06
    }

    /// LCDRAM07 Register bits
    namespace lcdram07_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 07
    }

    /// LCDRAM08 Register bits
    namespace lcdram08_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 08
    }

    /// LCDRAM09 Register bits
    namespace lcdram09_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 09
    }

    /// LCDRAM10 Register bits
    namespace lcdram10_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 10
    }

    /// LCDRAM11 Register bits
    namespace lcdram11_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 11
    }

    /// LCDRAM12 Register bits
    namespace lcdram12_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 12
    }

    /// LCDRAM13 Register bits
    namespace lcdram13_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 13
    }

    /// LCDRAM14 Register bits
    namespace lcdram14_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 14
    }

    /// LCDRAM15 Register bits
    namespace lcdram15_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 15
    }

    /// LCDRAM16 Register bits
    namespace lcdram16_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 16
    }

    /// LCDRAM17 Register bits
    namespace lcdram17_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 17
    }

    /// LCDRAM18 Register bits
    namespace lcdram18_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 18
    }

    /// LCDRAM19 Register bits
    namespace lcdram19_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 19
    }

    /// LCDRAM20 Register bits
    namespace lcdram20_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 20
    }

    /// LCDRAM21 Register bits
    namespace lcdram21_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 21
    }

    /// LCDRAM22 Register bits
    namespace lcdram22_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 22
    }

    /// LCDRAM23 Register bits
    namespace lcdram23_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 23
    }

    /// LCDRAM24 Register bits
    namespace lcdram24_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 24
    }

    /// LCDRAM25 Register bits
    namespace lcdram25_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 25
    }

    /// LCDRAM26 Register bits
    namespace lcdram26_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 26
    }

    /// LCDRAM27 Register bits
    namespace lcdram27_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 27
    }

    /// LCDRAM28 Register bits
    namespace lcdram28_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 28
    }

    /// LCDRAM29 Register bits
    namespace lcdram29_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 29
    }

    /// LCDRAM30 Register bits
    namespace lcdram30_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 30
    }

    /// LCDRAM31 Register bits
    namespace lcdram31_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 31
    }

    /// LCDRAM32 Register bits
    namespace lcdram32_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 32
    }

    /// LCDRAM33 Register bits
    namespace lcdram33_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 33
    }

    /// LCDRAM34 Register bits
    namespace lcdram34_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 34
    }

    /// LCDRAM35 Register bits
    namespace lcdram35_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 35
    }

    /// LCDRAM36 Register bits
    namespace lcdram36_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 36
    }

    /// LCDRAM37 Register bits
    namespace lcdram37_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 37
    }

    /// LCDRAM38 Register bits
    namespace lcdram38_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 38
    }

    /// LCDRAM39 Register bits
    namespace lcdram39_bits {
        constexpr uint32_t LCDRAM = (8 << 0);  ///< Display Data 39
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x40033000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PFR0;  ///< Offset: 0x00 - Port function setting register 0
        volatile uint32_t PFR1;  ///< Offset: 0x04 - Port function setting register 1
        volatile uint32_t PFR2;  ///< Offset: 0x08 - Port function setting register 2
        volatile uint32_t PFR3;  ///< Offset: 0x0C - Port function setting register 3
        volatile uint32_t PFR4;  ///< Offset: 0x10 - Port function setting register 4
        volatile uint32_t PFR5;  ///< Offset: 0x14 - Port function setting register 5
        volatile uint32_t PFR6;  ///< Offset: 0x18 - Port function setting register 6
        volatile uint32_t PFR8;  ///< Offset: 0x20 - Port function setting register 8
        volatile uint32_t PFRE;  ///< Offset: 0x38 - Port function setting register E
        volatile uint32_t PCR0;  ///< Offset: 0x100 - Pull-up Setting Register 0
        volatile uint32_t PCR1;  ///< Offset: 0x104 - Pull-up Setting Register 1
        volatile uint32_t PCR2;  ///< Offset: 0x108 - Pull-up Setting Register 2
        volatile uint32_t PCR3;  ///< Offset: 0x10C - Pull-up Setting Register 3
        volatile uint32_t PCR4;  ///< Offset: 0x110 - Pull-up Setting Register 4
        volatile uint32_t PCR5;  ///< Offset: 0x114 - Pull-up Setting Register 5
        volatile uint32_t PCR6;  ///< Offset: 0x118 - Pull-up Setting Register 6
        volatile uint32_t PCRE;  ///< Offset: 0x138 - Pull-up Setting Register E
        volatile uint32_t DDR0;  ///< Offset: 0x200 - Port input/output direction setting register 0
        volatile uint32_t DDR1;  ///< Offset: 0x204 - Port input/output direction setting register 1
        volatile uint32_t DDR2;  ///< Offset: 0x208 - Port input/output direction setting register 2
        volatile uint32_t DDR3;  ///< Offset: 0x20C - Port input/output direction setting register 3
        volatile uint32_t DDR4;  ///< Offset: 0x210 - Port input/output direction setting register 4
        volatile uint32_t DDR5;  ///< Offset: 0x214 - Port input/output direction setting register 5
        volatile uint32_t DDR6;  ///< Offset: 0x218 - Port input/output direction setting register 6
        volatile uint32_t DDR8;  ///< Offset: 0x220 - Port input/output direction setting register 8
        volatile uint32_t DDRE;  ///< Offset: 0x238 - Port input/output direction setting register E
        volatile uint32_t PDIR0;  ///< Offset: 0x300 - Port input data register 0
        volatile uint32_t PDIR1;  ///< Offset: 0x304 - Port input data register 1
        volatile uint32_t PDIR2;  ///< Offset: 0x308 - Port input data register 2
        volatile uint32_t PDIR3;  ///< Offset: 0x30C - Port input data register 3
        volatile uint32_t PDIR4;  ///< Offset: 0x310 - Port input data register 4
        volatile uint32_t PDIR5;  ///< Offset: 0x314 - Port input data register 5
        volatile uint32_t PDIR6;  ///< Offset: 0x318 - Port input data register 6
        volatile uint32_t PDIR8;  ///< Offset: 0x320 - Port input data register 8
        volatile uint32_t PDIRE;  ///< Offset: 0x338 - Port input data register E
        volatile uint32_t PDOR0;  ///< Offset: 0x400 - Port output data register 0
        volatile uint32_t PDOR1;  ///< Offset: 0x404 - Port output data register 1
        volatile uint32_t PDOR2;  ///< Offset: 0x408 - Port output data register 2
        volatile uint32_t PDOR3;  ///< Offset: 0x40C - Port output data register 3
        volatile uint32_t PDOR4;  ///< Offset: 0x410 - Port output data register 4
        volatile uint32_t PDOR5;  ///< Offset: 0x414 - Port output data register 5
        volatile uint32_t PDOR6;  ///< Offset: 0x418 - Port output data register 6
        volatile uint32_t PDOR8;  ///< Offset: 0x420 - Port output data register 8
        volatile uint32_t PDORE;  ///< Offset: 0x438 - Port output data register E
        volatile uint32_t ADE;  ///< Offset: 0x500 - Analog input setting register
        volatile uint32_t SPSR;  ///< Offset: 0x580 - Special port setting register
        volatile uint32_t EPFR00;  ///< Offset: 0x600 - Extended pin function setting register 00
        volatile uint32_t EPFR04;  ///< Offset: 0x610 - Extended pin function setting register 04
        volatile uint32_t EPFR05;  ///< Offset: 0x614 - Extended pin function setting register 05
        volatile uint32_t EPFR06;  ///< Offset: 0x618 - Extended pin function setting register 06
        volatile uint32_t EPFR07;  ///< Offset: 0x61C - Extended pin function setting register 07
        volatile uint32_t EPFR08;  ///< Offset: 0x620 - Extended pin function setting register 08
        volatile uint32_t EPFR09;  ///< Offset: 0x624 - Extended pin function setting register 09
        volatile uint32_t EPFR10;  ///< Offset: 0x628 - Extended pin function setting register 10
        volatile uint32_t EPFR11;  ///< Offset: 0x62C - Extended pin function setting register 11
        volatile uint32_t EPFR14;  ///< Offset: 0x638 - Extended pin function setting register 14
        volatile uint32_t PZR0;  ///< Offset: 0x700 - Port Pseudo Open Drain Setting Register 0
        volatile uint32_t PZR4;  ///< Offset: 0x710 - Port Pseudo Open Drain Setting Register 4
        volatile uint32_t PZR6;  ///< Offset: 0x718 - Port Pseudo Open Drain Setting Register 6
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// PFR0 Register bits
    namespace pfr0_bits {
        constexpr uint32_t PF = (1U << 15);  ///< Bit15 of PFR0
        constexpr uint32_t PE = (1U << 14);  ///< Bit14 of PFR0
        constexpr uint32_t PD = (1U << 13);  ///< Bit13 of PFR0
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of PFR0
        constexpr uint32_t PB = (1U << 11);  ///< Bit11 of PFR0
        constexpr uint32_t PA = (1U << 10);  ///< Bit10 of PFR0
        constexpr uint32_t P9 = (1U << 9);  ///< Bit9 of PFR0
        constexpr uint32_t P8 = (1U << 8);  ///< Bit8 of PFR0
        constexpr uint32_t P7 = (1U << 7);  ///< Bit7 of PFR0
        constexpr uint32_t P6 = (1U << 6);  ///< Bit6 of PFR0
        constexpr uint32_t P5 = (1U << 5);  ///< Bit5 of PFR0
        constexpr uint32_t P4 = (1U << 4);  ///< Bit4 of PFR0
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR0
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR0
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR0
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR0
    }

    /// PFR1 Register bits
    namespace pfr1_bits {
        constexpr uint32_t PF = (1U << 15);  ///< Bit15 of PFR1
        constexpr uint32_t PE = (1U << 14);  ///< Bit14 of PFR1
        constexpr uint32_t PD = (1U << 13);  ///< Bit13 of PFR1
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of PFR1
        constexpr uint32_t PB = (1U << 11);  ///< Bit11 of PFR1
        constexpr uint32_t PA = (1U << 10);  ///< Bit10 of PFR1
        constexpr uint32_t P9 = (1U << 9);  ///< Bit9 of PFR1
        constexpr uint32_t P8 = (1U << 8);  ///< Bit8 of PFR1
        constexpr uint32_t P7 = (1U << 7);  ///< Bit7 of PFR1
        constexpr uint32_t P6 = (1U << 6);  ///< Bit6 of PFR1
        constexpr uint32_t P5 = (1U << 5);  ///< Bit5 of PFR1
        constexpr uint32_t P4 = (1U << 4);  ///< Bit4 of PFR1
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR1
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR1
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR1
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR1
    }

    /// PFR2 Register bits
    namespace pfr2_bits {
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR2
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR2
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR2
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR2
    }

    /// PFR3 Register bits
    namespace pfr3_bits {
        constexpr uint32_t PF = (1U << 15);  ///< Bit15 of PFR3
        constexpr uint32_t PE = (1U << 14);  ///< Bit14 of PFR3
        constexpr uint32_t PD = (1U << 13);  ///< Bit13 of PFR3
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of PFR3
        constexpr uint32_t PB = (1U << 11);  ///< Bit11 of PFR3
        constexpr uint32_t PA = (1U << 10);  ///< Bit10 of PFR3
        constexpr uint32_t P9 = (1U << 9);  ///< Bit9 of PFR3
        constexpr uint32_t P8 = (1U << 8);  ///< Bit8 of PFR3
        constexpr uint32_t P7 = (1U << 7);  ///< Bit7 of PFR3
        constexpr uint32_t P6 = (1U << 6);  ///< Bit6 of PFR3
        constexpr uint32_t P5 = (1U << 5);  ///< Bit5 of PFR3
        constexpr uint32_t P4 = (1U << 4);  ///< Bit4 of PFR3
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR3
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR3
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR3
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR3
    }

    /// PFR4 Register bits
    namespace pfr4_bits {
        constexpr uint32_t PE = (1U << 14);  ///< Bit14 of PFR4
        constexpr uint32_t PD = (1U << 13);  ///< Bit13 of PFR4
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of PFR4
        constexpr uint32_t PB = (1U << 11);  ///< Bit11 of PFR4
        constexpr uint32_t PA = (1U << 10);  ///< Bit10 of PFR4
        constexpr uint32_t P9 = (1U << 9);  ///< Bit9 of PFR4
        constexpr uint32_t P8 = (1U << 8);  ///< Bit8 of PFR4
        constexpr uint32_t P7 = (1U << 7);  ///< Bit7 of PFR4
        constexpr uint32_t P6 = (1U << 6);  ///< Bit6 of PFR4
        constexpr uint32_t P5 = (1U << 5);  ///< Bit5 of PFR4
        constexpr uint32_t P4 = (1U << 4);  ///< Bit4 of PFR4
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR4
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR4
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR4
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR4
    }

    /// PFR5 Register bits
    namespace pfr5_bits {
        constexpr uint32_t P6 = (1U << 6);  ///< Bit6 of PFR5
        constexpr uint32_t P5 = (1U << 5);  ///< Bit5 of PFR5
        constexpr uint32_t P4 = (1U << 4);  ///< Bit4 of PFR5
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR5
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR5
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR5
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR5
    }

    /// PFR6 Register bits
    namespace pfr6_bits {
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFR6
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFR6
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR6
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR6
    }

    /// PFR8 Register bits
    namespace pfr8_bits {
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of PFR8
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFR8
    }

    /// PFRE Register bits
    namespace pfre_bits {
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of PFRE
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of PFRE
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PFRE
    }

    /// DDR0 Register bits
    namespace ddr0_bits {
        constexpr uint32_t PF = (1U << 15);  ///< Bit15 of DDR0
        constexpr uint32_t PE = (1U << 14);  ///< Bit14 of DDR0
        constexpr uint32_t PD = (1U << 13);  ///< Bit13 of DDR0
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of DDR0
        constexpr uint32_t PB = (1U << 11);  ///< Bit11 of DDR0
        constexpr uint32_t PA = (1U << 10);  ///< Bit10 of DDR0
        constexpr uint32_t P9 = (1U << 9);  ///< Bit9 of DDR0
        constexpr uint32_t P8 = (1U << 8);  ///< Bit8 of DDR0
        constexpr uint32_t P7 = (1U << 7);  ///< Bit7 of DDR0
        constexpr uint32_t P6 = (1U << 6);  ///< Bit6 of DDR0
        constexpr uint32_t P5 = (1U << 5);  ///< Bit5 of DDR0
        constexpr uint32_t P4 = (1U << 4);  ///< Bit4 of DDR0
        constexpr uint32_t P3 = (1U << 3);  ///< Bit3 of DDR0
        constexpr uint32_t P2 = (1U << 2);  ///< Bit2 of DDR0
        constexpr uint32_t P1 = (1U << 1);  ///< Bit1 of DDR0
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of DDR0
    }

    /// ADE Register bits
    namespace ade_bits {
        constexpr uint32_t AN23 = (1U << 23);  ///< Bit23 of ADE
        constexpr uint32_t AN22 = (1U << 22);  ///< Bit22 of ADE
        constexpr uint32_t AN21 = (1U << 21);  ///< Bit21 of ADE
        constexpr uint32_t AN20 = (1U << 20);  ///< Bit20 of ADE
        constexpr uint32_t AN19 = (1U << 19);  ///< Bit19 of ADE
        constexpr uint32_t AN18 = (1U << 18);  ///< Bit18 of ADE
        constexpr uint32_t AN17 = (1U << 17);  ///< Bit17 of ADE
        constexpr uint32_t AN16 = (1U << 16);  ///< Bit16 of ADE
        constexpr uint32_t AN15 = (1U << 15);  ///< Bit15 of ADE
        constexpr uint32_t AN14 = (1U << 14);  ///< Bit14 of ADE
        constexpr uint32_t AN13 = (1U << 13);  ///< Bit13 of ADE
        constexpr uint32_t AN12 = (1U << 12);  ///< Bit12 of ADE
        constexpr uint32_t AN11 = (1U << 11);  ///< Bit11 of ADE
        constexpr uint32_t AN10 = (1U << 10);  ///< Bit10 of ADE
        constexpr uint32_t AN9 = (1U << 9);  ///< Bit9 of ADE
        constexpr uint32_t AN8 = (1U << 8);  ///< Bit8 of ADE
        constexpr uint32_t AN7 = (1U << 7);  ///< Bit7 of ADE
        constexpr uint32_t AN6 = (1U << 6);  ///< Bit6 of ADE
        constexpr uint32_t AN5 = (1U << 5);  ///< Bit5 of ADE
        constexpr uint32_t AN4 = (1U << 4);  ///< Bit4 of ADE
        constexpr uint32_t AN3 = (1U << 3);  ///< Bit3 of ADE
        constexpr uint32_t AN2 = (1U << 2);  ///< Bit2 of ADE
        constexpr uint32_t AN1 = (1U << 1);  ///< Bit1 of ADE
        constexpr uint32_t AN0 = (1U << 0);  ///< Bit0 of ADE
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t MAINXC = (2 << 2);  ///< Main clock(oscillation) pin setting bit
        constexpr uint32_t SUBXC = (2 << 0);  ///< Sub clock(oscillation) pin setting bit
    }

    /// EPFR00 Register bits
    namespace epfr00_bits {
        constexpr uint32_t TRC1E = (1U << 25);  ///< TRACED function select bit1
        constexpr uint32_t TRC0E = (1U << 24);  ///< TRACED function select bit0
        constexpr uint32_t JTAGEN1S = (1U << 17);  ///< JTAG function select bit1
        constexpr uint32_t JTAGEN0B = (1U << 16);  ///< JTAG function select bit0
        constexpr uint32_t SUBOUTE = (2 << 6);  ///< Sub clock divide output function select bit
        constexpr uint32_t RTCCOE = (2 << 4);  ///< RTC clock output select bit
        constexpr uint32_t CROUTE = (2 << 1);  ///< Internal high-speed CR oscillation output function select bit
        constexpr uint32_t NMIS = (1U << 0);  ///< NMIX function select bit
    }

    /// EPFR04 Register bits
    namespace epfr04_bits {
        constexpr uint32_t TIOB3S = (2 << 28);  ///< TIOB3 input select bit
        constexpr uint32_t TIOA3E = (2 << 26);  ///< TIOA3E output select bit
        constexpr uint32_t TIOA3S = (2 << 24);  ///< TIOA3 input select bit
        constexpr uint32_t TIOB2S = (2 << 20);  ///< TIOB2 input select bit
        constexpr uint32_t TIOA2E = (2 << 18);  ///< TIOA2 output select bit
        constexpr uint32_t TIOB1S = (2 << 12);  ///< TIOB1 input select bit
        constexpr uint32_t TIOA1E = (2 << 10);  ///< TIOA1E output select bit
        constexpr uint32_t TIOA1S = (2 << 8);  ///< TIOA1 input select bit
        constexpr uint32_t TIOB0S = (3 << 4);  ///< TIOB0 input select bit
        constexpr uint32_t TIOA0E = (2 << 2);  ///< TIOA0 output select bit
    }

    /// EPFR05 Register bits
    namespace epfr05_bits {
        constexpr uint32_t TIOB7S = (2 << 28);  ///< TIOB7 input select Bit
        constexpr uint32_t TIOA7E = (2 << 26);  ///< TIOA7E output select bit
        constexpr uint32_t TIOA7S = (2 << 24);  ///< TIOA7 input select bit
        constexpr uint32_t TIOB6S = (2 << 20);  ///< TIOB6 input select bit
        constexpr uint32_t TIOA6E = (2 << 18);  ///< TIOA6 output select bit
        constexpr uint32_t TIOB5S = (2 << 12);  ///< TIOB5 input select bit
        constexpr uint32_t TIOA5E = (2 << 10);  ///< TIOA5E output select bit
        constexpr uint32_t TIOA5S = (2 << 8);  ///< TIOA5 input select bit
        constexpr uint32_t TIOB4S = (2 << 4);  ///< TIOB4 input select bit
        constexpr uint32_t TIOA4E = (2 << 2);  ///< TIOA4 output select bit
    }

    /// EPFR06 Register bits
    namespace epfr06_bits {
        constexpr uint32_t EINT15S = (2 << 30);  ///< External interrupt 15 input select bit
        constexpr uint32_t EINT14S = (2 << 28);  ///< External interrupt 14 input select bit
        constexpr uint32_t EINT13S = (2 << 26);  ///< External interrupt 13 input select bit
        constexpr uint32_t EINT12S = (2 << 24);  ///< External interrupt 12 input select bit
        constexpr uint32_t EINT11S = (2 << 22);  ///< External interrupt 11 input select bit
        constexpr uint32_t EINT10S = (2 << 20);  ///< External interrupt 10 input select bit
        constexpr uint32_t EINT09S = (2 << 18);  ///< External interrupt 9 input select bit
        constexpr uint32_t EINT08S = (2 << 16);  ///< External interrupt 8 input select bit
        constexpr uint32_t EINT07S = (2 << 14);  ///< External interrupt 7 input select bit
        constexpr uint32_t EINT06S = (2 << 12);  ///< External interrupt 6 input select bit
        constexpr uint32_t EINT05S = (2 << 10);  ///< External interrupt 5 input select bit
        constexpr uint32_t EINT04S = (2 << 8);  ///< External interrupt 4 input select bit
        constexpr uint32_t EINT03S = (2 << 6);  ///< External interrupt 3 input select bit
        constexpr uint32_t EINT02S = (2 << 4);  ///< External interrupt 2 input select bit
        constexpr uint32_t EINT01S = (2 << 2);  ///< External interrupt 1 input select bit
        constexpr uint32_t EINT00S = (2 << 0);  ///< External interrupt 0 input select bit
    }

    /// EPFR07 Register bits
    namespace epfr07_bits {
        constexpr uint32_t SCK3B = (2 << 26);  ///< SCK3 input/output select bit
        constexpr uint32_t SOT3B = (2 << 24);  ///< SOT3B input/output select bit
        constexpr uint32_t SIN3S = (2 << 22);  ///< SIN3S input select bit
        constexpr uint32_t SCK2B = (2 << 20);  ///< SCK2 input/output select bit
        constexpr uint32_t SOT2B = (2 << 18);  ///< SOT2B input/output select bit
        constexpr uint32_t SIN2S = (2 << 16);  ///< SIN2S input select bit
        constexpr uint32_t SCK1B = (2 << 14);  ///< SCK1 input/output select bit
        constexpr uint32_t SOT1B = (2 << 12);  ///< SCK1B input/output select bit
        constexpr uint32_t SIN1S = (2 << 10);  ///< SIN1S input select bit
        constexpr uint32_t SCK0B = (2 << 8);  ///< SCK0 input/output select bit
        constexpr uint32_t SOT0B = (2 << 6);  ///< SOT0B input/output select bit
        constexpr uint32_t SIN0S = (2 << 4);  ///< SIN0S input select bit
    }

    /// EPFR08 Register bits
    namespace epfr08_bits {
        constexpr uint32_t SCK7B = (2 << 26);  ///< SCK7 input/output select bit
        constexpr uint32_t SOT7B = (2 << 24);  ///< SOT7B input/output select bit
        constexpr uint32_t SIN7S = (2 << 22);  ///< SIN7S input select bit
        constexpr uint32_t SCK6B = (2 << 20);  ///< SCK6 input/output select bit
        constexpr uint32_t SOT6B = (2 << 18);  ///< SOT6B input/output select bit
        constexpr uint32_t SIN6S = (2 << 16);  ///< SIN6S input select bit
        constexpr uint32_t SCK5B = (2 << 14);  ///< SCK5 input/output select bit
        constexpr uint32_t SOT5B = (2 << 12);  ///< SOT5B input/output select bit
        constexpr uint32_t SIN5S = (2 << 10);  ///< SIN5S input select bit
        constexpr uint32_t SCK4B = (2 << 8);  ///< SCK4 input/output select bit
        constexpr uint32_t SOT4B = (2 << 6);  ///< SOT4B input/output select bit
        constexpr uint32_t SIN4S = (2 << 4);  ///< SIN4S input select bit
        constexpr uint32_t CTS4S = (2 << 2);  ///< CTS4S input select bit
        constexpr uint32_t RTS4E = (2 << 0);  ///< RTS4E output select bit
    }

    /// EPFR09 Register bits
    namespace epfr09_bits {
        constexpr uint32_t ADTRG1S = (4 << 16);  ///< ADTRG1 input select bit
        constexpr uint32_t ADTRG0S = (4 << 12);  ///< ADTRG0 input select bit
    }

    /// EPFR10 Register bits
    namespace epfr10_bits {
        constexpr uint32_t UEA24E = (1U << 31);  ///< UEA24E output select bit
        constexpr uint32_t UEA23E = (1U << 30);  ///< UEA23E output select bit
        constexpr uint32_t UEA22E = (1U << 29);  ///< UEA22E output select bit
        constexpr uint32_t UEA21E = (1U << 28);  ///< UEA21E output select bit
        constexpr uint32_t UEA20E = (1U << 27);  ///< UEA20E output select bit
        constexpr uint32_t UEA19E = (1U << 26);  ///< UEA19E output select bit
        constexpr uint32_t UEA18E = (1U << 25);  ///< UEA18E output select bit
        constexpr uint32_t UEA17E = (1U << 24);  ///< UEA17E output select bit
        constexpr uint32_t UEA16E = (1U << 23);  ///< UEA16E output select bit
        constexpr uint32_t UEA15E = (1U << 22);  ///< UEA15E output select bit
        constexpr uint32_t UEA14E = (1U << 21);  ///< UEA14E output select bit
        constexpr uint32_t UEA13E = (1U << 20);  ///< UEA13E output select bit
        constexpr uint32_t UEA12E = (1U << 19);  ///< UEA12E output select bit
        constexpr uint32_t UEA11E = (1U << 18);  ///< UEA11E output select bit
        constexpr uint32_t UEA10E = (1U << 17);  ///< UEA10E output select bit
        constexpr uint32_t UEA09E = (1U << 16);  ///< UEA09E output select bit
        constexpr uint32_t UEA08E = (1U << 15);  ///< UEA08E output select bit
        constexpr uint32_t UEAOOE = (1U << 14);  ///< UEAOOE output select bit
        constexpr uint32_t UECS7E = (1U << 13);  ///< UECS7E output select bit
        constexpr uint32_t UECS6E = (1U << 12);  ///< UECS6E output select bit
        constexpr uint32_t UECS5E = (1U << 11);  ///< UECS5E output select bit
        constexpr uint32_t UECS4E = (1U << 10);  ///< UECS4E output select bit
        constexpr uint32_t UECS3E = (1U << 9);  ///< UECS3E output select bit
        constexpr uint32_t UECS2E = (1U << 8);  ///< UECS2E output select bit
        constexpr uint32_t UECS1E = (1U << 7);  ///< UECS1E output select bit
        constexpr uint32_t UEFLSE = (1U << 6);  ///< UEFLSE output select bit
        constexpr uint32_t UEOEXE = (1U << 5);  ///< UEOEXE output select bit
        constexpr uint32_t UEDQME = (1U << 4);  ///< UEDQME output select bit
        constexpr uint32_t UEWEXE = (1U << 3);  ///< UEWEXE output select bit
        constexpr uint32_t UECLKE = (1U << 2);  ///< UECLKE output select bit
        constexpr uint32_t UEDTHB = (1U << 1);  ///< UEDTHB input/output select bit
        constexpr uint32_t UEDEFB = (1U << 0);  ///< UEDEFB input/output select bit
    }

    /// EPFR11 Register bits
    namespace epfr11_bits {
        constexpr uint32_t UERLC = (1U << 25);  ///< UERLC relocation select bit
        constexpr uint32_t UED15B = (1U << 24);  ///< UED15B input/output select bit
        constexpr uint32_t UED14B = (1U << 23);  ///< UED14B output select bit
        constexpr uint32_t UED13B = (1U << 22);  ///< UED13B output select bit
        constexpr uint32_t UED12B = (1U << 21);  ///< UED12B output select bit
        constexpr uint32_t UED11B = (1U << 20);  ///< UED11B output select bit
        constexpr uint32_t UED10B = (1U << 19);  ///< UED10B output select bit
        constexpr uint32_t UED09B = (1U << 18);  ///< UED09B output select bit
        constexpr uint32_t UED08B = (1U << 17);  ///< UED08B output select bit
        constexpr uint32_t UED07B = (1U << 16);  ///< UED07B output select bit
        constexpr uint32_t UED06B = (1U << 15);  ///< UED06B output select bit
        constexpr uint32_t UED05B = (1U << 14);  ///< UED05B output select bit
        constexpr uint32_t UED04B = (1U << 13);  ///< UED04B output select bit
        constexpr uint32_t UED03B = (1U << 12);  ///< UED03B output select bit
        constexpr uint32_t UED02B = (1U << 11);  ///< UED02B output select bit
        constexpr uint32_t UED01B = (1U << 10);  ///< UED01B output select bit
        constexpr uint32_t UED00B = (1U << 9);  ///< UED00B output select bit
        constexpr uint32_t UEA07E = (1U << 8);  ///< UEA07E output select bit
        constexpr uint32_t UEA06E = (1U << 7);  ///< UEA06E output select bit
        constexpr uint32_t UEA05E = (1U << 6);  ///< UEA05E output select bit
        constexpr uint32_t UEA04E = (1U << 5);  ///< UEA04E output select bit
        constexpr uint32_t UEA03E = (1U << 4);  ///< UEA03E output select bit
        constexpr uint32_t UEA02E = (1U << 3);  ///< UEA02E output select bit
        constexpr uint32_t UEA01E = (1U << 2);  ///< UEA01E output select bit
        constexpr uint32_t UECS0E = (1U << 1);  ///< UECS0E output select bit
        constexpr uint32_t UEALEE = (1U << 0);  ///< UEALEE output select bit
    }

    /// EPFR14 Register bits
    namespace epfr14_bits {
        constexpr uint32_t CEC1B = (1U << 31);  ///< CEC1 Input/Output Select bit
        constexpr uint32_t CEC0B = (1U << 30);  ///< CEC0 Input/Output Select bit
    }

    /// PZR0 Register bits
    namespace pzr0_bits {
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of PZR0
        constexpr uint32_t PB = (1U << 11);  ///< Bit11 of PZR0
        constexpr uint32_t PA = (1U << 10);  ///< Bit10 of PZR0
    }

    /// PZR4 Register bits
    namespace pzr4_bits {
        constexpr uint32_t PE = (1U << 14);  ///< Bit14 of PZR4
        constexpr uint32_t PD = (1U << 13);  ///< Bit13 of PZR4
        constexpr uint32_t PC = (1U << 12);  ///< Bit12 of PZR4
    }

    /// PZR6 Register bits
    namespace pzr6_bits {
        constexpr uint32_t P0 = (1U << 0);  ///< Bit0 of PZR6
    }

}

// ============================================================================
// HDMICEC0 Peripheral
// ============================================================================

namespace hdmicec0 {
    /// Base addresses
    constexpr uint32_t HDMICEC0_BASE = 0x40034000;

    /// HDMICEC0 Register structure
    struct Registers {
        volatile uint32_t TXCTRL;  ///< Offset: 0x00 - Transmission Control Register
        volatile uint32_t TXDATA;  ///< Offset: 0x04 - Transmission Data Register
        volatile uint32_t TXSTS;  ///< Offset: 0x08 - Transmission Status Register
        volatile uint32_t SFREE;  ///< Offset: 0x0C - Signal Free Time Setting Register
        volatile uint32_t RCST;  ///< Offset: 0x40 - Reception Interrupt Control Register
        volatile uint32_t RCCR;  ///< Offset: 0x41 - Reception Control Register
        volatile uint32_t RCDAHW;  ///< Offset: 0x44 - "H" Width Setting Register A
        volatile uint32_t RCSHW;  ///< Offset: 0x45 - Start Bit "H" Width Setting Register
        volatile uint32_t RCDBHW;  ///< Offset: 0x49 - "H" Width Setting Register B
        volatile uint32_t RCADR2;  ///< Offset: 0x4C - Device Address Setting Register 2
        volatile uint32_t RCADR1;  ///< Offset: 0x4D - Device Address Setting Register 1
        volatile uint32_t RCDTHL;  ///< Offset: 0x50 - Data Save Register (High-Low)
        volatile uint32_t RCDTHH;  ///< Offset: 0x51 - Data Save Register (High-High)
        volatile uint32_t RCDTLL;  ///< Offset: 0x54 - Data Save Register (Low-Low)
        volatile uint32_t RCDTLH;  ///< Offset: 0x55 - Data Save Register (Low-High)
        volatile uint32_t RCCKD;  ///< Offset: 0x58 - Clock Division Setting Register
        volatile uint32_t RCRHW;  ///< Offset: 0x5C - Repeat Code "H" Width Setting Register
        volatile uint32_t RCRC;  ///< Offset: 0x5D - Repeat Code Interrupt Control Register
        volatile uint32_t RCLE;  ///< Offset: 0x61 - Data Bit Width Violation Control Register
        volatile uint32_t RCLESW;  ///< Offset: 0x64 - Minimum Data Bit Width Setting Register
        volatile uint32_t RCLELW;  ///< Offset: 0x65 - Maximum Data Bit Width Setting Register
    };

    /// Peripheral instances
    inline Registers* HDMICEC0 = reinterpret_cast<Registers*>(HDMICEC0_BASE);

    // Bit definitions
    /// TXCTRL Register bits
    namespace txctrl_bits {
        constexpr uint32_t IBREN = (1U << 5);  ///< Bus error detection interrupt enable bit
        constexpr uint32_t ITSTEN = (1U << 4);  ///< transmission status interrupt enable bit
        constexpr uint32_t EOM = (1U << 3);  ///< EOM setting bit
        constexpr uint32_t START = (1U << 2);  ///< START setting bit
        constexpr uint32_t TXEN = (1U << 0);  ///< Transmission operation enable bit
    }

    /// TXDATA Register bits
    namespace txdata_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< Transmission Data
    }

    /// TXSTS Register bits
    namespace txsts_bits {
        constexpr uint32_t IBR = (1U << 5);  ///< Bus error detection interrupt request bit
        constexpr uint32_t ITST = (1U << 4);  ///< Transmission status interrupt request bit
        constexpr uint32_t ACKSV = (1U << 0);  ///< ACK cycle value bit
    }

    /// SFREE Register bits
    namespace sfree_bits {
        constexpr uint32_t SFREE = (4 << 0);  ///< Signal free time setting bits
    }

    /// RCST Register bits
    namespace rcst_bits {
        constexpr uint32_t STIE = (1U << 7);  ///< Start bit interrupt enable bit
        constexpr uint32_t ACKIE = (1U << 6);  ///< ACK interrupt enable bit
        constexpr uint32_t OVFIE = (1U << 5);  ///< Counter overflow interrupt enable bit
        constexpr uint32_t OVFSEL = (1U << 4);  ///< Counter overflow detection condition setting bit
        constexpr uint32_t ST = (1U << 3);  ///< Start bit detection bit
        constexpr uint32_t ACK = (1U << 2);  ///< ACK: ACK detection bit
        constexpr uint32_t EOM = (1U << 1);  ///< EOM detection bit
        constexpr uint32_t OVF = (1U << 0);  ///< Counter overflow detection bit
    }

    /// RCCR Register bits
    namespace rccr_bits {
        constexpr uint32_t THSEL = (1U << 7);  ///< Threshold selection bit
        constexpr uint32_t ADRCE = (1U << 3);  ///< Address comparison enable bit
        constexpr uint32_t MOD1 = (1U << 2);  ///< Operation mode setting bits
        constexpr uint32_t MOD0 = (1U << 1);  ///< Operation mode setting bits
        constexpr uint32_t EN = (1U << 0);  ///< Operation enable bit
    }

    /// RCDAHW Register bits
    namespace rcdahw_bits {
        constexpr uint32_t RCDAHW = (8 << 0);  ///< "H" Width Setting A
    }

    /// RCSHW Register bits
    namespace rcshw_bits {
        constexpr uint32_t RCSHW = (8 << 0);  ///< Start Bit "H" Width Setting
    }

    /// RCDBHW Register bits
    namespace rcdbhw_bits {
        constexpr uint32_t RCDBHW = (8 << 0);  ///< "H" Width Setting B
    }

    /// RCADR2 Register bits
    namespace rcadr2_bits {
        constexpr uint32_t RCADR2 = (5 << 0);  ///< Device Address 2
    }

    /// RCADR1 Register bits
    namespace rcadr1_bits {
        constexpr uint32_t RCADR1 = (5 << 0);  ///< Device Address 1
    }

    /// RCDTHL Register bits
    namespace rcdthl_bits {
        constexpr uint32_t RCDTHL = (8 << 0);  ///< RCDTHL
    }

    /// RCDTHH Register bits
    namespace rcdthh_bits {
        constexpr uint32_t RCDTHH = (8 << 0);  ///< RCDTHH
    }

    /// RCDTLL Register bits
    namespace rcdtll_bits {
        constexpr uint32_t RCDTLL = (8 << 0);  ///< RCDTLL
    }

    /// RCDTLH Register bits
    namespace rcdtlh_bits {
        constexpr uint32_t RCDTLH = (8 << 0);  ///< RCDTLH
    }

    /// RCCKD Register bits
    namespace rcckd_bits {
        constexpr uint32_t CKSEL = (1U << 12);  ///< Operating clock selection bit
        constexpr uint32_t CKDIV = (12 << 0);  ///< Operating clock division setting bits
    }

    /// RCRHW Register bits
    namespace rcrhw_bits {
        constexpr uint32_t RCRHW = (8 << 0);  ///< "Repeat code "H" width setting bits"
    }

    /// RCRC Register bits
    namespace rcrc_bits {
        constexpr uint32_t RCIE = (1U << 4);  ///< Repeat Code Interrupt enable bit
        constexpr uint32_t RC = (1U << 0);  ///< Repeat code detection flag bit
    }

    /// RCLE Register bits
    namespace rcle_bits {
        constexpr uint32_t LELIE = (1U << 7);  ///< Maximum data bit width violation interrupt enable bit
        constexpr uint32_t LESIE = (1U << 6);  ///< Minimum data bit width violation interrupt enable bit
        constexpr uint32_t LELE = (1U << 5);  ///< Maximum data bit width violation detection enable bit
        constexpr uint32_t LESE = (1U << 4);  ///< Minimum data bit width violation detection enable bit
        constexpr uint32_t EPE = (1U << 3);  ///< Error pulse output enable bit
        constexpr uint32_t LEL = (1U << 1);  ///< Maximum data bit width violation detection flag bit
        constexpr uint32_t LES = (1U << 0);  ///< Minimum data bit width violation detection flag bit
    }

    /// RCLESW Register bits
    namespace rclesw_bits {
        constexpr uint32_t RCLESW = (8 << 0);  ///< Minimum data bit width setting bits
    }

    /// RCLELW Register bits
    namespace rclelw_bits {
        constexpr uint32_t RCLELW = (8 << 0);  ///< Maximum data bit width setting bits
    }

}

// ============================================================================
// HDMICEC1 Peripheral
// ============================================================================

namespace hdmicec1 {
    /// Base addresses
    constexpr uint32_t HDMICEC1_BASE = 0x40034100;

    /// HDMICEC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HDMICEC1 = reinterpret_cast<Registers*>(HDMICEC1_BASE);

}

// ============================================================================
// LVD Peripheral
// ============================================================================

namespace lvd {
    /// Base addresses
    constexpr uint32_t LVD_BASE = 0x40035000;

    /// LVD Register structure
    struct Registers {
        volatile uint32_t LVD_CTL;  ///< Offset: 0x00 - Low-voltage Detection Voltage Control Register
        volatile uint32_t LVD_STR;  ///< Offset: 0x04 - Low-voltage Detection Interrupt Register
        volatile uint32_t LVD_CLR;  ///< Offset: 0x08 - Low-voltage Detection Interrupt Clear Register
        volatile uint32_t LVD_RLR;  ///< Offset: 0x0C - Low-voltage Detection Voltage Protection Register
        volatile uint32_t LVD_STR2;  ///< Offset: 0x10 - Low-voltage Detection Circuit Status Register
    };

    /// Peripheral instances
    inline Registers* LVD = reinterpret_cast<Registers*>(LVD_BASE);

    // Bit definitions
    /// LVD_CTL Register bits
    namespace lvd_ctl_bits {
        constexpr uint32_t LVDRE = (1U << 15);  ///< Low-voltage detection reset operation enable bit
        constexpr uint32_t SVHR = (5 << 10);  ///< Low-voltage detection reset voltage setting bits
        constexpr uint32_t LVDIE = (1U << 7);  ///< Low-voltage detection interrupt enable bit
        constexpr uint32_t SVHI = (5 << 2);  ///< Low-voltage detection interrupt voltage setting bits
    }

    /// LVD_STR Register bits
    namespace lvd_str_bits {
        constexpr uint32_t LVDIR = (1U << 7);  ///< Low-voltage detection interrupt bit
    }

    /// LVD_CLR Register bits
    namespace lvd_clr_bits {
        constexpr uint32_t LVDCL = (1U << 7);  ///< Low-voltage detection interrupt clear bit
    }

    /// LVD_RLR Register bits
    namespace lvd_rlr_bits {
        constexpr uint32_t LVDLCK = (32 << 0);  ///< Low-voltage Detection Voltage Control Register protection bits
    }

    /// LVD_STR2 Register bits
    namespace lvd_str2_bits {
        constexpr uint32_t LVDIRDY = (1U << 7);  ///< Low-voltage detection interrupt status flag
        constexpr uint32_t LVDRRDY = (1U << 6);  ///< Low-voltage detection reset status flag
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x40035100;

    /// DS Register structure
    struct Registers {
        volatile uint32_t REG_CTL;  ///< Offset: 0x00 - Sub Oscillation Circuit Power Supply Control Register
        volatile uint32_t RCK_CTL;  ///< Offset: 0x04 - Sub Clock Control Register
        volatile uint32_t PMD_CTL;  ///< Offset: 0x700 - RTC Mode Control Register
        volatile uint32_t WRFSR;  ///< Offset: 0x704 - Deep Standby Return Cause Register 1
        volatile uint32_t WIFSR;  ///< Offset: 0x708 - Deep Standby Return Cause Register 2
        volatile uint32_t WIER;  ///< Offset: 0x70C - Deep Standby Return Enable Register
        volatile uint32_t WILVR;  ///< Offset: 0x710 - WKUP Pin Input Level Register
        volatile uint32_t DSRAMR;  ///< Offset: 0x714 - Deep Standby RAM Retention Register
        volatile uint32_t BUR01;  ///< Offset: 0x800 - Backup Registers from 1
        volatile uint32_t BUR02;  ///< Offset: 0x801 - Backup Registers from 2
        volatile uint32_t BUR03;  ///< Offset: 0x802 - Backup Registers from 3
        volatile uint32_t BUR04;  ///< Offset: 0x803 - Backup Registers from 4
        volatile uint32_t BUR05;  ///< Offset: 0x804 - Backup Registers from 5
        volatile uint32_t BUR06;  ///< Offset: 0x805 - Backup Registers from 6
        volatile uint32_t BUR07;  ///< Offset: 0x806 - Backup Registers from 7
        volatile uint32_t BUR08;  ///< Offset: 0x807 - Backup Registers from 8
        volatile uint32_t BUR09;  ///< Offset: 0x808 - Backup Registers from 9
        volatile uint32_t BUR10;  ///< Offset: 0x809 - Backup Registers from 10
        volatile uint32_t BUR11;  ///< Offset: 0x80A - Backup Registers from 11
        volatile uint32_t BUR12;  ///< Offset: 0x80B - Backup Registers from 12
        volatile uint32_t BUR13;  ///< Offset: 0x80C - Backup Registers from 13
        volatile uint32_t BUR14;  ///< Offset: 0x80D - Backup Registers from 14
        volatile uint32_t BUR15;  ///< Offset: 0x80E - Backup Registers from 15
        volatile uint32_t BUR16;  ///< Offset: 0x80F - Backup Registers from 16
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// REG_CTL Register bits
    namespace reg_ctl_bits {
        constexpr uint32_t ISUBSEL = (2 << 1);  ///< Sub oscillation circuit current setting bits
    }

    /// RCK_CTL Register bits
    namespace rck_ctl_bits {
        constexpr uint32_t CECCKE = (1U << 1);  ///< CEC clock control bit
        constexpr uint32_t RTCCKE = (1U << 0);  ///< RTC clock control bit
    }

    /// PMD_CTL Register bits
    namespace pmd_ctl_bits {
        constexpr uint32_t RTCE = (1U << 0);  ///< RTC mode control bit
    }

    /// WRFSR Register bits
    namespace wrfsr_bits {
        constexpr uint32_t WLVDH = (1U << 1);  ///< Low-voltage detection reset return bit
        constexpr uint32_t WINITX = (1U << 0);  ///< INITX pin input reset return bit
    }

    /// WIFSR Register bits
    namespace wifsr_bits {
        constexpr uint32_t WCEC1I = (1U << 9);  ///< CEC ch.1 interrupt return bit
        constexpr uint32_t WCEC0I = (1U << 8);  ///< CEC ch.0 interrupt return bit
        constexpr uint32_t WUI3 = (1U << 5);  ///< WKUP pin input return bit 3
        constexpr uint32_t WUI2 = (1U << 4);  ///< WKUP pin input return bit 2
        constexpr uint32_t WUI1 = (1U << 3);  ///< WKUP pin input return bit 1
        constexpr uint32_t WUI0 = (1U << 2);  ///< WKUP pin input return bit 0
        constexpr uint32_t WLVDI = (1U << 1);  ///< LVD interrupt return bit
        constexpr uint32_t WRTCI = (1U << 0);  ///< RTC interrupt return bit
    }

    /// WIER Register bits
    namespace wier_bits {
        constexpr uint32_t WCEC1E = (1U << 9);  ///< HDMI-CEC/ Remote Control Reception ch.1 interrupt return enable bit
        constexpr uint32_t WCEC0E = (1U << 8);  ///< HDMI-CEC/ Remote Control Reception ch.0 interrupt return enable bit
        constexpr uint32_t WUI3E = (1U << 5);  ///< WKUP pin input return enable bit 3
        constexpr uint32_t WUI2E = (1U << 4);  ///< WKUP pin input return enable bit 2
        constexpr uint32_t WUI1E = (1U << 3);  ///< WKUP pin input return enable bit 1
        constexpr uint32_t WLVDE = (1U << 1);  ///< LVD interrupt return enable bit
        constexpr uint32_t WRTCE = (1U << 0);  ///< RTC interrupt return enable bit
    }

    /// WILVR Register bits
    namespace wilvr_bits {
        constexpr uint32_t WUI3LV = (1U << 2);  ///< WKUP pin input level select bit 3
        constexpr uint32_t WUI2LV = (1U << 1);  ///< WKUP pin input level select bit 2
        constexpr uint32_t WUI1LV = (1U << 0);  ///< WKUP pin input level select bit 1
    }

    /// DSRAMR Register bits
    namespace dsramr_bits {
        constexpr uint32_t SRAMR = (2 << 0);  ///< On-chip SRAM retention control bits
    }

}

// ============================================================================
// MFS0 Peripheral
// ============================================================================

namespace mfs0 {
    /// Base addresses
    constexpr uint32_t MFS0_BASE = 0x40038000;

    /// MFS0 Register structure
    struct Registers {
        volatile uint32_t UART_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t UART_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t UART_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t UART_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t UART_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t UART_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t UART_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t CSIO_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t CSIO_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t CSIO_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t CSIO_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t CSIO_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t CSIO_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t CSIO_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t I2C_IBCR;  ///< Offset: 0x01 - I2C Bus Control Register
        volatile uint32_t I2C_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t I2C_IBSR;  ///< Offset: 0x04 - I2C Bus Status Register
        volatile uint32_t I2C_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t I2C_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t I2C_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t I2C_ISMK;  ///< Offset: 0x11 - 7-bit Slave Address Mask Register
        volatile uint32_t I2C_ISBA;  ///< Offset: 0x10 - 7-bit Slave Address Register
        volatile uint32_t I2C_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t I2C_EIBCR;  ///< Offset: 0x1D - Extension I2C Bus Control Register
    };

    /// Peripheral instances
    inline Registers* MFS0 = reinterpret_cast<Registers*>(MFS0_BASE);

    // Bit definitions
    /// UART_SCR Register bits
    namespace uart_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable Clear bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Received operation enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Transmission operation enable bit
    }

    /// UART_SMR Register bits
    namespace uart_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bit
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t SBL = (1U << 3);  ///< Stop bit length select bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// UART_SSR Register bits
    namespace uart_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t PE = (1U << 5);  ///< Parity error flag bit (only functions in operation mode 0)
        constexpr uint32_t FRE = (1U << 4);  ///< Framing error flag bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag
    }

    /// UART_ESCR Register bits
    namespace uart_escr_bits {
        constexpr uint32_t FLWEN = (1U << 7);  ///< Flow control enable bit
        constexpr uint32_t ESBL = (1U << 6);  ///< Extension stop bit length select bit
        constexpr uint32_t INV = (1U << 5);  ///< Inverted serial data format bit
        constexpr uint32_t PEN = (1U << 4);  ///< Parity enable bit (only functions in operation mode 0)
        constexpr uint32_t P = (1U << 3);  ///< Parity select bit (only functions in operation mode 0)
        constexpr uint32_t L = (3 << 0);  ///< Data length select bit
    }

    /// UART_BGR Register bits
    namespace uart_bgr_bits {
        constexpr uint32_t EXT = (1U << 15);  ///< External clock select bit
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// CSIO_SCR Register bits
    namespace csio_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable clear bit
        constexpr uint32_t MS = (1U << 6);  ///< Master/Slave function select bit
        constexpr uint32_t SPI = (1U << 5);  ///< SPI corresponding bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Data received enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Data transmission enable bit
    }

    /// CSIO_SMR Register bits
    namespace csio_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bits
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t SCINV = (1U << 3);  ///< Serial clock invert bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SCKE = (1U << 1);  ///< Master mode serial clock output enable bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// CSIO_SSR Register bits
    namespace csio_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit
    }

    /// CSIO_ESCR Register bits
    namespace csio_escr_bits {
        constexpr uint32_t SOP = (1U << 7);  ///< Serial output pin set bit
        constexpr uint32_t WT = (2 << 3);  ///< Data transmit/received wait select bits
        constexpr uint32_t L = (3 << 0);  ///< Data length select bits
    }

    /// CSIO_BGR Register bits
    namespace csio_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// I2C_IBCR Register bits
    namespace i2c_ibcr_bits {
        constexpr uint32_t MSS = (1U << 7);  ///< Master/slave select bit
        constexpr uint32_t ACT_SCC = (1U << 6);  ///< Operation flag/iteration start condition generation bit
        constexpr uint32_t ACKE = (1U << 5);  ///< Data byte acknowledge enable bit
        constexpr uint32_t WSEL = (1U << 4);  ///< Wait selection bit
        constexpr uint32_t CNDE = (1U << 3);  ///< Condition detection interrupt enable bit
        constexpr uint32_t INTE = (1U << 2);  ///< Interrupt enable bit
        constexpr uint32_t BER = (1U << 1);  ///< Bus error flag bit
        constexpr uint32_t INT_ = (1U << 0);  ///< interrupt flag bit (renamed from INT_)
    }

    /// I2C_SMR Register bits
    namespace i2c_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< operation mode set bits
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t RIE = (1U << 3);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 2);  ///< Transmit interrupt enable bit
    }

    /// I2C_IBSR Register bits
    namespace i2c_ibsr_bits {
        constexpr uint32_t FBT = (1U << 7);  ///< First byte bit
        constexpr uint32_t RACK = (1U << 6);  ///< Acknowledge flag bit
        constexpr uint32_t RSA = (1U << 5);  ///< Reserved address detection bit
        constexpr uint32_t TRX = (1U << 4);  ///< Data direction bit
        constexpr uint32_t AL = (1U << 3);  ///< Arbitration lost bit
        constexpr uint32_t RSC = (1U << 2);  ///< Iteration start condition check bit
        constexpr uint32_t SPC = (1U << 1);  ///< Stop condition check bit
        constexpr uint32_t BB = (1U << 0);  ///< Bus state bit
    }

    /// I2C_SSR Register bits
    namespace i2c_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t TSET = (1U << 6);  ///< Transmit empty flag set bit
        constexpr uint32_t DMA = (1U << 5);  ///< DMA mode enable bit
        constexpr uint32_t TBIE = (1U << 4);  ///< Transmit bus idle interrupt enable bit (Effective only when DMA mode is enabled)
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit (Effective only when DMA mode is enabled)
    }

    /// I2C_ISMK Register bits
    namespace i2c_ismk_bits {
        constexpr uint32_t EN = (1U << 7);  ///< I2C interface operation enable bit
        constexpr uint32_t SM = (7 << 0);  ///< Slave address mask bits
    }

    /// I2C_ISBA Register bits
    namespace i2c_isba_bits {
        constexpr uint32_t SAEN = (1U << 7);  ///< Slave address enable bit
        constexpr uint32_t SA = (7 << 0);  ///< 7-bit slave address
    }

    /// I2C_BGR Register bits
    namespace i2c_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// I2C_EIBCR Register bits
    namespace i2c_eibcr_bits {
        constexpr uint32_t SDAS = (1U << 5);  ///< SDA status bit
        constexpr uint32_t SCLS = (1U << 4);  ///< SCL status bit
        constexpr uint32_t SDAC = (1U << 3);  ///< SDA output control bit
        constexpr uint32_t SCLC = (1U << 2);  ///< SCL output control bit
        constexpr uint32_t SOCE = (1U << 1);  ///< Serial output enabled bit
        constexpr uint32_t BEC = (1U << 0);  ///< Bus error control bit
    }

}

// ============================================================================
// MFS1 Peripheral
// ============================================================================

namespace mfs1 {
    /// Base addresses
    constexpr uint32_t MFS1_BASE = 0x40038100;

    /// MFS1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS1 = reinterpret_cast<Registers*>(MFS1_BASE);

}

// ============================================================================
// MFS2 Peripheral
// ============================================================================

namespace mfs2 {
    /// Base addresses
    constexpr uint32_t MFS2_BASE = 0x40038200;

    /// MFS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS2 = reinterpret_cast<Registers*>(MFS2_BASE);

}

// ============================================================================
// MFS3 Peripheral
// ============================================================================

namespace mfs3 {
    /// Base addresses
    constexpr uint32_t MFS3_BASE = 0x40038300;

    /// MFS3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS3 = reinterpret_cast<Registers*>(MFS3_BASE);

}

// ============================================================================
// MFS4 Peripheral
// ============================================================================

namespace mfs4 {
    /// Base addresses
    constexpr uint32_t MFS4_BASE = 0x40038400;

    /// MFS4 Register structure
    struct Registers {
        volatile uint32_t UART_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t UART_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t UART_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t UART_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t UART_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t UART_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t UART_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t UART_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t UART_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t UART_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t UART_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t CSIO_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t CSIO_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t CSIO_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t CSIO_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t CSIO_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t CSIO_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t CSIO_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t CSIO_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t CSIO_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t CSIO_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t CSIO_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t I2C_IBCR;  ///< Offset: 0x01 - I2C Bus Control Register
        volatile uint32_t I2C_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t I2C_IBSR;  ///< Offset: 0x04 - I2C Bus Status Register
        volatile uint32_t I2C_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t I2C_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t I2C_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t I2C_ISMK;  ///< Offset: 0x11 - 7-bit Slave Address Mask Register
        volatile uint32_t I2C_ISBA;  ///< Offset: 0x10 - 7-bit Slave Address Register
        volatile uint32_t I2C_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t I2C_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t I2C_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t I2C_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t I2C_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t I2C_EIBCR;  ///< Offset: 0x1D - Extension I2C Bus Control Register
    };

    /// Peripheral instances
    inline Registers* MFS4 = reinterpret_cast<Registers*>(MFS4_BASE);

    // Bit definitions
    /// UART_SCR Register bits
    namespace uart_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable Clear bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Received operation enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Transmission operation enable bit
    }

    /// UART_SMR Register bits
    namespace uart_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bit
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t SBL = (1U << 3);  ///< Stop bit length select bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// UART_SSR Register bits
    namespace uart_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t PE = (1U << 5);  ///< Parity error flag bit (only functions in operation mode 0)
        constexpr uint32_t FRE = (1U << 4);  ///< Framing error flag bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag
    }

    /// UART_ESCR Register bits
    namespace uart_escr_bits {
        constexpr uint32_t FLWEN = (1U << 7);  ///< Flow control enable bit
        constexpr uint32_t ESBL = (1U << 6);  ///< Extension stop bit length select bit
        constexpr uint32_t INV = (1U << 5);  ///< Inverted serial data format bit
        constexpr uint32_t PEN = (1U << 4);  ///< Parity enable bit (only functions in operation mode 0)
        constexpr uint32_t P = (1U << 3);  ///< Parity select bit (only functions in operation mode 0)
        constexpr uint32_t L = (3 << 0);  ///< Data length select bit
    }

    /// UART_BGR Register bits
    namespace uart_bgr_bits {
        constexpr uint32_t EXT = (1U << 15);  ///< External clock select bit
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// UART_FCR1 Register bits
    namespace uart_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// UART_FCR0 Register bits
    namespace uart_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// CSIO_SCR Register bits
    namespace csio_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable clear bit
        constexpr uint32_t MS = (1U << 6);  ///< Master/Slave function select bit
        constexpr uint32_t SPI = (1U << 5);  ///< SPI corresponding bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Data received enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Data transmission enable bit
    }

    /// CSIO_SMR Register bits
    namespace csio_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bits
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t SCINV = (1U << 3);  ///< Serial clock invert bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SCKE = (1U << 1);  ///< Master mode serial clock output enable bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// CSIO_SSR Register bits
    namespace csio_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit
    }

    /// CSIO_ESCR Register bits
    namespace csio_escr_bits {
        constexpr uint32_t SOP = (1U << 7);  ///< Serial output pin set bit
        constexpr uint32_t WT = (2 << 3);  ///< Data transmit/received wait select bits
        constexpr uint32_t L = (3 << 0);  ///< Data length select bits
    }

    /// CSIO_BGR Register bits
    namespace csio_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// CSIO_FCR1 Register bits
    namespace csio_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// CSIO_FCR0 Register bits
    namespace csio_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// I2C_IBCR Register bits
    namespace i2c_ibcr_bits {
        constexpr uint32_t MSS = (1U << 7);  ///< Master/slave select bit
        constexpr uint32_t ACT_SCC = (1U << 6);  ///< Operation flag/iteration start condition generation bit
        constexpr uint32_t ACKE = (1U << 5);  ///< Data byte acknowledge enable bit
        constexpr uint32_t WSEL = (1U << 4);  ///< Wait selection bit
        constexpr uint32_t CNDE = (1U << 3);  ///< Condition detection interrupt enable bit
        constexpr uint32_t INTE = (1U << 2);  ///< Interrupt enable bit
        constexpr uint32_t BER = (1U << 1);  ///< Bus error flag bit
        constexpr uint32_t INT_ = (1U << 0);  ///< interrupt flag bit (renamed from INT_)
    }

    /// I2C_SMR Register bits
    namespace i2c_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< operation mode set bits
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t RIE = (1U << 3);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 2);  ///< Transmit interrupt enable bit
    }

    /// I2C_IBSR Register bits
    namespace i2c_ibsr_bits {
        constexpr uint32_t FBT = (1U << 7);  ///< First byte bit
        constexpr uint32_t RACK = (1U << 6);  ///< Acknowledge flag bit
        constexpr uint32_t RSA = (1U << 5);  ///< Reserved address detection bit
        constexpr uint32_t TRX = (1U << 4);  ///< Data direction bit
        constexpr uint32_t AL = (1U << 3);  ///< Arbitration lost bit
        constexpr uint32_t RSC = (1U << 2);  ///< Iteration start condition check bit
        constexpr uint32_t SPC = (1U << 1);  ///< Stop condition check bit
        constexpr uint32_t BB = (1U << 0);  ///< Bus state bit
    }

    /// I2C_SSR Register bits
    namespace i2c_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t TSET = (1U << 6);  ///< Transmit empty flag set bit
        constexpr uint32_t DMA = (1U << 5);  ///< DMA mode enable bit
        constexpr uint32_t TBIE = (1U << 4);  ///< Transmit bus idle interrupt enable bit (Effective only when DMA mode is enabled)
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit (Effective only when DMA mode is enabled)
    }

    /// I2C_ISMK Register bits
    namespace i2c_ismk_bits {
        constexpr uint32_t EN = (1U << 7);  ///< I2C interface operation enable bit
        constexpr uint32_t SM = (7 << 0);  ///< Slave address mask bits
    }

    /// I2C_ISBA Register bits
    namespace i2c_isba_bits {
        constexpr uint32_t SAEN = (1U << 7);  ///< Slave address enable bit
        constexpr uint32_t SA = (7 << 0);  ///< 7-bit slave address
    }

    /// I2C_BGR Register bits
    namespace i2c_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// I2C_FCR1 Register bits
    namespace i2c_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// I2C_FCR0 Register bits
    namespace i2c_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// I2C_EIBCR Register bits
    namespace i2c_eibcr_bits {
        constexpr uint32_t SDAS = (1U << 5);  ///< SDA status bit
        constexpr uint32_t SCLS = (1U << 4);  ///< SCL status bit
        constexpr uint32_t SDAC = (1U << 3);  ///< SDA output control bit
        constexpr uint32_t SCLC = (1U << 2);  ///< SCL output control bit
        constexpr uint32_t SOCE = (1U << 1);  ///< Serial output enabled bit
        constexpr uint32_t BEC = (1U << 0);  ///< Bus error control bit
    }

}

// ============================================================================
// MFS5 Peripheral
// ============================================================================

namespace mfs5 {
    /// Base addresses
    constexpr uint32_t MFS5_BASE = 0x40038500;

    /// MFS5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS5 = reinterpret_cast<Registers*>(MFS5_BASE);

}

// ============================================================================
// MFS6 Peripheral
// ============================================================================

namespace mfs6 {
    /// Base addresses
    constexpr uint32_t MFS6_BASE = 0x40038600;

    /// MFS6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS6 = reinterpret_cast<Registers*>(MFS6_BASE);

}

// ============================================================================
// MFS7 Peripheral
// ============================================================================

namespace mfs7 {
    /// Base addresses
    constexpr uint32_t MFS7_BASE = 0x40038700;

    /// MFS7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS7 = reinterpret_cast<Registers*>(MFS7_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003B000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t WTCR1;  ///< Offset: 0x00 - Control Register 1
        volatile uint32_t WTCR2;  ///< Offset: 0x04 - Control Register 2
        volatile uint32_t WTBR;  ///< Offset: 0x08 - Counter Cycle Setting Register
        volatile uint32_t WTDR;  ///< Offset: 0x0F - Date Register
        volatile uint32_t WTHR;  ///< Offset: 0x0E - Hour register
        volatile uint32_t WTMIR;  ///< Offset: 0x0D - Minute Register
        volatile uint32_t WTSR;  ///< Offset: 0x0C - Second Register
        volatile uint32_t WTYR;  ///< Offset: 0x12 - Year Register
        volatile uint32_t WTMOR;  ///< Offset: 0x11 - Month Register
        volatile uint32_t WTDW;  ///< Offset: 0x10 - Day of the Week Register
        volatile uint32_t ALDR;  ///< Offset: 0x17 - Alarm Date Register
        volatile uint32_t ALHR;  ///< Offset: 0x16 - Alarm Hour Register
        volatile uint32_t ALMIR;  ///< Offset: 0x15 - Alarm Minute Register
        volatile uint32_t ALYR;  ///< Offset: 0x1A - Alarm Years Register
        volatile uint32_t ALMOR;  ///< Offset: 0x19 - Alarm Month Register
        volatile uint32_t WTTR;  ///< Offset: 0x1C - Timer Setting Register
        volatile uint32_t WTCLKS;  ///< Offset: 0x20 - Clock Selection Register
        volatile uint32_t WTCLKM;  ///< Offset: 0x21 - Selection Clock Status Register
        volatile uint32_t WTCAL;  ///< Offset: 0x24 - Frequency Correction Value Setting Register
        volatile uint32_t WTCALEN;  ///< Offset: 0x26 - Frequency Correction Enable Register
        volatile uint32_t WTDIV;  ///< Offset: 0x28 - Divider Ratio Setting Register
        volatile uint32_t WTDIVEN;  ///< Offset: 0x29 - Divider Output Enable Register
        volatile uint32_t WTCALPRD;  ///< Offset: 0x2C - Frequency Correction Cycle Setting Register
        volatile uint32_t WTCOSEL;  ///< Offset: 0x30 - RTCCO Output Selection Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// WTCR1 Register bits
    namespace wtcr1_bits {
        constexpr uint32_t INTCRIE = (1U << 31);  ///< Year/month/date/hour/minute/second/day of the week counter value read completion interrupt enable bit
        constexpr uint32_t INTERIE = (1U << 30);  ///< Time rewrite error interrupt enable bit
        constexpr uint32_t INTALIE = (1U << 29);  ///< Alarm interrupt enable bit
        constexpr uint32_t INTTMIE = (1U << 28);  ///< Timer interrupt enable bit
        constexpr uint32_t INTHIE = (1U << 27);  ///< 1-hour interrupt enable bit
        constexpr uint32_t INTMIE = (1U << 26);  ///< 1-minute interrupt enable bit
        constexpr uint32_t INTSIE = (1U << 25);  ///< 1-second interrupt enable bit
        constexpr uint32_t INTSSIE = (1U << 24);  ///< 0.5-second interrupt enable bit
        constexpr uint32_t INTCRI = (1U << 23);  ///< Year/month/date/hour/minute/second/day of the week counter value read completion interrupt flag bit
        constexpr uint32_t INTERI = (1U << 22);  ///< Time rewrite error interrupt flag bit
        constexpr uint32_t INTALI = (1U << 21);  ///< Alarm interrupt flag bit
        constexpr uint32_t INTTMI = (1U << 20);  ///< Timer interrupt flag bit
        constexpr uint32_t INTHI = (1U << 19);  ///< 1-hour interrupt flag bit
        constexpr uint32_t INTMI = (1U << 18);  ///< 1-minute interrupt flag bit
        constexpr uint32_t INTSI = (1U << 17);  ///< 1-second interrupt flag bit
        constexpr uint32_t INTSSI = (1U << 16);  ///< 0.5-second interrupt flag bit
        constexpr uint32_t YEN = (1U << 12);  ///< Alarm year register enable bit
        constexpr uint32_t MOEN = (1U << 11);  ///< Alarm month register enable bit
        constexpr uint32_t DEN = (1U << 10);  ///< Alarm date register enable bit
        constexpr uint32_t HEN = (1U << 9);  ///< Alarm hour register enable bit
        constexpr uint32_t MIEN = (1U << 8);  ///< Alarm minute register enable bit
        constexpr uint32_t BUSY = (1U << 6);  ///< Busy bit
        constexpr uint32_t SCRST = (1U << 5);  ///< Sub second generation/1-second generation counter reset bit
        constexpr uint32_t SCST = (1U << 4);  ///< 1-second clock output stop bit
        constexpr uint32_t SRST = (1U << 3);  ///< RTC reset bit
        constexpr uint32_t RUN = (1U << 2);  ///< RTC count block operation bit
        constexpr uint32_t ST = (1U << 0);  ///< Start bit
    }

    /// WTCR2 Register bits
    namespace wtcr2_bits {
        constexpr uint32_t TMRUN = (1U << 10);  ///< Timer counter operation bit
        constexpr uint32_t TMEN = (1U << 9);  ///< Timer counter control bit
        constexpr uint32_t TMST = (1U << 8);  ///< Timer counter start bit
        constexpr uint32_t CREAD = (1U << 0);  ///< Year/month/date/hour/minute/second/day of the week counter value read control bit
    }

    /// WTBR Register bits
    namespace wtbr_bits {
        constexpr uint32_t BR23 = (1U << 23);  ///< Bit23 of WTBR
        constexpr uint32_t BR22 = (1U << 22);  ///< Bit22 of WTBR
        constexpr uint32_t BR21 = (1U << 21);  ///< Bit21 of WTBR
        constexpr uint32_t BR20 = (1U << 20);  ///< Bit20 of WTBR
        constexpr uint32_t BR19 = (1U << 19);  ///< Bit19 of WTBR
        constexpr uint32_t BR18 = (1U << 18);  ///< Bit18 of WTBR
        constexpr uint32_t BR17 = (1U << 17);  ///< Bit17 of WTBR
        constexpr uint32_t BR16 = (1U << 16);  ///< Bit16 of WTBR
        constexpr uint32_t BR15 = (1U << 15);  ///< Bit15 of WTBR
        constexpr uint32_t BR14 = (1U << 14);  ///< Bit14 of WTBR
        constexpr uint32_t BR13 = (1U << 13);  ///< Bit13 of WTBR
        constexpr uint32_t BR12 = (1U << 12);  ///< Bit12 of WTBR
        constexpr uint32_t BR11 = (1U << 11);  ///< Bit11 of WTBR
        constexpr uint32_t BR10 = (1U << 10);  ///< Bit10 of WTBR
        constexpr uint32_t BR9 = (1U << 9);  ///< Bit9 of WTBR
        constexpr uint32_t BR8 = (1U << 8);  ///< Bit8 of WTBR
        constexpr uint32_t BR7 = (1U << 7);  ///< Bit7 of WTBR
        constexpr uint32_t BR6 = (1U << 6);  ///< Bit6 of WTBR
        constexpr uint32_t BR5 = (1U << 5);  ///< Bit5 of WTBR
        constexpr uint32_t BR4 = (1U << 4);  ///< Bit4 of WTBR
        constexpr uint32_t BR3 = (1U << 3);  ///< Bit3 of WTBR
        constexpr uint32_t BR2 = (1U << 2);  ///< Bit2 of WTBR
        constexpr uint32_t BR1 = (1U << 1);  ///< Bit1 of WTBR
        constexpr uint32_t BR0 = (1U << 0);  ///< Bit0 of WTBR
    }

    /// WTDR Register bits
    namespace wtdr_bits {
        constexpr uint32_t TD = (2 << 4);  ///< the second digit of the date
        constexpr uint32_t D = (4 << 0);  ///< the first digit of the date
    }

    /// WTHR Register bits
    namespace wthr_bits {
        constexpr uint32_t TH = (2 << 4);  ///< the second digit of the hour
        constexpr uint32_t H = (4 << 0);  ///< the first digit of the hour
    }

    /// WTMIR Register bits
    namespace wtmir_bits {
        constexpr uint32_t TMI = (3 << 4);  ///< the second digit of the minute
        constexpr uint32_t MI = (4 << 0);  ///< the first digit of the minute
    }

    /// WTSR Register bits
    namespace wtsr_bits {
        constexpr uint32_t TS = (3 << 4);  ///< the second digit of the second
        constexpr uint32_t S = (4 << 0);  ///< the first digit of the second
    }

    /// WTYR Register bits
    namespace wtyr_bits {
        constexpr uint32_t TY = (4 << 4);  ///< the second digit of the year
        constexpr uint32_t Y = (4 << 0);  ///< the first digit of the year
    }

    /// WTMOR Register bits
    namespace wtmor_bits {
        constexpr uint32_t TMO = (1U << 4);  ///< the second digit in the month
        constexpr uint32_t MO = (4 << 0);  ///< the first digit of the month
    }

    /// WTDW Register bits
    namespace wtdw_bits {
        constexpr uint32_t DW = (3 << 0);  ///< Day of the week
    }

    /// ALDR Register bits
    namespace aldr_bits {
        constexpr uint32_t TAD = (2 << 4);  ///< the second digit of the alarm-set date
        constexpr uint32_t AD = (4 << 0);  ///< the first digit of the alarm-set date
    }

    /// ALHR Register bits
    namespace alhr_bits {
        constexpr uint32_t TAH = (2 << 4);  ///< the second digit of the alarm-set hour
        constexpr uint32_t AH = (4 << 0);  ///< the first digit of the alarm-set hour
    }

    /// ALMIR Register bits
    namespace almir_bits {
        constexpr uint32_t TAMI = (3 << 4);  ///< the second digit of the alarm-set minute
        constexpr uint32_t AMI = (4 << 0);  ///< the first digit of the alarm-set minute
    }

    /// ALYR Register bits
    namespace alyr_bits {
        constexpr uint32_t TAY = (4 << 4);  ///< the second digit of the alarm-set year
        constexpr uint32_t AY = (4 << 0);  ///< the first digit of the alarm-set year
    }

    /// ALMOR Register bits
    namespace almor_bits {
        constexpr uint32_t TAMO = (1U << 4);  ///< the second digit of the alarm-set month
        constexpr uint32_t AMO = (4 << 0);  ///< the first digit of the alarm-set month
    }

    /// WTTR Register bits
    namespace wttr_bits {
        constexpr uint32_t TM17 = (1U << 17);  ///< Bit17 of WTTR
        constexpr uint32_t TM16 = (1U << 16);  ///< Bit16 of WTTR
        constexpr uint32_t TM15 = (1U << 15);  ///< Bit15 of WTTR
        constexpr uint32_t TM14 = (1U << 14);  ///< Bit14 of WTTR
        constexpr uint32_t TM13 = (1U << 13);  ///< Bit13 of WTTR
        constexpr uint32_t TM12 = (1U << 12);  ///< Bit12 of WTTR
        constexpr uint32_t TM11 = (1U << 11);  ///< Bit11 of WTTR
        constexpr uint32_t TM10 = (1U << 10);  ///< Bit10 of WTTR
        constexpr uint32_t TM9 = (1U << 9);  ///< Bit9 of WTTR
        constexpr uint32_t TM8 = (1U << 8);  ///< Bit8 of WTTR
        constexpr uint32_t TM7 = (1U << 7);  ///< Bit7 of WTTR
        constexpr uint32_t TM6 = (1U << 6);  ///< Bit6 of WTTR
        constexpr uint32_t TM5 = (1U << 5);  ///< Bit5 of WTTR
        constexpr uint32_t TM4 = (1U << 4);  ///< Bit4 of WTTR
        constexpr uint32_t TM3 = (1U << 3);  ///< Bit3 of WTTR
        constexpr uint32_t TM2 = (1U << 2);  ///< Bit2 of WTTR
        constexpr uint32_t TM1 = (1U << 1);  ///< Bit1 of WTTR
        constexpr uint32_t TM0 = (1U << 0);  ///< Bit0 of WTTR
    }

    /// WTCLKS Register bits
    namespace wtclks_bits {
        constexpr uint32_t WTCLKS = (1U << 0);  ///< Input clock selection bit
    }

    /// WTCLKM Register bits
    namespace wtclkm_bits {
        constexpr uint32_t WTCLKM = (2 << 0);  ///< Clock selection status bit
    }

    /// WTCAL Register bits
    namespace wtcal_bits {
        constexpr uint32_t WTCAL = (10 << 0);  ///< Frequency correction value
    }

    /// WTCALEN Register bits
    namespace wtcalen_bits {
        constexpr uint32_t WTCALEN = (1U << 0);  ///< Frequency correction enable bit
    }

    /// WTDIV Register bits
    namespace wtdiv_bits {
        constexpr uint32_t WTDIV = (4 << 0);  ///< Divider ratio
    }

    /// WTDIVEN Register bits
    namespace wtdiven_bits {
        constexpr uint32_t WTDIVRDY = (1U << 1);  ///< Divider status bit
        constexpr uint32_t WTDIVEN = (1U << 0);  ///< Divider enable bit
    }

    /// WTCALPRD Register bits
    namespace wtcalprd_bits {
        constexpr uint32_t WTCALPRD = (6 << 0);  ///< frequency correction value
    }

    /// WTCOSEL Register bits
    namespace wtcosel_bits {
        constexpr uint32_t WTCOSEL = (1U << 0);  ///< RTCCO output selection bit
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40039000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR;  ///< Offset: 0x00 - CRC Control Register
        volatile uint32_t CRCINIT;  ///< Offset: 0x04 - Initial Value Register
        volatile uint32_t CRCIN;  ///< Offset: 0x08 - Input Data Register
        volatile uint32_t CRCR;  ///< Offset: 0x0C - CRC Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR Register bits
    namespace crccr_bits {
        constexpr uint32_t FXOR = (1U << 6);  ///< Initialization bit
        constexpr uint32_t CRCLSF = (1U << 5);  ///< Final XOR control bit
        constexpr uint32_t CRCLTE = (1U << 4);  ///< CRC result bit-order setting bit
        constexpr uint32_t LSBFST = (1U << 3);  ///< CRC result byte-order setting bit
        constexpr uint32_t LTLEND = (1U << 2);  ///< Bit-order setting bit
        constexpr uint32_t CRC32 = (1U << 1);  ///< Byte-order setting bit
        constexpr uint32_t INIT = (1U << 0);  ///< CRC mode selection bit
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t D = (32 << 0);  ///< Initial value
    }

    /// CRCIN Register bits
    namespace crcin_bits {
        constexpr uint32_t D = (32 << 0);  ///< Input data
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t D = (32 << 0);  ///< CRC Data
    }

}

// ============================================================================
// EXBUS Peripheral
// ============================================================================

namespace exbus {
    /// Base addresses
    constexpr uint32_t EXBUS_BASE = 0x4003F000;

    /// EXBUS Register structure
    struct Registers {
        volatile uint32_t MODE0;  ///< Offset: 0x00 - Mode Register 0
        volatile uint32_t MODE1;  ///< Offset: 0x04 - Mode Register 1
        volatile uint32_t MODE2;  ///< Offset: 0x08 - Mode Register 2
        volatile uint32_t MODE3;  ///< Offset: 0x0C - Mode Register 3
        volatile uint32_t MODE4;  ///< Offset: 0x10 - Mode Register 4
        volatile uint32_t MODE5;  ///< Offset: 0x14 - Mode Register 5
        volatile uint32_t MODE6;  ///< Offset: 0x18 - Mode Register 6
        volatile uint32_t MODE7;  ///< Offset: 0x1C - Mode Register 7
        volatile uint32_t TIM0;  ///< Offset: 0x20 - Timing Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - Timing Register 1
        volatile uint32_t TIM2;  ///< Offset: 0x28 - Timing Register 2
        volatile uint32_t TIM3;  ///< Offset: 0x2C - Timing Register 3
        volatile uint32_t TIM4;  ///< Offset: 0x30 - Timing Register 4
        volatile uint32_t TIM5;  ///< Offset: 0x34 - Timing Register 5
        volatile uint32_t TIM6;  ///< Offset: 0x38 - Timing Register 6
        volatile uint32_t TIM7;  ///< Offset: 0x3C - Timing Register 7
        volatile uint32_t AREA0;  ///< Offset: 0x40 - Area Register 0
        volatile uint32_t AREA1;  ///< Offset: 0x44 - Area Register 1
        volatile uint32_t AREA2;  ///< Offset: 0x48 - Area Register 2
        volatile uint32_t AREA3;  ///< Offset: 0x4C - Area Register 3
        volatile uint32_t AREA4;  ///< Offset: 0x50 - Area Register 4
        volatile uint32_t AREA5;  ///< Offset: 0x54 - Area Register 5
        volatile uint32_t AREA6;  ///< Offset: 0x58 - Area Register 6
        volatile uint32_t AREA7;  ///< Offset: 0x5C - Area Register 7
        volatile uint32_t ATIM0;  ///< Offset: 0x60 - ALE Timing Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x64 - ALE Timing Register 1
        volatile uint32_t ATIM2;  ///< Offset: 0x68 - ALE Timing Register 2
        volatile uint32_t ATIM3;  ///< Offset: 0x6C - ALE Timing Register 3
        volatile uint32_t ATIM4;  ///< Offset: 0x70 - ALE Timing Register 4
        volatile uint32_t ATIM5;  ///< Offset: 0x74 - ALE Timing Register 5
        volatile uint32_t ATIM6;  ///< Offset: 0x78 - ALE Timing Register 6
        volatile uint32_t ATIM7;  ///< Offset: 0x7C - ALE Timing Register 7
        volatile uint32_t DCLKR;  ///< Offset: 0x300 - Division Clock Register
    };

    /// Peripheral instances
    inline Registers* EXBUS = reinterpret_cast<Registers*>(EXBUS_BASE);

    // Bit definitions
    /// MODE0 Register bits
    namespace mode0_bits {
        constexpr uint32_t MOEXEUP = (1U << 13);  ///< select how to set the MOEX width
        constexpr uint32_t MPXCSOF = (1U << 12);  ///< select a CS assertion from the start of accessing to the end of address output
        constexpr uint32_t MPXDOFF = (1U << 11);  ///< select whether or not the address is output to the data lines in multiplex mode
        constexpr uint32_t ALEINV = (1U << 9);  ///< set up the polarity of the ALE signal
        constexpr uint32_t MPXMODE = (1U << 8);  ///< select operation bus mode
        constexpr uint32_t SHRTDOUT = (1U << 7);  ///< select to which idle cycle the write data output is extended
        constexpr uint32_t RDY = (1U << 6);  ///< control the external RDY function
        constexpr uint32_t PAGE = (1U << 5);  ///< NOR Flash memory page access mode
        constexpr uint32_t NAND = (1U << 4);  ///< NAND Flash memory mode
        constexpr uint32_t WEOFF = (1U << 3);  ///< disable the write enable signal (MWEX) operation
        constexpr uint32_t RBMON = (1U << 2);  ///< Read Byte Mask ON
        constexpr uint32_t WDTH = (2 << 0);  ///< specify Data Width
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t WIDLC = (4 << 28);  ///< Write Idle Cycle
        constexpr uint32_t WWEC = (4 << 24);  ///< Write Enable Cycle
        constexpr uint32_t WADC = (4 << 20);  ///< Write Address Setup cycle
        constexpr uint32_t WACC = (4 << 16);  ///< Write Access Cycle
        constexpr uint32_t RIDLC = (4 << 12);  ///< Read Idle Cycle
        constexpr uint32_t FRADC = (4 << 8);  ///< First Read Address Cycle
        constexpr uint32_t RADC = (4 << 4);  ///< Read Address Setup cycle
        constexpr uint32_t RACC = (4 << 0);  ///< Read Access Cycle
    }

    /// AREA0 Register bits
    namespace area0_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA1 Register bits
    namespace area1_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA2 Register bits
    namespace area2_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA3 Register bits
    namespace area3_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA4 Register bits
    namespace area4_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA5 Register bits
    namespace area5_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA6 Register bits
    namespace area6_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA7 Register bits
    namespace area7_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ALEW = (4 << 8);  ///< Address Latch Enable Width
        constexpr uint32_t ALES = (4 << 4);  ///< Address Latch Enable Setup cycle
        constexpr uint32_t ALC = (4 << 0);  ///< Address Latch Cycle
    }

    /// DCLKR Register bits
    namespace dclkr_bits {
        constexpr uint32_t MCLKON = (1U << 4);  ///< MCLK ON
        constexpr uint32_t MDIV = (4 << 0);  ///< MCLK Division Ratio Setup
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x40060000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMACR;  ///< Offset: 0x00 - Entire DMAC Configuration Register
        volatile uint32_t DMACA0;  ///< Offset: 0x10 - Configuration A Register
        volatile uint32_t DMACB0;  ///< Offset: 0x14 - Configuration B Register
        volatile uint32_t DMACSA0;  ///< Offset: 0x18 - Transfer Source Address Register
        volatile uint32_t DMACDA0;  ///< Offset: 0x1C - Transfer Destination Address Register
        volatile uint32_t DMACA1;  ///< Offset: 0x20 - Configuration A Register 1
        volatile uint32_t DMACB1;  ///< Offset: 0x24 - Configuration B Register 1
        volatile uint32_t DMACSA1;  ///< Offset: 0x28 - Transfer Source Address Register 1
        volatile uint32_t DMACDA1;  ///< Offset: 0x2C - Transfer Destination Address Register 1
        volatile uint32_t DMACA2;  ///< Offset: 0x30 - Configuration A Register 2
        volatile uint32_t DMACB2;  ///< Offset: 0x34 - Configuration B Register 2
        volatile uint32_t DMACSA2;  ///< Offset: 0x38 - Transfer Source Address Register 2
        volatile uint32_t DMACDA2;  ///< Offset: 0x3C - Transfer Destination Address Register 2
        volatile uint32_t DMACA3;  ///< Offset: 0x40 - Configuration A Register 3
        volatile uint32_t DMACB3;  ///< Offset: 0x44 - Configuration B Register 3
        volatile uint32_t DMACSA3;  ///< Offset: 0x48 - Transfer Source Address Register 3
        volatile uint32_t DMACDA3;  ///< Offset: 0x4C - Transfer Destination Address Register 3
        volatile uint32_t DMACA4;  ///< Offset: 0x50 - Configuration A Register 4
        volatile uint32_t DMACB4;  ///< Offset: 0x54 - Configuration B Register 4
        volatile uint32_t DMACSA4;  ///< Offset: 0x58 - Transfer Source Address Register 4
        volatile uint32_t DMACDA4;  ///< Offset: 0x5C - Transfer Destination Address Register 4
        volatile uint32_t DMACA5;  ///< Offset: 0x60 - Configuration A Register 5
        volatile uint32_t DMACB5;  ///< Offset: 0x64 - Configuration B Register 5
        volatile uint32_t DMACSA5;  ///< Offset: 0x68 - Transfer Source Address Register 5
        volatile uint32_t DMACDA5;  ///< Offset: 0x6C - Transfer Destination Address Register 5
        volatile uint32_t DMACA6;  ///< Offset: 0x70 - Configuration A Register 6
        volatile uint32_t DMACB6;  ///< Offset: 0x74 - Configuration B Register 6
        volatile uint32_t DMACSA6;  ///< Offset: 0x78 - Transfer Source Address Register 6
        volatile uint32_t DMACDA6;  ///< Offset: 0x7C - Transfer Destination Address Register 6
        volatile uint32_t DMACA7;  ///< Offset: 0x80 - Configuration A Register 7
        volatile uint32_t DMACB7;  ///< Offset: 0x84 - Configuration B Register 7
        volatile uint32_t DMACSA7;  ///< Offset: 0x88 - Transfer Source Address Register 7
        volatile uint32_t DMACDA7;  ///< Offset: 0x8C - Transfer Destination Address Register 7
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

    // Bit definitions
    /// DMACR Register bits
    namespace dmacr_bits {
        constexpr uint32_t DE = (1U << 31);  ///< DMA Enable (all-channel operation enable bit)
        constexpr uint32_t DS = (1U << 30);  ///< DMA Stop
        constexpr uint32_t PR = (1U << 28);  ///< Priority Rotation
        constexpr uint32_t DH = (4 << 24);  ///< DMA Halt (All-channel pause bit)
    }

    /// DMACA0 Register bits
    namespace dmaca0_bits {
        constexpr uint32_t EB = (1U << 31);  ///< Enable bit (individual-channel operation enable bit)
        constexpr uint32_t PB = (1U << 30);  ///< Pause bit (individual-channel pause bit)
        constexpr uint32_t ST = (1U << 29);  ///< Software Trigger
        constexpr uint32_t IS = (6 << 23);  ///< Input Select
        constexpr uint32_t BC = (4 << 16);  ///< Block Count
        constexpr uint32_t TC = (16 << 0);  ///< Transfer Count
    }

    /// DMACB0 Register bits
    namespace dmacb0_bits {
        constexpr uint32_t MS = (2 << 28);  ///< Mode Select
        constexpr uint32_t TW = (2 << 26);  ///< Transfer Width
        constexpr uint32_t FS = (1U << 25);  ///< Fixed Source
        constexpr uint32_t FD = (1U << 24);  ///< Fixed Destination
        constexpr uint32_t RC = (1U << 23);  ///< Reload Count (BC/TC reload)
        constexpr uint32_t RS = (1U << 22);  ///< Reload Source
        constexpr uint32_t RD = (1U << 21);  ///< Reload Destination
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt (unsuccessful transfer completion interrupt enable)
        constexpr uint32_t CI = (1U << 19);  ///< Completion Interrupt (successful transfer completion interrupt enable)
        constexpr uint32_t SS = (3 << 16);  ///< Stop Status (stop status notification)
        constexpr uint32_t EM = (1U << 0);  ///< Enable bit Mask (EB bit clear mask)
    }

}


} // namespace alloy::generated::mb9afa4xn

#endif // ALLOY_GENERATED_MB9AFA4XN_PERIPHERALS_HPP