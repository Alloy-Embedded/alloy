/// Auto-generated code for MK70F15WS
/// Generated by Alloy Code Generator
/// Source: nxp_mk70.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:18
#ifndef ALLOY_GENERATED_MK70F15WS_PERIPHERALS_HPP
#define ALLOY_GENERATED_MK70F15WS_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mk70f15ws {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips0 = true;
    constexpr uint32_t num_aips0_instances = 1;
    constexpr bool has_aips1 = true;
    constexpr uint32_t num_aips1_instances = 1;
    constexpr bool has_axbs = true;
    constexpr uint32_t num_axbs_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 3;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_ftfe = true;
    constexpr uint32_t num_ftfe_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 2;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 3;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_ftm3 = true;
    constexpr uint32_t num_ftm3_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 4;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_dry = true;
    constexpr uint32_t num_dry_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 6;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc0 = true;
    constexpr uint32_t num_osc0_instances = 1;
    constexpr bool has_osc1 = true;
    constexpr uint32_t num_osc1_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_cmp3 = true;
    constexpr uint32_t num_cmp3_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_nfc = true;
    constexpr uint32_t num_nfc_instances = 1;
    constexpr bool has_ddr = true;
    constexpr uint32_t num_ddr_instances = 1;
    constexpr bool has_sdhc = true;
    constexpr uint32_t num_sdhc_instances = 1;
    constexpr bool has_lcdc = true;
    constexpr uint32_t num_lcdc_instances = 1;
    constexpr bool has_enet = true;
    constexpr uint32_t num_enet_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_pta = true;
    constexpr uint32_t num_pta_instances = 1;
    constexpr bool has_ptb = true;
    constexpr uint32_t num_ptb_instances = 1;
    constexpr bool has_ptc = true;
    constexpr uint32_t num_ptc_instances = 1;
    constexpr bool has_ptd = true;
    constexpr uint32_t num_ptd_instances = 1;
    constexpr bool has_pte = true;
    constexpr uint32_t num_pte_instances = 1;
    constexpr bool has_ptf = true;
    constexpr uint32_t num_ptf_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;
    constexpr bool has_cau = true;
    constexpr uint32_t num_cau_instances = 1;
    constexpr bool has_lmem = true;
    constexpr uint32_t num_lmem_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axbs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfe_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dry_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nfc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ddr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct enet_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pta_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pte_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cau_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lmem_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 6;
    constexpr uint32_t max_gpio_pins = 96;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFE_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFE_FlashConfig = reinterpret_cast<Registers*>(FTFE_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t EZPORT_DIS = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// AIPS0 Peripheral
// ============================================================================

namespace aips0 {
    /// Base addresses
    constexpr uint32_t AIPS0_BASE = 0x40000000;

    /// AIPS0 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS0 = reinterpret_cast<Registers*>(AIPS0_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL7 = (1U << 0);  ///< Master privilege level
        constexpr uint32_t MTW7 = (1U << 1);  ///< Master trusted for writes
        constexpr uint32_t MTR7 = (1U << 2);  ///< Master trusted for read
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t MPL6 = (1U << 4);  ///< Master privilege level
        constexpr uint32_t MTW6 = (1U << 5);  ///< Master trusted for writes
        constexpr uint32_t MTR6 = (1U << 6);  ///< Master trusted for read
        constexpr uint32_t MPL5 = (1U << 8);  ///< Master privilege level
        constexpr uint32_t MTW5 = (1U << 9);  ///< Master trusted for writes
        constexpr uint32_t MTR5 = (1U << 10);  ///< Master trusted for read
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master privilege level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master trusted for writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master trusted for read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master privilege level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master trusted for writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master trusted for read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master privilege level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master trusted for writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master trusted for read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master privilege level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master trusted for writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master trusted for read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

}

// ============================================================================
// AIPS1 Peripheral
// ============================================================================

namespace aips1 {
    /// Base addresses
    constexpr uint32_t AIPS1_BASE = 0x40080000;

    /// AIPS1 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS1 = reinterpret_cast<Registers*>(AIPS1_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL7 = (1U << 0);  ///< Master privilege level
        constexpr uint32_t MTW7 = (1U << 1);  ///< Master trusted for writes
        constexpr uint32_t MTR7 = (1U << 2);  ///< Master trusted for read
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t MPL6 = (1U << 4);  ///< Master privilege level
        constexpr uint32_t MTW6 = (1U << 5);  ///< Master trusted for writes
        constexpr uint32_t MTR6 = (1U << 6);  ///< Master trusted for read
        constexpr uint32_t MPL5 = (1U << 8);  ///< Master privilege level
        constexpr uint32_t MTW5 = (1U << 9);  ///< Master trusted for writes
        constexpr uint32_t MTR5 = (1U << 10);  ///< Master trusted for read
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master privilege level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master trusted for writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master trusted for read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master privilege level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master trusted for writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master trusted for read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master privilege level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master trusted for writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master trusted for read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master privilege level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master trusted for writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master trusted for read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

}

// ============================================================================
// AXBS Peripheral
// ============================================================================

namespace axbs {
    /// Base addresses
    constexpr uint32_t AXBS_BASE = 0x40004000;

    /// AXBS Register structure
    struct Registers {
        volatile uint32_t PRS;  ///< Offset: 0x00 - Priority Registers Slave (renamed from PRS)
        volatile uint32_t CRS;  ///< Offset: 0x10 - Control Register (renamed from CRS)
        volatile uint32_t MGPCR;  ///< Offset: 0x800 - Master General Purpose Control Register (renamed from MGPCR)
    };

    /// Peripheral instances
    inline Registers* AXBS = reinterpret_cast<Registers*>(AXBS_BASE);

    // Bit definitions
    /// PRS Register bits
    namespace prs_bits {
        constexpr uint32_t M0 = (3 << 0);  ///< Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t M1 = (3 << 4);  ///< Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M2 = (3 << 8);  ///< Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M3 = (3 << 12);  ///< Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M4 = (3 << 16);  ///< Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M5 = (3 << 20);  ///< Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M6 = (3 << 24);  ///< Master 6 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M7 = (3 << 28);  ///< Master 7 Priority. Sets the arbitration priority for this port on the associated slave port.
    }

    /// CRS Register bits
    namespace crs_bits {
        constexpr uint32_t PARK = (3 << 0);  ///< Park
        constexpr uint32_t RESERVED = (20 << 10);  ///< no description available
        constexpr uint32_t PCTL = (2 << 4);  ///< Parking Control
        constexpr uint32_t ARB = (2 << 8);  ///< Arbitration Mode
        constexpr uint32_t HLP = (1U << 30);  ///< Halt Low Priority
        constexpr uint32_t RO = (1U << 31);  ///< Read Only
    }

    /// MGPCR Register bits
    namespace mgpcr_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
        constexpr uint32_t RESERVED = (29 << 3);  ///< no description available
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX0_BASE = 0x40021000;
    constexpr uint32_t DMAMUX1_BASE = 0x40022000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Enabled and... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX0 = reinterpret_cast<Registers*>(DMAMUX0_BASE);
    inline Registers* DMAMUX1 = reinterpret_cast<Registers*>(DMAMUX1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESERVED = (14 << 18);  ///< no description available
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t ERGA = (1U << 3);  ///< Enable Round Robin Group Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t GRP0PRI = (2 << 8);  ///< Channel Group 0 Priority
        constexpr uint32_t GRP1PRI = (2 << 10);  ///< Channel Group 1 Priority
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (5 << 8);  ///< Error Channel Number or Cancelled Channel Number
        constexpr uint32_t RESERVED = (14 << 17);  ///< no description available
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t GPE = (1U << 15);  ///< Group Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Cancelled
        constexpr uint32_t VLD = (1U << 31);  ///< no description available
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
        constexpr uint32_t ERQ16 = (1U << 16);  ///< Enable DMA Request 16
        constexpr uint32_t ERQ17 = (1U << 17);  ///< Enable DMA Request 17
        constexpr uint32_t ERQ18 = (1U << 18);  ///< Enable DMA Request 18
        constexpr uint32_t ERQ19 = (1U << 19);  ///< Enable DMA Request 19
        constexpr uint32_t ERQ20 = (1U << 20);  ///< Enable DMA Request 20
        constexpr uint32_t ERQ21 = (1U << 21);  ///< Enable DMA Request 21
        constexpr uint32_t ERQ22 = (1U << 22);  ///< Enable DMA Request 22
        constexpr uint32_t ERQ23 = (1U << 23);  ///< Enable DMA Request 23
        constexpr uint32_t ERQ24 = (1U << 24);  ///< Enable DMA Request 24
        constexpr uint32_t ERQ25 = (1U << 25);  ///< Enable DMA Request 25
        constexpr uint32_t ERQ26 = (1U << 26);  ///< Enable DMA Request 26
        constexpr uint32_t ERQ27 = (1U << 27);  ///< Enable DMA Request 27
        constexpr uint32_t ERQ28 = (1U << 28);  ///< Enable DMA Request 28
        constexpr uint32_t ERQ29 = (1U << 29);  ///< Enable DMA Request 29
        constexpr uint32_t ERQ30 = (1U << 30);  ///< Enable DMA Request 30
        constexpr uint32_t ERQ31 = (1U << 31);  ///< Enable DMA Request 31
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
        constexpr uint32_t EEI16 = (1U << 16);  ///< Enable Error Interrupt 16
        constexpr uint32_t EEI17 = (1U << 17);  ///< Enable Error Interrupt 17
        constexpr uint32_t EEI18 = (1U << 18);  ///< Enable Error Interrupt 18
        constexpr uint32_t EEI19 = (1U << 19);  ///< Enable Error Interrupt 19
        constexpr uint32_t EEI20 = (1U << 20);  ///< Enable Error Interrupt 20
        constexpr uint32_t EEI21 = (1U << 21);  ///< Enable Error Interrupt 21
        constexpr uint32_t EEI22 = (1U << 22);  ///< Enable Error Interrupt 22
        constexpr uint32_t EEI23 = (1U << 23);  ///< Enable Error Interrupt 23
        constexpr uint32_t EEI24 = (1U << 24);  ///< Enable Error Interrupt 24
        constexpr uint32_t EEI25 = (1U << 25);  ///< Enable Error Interrupt 25
        constexpr uint32_t EEI26 = (1U << 26);  ///< Enable Error Interrupt 26
        constexpr uint32_t EEI27 = (1U << 27);  ///< Enable Error Interrupt 27
        constexpr uint32_t EEI28 = (1U << 28);  ///< Enable Error Interrupt 28
        constexpr uint32_t EEI29 = (1U << 29);  ///< Enable Error Interrupt 29
        constexpr uint32_t EEI30 = (1U << 30);  ///< Enable Error Interrupt 30
        constexpr uint32_t EEI31 = (1U << 31);  ///< Enable Error Interrupt 31
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (5 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (5 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (5 << 0);  ///< Clear Enable Request
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (5 << 0);  ///< Set Enable Request
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (5 << 0);  ///< Clear DONE Bit
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (5 << 0);  ///< Set START Bit
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (5 << 0);  ///< Clear Error Indicator
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (5 << 0);  ///< Clear interrupt request
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
        constexpr uint32_t INT16 = (1U << 16);  ///< Interrupt Request 16
        constexpr uint32_t INT17 = (1U << 17);  ///< Interrupt Request 17
        constexpr uint32_t INT18 = (1U << 18);  ///< Interrupt Request 18
        constexpr uint32_t INT19 = (1U << 19);  ///< Interrupt Request 19
        constexpr uint32_t INT20 = (1U << 20);  ///< Interrupt Request 20
        constexpr uint32_t INT21 = (1U << 21);  ///< Interrupt Request 21
        constexpr uint32_t INT22 = (1U << 22);  ///< Interrupt Request 22
        constexpr uint32_t INT23 = (1U << 23);  ///< Interrupt Request 23
        constexpr uint32_t INT24 = (1U << 24);  ///< Interrupt Request 24
        constexpr uint32_t INT25 = (1U << 25);  ///< Interrupt Request 25
        constexpr uint32_t INT26 = (1U << 26);  ///< Interrupt Request 26
        constexpr uint32_t INT27 = (1U << 27);  ///< Interrupt Request 27
        constexpr uint32_t INT28 = (1U << 28);  ///< Interrupt Request 28
        constexpr uint32_t INT29 = (1U << 29);  ///< Interrupt Request 29
        constexpr uint32_t INT30 = (1U << 30);  ///< Interrupt Request 30
        constexpr uint32_t INT31 = (1U << 31);  ///< Interrupt Request 31
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
        constexpr uint32_t ERR16 = (1U << 16);  ///< Error In Channel 16
        constexpr uint32_t ERR17 = (1U << 17);  ///< Error In Channel 17
        constexpr uint32_t ERR18 = (1U << 18);  ///< Error In Channel 18
        constexpr uint32_t ERR19 = (1U << 19);  ///< Error In Channel 19
        constexpr uint32_t ERR20 = (1U << 20);  ///< Error In Channel 20
        constexpr uint32_t ERR21 = (1U << 21);  ///< Error In Channel 21
        constexpr uint32_t ERR22 = (1U << 22);  ///< Error In Channel 22
        constexpr uint32_t ERR23 = (1U << 23);  ///< Error In Channel 23
        constexpr uint32_t ERR24 = (1U << 24);  ///< Error In Channel 24
        constexpr uint32_t ERR25 = (1U << 25);  ///< Error In Channel 25
        constexpr uint32_t ERR26 = (1U << 26);  ///< Error In Channel 26
        constexpr uint32_t ERR27 = (1U << 27);  ///< Error In Channel 27
        constexpr uint32_t ERR28 = (1U << 28);  ///< Error In Channel 28
        constexpr uint32_t ERR29 = (1U << 29);  ///< Error In Channel 29
        constexpr uint32_t ERR30 = (1U << 30);  ///< Error In Channel 30
        constexpr uint32_t ERR31 = (1U << 31);  ///< Error In Channel 31
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
        constexpr uint32_t HRS16 = (1U << 16);  ///< Hardware Request Status Channel 16
        constexpr uint32_t HRS17 = (1U << 17);  ///< Hardware Request Status Channel 17
        constexpr uint32_t HRS18 = (1U << 18);  ///< Hardware Request Status Channel 18
        constexpr uint32_t HRS19 = (1U << 19);  ///< Hardware Request Status Channel 19
        constexpr uint32_t HRS20 = (1U << 20);  ///< Hardware Request Status Channel 20
        constexpr uint32_t HRS21 = (1U << 21);  ///< Hardware Request Status Channel 21
        constexpr uint32_t HRS22 = (1U << 22);  ///< Hardware Request Status Channel 22
        constexpr uint32_t HRS23 = (1U << 23);  ///< Hardware Request Status Channel 23
        constexpr uint32_t HRS24 = (1U << 24);  ///< Hardware Request Status Channel 24
        constexpr uint32_t HRS25 = (1U << 25);  ///< Hardware Request Status Channel 25
        constexpr uint32_t HRS26 = (1U << 26);  ///< Hardware Request Status Channel 26
        constexpr uint32_t HRS27 = (1U << 27);  ///< Hardware Request Status Channel 27
        constexpr uint32_t HRS28 = (1U << 28);  ///< Hardware Request Status Channel 28
        constexpr uint32_t HRS29 = (1U << 29);  ///< Hardware Request Status Channel 29
        constexpr uint32_t HRS30 = (1U << 30);  ///< Hardware Request Status Channel 30
        constexpr uint32_t HRS31 = (1U << 31);  ///< Hardware Request Status Channel 31
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable preempt ability. This bit resets to zero.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption. This bit resets to zero.
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source Address Signed Offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination Data Transfer Size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset Enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t RESERVED = (1U << 14);  ///< no description available
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< no description available
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Link Channel Number
        constexpr uint32_t RESERVED = (1U << 13);  ///< no description available
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t RESERVED = (1U << 14);  ///< no description available
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR;  ///< Offset: 0x00 - Chip select address register (renamed from CSAR)
        volatile uint32_t CSMR;  ///< Offset: 0x04 - Chip select mask register (renamed from CSMR)
        volatile uint32_t CSCR;  ///< Offset: 0x08 - Chip select control register (renamed from CSCR)
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip select port multiplexing control register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR Register bits
    namespace csar_bits {
        constexpr uint32_t RESERVED = (16 << 0);  ///< no description available
        constexpr uint32_t BA = (16 << 16);  ///< Base address
    }

    /// CSMR Register bits
    namespace csmr_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t RESERVED = (7 << 9);  ///< no description available
        constexpr uint32_t WP = (1U << 8);  ///< Write protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base address mask
    }

    /// CSCR Register bits
    namespace cscr_bits {
        constexpr uint32_t RESERVED = (2 << 24);  ///< no description available
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-write enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-read enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-enable mode
        constexpr uint32_t PS = (2 << 6);  ///< Port size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-acknowledge enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-lane shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait states
        constexpr uint32_t WRAH = (2 << 16);  ///< Write address hold or deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read address hold or deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address setup
        constexpr uint32_t EXTS = (1U << 22);  ///< no description available
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary wait state enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary wait states
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t RESERVED = (12 << 0);  ///< no description available
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus signal group 5 multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus signal group 4 multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus signal group 3 multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus signal group 2 multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus signal group 1 multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR;  ///< Offset: 0x10 - Error Address Register, Slave Port n (renamed from EAR)
        volatile uint32_t EDR;  ///< Offset: 0x14 - Error Detail Register, Slave Port n (renamed from EDR)
        volatile uint32_t RGD_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0 (renamed from RGD_WORD0)
        volatile uint32_t RGD_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1 (renamed from RGD_WORD1)
        volatile uint32_t RGD_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2 (renamed from RGD_WORD2)
        volatile uint32_t RGD_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3 (renamed from RGD_WORD3)
        volatile uint32_t RGDAAC;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n (renamed from RGDAAC)
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid (global enable/disable for the MPU)
        constexpr uint32_t RESERVED = (1U << 23);  ///< no description available
        constexpr uint32_t NRGD = (4 << 8);  ///< Number of region descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number of slave ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware revision level
        constexpr uint32_t SPERR = (8 << 24);  ///< Slave port n error
    }

    /// EAR Register bits
    namespace ear_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error address
    }

    /// EDR Register bits
    namespace edr_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error read/write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error master number
        constexpr uint32_t EPID = (8 << 8);  ///< Error process identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error access control detail
    }

    /// RGD_WORD0 Register bits
    namespace rgd_word0_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< no description available
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start address
    }

    /// RGD_WORD1 Register bits
    namespace rgd_word1_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< no description available
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End address
    }

    /// RGD_WORD2 Register bits
    namespace rgd_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus master 0 user mode access control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus master 0 supervisor mode access control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus master 0 process identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus master 1 user mode access control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus master 1 supervisor mode access control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus master 1 process identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus master 2 user mode access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus master 2 supervisor mode access control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus master 2 process identifier enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus master 3 user mode access control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus master 3 supervisor mode access control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus master 3 process identifier enable.
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus master 4 write enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus master 4 read enable.
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus master 5 write enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus master 5 read enable.
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus master 6 write enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus master 6 read enable.
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus master 7 write enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus master 7 read enable.
    }

    /// RGD_WORD3 Register bits
    namespace rgd_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t RESERVED = (15 << 1);  ///< no description available
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process identifier mask
        constexpr uint32_t PID = (8 << 24);  ///< Process identifier
    }

    /// RGDAAC Register bits
    namespace rgdaac_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus master 0 user mode access control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus master 0 supervisor mode access control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus master 0 process identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus master 1 user mode access control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus master 1 supervisor mode access control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus master 1 process identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus master 2 user mode access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus master 2 supervisor mode access control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus master 2 process identifier enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus master 3 user mode access control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus master 3 supervisor mode access control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus master 3 process identifier enable.
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus master 4 write enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus master 4 read enable.
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus master 5 write enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus master 5 read enable.
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus master 6 write enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus master 6 read enable.
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus master 7 write enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus master 7 read enable.
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB01CR;  ///< Offset: 0x04 - Flash Bank 0-1 Control Register
        volatile uint32_t PFB23CR;  ///< Offset: 0x08 - Flash Bank 2-3 Control Register
        volatile uint32_t TAGVDW0S;  ///< Offset: 0x100 - Cache Tag Storage (renamed from TAGVDW0S)
        volatile uint32_t TAGVDW1S;  ///< Offset: 0x110 - Cache Tag Storage (renamed from TAGVDW1S)
        volatile uint32_t TAGVDW2S;  ///< Offset: 0x120 - Cache Tag Storage (renamed from TAGVDW2S)
        volatile uint32_t TAGVDW3S;  ///< Offset: 0x130 - Cache Tag Storage (renamed from TAGVDW3S)
        volatile uint32_t DATAW0SUM;  ///< Offset: 0x200 - Cache Data Storage (uppermost word) (renamed from DATAW0SUM)
        volatile uint32_t DATAW0SMU;  ///< Offset: 0x204 - Cache Data Storage (mid-upper word) (renamed from DATAW0SMU)
        volatile uint32_t DATAW0SML;  ///< Offset: 0x208 - Cache Data Storage (mid-lower word) (renamed from DATAW0SML)
        volatile uint32_t DATAW0SLM;  ///< Offset: 0x20C - Cache Data Storage (lowermost word) (renamed from DATAW0SLM)
        volatile uint32_t DATAW1SUM;  ///< Offset: 0x240 - Cache Data Storage (uppermost word) (renamed from DATAW1SUM)
        volatile uint32_t DATAW1SMU;  ///< Offset: 0x244 - Cache Data Storage (mid-upper word) (renamed from DATAW1SMU)
        volatile uint32_t DATAW1SML;  ///< Offset: 0x248 - Cache Data Storage (mid-lower word) (renamed from DATAW1SML)
        volatile uint32_t DATAW1SLM;  ///< Offset: 0x24C - Cache Data Storage (lowermost word) (renamed from DATAW1SLM)
        volatile uint32_t DATAW2SUM;  ///< Offset: 0x280 - Cache Data Storage (uppermost word) (renamed from DATAW2SUM)
        volatile uint32_t DATAW2SMU;  ///< Offset: 0x284 - Cache Data Storage (mid-upper word) (renamed from DATAW2SMU)
        volatile uint32_t DATAW2SML;  ///< Offset: 0x288 - Cache Data Storage (mid-lower word) (renamed from DATAW2SML)
        volatile uint32_t DATAW2SLM;  ///< Offset: 0x28C - Cache Data Storage (lowermost word) (renamed from DATAW2SLM)
        volatile uint32_t DATAW3SUM;  ///< Offset: 0x2C0 - Cache Data Storage (uppermost word) (renamed from DATAW3SUM)
        volatile uint32_t DATAW3SMU;  ///< Offset: 0x2C4 - Cache Data Storage (mid-upper word) (renamed from DATAW3SMU)
        volatile uint32_t DATAW3SML;  ///< Offset: 0x2C8 - Cache Data Storage (mid-lower word) (renamed from DATAW3SML)
        volatile uint32_t DATAW3SLM;  ///< Offset: 0x2CC - Cache Data Storage (lowermost word) (renamed from DATAW3SLM)
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M4AP = (2 << 8);  ///< Master 4 Access Protection
        constexpr uint32_t M5AP = (2 << 10);  ///< Master 5 Access Protection
        constexpr uint32_t M6AP = (2 << 12);  ///< Master 6 Access Protection
        constexpr uint32_t M7AP = (2 << 14);  ///< Master 7 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
        constexpr uint32_t M4PFD = (1U << 20);  ///< Master 4 Prefetch Disable
        constexpr uint32_t M5PFD = (1U << 21);  ///< Master 5 Prefetch Disable
        constexpr uint32_t M6PFD = (1U << 22);  ///< Master 6 Prefetch Disable
        constexpr uint32_t M7PFD = (1U << 23);  ///< Master 7 Prefetch Disable
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
    }

    /// PFB01CR Register bits
    namespace pfb01cr_bits {
        constexpr uint32_t B01SEBE = (1U << 0);  ///< Bank 0-1 Single Entry Buffer Enable
        constexpr uint32_t B01IPE = (1U << 1);  ///< Bank 0-1 Instruction Prefetch Enable
        constexpr uint32_t B01DPE = (1U << 2);  ///< Bank 0-1 Data Prefetch Enable
        constexpr uint32_t B01ICE = (1U << 3);  ///< Bank 0-1 Instruction Cache Enable
        constexpr uint32_t B01DCE = (1U << 4);  ///< Bank 0-1 Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t RESERVED = (1U << 16);  ///< no description available
        constexpr uint32_t B01MW = (2 << 17);  ///< Bank 0-1 Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B01RWSC = (4 << 28);  ///< Bank 0-1 Read Wait State Control
    }

    /// PFB23CR Register bits
    namespace pfb23cr_bits {
        constexpr uint32_t B23SEBE = (1U << 0);  ///< Bank 2-3 Single Entry Buffer Enable
        constexpr uint32_t B23IPE = (1U << 1);  ///< Bank 2-3 Instruction Prefetch Enable
        constexpr uint32_t B23DPE = (1U << 2);  ///< Bank 2-3 Data Prefetch Enable
        constexpr uint32_t B23ICE = (1U << 3);  ///< Bank 2-3 Instruction Cache Enable
        constexpr uint32_t B23DCE = (1U << 4);  ///< Bank 2-3 Data Cache Enable
        constexpr uint32_t RESERVED = (9 << 19);  ///< no description available
        constexpr uint32_t B23MW = (2 << 17);  ///< Bank 2-3 Memory Width
        constexpr uint32_t B23RWSC = (4 << 28);  ///< Bank 2-3 Read Wait State Control
    }

    /// TAGVDW0S Register bits
    namespace tagvdw0s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t tag = (14 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW1S Register bits
    namespace tagvdw1s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t tag = (14 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW2S Register bits
    namespace tagvdw2s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t tag = (14 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW3S Register bits
    namespace tagvdw3s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t tag = (14 << 6);  ///< 13-bit tag for cache entry
    }

    /// DATAW0SUM Register bits
    namespace dataw0sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW0SMU Register bits
    namespace dataw0smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW0SML Register bits
    namespace dataw0sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW0SLM Register bits
    namespace dataw0slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1SUM Register bits
    namespace dataw1sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW1SMU Register bits
    namespace dataw1smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW1SML Register bits
    namespace dataw1sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW1SLM Register bits
    namespace dataw1slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2SUM Register bits
    namespace dataw2sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW2SMU Register bits
    namespace dataw2smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW2SML Register bits
    namespace dataw2sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW2SLM Register bits
    namespace dataw2slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3SUM Register bits
    namespace dataw3sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW3SMU Register bits
    namespace dataw3smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW3SML Register bits
    namespace dataw3sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW3SLM Register bits
    namespace dataw3slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// FTFE Peripheral
// ============================================================================

namespace ftfe {
    /// Base addresses
    constexpr uint32_t FTFE_BASE = 0x40020000;

    /// FTFE Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB;  ///< Offset: 0x04 - Flash Common Command Object Registers (renamed from FCCOB)
        volatile uint32_t FPROT;  ///< Offset: 0x10 - Program Flash Protection Registers (renamed from FPROT)
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFE = reinterpret_cast<Registers*>(FTFE_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t RESERVED = (3 << 1);  ///< no description available
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFE Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< no description available
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< FTFE configuration
        constexpr uint32_t SWAP = (1U << 3);  ///< Swap
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB Register bits
    namespace fccob_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< no description available
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40024000;
    constexpr uint32_t CAN1_BASE = 0x400A4000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 Register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx 14 Mask Register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx 15 Mask Register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 Register
        volatile uint32_t IMASK2;  ///< Offset: 0x24 - Interrupt Masks 2 Register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 Register
        volatile uint32_t IFLAG2;  ///< Offset: 0x2C - Interrupt Flags 2 Register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 Register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 Register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 Register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask Register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t CS0;  ///< Offset: 0x80 - Message Buffer 0 CS Register
        volatile uint32_t ID0;  ///< Offset: 0x84 - Message Buffer 0 ID Register
        volatile uint32_t WORD00;  ///< Offset: 0x88 - Message Buffer 0 WORD0 Register
        volatile uint32_t WORD10;  ///< Offset: 0x8C - Message Buffer 0 WORD1 Register
        volatile uint32_t CS1;  ///< Offset: 0x90 - Message Buffer 1 CS Register
        volatile uint32_t ID1;  ///< Offset: 0x94 - Message Buffer 1 ID Register
        volatile uint32_t WORD01;  ///< Offset: 0x98 - Message Buffer 1 WORD0 Register
        volatile uint32_t WORD11;  ///< Offset: 0x9C - Message Buffer 1 WORD1 Register
        volatile uint32_t CS2;  ///< Offset: 0xA0 - Message Buffer 2 CS Register
        volatile uint32_t ID2;  ///< Offset: 0xA4 - Message Buffer 2 ID Register
        volatile uint32_t WORD02;  ///< Offset: 0xA8 - Message Buffer 2 WORD0 Register
        volatile uint32_t WORD12;  ///< Offset: 0xAC - Message Buffer 2 WORD1 Register
        volatile uint32_t CS3;  ///< Offset: 0xB0 - Message Buffer 3 CS Register
        volatile uint32_t ID3;  ///< Offset: 0xB4 - Message Buffer 3 ID Register
        volatile uint32_t WORD03;  ///< Offset: 0xB8 - Message Buffer 3 WORD0 Register
        volatile uint32_t WORD13;  ///< Offset: 0xBC - Message Buffer 3 WORD1 Register
        volatile uint32_t CS4;  ///< Offset: 0xC0 - Message Buffer 4 CS Register
        volatile uint32_t ID4;  ///< Offset: 0xC4 - Message Buffer 4 ID Register
        volatile uint32_t WORD04;  ///< Offset: 0xC8 - Message Buffer 4 WORD0 Register
        volatile uint32_t WORD14;  ///< Offset: 0xCC - Message Buffer 4 WORD1 Register
        volatile uint32_t CS5;  ///< Offset: 0xD0 - Message Buffer 5 CS Register
        volatile uint32_t ID5;  ///< Offset: 0xD4 - Message Buffer 5 ID Register
        volatile uint32_t WORD05;  ///< Offset: 0xD8 - Message Buffer 5 WORD0 Register
        volatile uint32_t WORD15;  ///< Offset: 0xDC - Message Buffer 5 WORD1 Register
        volatile uint32_t CS6;  ///< Offset: 0xE0 - Message Buffer 6 CS Register
        volatile uint32_t ID6;  ///< Offset: 0xE4 - Message Buffer 6 ID Register
        volatile uint32_t WORD06;  ///< Offset: 0xE8 - Message Buffer 6 WORD0 Register
        volatile uint32_t WORD16;  ///< Offset: 0xEC - Message Buffer 6 WORD1 Register
        volatile uint32_t CS7;  ///< Offset: 0xF0 - Message Buffer 7 CS Register
        volatile uint32_t ID7;  ///< Offset: 0xF4 - Message Buffer 7 ID Register
        volatile uint32_t WORD07;  ///< Offset: 0xF8 - Message Buffer 7 WORD0 Register
        volatile uint32_t WORD17;  ///< Offset: 0xFC - Message Buffer 7 WORD1 Register
        volatile uint32_t CS8;  ///< Offset: 0x100 - Message Buffer 8 CS Register
        volatile uint32_t ID8;  ///< Offset: 0x104 - Message Buffer 8 ID Register
        volatile uint32_t WORD08;  ///< Offset: 0x108 - Message Buffer 8 WORD0 Register
        volatile uint32_t WORD18;  ///< Offset: 0x10C - Message Buffer 8 WORD1 Register
        volatile uint32_t CS9;  ///< Offset: 0x110 - Message Buffer 9 CS Register
        volatile uint32_t ID9;  ///< Offset: 0x114 - Message Buffer 9 ID Register
        volatile uint32_t WORD09;  ///< Offset: 0x118 - Message Buffer 9 WORD0 Register
        volatile uint32_t WORD19;  ///< Offset: 0x11C - Message Buffer 9 WORD1 Register
        volatile uint32_t CS10;  ///< Offset: 0x120 - Message Buffer 10 CS Register
        volatile uint32_t ID10;  ///< Offset: 0x124 - Message Buffer 10 ID Register
        volatile uint32_t WORD010;  ///< Offset: 0x128 - Message Buffer 10 WORD0 Register
        volatile uint32_t WORD110;  ///< Offset: 0x12C - Message Buffer 10 WORD1 Register
        volatile uint32_t CS11;  ///< Offset: 0x130 - Message Buffer 11 CS Register
        volatile uint32_t ID11;  ///< Offset: 0x134 - Message Buffer 11 ID Register
        volatile uint32_t WORD011;  ///< Offset: 0x138 - Message Buffer 11 WORD0 Register
        volatile uint32_t WORD111;  ///< Offset: 0x13C - Message Buffer 11 WORD1 Register
        volatile uint32_t CS12;  ///< Offset: 0x140 - Message Buffer 12 CS Register
        volatile uint32_t ID12;  ///< Offset: 0x144 - Message Buffer 12 ID Register
        volatile uint32_t WORD012;  ///< Offset: 0x148 - Message Buffer 12 WORD0 Register
        volatile uint32_t WORD112;  ///< Offset: 0x14C - Message Buffer 12 WORD1 Register
        volatile uint32_t CS13;  ///< Offset: 0x150 - Message Buffer 13 CS Register
        volatile uint32_t ID13;  ///< Offset: 0x154 - Message Buffer 13 ID Register
        volatile uint32_t WORD013;  ///< Offset: 0x158 - Message Buffer 13 WORD0 Register
        volatile uint32_t WORD113;  ///< Offset: 0x15C - Message Buffer 13 WORD1 Register
        volatile uint32_t CS14;  ///< Offset: 0x160 - Message Buffer 14 CS Register
        volatile uint32_t ID14;  ///< Offset: 0x164 - Message Buffer 14 ID Register
        volatile uint32_t WORD014;  ///< Offset: 0x168 - Message Buffer 14 WORD0 Register
        volatile uint32_t WORD114;  ///< Offset: 0x16C - Message Buffer 14 WORD1 Register
        volatile uint32_t CS15;  ///< Offset: 0x170 - Message Buffer 15 CS Register
        volatile uint32_t ID15;  ///< Offset: 0x174 - Message Buffer 15 ID Register
        volatile uint32_t WORD015;  ///< Offset: 0x178 - Message Buffer 15 WORD0 Register
        volatile uint32_t WORD115;  ///< Offset: 0x17C - Message Buffer 15 WORD1 Register
        volatile uint32_t RXIMR;  ///< Offset: 0x880 - Rx Individual Mask Registers (renamed from RXIMR)
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< Number of the Last Message Buffer
        constexpr uint32_t RESERVED = (1U << 19);  ///< no description available
        constexpr uint32_t IDAM = (2 << 8);  ///< ID Acceptance Mode
        constexpr uint32_t AEN = (1U << 12);  ///< Abort Enable
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< Local Priority Enable
        constexpr uint32_t IRMQ = (1U << 16);  ///< Individual Rx Masking and Queue Enable
        constexpr uint32_t SRXDIS = (1U << 17);  ///< Self Reception Disable
        constexpr uint32_t LPMACK = (1U << 20);  ///< Low Power Mode Acknowledge
        constexpr uint32_t WRNEN = (1U << 21);  ///< Warning Interrupt Enable
        constexpr uint32_t SLFWAK = (1U << 22);  ///< Self Wake Up
        constexpr uint32_t SUPV = (1U << 23);  ///< Supervisor Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< Freeze Mode Acknowledge
        constexpr uint32_t SOFTRST = (1U << 25);  ///< Soft Reset
        constexpr uint32_t WAKMSK = (1U << 26);  ///< Wake Up Interrupt Mask
        constexpr uint32_t NOTRDY = (1U << 27);  ///< FlexCAN Not Ready
        constexpr uint32_t HALT = (1U << 28);  ///< Halt FlexCAN
        constexpr uint32_t RFEN = (1U << 29);  ///< Rx FIFO Enable
        constexpr uint32_t FRZ = (1U << 30);  ///< Freeze Enable
        constexpr uint32_t MDIS = (1U << 31);  ///< Module Disable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< Propagation Segment
        constexpr uint32_t LOM = (1U << 3);  ///< Listen-Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< Lowest Buffer Transmitted First
        constexpr uint32_t TSYN = (1U << 5);  ///< Timer Sync
        constexpr uint32_t BOFFREC = (1U << 6);  ///< Bus Off Recovery
        constexpr uint32_t SMP = (1U << 7);  ///< CAN Bit Sampling
        constexpr uint32_t RESERVED = (2 << 8);  ///< no description available
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< Rx Warning Interrupt Mask
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< Tx Warning Interrupt Mask
        constexpr uint32_t LPB = (1U << 12);  ///< Loop Back Mode
        constexpr uint32_t CLKSRC = (1U << 13);  ///< CAN Engine Clock Source
        constexpr uint32_t ERRMSK = (1U << 14);  ///< Error Mask
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< Bus Off Mask
        constexpr uint32_t PSEG2 = (3 << 16);  ///< Phase Segment 2
        constexpr uint32_t PSEG1 = (3 << 19);  ///< Phase Segment 1
        constexpr uint32_t RJW = (2 << 22);  ///< Resync Jump Width
        constexpr uint32_t PRESDIV = (8 << 24);  ///< Prescaler Division Factor
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< Timer value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< Rx Mailboxes Global Mask Bits
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< Rx Buffer 14 Mask Bits
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< Rx Buffer 15 Mask Bits
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TXERRCNT = (8 << 0);  ///< Transmit Error Counter
        constexpr uint32_t RXERRCNT = (8 << 8);  ///< Receive Error Counter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< Wake-Up Interrupt
        constexpr uint32_t ERRINT = (1U << 1);  ///< Error Interrupt
        constexpr uint32_t BOFFINT = (1U << 2);  ///< 'Bus Off' Interrupt
        constexpr uint32_t RX = (1U << 3);  ///< FlexCAN in Reception
        constexpr uint32_t FLTCONF = (2 << 4);  ///< Fault Confinement State
        constexpr uint32_t TX = (1U << 6);  ///< FlexCAN in Transmission
        constexpr uint32_t IDLE = (1U << 7);  ///< no description available
        constexpr uint32_t RXWRN = (1U << 8);  ///< Rx Error Warning
        constexpr uint32_t TXWRN = (1U << 9);  ///< TX Error Warning
        constexpr uint32_t STFERR = (1U << 10);  ///< Stuffing Error
        constexpr uint32_t FRMERR = (1U << 11);  ///< Form Error
        constexpr uint32_t CRCERR = (1U << 12);  ///< Cyclic Redundancy Check Error
        constexpr uint32_t ACKERR = (1U << 13);  ///< Acknowledge Error
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< Bit0 Error
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< Bit1 Error
        constexpr uint32_t RWRNINT = (1U << 16);  ///< Rx Warning Interrupt Flag
        constexpr uint32_t TWRNINT = (1U << 17);  ///< Tx Warning Interrupt Flag
        constexpr uint32_t SYNCH = (1U << 18);  ///< CAN Synchronization Status
        constexpr uint32_t RESERVED = (13 << 19);  ///< no description available
    }

    /// IMASK2 Register bits
    namespace imask2_bits {
        constexpr uint32_t BUFHM = (32 << 0);  ///< Buffer MBi Mask
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUFLM = (32 << 0);  ///< Buffer MBi Mask
    }

    /// IFLAG2 Register bits
    namespace iflag2_bits {
        constexpr uint32_t BUFHI = (32 << 0);  ///< Buffer MBi Interrupt
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF4TO0I = (5 << 0);  ///< Buffer MBi Interrupt or "reserved"
        constexpr uint32_t BUF5I = (1U << 5);  ///< Buffer MB5 Interrupt or "Frames available in Rx FIFO"
        constexpr uint32_t BUF6I = (1U << 6);  ///< Buffer MB6 Interrupt or "Rx FIFO Warning"
        constexpr uint32_t BUF7I = (1U << 7);  ///< Buffer MB7 Interrupt or "Rx FIFO Overflow"
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Buffer MBi Interrupt
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t EACEN = (1U << 16);  ///< Entire Frame Arbitration Field Comparison Enable for Rx Mailboxes
        constexpr uint32_t RRS = (1U << 17);  ///< Remote Request Storing
        constexpr uint32_t MRP = (1U << 18);  ///< Mailboxes Reception Priority
        constexpr uint32_t TASD = (5 << 19);  ///< Tx Arbitration Start Delay
        constexpr uint32_t RFFN = (4 << 24);  ///< Number of Rx FIFO Filters
        constexpr uint32_t WRMFRZ = (1U << 28);  ///< Write-Access to Memory in Freeze mode
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t RESERVED = (9 << 23);  ///< no description available
        constexpr uint32_t IMB = (1U << 13);  ///< Inactive Mailbox
        constexpr uint32_t VPS = (1U << 14);  ///< Valid Priority Status
        constexpr uint32_t LPTM = (7 << 16);  ///< Lowest Priority Tx Mailbox
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< CRC Transmitted
        constexpr uint32_t RESERVED = (9 << 23);  ///< no description available
        constexpr uint32_t MBCRC = (7 << 16);  ///< CRC Mailbox
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< Rx FIFO Global Mask Bits
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< Identifier Acceptance Filter Hit Indicator
        constexpr uint32_t RESERVED = (23 << 9);  ///< no description available
    }

    /// CS0 Register bits
    namespace cs0_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID0 Register bits
    namespace id0_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD00 Register bits
    namespace word00_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD10 Register bits
    namespace word10_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID1 Register bits
    namespace id1_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD01 Register bits
    namespace word01_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD11 Register bits
    namespace word11_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID2 Register bits
    namespace id2_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD02 Register bits
    namespace word02_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD12 Register bits
    namespace word12_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS3 Register bits
    namespace cs3_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID3 Register bits
    namespace id3_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD03 Register bits
    namespace word03_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD13 Register bits
    namespace word13_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS4 Register bits
    namespace cs4_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID4 Register bits
    namespace id4_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD04 Register bits
    namespace word04_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD14 Register bits
    namespace word14_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS5 Register bits
    namespace cs5_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID5 Register bits
    namespace id5_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD05 Register bits
    namespace word05_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD15 Register bits
    namespace word15_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS6 Register bits
    namespace cs6_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID6 Register bits
    namespace id6_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD06 Register bits
    namespace word06_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD16 Register bits
    namespace word16_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS7 Register bits
    namespace cs7_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID7 Register bits
    namespace id7_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD07 Register bits
    namespace word07_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD17 Register bits
    namespace word17_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS8 Register bits
    namespace cs8_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID8 Register bits
    namespace id8_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD08 Register bits
    namespace word08_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD18 Register bits
    namespace word18_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS9 Register bits
    namespace cs9_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID9 Register bits
    namespace id9_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD09 Register bits
    namespace word09_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD19 Register bits
    namespace word19_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS10 Register bits
    namespace cs10_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID10 Register bits
    namespace id10_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD010 Register bits
    namespace word010_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD110 Register bits
    namespace word110_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS11 Register bits
    namespace cs11_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID11 Register bits
    namespace id11_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD011 Register bits
    namespace word011_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD111 Register bits
    namespace word111_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS12 Register bits
    namespace cs12_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID12 Register bits
    namespace id12_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD012 Register bits
    namespace word012_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD112 Register bits
    namespace word112_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS13 Register bits
    namespace cs13_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID13 Register bits
    namespace id13_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD013 Register bits
    namespace word013_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD113 Register bits
    namespace word113_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS14 Register bits
    namespace cs14_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID14 Register bits
    namespace id14_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD014 Register bits
    namespace word014_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD114 Register bits
    namespace word114_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS15 Register bits
    namespace cs15_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID15 Register bits
    namespace id15_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD015 Register bits
    namespace word015_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD115 Register bits
    namespace word115_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// RXIMR Register bits
    namespace rximr_bits {
        constexpr uint32_t MI = (32 << 0);  ///< Individual Mask Bits
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t SPI2_BASE = 0x400AC000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - DSPI Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - DSPI Transfer Count Register
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t CTAR;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t SR;  ///< Offset: 0x2C - DSPI Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DSPI DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - DSPI PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - DSPI PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - DSPI POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - DSPI Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - DSPI Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t RESERVED = (2 << 22);  ///< no description available
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< no description available
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Timing Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< DSPI Configuration
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t RESERVED = (16 << 0);  ///< no description available
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t RESERVED = (2 << 23);  ///< no description available
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (5 << 27);  ///< Frame Size
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RESERVED = (1U << 29);  ///< no description available
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RESERVED = (1U << 30);  ///< no description available
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select.
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< DSPI Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< no description available
        constexpr uint32_t RESERVED = (2 << 24);  ///< no description available
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter.
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select.
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;
    constexpr uint32_t I2S1_BASE = 0x400AF000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x04 - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR;  ///< Offset: 0x20 - SAI Transmit Data Register (renamed from TDR)
        volatile uint32_t TFR;  ///< Offset: 0x40 - SAI Transmit FIFO Register (renamed from TFR)
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x84 - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR;  ///< Offset: 0xA0 - SAI Receive Data Register (renamed from RDR)
        volatile uint32_t RFR;  ///< Offset: 0xC0 - SAI Receive FIFO Register (renamed from RFR)
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
        volatile uint32_t MCR;  ///< Offset: 0x100 - SAI MCLK Control Register
        volatile uint32_t MDR;  ///< Offset: 0x104 - MCLK Divide Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO request DMA enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO warning DMA enable
        constexpr uint32_t RESERVED = (2 << 26);  ///< no description available
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO request interrupt enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO warning interrupt enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO error interrupt enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync error interrupt enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word start interrupt enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO request flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO warning flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO error flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync error flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word start flag
        constexpr uint32_t SR = (1U << 24);  ///< Software reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (3 << 0);  ///< Transmit FIFO watermark
        constexpr uint32_t RESERVED = (29 << 3);  ///< no description available
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit clock divide
        constexpr uint32_t RESERVED = (16 << 8);  ///< no description available
        constexpr uint32_t BCD = (1U << 24);  ///< Bit clock direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit clock polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word flag configuration
        constexpr uint32_t RESERVED = (14 << 18);  ///< no description available
        constexpr uint32_t TCE = (2 << 16);  ///< Transmit channel enable
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame sync direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame sync polarity
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t FSE = (1U << 3);  ///< Frame sync early
        constexpr uint32_t MF = (1U << 4);  ///< MSB first
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t FBT = (5 << 8);  ///< First bit shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N width
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit data register
    }

    /// TFR Register bits
    namespace tfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO pointer
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit word mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO request DMA enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO warning DMA enable
        constexpr uint32_t RESERVED = (2 << 26);  ///< no description available
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO request interrupt enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO warning interrupt enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO error interrupt enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync error interrupt enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word start interrupt enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO request flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO warning flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO error flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync error flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word start flag
        constexpr uint32_t SR = (1U << 24);  ///< Software reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (3 << 0);  ///< Receive FIFO watermark
        constexpr uint32_t RESERVED = (29 << 3);  ///< no description available
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit clock divide
        constexpr uint32_t RESERVED = (16 << 8);  ///< no description available
        constexpr uint32_t BCD = (1U << 24);  ///< Bit clock direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit clock polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word flag configuration
        constexpr uint32_t RESERVED = (14 << 18);  ///< no description available
        constexpr uint32_t RCE = (2 << 16);  ///< Receive channel enable
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame sync direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame sync polarity
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t FSE = (1U << 3);  ///< Frame sync early
        constexpr uint32_t MF = (1U << 4);  ///< MSB first
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t FBT = (5 << 8);  ///< First bit shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N width
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive data register
    }

    /// RFR Register bits
    namespace rfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO pointer
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive word mask
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t RESERVED = (4 << 26);  ///< no description available
        constexpr uint32_t MICS = (2 << 24);  ///< MCLK Input Clock Select
        constexpr uint32_t MOE = (1U << 30);  ///< MCLK Output Enable
        constexpr uint32_t DUF = (1U << 31);  ///< Divider Update Flag
    }

    /// MDR Register bits
    namespace mdr_bits {
        constexpr uint32_t DIVIDE = (12 << 0);  ///< MCLK Divide
        constexpr uint32_t FRACT = (8 << 12);  ///< MCLK Fraction
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCLL;  ///< Offset: 0x00 - CRC_CRCLL register.
        volatile uint32_t CRC;  ///< Offset: 0x00 - CRC Data Register
        volatile uint32_t CRCL;  ///< Offset: 0x00 - CRC_CRCL register.
        volatile uint32_t CRCLU;  ///< Offset: 0x01 - CRC_CRCLU register.
        volatile uint32_t CRCHL;  ///< Offset: 0x02 - CRC_CRCHL register.
        volatile uint32_t CRCH;  ///< Offset: 0x02 - CRC_CRCH register.
        volatile uint32_t CRCHU;  ///< Offset: 0x03 - CRC_CRCHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial Register
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control Register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCLL Register bits
    namespace crcll_bits {
        constexpr uint32_t CRCLL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit CRC
    }

    /// CRC Register bits
    namespace crc_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// CRCL Register bits
    namespace crcl_bits {
        constexpr uint32_t CRCL = (16 << 0);  ///< CRCL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// CRCLU Register bits
    namespace crclu_bits {
        constexpr uint32_t CRCLU = (8 << 0);  ///< CRCLL stores the second 8 bits of the 32 bit CRC
    }

    /// CRCHL Register bits
    namespace crchl_bits {
        constexpr uint32_t CRCHL = (8 << 0);  ///< CRCHL stores the third 8 bits of the 32 bit CRC
    }

    /// CRCH Register bits
    namespace crch_bits {
        constexpr uint32_t CRCH = (16 << 0);  ///< CRCH stores the high 16 bits of the 16/32 bit CRC
    }

    /// CRCHU Register bits
    namespace crchu_bits {
        constexpr uint32_t CRCHU = (8 << 0);  ///< CRCHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low polynominal half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High polynominal half-word
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t TCRC = (1U << 24);  ///< no description available
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC data register as seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read of CRC data register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type of Transpose for Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type of Transpose for Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 3);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBHS_BASE = 0x40034000;
    constexpr uint32_t USBDCD_BASE = 0x40035000;
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - Identification Register
        volatile uint32_t HWGENERAL;  ///< Offset: 0x04 - General Hardware Parameters Register
        volatile uint32_t HWHOST;  ///< Offset: 0x08 - Host Hardware Parameters Register
        volatile uint32_t HWDEVICE;  ///< Offset: 0x0C - Device Hardware Parameters Register
        volatile uint32_t HWTXBUF;  ///< Offset: 0x10 - Transmit Buffer Hardware Parameters Register
        volatile uint32_t HWRXBUF;  ///< Offset: 0x14 - Receive Buffer Hardware Parameters Register
        volatile uint32_t GPTIMERLD;  ///< Offset: 0x80 - General Purpose Timer n Load Register (renamed from GPTIMERLD)
        volatile uint32_t GPTIMERCTL;  ///< Offset: 0x84 - General Purpose Timer n Control Register (renamed from GPTIMERCTL)
        volatile uint32_t USB_SBUSCFG;  ///< Offset: 0x90 - System Bus Interface Configuration Register
        volatile uint32_t HCIVERSION;  ///< Offset: 0x100 - Host Controller Interface Version and Capability...
        volatile uint32_t HCSPARAMS;  ///< Offset: 0x104 - Host Controller Structural Parameters Register
        volatile uint32_t HCCPARAMS;  ///< Offset: 0x108 - Host Controller Capability Parameters Register
        volatile uint32_t DCIVERSION;  ///< Offset: 0x122 - Device Controller Interface Version
        volatile uint32_t DCCPARAMS;  ///< Offset: 0x124 - Device Controller Capability Parameters
        volatile uint32_t USBCMD;  ///< Offset: 0x140 - USB Command Register
        volatile uint32_t USBSTS;  ///< Offset: 0x144 - USB Status Register
        volatile uint32_t USBINTR;  ///< Offset: 0x148 - USB Interrupt Enable Register
        volatile uint32_t FRINDEX;  ///< Offset: 0x14C - Frame Index Register
        volatile uint32_t PERIODICLISTBASE;  ///< Offset: 0x154 - Periodic Frame List Base Address Register
        volatile uint32_t DEVICEADDR;  ///< Offset: 0x154 - Device Address Register
        volatile uint32_t ASYNCLISTADDR;  ///< Offset: 0x158 - Current Asynchronous List Address Register
        volatile uint32_t EPLISTADDR;  ///< Offset: 0x158 - Endpoint List Address Register
        volatile uint32_t TTCTRL;  ///< Offset: 0x15C - Host TT Asynchronous Buffer Control
        volatile uint32_t BURSTSIZE;  ///< Offset: 0x160 - Master Interface Data Burst Size Register
        volatile uint32_t TXFILLTUNING;  ///< Offset: 0x164 - Transmit FIFO Tuning Control Register
        volatile uint32_t ULPI_VIEWPORT;  ///< Offset: 0x170 - ULPI Register Access
        volatile uint32_t ENDPTNAK;  ///< Offset: 0x178 - Endpoint NAK Register
        volatile uint32_t ENDPTNAKEN;  ///< Offset: 0x17C - Endpoint NAK Enable Register
        volatile uint32_t CONFIGFLAG;  ///< Offset: 0x180 - Configure Flag Register
        volatile uint32_t PORTSC1;  ///< Offset: 0x184 - Port Status and Control Registers
        volatile uint32_t OTGSC;  ///< Offset: 0x1A4 - On-the-Go Status and Control Register
        volatile uint32_t USBMODE;  ///< Offset: 0x1A8 - USB Mode Register
        volatile uint32_t EPSETUPSR;  ///< Offset: 0x1AC - Endpoint Setup Status Register
        volatile uint32_t EPPRIME;  ///< Offset: 0x1B0 - Endpoint Initialization Register
        volatile uint32_t EPFLUSH;  ///< Offset: 0x1B4 - Endpoint Flush Register
        volatile uint32_t EPSR;  ///< Offset: 0x1B8 - Endpoint Status Register
        volatile uint32_t EPCOMPLETE;  ///< Offset: 0x1BC - Endpoint Complete Register
        volatile uint32_t EPCR0;  ///< Offset: 0x1C0 - Endpoint Control Register 0
        volatile uint32_t EPCR;  ///< Offset: 0x1C4 - Endpoint Control Register n (renamed from EPCR)
        volatile uint32_t USBGENCTRL;  ///< Offset: 0x200 - USB General Control Register
    };

    /// Peripheral instances
    inline Registers* USBHS = reinterpret_cast<Registers*>(USBHS_BASE);
    inline Registers* USBDCD = reinterpret_cast<Registers*>(USBDCD_BASE);
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (6 << 0);  ///< Configuration number
        constexpr uint32_t RESERVED = (2 << 14);  ///< Reserved
        constexpr uint32_t NID = (6 << 8);  ///< no description available
        constexpr uint32_t TAG = (5 << 16);  ///< Tag
        constexpr uint32_t REVISION = (4 << 21);  ///< Revision
        constexpr uint32_t VERSION = (4 << 25);  ///< Version
        constexpr uint32_t VERSIONID = (3 << 29);  ///< Version ID
    }

    /// HWGENERAL Register bits
    namespace hwgeneral_bits {
        constexpr uint32_t RESERVED = (21 << 11);  ///< Reserved
        constexpr uint32_t PHYM = (3 << 6);  ///< PHY Mode
        constexpr uint32_t SM = (2 << 9);  ///< Serial mode
    }

    /// HWHOST Register bits
    namespace hwhost_bits {
        constexpr uint32_t HC = (1U << 0);  ///< Host Capable
        constexpr uint32_t NPORT = (3 << 1);  ///< Number of Ports
        constexpr uint32_t RESERVED = (12 << 4);  ///< Reserved
        constexpr uint32_t TTASY = (8 << 16);  ///< Transaction translator contexts.
        constexpr uint32_t TTPER = (8 << 24);  ///< Transaction translator periodic contexts.
    }

    /// HWDEVICE Register bits
    namespace hwdevice_bits {
        constexpr uint32_t DC = (1U << 0);  ///< Device Capable
        constexpr uint32_t DEVEP = (5 << 1);  ///< Device endpoints.
        constexpr uint32_t RESERVED = (26 << 6);  ///< Reserved
    }

    /// HWTXBUF Register bits
    namespace hwtxbuf_bits {
        constexpr uint32_t TXBURST = (8 << 0);  ///< Transmit Burst.
        constexpr uint32_t TXADD = (8 << 8);  ///< Transmit Address.
        constexpr uint32_t TXCHANADD = (8 << 16);  ///< Transmit Channel Address
        constexpr uint32_t RESERVED = (7 << 24);  ///< Reserved
        constexpr uint32_t TXLC = (1U << 31);  ///< Transmit local Context Registers
    }

    /// HWRXBUF Register bits
    namespace hwrxbuf_bits {
        constexpr uint32_t RXBURST = (8 << 0);  ///< Receive Burst.
        constexpr uint32_t RXADD = (8 << 8);  ///< Receive Address.
        constexpr uint32_t RESERVED = (16 << 16);  ///< Reserved
    }

    /// GPTIMERLD Register bits
    namespace gptimerld_bits {
        constexpr uint32_t GPTLD = (24 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (8 << 24);  ///< Reserved
    }

    /// GPTIMERCTL Register bits
    namespace gptimerctl_bits {
        constexpr uint32_t GPTCNT = (24 << 0);  ///< Timer Count
        constexpr uint32_t MODE = (1U << 24);  ///< Timer Mode
        constexpr uint32_t RESERVED = (5 << 25);  ///< Reserved
        constexpr uint32_t RST = (1U << 30);  ///< Timer Reset
        constexpr uint32_t RUN = (1U << 31);  ///< Timer Run
    }

    /// USB_SBUSCFG Register bits
    namespace usb_sbuscfg_bits {
        constexpr uint32_t BURSTMODE = (3 << 0);  ///< Burst mode
        constexpr uint32_t RESERVED = (29 << 3);  ///< Reserved
    }

    /// HCIVERSION Register bits
    namespace hciversion_bits {
        constexpr uint32_t CAPLENGTH = (8 << 0);  ///< Capability registers length
        constexpr uint32_t RESERVED = (8 << 8);  ///< Reserved
        constexpr uint32_t HCIVERSION = (16 << 16);  ///< EHCI revision number
    }

    /// HCSPARAMS Register bits
    namespace hcsparams_bits {
        constexpr uint32_t N_PORTS = (4 << 0);  ///< Number of Ports
        constexpr uint32_t PPC = (1U << 4);  ///< Power Port Control
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t N_PCC = (4 << 8);  ///< Number Ports per CC
        constexpr uint32_t N_CC = (4 << 12);  ///< Number of Companion Controllers
        constexpr uint32_t PI = (1U << 16);  ///< Port Indicators
        constexpr uint32_t N_PTT = (4 << 20);  ///< Ports per Transaction Translator
        constexpr uint32_t N_TT = (4 << 24);  ///< Number of Transaction Translators.
    }

    /// HCCPARAMS Register bits
    namespace hccparams_bits {
        constexpr uint32_t ADC = (1U << 0);  ///< 64-bit addressing capability.
        constexpr uint32_t PFL = (1U << 1);  ///< Programmable Frame List flag
        constexpr uint32_t ASP = (1U << 2);  ///< Asynchronous Schedule Park capability
        constexpr uint32_t RESERVED = (16 << 16);  ///< Reserved
        constexpr uint32_t IST = (4 << 4);  ///< Isochronous Scheduling Threshold
        constexpr uint32_t EECP = (8 << 8);  ///< EHCI Extended Capabilities Pointer
    }

    /// DCIVERSION Register bits
    namespace dciversion_bits {
        constexpr uint32_t DCIVERSION = (16 << 0);  ///< no description available
    }

    /// DCCPARAMS Register bits
    namespace dccparams_bits {
        constexpr uint32_t DEN = (5 << 0);  ///< Device Endpoint Number
        constexpr uint32_t RESERVED = (23 << 9);  ///< Reserved
        constexpr uint32_t DC = (1U << 7);  ///< Device Capable
        constexpr uint32_t HC = (1U << 8);  ///< Host Capable
    }

    /// USBCMD Register bits
    namespace usbcmd_bits {
        constexpr uint32_t RS = (1U << 0);  ///< Run/Stop
        constexpr uint32_t RST = (1U << 1);  ///< Controller Reset
        constexpr uint32_t FS = (2 << 2);  ///< Frame list Size
        constexpr uint32_t PSE = (1U << 4);  ///< Periodic Schedule Enable
        constexpr uint32_t ASE = (1U << 5);  ///< Asynchronous Schedule Enable
        constexpr uint32_t IAA = (1U << 6);  ///< Interrupt on Async Advance doorbell
        constexpr uint32_t RESERVED = (8 << 24);  ///< Reserved
        constexpr uint32_t ASP = (2 << 8);  ///< Asynchronous Schedule Park mode count
        constexpr uint32_t ASPE = (1U << 11);  ///< Asynchronous Schedule Park mode Enable
        constexpr uint32_t SUTW = (1U << 13);  ///< Setup TripWire
        constexpr uint32_t ATDTW = (1U << 14);  ///< Add dTD TripWire
        constexpr uint32_t FS2 = (1U << 15);  ///< Frame list Size 2
        constexpr uint32_t ITC = (8 << 16);  ///< Interrupt Threshold Control
    }

    /// USBSTS Register bits
    namespace usbsts_bits {
        constexpr uint32_t UI = (1U << 0);  ///< USB Interrupt (USBINT)
        constexpr uint32_t UEI = (1U << 1);  ///< USB Error Interrupt
        constexpr uint32_t PCI = (1U << 2);  ///< Port Change detect
        constexpr uint32_t FRI = (1U << 3);  ///< Frame-list Rollover
        constexpr uint32_t SEI = (1U << 4);  ///< System Error
        constexpr uint32_t AAI = (1U << 5);  ///< Interrupt on Async Advance
        constexpr uint32_t URI = (1U << 6);  ///< USB Reset received
        constexpr uint32_t SRI = (1U << 7);  ///< SOF Received
        constexpr uint32_t SLI = (1U << 8);  ///< Device-controller suspend
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t ULPII = (1U << 10);  ///< ULPI Interrupt
        constexpr uint32_t HCH = (1U << 12);  ///< Host Controller Halted
        constexpr uint32_t RCL = (1U << 13);  ///< Reclamation
        constexpr uint32_t PS = (1U << 14);  ///< Periodic schedule Status
        constexpr uint32_t AS = (1U << 15);  ///< Asynchronous schedule Status
        constexpr uint32_t NAKI = (1U << 16);  ///< NAK Interrupt
        constexpr uint32_t UAI = (1U << 18);  ///< USB host Asynchronous Interrupt
        constexpr uint32_t UPI = (1U << 19);  ///< USB host Periodic Interrupt
        constexpr uint32_t TI0 = (1U << 24);  ///< General purpose Timer 0 Interrupt
        constexpr uint32_t TI1 = (1U << 25);  ///< General purpose Timer 1 Interrupt
    }

    /// USBINTR Register bits
    namespace usbintr_bits {
        constexpr uint32_t UE = (1U << 0);  ///< USB interrupt Enable
        constexpr uint32_t UEE = (1U << 1);  ///< USB Error interrupt Enable
        constexpr uint32_t PCE = (1U << 2);  ///< Port Change detect Enable
        constexpr uint32_t FRE = (1U << 3);  ///< Frame list Rollover Enable
        constexpr uint32_t SEE = (1U << 4);  ///< System Error Enable
        constexpr uint32_t AAE = (1U << 5);  ///< Interrupt on Async advance Enable
        constexpr uint32_t URE = (1U << 6);  ///< USB-Reset Enable
        constexpr uint32_t SRE = (1U << 7);  ///< SOF-Received Enable
        constexpr uint32_t SLE = (1U << 8);  ///< Sleep (DC suspend) Enable
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t ULPIE = (1U << 10);  ///< ULPI Enable
        constexpr uint32_t NAKE = (1U << 16);  ///< NAK Interrupt Enable
        constexpr uint32_t UAIE = (1U << 18);  ///< USB host Asynchronous Interrupt Enable
        constexpr uint32_t UPIE = (1U << 19);  ///< USB host Periodic Interrupt Enable
        constexpr uint32_t TIE0 = (1U << 24);  ///< General purpose Timer 0 Interrupt Enable
        constexpr uint32_t TIE1 = (1U << 25);  ///< General purpose Timer 1 Interrupt Enable
    }

    /// FRINDEX Register bits
    namespace frindex_bits {
        constexpr uint32_t FRINDEX = (14 << 0);  ///< Frame Index
        constexpr uint32_t Reerved = (18 << 14);  ///< Reserved
    }

    /// PERIODICLISTBASE Register bits
    namespace periodiclistbase_bits {
        constexpr uint32_t RESERVED = (12 << 0);  ///< Reserved
        constexpr uint32_t PERBASE = (20 << 12);  ///< Base address
    }

    /// DEVICEADDR Register bits
    namespace deviceaddr_bits {
        constexpr uint32_t RESERVED = (24 << 0);  ///< Reserved
        constexpr uint32_t USBADRA = (1U << 24);  ///< Device Address Advance
        constexpr uint32_t USBADR = (7 << 25);  ///< Device Address
    }

    /// ASYNCLISTADDR Register bits
    namespace asynclistaddr_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< Reserved
        constexpr uint32_t ASYBASE = (27 << 5);  ///< Link pointer low (LPL)
    }

    /// EPLISTADDR Register bits
    namespace eplistaddr_bits {
        constexpr uint32_t RESERVED = (11 << 0);  ///< Reserved
        constexpr uint32_t EPBASE = (21 << 11);  ///< Endpoint list address
    }

    /// TTCTRL Register bits
    namespace ttctrl_bits {
        constexpr uint32_t RESERVED = (24 << 0);  ///< Reserved
        constexpr uint32_t TTHA = (7 << 24);  ///< TT Hub Address
        constexpr uint32_t Reerved = (1U << 31);  ///< Reserved
    }

    /// BURSTSIZE Register bits
    namespace burstsize_bits {
        constexpr uint32_t RXPBURST = (8 << 0);  ///< Programable RX Burst length
        constexpr uint32_t TXPBURST = (8 << 8);  ///< Programable TX Burst length
        constexpr uint32_t RESERVED = (16 << 16);  ///< Reserved
    }

    /// TXFILLTUNING Register bits
    namespace txfilltuning_bits {
        constexpr uint32_t TXSCHOH = (7 << 0);  ///< Scheduler Overhead
        constexpr uint32_t RESERVED = (10 << 22);  ///< Reserved
        constexpr uint32_t TXSCHHEALTH = (5 << 8);  ///< Scheduler Health counter
        constexpr uint32_t TXFIFOTHRES = (6 << 16);  ///< FIFO burst Threshold
    }

    /// ULPI_VIEWPORT Register bits
    namespace ulpi_viewport_bits {
        constexpr uint32_t ULPI_DATWR = (8 << 0);  ///< ULPI Data Write
        constexpr uint32_t ULPI_DATRD = (8 << 8);  ///< ULPI Data Read
        constexpr uint32_t ULPI_ADDR = (8 << 16);  ///< ULPI data Address
        constexpr uint32_t ULPI_PORT = (3 << 24);  ///< ULPI Port number
        constexpr uint32_t ULPI_SS = (1U << 27);  ///< ULPI Sync State
        constexpr uint32_t RESERVED = (1U << 28);  ///< Reserved
        constexpr uint32_t ULPI_RW = (1U << 29);  ///< ULPI Read/Write
        constexpr uint32_t ULPI_RUN = (1U << 30);  ///< ULPI Run
        constexpr uint32_t ULPI_WU = (1U << 31);  ///< ULPI Wake-Up
    }

    /// ENDPTNAK Register bits
    namespace endptnak_bits {
        constexpr uint32_t EPRN = (4 << 0);  ///< RX Endpoint NAK
        constexpr uint32_t RESERVED = (12 << 20);  ///< Reserved
        constexpr uint32_t EPTN = (4 << 16);  ///< TX Endpoint NAK
    }

    /// ENDPTNAKEN Register bits
    namespace endptnaken_bits {
        constexpr uint32_t EPRNE = (4 << 0);  ///< RX Endpoint NAK
        constexpr uint32_t RESERVED = (12 << 20);  ///< Reserved
        constexpr uint32_t EPTNE = (4 << 16);  ///< TX Endpoint NAK
    }

    /// CONFIGFLAG Register bits
    namespace configflag_bits {
        constexpr uint32_t RESERVED = (31 << 1);  ///< Reserved
    }

    /// PORTSC1 Register bits
    namespace portsc1_bits {
        constexpr uint32_t CCS = (1U << 0);  ///< Current Connect Status
        constexpr uint32_t CSC = (1U << 1);  ///< Connect Change Status
        constexpr uint32_t PE = (1U << 2);  ///< Port Enabled/disabled
        constexpr uint32_t PEC = (1U << 3);  ///< Port Enable/disable Change
        constexpr uint32_t OCA = (1U << 4);  ///< Over-current active
        constexpr uint32_t OCC = (1U << 5);  ///< Over-Current Change
        constexpr uint32_t FPR = (1U << 6);  ///< Force Port Resume
        constexpr uint32_t SUSP = (1U << 7);  ///< Suspend
        constexpr uint32_t PR = (1U << 8);  ///< Port Reset
        constexpr uint32_t HSP = (1U << 9);  ///< High Speed Port.
        constexpr uint32_t LS = (2 << 10);  ///< Line Status
        constexpr uint32_t PP = (1U << 12);  ///< Port Power
        constexpr uint32_t PO = (1U << 13);  ///< Port Owner
        constexpr uint32_t PIC = (2 << 14);  ///< Port Indicator Control
        constexpr uint32_t PTC = (4 << 16);  ///< Port Test Control
        constexpr uint32_t WKCN = (1U << 20);  ///< Wake on Connect enable
        constexpr uint32_t WKDS = (1U << 21);  ///< Wake on Disconnect enable
        constexpr uint32_t WKOC = (1U << 22);  ///< Wake on Over-Current enable
        constexpr uint32_t PHCD = (1U << 23);  ///< PHY low power suspend
        constexpr uint32_t PFSC = (1U << 24);  ///< Port force Full-Speed Connect
        constexpr uint32_t RESERVED = (1U << 29);  ///< Reserved
        constexpr uint32_t PSPD = (2 << 26);  ///< Port Speed
        constexpr uint32_t PTS = (2 << 30);  ///< Port Transceiver Select
    }

    /// OTGSC Register bits
    namespace otgsc_bits {
        constexpr uint32_t VD = (1U << 0);  ///< VBUS Discharge
        constexpr uint32_t VC = (1U << 1);  ///< VBUS Charge
        constexpr uint32_t HAAR = (1U << 2);  ///< Hardware Assist Auto-Reset
        constexpr uint32_t OT = (1U << 3);  ///< OTG Termination
        constexpr uint32_t DP = (1U << 4);  ///< Data Pulsing
        constexpr uint32_t IDPU = (1U << 5);  ///< ID Pull-Up
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t HABA = (1U << 7);  ///< Hardware Assist B-Disconnect to A-connect
        constexpr uint32_t ID = (1U << 8);  ///< USB ID
        constexpr uint32_t AVV = (1U << 9);  ///< A VBus Valid
        constexpr uint32_t ASV = (1U << 10);  ///< A Session Valid
        constexpr uint32_t BSV = (1U << 11);  ///< B Session Valid
        constexpr uint32_t BSE = (1U << 12);  ///< B Session End
        constexpr uint32_t MST = (1U << 13);  ///< 1 Milli-Second timer Toggle
        constexpr uint32_t DPS = (1U << 14);  ///< Data bus Pulsing Status
        constexpr uint32_t IDIS = (1U << 16);  ///< USB ID Interrupt Status
        constexpr uint32_t AVVIS = (1U << 17);  ///< A VBUS Valid Interrupt Status
        constexpr uint32_t ASVIS = (1U << 18);  ///< A Session Valid Interrupt Status
        constexpr uint32_t BSVIS = (1U << 19);  ///< B Session Valid Interrupt Status
        constexpr uint32_t BSEIS = (1U << 20);  ///< B Session End Interrupt Status
        constexpr uint32_t MSS = (1U << 21);  ///< 1 Milli-Second timer interrupt Status
        constexpr uint32_t DPIS = (1U << 22);  ///< Data Pulse interrupt Status
        constexpr uint32_t IDIE = (1U << 24);  ///< USB ID Interrupt Enable
        constexpr uint32_t AVVIE = (1U << 25);  ///< A VBUS Valid Interrupt Enable
        constexpr uint32_t ASVIE = (1U << 26);  ///< A Session Valid Interrupt Enable
        constexpr uint32_t BSVIE = (1U << 27);  ///< B Session Valid Interrupt Enable
        constexpr uint32_t BSEIE = (1U << 28);  ///< B Session End Interrupt Enable
        constexpr uint32_t MSE = (1U << 29);  ///< 1 Milli-Second timer interrupt Enable
        constexpr uint32_t DPIE = (1U << 30);  ///< Data Pulse Interrupt Enable
    }

    /// USBMODE Register bits
    namespace usbmode_bits {
        constexpr uint32_t CM = (2 << 0);  ///< Controller Mode
        constexpr uint32_t ES = (1U << 2);  ///< Endian Select
        constexpr uint32_t SLOM = (1U << 3);  ///< Setup Lock-Out Mode
        constexpr uint32_t SDIS = (1U << 4);  ///< Stream DISable
        constexpr uint32_t RESERVED = (17 << 15);  ///< Reserved
        constexpr uint32_t TXHSD = (3 << 12);  ///< Tx to Tx HS Delay
    }

    /// EPSETUPSR Register bits
    namespace epsetupsr_bits {
        constexpr uint32_t EPSETUPSTAT = (4 << 0);  ///< Setup Endpoint Status
        constexpr uint32_t RESERVED = (28 << 4);  ///< Reserved
    }

    /// EPPRIME Register bits
    namespace epprime_bits {
        constexpr uint32_t PERB = (4 << 0);  ///< Prime Endpoint Receive Buffer
        constexpr uint32_t RESERVED = (12 << 20);  ///< Reserved
        constexpr uint32_t PETB = (4 << 16);  ///< Prime Endpoint tTansmit Buffer
    }

    /// EPFLUSH Register bits
    namespace epflush_bits {
        constexpr uint32_t FERB = (4 << 0);  ///< Flush Endpoint Receive Buffer
        constexpr uint32_t RESERVED = (12 << 20);  ///< Reserved
        constexpr uint32_t FETB = (4 << 16);  ///< Flush Endpoint Transmit Buffer
    }

    /// EPSR Register bits
    namespace epsr_bits {
        constexpr uint32_t ERBR = (4 << 0);  ///< Endpoint Receive Buffer Ready
        constexpr uint32_t RESERVED = (12 << 20);  ///< Reserved
        constexpr uint32_t ETBR = (4 << 16);  ///< Endpoint Transmit Buffer Ready
    }

    /// EPCOMPLETE Register bits
    namespace epcomplete_bits {
        constexpr uint32_t ERCE = (4 << 0);  ///< Endpoint Receive Complete Event
        constexpr uint32_t RESERVED = (12 << 20);  ///< Reserved
        constexpr uint32_t ETCE = (4 << 16);  ///< Endpoint Transmit Complete Event
    }

    /// EPCR0 Register bits
    namespace epcr0_bits {
        constexpr uint32_t RXS = (1U << 0);  ///< RX endpoint Stall
        constexpr uint32_t RESERVED = (8 << 24);  ///< This register is not defined in the EHCI specification. Every device implements endpoint 0 as a control endpoint.
        constexpr uint32_t RXT = (2 << 2);  ///< RX endpoint Type
        constexpr uint32_t RXE = (1U << 7);  ///< RX endpoint Enable
        constexpr uint32_t TXS = (1U << 16);  ///< TX Endpoint Stall
        constexpr uint32_t TXT = (2 << 18);  ///< TX Endpoint Type
        constexpr uint32_t TXE = (1U << 23);  ///< TX Endpoint Enable
    }

    /// EPCR Register bits
    namespace epcr_bits {
        constexpr uint32_t RXS = (1U << 0);  ///< RX endpoint Stall
        constexpr uint32_t RXD = (1U << 1);  ///< RX endpoint Data sink
        constexpr uint32_t RXT = (2 << 2);  ///< RX endpoint Type
        constexpr uint32_t RESERVED = (8 << 24);  ///< Reserved
        constexpr uint32_t RXI = (1U << 5);  ///< RX data toggle Inhibit
        constexpr uint32_t RXR = (1U << 6);  ///< RX data toggle Reset
        constexpr uint32_t RXE = (1U << 7);  ///< RX endpoint Enable
        constexpr uint32_t TXS = (1U << 16);  ///< TX endpoint Stall
        constexpr uint32_t TXD = (1U << 17);  ///< TX endpoint Data source
        constexpr uint32_t TXT = (2 << 18);  ///< TX endpoint Type
        constexpr uint32_t TXI = (1U << 21);  ///< TX data toggle Inhibit
        constexpr uint32_t TXR = (1U << 22);  ///< TX data toggle Reset
        constexpr uint32_t TXE = (1U << 23);  ///< TX endpoint Enable
    }

    /// USBGENCTRL Register bits
    namespace usbgenctrl_bits {
        constexpr uint32_t WU_IE = (1U << 0);  ///< Wakeup Interrupt Enable
        constexpr uint32_t WU_ULPI_EN = (1U << 1);  ///< Wakeup on ULPI Interrupt Event
        constexpr uint32_t RESERVED = (26 << 6);  ///< Reserved
        constexpr uint32_t WU_INT_CLR = (1U << 5);  ///< Wakeup Interrupt Clear
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1 (renamed from CHC1)
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register (renamed from CHS)
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register (renamed from CHDLY0)
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register (renamed from CHDLY1)
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control Register (renamed from DACINTC)
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n Register (renamed from DACINT)
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register (renamed from PODLY)
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus.
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
        constexpr uint32_t RESERVED = (30 << 2);  ///< no description available
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT_ = (16 << 0);  ///< DAC Interval (renamed from INT_)
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
        constexpr uint32_t RESERVED = (30 << 2);  ///< no description available
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value Bits
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable Bit.
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable Bit.
        constexpr uint32_t RESERVED = (30 << 2);  ///< no description available
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag.
        constexpr uint32_t RESERVED = (31 << 1);  ///< no description available
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x400B8000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM3 Peripheral
// ============================================================================

namespace ftm3 {
    /// Base addresses
    constexpr uint32_t FTM3_BASE = 0x400B9000;

    /// FTM3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM3 = reinterpret_cast<Registers*>(FTM3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x400BB000;
    constexpr uint32_t ADC2_BASE = 0x4003C000;
    constexpr uint32_t ADC3_BASE = 0x400BC000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC status and control registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC configuration register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - Configuration register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC data result register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare value registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and control register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and control register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC offset correction register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC plus-side gain register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC minus-side gain register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC plus-side general calibration value register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC plus-side general calibration value register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC plus-side general calibration value register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC plus-side general calibration value register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC plus-side general calibration value register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC plus-side general calibration value register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC plus-side general calibration value register
        volatile uint32_t PGA;  ///< Offset: 0x50 - ADC PGA register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC minus-side general calibration value register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC minus-side general calibration value register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC minus-side general calibration value register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC minus-side general calibration value register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC minus-side general calibration value register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC minus-side general calibration value register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC minus-side general calibration value register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC3 = reinterpret_cast<Registers*>(ADC3_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential mode enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion complete flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input clock select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample time configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock divide select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-power configuration
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long sample time select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High speed configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous clock output enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux select
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage reference selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare function range enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare function greater than enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare function enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion trigger select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion active
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware average select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware average enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous conversion enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration failed flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset error correction value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-side gain
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-side gain
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (23 << 9);  ///< no description available
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (25 << 7);  ///< no description available
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// PGA Register bits
    namespace pga_bits {
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t PGAOFSM = (1U << 14);  ///< PGA Offset Measurement
        constexpr uint32_t PGAG = (4 << 16);  ///< PGA gain setting
        constexpr uint32_t PGALPb = (1U << 20);  ///< PGA low-power mode control
        constexpr uint32_t PGACHPb = (1U << 21);  ///< PGA chopping control
        constexpr uint32_t PGAEN = (1U << 23);  ///< PGA enable
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (23 << 9);  ///< no description available
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (25 << 7);  ///< no description available
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t TTSR;  ///< Offset: 0x20 - RTC Tamper Time Seconds Register
        volatile uint32_t MER;  ///< Offset: 0x24 - RTC Monotonic Enable Register
        volatile uint32_t MCLR;  ///< Offset: 0x28 - RTC Monotonic Counter Low Register
        volatile uint32_t MCHR;  ///< Offset: 0x2C - RTC Monotonic Counter High Register
        volatile uint32_t TER;  ///< Offset: 0x30 - RTC Tamper Enable Register
        volatile uint32_t TDR;  ///< Offset: 0x34 - RTC Tamper Detect Register
        volatile uint32_t TTR;  ///< Offset: 0x38 - RTC Tamper Trim Register
        volatile uint32_t TIR;  ///< Offset: 0x3C - RTC Tamper Interrupt Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t RESERVED = (17 << 15);  ///< no description available
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF load configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF load configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF load configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF load configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t MOF = (1U << 3);  ///< Monotonic Overflow Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
        constexpr uint32_t TTSL = (1U << 8);  ///< Tamper Time Seconds Lock
        constexpr uint32_t MEL = (1U << 9);  ///< Monotonic Enable Lock
        constexpr uint32_t MCLL = (1U << 10);  ///< Monotonic Counter Low Lock
        constexpr uint32_t MCHL = (1U << 11);  ///< Monotonic Counter High Lock
        constexpr uint32_t TEL = (1U << 12);  ///< Tamper Enable Lock
        constexpr uint32_t TDL = (1U << 13);  ///< Tamper Detect Lock
        constexpr uint32_t TTL = (1U << 14);  ///< Tamper Trim Lock
        constexpr uint32_t TIL = (1U << 15);  ///< Tamper Interrupt Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t MOIE = (1U << 3);  ///< Monotonic Overflow Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// TTSR Register bits
    namespace ttsr_bits {
        constexpr uint32_t TTS = (32 << 0);  ///< Tamper Time Seconds
    }

    /// MER Register bits
    namespace mer_bits {
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
        constexpr uint32_t MCE = (1U << 4);  ///< Monotonic Counter Enable
    }

    /// MCLR Register bits
    namespace mclr_bits {
        constexpr uint32_t MCL = (32 << 0);  ///< Monotonic Counter Low
    }

    /// MCHR Register bits
    namespace mchr_bits {
        constexpr uint32_t MCH = (32 << 0);  ///< Monotonic Counter High
    }

    /// TER Register bits
    namespace ter_bits {
        constexpr uint32_t DTE = (1U << 0);  ///< DryIce Tamper Enable
        constexpr uint32_t VTE = (1U << 1);  ///< Voltage Tamper Enable
        constexpr uint32_t CTE = (1U << 2);  ///< Clock Tamper Enable
        constexpr uint32_t TTE = (1U << 3);  ///< Temperature Tamper Enable
        constexpr uint32_t FSE = (1U << 4);  ///< Flash Security Enable
        constexpr uint32_t TME = (1U << 5);  ///< Test Mode Enable
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t DTF = (1U << 0);  ///< DryIce Tamper Flag
        constexpr uint32_t VTF = (1U << 1);  ///< Voltage Tamper Flag
        constexpr uint32_t CTF = (1U << 2);  ///< Clock Tamper Flag
        constexpr uint32_t TTF = (1U << 3);  ///< Temperature Tamper Flag
        constexpr uint32_t FSF = (1U << 4);  ///< Flash Security Flag
        constexpr uint32_t TMF = (1U << 5);  ///< Test Mode Flag
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// TTR Register bits
    namespace ttr_bits {
        constexpr uint32_t VDTL = (3 << 0);  ///< Voltage Detect Trim Low
        constexpr uint32_t VDTH = (3 << 3);  ///< Voltage Detect Trim High
        constexpr uint32_t CDTL = (3 << 6);  ///< Clock Detect Trim Low
        constexpr uint32_t CDTH = (3 << 9);  ///< Clock Detect Trim High
        constexpr uint32_t TDTH = (3 << 12);  ///< Temperature Detect Trim High
        constexpr uint32_t TDTL = (3 << 15);  ///< Temperature Detect Trim Low
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
    }

    /// TIR Register bits
    namespace tir_bits {
        constexpr uint32_t DTIE = (1U << 0);  ///< DryIce Tamper Interrupt Enable
        constexpr uint32_t VTIE = (1U << 1);  ///< Voltage Tamper Interrupt Enable
        constexpr uint32_t CTIE = (1U << 2);  ///< Clock Tamper Interrupt Enable
        constexpr uint32_t TTIE = (1U << 3);  ///< Temperature Tamper Interrupt Enable
        constexpr uint32_t FSIE = (1U << 4);  ///< Flash Security Interrupt Enable
        constexpr uint32_t TMIE = (1U << 5);  ///< Test Mode Interrupt Enable
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
        constexpr uint32_t TTSW = (1U << 8);  ///< Tamper Time Seconds Write
        constexpr uint32_t MERW = (1U << 9);  ///< Monotonic Enable Register Write
        constexpr uint32_t MCLW = (1U << 10);  ///< Monotonic Counter Low Write
        constexpr uint32_t MCHW = (1U << 11);  ///< Monotonic Counter High Write
        constexpr uint32_t TERW = (1U << 12);  ///< Tamper Enable Register Write
        constexpr uint32_t TDRW = (1U << 13);  ///< Tamper Detect Register Write
        constexpr uint32_t TTRW = (1U << 14);  ///< Tamper Trim Register Write
        constexpr uint32_t TIRW = (1U << 15);  ///< Tamper Interrupt Register Write
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
        constexpr uint32_t TTSR = (1U << 8);  ///< Tamper Time Seconds Read
        constexpr uint32_t MERR = (1U << 9);  ///< Monotonic Enable Register Read
        constexpr uint32_t MCLR = (1U << 10);  ///< Monotonic Counter Low Read
        constexpr uint32_t MCHR = (1U << 11);  ///< Monotonic Counter High Read
        constexpr uint32_t TERR = (1U << 12);  ///< Tamper Enable Register Read
        constexpr uint32_t TDRR = (1U << 13);  ///< Tamper Detect Register Read
        constexpr uint32_t TTRR = (1U << 14);  ///< Tamper Trim Register Read
        constexpr uint32_t TIRR = (1U << 15);  ///< Tamper Interrupt Register Read
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - VBAT register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< no description available
        constexpr uint32_t LH = (8 << 8);  ///< no description available
        constexpr uint32_t HL = (8 << 16);  ///< no description available
        constexpr uint32_t HH = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< no description available
        constexpr uint32_t LH = (8 << 8);  ///< no description available
        constexpr uint32_t HL = (8 << 16);  ///< no description available
        constexpr uint32_t HH = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// DRY Peripheral
// ============================================================================

namespace dry {
    /// Base addresses
    constexpr uint32_t DRY_BASE = 0x40042000;

    /// DRY Register structure
    struct Registers {
        volatile uint32_t SKVR;  ///< Offset: 0x04 - DryIce Secure Key Valid Register
        volatile uint32_t SKWLR;  ///< Offset: 0x08 - DryIce Secure Key Write Lock Register
        volatile uint32_t SKRLR;  ///< Offset: 0x0C - DryIce Secure Key Read Lock Register
        volatile uint32_t CR;  ///< Offset: 0x10 - DryIce Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - DryIce Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - DryIce Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - DryIce Interrupt Enable Register
        volatile uint32_t TSR;  ///< Offset: 0x20 - DryIce Tamper Seconds Register
        volatile uint32_t TER;  ///< Offset: 0x24 - DryIce Tamper Enable Register
        volatile uint32_t PDR;  ///< Offset: 0x28 - DryIce Pin Direction Register
        volatile uint32_t PPR;  ///< Offset: 0x2C - DryIce Pin Polarity Register
        volatile uint32_t ATR;  ///< Offset: 0x30 - DryIce Active Tamper Register (renamed from ATR)
        volatile uint32_t PGFR;  ///< Offset: 0x40 - DryIce Pin Glitch Filter Register (renamed from PGFR)
        volatile uint32_t WAC;  ///< Offset: 0x800 - DryIce Write Access Control Register
        volatile uint32_t RAC;  ///< Offset: 0x804 - DryIce Read Access Control Register
        volatile uint32_t SKR;  ///< Offset: 0x1000 - Secure Key Register (renamed from SKR)
        volatile uint32_t SWAC;  ///< Offset: 0x1800 - Secure Write Access Control
        volatile uint32_t SRAC;  ///< Offset: 0x1804 - Secure Read Access Control
    };

    /// Peripheral instances
    inline Registers* DRY = reinterpret_cast<Registers*>(DRY_BASE);

    // Bit definitions
    /// SKVR Register bits
    namespace skvr_bits {
        constexpr uint32_t SKV = (8 << 0);  ///< Secure Key Valid
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SKWLR Register bits
    namespace skwlr_bits {
        constexpr uint32_t SKWL = (8 << 0);  ///< Secure Key Write Lock
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SKRLR Register bits
    namespace skrlr_bits {
        constexpr uint32_t SKRL = (8 << 0);  ///< Secure Key Read Lock
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t DEN = (1U << 1);  ///< DryIce Enable
        constexpr uint32_t TFSR = (1U << 2);  ///< Tamper Force System Reset
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t RESERVED = (5 << 12);  ///< no description available
        constexpr uint32_t THYS = (1U << 8);  ///< Tamper Hysteresis Select
        constexpr uint32_t TPFE = (1U << 9);  ///< Tamper Passive Filter Enable
        constexpr uint32_t TDSE = (1U << 10);  ///< Tamper Drive Strength Enable
        constexpr uint32_t TSRE = (1U << 11);  ///< Tamper Slew Rate Enable
        constexpr uint32_t DPR = (15 << 17);  ///< DryIce Prescaler Register
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DTF = (1U << 0);  ///< DryIce Tamper Flag
        constexpr uint32_t TAF = (1U << 1);  ///< Tamper Acknowledge Flag
        constexpr uint32_t TOF = (1U << 2);  ///< Time Overflow Flag
        constexpr uint32_t MOF = (1U << 3);  ///< Monotonic Overflow Flag
        constexpr uint32_t VTF = (1U << 4);  ///< Voltage Tamper Flag
        constexpr uint32_t CTF = (1U << 5);  ///< Clock Tamper Flag
        constexpr uint32_t TTF = (1U << 6);  ///< Temperature Tamper Flag
        constexpr uint32_t STF = (1U << 7);  ///< Security Tamper Flag
        constexpr uint32_t FSF = (1U << 8);  ///< Flash Security Flag
        constexpr uint32_t TMF = (1U << 9);  ///< Test Mode Flag
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t TPF = (8 << 16);  ///< Tamper Pin Flag
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t KVL = (1U << 1);  ///< Key Valid Lock
        constexpr uint32_t KWL = (1U << 2);  ///< Key Write Lock
        constexpr uint32_t KRL = (1U << 3);  ///< Key Read Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
        constexpr uint32_t IEL = (1U << 7);  ///< Interrupt Enable Lock
        constexpr uint32_t TSL = (1U << 8);  ///< Tamper Seconds Lock
        constexpr uint32_t TEL = (1U << 9);  ///< Tamper Enable Lock
        constexpr uint32_t PDL = (1U << 10);  ///< Pin Direction Lock
        constexpr uint32_t PPL = (1U << 11);  ///< Pin Polarity Lock
        constexpr uint32_t ATL = (2 << 12);  ///< Active Tamper Lock
        constexpr uint32_t GFL = (8 << 16);  ///< Glitch Filter Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t DTIE = (1U << 0);  ///< DryIce Tamper Interrupt Enable
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t TOIE = (1U << 2);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t MOIE = (1U << 3);  ///< Monotonic Overflow Interrupt Enable
        constexpr uint32_t VTIE = (1U << 4);  ///< Voltage Tamper Interrupt Enable
        constexpr uint32_t CTIE = (1U << 5);  ///< Clock Tamper Interrupt Enable
        constexpr uint32_t TTIE = (1U << 6);  ///< Temperature Tamper Interrupt Enable
        constexpr uint32_t STIE = (1U << 7);  ///< Security Tamper Interrupt Enable
        constexpr uint32_t FSIE = (1U << 8);  ///< Flash Security Interrupt Enable
        constexpr uint32_t TMIE = (1U << 9);  ///< Test Mode Interrupt Enable
        constexpr uint32_t TPIE = (8 << 16);  ///< Tamper Pin Interrupt Enable
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TTS = (32 << 0);  ///< Tamper Time Seconds
    }

    /// TER Register bits
    namespace ter_bits {
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t TOE = (1U << 2);  ///< Time Overflow Enable
        constexpr uint32_t MOE = (1U << 3);  ///< Monotonic Overflow Enable
        constexpr uint32_t VTE = (1U << 4);  ///< Voltage Tamper Enable
        constexpr uint32_t CTE = (1U << 5);  ///< Clock Tamper Enable
        constexpr uint32_t TTE = (1U << 6);  ///< Temperature Tamper Enable
        constexpr uint32_t STE = (1U << 7);  ///< Security Tamper Enable
        constexpr uint32_t FSE = (1U << 8);  ///< Flash Security Enable
        constexpr uint32_t TME = (1U << 9);  ///< Test Mode Enable
        constexpr uint32_t TPE = (8 << 16);  ///< Tamper Pin Enable
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t TPD = (8 << 0);  ///< Tamper Pin Direction
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t TPOD = (8 << 16);  ///< Tamper Pin Output Data
    }

    /// PPR Register bits
    namespace ppr_bits {
        constexpr uint32_t TPP = (8 << 0);  ///< Tamper Pin Polarity
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t TPID = (8 << 16);  ///< Tamper Pin Input Data
    }

    /// ATR Register bits
    namespace atr_bits {
        constexpr uint32_t ATSR = (16 << 0);  ///< Active Tamper Shift Register
        constexpr uint32_t ATP = (16 << 16);  ///< Active Tamper Polynomial
    }

    /// PGFR Register bits
    namespace pgfr_bits {
        constexpr uint32_t GFW = (6 << 0);  ///< Glitch Filter Width
        constexpr uint32_t GFP = (1U << 6);  ///< Glitch Filter Prescaler
        constexpr uint32_t GFE = (1U << 7);  ///< Glitch Filter Enable
        constexpr uint32_t RESERVED = (7 << 25);  ///< no description available
        constexpr uint32_t TPEX = (2 << 16);  ///< Tamper Pin Expected
        constexpr uint32_t TPE = (1U << 24);  ///< Tamper Pull Enable
    }

    /// WAC Register bits
    namespace wac_bits {
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t SKVW = (1U << 1);  ///< Secure Key Valid Write
        constexpr uint32_t SKWRW = (1U << 2);  ///< Secure Key Write Lock Register Write
        constexpr uint32_t SKRRW = (1U << 3);  ///< Secure Key Read Lock Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IEW = (1U << 7);  ///< Interrupt Enable Write
        constexpr uint32_t TSRW = (1U << 8);  ///< Tamper Seconds Register Write
        constexpr uint32_t TEW = (1U << 9);  ///< Tamper Enable Write
        constexpr uint32_t PDW = (1U << 10);  ///< Pin Direction Write
        constexpr uint32_t PPW = (1U << 11);  ///< Pin Polarity Write
        constexpr uint32_t ATW = (2 << 12);  ///< Active Tamper Write
        constexpr uint32_t GFW = (8 << 16);  ///< Glitch Filter Write
    }

    /// RAC Register bits
    namespace rac_bits {
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t SKVR = (1U << 1);  ///< Secure Key Valid Read
        constexpr uint32_t SKWRR = (1U << 2);  ///< Secure Key Write Lock Register Read
        constexpr uint32_t SKRRR = (1U << 3);  ///< Secure Key Read Lock Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IER = (1U << 7);  ///< Interrupt Enable Read
        constexpr uint32_t TSRR = (1U << 8);  ///< Tamper Seconds Register Read
        constexpr uint32_t TER = (1U << 9);  ///< Tamper Enable Read
        constexpr uint32_t PDR = (1U << 10);  ///< Pin Direction Read
        constexpr uint32_t PPR = (1U << 11);  ///< Pin Polarity Read
        constexpr uint32_t ATR = (2 << 12);  ///< Active Tamper Read
        constexpr uint32_t GFR = (8 << 16);  ///< Glitch Filter Read
    }

    /// SKR Register bits
    namespace skr_bits {
        constexpr uint32_t SK = (32 << 0);  ///< Secure Key
    }

    /// SWAC Register bits
    namespace swac_bits {
        constexpr uint32_t SKRW = (8 << 0);  ///< Secure Key Register Write
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SRAC Register bits
    namespace srac_bits {
        constexpr uint32_t SKRR = (8 << 0);  ///< Secure Key Register Read
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - General Control and Status Register
        volatile uint32_t SCANC;  ///< Offset: 0x04 - SCAN Control Register
        volatile uint32_t PEN;  ///< Offset: 0x08 - Pin Enable Register
        volatile uint32_t WUCNTR;  ///< Offset: 0x0C - Wake-Up Channel Counter Register
        volatile uint32_t CNTR;  ///< Offset: 0x100 - Counter Register (renamed from CNTR)
        volatile uint32_t THRESHOLD;  ///< Offset: 0x120 - Low Power Channel Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t STPE = (1U << 0);  ///< no description available
        constexpr uint32_t STM = (1U << 1);  ///< Scan Trigger Mode. This bit-field can only be changed if the TSI module is disabled (TSIEN bit = 0).
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t ESOR = (1U << 4);  ///< End-of-Scan or Out-of-Range Interrupt select
        constexpr uint32_t ERIE = (1U << 5);  ///< Error Interrupt Enable
        constexpr uint32_t TSIIE = (1U << 6);  ///< Touch Sensing Input Interrupt Module Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t SWTS = (1U << 8);  ///< Software Trigger Start
        constexpr uint32_t SCNIP = (1U << 9);  ///< Scan In Progress status
        constexpr uint32_t OVRF = (1U << 12);  ///< Overrun error Flag. This flag is set when a scan trigger occurs while a scan is still in progress. Writing "1" to this bit will clear the flag to 0.
        constexpr uint32_t EXTERF = (1U << 13);  ///< External Electrode error occurred
        constexpr uint32_t OUTRGF = (1U << 14);  ///< Out of Range Flag.
        constexpr uint32_t EOSF = (1U << 15);  ///< End of Scan Flag.
        constexpr uint32_t PS = (3 << 16);  ///< Electrode Oscillator prescaler. .
        constexpr uint32_t NSCN = (5 << 19);  ///< Number of Consecutive Scans per Electrode electrode.
        constexpr uint32_t LPSCNITV = (4 << 24);  ///< TSI Low Power Mode Scan Interval.
        constexpr uint32_t LPCLKS = (1U << 28);  ///< Low Power Mode Clock Source Selection.
    }

    /// SCANC Register bits
    namespace scanc_bits {
        constexpr uint32_t AMPSC = (3 << 0);  ///< Active Mode Prescaler
        constexpr uint32_t AMCLKS = (2 << 3);  ///< Active Mode Clock Source
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t SMOD = (8 << 8);  ///< Scan Module
        constexpr uint32_t EXTCHRG = (4 << 16);  ///< External OSC Charge Current select
        constexpr uint32_t REFCHRG = (4 << 24);  ///< Ref OSC Charge Current select
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN0 = (1U << 0);  ///< Touch Sensing Input Pin Enable Register 0
        constexpr uint32_t PEN1 = (1U << 1);  ///< Touch Sensing Input Pin Enable Register 1
        constexpr uint32_t PEN2 = (1U << 2);  ///< Touch Sensing Input Pin Enable Register 2
        constexpr uint32_t PEN3 = (1U << 3);  ///< Touch Sensing Input Pin Enable Register 3
        constexpr uint32_t PEN4 = (1U << 4);  ///< Touch Sensing Input Pin Enable Register 4
        constexpr uint32_t PEN5 = (1U << 5);  ///< Touch Sensing Input Pin Enable Register 5
        constexpr uint32_t PEN6 = (1U << 6);  ///< Touch Sensing Input Pin Enable Register 6
        constexpr uint32_t PEN7 = (1U << 7);  ///< Touch Sensing Input Pin Enable Register 7
        constexpr uint32_t PEN8 = (1U << 8);  ///< Touch Sensing Input Pin Enable Register 8
        constexpr uint32_t PEN9 = (1U << 9);  ///< Touch Sensing Input Pin Enable Register 9
        constexpr uint32_t PEN10 = (1U << 10);  ///< Touch Sensing Input Pin Enable Register 10
        constexpr uint32_t PEN11 = (1U << 11);  ///< Touch Sensing Input Pin Enable Register 11
        constexpr uint32_t PEN12 = (1U << 12);  ///< Touch Sensing Input Pin Enable Register 12
        constexpr uint32_t PEN13 = (1U << 13);  ///< Touch Sensing Input Pin Enable Register 13
        constexpr uint32_t PEN14 = (1U << 14);  ///< Touch Sensing Input Pin Enable Register 14
        constexpr uint32_t PEN15 = (1U << 15);  ///< Touch Sensing Input Pin Enable Register 15
        constexpr uint32_t LPSP = (4 << 16);  ///< Low Power Scan Pin
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
    }

    /// WUCNTR Register bits
    namespace wucntr_bits {
        constexpr uint32_t WUCNT = (16 << 0);  ///< TouchSensing wake-up Channel 16bit counter value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t CTN1 = (16 << 0);  ///< TouchSensing Channel n-1 16-bit counter value
        constexpr uint32_t CTN = (16 << 16);  ///< TouchSensing Channel n 16-bit counter value
    }

    /// THRESHOLD Register bits
    namespace threshold_bits {
        constexpr uint32_t HTHH = (16 << 0);  ///< Touch Sensing Channel High Threshold value
        constexpr uint32_t LTHH = (16 << 16);  ///< Touch Sensing Channel Low Threshold value
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT6;  ///< Offset: 0x1014 - System Options Register 6
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC1;  ///< Offset: 0x1028 - System Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x102C - System Clock Gating Control Register 2
        volatile uint32_t SCGC3;  ///< Offset: 0x1030 - System Clock Gating Control Register 3
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t CLKDIV3;  ///< Offset: 0x1064 - System Clock Divider Register 3
        volatile uint32_t CLKDIV4;  ///< Offset: 0x1068 - System Clock Divider Register 4
        volatile uint32_t MCR;  ///< Offset: 0x106C - Misc Control Register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RESERVED = (9 << 20);  ///< no description available
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (1U << 19);  ///< 32 kHz oscillator clock select
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR or VLPW
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS or VLLS
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t RESERVED = (5 << 27);  ///< no description available
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RESERVED = (2 << 24);  ///< no description available
        constexpr uint32_t USBHSRC = (2 << 2);  ///< USB HS clock source select
        constexpr uint32_t RTCCLKOUTSEL = (1U << 4);  ///< RTC clock out select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< Clock out select
        constexpr uint32_t FBSL = (2 << 8);  ///< Flexbus security level
        constexpr uint32_t CMTUARTPAD = (1U << 11);  ///< CMT/UART pad drive strength
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t LCDC_CLKSEL = (1U << 14);  ///< LCDC pixel clock select
        constexpr uint32_t NFC_CLKSEL = (1U << 15);  ///< NFC Flash clock select
        constexpr uint32_t PLLFLLSEL = (2 << 16);  ///< PLL/FLL clock select
        constexpr uint32_t USBF_CLKSEL = (1U << 18);  ///< USB FS clock select
        constexpr uint32_t TIMESRC = (2 << 20);  ///< Ethernet timestamp clock source select
        constexpr uint32_t USBFSRC = (2 << 22);  ///< USB FS clock source select
        constexpr uint32_t LCDCSRC = (2 << 26);  ///< LCDC Pixel clock source select
        constexpr uint32_t ESDHCSRC = (2 << 28);  ///< ESDHC perclk source select
        constexpr uint32_t NFCSRC = (2 << 30);  ///< NFC Flash clock source select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FlexTimer 0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FlexTimer 0 Fault 1 Select
        constexpr uint32_t FTM0FLT2 = (1U << 2);  ///< FlexTimer 0 Fault 2 Select
        constexpr uint32_t FTM0FLT3 = (1U << 3);  ///< FlexTimer 0 Fault 3 Select.
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FlexTimer 1 Fault 0 Select
        constexpr uint32_t RESERVED = (2 << 22);  ///< no description available
        constexpr uint32_t FTM2FLT0 = (1U << 8);  ///< FlexTimer 2 Fault 0 Select
        constexpr uint32_t FTM3FLT0 = (1U << 12);  ///< FlexTimer 3 Fault 0 Select.
        constexpr uint32_t FTM1CH0SRC = (2 << 18);  ///< FlexTimer 1 channel 0 input capture source select
        constexpr uint32_t FTM2CH0SRC = (2 << 20);  ///< FlexTimer 2 channel 0 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 external clock pin select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FlexTimer 1 external clock pin select
        constexpr uint32_t FTM2CLKSEL = (1U << 26);  ///< FlexTimer 2 external clock pin select
        constexpr uint32_t FTM3CLKSEL = (1U << 27);  ///< FlexTimer 3 external clock pin select
        constexpr uint32_t FTM0TRG0SRC = (1U << 28);  ///< FlexTimer 0 hardware trigger 0 source select
        constexpr uint32_t FTM0TRG1SRC = (1U << 29);  ///< FlexTimer 0 hardware trigger 1 source select
        constexpr uint32_t FTM3TRG0SRC = (1U << 30);  ///< FlexTimer 3 hardware trigger 0 source select
        constexpr uint32_t FTM3TRG1SRC = (1U << 31);  ///< FlexTimer 3 hardware trigger 1 source select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (2 << 0);  ///< UART0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART0 receive data source select
        constexpr uint32_t UART1TXSRC = (2 << 4);  ///< UART1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART1 receive data source select
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SOPT6 Register bits
    namespace sopt6_bits {
        constexpr uint32_t MCC = (16 << 0);  ///< MCC
        constexpr uint32_t PCR = (4 << 16);  ///< PCR
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pre-trigger select
        constexpr uint32_t RESERVED = (2 << 29);  ///< no description available
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 alternate trigger enable
        constexpr uint32_t ADC1TRGSEL = (4 << 8);  ///< ADC1 trigger select
        constexpr uint32_t ADC1PRETRGSEL = (1U << 12);  ///< ADC1 pre-trigger select
        constexpr uint32_t ADC1ALTTRGEN = (1U << 15);  ///< ADC1 alternate trigger enable
        constexpr uint32_t ADC2TRGSEL = (4 << 16);  ///< ADC2 trigger select
        constexpr uint32_t ADC2PRETRGSEL = (1U << 20);  ///< ADC2 pre-trigger select
        constexpr uint32_t ADC2ALTTRGEN = (1U << 23);  ///< ADC2 alternate trigger enable
        constexpr uint32_t ADC3TRGSEL = (4 << 24);  ///< ADC3 trigger select
        constexpr uint32_t ADC3PRETRGSEL = (1U << 28);  ///< ADC3 pre-trigger select
        constexpr uint32_t ADC3ALTTRGEN = (1U << 31);  ///< ADC3 alternate trigger enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family identification
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
    }

    /// SCGC1 Register bits
    namespace scgc1_bits {
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
        constexpr uint32_t OSC1 = (1U << 5);  ///< OSC1 clock gate control
        constexpr uint32_t UART4 = (1U << 10);  ///< UART4 clock gate control
        constexpr uint32_t UART5 = (1U << 11);  ///< UART5 clock gate control
    }

    /// SCGC2 Register bits
    namespace scgc2_bits {
        constexpr uint32_t ENET = (1U << 0);  ///< ENET clock gate control
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
        constexpr uint32_t DAC0 = (1U << 12);  ///< 12BDAC0 clock gate control
        constexpr uint32_t DAC1 = (1U << 13);  ///< 12BDAC1 clock gate control
    }

    /// SCGC3 Register bits
    namespace scgc3_bits {
        constexpr uint32_t RNGA = (1U << 0);  ///< RNGA clock gate control
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t FLEXCAN1 = (1U << 4);  ///< FlexCAN1 clock gate control
        constexpr uint32_t NFC = (1U << 8);  ///< NFC clock gate control
        constexpr uint32_t DSPI2 = (1U << 12);  ///< DSPI2 clock gate control
        constexpr uint32_t DDR = (1U << 14);  ///< DDR clock gate control
        constexpr uint32_t SAI1 = (1U << 15);  ///< SAI1 clock gate control
        constexpr uint32_t ESDHC = (1U << 17);  ///< ESDHC clock gate control
        constexpr uint32_t LCDC = (1U << 22);  ///< LCDC clock gate control
        constexpr uint32_t FTM2 = (1U << 24);  ///< FTM2 clock gate control
        constexpr uint32_t FTM3 = (1U << 25);  ///< FTM3 clock gate control
        constexpr uint32_t ADC1 = (1U << 27);  ///< ADC1 clock gate control
        constexpr uint32_t ADC3 = (1U << 28);  ///< ADC3 clock gate control
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t EWM = (1U << 1);  ///< EWM clock gate control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT clock gate control
        constexpr uint32_t IIC0 = (1U << 6);  ///< IIC0 clock gate control
        constexpr uint32_t IIC1 = (1U << 7);  ///< IIC1 clock gate control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 clock gate control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 clock gate control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 clock gate control
        constexpr uint32_t UART3 = (1U << 13);  ///< UART3 clock gate control
        constexpr uint32_t USBFS = (1U << 18);  ///< USB FS clock gate control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator clock gate control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF clock gate control
        constexpr uint32_t LLWU = (1U << 28);  ///< LLWU Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTIMER = (1U << 0);  ///< LPTMR clock gate control
        constexpr uint32_t REGFILE = (1U << 1);  ///< Register File Clock Gate Control
        constexpr uint32_t DRYICE = (1U << 2);  ///< Dryice clock gate control
        constexpr uint32_t DRYICESECREG = (1U << 3);  ///< Dryice secure storage clock gate control
        constexpr uint32_t RESERVED = (13 << 19);  ///< no description available
        constexpr uint32_t TSI = (1U << 5);  ///< TSI clock gate control
        constexpr uint32_t PORTA = (1U << 9);  ///< PORTA clock gate control
        constexpr uint32_t PORTB = (1U << 10);  ///< PORTB clock gate control
        constexpr uint32_t PORTC = (1U << 11);  ///< PORTC clock gate control
        constexpr uint32_t PORTD = (1U << 12);  ///< PORTD clock gate control
        constexpr uint32_t PORTE = (1U << 13);  ///< PORTE clock gate control
        constexpr uint32_t PORTF = (1U << 14);  ///< PORTF clock gate control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t DMAMUX0 = (1U << 1);  ///< DMAMUX0 clock gate control
        constexpr uint32_t DMAMUX1 = (1U << 2);  ///< DMAMUX1 clock gate control
        constexpr uint32_t FLEXCAN0 = (1U << 4);  ///< FlexCAN0 clock gate control
        constexpr uint32_t DSPI0 = (1U << 12);  ///< DSPI0 clock gate control
        constexpr uint32_t DSPI1 = (1U << 13);  ///< DSPI1 clock gate control
        constexpr uint32_t SAI0 = (1U << 15);  ///< SAI0 clock gate control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC clock gate control
        constexpr uint32_t USBHS = (1U << 20);  ///< USBHS clock gate control
        constexpr uint32_t USBDCD = (1U << 21);  ///< USB DCD clock gate control
        constexpr uint32_t PDB = (1U << 22);  ///< PDB clock gate control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT clock gate control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 clock gate control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 clock gate control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 clock gate control
        constexpr uint32_t ADC2 = (1U << 28);  ///< ADC2 clock gate control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC clock gate control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus controller clock gate control
        constexpr uint32_t DMA = (1U << 1);  ///< DMA controller clock gate control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU clock gate control
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t RESERVED = (16 << 0);  ///< no description available
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (4 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t USBFSFRAC = (1U << 0);  ///< USB FS clock divider fraction
        constexpr uint32_t USBFSDIV = (3 << 1);  ///< USB FS clock divider divisor
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
        constexpr uint32_t USBHSFRAC = (1U << 8);  ///< USB HS clock divider fraction
        constexpr uint32_t USBHSDIV = (3 << 9);  ///< USB HS clock divider divisor
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FTFDIS = (1U << 0);  ///< Disable FTFE
        constexpr uint32_t RESERVED = (4 << 20);  ///< no description available
        constexpr uint32_t DEPART = (4 << 8);  ///< FlexNVM partition
        constexpr uint32_t EESIZE = (4 << 16);  ///< EEPROM size
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t MAXADDR23 = (6 << 16);  ///< Max address block 2 or 3
        constexpr uint32_t MAXADDR01 = (6 << 24);  ///< Max address block 0 or 1
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// CLKDIV3 Register bits
    namespace clkdiv3_bits {
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t LCDCFRAC = (8 << 8);  ///< LCDCFRAC clock divider fraction.
        constexpr uint32_t LCDCDIV = (12 << 16);  ///< LCDC Clock divder fraction
    }

    /// CLKDIV4 Register bits
    namespace clkdiv4_bits {
        constexpr uint32_t TRACEFRAC = (1U << 0);  ///< Trace clock divider fraction
        constexpr uint32_t TRACEDIV = (3 << 1);  ///< Trace clock divider divisor
        constexpr uint32_t RESERVED = (20 << 4);  ///< no description available
        constexpr uint32_t NFCFRAC = (3 << 24);  ///< NFC clock divider fraction
        constexpr uint32_t NFCDIV = (5 << 27);  ///< NFC clock divider divisor
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t DDRSREN = (1U << 0);  ///< DDR self refresh enable
        constexpr uint32_t DDRS = (1U << 1);  ///< DDR Self Refresh Status
        constexpr uint32_t DDRPEN = (1U << 2);  ///< Pin enable for all DDR I/O
        constexpr uint32_t DDRDQSDIS = (1U << 3);  ///< DDR_DQS analog circuit disable
        constexpr uint32_t RESERVED = (12 << 17);  ///< no description available
        constexpr uint32_t DDRCFG = (3 << 5);  ///< DDR configuration select
        constexpr uint32_t RCRRSTEN = (1U << 8);  ///< DDR RCR Special Reset Enable
        constexpr uint32_t RCRRST = (1U << 9);  ///< DDR RCR Reset Status
        constexpr uint32_t LCDSTART = (1U << 16);  ///< Start LCDC display
        constexpr uint32_t PDBLOOP = (1U << 29);  ///< PDB Loop Mode
        constexpr uint32_t ULPICLKOBE = (1U << 30);  ///< 60 MHz ULPI clock (ULPI_CLK) output enable
        constexpr uint32_t TRACECLKDIS = (1U << 31);  ///< Trace clock disable.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t PORTF_BASE = 0x4004E000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR;  ///< Offset: 0x00 - Pin Control Register n (renamed from PCR)
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
        volatile uint32_t DFER;  ///< Offset: 0xC0 - Digital Filter Enable Register
        volatile uint32_t DFCR;  ///< Offset: 0xC4 - Digital Filter Clock Register
        volatile uint32_t DFWR;  ///< Offset: 0xC8 - Digital Filter Width Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* PORTF = reinterpret_cast<Registers*>(PORTF_BASE);

    // Bit definitions
    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t RESERVED = (7 << 25);  ///< no description available
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

    /// DFER Register bits
    namespace dfer_bits {
        constexpr uint32_t DFE = (32 << 0);  ///< Digital Filter Enable
    }

    /// DFCR Register bits
    namespace dfcr_bits {
        constexpr uint32_t CS = (1U << 0);  ///< Clock Source
        constexpr uint32_t RESERVED = (31 << 1);  ///< no description available
    }

    /// DFWR Register bits
    namespace dfwr_bits {
        constexpr uint32_t FILT = (5 << 0);  ///< Filter Length
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh Register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock Register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count Register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler Register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< no description available
        constexpr uint32_t CLKSRC = (1U << 1);  ///< no description available
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< no description available
        constexpr uint32_t WINEN = (1U << 3);  ///< no description available
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< no description available
        constexpr uint32_t DBGEN = (1U << 5);  ///< no description available
        constexpr uint32_t STOPEN = (1U << 6);  ///< no description available
        constexpr uint32_t WAITEN = (1U << 7);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 15);  ///< no description available
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< no description available
        constexpr uint32_t TESTSEL = (1U << 11);  ///< no description available
        constexpr uint32_t BYTESEL = (2 << 12);  ///< no description available
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< no description available
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t RESERVED = (15 << 0);  ///< no description available
        constexpr uint32_t INTFLG = (1U << 15);  ///< no description available
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< no description available
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< no description available
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< no description available
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< no description available
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< no description available
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< no description available
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< no description available
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< no description available
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< no description available
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t RESERVED = (5 << 11);  ///< no description available
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< no description available
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< no description available
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< no description available
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< no description available
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< no description available
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< no description available
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< no description available
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< no description available
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (7 << 1);  ///< no description available
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
        volatile uint32_t C10;  ///< Offset: 0x0F - MCG Control 10 Register
        volatile uint32_t C11;  ///< Offset: 0x10 - MCG Control 11 Register
        volatile uint32_t C12;  ///< Offset: 0x11 - MCG Control 12 Register
        volatile uint32_t S2;  ///< Offset: 0x12 - MCG Status 2 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS0 = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO0 = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE0 = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV0 = (3 << 0);  ///< PLL0 External Reference Divider
        constexpr uint32_t RESERVED = (2 << 3);  ///< Reserved
        constexpr uint32_t PLLSTEN0 = (1U << 5);  ///< PLL0 Stop Enable
        constexpr uint32_t PLLCLKEN0 = (1U << 6);  ///< PLL Clock Enable
        constexpr uint32_t PLLREFSEL0 = (1U << 7);  ///< PLL0 External Reference Select
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV0 = (5 << 0);  ///< VCO0 Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS0 = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
        constexpr uint32_t RESERVED = (7 << 1);  ///< no description available
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C10 Register bits
    namespace c10_bits {
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t EREFS1 = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO1 = (1U << 3);  ///< High Gain Oscillator1 Select
        constexpr uint32_t RANGE1 = (2 << 4);  ///< Frequency Range1 Select
        constexpr uint32_t LOCRE2 = (1U << 7);  ///< OSC1 Loss of Clock Reset Enable
    }

    /// C11 Register bits
    namespace c11_bits {
        constexpr uint32_t PRDIV1 = (3 << 0);  ///< PLL1 External Reference Divider
        constexpr uint32_t RESERVED = (1U << 3);  ///< no description available
        constexpr uint32_t PLLCS = (1U << 4);  ///< PLL Clock Select
        constexpr uint32_t PLLSTEN1 = (1U << 5);  ///< PLL1 Stop Enable
        constexpr uint32_t PLLCLKEN1 = (1U << 6);  ///< PLL1 Clock Enable
        constexpr uint32_t PLLREFSEL1 = (1U << 7);  ///< PLL1 External Reference Select
    }

    /// C12 Register bits
    namespace c12_bits {
        constexpr uint32_t VDIV1 = (5 << 0);  ///< VCO1 Divider
        constexpr uint32_t CME2 = (1U << 5);  ///< Clock Monitor Enable2
        constexpr uint32_t RESERVED = (1U << 6);  ///< Reserved
        constexpr uint32_t LOLIE1 = (1U << 7);  ///< PLL1 Loss of Lock Interrupt Enable
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t LOCS2 = (1U << 0);  ///< OSC1 Loss of Clock Status
        constexpr uint32_t OSCINIT1 = (1U << 1);  ///< OSC1 Initialization
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t PLLCST = (1U << 4);  ///< PLL Clock Select Status
        constexpr uint32_t LOCK1 = (1U << 6);  ///< Lock1 Status
        constexpr uint32_t LOLS1 = (1U << 7);  ///< Loss of Lock2 Status
    }

}

// ============================================================================
// OSC0 Peripheral
// ============================================================================

namespace osc0 {
    /// Base addresses
    constexpr uint32_t OSC0_BASE = 0x40065000;

    /// OSC0 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC0 = reinterpret_cast<Registers*>(OSC0_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// OSC1 Peripheral
// ============================================================================

namespace osc1 {
    /// Base addresses
    constexpr uint32_t OSC1_BASE = 0x400E5000;

    /// OSC1 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC1 = reinterpret_cast<Registers*>(OSC1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status Register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t RESERVED = (1U << 0);  ///< no description available
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< Clock rate
        constexpr uint32_t MULT = (2 << 6);  ///< no description available
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit acknowledge enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit mode select
        constexpr uint32_t MST = (1U << 5);  ///< Master mode select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C interrupt enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave read/write
        constexpr uint32_t RAM = (1U << 3);  ///< Range address match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed as a slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer complete flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range address matching enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave baud rate control
        constexpr uint32_t HDRS = (1U << 5);  ///< High drive select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General call address enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (5 << 0);  ///< I2C programmable filter factor
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RESERVED = (1U << 0);  ///< no description available
        constexpr uint32_t RAD = (7 << 1);  ///< Range slave address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 interrupt enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL high timeout flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL high timeout flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL low timeout flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout counter clock select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C address enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus alert response address enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t RESERVED = (1U << 0);  ///< no description available
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;
    constexpr uint32_t UART3_BASE = 0x4006D000;
    constexpr uint32_t UART4_BASE = 0x400EA000;
    constexpr uint32_t UART5_BASE = 0x400EB000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
        volatile uint32_t C7816;  ///< Offset: 0x18 - UART 7816 Control Register
        volatile uint32_t IE7816;  ///< Offset: 0x19 - UART 7816 Interrupt Enable Register
        volatile uint32_t IS7816;  ///< Offset: 0x1A - UART 7816 Interrupt Status Register
        volatile uint32_t WP7816T1;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WP7816T0;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WN7816;  ///< Offset: 0x1C - UART 7816 Wait N Register
        volatile uint32_t WF7816;  ///< Offset: 0x1D - UART 7816 Wait FD Register
        volatile uint32_t ET7816;  ///< Offset: 0x1E - UART 7816 Error Threshold Register
        volatile uint32_t TL7816;  ///< Offset: 0x1F - UART 7816 Transmit Length Register
        volatile uint32_t C6;  ///< Offset: 0x21 - UART CEA709.1-B Control Register 6
        volatile uint32_t PCTH;  ///< Offset: 0x22 - UART CEA709.1-B Packet Cycle Time Counter High
        volatile uint32_t PCTL;  ///< Offset: 0x23 - UART CEA709.1-B Packet Cycle Time Counter Low
        volatile uint32_t B1T;  ///< Offset: 0x24 - UART CEA709.1-B Beta1 Timer
        volatile uint32_t SDTH;  ///< Offset: 0x25 - UART CEA709.1-B Secondary Delay Timer High
        volatile uint32_t SDTL;  ///< Offset: 0x26 - UART CEA709.1-B Secondary Delay Timer Low
        volatile uint32_t PRE;  ///< Offset: 0x27 - UART CEA709.1-B Preamble
        volatile uint32_t TPL;  ///< Offset: 0x28 - UART CEA709.1-B Transmit Packet Length
        volatile uint32_t IE;  ///< Offset: 0x29 - UART CEA709.1-B Interrupt Enable Register
        volatile uint32_t WB;  ///< Offset: 0x2A - UART CEA709.1-B WBASE
        volatile uint32_t S3;  ///< Offset: 0x2B - UART CEA709.1-B Status Register
        volatile uint32_t S4;  ///< Offset: 0x2C - UART CEA709.1-B Status Register
        volatile uint32_t RPL;  ///< Offset: 0x2D - UART CEA709.1-B Received Packet Length
        volatile uint32_t RPREL;  ///< Offset: 0x2E - UART CEA709.1-B Received Preamble Length
        volatile uint32_t CPW;  ///< Offset: 0x2F - UART CEA709.1-B Collision Pulse Width
        volatile uint32_t RIDT;  ///< Offset: 0x30 - UART CEA709.1-B Receive Indeterminate Time
        volatile uint32_t TIDT;  ///< Offset: 0x31 - UART CEA709.1-B Transmit Indeterminate Time
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 3);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< no description available
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t RESERVED = (6 << 0);  ///< no description available
        constexpr uint32_t PARITYE = (1U << 6);  ///< no description available
        constexpr uint32_t NOISY = (1U << 7);  ///< no description available
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXOFE = (1U << 2);  ///< Receive FIFO Overflow Interrupt Enable
        constexpr uint32_t RESERVED = (3 << 3);  ///< no description available
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXOF = (1U << 2);  ///< Receiver Buffer Overflow Flag
        constexpr uint32_t RESERVED = (3 << 3);  ///< no description available
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

    /// C7816 Register bits
    namespace c7816_bits {
        constexpr uint32_t ISO_7816E = (1U << 0);  ///< ISO-7816 Functionality Enabled
        constexpr uint32_t TTYPE = (1U << 1);  ///< Transfer Type
        constexpr uint32_t INIT = (1U << 2);  ///< Detect Initial Character
        constexpr uint32_t ANACK = (1U << 3);  ///< Generate NACK on Error
        constexpr uint32_t ONACK = (1U << 4);  ///< Generate NACK on Overflow
        constexpr uint32_t RESERVED = (3 << 5);  ///< no description available
    }

    /// IE7816 Register bits
    namespace ie7816_bits {
        constexpr uint32_t RXTE = (1U << 0);  ///< Receive Threshold Exceeded Interrupt Enable
        constexpr uint32_t TXTE = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt Enable
        constexpr uint32_t GTVE = (1U << 2);  ///< Guard Timer Violated Interrupt Enable
        constexpr uint32_t RESERVED = (1U << 3);  ///< no description available
        constexpr uint32_t INITDE = (1U << 4);  ///< Initial Character Detected Interrupt Enable
        constexpr uint32_t BWTE = (1U << 5);  ///< Block Wait Timer Interrupt Enable
        constexpr uint32_t CWTE = (1U << 6);  ///< Character Wait Timer Interrupt Enable
        constexpr uint32_t WTE = (1U << 7);  ///< Wait Timer Interrupt Enable
    }

    /// IS7816 Register bits
    namespace is7816_bits {
        constexpr uint32_t RXT = (1U << 0);  ///< Receive Threshold Exceeded Interrupt
        constexpr uint32_t TXT = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt
        constexpr uint32_t GTV = (1U << 2);  ///< Guard Timer Violated Interrupt
        constexpr uint32_t RESERVED = (1U << 3);  ///< no description available
        constexpr uint32_t INITD = (1U << 4);  ///< Initial Character Detected Interrupt
        constexpr uint32_t BWT = (1U << 5);  ///< Block Wait Timer Interrupt
        constexpr uint32_t CWT = (1U << 6);  ///< Character Wait Timer Interrupt
        constexpr uint32_t WT = (1U << 7);  ///< Wait Timer Interrupt
    }

    /// WP7816T1 Register bits
    namespace wp7816t1_bits {
        constexpr uint32_t BWI = (4 << 0);  ///< Block Wait Time Integer(C7816[TTYPE] = 1)
        constexpr uint32_t CWI = (4 << 4);  ///< Character Wait Time Integer (C7816[TTYPE] = 1)
    }

    /// WP7816T0 Register bits
    namespace wp7816t0_bits {
        constexpr uint32_t WI = (8 << 0);  ///< Wait Timer Interrupt (C7816[TTYPE] = 0)
    }

    /// WN7816 Register bits
    namespace wn7816_bits {
        constexpr uint32_t GTN = (8 << 0);  ///< Guard Band N
    }

    /// WF7816 Register bits
    namespace wf7816_bits {
        constexpr uint32_t GTFD = (8 << 0);  ///< FD Multiplier
    }

    /// ET7816 Register bits
    namespace et7816_bits {
        constexpr uint32_t RXTHRESHOLD = (4 << 0);  ///< Receive NACK Threshold
        constexpr uint32_t TXTHRESHOLD = (4 << 4);  ///< Transmit NACK Threshold
    }

    /// TL7816 Register bits
    namespace tl7816_bits {
        constexpr uint32_t TLEN = (8 << 0);  ///< Transmit Length
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t RESERVED = (4 << 0);  ///< no description available
        constexpr uint32_t CP = (1U << 4);  ///< Collision Signal Polarity
        constexpr uint32_t CE = (1U << 5);  ///< Collision Enable
        constexpr uint32_t TX709 = (1U << 6);  ///< CEA709.1-B Transmit Enable
        constexpr uint32_t EN709 = (1U << 7);  ///< EN709
    }

    /// PCTH Register bits
    namespace pcth_bits {
        constexpr uint32_t PCTH = (8 << 0);  ///< Packet Cycle Time Counter High
    }

    /// PCTL Register bits
    namespace pctl_bits {
        constexpr uint32_t PCTL = (8 << 0);  ///< Packet Cycle Time Counter Low
    }

    /// B1T Register bits
    namespace b1t_bits {
        constexpr uint32_t B1T = (8 << 0);  ///< Beta1 Timer
    }

    /// SDTH Register bits
    namespace sdth_bits {
        constexpr uint32_t SDTH = (8 << 0);  ///< Secondary Delay Timer High
    }

    /// SDTL Register bits
    namespace sdtl_bits {
        constexpr uint32_t SDTL = (8 << 0);  ///< Secondary Delay Timer Low
    }

    /// PRE Register bits
    namespace pre_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< CEA709.1-B Preamble Register
    }

    /// TPL Register bits
    namespace tpl_bits {
        constexpr uint32_t TPL = (8 << 0);  ///< Transmit Packet Length Register
    }

    /// IE Register bits
    namespace ie_bits {
        constexpr uint32_t TXFIE = (1U << 0);  ///< Transmission Fail Interrupt Enable
        constexpr uint32_t PSIE = (1U << 1);  ///< Preamble Start Interrupt Enable
        constexpr uint32_t PCTEIE = (1U << 2);  ///< Packet Cycle Timer Interrupt Enable
        constexpr uint32_t PTXIE = (1U << 3);  ///< Packet Transmitted Interrupt Enable
        constexpr uint32_t PRXIE = (1U << 4);  ///< Packet Received Interrupt Enable
        constexpr uint32_t ISDIE = (1U << 5);  ///< Initial Sync Detection Interrupt Enable
        constexpr uint32_t WBEIE = (1U << 6);  ///< WBASE Expired Interrupt Enable
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

    /// WB Register bits
    namespace wb_bits {
        constexpr uint32_t WBASE = (8 << 0);  ///< CEA709.1-B WBASE register
    }

    /// S3 Register bits
    namespace s3_bits {
        constexpr uint32_t TXFF = (1U << 0);  ///< Transmission Fail Flag
        constexpr uint32_t PSF = (1U << 1);  ///< Preamble Start Flag
        constexpr uint32_t PCTEF = (1U << 2);  ///< Packet Cycle Timer Expired Flag
        constexpr uint32_t PTXF = (1U << 3);  ///< Packet Transmitted Flag
        constexpr uint32_t PRXF = (1U << 4);  ///< Packet Received Flag
        constexpr uint32_t ISD = (1U << 5);  ///< Initial Sync Detect
        constexpr uint32_t WBEF = (1U << 6);  ///< Wbase Expired Flag
        constexpr uint32_t PEF = (1U << 7);  ///< Preamble Error Flag
    }

    /// S4 Register bits
    namespace s4_bits {
        constexpr uint32_t FE = (1U << 0);  ///< Framing Error
        constexpr uint32_t ILCV = (1U << 1);  ///< Improper Line Code Violation
        constexpr uint32_t CDET = (2 << 2);  ///< CDET
        constexpr uint32_t INITF = (1U << 4);  ///< Initial Synchronization Fail Flag
        constexpr uint32_t RESERVED = (3 << 5);  ///< no description available
    }

    /// RPL Register bits
    namespace rpl_bits {
        constexpr uint32_t RPL = (8 << 0);  ///< Received Packet Length
    }

    /// RPREL Register bits
    namespace rprel_bits {
        constexpr uint32_t RPREL = (8 << 0);  ///< Received Preamble Length
    }

    /// CPW Register bits
    namespace cpw_bits {
        constexpr uint32_t CPW = (8 << 0);  ///< CEA709.1-B CPW register
    }

    /// RIDT Register bits
    namespace ridt_bits {
        constexpr uint32_t RIDT = (8 << 0);  ///< CEA709.1-B Receive IDT register
    }

    /// TIDT Register bits
    namespace tidt_bits {
        constexpr uint32_t TIDT = (8 << 0);  ///< CEA709.1-B Transmit IDT Register
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40073010;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// CMP3 Peripheral
// ============================================================================

namespace cmp3 {
    /// Base addresses
    constexpr uint32_t CMP3_BASE = 0x40073018;

    /// CMP3 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP3 = reinterpret_cast<Registers*>(CMP3_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference has settled
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 Register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 Register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 Register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 Register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable Register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 Register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 Register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 Register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 Register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 Register
        volatile uint32_t RST;  ///< Offset: 0x0A - LLWU Reset Enable Register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable for Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable for Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable for Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable for Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable for Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable for Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable for Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag for LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag for LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag for LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag for LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag for LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag for LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag for LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag for LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag for LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag for LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag for LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag for LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag for LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag for LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag for LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag for LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag for module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag for module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag for module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag for module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag for module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag for module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag for module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag for module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter pin select
        constexpr uint32_t RESERVED = (1U << 4);  ///< no description available
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter on External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter pin select
        constexpr uint32_t RESERVED = (1U << 4);  ///< no description available
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter on External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// RST Register bits
    namespace rst_bits {
        constexpr uint32_t RSTFILT = (1U << 0);  ///< Digital Filter on RESET Pin
        constexpr uint32_t LLRSTE = (1U << 1);  ///< Low Leakage mode RESET enable
        constexpr uint32_t RESERVED = (6 << 2);  ///< no description available
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status and Control 1 Register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status and Control 2 Register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status and Control Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t RESERVED = (2 << 2);  ///< no description available
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t RESERVED = (3 << 2);  ///< no description available
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator in Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection Register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control Register
        volatile uint32_t VLLSCTRL;  ///< Offset: 0x02 - VLLS Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status Register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow very low leakage stop mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow low leakage stop mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow very low power modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RESERVED = (1U << 4);  ///< no description available
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
        constexpr uint32_t LPWUI = (1U << 7);  ///< Low Power Wake Up on Interrupt
    }

    /// VLLSCTRL Register bits
    namespace vllsctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (7 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control Register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width Register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low leakage wakeup reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-voltage detect reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-clock reset
        constexpr uint32_t RESERVED = (2 << 3);  ///< no description available
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External reset pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-on reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG generated reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP system reset request
        constexpr uint32_t EZPT = (1U << 4);  ///< EzPort Reset
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t TAMPER = (1U << 7);  ///< Tamper detect
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset pin filter select in run and wait modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset pin filter select in stop mode
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset pin filter bus clock select
        constexpr uint32_t RESERVED = (3 << 5);  ///< no description available
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t RESERVED = (6 << 2);  ///< no description available
        constexpr uint32_t EZP_MS = (1U << 1);  ///< EZP_MS_B pin state
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x400A0000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - RNGA Control Register
        volatile uint32_t SR;  ///< Offset: 0x04 - RNGA Status Register
        volatile uint32_t ER;  ///< Offset: 0x08 - RNGA Entropy Register
        volatile uint32_t OR_;  ///< Offset: 0x0C - RNGA Output Register (renamed from OR_)
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t GO = (1U << 0);  ///< no description available
        constexpr uint32_t HA = (1U << 1);  ///< High Assurance
        constexpr uint32_t INTM = (1U << 2);  ///< Interrupt Mask
        constexpr uint32_t CLRI = (1U << 3);  ///< Clear Interrupt
        constexpr uint32_t SLP = (1U << 4);  ///< Sleep
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SECV = (1U << 0);  ///< Security Violation
        constexpr uint32_t LRS = (1U << 1);  ///< Last Read Status
        constexpr uint32_t ORU = (1U << 2);  ///< Output Register Underflow
        constexpr uint32_t ERRI = (1U << 3);  ///< Error Interrupt
        constexpr uint32_t SLP = (1U << 4);  ///< Sleep
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t OREG_LVL = (8 << 8);  ///< Output Register Level
        constexpr uint32_t OREG_SIZE = (8 << 16);  ///< Output Register Size
    }

    /// ER Register bits
    namespace er_bits {
        constexpr uint32_t EXT_ENT = (32 << 0);  ///< External Entropy
    }

    /// OR_ Register bits
    namespace or__bits {
        constexpr uint32_t RANDOUT = (32 << 0);  ///< Random Output
    }

}

// ============================================================================
// NFC Peripheral
// ============================================================================

namespace nfc {
    /// Base addresses
    constexpr uint32_t NFC_BASE = 0x400A8000;

    /// NFC Register structure
    struct Registers {
        volatile uint32_t CMD1;  ///< Offset: 0x3F00 - Flash command 1
        volatile uint32_t CMD2;  ///< Offset: 0x3F04 - Flash command 2
        volatile uint32_t CAR;  ///< Offset: 0x3F08 - Column address
        volatile uint32_t RAR;  ///< Offset: 0x3F0C - Row address
        volatile uint32_t RPT;  ///< Offset: 0x3F10 - Flash command repeat
        volatile uint32_t RAI;  ///< Offset: 0x3F14 - Row address increment
        volatile uint32_t SR1;  ///< Offset: 0x3F18 - Flash status 1
        volatile uint32_t SR2;  ///< Offset: 0x3F1C - Flash status 2
        volatile uint32_t DMA1;  ///< Offset: 0x3F20 - DMA channel 1 address
        volatile uint32_t DMACFG;  ///< Offset: 0x3F24 - DMA configuration
        volatile uint32_t SWAP;  ///< Offset: 0x3F28 - Cach swap
        volatile uint32_t SECSZ;  ///< Offset: 0x3F2C - Sector size
        volatile uint32_t CFG;  ///< Offset: 0x3F30 - Flash configuration
        volatile uint32_t DMA2;  ///< Offset: 0x3F34 - DMA channel 2 address
        volatile uint32_t ISR;  ///< Offset: 0x3F38 - Interrupt status
    };

    /// Peripheral instances
    inline Registers* NFC = reinterpret_cast<Registers*>(NFC_BASE);

    // Bit definitions
    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t RESERVED = (16 << 0);  ///< no description available
        constexpr uint32_t BYTE3 = (8 << 16);  ///< Third command byte that may be sent to the flash device
        constexpr uint32_t BYTE2 = (8 << 24);  ///< Second command byte that may be sent to the flash device
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t BUSY_START = (1U << 0);  ///< Busy indicator and start command
        constexpr uint32_t BUFNO = (2 << 1);  ///< Internal buffer number used for this command
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
        constexpr uint32_t CODE = (16 << 8);  ///< User-defined flash operation sequencer
        constexpr uint32_t BYTE1 = (8 << 24);  ///< First command byte that may be sent to the flash device
    }

    /// CAR Register bits
    namespace car_bits {
        constexpr uint32_t BYTE1 = (8 << 0);  ///< First byte of column address
        constexpr uint32_t BYTE2 = (8 << 8);  ///< Second byte of column address
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t BYTE1 = (8 << 0);  ///< First byte of row address
        constexpr uint32_t BYTE2 = (8 << 8);  ///< Second byte of row address
        constexpr uint32_t BYTE3 = (8 << 16);  ///< Third byte of row address
        constexpr uint32_t RB0 = (1U << 24);  ///< Ready/busy 0 enable
        constexpr uint32_t RB1 = (1U << 25);  ///< Ready/busy 1 enable
        constexpr uint32_t RESERVED = (2 << 30);  ///< no description available
        constexpr uint32_t CS0 = (1U << 28);  ///< Chip select 0 enable
        constexpr uint32_t CS1 = (1U << 29);  ///< Chip select 1 enable
    }

    /// RPT Register bits
    namespace rpt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< 16-bit repeat count
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// RAI Register bits
    namespace rai_bits {
        constexpr uint32_t INC1 = (8 << 0);  ///< Increment for the first byte of row address
        constexpr uint32_t INC2 = (8 << 8);  ///< Increment for the second byte of row address
        constexpr uint32_t INC3 = (8 << 16);  ///< Increment for the third byte of row address
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t ID4 = (8 << 0);  ///< Fourth byte returned by read ID command
        constexpr uint32_t ID3 = (8 << 8);  ///< Third byte returned by read ID command
        constexpr uint32_t ID2 = (8 << 16);  ///< Second byte returned by read ID command
        constexpr uint32_t ID1 = (8 << 24);  ///< First byte returned by read ID command
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t STATUS1 = (8 << 0);  ///< Byte returned by read status command
        constexpr uint32_t RESERVED = (16 << 8);  ///< no description available
        constexpr uint32_t ID5 = (8 << 24);  ///< Fifth byte returned by read ID command
    }

    /// DMA1 Register bits
    namespace dma1_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< DMA channel 1 address. DMA channel 1 address, it is 8-byte aligned.
    }

    /// DMACFG Register bits
    namespace dmacfg_bits {
        constexpr uint32_t ACT2 = (1U << 0);  ///< DMA channel 2 status
        constexpr uint32_t ACT1 = (1U << 1);  ///< DMA channel 1 status
        constexpr uint32_t RESERVED = (7 << 2);  ///< no description available
        constexpr uint32_t OFFSET2 = (4 << 9);  ///< 256-byte offset for DMA channel 2. DMA channel 2 transfer starts at this offset count x 256 bytes. For example, if OFFSET2 = 0x2, DMA channel 2 transfer starts at 0x200.
        constexpr uint32_t COUNT2 = (7 << 13);  ///< Number of bytes to be transferred by DMA channel 2. It should be multiple of 8 bytes.
        constexpr uint32_t COUNT1 = (12 << 20);  ///< Number of bytes to be transferred by DMA channel 1. It should be multiple of 8 bytes.
    }

    /// SWAP Register bits
    namespace swap_bits {
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t ADDR2 = (11 << 1);  ///< Upper swap address
        constexpr uint32_t ADDR1 = (11 << 17);  ///< Lower swap address
    }

    /// SECSZ Register bits
    namespace secsz_bits {
        constexpr uint32_t SIZE = (13 << 0);  ///< Size in bytes of one elementary transfer unit
        constexpr uint32_t RESERVED = (19 << 13);  ///< no description available
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t PAGECNT = (4 << 0);  ///< Number of virtual pages (in one physical flash page) to be programmed or read, etc.
        constexpr uint32_t AIBN = (1U << 4);  ///< no description available
        constexpr uint32_t AIAD = (1U << 5);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t BITWIDTH = (1U << 7);  ///< no description available
        constexpr uint32_t TIMEOUT = (5 << 8);  ///< no description available
        constexpr uint32_t IDCNT = (3 << 13);  ///< Number of bytes that are read for the read id command.
        constexpr uint32_t FAST = (1U << 16);  ///< See the "Fast Flash Configuration for EDO" section for more details.
        constexpr uint32_t ECCMODE = (3 << 17);  ///< no description available
        constexpr uint32_t DMAREQ = (1U << 20);  ///< no description available
        constexpr uint32_t ECCSRAM = (1U << 21);  ///< no description available
        constexpr uint32_t ECCAD = (9 << 22);  ///< Byte address in SRAM where ECC status is written.
        constexpr uint32_t STOPWERR = (1U << 31);  ///< no description available
    }

    /// DMA2 Register bits
    namespace dma2_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< DMA channel 2 address. DMA channel 2 address, it is 8-byte aligned.
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t DMABN = (2 << 0);  ///< DMA buffer number
        constexpr uint32_t ECCBN = (2 << 2);  ///< ECC buffer number
        constexpr uint32_t RESBN = (2 << 4);  ///< Residue buffer number
        constexpr uint32_t RESERVED = (1U << 28);  ///< no description available
        constexpr uint32_t IDLECLR = (1U << 17);  ///< no description available
        constexpr uint32_t DONECLR = (1U << 18);  ///< no description available
        constexpr uint32_t WERRCLR = (1U << 19);  ///< no description available
        constexpr uint32_t IDLEEN = (1U << 20);  ///< no description available
        constexpr uint32_t DONEEN = (1U << 21);  ///< no description available
        constexpr uint32_t WERREN = (1U << 22);  ///< no description available
        constexpr uint32_t DMABUSY = (1U << 23);  ///< DMA engine busy
        constexpr uint32_t ECCBUSY = (1U << 24);  ///< ECC engine busy
        constexpr uint32_t RESBUSY = (1U << 25);  ///< Residue engine busy
        constexpr uint32_t CMDBUSY = (1U << 26);  ///< Command busy
        constexpr uint32_t WERRNS = (1U << 27);  ///< Write error status
        constexpr uint32_t IDLE = (1U << 29);  ///< Command idle interrupt
        constexpr uint32_t DONE = (1U << 30);  ///< Done interrupt
        constexpr uint32_t WERR = (1U << 31);  ///< Write error interrupt
    }

}

// ============================================================================
// DDR Peripheral
// ============================================================================

namespace ddr {
    /// Base addresses
    constexpr uint32_t DDR_BASE = 0x400AE000;

    /// DDR Register structure
    struct Registers {
        volatile uint32_t CR00;  ///< Offset: 0x00 - DDR Control Register 0
        volatile uint32_t CR01;  ///< Offset: 0x04 - DDR Control Register 1
        volatile uint32_t CR02;  ///< Offset: 0x08 - DDR Control Register 2
        volatile uint32_t CR03;  ///< Offset: 0x0C - DDR Control Register 3
        volatile uint32_t CR04;  ///< Offset: 0x10 - DDR Control Register 4
        volatile uint32_t CR05;  ///< Offset: 0x14 - DDR Control Register 5
        volatile uint32_t CR06;  ///< Offset: 0x18 - DDR Control Register 6
        volatile uint32_t CR07;  ///< Offset: 0x1C - DDR Control Register 7
        volatile uint32_t CR08;  ///< Offset: 0x20 - DDR Control Register 8
        volatile uint32_t CR09;  ///< Offset: 0x24 - DDR Control Register 9
        volatile uint32_t CR10;  ///< Offset: 0x28 - DDR Control Register 10
        volatile uint32_t CR11;  ///< Offset: 0x2C - DDR Control Register 11
        volatile uint32_t CR12;  ///< Offset: 0x30 - DDR Control Register 12
        volatile uint32_t CR13;  ///< Offset: 0x34 - DDR Control Register 13
        volatile uint32_t CR14;  ///< Offset: 0x38 - DDR Control Register 14
        volatile uint32_t CR15;  ///< Offset: 0x3C - DDR Control Register 15
        volatile uint32_t CR16;  ///< Offset: 0x40 - DDR Control Register 16
        volatile uint32_t CR17;  ///< Offset: 0x44 - DDR Control Register 17
        volatile uint32_t CR18;  ///< Offset: 0x48 - DDR Control Register 18
        volatile uint32_t CR19;  ///< Offset: 0x4C - DDR Control Register 19
        volatile uint32_t CR20;  ///< Offset: 0x50 - DDR Control Register 20
        volatile uint32_t CR21;  ///< Offset: 0x54 - DDR Control Register 21
        volatile uint32_t CR22;  ///< Offset: 0x58 - DDR Control Register 22
        volatile uint32_t CR23;  ///< Offset: 0x5C - DDR Control Register 23
        volatile uint32_t CR24;  ///< Offset: 0x60 - DDR Control Register 24
        volatile uint32_t CR25;  ///< Offset: 0x64 - DDR Control Register 25
        volatile uint32_t CR26;  ///< Offset: 0x68 - DDR Control Register 26
        volatile uint32_t CR27;  ///< Offset: 0x6C - DDR Control Register 27
        volatile uint32_t CR28;  ///< Offset: 0x70 - DDR Control Register 28
        volatile uint32_t CR29;  ///< Offset: 0x74 - DDR Control Register 29
        volatile uint32_t CR30;  ///< Offset: 0x78 - DDR Control Register 30
        volatile uint32_t CR31;  ///< Offset: 0x7C - DDR Control Register 31
        volatile uint32_t CR32;  ///< Offset: 0x80 - DDR Control Register 32
        volatile uint32_t CR33;  ///< Offset: 0x84 - DDR Control Register 33
        volatile uint32_t CR34;  ///< Offset: 0x88 - DDR Control Register 34
        volatile uint32_t CR35;  ///< Offset: 0x8C - DDR Control Register 35
        volatile uint32_t CR36;  ///< Offset: 0x90 - DDR Control Register 36
        volatile uint32_t CR37;  ///< Offset: 0x94 - DDR Control Register 37
        volatile uint32_t CR38;  ///< Offset: 0x98 - DDR Control Register 38
        volatile uint32_t CR39;  ///< Offset: 0x9C - DDR Control Register 39
        volatile uint32_t CR40;  ///< Offset: 0xA0 - DDR Control Register 40
        volatile uint32_t CR41;  ///< Offset: 0xA4 - DDR Control Register 41
        volatile uint32_t CR42;  ///< Offset: 0xA8 - DDR Control Register 42
        volatile uint32_t CR43;  ///< Offset: 0xAC - DDR Control Register 43
        volatile uint32_t CR44;  ///< Offset: 0xB0 - DDR Control Register 44
        volatile uint32_t CR45;  ///< Offset: 0xB4 - DDR Control Register 45
        volatile uint32_t CR46;  ///< Offset: 0xB8 - DDR Control Register 46
        volatile uint32_t CR47;  ///< Offset: 0xBC - DDR Control Register 47
        volatile uint32_t CR48;  ///< Offset: 0xC0 - DDR Control Register 48
        volatile uint32_t CR49;  ///< Offset: 0xC4 - DDR Control Register 49
        volatile uint32_t CR50;  ///< Offset: 0xC8 - DDR Control Register 50
        volatile uint32_t CR51;  ///< Offset: 0xCC - DDR Control Register 51
        volatile uint32_t CR52;  ///< Offset: 0xD0 - DDR Control Register 52
        volatile uint32_t CR53;  ///< Offset: 0xD4 - DDR Control Register 53
        volatile uint32_t CR54;  ///< Offset: 0xD8 - DDR Control Register 54
        volatile uint32_t CR55;  ///< Offset: 0xDC - DDR Control Register 55
        volatile uint32_t CR56;  ///< Offset: 0xE0 - DDR Control Register 56
        volatile uint32_t CR57;  ///< Offset: 0xE4 - DDR Control Register 57
        volatile uint32_t CR58;  ///< Offset: 0xE8 - DDR Control Register 58
        volatile uint32_t CR59;  ///< Offset: 0xEC - DDR Control Register 59
        volatile uint32_t CR60;  ///< Offset: 0xF0 - DDR Control Register 60
        volatile uint32_t CR61;  ///< Offset: 0xF4 - DDR Control Register 61
        volatile uint32_t CR62;  ///< Offset: 0xF8 - DDR Control Register 62
        volatile uint32_t CR63;  ///< Offset: 0xFC - DDR Control Register 63
        volatile uint32_t RCR;  ///< Offset: 0x180 - RCR Control Register
        volatile uint32_t PAD_CTRL;  ///< Offset: 0x1AC - I/O Pad Control Register
    };

    /// Peripheral instances
    inline Registers* DDR = reinterpret_cast<Registers*>(DDR_BASE);

    // Bit definitions
    /// CR00 Register bits
    namespace cr00_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start
        constexpr uint32_t RESERVED = (4 << 12);  ///< Reserved
        constexpr uint32_t DDRCLS = (4 << 8);  ///< DRAM Class
        constexpr uint32_t VERSION = (16 << 16);  ///< Version
    }

    /// CR01 Register bits
    namespace cr01_bits {
        constexpr uint32_t MAXROW = (5 << 0);  ///< Maxmum Row
        constexpr uint32_t RESERVED = (14 << 18);  ///< Reserved
        constexpr uint32_t MAXCOL = (4 << 8);  ///< Maximum Column
        constexpr uint32_t CSMAX = (2 << 16);  ///< Chip Select Maximum
    }

    /// CR02 Register bits
    namespace cr02_bits {
        constexpr uint32_t TINIT = (24 << 0);  ///< Time Initialization
        constexpr uint32_t INITAREF = (4 << 24);  ///< Initialization Auto-Refresh
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
    }

    /// CR03 Register bits
    namespace cr03_bits {
        constexpr uint32_t LATLIN = (4 << 0);  ///< Latency Linear
        constexpr uint32_t RESERVED = (3 << 29);  ///< Reserved
        constexpr uint32_t LATGATE = (4 << 8);  ///< Latency Gate
        constexpr uint32_t WRLAT = (4 << 16);  ///< Write Latency
        constexpr uint32_t TCCD = (5 << 24);  ///< Time CAS-to-CAS Delay
    }

    /// CR04 Register bits
    namespace cr04_bits {
        constexpr uint32_t TBINT = (3 << 0);  ///< Time Burst Interrupt Interval
        constexpr uint32_t RESERVED = (2 << 22);  ///< Reserved
        constexpr uint32_t TRRD = (3 << 8);  ///< no description available
        constexpr uint32_t TRC = (6 << 16);  ///< no description available
        constexpr uint32_t TRASMIN = (8 << 24);  ///< Time RAS Minimum
    }

    /// CR05 Register bits
    namespace cr05_bits {
        constexpr uint32_t TWTR = (4 << 0);  ///< Time Write-To-Read
        constexpr uint32_t RESERVED = (3 << 29);  ///< Reserved
        constexpr uint32_t TRP = (4 << 8);  ///< no description available
        constexpr uint32_t TRTP = (3 << 16);  ///< Time Read-To-Precharge
        constexpr uint32_t TMRD = (5 << 24);  ///< no description available
    }

    /// CR06 Register bits
    namespace cr06_bits {
        constexpr uint32_t TMOD = (8 << 0);  ///< Time Mode
        constexpr uint32_t TRASMAX = (16 << 8);  ///< Time Row Access Maximum
        constexpr uint32_t INTWBR = (1U << 24);  ///< Interrupt Write Burst
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
    }

    /// CR07 Register bits
    namespace cr07_bits {
        constexpr uint32_t CLKPW = (3 << 0);  ///< Clock Pulse Width
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t TCKESR = (5 << 8);  ///< Time Clock low Self Refresh
        constexpr uint32_t AP = (1U << 16);  ///< Auto Precharge
        constexpr uint32_t CCAPEN = (1U << 24);  ///< Concurrent Auto-Precharge Enable
    }

    /// CR08 Register bits
    namespace cr08_bits {
        constexpr uint32_t TRAS = (1U << 0);  ///< Time RAS lockout
        constexpr uint32_t RESERVED = (3 << 29);  ///< Reserved
        constexpr uint32_t TRASDI = (8 << 8);  ///< Time RAS-to-CAS Delay Interval
        constexpr uint32_t TWR = (5 << 16);  ///< Time Write Recovery
        constexpr uint32_t TDAL = (5 << 24);  ///< no description available
    }

    /// CR09 Register bits
    namespace cr09_bits {
        constexpr uint32_t TDLL = (16 << 0);  ///< Time DLL
        constexpr uint32_t NOCMD = (1U << 16);  ///< No Command
        constexpr uint32_t RESERVED = (5 << 27);  ///< Reserved
        constexpr uint32_t BSTLEN = (3 << 24);  ///< Burst Length
    }

    /// CR10 Register bits
    namespace cr10_bits {
        constexpr uint32_t TFAW = (6 << 0);  ///< Time FAW
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t TCPD = (16 << 8);  ///< Time Clock Enable to Precharge Delay
        constexpr uint32_t TRPAB = (4 << 24);  ///< TRP All Bank
    }

    /// CR11 Register bits
    namespace cr11_bits {
        constexpr uint32_t REGDIMM = (1U << 0);  ///< Registered DIMM
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t AREF = (1U << 8);  ///< Auto Refresh
        constexpr uint32_t AREFMODE = (1U << 16);  ///< Auto Refresh Mode
        constexpr uint32_t TREFEN = (1U << 24);  ///< no description available
    }

    /// CR12 Register bits
    namespace cr12_bits {
        constexpr uint32_t TRFC = (10 << 0);  ///< Time Refresh Command
        constexpr uint32_t RESERVED = (2 << 30);  ///< Reserved
        constexpr uint32_t TREF = (14 << 16);  ///< Time Refresh
    }

    /// CR13 Register bits
    namespace cr13_bits {
        constexpr uint32_t TREFINT = (14 << 0);  ///< Reserved
        constexpr uint32_t RESERVED = (15 << 17);  ///< Reserved
        constexpr uint32_t PD = (1U << 16);  ///< Power Down
    }

    /// CR14 Register bits
    namespace cr14_bits {
        constexpr uint32_t TPDEX = (16 << 0);  ///< Time Power Down Exit
        constexpr uint32_t TXSR = (16 << 16);  ///< Time Exit Self Refresh
    }

    /// CR15 Register bits
    namespace cr15_bits {
        constexpr uint32_t TXSNR = (16 << 0);  ///< TXSNR parameter
        constexpr uint32_t SREF = (1U << 16);  ///< Self Refresh
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t PUREF = (1U << 24);  ///< Power Up Refresh
    }

    /// CR16 Register bits
    namespace cr16_bits {
        constexpr uint32_t QKREF = (1U << 0);  ///< Quick Refresh
        constexpr uint32_t RESERVED = (11 << 21);  ///< Reserved
        constexpr uint32_t CLKDLY = (3 << 8);  ///< Clock Delay
        constexpr uint32_t LPCTRL = (5 << 16);  ///< Low Power Control
    }

    /// CR17 Register bits
    namespace cr17_bits {
        constexpr uint32_t LPPDCNT = (16 << 0);  ///< Low Power Power Down Count
        constexpr uint32_t LPRFCNT = (16 << 16);  ///< Low Power Refresh Count
    }

    /// CR18 Register bits
    namespace cr18_bits {
        constexpr uint32_t LPEXTCNT = (16 << 0);  ///< Low Power External Count
        constexpr uint32_t LPAUTO = (5 << 16);  ///< Low Power Auto
        constexpr uint32_t RESERVED = (11 << 21);  ///< Reserved
    }

    /// CR19 Register bits
    namespace cr19_bits {
        constexpr uint32_t LPINTCNT = (16 << 0);  ///< Low Power Interval Count
        constexpr uint32_t LPRFHOLD = (16 << 16);  ///< Low Power Refresh Hold
    }

    /// CR20 Register bits
    namespace cr20_bits {
        constexpr uint32_t LPRE = (2 << 0);  ///< Low Power Refresh enable
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t CKSRE = (4 << 8);  ///< no description available
        constexpr uint32_t CKSRX = (4 << 16);  ///< Clock Self Refresh Exit
        constexpr uint32_t WRMD = (1U << 24);  ///< Write Mode Register
    }

    /// CR21 Register bits
    namespace cr21_bits {
        constexpr uint32_t MR0DAT0 = (16 << 0);  ///< no description available
        constexpr uint32_t MR1DAT0 = (16 << 16);  ///< no description available
    }

    /// CR22 Register bits
    namespace cr22_bits {
        constexpr uint32_t MR2DATA0 = (16 << 0);  ///< no description available
        constexpr uint32_t MR3DAT0 = (16 << 16);  ///< no description available
    }

    /// CR23 Register bits
    namespace cr23_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR24 Register bits
    namespace cr24_bits {
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CR25 Register bits
    namespace cr25_bits {
        constexpr uint32_t BNK8 = (1U << 0);  ///< Eight Bank Mode
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t ADDPINS = (3 << 8);  ///< Address Pins
        constexpr uint32_t COLSIZ = (3 << 16);  ///< Column Size
        constexpr uint32_t APREBIT = (4 << 24);  ///< Auto Precharge Bit
    }

    /// CR26 Register bits
    namespace cr26_bits {
        constexpr uint32_t AGECNT = (8 << 0);  ///< Age Count
        constexpr uint32_t CMDAGE = (8 << 8);  ///< Command Age count
        constexpr uint32_t ADDCOL = (1U << 16);  ///< Address Collision enable
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t BNKSPT = (1U << 24);  ///< Bank Split enable
    }

    /// CR27 Register bits
    namespace cr27_bits {
        constexpr uint32_t PLEN = (1U << 0);  ///< Placement Enable
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t PRIEN = (1U << 8);  ///< Priority Enable
        constexpr uint32_t RWEN = (1U << 16);  ///< Read Write same Enable
        constexpr uint32_t SWPEN = (1U << 24);  ///< Swap Enable
    }

    /// CR28 Register bits
    namespace cr28_bits {
        constexpr uint32_t CSMAP = (1U << 0);  ///< Chip Select Map
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t REDUC = (1U << 8);  ///< no description available
        constexpr uint32_t BIGEND = (1U << 16);  ///< Big Endian Enable
        constexpr uint32_t CMDLATR = (1U << 24);  ///< Command Latency Reduction Enable
    }

    /// CR29 Register bits
    namespace cr29_bits {
        constexpr uint32_t WRLATR = (1U << 0);  ///< Write Latency Reduction enable
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t FSTWR = (1U << 8);  ///< Fast Write
        constexpr uint32_t QFULL = (2 << 16);  ///< Queue Fullness
        constexpr uint32_t RESYNC = (1U << 24);  ///< Resyncronize
    }

    /// CR30 Register bits
    namespace cr30_bits {
        constexpr uint32_t RSYNCRF = (1U << 0);  ///< Resynchroize after Refresh
        constexpr uint32_t RESERVED = (7 << 17);  ///< Reserved
        constexpr uint32_t INTSTAT = (9 << 8);  ///< Interrupt Status
        constexpr uint32_t INTACK = (8 << 24);  ///< Interupt Acknowlege
    }

    /// CR31 Register bits
    namespace cr31_bits {
        constexpr uint32_t INTMASK = (9 << 0);  ///< Interrupt Mask
        constexpr uint32_t RESERVED = (23 << 9);  ///< Reserved
    }

    /// CR32 Register bits
    namespace cr32_bits {
        constexpr uint32_t OORAD = (32 << 0);  ///< Out Of Range Address
    }

    /// CR33 Register bits
    namespace cr33_bits {
        constexpr uint32_t OORLEN = (10 << 0);  ///< Out Of Range Length
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t OORTYP = (6 << 16);  ///< Out Of Range Type
        constexpr uint32_t OORID = (2 << 24);  ///< Out Of Range source ID
    }

    /// CR34 Register bits
    namespace cr34_bits {
        constexpr uint32_t ODTRDC = (1U << 0);  ///< ODT Read map CS
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t ODTWRCS = (1U << 8);  ///< ODT Write map CS
    }

    /// CR35 Register bits
    namespace cr35_bits {
        constexpr uint32_t R2WSMCS = (4 << 0);  ///< Read To Write Same Chip Select
        constexpr uint32_t RESERVED = (20 << 12);  ///< Reserved
        constexpr uint32_t W2RSMCS = (4 << 8);  ///< Write To Read Same Chip Select
    }

    /// CR36 Register bits
    namespace cr36_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR37 Register bits
    namespace cr37_bits {
        constexpr uint32_t R2RSAME = (3 << 0);  ///< R2R Same chip select delay
        constexpr uint32_t RESERVED = (5 << 27);  ///< Reserved
        constexpr uint32_t R2WSAME = (3 << 8);  ///< R2W Same chip select delay
        constexpr uint32_t W2RSAME = (3 << 16);  ///< W2R Same chip select delay
        constexpr uint32_t W2WSAME = (3 << 24);  ///< W2W Same chip select delay
    }

    /// CR38 Register bits
    namespace cr38_bits {
        constexpr uint32_t PDNCS = (5 << 0);  ///< OCD Pull Down adjustment Chip Select
        constexpr uint32_t RESERVED = (5 << 27);  ///< Reserved
        constexpr uint32_t PUPCS = (5 << 8);  ///< OCD Pull Up adjustment Chip Select
        constexpr uint32_t PWRCNT = (11 << 16);  ///< Port 0 Write Count
    }

    /// CR39 Register bits
    namespace cr39_bits {
        constexpr uint32_t P0RDCNT = (11 << 0);  ///< Port 0 Read command Count
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t RP0 = (2 << 16);  ///< Port 0 Read command Priority
        constexpr uint32_t WP0 = (2 << 24);  ///< Port 0 Write command Priority
    }

    /// CR40 Register bits
    namespace cr40_bits {
        constexpr uint32_t P0TYP = (2 << 0);  ///< Port 0 Type
        constexpr uint32_t RESERVED = (13 << 19);  ///< Reserved
        constexpr uint32_t P1WRCNT = (11 << 8);  ///< Port 1 Write command Count
    }

    /// CR41 Register bits
    namespace cr41_bits {
        constexpr uint32_t P1RDCNT = (11 << 0);  ///< Port 1 Read command Count
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t RP1 = (2 << 16);  ///< Read command priority Port 1
        constexpr uint32_t WP1 = (2 << 24);  ///< Write command priority Port 1
    }

    /// CR42 Register bits
    namespace cr42_bits {
        constexpr uint32_t P1TYP = (2 << 0);  ///< Port 1 Type
        constexpr uint32_t RESERVED = (13 << 19);  ///< Reserved
        constexpr uint32_t P2WRCNT = (11 << 8);  ///< Port 2 Write command Count
    }

    /// CR43 Register bits
    namespace cr43_bits {
        constexpr uint32_t P2RDCNT = (11 << 0);  ///< Port 2 Read command Count
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t RP2 = (2 << 16);  ///< Read command priority Port 2
        constexpr uint32_t WP2 = (2 << 24);  ///< Write command priority Port 2
    }

    /// CR44 Register bits
    namespace cr44_bits {
        constexpr uint32_t P2TYP = (2 << 0);  ///< Port 2 Type
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t WRRLAT = (1U << 8);  ///< WRR Latency
        constexpr uint32_t WRRSHARE = (1U << 16);  ///< WRR Shared arbitration
        constexpr uint32_t WRRERR = (4 << 24);  ///< WRR parameters Error
    }

    /// CR45 Register bits
    namespace cr45_bits {
        constexpr uint32_t P0PRI0 = (4 << 0);  ///< Port 0 Priority 0 commands
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t P0PRI1 = (4 << 8);  ///< Port 0 Priority 1 commands
        constexpr uint32_t P0PRI2 = (4 << 16);  ///< Port 0 Priority 2 commands
        constexpr uint32_t P0PRI3 = (4 << 24);  ///< Port 0 Priority 3 commands
    }

    /// CR46 Register bits
    namespace cr46_bits {
        constexpr uint32_t P0ORD = (2 << 0);  ///< Port 0 Order
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t P0PRIRLX = (10 << 8);  ///< Port 0 Priority Relax
        constexpr uint32_t P1PRI0 = (4 << 24);  ///< Port 1 Priority 0 commands
    }

    /// CR47 Register bits
    namespace cr47_bits {
        constexpr uint32_t P1PRI1 = (4 << 0);  ///< Port 1 Priority 1 commands
        constexpr uint32_t RESERVED = (6 << 26);  ///< Reserved
        constexpr uint32_t P1PRI2 = (4 << 8);  ///< Port 1 Priority 2 commands
        constexpr uint32_t P1PRI3 = (4 << 16);  ///< Port 1 Priority 3 commands
        constexpr uint32_t P1ORD = (2 << 24);  ///< Port 1 Order
    }

    /// CR48 Register bits
    namespace cr48_bits {
        constexpr uint32_t P1PRIRLX = (10 << 0);  ///< Port 1 Priority Relax
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t P2PRI0 = (4 << 16);  ///< Port 2 Priority 0 commands
        constexpr uint32_t P2PRI1 = (4 << 24);  ///< Port 2 Priority 1 commands
    }

    /// CR49 Register bits
    namespace cr49_bits {
        constexpr uint32_t P2PRI2 = (4 << 0);  ///< Port 2 Priority 2 commands
        constexpr uint32_t RESERVED = (14 << 18);  ///< Reserved
        constexpr uint32_t P2PRI3 = (4 << 8);  ///< Port 2 Priority 3 commands
        constexpr uint32_t P2ORD = (2 << 16);  ///< Port 2 Order
    }

    /// CR50 Register bits
    namespace cr50_bits {
        constexpr uint32_t P2PRIRLX = (10 << 0);  ///< Port 2 Priority Relax
        constexpr uint32_t RESERVED = (15 << 17);  ///< Reserved
        constexpr uint32_t CLKSTATUS = (1U << 16);  ///< Clock Status
    }

    /// CR51 Register bits
    namespace cr51_bits {
        constexpr uint32_t DLLRSTDLY = (16 << 0);  ///< DLL Reset Delay
        constexpr uint32_t DLLRADLY = (8 << 16);  ///< DLL Reset Adjust Delay
        constexpr uint32_t PHYWRLAT = (4 << 24);  ///< PHY Write Latency
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
    }

    /// CR52 Register bits
    namespace cr52_bits {
        constexpr uint32_t PYWRLTBS = (4 << 0);  ///< PHY Write Latency Base
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t PHYRDLAT = (4 << 8);  ///< PHY Read Latency
        constexpr uint32_t RDDATAEN = (4 << 16);  ///< Read Data Enable
        constexpr uint32_t RDDTENBAS = (4 << 24);  ///< Read Data Enable Base
    }

    /// CR53 Register bits
    namespace cr53_bits {
        constexpr uint32_t CLKDISCS = (1U << 0);  ///< DRAM Clock Disable for chip select
        constexpr uint32_t RESERVED = (2 << 30);  ///< Reserved
        constexpr uint32_t CRTLUPDMN = (4 << 8);  ///< DFI CRTLUPD Minimum
        constexpr uint32_t CTRLUPDMX = (14 << 16);  ///< DFI CRTLUPD Minimum
    }

    /// CR54 Register bits
    namespace cr54_bits {
        constexpr uint32_t PHYUPDTY0 = (14 << 0);  ///< DFI PHYUPD Type 0
        constexpr uint32_t RESERVED = (2 << 30);  ///< Reserved
        constexpr uint32_t PHYUPDTY1 = (14 << 16);  ///< DFI PHYUPD Type 1
    }

    /// CR55 Register bits
    namespace cr55_bits {
        constexpr uint32_t PHYUPDTY2 = (14 << 0);  ///< DFI PHYUPD TYPE2
        constexpr uint32_t RESERVED = (2 << 30);  ///< Reserved
        constexpr uint32_t PHYUPDTY3 = (14 << 16);  ///< DFI PHYUPD TYPE3
    }

    /// CR56 Register bits
    namespace cr56_bits {
        constexpr uint32_t PHYUPDRESP = (14 << 0);  ///< TDFI PHYUPDRESP parameter
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t RDLATADJ = (4 << 16);  ///< Read Latency Adjust
        constexpr uint32_t WRLATADJ = (4 << 24);  ///< Write Latency Adjust
    }

    /// CR57 Register bits
    namespace cr57_bits {
        constexpr uint32_t CMDDLY = (4 << 0);  ///< Command Delay
        constexpr uint32_t RESERVED = (7 << 25);  ///< Reserved
        constexpr uint32_t CLKDISDLY = (3 << 8);  ///< DFI Clock Disable Delay
        constexpr uint32_t CLKENDLY = (4 << 16);  ///< DFI Clock Enable Delay
        constexpr uint32_t ODTALTEN = (1U << 24);  ///< ODT Alternate Enable
    }

    /// CR58 Register bits
    namespace cr58_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR59 Register bits
    namespace cr59_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR60 Register bits
    namespace cr60_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR61 Register bits
    namespace cr61_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR62 Register bits
    namespace cr62_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// CR63 Register bits
    namespace cr63_bits {
        constexpr uint32_t Not_Used = (16 << 0);  ///< Reserved
        constexpr uint32_t NOT_USED = (16 << 16);  ///< Reserved
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t RST = (1U << 30);  ///< Reset
    }

    /// PAD_CTRL Register bits
    namespace pad_ctrl_bits {
        constexpr uint32_t SPARE_DLY_CTRL = (4 << 0);  ///< These SPARE_DLY_CTRL[3:0]bits set the delay chains in the spare logic.
        constexpr uint32_t RESERVED = (4 << 28);  ///< Reserved
        constexpr uint32_t PAD_ODT_CS0 = (2 << 24);  ///< Required to enable ODT and configure ODT resistor value in the pad.
    }

}

// ============================================================================
// SDHC Peripheral
// ============================================================================

namespace sdhc {
    /// Base addresses
    constexpr uint32_t SDHC_BASE = 0x400B1000;

    /// SDHC Register structure
    struct Registers {
        volatile uint32_t DSADDR;  ///< Offset: 0x00 - DMA System Address Register
        volatile uint32_t BLKATTR;  ///< Offset: 0x04 - Block Attributes Register
        volatile uint32_t CMDARG;  ///< Offset: 0x08 - Command Argument Register
        volatile uint32_t XFERTYP;  ///< Offset: 0x0C - Transfer Type Register
        volatile uint32_t CMDRSP0;  ///< Offset: 0x10 - Command Response 0
        volatile uint32_t CMDRSP1;  ///< Offset: 0x14 - Command Response 1
        volatile uint32_t CMDRSP2;  ///< Offset: 0x18 - Command Response 2
        volatile uint32_t CMDRSP3;  ///< Offset: 0x1C - Command Response 3
        volatile uint32_t DATPORT;  ///< Offset: 0x20 - Buffer Data Port Register
        volatile uint32_t PRSSTAT;  ///< Offset: 0x24 - Present State Register
        volatile uint32_t PROCTL;  ///< Offset: 0x28 - Protocol Control Register
        volatile uint32_t SYSCTL;  ///< Offset: 0x2C - System Control Register
        volatile uint32_t IRQSTAT;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t IRQSTATEN;  ///< Offset: 0x34 - Interrupt Status Enable Register
        volatile uint32_t IRQSIGEN;  ///< Offset: 0x38 - Interrupt Signal Enable Register
        volatile uint32_t AC12ERR;  ///< Offset: 0x3C - Auto CMD12 Error Status Register
        volatile uint32_t HTCAPBLT;  ///< Offset: 0x40 - Host Controller Capabilities
        volatile uint32_t WML;  ///< Offset: 0x44 - Watermark Level Register
        volatile uint32_t FEVT;  ///< Offset: 0x50 - Force Event Register
        volatile uint32_t ADMAES;  ///< Offset: 0x54 - ADMA Error Status Register
        volatile uint32_t ADSADDR;  ///< Offset: 0x58 - ADMA System Address Register
        volatile uint32_t VENDOR;  ///< Offset: 0xC0 - Vendor Specific Register
        volatile uint32_t MMCBOOT;  ///< Offset: 0xC4 - MMC Boot Register
        volatile uint32_t HOSTVER;  ///< Offset: 0xFC - Host Controller Version
    };

    /// Peripheral instances
    inline Registers* SDHC = reinterpret_cast<Registers*>(SDHC_BASE);

    // Bit definitions
    /// DSADDR Register bits
    namespace dsaddr_bits {
        constexpr uint32_t RESERVED = (2 << 0);  ///< no description available
        constexpr uint32_t DSADDR = (30 << 2);  ///< DMA System Address
    }

    /// BLKATTR Register bits
    namespace blkattr_bits {
        constexpr uint32_t BLKSIZE = (13 << 0);  ///< Transfer Block Size
        constexpr uint32_t RESERVED = (3 << 13);  ///< no description available
        constexpr uint32_t BLKCNT = (16 << 16);  ///< Blocks Count For Current Transfer
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command Argument
    }

    /// XFERTYP Register bits
    namespace xfertyp_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t AC12EN = (1U << 2);  ///< Auto CMD12 Enable
        constexpr uint32_t RESERVED = (2 << 30);  ///< no description available
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi/Single Block Select
        constexpr uint32_t RSPTYP = (2 << 16);  ///< Response Type Select
        constexpr uint32_t CCCEN = (1U << 19);  ///< Command CRC Check Enable
        constexpr uint32_t CICEN = (1U << 20);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 21);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 22);  ///< Command Type
        constexpr uint32_t CMDINX = (6 << 24);  ///< Command Index
    }

    /// CMDRSP0 Register bits
    namespace cmdrsp0_bits {
        constexpr uint32_t CMDRSP0 = (32 << 0);  ///< Command Response 0
    }

    /// CMDRSP1 Register bits
    namespace cmdrsp1_bits {
        constexpr uint32_t CMDRSP1 = (32 << 0);  ///< Command Response 1
    }

    /// CMDRSP2 Register bits
    namespace cmdrsp2_bits {
        constexpr uint32_t CMDRSP2 = (32 << 0);  ///< Command Response 2
    }

    /// CMDRSP3 Register bits
    namespace cmdrsp3_bits {
        constexpr uint32_t CMDRSP3 = (32 << 0);  ///< Command Response 3
    }

    /// DATPORT Register bits
    namespace datport_bits {
        constexpr uint32_t DATCONT = (32 << 0);  ///< Data Content
    }

    /// PRSSTAT Register bits
    namespace prsstat_bits {
        constexpr uint32_t CIHB = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CDIHB = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t DLA = (1U << 2);  ///< Data Line Active
        constexpr uint32_t SDSTB = (1U << 3);  ///< SD Clock Stable
        constexpr uint32_t IPGOFF = (1U << 4);  ///< Bus Clock Gated Off Internally
        constexpr uint32_t HCKOFF = (1U << 5);  ///< System Clock Gated Off Internally
        constexpr uint32_t PEROFF = (1U << 6);  ///< SDHC clock Gated Off Internally
        constexpr uint32_t SDOFF = (1U << 7);  ///< SD Clock Gated Off Internally
        constexpr uint32_t WTA = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTA = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BWEN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BREN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t RESERVED = (6 << 17);  ///< no description available
        constexpr uint32_t CINS = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CLSL = (1U << 23);  ///< CMD Line Signal Level
        constexpr uint32_t DLSL = (8 << 24);  ///< DAT Line Signal Level
    }

    /// PROCTL Register bits
    namespace proctl_bits {
        constexpr uint32_t LCTL = (1U << 0);  ///< LED Control
        constexpr uint32_t DTW = (2 << 1);  ///< Data Transfer Width
        constexpr uint32_t D3CD = (1U << 3);  ///< DAT3 as Card Detection Pin
        constexpr uint32_t EMODE = (2 << 4);  ///< Endian Mode
        constexpr uint32_t CDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CDSS = (1U << 7);  ///< Card Detect Signal Selection
        constexpr uint32_t DMAS = (2 << 8);  ///< DMA Select
        constexpr uint32_t RESERVED = (5 << 27);  ///< no description available
        constexpr uint32_t SABGREQ = (1U << 16);  ///< Stop At Block Gap Request
        constexpr uint32_t CREQ = (1U << 17);  ///< Continue Request
        constexpr uint32_t RWCTL = (1U << 18);  ///< Read Wait Control
        constexpr uint32_t IABG = (1U << 19);  ///< Interrupt At Block Gap
        constexpr uint32_t WECINT = (1U << 24);  ///< Wakeup Event Enable On Card Interrupt
        constexpr uint32_t WECINS = (1U << 25);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WECRM = (1U << 26);  ///< Wakeup Event Enable On SD Card Removal
    }

    /// SYSCTL Register bits
    namespace sysctl_bits {
        constexpr uint32_t IPGEN = (1U << 0);  ///< IPG Clock Enable
        constexpr uint32_t HCKEN = (1U << 1);  ///< System Clock Enable
        constexpr uint32_t PEREN = (1U << 2);  ///< Peripheral Clock Enable
        constexpr uint32_t SDCLKEN = (1U << 3);  ///< SD Clock Enable
        constexpr uint32_t DVS = (4 << 4);  ///< Divisor
        constexpr uint32_t SDCLKFS = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t DTOCV = (4 << 16);  ///< Data Timeout Counter Value
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t RSTA = (1U << 24);  ///< Software Reset For ALL
        constexpr uint32_t RSTC = (1U << 25);  ///< Software Reset For CMD Line
        constexpr uint32_t RSTD = (1U << 26);  ///< Software Reset For DAT Line
        constexpr uint32_t INITA = (1U << 27);  ///< Initialization Active
    }

    /// IRQSTAT Register bits
    namespace irqstat_bits {
        constexpr uint32_t CC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWR = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRR = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CRM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t CTOE = (1U << 16);  ///< Command Timeout Error
        constexpr uint32_t CCE = (1U << 17);  ///< Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Data Timeout Error
        constexpr uint32_t DCE = (1U << 21);  ///< Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Auto CMD12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< DMA Error
    }

    /// IRQSTATEN Register bits
    namespace irqstaten_bits {
        constexpr uint32_t CCSEN = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TCSEN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BGESEN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DINTSEN = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRSEN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRRSEN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINSEN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CRMSEN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINTSEN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t CTOESEN = (1U << 16);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CCESEN = (1U << 17);  ///< Command CRC Error Status Enable
        constexpr uint32_t CEBESEN = (1U << 18);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CIESEN = (1U << 19);  ///< Command Index Error Status Enable
        constexpr uint32_t DTOESEN = (1U << 20);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DCESEN = (1U << 21);  ///< Data CRC Error Status Enable
        constexpr uint32_t DEBESEN = (1U << 22);  ///< Data End Bit Error Status Enable
        constexpr uint32_t AC12ESEN = (1U << 24);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t DMAESEN = (1U << 28);  ///< DMA Error Status Enable
    }

    /// IRQSIGEN Register bits
    namespace irqsigen_bits {
        constexpr uint32_t CCIEN = (1U << 0);  ///< Command Complete Interrupt Enable
        constexpr uint32_t TCIEN = (1U << 1);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t BGEIEN = (1U << 2);  ///< Block Gap Event Interrupt Enable
        constexpr uint32_t DINTIEN = (1U << 3);  ///< DMA Interrupt Enable
        constexpr uint32_t BWRIEN = (1U << 4);  ///< Buffer Write Ready Interrupt Enable
        constexpr uint32_t BRRIEN = (1U << 5);  ///< Buffer Read Ready Interrupt Enable
        constexpr uint32_t CINSIEN = (1U << 6);  ///< Card Insertion Interrupt Enable
        constexpr uint32_t CRMIEN = (1U << 7);  ///< Card Removal Interrupt Enable
        constexpr uint32_t CINTIEN = (1U << 8);  ///< Card Interrupt Enable
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t CTOEIEN = (1U << 16);  ///< Command Timeout Error Interrupt Enable
        constexpr uint32_t CCEIEN = (1U << 17);  ///< Command CRC Error Interrupt Enable
        constexpr uint32_t CEBEIEN = (1U << 18);  ///< Command End Bit Error Interrupt Enable
        constexpr uint32_t CIEIEN = (1U << 19);  ///< Command Index Error Interrupt Enable
        constexpr uint32_t DTOEIEN = (1U << 20);  ///< Data Timeout Error Interrupt Enable
        constexpr uint32_t DCEIEN = (1U << 21);  ///< Data CRC Error Interrupt Enable
        constexpr uint32_t DEBEIEN = (1U << 22);  ///< Data End Bit Error Interrupt Enable
        constexpr uint32_t AC12EIEN = (1U << 24);  ///< Auto CMD12 Error Interrupt Enable
        constexpr uint32_t DMAEIEN = (1U << 28);  ///< DMA Error Interrupt Enable
    }

    /// AC12ERR Register bits
    namespace ac12err_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Auto CMD12 Timeout Error
        constexpr uint32_t AC12EBE = (1U << 2);  ///< Auto CMD12 End Bit Error
        constexpr uint32_t AC12CE = (1U << 3);  ///< Auto CMD12 CRC Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Auto CMD12 Index Error
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
    }

    /// HTCAPBLT Register bits
    namespace htcapblt_bits {
        constexpr uint32_t RESERVED = (5 << 27);  ///< no description available
        constexpr uint32_t MBL = (3 << 16);  ///< Max Block Length
        constexpr uint32_t ADMAS = (1U << 20);  ///< ADMA Support
        constexpr uint32_t HSS = (1U << 21);  ///< High Speed Support
        constexpr uint32_t DMAS = (1U << 22);  ///< DMA Support
        constexpr uint32_t SRS = (1U << 23);  ///< Suspend/Resume Support
        constexpr uint32_t VS33 = (1U << 24);  ///< Voltage Support 3.3 V
        constexpr uint32_t VS30 = (1U << 25);  ///< Voltage Support 3.0 V
        constexpr uint32_t VS18 = (1U << 26);  ///< Voltage Support 1.8 V
    }

    /// WML Register bits
    namespace wml_bits {
        constexpr uint32_t RDWML = (8 << 0);  ///< Read Watermark Level
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t WRWML = (8 << 16);  ///< Write Watermark Level
        constexpr uint32_t WRBRSTLEN = (5 << 24);  ///< no description available
    }

    /// FEVT Register bits
    namespace fevt_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Force Event Auto Command 12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Force Event Auto Command 12 Time Out Error
        constexpr uint32_t AC12CE = (1U << 2);  ///< Force Event Auto Command 12 CRC Error
        constexpr uint32_t AC12EBE = (1U << 3);  ///< Force Event Auto Command 12 End Bit Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Force Event Auto Command 12 Index Error
        constexpr uint32_t RESERVED = (2 << 29);  ///< no description available
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Force Event Command Not Executed By Auto Command 12 Error
        constexpr uint32_t CTOE = (1U << 16);  ///< Force Event Command Time Out Error
        constexpr uint32_t CCE = (1U << 17);  ///< Force Event Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Force Event Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Force Event Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Force Event Data Time Out Error
        constexpr uint32_t DCE = (1U << 21);  ///< Force Event Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Force Event Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Force Event Auto Command 12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< Force Event DMA Error
        constexpr uint32_t CINT = (1U << 31);  ///< Force Event Card Interrupt
    }

    /// ADMAES Register bits
    namespace admaes_bits {
        constexpr uint32_t ADMAES = (2 << 0);  ///< ADMA Error State (when ADMA Error is occurred.)
        constexpr uint32_t ADMALME = (1U << 2);  ///< ADMA Length Mismatch Error
        constexpr uint32_t ADMADCE = (1U << 3);  ///< ADMA Descritor Error
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// ADSADDR Register bits
    namespace adsaddr_bits {
        constexpr uint32_t RESERVED = (2 << 0);  ///< no description available
        constexpr uint32_t ADSADDR = (30 << 2);  ///< ADMA System Address
    }

    /// VENDOR Register bits
    namespace vendor_bits {
        constexpr uint32_t EXTDMAEN = (1U << 0);  ///< External DMA Request Enable
        constexpr uint32_t EXBLKNU = (1U << 1);  ///< Exact block number block read enable for SDIO CMD53
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t INTSTVAL = (8 << 16);  ///< Internal State Value
    }

    /// MMCBOOT Register bits
    namespace mmcboot_bits {
        constexpr uint32_t DTOCVACK = (4 << 0);  ///< Boot ACK time out counter value.
        constexpr uint32_t BOOTACK = (1U << 4);  ///< Boot ack mode select
        constexpr uint32_t BOOTMODE = (1U << 5);  ///< Boot mode select
        constexpr uint32_t BOOTEN = (1U << 6);  ///< Boot mode enable
        constexpr uint32_t AUTOSABGEN = (1U << 7);  ///< no description available
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
        constexpr uint32_t BOOTBLKCNT = (16 << 16);  ///< no description available
    }

    /// HOSTVER Register bits
    namespace hostver_bits {
        constexpr uint32_t SVN = (8 << 0);  ///< Specification Version Number
        constexpr uint32_t VVN = (8 << 8);  ///< Vendor Version Number
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

}

// ============================================================================
// LCDC Peripheral
// ============================================================================

namespace lcdc {
    /// Base addresses
    constexpr uint32_t LCDC_BASE = 0x400B6000;

    /// LCDC Register structure
    struct Registers {
        volatile uint32_t LSSAR;  ///< Offset: 0x00 - LCDC screen start address register
        volatile uint32_t LSR;  ///< Offset: 0x04 - LCDC size register
        volatile uint32_t LVPWR;  ///< Offset: 0x08 - LCDC virtual page width register
        volatile uint32_t LCPR;  ///< Offset: 0x0C - LCDC cursor position register
        volatile uint32_t LCWHB;  ///< Offset: 0x10 - LCDC cursor width, height, and blink register
        volatile uint32_t LCCMR;  ///< Offset: 0x14 - LCDC color cursor mapping register
        volatile uint32_t LPCR;  ///< Offset: 0x18 - LCDC panel configuration register
        volatile uint32_t LHCR;  ///< Offset: 0x1C - LCDC horizontal configuration register
        volatile uint32_t LVCR;  ///< Offset: 0x20 - LCDC vertical configuration register
        volatile uint32_t LPOR;  ///< Offset: 0x24 - LCDC panning offset register
        volatile uint32_t LPCCR;  ///< Offset: 0x2C - LCDC PWM contrast control register
        volatile uint32_t LDCR;  ///< Offset: 0x30 - LCDC DMA control register
        volatile uint32_t LRMCR;  ///< Offset: 0x34 - LCDC refresh mode control register
        volatile uint32_t LICR;  ///< Offset: 0x38 - LCDC interrupt configuration register
        volatile uint32_t LIER;  ///< Offset: 0x3C - LCDC interrupt enable register
        volatile uint32_t LISR;  ///< Offset: 0x40 - LCDC interrupt status register
        volatile uint32_t LGWSAR;  ///< Offset: 0x50 - LCDC graphic window start address register
        volatile uint32_t LGWSR;  ///< Offset: 0x54 - LCDC graphic window size register
        volatile uint32_t LGWVPWR;  ///< Offset: 0x58 - LCDC graphic window virtual page width register
        volatile uint32_t LGWPOR;  ///< Offset: 0x5C - LCDC graphic window panning offset register
        volatile uint32_t LGWPR;  ///< Offset: 0x60 - LCDC graphic window position register
        volatile uint32_t LGWCR;  ///< Offset: 0x64 - LCDC graphic window control register
        volatile uint32_t LGWDCR;  ///< Offset: 0x68 - LCDC graphic window DMA control register
        volatile uint32_t LAUSCR;  ///< Offset: 0x80 - LCDC AUS mode control register
        volatile uint32_t LAUSCCR;  ///< Offset: 0x84 - LCDC AUS mode cursor control register
    };

    /// Peripheral instances
    inline Registers* LCDC = reinterpret_cast<Registers*>(LCDC_BASE);

    // Bit definitions
    /// LSSAR Register bits
    namespace lssar_bits {
        constexpr uint32_t RESERVED = (2 << 0);  ///< no description available
        constexpr uint32_t SSA = (30 << 2);  ///< Screen start address of LCD panel
    }

    /// LSR Register bits
    namespace lsr_bits {
        constexpr uint32_t YMAX = (10 << 0);  ///< Screen height
        constexpr uint32_t RESERVED = (3 << 29);  ///< no description available
        constexpr uint32_t XMAX = (7 << 20);  ///< Screen width divided by 16
    }

    /// LVPWR Register bits
    namespace lvpwr_bits {
        constexpr uint32_t VPW = (11 << 0);  ///< Virtual page width
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
    }

    /// LCPR Register bits
    namespace lcpr_bits {
        constexpr uint32_t CYP = (10 << 0);  ///< Cursor Y position
        constexpr uint32_t RESERVED = (1U << 29);  ///< no description available
        constexpr uint32_t CXP = (10 << 16);  ///< Cursor X position
        constexpr uint32_t OP = (1U << 28);  ///< Arithmetic operation control
        constexpr uint32_t CC = (2 << 30);  ///< Cursor control
    }

    /// LCWHB Register bits
    namespace lcwhb_bits {
        constexpr uint32_t BD = (8 << 0);  ///< Blink divisor
        constexpr uint32_t RESERVED = (2 << 29);  ///< no description available
        constexpr uint32_t CH = (5 << 16);  ///< Cursor height
        constexpr uint32_t CW = (5 << 24);  ///< Cursor width
        constexpr uint32_t BK_EN = (1U << 31);  ///< Blink enable
    }

    /// LCCMR Register bits
    namespace lccmr_bits {
        constexpr uint32_t CUR_COL_B = (6 << 0);  ///< Cursor blue field
        constexpr uint32_t CUR_COL_G = (6 << 6);  ///< Cursor green field
        constexpr uint32_t CUR_COL_R = (6 << 12);  ///< Cursor red field
        constexpr uint32_t RESERVED = (14 << 18);  ///< no description available
    }

    /// LPCR Register bits
    namespace lpcr_bits {
        constexpr uint32_t PCD = (6 << 0);  ///< Pixel clock divider
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t SCLKSEL = (1U << 7);  ///< LSCLK select
        constexpr uint32_t ACD = (7 << 8);  ///< Alternate crystal direction
        constexpr uint32_t ACDSEL = (1U << 15);  ///< ACD clock source select
        constexpr uint32_t REV_VS = (1U << 16);  ///< Reverse vertical scan
        constexpr uint32_t SWAP_SEL = (1U << 17);  ///< Swap select
        constexpr uint32_t END_SEL = (1U << 18);  ///< Endian select
        constexpr uint32_t SCLKIDLE = (1U << 19);  ///< LSCLK idle enable
        constexpr uint32_t OEPOL = (1U << 20);  ///< Output enable polarity
        constexpr uint32_t CLKPOL = (1U << 21);  ///< LCD shift clock polarity
        constexpr uint32_t LPPOL = (1U << 22);  ///< Line pulse polarity
        constexpr uint32_t FLMPOL = (1U << 23);  ///< First line marker polarity
        constexpr uint32_t PIXPOL = (1U << 24);  ///< Pixel polarity
        constexpr uint32_t BPIX = (3 << 25);  ///< Bits per pixel
        constexpr uint32_t PBSIZ = (2 << 28);  ///< Panel bus width
        constexpr uint32_t COLOR = (1U << 30);  ///< Interfaces to color display
        constexpr uint32_t TFT = (1U << 31);  ///< Interfaces to TFT display
    }

    /// LHCR Register bits
    namespace lhcr_bits {
        constexpr uint32_t H_WAIT_2 = (8 << 0);  ///< Wait between HSYNC and start of next line
        constexpr uint32_t H_WAIT_1 = (8 << 8);  ///< Wait between OE and HSYNC
        constexpr uint32_t RESERVED = (10 << 16);  ///< no description available
        constexpr uint32_t H_WIDTH = (6 << 26);  ///< Horizontal sync pulse width
    }

    /// LVCR Register bits
    namespace lvcr_bits {
        constexpr uint32_t V_WAIT_2 = (8 << 0);  ///< Wait between frames 2
        constexpr uint32_t V_WAIT_1 = (8 << 8);  ///< Wait between frames 1
        constexpr uint32_t RESERVED = (10 << 16);  ///< no description available
        constexpr uint32_t V_WIDTH = (6 << 26);  ///< Vertical sync pulse width
    }

    /// LPOR Register bits
    namespace lpor_bits {
        constexpr uint32_t POS = (5 << 0);  ///< Panning offset
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

    /// LPCCR Register bits
    namespace lpccr_bits {
        constexpr uint32_t PW = (8 << 0);  ///< Pulse-width
        constexpr uint32_t CC_EN = (1U << 8);  ///< Contrast control enable
        constexpr uint32_t SCR = (2 << 9);  ///< Source select
        constexpr uint32_t RESERVED = (7 << 25);  ///< no description available
        constexpr uint32_t LDMSK = (1U << 15);  ///< LD mask
    }

    /// LDCR Register bits
    namespace ldcr_bits {
        constexpr uint32_t TM = (7 << 0);  ///< DMA trigger mark
        constexpr uint32_t RESERVED = (8 << 23);  ///< no description available
        constexpr uint32_t HM = (7 << 16);  ///< DMA high mark
        constexpr uint32_t BURST = (1U << 31);  ///< Burst length
    }

    /// LRMCR Register bits
    namespace lrmcr_bits {
        constexpr uint32_t SELF_REF = (1U << 0);  ///< Self-refresh
        constexpr uint32_t RESERVED = (31 << 1);  ///< no description available
    }

    /// LICR Register bits
    namespace licr_bits {
        constexpr uint32_t INTCON = (1U << 0);  ///< Interrupt condition
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
        constexpr uint32_t INTSYN = (1U << 2);  ///< Interrupt source
        constexpr uint32_t GW_INT_CON = (1U << 4);  ///< Graphic window interrupt condition
    }

    /// LIER Register bits
    namespace lier_bits {
        constexpr uint32_t BOF_EN = (1U << 0);  ///< Beginning of frame interrupt enable
        constexpr uint32_t EOF_EN = (1U << 1);  ///< End of frame interrupt enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t UDR_ERR_EN = (1U << 3);  ///< Under run error interrupt enable
        constexpr uint32_t GW_BOF_EN = (1U << 4);  ///< Graphic window beginning of frame interrupt enable
        constexpr uint32_t GW_EOF_EN = (1U << 5);  ///< Graphic window end of frame interrupt enable
        constexpr uint32_t GW_UDR_ERR_EN = (1U << 7);  ///< Graphic window under run error interrupt enable
    }

    /// LISR Register bits
    namespace lisr_bits {
        constexpr uint32_t BOF = (1U << 0);  ///< Beginning of frame
        constexpr uint32_t EOF = (1U << 1);  ///< End of frame
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t UDR_ERR = (1U << 3);  ///< Under run error
        constexpr uint32_t GW_BOF = (1U << 4);  ///< Graphic window beginning of frame
        constexpr uint32_t GW_EOF = (1U << 5);  ///< Graphic window end of frame
        constexpr uint32_t GW_UDR_ERR = (1U << 7);  ///< Graphic window under run error
    }

    /// LGWSAR Register bits
    namespace lgwsar_bits {
        constexpr uint32_t RESERVED = (2 << 0);  ///< no description available
        constexpr uint32_t GWSA = (30 << 2);  ///< Graphic window start address on LCD screen
    }

    /// LGWSR Register bits
    namespace lgwsr_bits {
        constexpr uint32_t GWH = (10 << 0);  ///< Graphic window height
        constexpr uint32_t RESERVED = (5 << 27);  ///< no description available
        constexpr uint32_t GWW = (7 << 20);  ///< Graphic window width divided by 16
    }

    /// LGWVPWR Register bits
    namespace lgwvpwr_bits {
        constexpr uint32_t GWVPW = (11 << 0);  ///< Graphic window virtual page width
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
    }

    /// LGWPOR Register bits
    namespace lgwpor_bits {
        constexpr uint32_t GWPO = (5 << 0);  ///< Graphic window panning offset
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

    /// LGWPR Register bits
    namespace lgwpr_bits {
        constexpr uint32_t GWYP = (10 << 0);  ///< Graphic window Y position
        constexpr uint32_t RESERVED = (6 << 26);  ///< no description available
        constexpr uint32_t GWXP = (10 << 16);  ///< Graphic window X position
    }

    /// LGWCR Register bits
    namespace lgwcr_bits {
        constexpr uint32_t GWCKB = (6 << 0);  ///< Graphic window color keying blue component
        constexpr uint32_t GWCKG = (6 << 6);  ///< Graphic window color keying green component
        constexpr uint32_t GWCKR = (6 << 12);  ///< Graphic window color keying red component
        constexpr uint32_t RESERVED = (3 << 18);  ///< no description available
        constexpr uint32_t GW_RVS = (1U << 21);  ///< Graphic window reverse vertical scan
        constexpr uint32_t GWE = (1U << 22);  ///< Graphic window enable
        constexpr uint32_t GWCKE = (1U << 23);  ///< Graphic window color keying enable
        constexpr uint32_t GWAV = (8 << 24);  ///< Graphic window alpha value
    }

    /// LGWDCR Register bits
    namespace lgwdcr_bits {
        constexpr uint32_t GWTM = (7 << 0);  ///< Graphic window DMA low mark
        constexpr uint32_t RESERVED = (8 << 23);  ///< no description available
        constexpr uint32_t GWHM = (7 << 16);  ///< Graphic window DMA high mark
        constexpr uint32_t GWBT = (1U << 31);  ///< Graphic window DMA burst type
    }

    /// LAUSCR Register bits
    namespace lauscr_bits {
        constexpr uint32_t AGWCKB = (8 << 0);  ///< AUS graphic window color keying blue component
        constexpr uint32_t AGWCKG = (8 << 8);  ///< AUS graphic window color keying green component
        constexpr uint32_t AGWCKR = (8 << 16);  ///< AUS graphic window color keying red component
        constexpr uint32_t RESERVED = (7 << 24);  ///< no description available
        constexpr uint32_t AUS_Mode = (1U << 31);  ///< AUS mode control
    }

    /// LAUSCCR Register bits
    namespace lausccr_bits {
        constexpr uint32_t ACUR_COL_B = (8 << 0);  ///< AUS cursor red field
        constexpr uint32_t ACUR_COL_G = (8 << 8);  ///< AUS cursor green field
        constexpr uint32_t ACUR_COL_R = (8 << 16);  ///< AUS cursor red field
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// ENET Peripheral
// ============================================================================

namespace enet {
    /// Base addresses
    constexpr uint32_t ENET_BASE = 0x400C0000;

    /// ENET Register structure
    struct Registers {
        volatile uint32_t EIR;  ///< Offset: 0x04 - Interrupt Event Register
        volatile uint32_t EIMR;  ///< Offset: 0x08 - Interrupt Mask Register
        volatile uint32_t RDAR;  ///< Offset: 0x10 - Receive Descriptor Active Register
        volatile uint32_t TDAR;  ///< Offset: 0x14 - Transmit Descriptor Active Register
        volatile uint32_t ECR;  ///< Offset: 0x24 - Ethernet Control Register
        volatile uint32_t MMFR;  ///< Offset: 0x40 - MII Management Frame Register
        volatile uint32_t MSCR;  ///< Offset: 0x44 - MII Speed Control Register
        volatile uint32_t MIBC;  ///< Offset: 0x64 - MIB Control Register
        volatile uint32_t RCR;  ///< Offset: 0x84 - Receive Control Register
        volatile uint32_t TCR;  ///< Offset: 0xC4 - Transmit Control Register
        volatile uint32_t PALR;  ///< Offset: 0xE4 - Physical Address Lower Register
        volatile uint32_t PAUR;  ///< Offset: 0xE8 - Physical Address Upper Register
        volatile uint32_t OPD;  ///< Offset: 0xEC - Opcode/Pause Duration Register
        volatile uint32_t IAUR;  ///< Offset: 0x118 - Descriptor Individual Upper Address Register
        volatile uint32_t IALR;  ///< Offset: 0x11C - Descriptor Individual Lower Address Register
        volatile uint32_t GAUR;  ///< Offset: 0x120 - Descriptor Group Upper Address Register
        volatile uint32_t GALR;  ///< Offset: 0x124 - Descriptor Group Lower Address Register
        volatile uint32_t TFWR;  ///< Offset: 0x144 - Transmit FIFO Watermark Register
        volatile uint32_t RDSR;  ///< Offset: 0x180 - Receive Descriptor Ring Start Register
        volatile uint32_t TDSR;  ///< Offset: 0x184 - Transmit Buffer Descriptor Ring Start Register
        volatile uint32_t MRBR;  ///< Offset: 0x188 - Maximum Receive Buffer Size Register
        volatile uint32_t RSFL;  ///< Offset: 0x190 - Receive FIFO Section Full Threshold
        volatile uint32_t RSEM;  ///< Offset: 0x194 - Receive FIFO Section Empty Threshold
        volatile uint32_t RAEM;  ///< Offset: 0x198 - Receive FIFO Almost Empty Threshold
        volatile uint32_t RAFL;  ///< Offset: 0x19C - Receive FIFO Almost Full Threshold
        volatile uint32_t TSEM;  ///< Offset: 0x1A0 - Transmit FIFO Section Empty Threshold
        volatile uint32_t TAEM;  ///< Offset: 0x1A4 - Transmit FIFO Almost Empty Threshold
        volatile uint32_t TAFL;  ///< Offset: 0x1A8 - Transmit FIFO Almost Full Threshold
        volatile uint32_t TIPG;  ///< Offset: 0x1AC - Transmit Inter-Packet Gap
        volatile uint32_t FTRL;  ///< Offset: 0x1B0 - Frame Truncation Length
        volatile uint32_t TACC;  ///< Offset: 0x1C0 - Transmit Accelerator Function Configuration
        volatile uint32_t RACC;  ///< Offset: 0x1C4 - Receive Accelerator Function Configuration
        volatile uint32_t RMON_T_DROP;  ///< Offset: 0x200 - Count of frames not counted correctly (RMON_T_DROP)....
        volatile uint32_t RMON_T_PACKETS;  ///< Offset: 0x204 - RMON Tx packet count (RMON_T_PACKETS)
        volatile uint32_t RMON_T_BC_PKT;  ///< Offset: 0x208 - RMON Tx Broadcast Packets (RMON_T_BC_PKT)
        volatile uint32_t RMON_T_MC_PKT;  ///< Offset: 0x20C - RMON Tx Multicast Packets (RMON_T_MC_PKT)
        volatile uint32_t RMON_T_CRC_ALIGN;  ///< Offset: 0x210 - RMON Tx Packets w CRC/Align error (RMON_T_CRC_ALIGN)
        volatile uint32_t RMON_T_UNDERSIZE;  ///< Offset: 0x214 - RMON Tx Packets < 64 bytes, good CRC (RMON_T_UNDERSIZE)
        volatile uint32_t RMON_T_OVERSIZE;  ///< Offset: 0x218 - RMON Tx Packets > MAX_FL bytes, good CRC (RMON_T_OVERSIZE)
        volatile uint32_t RMON_T_FRAG;  ///< Offset: 0x21C - RMON Tx Packets < 64 bytes, bad CRC (RMON_T_FRAG)
        volatile uint32_t RMON_T_JAB;  ///< Offset: 0x220 - RMON Tx Packets > MAX_FL bytes, bad CRC (RMON_T_JAB)
        volatile uint32_t RMON_T_COL;  ///< Offset: 0x224 - RMON Tx collision count (RMON_T_COL)
        volatile uint32_t RMON_T_P64;  ///< Offset: 0x228 - RMON Tx 64 byte packets (RMON_T_P64)
        volatile uint32_t RMON_T_P65TO127;  ///< Offset: 0x22C - RMON Tx 65 to 127 byte packets (RMON_T_P65TO127)
        volatile uint32_t RMON_T_P128TO255;  ///< Offset: 0x230 - RMON Tx 128 to 255 byte packets (RMON_T_P128TO255)
        volatile uint32_t RMON_T_P256TO511;  ///< Offset: 0x234 - RMON Tx 256 to 511 byte packets (RMON_T_P256TO511)
        volatile uint32_t RMON_T_P512TO1023;  ///< Offset: 0x238 - RMON Tx 512 to 1023 byte packets (RMON_T_P512TO1023)
        volatile uint32_t RMON_T_P1024TO2047;  ///< Offset: 0x23C - RMON Tx 1024 to 2047 byte packets (RMON_T_P1024TO2047)
        volatile uint32_t RMON_T_P_GTE2048;  ///< Offset: 0x240 - RMON Tx packets w > 2048 bytes (RMON_T_P_GTE2048)
        volatile uint32_t RMON_T_OCTETS;  ///< Offset: 0x244 - RMON Tx Octets (RMON_T_OCTETS)
        volatile uint32_t IEEE_T_DROP;  ///< Offset: 0x248 - Count of frames not counted correctly (IEEE_T_DROP)....
        volatile uint32_t IEEE_T_FRAME_OK;  ///< Offset: 0x24C - Frames Transmitted OK (IEEE_T_FRAME_OK)
        volatile uint32_t IEEE_T_1COL;  ///< Offset: 0x250 - Frames Transmitted with Single Collision (IEEE_T_1COL)
        volatile uint32_t IEEE_T_MCOL;  ///< Offset: 0x254 - Frames Transmitted with Multiple Collisions (IEEE_T_MCOL)
        volatile uint32_t IEEE_T_DEF;  ///< Offset: 0x258 - Frames Transmitted after Deferral Delay (IEEE_T_DEF)
        volatile uint32_t IEEE_T_LCOL;  ///< Offset: 0x25C - Frames Transmitted with Late Collision (IEEE_T_LCOL)
        volatile uint32_t IEEE_T_EXCOL;  ///< Offset: 0x260 - Frames Transmitted with Excessive Collisions (IEEE_T_EXCOL)
        volatile uint32_t IEEE_T_MACERR;  ///< Offset: 0x264 - Frames Transmitted with Tx FIFO Underrun (IEEE_T_MACERR)
        volatile uint32_t IEEE_T_CSERR;  ///< Offset: 0x268 - Frames Transmitted with Carrier Sense Error (IEEE_T_CSERR)
        volatile uint32_t IEEE_T_SQE;  ///< Offset: 0x26C - Frames Transmitted with SQE Error (IEEE_T_SQE). NOTE:...
        volatile uint32_t IEEE_T_FDXFC;  ///< Offset: 0x270 - Flow Control Pause frames transmitted (IEEE_T_FDXFC)
        volatile uint32_t IEEE_T_OCTETS_OK;  ///< Offset: 0x274 - Octet count for Frames Transmitted w/o Error...
        volatile uint32_t RMON_R_PACKETS;  ///< Offset: 0x284 - RMON Rx packet count (RMON_R_PACKETS)
        volatile uint32_t RMON_R_BC_PKT;  ///< Offset: 0x288 - RMON Rx Broadcast Packets (RMON_R_BC_PKT)
        volatile uint32_t RMON_R_MC_PKT;  ///< Offset: 0x28C - RMON Rx Multicast Packets (RMON_R_MC_PKT)
        volatile uint32_t RMON_R_CRC_ALIGN;  ///< Offset: 0x290 - RMON Rx Packets w CRC/Align error (RMON_R_CRC_ALIGN)
        volatile uint32_t RMON_R_UNDERSIZE;  ///< Offset: 0x294 - RMON Rx Packets < 64 bytes, good CRC (RMON_R_UNDERSIZE)
        volatile uint32_t RMON_R_OVERSIZE;  ///< Offset: 0x298 - RMON Rx Packets > MAX_FL bytes, good CRC (RMON_R_OVERSIZE)
        volatile uint32_t RMON_R_FRAG;  ///< Offset: 0x29C - RMON Rx Packets < 64 bytes, bad CRC (RMON_R_FRAG)
        volatile uint32_t RMON_R_JAB;  ///< Offset: 0x2A0 - RMON Rx Packets > MAX_FL bytes, bad CRC (RMON_R_JAB)
        volatile uint32_t RMON_R_RESVD_0;  ///< Offset: 0x2A4 - Reserved (RMON_R_RESVD_0)
        volatile uint32_t RMON_R_P64;  ///< Offset: 0x2A8 - RMON Rx 64 byte packets (RMON_R_P64)
        volatile uint32_t RMON_R_P65TO127;  ///< Offset: 0x2AC - RMON Rx 65 to 127 byte packets (RMON_R_P65TO127)
        volatile uint32_t RMON_R_P128TO255;  ///< Offset: 0x2B0 - RMON Rx 128 to 255 byte packets (RMON_R_P128TO255)
        volatile uint32_t RMON_R_P256TO511;  ///< Offset: 0x2B4 - RMON Rx 256 to 511 byte packets (RMON_R_P256TO511)
        volatile uint32_t RMON_R_P512TO1023;  ///< Offset: 0x2B8 - RMON Rx 512 to 1023 byte packets (RMON_R_P512TO1023)
        volatile uint32_t RMON_R_P1024TO2047;  ///< Offset: 0x2BC - RMON Rx 1024 to 2047 byte packets (RMON_R_P1024TO2047)
        volatile uint32_t RMON_R_P_GTE2048;  ///< Offset: 0x2C0 - RMON Rx packets w > 2048 bytes (RMON_R_P_GTE2048)
        volatile uint32_t RMON_R_OCTETS;  ///< Offset: 0x2C4 - RMON Rx Octets (RMON_R_OCTETS)
        volatile uint32_t IEEE_R_DROP;  ///< Offset: 0x2C8 - Count of frames not counted correctly (IEEE_R_DROP)....
        volatile uint32_t IEEE_R_FRAME_OK;  ///< Offset: 0x2CC - Frames Received OK (IEEE_R_FRAME_OK)
        volatile uint32_t IEEE_R_CRC;  ///< Offset: 0x2D0 - Frames Received with CRC Error (IEEE_R_CRC)
        volatile uint32_t IEEE_R_ALIGN;  ///< Offset: 0x2D4 - Frames Received with Alignment Error (IEEE_R_ALIGN)
        volatile uint32_t IEEE_R_MACERR;  ///< Offset: 0x2D8 - Receive Fifo Overflow count (IEEE_R_MACERR)
        volatile uint32_t IEEE_R_FDXFC;  ///< Offset: 0x2DC - Flow Control Pause frames received (IEEE_R_FDXFC)
        volatile uint32_t IEEE_R_OCTETS_OK;  ///< Offset: 0x2E0 - Octet count for Frames Rcvd w/o Error...
        volatile uint32_t ATCR;  ///< Offset: 0x400 - Timer Control Register
        volatile uint32_t ATVR;  ///< Offset: 0x404 - Timer Value Register
        volatile uint32_t ATOFF;  ///< Offset: 0x408 - Timer Offset Register
        volatile uint32_t ATPER;  ///< Offset: 0x40C - Timer Period Register
        volatile uint32_t ATCOR;  ///< Offset: 0x410 - Timer Correction Register
        volatile uint32_t ATINC;  ///< Offset: 0x414 - Time-Stamping Clock Period Register
        volatile uint32_t ATSTMP;  ///< Offset: 0x418 - Timestamp of Last Transmitted Frame
        volatile uint32_t TGSR;  ///< Offset: 0x604 - Timer Global Status Register
        volatile uint32_t TCSR;  ///< Offset: 0x608 - Timer Control Status Register (renamed from TCSR)
        volatile uint32_t TCCR;  ///< Offset: 0x60C - Timer Compare Capture Register (renamed from TCCR)
    };

    /// Peripheral instances
    inline Registers* ENET = reinterpret_cast<Registers*>(ENET_BASE);

    // Bit definitions
    /// EIR Register bits
    namespace eir_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TS_TIMER = (1U << 15);  ///< Timestamp timer
        constexpr uint32_t TS_AVAIL = (1U << 16);  ///< Transmit timestamp available
        constexpr uint32_t WAKEUP = (1U << 17);  ///< Node wake-up request indication
        constexpr uint32_t PLR = (1U << 18);  ///< Payload receive error
        constexpr uint32_t UN = (1U << 19);  ///< Transmit FIFO underrun
        constexpr uint32_t RL = (1U << 20);  ///< Collision Retry Limit.
        constexpr uint32_t LC = (1U << 21);  ///< Late Collision
        constexpr uint32_t EBERR = (1U << 22);  ///< Ethernet Bus Error
        constexpr uint32_t MII = (1U << 23);  ///< MII Interrupt.
        constexpr uint32_t RXB = (1U << 24);  ///< Receive Buffer Interrupt.
        constexpr uint32_t RXF = (1U << 25);  ///< Receive Frame Interrupt
        constexpr uint32_t TXB = (1U << 26);  ///< Transmit Buffer Interrupt
        constexpr uint32_t TXF = (1U << 27);  ///< Transmit Frame Interrupt
        constexpr uint32_t GRA = (1U << 28);  ///< Graceful Stop Complete
        constexpr uint32_t BABT = (1U << 29);  ///< Babbling Transmit Error
        constexpr uint32_t BABR = (1U << 30);  ///< Babbling Receive Error
    }

    /// EIMR Register bits
    namespace eimr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TS_TIMER = (1U << 15);  ///< TS_TIMER interrupt mask
        constexpr uint32_t TS_AVAIL = (1U << 16);  ///< TS_AVAIL interrupt mask
        constexpr uint32_t WAKEUP = (1U << 17);  ///< WAKEUP interrupt mask
        constexpr uint32_t PLR = (1U << 18);  ///< PLR interrupt mask
        constexpr uint32_t UN = (1U << 19);  ///< UN interrupt mask
        constexpr uint32_t RL = (1U << 20);  ///< RL interrupt mask
        constexpr uint32_t LC = (1U << 21);  ///< LC interrupt mask
        constexpr uint32_t EBERR = (1U << 22);  ///< EBERR interrupt mask
        constexpr uint32_t MII = (1U << 23);  ///< MII interrupt mask
        constexpr uint32_t RXB = (1U << 24);  ///< RXB interrupt mask
        constexpr uint32_t RXF = (1U << 25);  ///< RXF interrupt mask
        constexpr uint32_t TXB = (1U << 26);  ///< TXB interrupt mask
        constexpr uint32_t TXF = (1U << 27);  ///< TXF interrupt mask
        constexpr uint32_t GRA = (1U << 28);  ///< GRA interrupt mask
        constexpr uint32_t BABT = (1U << 29);  ///< BABT interrupt mask
        constexpr uint32_t BABR = (1U << 30);  ///< BABR interrupt mask
    }

    /// RDAR Register bits
    namespace rdar_bits {
        constexpr uint32_t RESERVED = (7 << 25);  ///< no description available
        constexpr uint32_t RDAR = (1U << 24);  ///< Receive descriptor active
    }

    /// TDAR Register bits
    namespace tdar_bits {
        constexpr uint32_t RESERVED = (7 << 25);  ///< no description available
        constexpr uint32_t TDAR = (1U << 24);  ///< Transmit descriptor active
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< Ethernet MAC reset
        constexpr uint32_t ETHEREN = (1U << 1);  ///< Ethernet enable
        constexpr uint32_t MAGICEN = (1U << 2);  ///< Magic packet detection enable
        constexpr uint32_t SLEEP = (1U << 3);  ///< Sleep mode enable
        constexpr uint32_t EN1588 = (1U << 4);  ///< EN1588 enable
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t DBGEN = (1U << 6);  ///< Debug enable
        constexpr uint32_t STOPEN = (1U << 7);  ///< STOPEN Signal Control
        constexpr uint32_t DBSWP = (1U << 8);  ///< Descriptor Byte Swapping Enable
    }

    /// MMFR Register bits
    namespace mmfr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Management frame data
        constexpr uint32_t TA = (2 << 16);  ///< Turn around
        constexpr uint32_t RA = (5 << 18);  ///< Register address
        constexpr uint32_t PA = (5 << 23);  ///< PHY address
        constexpr uint32_t OP = (2 << 28);  ///< Operation code
        constexpr uint32_t ST = (2 << 30);  ///< Start of frame delimiter
    }

    /// MSCR Register bits
    namespace mscr_bits {
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t MII_SPEED = (6 << 1);  ///< MII speed
        constexpr uint32_t DIS_PRE = (1U << 7);  ///< Disable preamble
        constexpr uint32_t HOLDTIME = (3 << 8);  ///< Holdtime on MDIO output
    }

    /// MIBC Register bits
    namespace mibc_bits {
        constexpr uint32_t RESERVED = (29 << 0);  ///< no description available
        constexpr uint32_t MIB_CLEAR = (1U << 29);  ///< MIB clear
        constexpr uint32_t MIB_IDLE = (1U << 30);  ///< MIB idle
        constexpr uint32_t MIB_DIS = (1U << 31);  ///< Disable MIB logic
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t LOOP = (1U << 0);  ///< Internal loopback
        constexpr uint32_t DRT = (1U << 1);  ///< Disable receive on transmit
        constexpr uint32_t MII_MODE = (1U << 2);  ///< Media independent interface mode
        constexpr uint32_t PROM = (1U << 3);  ///< Promiscuous mode. All frames are accepted regardless of address matching.
        constexpr uint32_t BC_REJ = (1U << 4);  ///< Broadcast frame reject
        constexpr uint32_t FCE = (1U << 5);  ///< Flow control enable
        constexpr uint32_t RESERVED = (2 << 10);  ///< no description available
        constexpr uint32_t RMII_MODE = (1U << 8);  ///< RMII mode enable
        constexpr uint32_t RMII_10T = (1U << 9);  ///< no description available
        constexpr uint32_t PADEN = (1U << 12);  ///< Enable frame padding remove on receive
        constexpr uint32_t PAUFWD = (1U << 13);  ///< Terminate/forward pause frames.
        constexpr uint32_t CRCFWD = (1U << 14);  ///< Terminate/forward received CRC
        constexpr uint32_t CFEN = (1U << 15);  ///< MAC control frame enable
        constexpr uint32_t MAX_FL = (14 << 16);  ///< Maximum frame length
        constexpr uint32_t NLC = (1U << 30);  ///< Payload length check disable
        constexpr uint32_t GRS = (1U << 31);  ///< Graceful receive stopped
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t GTS = (1U << 0);  ///< Graceful transmit stop
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t FDEN = (1U << 2);  ///< Full duplex enable
        constexpr uint32_t TFC_PAUSE = (1U << 3);  ///< Transmit frame control pause
        constexpr uint32_t RFC_PAUSE = (1U << 4);  ///< Receive frame control pause
        constexpr uint32_t ADDSEL = (3 << 5);  ///< Source MAC address select on transmit
        constexpr uint32_t ADDINS = (1U << 8);  ///< Set MAC address on transmit
        constexpr uint32_t CRCFWD = (1U << 9);  ///< Forward frame from application with CRC
    }

    /// PALR Register bits
    namespace palr_bits {
        constexpr uint32_t PADDR1 = (32 << 0);  ///< Pause address
    }

    /// PAUR Register bits
    namespace paur_bits {
        constexpr uint32_t TYPE = (16 << 0);  ///< Type field in PAUSE frames.
        constexpr uint32_t PADDR2 = (16 << 16);  ///< no description available
    }

    /// OPD Register bits
    namespace opd_bits {
        constexpr uint32_t PAUSE_DUR = (16 << 0);  ///< Pause duration
        constexpr uint32_t OPCODE = (16 << 16);  ///< Opcode field in PAUSE frames
    }

    /// IAUR Register bits
    namespace iaur_bits {
        constexpr uint32_t IADDR1 = (32 << 0);  ///< no description available
    }

    /// IALR Register bits
    namespace ialr_bits {
        constexpr uint32_t IADDR2 = (32 << 0);  ///< no description available
    }

    /// GAUR Register bits
    namespace gaur_bits {
        constexpr uint32_t GADDR1 = (32 << 0);  ///< no description available
    }

    /// GALR Register bits
    namespace galr_bits {
        constexpr uint32_t GADDR2 = (32 << 0);  ///< no description available
    }

    /// TFWR Register bits
    namespace tfwr_bits {
        constexpr uint32_t TFWR = (6 << 0);  ///< Transmit FIFO write
        constexpr uint32_t RESERVED = (23 << 9);  ///< no description available
        constexpr uint32_t STRFWD = (1U << 8);  ///< Store and forward enable
    }

    /// RDSR Register bits
    namespace rdsr_bits {
        constexpr uint32_t RESERVED = (3 << 0);  ///< no description available
        constexpr uint32_t R_DES_START = (29 << 3);  ///< no description available
    }

    /// TDSR Register bits
    namespace tdsr_bits {
        constexpr uint32_t RESERVED = (3 << 0);  ///< no description available
        constexpr uint32_t X_DES_START = (29 << 3);  ///< no description available
    }

    /// MRBR Register bits
    namespace mrbr_bits {
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
        constexpr uint32_t R_BUF_SIZE = (10 << 4);  ///< no description available
    }

    /// RSFL Register bits
    namespace rsfl_bits {
        constexpr uint32_t RX_SECTION_FULL = (8 << 0);  ///< Value of receive FIFO section full threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// RSEM Register bits
    namespace rsem_bits {
        constexpr uint32_t RX_SECTION_EMPTY = (8 << 0);  ///< Value of the receive FIFO section empty threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// RAEM Register bits
    namespace raem_bits {
        constexpr uint32_t RX_ALMOST_EMPTY = (8 << 0);  ///< Value of the receive FIFO almost empty threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// RAFL Register bits
    namespace rafl_bits {
        constexpr uint32_t RX_ALMOST_FULL = (8 << 0);  ///< Value of the receive FIFO almost full threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// TSEM Register bits
    namespace tsem_bits {
        constexpr uint32_t TX_SECTION_EMPTY = (8 << 0);  ///< Value of the transmit FIFO section empty threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// TAEM Register bits
    namespace taem_bits {
        constexpr uint32_t TX_ALMOST_EMPTY = (8 << 0);  ///< Value of transmit FIFO almost empty threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// TAFL Register bits
    namespace tafl_bits {
        constexpr uint32_t TX_ALMOST_FULL = (8 << 0);  ///< Value of the transmit FIFO almost full threshold
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// TIPG Register bits
    namespace tipg_bits {
        constexpr uint32_t IPG = (5 << 0);  ///< Transmit inter-packet gap
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

    /// FTRL Register bits
    namespace ftrl_bits {
        constexpr uint32_t TRUNC_FL = (14 << 0);  ///< Frame truncation length
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
    }

    /// TACC Register bits
    namespace tacc_bits {
        constexpr uint32_t SHIFT16 = (1U << 0);  ///< TX FIFO shift-16
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
        constexpr uint32_t IPCHK = (1U << 3);  ///< no description available
        constexpr uint32_t PROCHK = (1U << 4);  ///< no description available
    }

    /// RACC Register bits
    namespace racc_bits {
        constexpr uint32_t PADREM = (1U << 0);  ///< Enable padding removal for short IP frames.
        constexpr uint32_t IPDIS = (1U << 1);  ///< Enable discard of frames with wrong IPv4 header checksum.
        constexpr uint32_t PRODIS = (1U << 2);  ///< Enable discard of frames with wrong protocol checksum
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t LINEDIS = (1U << 6);  ///< Enable discard of frames with MAC layer errors
        constexpr uint32_t SHIFT16 = (1U << 7);  ///< RX FIFO shift-16
    }

    /// RMON_T_DROP Register bits
    namespace rmon_t_drop_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_PACKETS Register bits
    namespace rmon_t_packets_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_BC_PKT Register bits
    namespace rmon_t_bc_pkt_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_MC_PKT Register bits
    namespace rmon_t_mc_pkt_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_CRC_ALIGN Register bits
    namespace rmon_t_crc_align_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_UNDERSIZE Register bits
    namespace rmon_t_undersize_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_OVERSIZE Register bits
    namespace rmon_t_oversize_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_FRAG Register bits
    namespace rmon_t_frag_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_JAB Register bits
    namespace rmon_t_jab_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_COL Register bits
    namespace rmon_t_col_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P64 Register bits
    namespace rmon_t_p64_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P65TO127 Register bits
    namespace rmon_t_p65to127_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P128TO255 Register bits
    namespace rmon_t_p128to255_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P256TO511 Register bits
    namespace rmon_t_p256to511_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P512TO1023 Register bits
    namespace rmon_t_p512to1023_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P1024TO2047 Register bits
    namespace rmon_t_p1024to2047_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_P_GTE2048 Register bits
    namespace rmon_t_p_gte2048_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_T_OCTETS Register bits
    namespace rmon_t_octets_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_DROP Register bits
    namespace ieee_t_drop_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_FRAME_OK Register bits
    namespace ieee_t_frame_ok_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_1COL Register bits
    namespace ieee_t_1col_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_MCOL Register bits
    namespace ieee_t_mcol_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_DEF Register bits
    namespace ieee_t_def_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_LCOL Register bits
    namespace ieee_t_lcol_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_EXCOL Register bits
    namespace ieee_t_excol_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_MACERR Register bits
    namespace ieee_t_macerr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_CSERR Register bits
    namespace ieee_t_cserr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_SQE Register bits
    namespace ieee_t_sqe_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_FDXFC Register bits
    namespace ieee_t_fdxfc_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_T_OCTETS_OK Register bits
    namespace ieee_t_octets_ok_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_PACKETS Register bits
    namespace rmon_r_packets_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_BC_PKT Register bits
    namespace rmon_r_bc_pkt_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_MC_PKT Register bits
    namespace rmon_r_mc_pkt_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_CRC_ALIGN Register bits
    namespace rmon_r_crc_align_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_UNDERSIZE Register bits
    namespace rmon_r_undersize_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_OVERSIZE Register bits
    namespace rmon_r_oversize_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_FRAG Register bits
    namespace rmon_r_frag_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_JAB Register bits
    namespace rmon_r_jab_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_RESVD_0 Register bits
    namespace rmon_r_resvd_0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P64 Register bits
    namespace rmon_r_p64_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P65TO127 Register bits
    namespace rmon_r_p65to127_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P128TO255 Register bits
    namespace rmon_r_p128to255_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P256TO511 Register bits
    namespace rmon_r_p256to511_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P512TO1023 Register bits
    namespace rmon_r_p512to1023_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P1024TO2047 Register bits
    namespace rmon_r_p1024to2047_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_P_GTE2048 Register bits
    namespace rmon_r_p_gte2048_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// RMON_R_OCTETS Register bits
    namespace rmon_r_octets_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_DROP Register bits
    namespace ieee_r_drop_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_FRAME_OK Register bits
    namespace ieee_r_frame_ok_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_CRC Register bits
    namespace ieee_r_crc_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_ALIGN Register bits
    namespace ieee_r_align_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_MACERR Register bits
    namespace ieee_r_macerr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_FDXFC Register bits
    namespace ieee_r_fdxfc_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// IEEE_R_OCTETS_OK Register bits
    namespace ieee_r_octets_ok_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// ATCR Register bits
    namespace atcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable timer
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
        constexpr uint32_t OFFEN = (1U << 2);  ///< Enable one-shot offset event
        constexpr uint32_t OFFRST = (1U << 3);  ///< Reset timer on offset event
        constexpr uint32_t PEREN = (1U << 4);  ///< Enable periodical event
        constexpr uint32_t PINPER = (1U << 7);  ///< no description available
        constexpr uint32_t RESTART = (1U << 9);  ///< Reset timer
        constexpr uint32_t CAPTURE = (1U << 11);  ///< Capture timer value
        constexpr uint32_t SLAVE = (1U << 13);  ///< Enable timer slave mode
    }

    /// ATVR Register bits
    namespace atvr_bits {
        constexpr uint32_t ATIME = (32 << 0);  ///< no description available
    }

    /// ATOFF Register bits
    namespace atoff_bits {
        constexpr uint32_t OFFSET = (32 << 0);  ///< no description available
    }

    /// ATPER Register bits
    namespace atper_bits {
        constexpr uint32_t PERIOD = (32 << 0);  ///< no description available
    }

    /// ATCOR Register bits
    namespace atcor_bits {
        constexpr uint32_t COR = (31 << 0);  ///< Correction counter wrap-around value
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// ATINC Register bits
    namespace atinc_bits {
        constexpr uint32_t INC = (7 << 0);  ///< Clock period of the timestamping clock (ts_clk) in nanoseconds
        constexpr uint32_t RESERVED = (17 << 15);  ///< no description available
        constexpr uint32_t INC_CORR = (7 << 8);  ///< Correction increment value
    }

    /// ATSTMP Register bits
    namespace atstmp_bits {
        constexpr uint32_t TIMESTAMP = (32 << 0);  ///< no description available
    }

    /// TGSR Register bits
    namespace tgsr_bits {
        constexpr uint32_t TF0 = (1U << 0);  ///< Copy of Timer Flag for channel 0
        constexpr uint32_t TF1 = (1U << 1);  ///< Copy of Timer Flag for channel 1
        constexpr uint32_t TF2 = (1U << 2);  ///< Copy of Timer Flag for channel 2
        constexpr uint32_t TF3 = (1U << 3);  ///< Copy of Timer Flag for channel 3
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t TDRE = (1U << 0);  ///< Timer DMA Request Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t TMODE = (4 << 2);  ///< Timer Mode
        constexpr uint32_t TIE = (1U << 6);  ///< Timer interrupt enable
        constexpr uint32_t TF = (1U << 7);  ///< Timer Flag
    }

    /// TCCR Register bits
    namespace tccr_bits {
        constexpr uint32_t TCC = (32 << 0);  ///< Timer Capture Compare
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x400CC000;
    constexpr uint32_t DAC1_BASE = 0x400CD000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< no description available
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA = (4 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC buffer read pointer bottom position flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC buffer read pointer top position flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC buffer watermark flag
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC buffer read pointer bottom flag interrupt enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC buffer read pointer top flag interrupt enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC buffer watermark interrupt enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC low power control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC software trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC trigger select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC buffer enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC buffer work mode select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC buffer watermark select
        constexpr uint32_t RESERVED = (2 << 5);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA enable select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC buffer upper limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC buffer read pointer
    }

}

// ============================================================================
// PTA Peripheral
// ============================================================================

namespace pta {
    /// Base addresses
    constexpr uint32_t PTA_BASE = 0x400FF000;

    /// PTA Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTA = reinterpret_cast<Registers*>(PTA_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTB Peripheral
// ============================================================================

namespace ptb {
    /// Base addresses
    constexpr uint32_t PTB_BASE = 0x400FF040;

    /// PTB Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTB = reinterpret_cast<Registers*>(PTB_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTC Peripheral
// ============================================================================

namespace ptc {
    /// Base addresses
    constexpr uint32_t PTC_BASE = 0x400FF080;

    /// PTC Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTC = reinterpret_cast<Registers*>(PTC_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTD Peripheral
// ============================================================================

namespace ptd {
    /// Base addresses
    constexpr uint32_t PTD_BASE = 0x400FF0C0;

    /// PTD Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTD = reinterpret_cast<Registers*>(PTD_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTE Peripheral
// ============================================================================

namespace pte {
    /// Base addresses
    constexpr uint32_t PTE_BASE = 0x400FF100;

    /// PTE Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTE = reinterpret_cast<Registers*>(PTE_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTF Peripheral
// ============================================================================

namespace ptf {
    /// Base addresses
    constexpr uint32_t PTF_BASE = 0x400FF140;

    /// PTF Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTF = reinterpret_cast<Registers*>(PTF_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t CR;  ///< Offset: 0x0C - Control Register
        volatile uint32_t ISCR;  ///< Offset: 0x10 - Interrupt Status and control Register
        volatile uint32_t ETBCC;  ///< Offset: 0x14 - ETB Counter Control register
        volatile uint32_t ETBRL;  ///< Offset: 0x18 - ETB Reload register
        volatile uint32_t ETBCNT;  ///< Offset: 0x1C - ETB Counter Value register
        volatile uint32_t FADR;  ///< Offset: 0x20 - Fault address register
        volatile uint32_t FATR;  ///< Offset: 0x24 - Fault attributes register
        volatile uint32_t FDR;  ///< Offset: 0x28 - Fault data register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t DDRSIZE = (2 << 20);  ///< DDR address size translation
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L Write Protect
    }

    /// ISCR Register bits
    namespace iscr_bits {
        constexpr uint32_t RESERVED = (2 << 29);  ///< no description available
        constexpr uint32_t IRQ = (1U << 1);  ///< Normal Interrupt Pending
        constexpr uint32_t NMI = (1U << 2);  ///< Nonmaskable Interrupt Pending
        constexpr uint32_t DHREQ = (1U << 3);  ///< Debug Halt Request Indicator
        constexpr uint32_t CWBER = (1U << 4);  ///< Cache write buffer error status
        constexpr uint32_t FIOC = (1U << 8);  ///< FPU invalid operation interrupt status
        constexpr uint32_t FDZC = (1U << 9);  ///< FPU divide-by-zero interrupt status
        constexpr uint32_t FOFC = (1U << 10);  ///< FPU overflow interrupt status
        constexpr uint32_t FUFC = (1U << 11);  ///< FPU underflow interrupt status
        constexpr uint32_t FIXC = (1U << 12);  ///< FPU inexact interrupt status
        constexpr uint32_t FIDC = (1U << 15);  ///< FPU input denormal interrupt status
        constexpr uint32_t CWBEE = (1U << 20);  ///< Cache write buffer error enable
        constexpr uint32_t FIOCE = (1U << 24);  ///< FPU invalid operation interrupt enable
        constexpr uint32_t FDZCE = (1U << 25);  ///< FPU divide-by-zero interrupt enable
        constexpr uint32_t FOFCE = (1U << 26);  ///< FPU overflow interrupt enable
        constexpr uint32_t FUFCE = (1U << 27);  ///< FPU underflow interrupt enable
        constexpr uint32_t FIXCE = (1U << 28);  ///< FPU inexact interrupt enable
        constexpr uint32_t FIDCE = (1U << 31);  ///< FPU input denormal interrupt enable
    }

    /// ETBCC Register bits
    namespace etbcc_bits {
        constexpr uint32_t CNTEN = (1U << 0);  ///< Counter Enable
        constexpr uint32_t RSPT = (2 << 1);  ///< Response Type
        constexpr uint32_t RLRQ = (1U << 3);  ///< Reload Request
        constexpr uint32_t ETDIS = (1U << 4);  ///< ETM-To-TPIU Disable
        constexpr uint32_t ITDIS = (1U << 5);  ///< ITM-To-TPIU Disable
        constexpr uint32_t RESERVED = (26 << 6);  ///< no description available
    }

    /// ETBRL Register bits
    namespace etbrl_bits {
        constexpr uint32_t RELOAD = (11 << 0);  ///< Byte Count Reload Value
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
    }

    /// ETBCNT Register bits
    namespace etbcnt_bits {
        constexpr uint32_t COUNTER = (11 << 0);  ///< Byte Count Counter Value
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
    }

    /// FADR Register bits
    namespace fadr_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Fault address
    }

    /// FATR Register bits
    namespace fatr_bits {
        constexpr uint32_t BEDA = (1U << 0);  ///< Bus error access type
        constexpr uint32_t BEMD = (1U << 1);  ///< Bus error privilege level
        constexpr uint32_t RESERVED = (19 << 12);  ///< no description available
        constexpr uint32_t BESZ = (2 << 4);  ///< Bus error size
        constexpr uint32_t BEWT = (1U << 7);  ///< Bus error write
        constexpr uint32_t BEMN = (4 << 8);  ///< Bus error master number
        constexpr uint32_t BEOVR = (1U << 31);  ///< Bus error overrun
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Fault data
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID and M1_PID for MPU
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

}

// ============================================================================
// CAU Peripheral
// ============================================================================

namespace cau {
    /// Base addresses
    constexpr uint32_t CAU_BASE = 0xE0081000;

    /// CAU Register structure
    struct Registers {
        volatile uint32_t CAU_DIRECT0;  ///< Offset: 0x00 - Direct access register 0
        volatile uint32_t CAU_DIRECT1;  ///< Offset: 0x04 - Direct access register 1
        volatile uint32_t CAU_DIRECT2;  ///< Offset: 0x08 - Direct access register 2
        volatile uint32_t CAU_DIRECT3;  ///< Offset: 0x0C - Direct access register 3
        volatile uint32_t CAU_DIRECT4;  ///< Offset: 0x10 - Direct access register 4
        volatile uint32_t CAU_DIRECT5;  ///< Offset: 0x14 - Direct access register 5
        volatile uint32_t CAU_DIRECT6;  ///< Offset: 0x18 - Direct access register 6
        volatile uint32_t CAU_DIRECT7;  ///< Offset: 0x1C - Direct access register 7
        volatile uint32_t CAU_DIRECT8;  ///< Offset: 0x20 - Direct access register 8
        volatile uint32_t CAU_DIRECT9;  ///< Offset: 0x24 - Direct access register 9
        volatile uint32_t CAU_DIRECT10;  ///< Offset: 0x28 - Direct access register 10
        volatile uint32_t CAU_DIRECT11;  ///< Offset: 0x2C - Direct access register 11
        volatile uint32_t CAU_DIRECT12;  ///< Offset: 0x30 - Direct access register 12
        volatile uint32_t CAU_DIRECT13;  ///< Offset: 0x34 - Direct access register 13
        volatile uint32_t CAU_DIRECT14;  ///< Offset: 0x38 - Direct access register 14
        volatile uint32_t CAU_DIRECT15;  ///< Offset: 0x3C - Direct access register 15
        volatile uint32_t CAU_LDR_CASR;  ///< Offset: 0x840 - Status register - Load Register command
        volatile uint32_t CAU_LDR_CAA;  ///< Offset: 0x844 - Accumulator register - Load Register command
        volatile uint32_t CAU_LDR_CA0;  ///< Offset: 0x848 - General Purpose Register 0 - Load Register command
        volatile uint32_t CAU_LDR_CA1;  ///< Offset: 0x84C - General Purpose Register 1 - Load Register command
        volatile uint32_t CAU_LDR_CA2;  ///< Offset: 0x850 - General Purpose Register 2 - Load Register command
        volatile uint32_t CAU_LDR_CA3;  ///< Offset: 0x854 - General Purpose Register 3 - Load Register command
        volatile uint32_t CAU_LDR_CA4;  ///< Offset: 0x858 - General Purpose Register 4 - Load Register command
        volatile uint32_t CAU_LDR_CA5;  ///< Offset: 0x85C - General Purpose Register 5 - Load Register command
        volatile uint32_t CAU_LDR_CA6;  ///< Offset: 0x860 - General Purpose Register 6 - Load Register command
        volatile uint32_t CAU_LDR_CA7;  ///< Offset: 0x864 - General Purpose Register 7 - Load Register command
        volatile uint32_t CAU_LDR_CA8;  ///< Offset: 0x868 - General Purpose Register 8 - Load Register command
        volatile uint32_t CAU_STR_CASR;  ///< Offset: 0x880 - Status register - Store Register command
        volatile uint32_t CAU_STR_CAA;  ///< Offset: 0x884 - Accumulator register - Store Register command
        volatile uint32_t CAU_STR_CA0;  ///< Offset: 0x888 - General Purpose Register 0 - Store Register command
        volatile uint32_t CAU_STR_CA1;  ///< Offset: 0x88C - General Purpose Register 1 - Store Register command
        volatile uint32_t CAU_STR_CA2;  ///< Offset: 0x890 - General Purpose Register 2 - Store Register command
        volatile uint32_t CAU_STR_CA3;  ///< Offset: 0x894 - General Purpose Register 3 - Store Register command
        volatile uint32_t CAU_STR_CA4;  ///< Offset: 0x898 - General Purpose Register 4 - Store Register command
        volatile uint32_t CAU_STR_CA5;  ///< Offset: 0x89C - General Purpose Register 5 - Store Register command
        volatile uint32_t CAU_STR_CA6;  ///< Offset: 0x8A0 - General Purpose Register 6 - Store Register command
        volatile uint32_t CAU_STR_CA7;  ///< Offset: 0x8A4 - General Purpose Register 7 - Store Register command
        volatile uint32_t CAU_STR_CA8;  ///< Offset: 0x8A8 - General Purpose Register 8 - Store Register command
        volatile uint32_t CAU_ADR_CASR;  ///< Offset: 0x8C0 - Status register - Add Register command
        volatile uint32_t CAU_ADR_CAA;  ///< Offset: 0x8C4 - Accumulator register - Add to register command
        volatile uint32_t CAU_ADR_CA0;  ///< Offset: 0x8C8 - General Purpose Register 0 - Add to register command
        volatile uint32_t CAU_ADR_CA1;  ///< Offset: 0x8CC - General Purpose Register 1 - Add to register command
        volatile uint32_t CAU_ADR_CA2;  ///< Offset: 0x8D0 - General Purpose Register 2 - Add to register command
        volatile uint32_t CAU_ADR_CA3;  ///< Offset: 0x8D4 - General Purpose Register 3 - Add to register command
        volatile uint32_t CAU_ADR_CA4;  ///< Offset: 0x8D8 - General Purpose Register 4 - Add to register command
        volatile uint32_t CAU_ADR_CA5;  ///< Offset: 0x8DC - General Purpose Register 5 - Add to register command
        volatile uint32_t CAU_ADR_CA6;  ///< Offset: 0x8E0 - General Purpose Register 6 - Add to register command
        volatile uint32_t CAU_ADR_CA7;  ///< Offset: 0x8E4 - General Purpose Register 7 - Add to register command
        volatile uint32_t CAU_ADR_CA8;  ///< Offset: 0x8E8 - General Purpose Register 8 - Add to register command
        volatile uint32_t CAU_RADR_CASR;  ///< Offset: 0x900 - Status register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CAA;  ///< Offset: 0x904 - Accumulator register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA0;  ///< Offset: 0x908 - General Purpose Register 0 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA1;  ///< Offset: 0x90C - General Purpose Register 1 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA2;  ///< Offset: 0x910 - General Purpose Register 2 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA3;  ///< Offset: 0x914 - General Purpose Register 3 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA4;  ///< Offset: 0x918 - General Purpose Register 4 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA5;  ///< Offset: 0x91C - General Purpose Register 5 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA6;  ///< Offset: 0x920 - General Purpose Register 6 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA7;  ///< Offset: 0x924 - General Purpose Register 7 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA8;  ///< Offset: 0x928 - General Purpose Register 8 - Reverse and Add to Register command
        volatile uint32_t CAU_XOR_CASR;  ///< Offset: 0x980 - Status register - Exclusive Or command
        volatile uint32_t CAU_XOR_CAA;  ///< Offset: 0x984 - Accumulator register - Exclusive Or command
        volatile uint32_t CAU_XOR_CA0;  ///< Offset: 0x988 - General Purpose Register 0 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA1;  ///< Offset: 0x98C - General Purpose Register 1 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA2;  ///< Offset: 0x990 - General Purpose Register 2 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA3;  ///< Offset: 0x994 - General Purpose Register 3 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA4;  ///< Offset: 0x998 - General Purpose Register 4 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA5;  ///< Offset: 0x99C - General Purpose Register 5 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA6;  ///< Offset: 0x9A0 - General Purpose Register 6 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA7;  ///< Offset: 0x9A4 - General Purpose Register 7 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA8;  ///< Offset: 0x9A8 - General Purpose Register 8 - Exclusive Or command
        volatile uint32_t CAU_ROTL_CASR;  ///< Offset: 0x9C0 - Status register - Rotate Left command
        volatile uint32_t CAU_ROTL_CAA;  ///< Offset: 0x9C4 - Accumulator register - Rotate Left command
        volatile uint32_t CAU_ROTL_CA0;  ///< Offset: 0x9C8 - General Purpose Register 0 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA1;  ///< Offset: 0x9CC - General Purpose Register 1 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA2;  ///< Offset: 0x9D0 - General Purpose Register 2 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA3;  ///< Offset: 0x9D4 - General Purpose Register 3 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA4;  ///< Offset: 0x9D8 - General Purpose Register 4 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA5;  ///< Offset: 0x9DC - General Purpose Register 5 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA6;  ///< Offset: 0x9E0 - General Purpose Register 6 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA7;  ///< Offset: 0x9E4 - General Purpose Register 7 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA8;  ///< Offset: 0x9E8 - General Purpose Register 8 - Rotate Left command
        volatile uint32_t CAU_AESC_CASR;  ///< Offset: 0xB00 - Status register - AES Column Operation command
        volatile uint32_t CAU_AESC_CAA;  ///< Offset: 0xB04 - Accumulator register - AES Column Operation command
        volatile uint32_t CAU_AESC_CA0;  ///< Offset: 0xB08 - General Purpose Register 0 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA1;  ///< Offset: 0xB0C - General Purpose Register 1 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA2;  ///< Offset: 0xB10 - General Purpose Register 2 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA3;  ///< Offset: 0xB14 - General Purpose Register 3 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA4;  ///< Offset: 0xB18 - General Purpose Register 4 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA5;  ///< Offset: 0xB1C - General Purpose Register 5 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA6;  ///< Offset: 0xB20 - General Purpose Register 6 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA7;  ///< Offset: 0xB24 - General Purpose Register 7 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA8;  ///< Offset: 0xB28 - General Purpose Register 8 - AES Column Operation command
        volatile uint32_t CAU_AESIC_CASR;  ///< Offset: 0xB40 - Status register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CAA;  ///< Offset: 0xB44 - Accumulator register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA0;  ///< Offset: 0xB48 - General Purpose Register 0 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA1;  ///< Offset: 0xB4C - General Purpose Register 1 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA2;  ///< Offset: 0xB50 - General Purpose Register 2 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA3;  ///< Offset: 0xB54 - General Purpose Register 3 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA4;  ///< Offset: 0xB58 - General Purpose Register 4 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA5;  ///< Offset: 0xB5C - General Purpose Register 5 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA6;  ///< Offset: 0xB60 - General Purpose Register 6 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA7;  ///< Offset: 0xB64 - General Purpose Register 7 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA8;  ///< Offset: 0xB68 - General Purpose Register 8 - AES Inverse Column Operation command
    };

    /// Peripheral instances
    inline Registers* CAU = reinterpret_cast<Registers*>(CAU_BASE);

    // Bit definitions
    /// CAU_DIRECT0 Register bits
    namespace cau_direct0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT1 Register bits
    namespace cau_direct1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT2 Register bits
    namespace cau_direct2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT3 Register bits
    namespace cau_direct3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT4 Register bits
    namespace cau_direct4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT5 Register bits
    namespace cau_direct5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT6 Register bits
    namespace cau_direct6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT7 Register bits
    namespace cau_direct7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT8 Register bits
    namespace cau_direct8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT9 Register bits
    namespace cau_direct9_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT10 Register bits
    namespace cau_direct10_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT11 Register bits
    namespace cau_direct11_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT12 Register bits
    namespace cau_direct12_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT13 Register bits
    namespace cau_direct13_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT14 Register bits
    namespace cau_direct14_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_DIRECT15 Register bits
    namespace cau_direct15_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CASR Register bits
    namespace cau_ldr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_LDR_CAA Register bits
    namespace cau_ldr_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA0 Register bits
    namespace cau_ldr_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA1 Register bits
    namespace cau_ldr_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA2 Register bits
    namespace cau_ldr_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA3 Register bits
    namespace cau_ldr_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA4 Register bits
    namespace cau_ldr_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA5 Register bits
    namespace cau_ldr_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA6 Register bits
    namespace cau_ldr_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA7 Register bits
    namespace cau_ldr_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_LDR_CA8 Register bits
    namespace cau_ldr_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CASR Register bits
    namespace cau_str_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_STR_CAA Register bits
    namespace cau_str_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA0 Register bits
    namespace cau_str_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA1 Register bits
    namespace cau_str_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA2 Register bits
    namespace cau_str_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA3 Register bits
    namespace cau_str_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA4 Register bits
    namespace cau_str_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA5 Register bits
    namespace cau_str_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA6 Register bits
    namespace cau_str_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA7 Register bits
    namespace cau_str_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_STR_CA8 Register bits
    namespace cau_str_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CASR Register bits
    namespace cau_adr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ADR_CAA Register bits
    namespace cau_adr_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA0 Register bits
    namespace cau_adr_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA1 Register bits
    namespace cau_adr_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA2 Register bits
    namespace cau_adr_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA3 Register bits
    namespace cau_adr_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA4 Register bits
    namespace cau_adr_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA5 Register bits
    namespace cau_adr_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA6 Register bits
    namespace cau_adr_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA7 Register bits
    namespace cau_adr_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ADR_CA8 Register bits
    namespace cau_adr_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CASR Register bits
    namespace cau_radr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_RADR_CAA Register bits
    namespace cau_radr_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA0 Register bits
    namespace cau_radr_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA1 Register bits
    namespace cau_radr_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA2 Register bits
    namespace cau_radr_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA3 Register bits
    namespace cau_radr_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA4 Register bits
    namespace cau_radr_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA5 Register bits
    namespace cau_radr_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA6 Register bits
    namespace cau_radr_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA7 Register bits
    namespace cau_radr_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_RADR_CA8 Register bits
    namespace cau_radr_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CASR Register bits
    namespace cau_xor_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_XOR_CAA Register bits
    namespace cau_xor_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA0 Register bits
    namespace cau_xor_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA1 Register bits
    namespace cau_xor_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA2 Register bits
    namespace cau_xor_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA3 Register bits
    namespace cau_xor_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA4 Register bits
    namespace cau_xor_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA5 Register bits
    namespace cau_xor_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA6 Register bits
    namespace cau_xor_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA7 Register bits
    namespace cau_xor_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_XOR_CA8 Register bits
    namespace cau_xor_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CASR Register bits
    namespace cau_rotl_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ROTL_CAA Register bits
    namespace cau_rotl_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA0 Register bits
    namespace cau_rotl_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA1 Register bits
    namespace cau_rotl_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA2 Register bits
    namespace cau_rotl_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA3 Register bits
    namespace cau_rotl_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA4 Register bits
    namespace cau_rotl_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA5 Register bits
    namespace cau_rotl_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA6 Register bits
    namespace cau_rotl_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA7 Register bits
    namespace cau_rotl_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_ROTL_CA8 Register bits
    namespace cau_rotl_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CASR Register bits
    namespace cau_aesc_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESC_CAA Register bits
    namespace cau_aesc_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA0 Register bits
    namespace cau_aesc_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA1 Register bits
    namespace cau_aesc_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA2 Register bits
    namespace cau_aesc_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA3 Register bits
    namespace cau_aesc_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA4 Register bits
    namespace cau_aesc_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA5 Register bits
    namespace cau_aesc_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA6 Register bits
    namespace cau_aesc_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA7 Register bits
    namespace cau_aesc_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESC_CA8 Register bits
    namespace cau_aesc_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CASR Register bits
    namespace cau_aesic_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESIC_CAA Register bits
    namespace cau_aesic_caa_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA0 Register bits
    namespace cau_aesic_ca0_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA1 Register bits
    namespace cau_aesic_ca1_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA2 Register bits
    namespace cau_aesic_ca2_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA3 Register bits
    namespace cau_aesic_ca3_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA4 Register bits
    namespace cau_aesic_ca4_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA5 Register bits
    namespace cau_aesic_ca5_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA6 Register bits
    namespace cau_aesic_ca6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA7 Register bits
    namespace cau_aesic_ca7_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CAU_AESIC_CA8 Register bits
    namespace cau_aesic_ca8_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

}

// ============================================================================
// LMEM Peripheral
// ============================================================================

namespace lmem {
    /// Base addresses
    constexpr uint32_t LMEM_BASE = 0xE0082000;

    /// LMEM Register structure
    struct Registers {
        volatile uint32_t PCCCR;  ///< Offset: 0x00 - Cache control register
        volatile uint32_t PCCLCR;  ///< Offset: 0x04 - Cache line control register
        volatile uint32_t PCCSAR;  ///< Offset: 0x08 - Cache search address register
        volatile uint32_t PCCCVR;  ///< Offset: 0x0C - Cache read/write value register
        volatile uint32_t PCCRMR;  ///< Offset: 0x20 - Cache regions mode register
        volatile uint32_t PSCCR;  ///< Offset: 0x800 - Cache control register
        volatile uint32_t PSCLCR;  ///< Offset: 0x804 - Cache line control register
        volatile uint32_t PSCSAR;  ///< Offset: 0x808 - Cache search address register
        volatile uint32_t PSCCVR;  ///< Offset: 0x80C - Cache read/write value register
        volatile uint32_t PSCRMR;  ///< Offset: 0x820 - Cache regions mode register
    };

    /// Peripheral instances
    inline Registers* LMEM = reinterpret_cast<Registers*>(LMEM_BASE);

    // Bit definitions
    /// PCCCR Register bits
    namespace pcccr_bits {
        constexpr uint32_t ENCACHE = (1U << 0);  ///< Cache enable
        constexpr uint32_t ENWRBUF = (1U << 1);  ///< Enable Write Buffer
        constexpr uint32_t RESERVED = (3 << 28);  ///< no description available
        constexpr uint32_t INVW0 = (1U << 24);  ///< Invalidate Way 0
        constexpr uint32_t PUSHW0 = (1U << 25);  ///< Push Way 0
        constexpr uint32_t INVW1 = (1U << 26);  ///< Invalidate Way 1
        constexpr uint32_t PUSHW1 = (1U << 27);  ///< Push Way 1
        constexpr uint32_t GO = (1U << 31);  ///< Initiate Cache Command
    }

    /// PCCLCR Register bits
    namespace pcclcr_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t CACHEADDR = (10 << 2);  ///< Cache address
        constexpr uint32_t WSEL = (1U << 14);  ///< Way select
        constexpr uint32_t TDSEL = (1U << 16);  ///< Tag/Data Select
        constexpr uint32_t LCIVB = (1U << 20);  ///< Line Command Initial Valid Bit
        constexpr uint32_t LCIMB = (1U << 21);  ///< Line Command Initial Modified Bit
        constexpr uint32_t LCWAY = (1U << 22);  ///< Line Command Way
        constexpr uint32_t LCMD = (2 << 24);  ///< Line Command
        constexpr uint32_t LADSEL = (1U << 26);  ///< Line Address Select
        constexpr uint32_t LACC = (1U << 27);  ///< Line access type
    }

    /// PCCSAR Register bits
    namespace pccsar_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t RESERVED = (1U << 1);  ///< no description available
        constexpr uint32_t PHYADDR = (30 << 2);  ///< Physical Address
    }

    /// PCCCVR Register bits
    namespace pcccvr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Cache read/write Data
    }

    /// PCCRMR Register bits
    namespace pccrmr_bits {
        constexpr uint32_t R15 = (2 << 0);  ///< Region 15 mode
        constexpr uint32_t R14 = (2 << 2);  ///< Region 14 mode
        constexpr uint32_t R13 = (2 << 4);  ///< Region 13 mode
        constexpr uint32_t R12 = (2 << 6);  ///< Region 12 mode
        constexpr uint32_t R11 = (2 << 8);  ///< Region 11 mode
        constexpr uint32_t R10 = (2 << 10);  ///< Region 10 mode
        constexpr uint32_t R9 = (2 << 12);  ///< Region 9 mode
        constexpr uint32_t R8 = (2 << 14);  ///< Region 8 mode
        constexpr uint32_t R7 = (2 << 16);  ///< Region 7 mode
        constexpr uint32_t R6 = (2 << 18);  ///< Region 6 mode
        constexpr uint32_t R5 = (2 << 20);  ///< Region 5 mode
        constexpr uint32_t R4 = (2 << 22);  ///< Region 4 mode
        constexpr uint32_t R3 = (2 << 24);  ///< Region 3 mode
        constexpr uint32_t R2 = (2 << 26);  ///< Region 2 mode
        constexpr uint32_t R1 = (2 << 28);  ///< Region 1 mode
        constexpr uint32_t R0 = (2 << 30);  ///< Region 0 mode
    }

    /// PSCCR Register bits
    namespace psccr_bits {
        constexpr uint32_t ENCACHE = (1U << 0);  ///< Cache enable
        constexpr uint32_t ENWRBUF = (1U << 1);  ///< Enable Write Buffer
        constexpr uint32_t RESERVED = (3 << 28);  ///< no description available
        constexpr uint32_t INVW0 = (1U << 24);  ///< Invalidate Way 0
        constexpr uint32_t PUSHW0 = (1U << 25);  ///< Push Way 0
        constexpr uint32_t INVW1 = (1U << 26);  ///< Invalidate Way 1
        constexpr uint32_t PUSHW1 = (1U << 27);  ///< Push Way 1
        constexpr uint32_t GO = (1U << 31);  ///< Initiate Cache Command
    }

    /// PSCLCR Register bits
    namespace psclcr_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t CACHEADDR = (10 << 2);  ///< Cache address
        constexpr uint32_t WSEL = (1U << 14);  ///< Way select
        constexpr uint32_t TDSEL = (1U << 16);  ///< Tag/Data Select
        constexpr uint32_t LCIVB = (1U << 20);  ///< Line Command Initial Valid Bit
        constexpr uint32_t LCIMB = (1U << 21);  ///< Line Command Initial Modified Bit
        constexpr uint32_t LCWAY = (1U << 22);  ///< Line Command Way
        constexpr uint32_t LCMD = (2 << 24);  ///< Line Command
        constexpr uint32_t LADSEL = (1U << 26);  ///< Line Address Select
        constexpr uint32_t LACC = (1U << 27);  ///< Line access type
    }

    /// PSCSAR Register bits
    namespace pscsar_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t RESERVED = (1U << 1);  ///< no description available
        constexpr uint32_t PHYADDR = (30 << 2);  ///< Physical Address
    }

    /// PSCCVR Register bits
    namespace psccvr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Cache read/write Data
    }

    /// PSCRMR Register bits
    namespace pscrmr_bits {
        constexpr uint32_t R15 = (2 << 0);  ///< Region 15 mode
        constexpr uint32_t R14 = (2 << 2);  ///< Region 14 mode
        constexpr uint32_t R13 = (2 << 4);  ///< Region 13 mode
        constexpr uint32_t R12 = (2 << 6);  ///< Region 12 mode
        constexpr uint32_t R11 = (2 << 8);  ///< Region 11 mode
        constexpr uint32_t R10 = (2 << 10);  ///< Region 10 mode
        constexpr uint32_t R9 = (2 << 12);  ///< Region 9 mode
        constexpr uint32_t R8 = (2 << 14);  ///< Region 8 mode
        constexpr uint32_t R7 = (2 << 16);  ///< Region 7 mode
        constexpr uint32_t R6 = (2 << 18);  ///< Region 6 mode
        constexpr uint32_t R5 = (2 << 20);  ///< Region 5 mode
        constexpr uint32_t R4 = (2 << 22);  ///< Region 4 mode
        constexpr uint32_t R3 = (2 << 24);  ///< Region 3 mode
        constexpr uint32_t R2 = (2 << 26);  ///< Region 2 mode
        constexpr uint32_t R1 = (2 << 28);  ///< Region 1 mode
        constexpr uint32_t R0 = (2 << 30);  ///< Region 0 mode
    }

}


} // namespace alloy::generated::mk70f15ws

#endif // ALLOY_GENERATED_MK70F15WS_PERIPHERALS_HPP