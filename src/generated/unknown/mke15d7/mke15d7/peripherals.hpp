/// Auto-generated code for MKE15D7
/// Generated by Alloy Code Generator
/// Source: nxp_mke15.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:45
#ifndef ALLOY_GENERATED_MKE15D7_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKE15D7_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mke15d7 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips = true;
    constexpr uint32_t num_aips_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_ievent = true;
    constexpr uint32_t num_ievent_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_pdb1 = true;
    constexpr uint32_t num_pdb1_instances = 1;
    constexpr bool has_pdb2 = true;
    constexpr uint32_t num_pdb2_instances = 1;
    constexpr bool has_pdb3 = true;
    constexpr uint32_t num_pdb3_instances = 1;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_ftm3 = true;
    constexpr uint32_t num_ftm3_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_ftmra = true;
    constexpr uint32_t num_ftmra_instances = 1;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 4;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_ics = true;
    constexpr uint32_t num_ics_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 4;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_cmp3 = true;
    constexpr uint32_t num_cmp3_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_pta = true;
    constexpr uint32_t num_pta_instances = 1;
    constexpr bool has_ptb = true;
    constexpr uint32_t num_ptb_instances = 1;
    constexpr bool has_ptc = true;
    constexpr uint32_t num_ptc_instances = 1;
    constexpr bool has_ptd = true;
    constexpr uint32_t num_ptd_instances = 1;
    constexpr bool has_pte = true;
    constexpr uint32_t num_pte_instances = 1;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ievent_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ftmra_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ics_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pta_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pte_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTMRA_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FPROT;  ///< Offset: 0x0E - Non-volatile P-Flash Protection Register
        volatile uint32_t DFPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTMRA_FlashConfig = reinterpret_cast<Registers*>(FTMRA_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t FPLS = (2 << 0);  ///< no description available
        constexpr uint32_t FPLDIS = (1U << 2);  ///< no description available
        constexpr uint32_t FPHS = (2 << 3);  ///< no description available
        constexpr uint32_t FPHDIS = (1U << 5);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t FPOPEN = (1U << 7);  ///< no description available
    }

    /// DFPROT Register bits
    namespace dfprot_bits {
        constexpr uint32_t DPS = (5 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t DPOPEN = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// AIPS Peripheral
// ============================================================================

namespace aips {
    /// Base addresses
    constexpr uint32_t AIPS_BASE = 0x40000000;

    /// AIPS Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
        volatile uint32_t PACRU;  ///< Offset: 0x80 - Peripheral Access Control Register U
    };

    /// Peripheral instances
    inline Registers* AIPS = reinterpret_cast<Registers*>(AIPS_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRU Register bits
    namespace pacru_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT;  ///< Offset: 0x24 - Interrupt Request Register
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t DCHPRI3;  ///< Offset: 0x100 - Channel n Priority Register
        volatile uint32_t DCHPRI2;  ///< Offset: 0x101 - Channel n Priority Register
        volatile uint32_t DCHPRI1;  ///< Offset: 0x102 - Channel n Priority Register
        volatile uint32_t DCHPRI0;  ///< Offset: 0x103 - Channel n Priority Register
        volatile uint32_t DCHPRI7;  ///< Offset: 0x104 - Channel n Priority Register
        volatile uint32_t DCHPRI6;  ///< Offset: 0x105 - Channel n Priority Register
        volatile uint32_t DCHPRI5;  ///< Offset: 0x106 - Channel n Priority Register
        volatile uint32_t DCHPRI4;  ///< Offset: 0x107 - Channel n Priority Register
        volatile uint32_t DCHPRI11;  ///< Offset: 0x108 - Channel n Priority Register
        volatile uint32_t DCHPRI10;  ///< Offset: 0x109 - Channel n Priority Register
        volatile uint32_t DCHPRI9;  ///< Offset: 0x10A - Channel n Priority Register
        volatile uint32_t DCHPRI8;  ///< Offset: 0x10B - Channel n Priority Register
        volatile uint32_t DCHPRI13;  ///< Offset: 0x10E - Channel n Priority Register
        volatile uint32_t DCHPRI12;  ///< Offset: 0x10F - Channel n Priority Register
        volatile uint32_t TCD%s_SADDR;  ///< Offset: 0x1000 - TCD Source Address
        volatile uint32_t TCD%s_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset
        volatile uint32_t TCD%s_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes
        volatile uint32_t TCD%s_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Disabled)
        volatile uint32_t TCD%s_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
        volatile uint32_t TCD%s_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Enabled and...
        volatile uint32_t TCD%s_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment
        volatile uint32_t TCD%s_DADDR;  ///< Offset: 0x1010 - TCD Destination Address
        volatile uint32_t TCD%s_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset
        volatile uint32_t TCD%s_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD%s_CSR;  ///< Offset: 0x101C - TCD Control and Status
        volatile uint32_t TCD%s_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESERVED = (14 << 18);  ///< no description available
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Cancelled Channel Number
        constexpr uint32_t RESERVED = (14 << 17);  ///< no description available
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Cancelled
        constexpr uint32_t VLD = (1U << 31);  ///< no description available
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set enable request
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t RESERVED = (18 << 14);  ///< no description available
    }

    /// DCHPRI3 Register bits
    namespace dchpri3_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI2 Register bits
    namespace dchpri2_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI1 Register bits
    namespace dchpri1_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI0 Register bits
    namespace dchpri0_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI7 Register bits
    namespace dchpri7_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI6 Register bits
    namespace dchpri6_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI5 Register bits
    namespace dchpri5_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI4 Register bits
    namespace dchpri4_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI11 Register bits
    namespace dchpri11_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI10 Register bits
    namespace dchpri10_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI9 Register bits
    namespace dchpri9_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI8 Register bits
    namespace dchpri8_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI13 Register bits
    namespace dchpri13_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// DCHPRI12 Register bits
    namespace dchpri12_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t RESERVED = (2 << 4);  ///< no description available
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// TCD%s_SADDR Register bits
    namespace tcd%s_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD%s_SOFF Register bits
    namespace tcd%s_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD%s_ATTR Register bits
    namespace tcd%s_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination Data Transfer Size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo.
    }

    /// TCD%s_NBYTES_MLNO Register bits
    namespace tcd%s_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD%s_NBYTES_MLOFFYES Register bits
    namespace tcd%s_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_NBYTES_MLOFFNO Register bits
    namespace tcd%s_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_SLAST Register bits
    namespace tcd%s_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last source Address Adjustment
    }

    /// TCD%s_DADDR Register bits
    namespace tcd%s_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD%s_DOFF Register bits
    namespace tcd%s_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed offset
    }

    /// TCD%s_CITER_ELINKNO Register bits
    namespace tcd%s_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_CITER_ELINKYES Register bits
    namespace tcd%s_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t RESERVED = (2 << 13);  ///< no description available
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_DLASTSGA Register bits
    namespace tcd%s_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< no description available
    }

    /// TCD%s_CSR Register bits
    namespace tcd%s_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Link Channel Number
        constexpr uint32_t RESERVED = (2 << 12);  ///< no description available
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD%s_BITER_ELINKNO Register bits
    namespace tcd%s_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD%s_BITER_ELINKYES Register bits
    namespace tcd%s_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t RESERVED = (2 << 13);  ///< no description available
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR%s;  ///< Offset: 0x00 - Chip Select Address Register
        volatile uint32_t CSMR%s;  ///< Offset: 0x04 - Chip Select Mask Register
        volatile uint32_t CSCR%s;  ///< Offset: 0x08 - Chip Select Control Register
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip Select port Multiplexing Control Register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR%s Register bits
    namespace csar%s_bits {
        constexpr uint32_t RESERVED = (16 << 0);  ///< no description available
        constexpr uint32_t BA = (16 << 16);  ///< Base Address
    }

    /// CSMR%s Register bits
    namespace csmr%s_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t RESERVED = (7 << 9);  ///< no description available
        constexpr uint32_t WP = (1U << 8);  ///< Write Protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base Address Mask
    }

    /// CSCR%s Register bits
    namespace cscr%s_bits {
        constexpr uint32_t RESERVED = (2 << 24);  ///< no description available
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-Write Enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-Read Enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-Enable Mode
        constexpr uint32_t PS = (2 << 6);  ///< Port Size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-Acknowledge Enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-Lane Shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait States
        constexpr uint32_t WRAH = (2 << 16);  ///< Write Address Hold or Deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read Address Hold or Deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address Setup
        constexpr uint32_t EXTS = (1U << 22);  ///< no description available
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary Wait State Enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary Wait States
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t RESERVED = (12 << 0);  ///< no description available
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus Signal Group 5 Multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus Signal Group 4 Multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus Signal Group 3 Multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus Signal Group 2 Multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus Signal Group 1 Multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR%s;  ///< Offset: 0x10 - Error Address Register, slave port n
        volatile uint32_t EDR%s;  ///< Offset: 0x14 - Error Detail Register, slave port n
        volatile uint32_t RGD%s_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0
        volatile uint32_t RGD%s_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1
        volatile uint32_t RGD%s_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2
        volatile uint32_t RGD%s_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3
        volatile uint32_t RGDAAC%s;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t RESERVED = (3 << 24);  ///< no description available
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave Port n Error
    }

    /// EAR%s Register bits
    namespace ear%s_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR%s Register bits
    namespace edr%s_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD%s_WORD0 Register bits
    namespace rgd%s_word0_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< no description available
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD%s_WORD1 Register bits
    namespace rgd%s_word1_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< no description available
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD%s_WORD2 Register bits
    namespace rgd%s_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t RESERVED = (1U << 23);  ///< no description available
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD%s_WORD3 Register bits
    namespace rgd%s_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t RESERVED = (31 << 1);  ///< no description available
    }

    /// RGDAAC%s Register bits
    namespace rgdaac%s_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t RESERVED = (1U << 23);  ///< no description available
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// IEVENT Peripheral
// ============================================================================

namespace ievent {
    /// Base addresses
    constexpr uint32_t IEVENT_BASE = 0x40019000;

    /// IEVENT Register structure
    struct Registers {
        volatile uint32_t DRL;  ///< Offset: 0x00 - iEvent Data Register: Low
        volatile uint32_t CRL;  ///< Offset: 0x80 - iEvent Control Register: Low
        volatile uint32_t IMXCR%s;  ///< Offset: 0x100 - iEvent Input Mux Configuration Register
        volatile uint32_t BFECR%s;  ///< Offset: 0x104 - iEvent Boolean Function Eva1ation Configuration Register
    };

    /// Peripheral instances
    inline Registers* IEVENT = reinterpret_cast<Registers*>(IEVENT_BASE);

    // Bit definitions
    /// DRL Register bits
    namespace drl_bits {
        constexpr uint32_t IN_A0 = (1U << 0);  ///< Event Inputs {A0}
        constexpr uint32_t IN_B0 = (1U << 1);  ///< Event Inputs {B0}
        constexpr uint32_t IN_C0 = (1U << 2);  ///< Event Inputs {C0}
        constexpr uint32_t IN_D0 = (1U << 3);  ///< Event Inputs {D0}
        constexpr uint32_t Output_FSM0 = (3 << 4);  ///< Output Finite State Machine 0
        constexpr uint32_t Ev_Out0 = (1U << 7);  ///< Event Output 0
        constexpr uint32_t IN_A1 = (1U << 8);  ///< Event Inputs {A1}
        constexpr uint32_t IN_B1 = (1U << 9);  ///< Event Inputs {B1}
        constexpr uint32_t IN_C1 = (1U << 10);  ///< Event Inputs {C1}
        constexpr uint32_t IN_D1 = (1U << 11);  ///< Event Inputs {D1}
        constexpr uint32_t Output_FSM1 = (3 << 12);  ///< Output Finite State Machine 1
        constexpr uint32_t Ev_Out1 = (1U << 15);  ///< Event Output 1
        constexpr uint32_t IN_A2 = (1U << 16);  ///< Event Inputs {A2}
        constexpr uint32_t IN_B2 = (1U << 17);  ///< Event Inputs {B2}
        constexpr uint32_t IN_C2 = (1U << 18);  ///< Event Inputs {C2}
        constexpr uint32_t IN_D2 = (1U << 19);  ///< Event Inputs {D2}
        constexpr uint32_t Output_FSM2 = (3 << 20);  ///< Output Finite State Machine 2
        constexpr uint32_t Ev_Out2 = (1U << 23);  ///< Event Output 2
        constexpr uint32_t IN_A3 = (1U << 24);  ///< Event Inputs {A3}
        constexpr uint32_t IN_B3 = (1U << 25);  ///< Event Inputs {B3}
        constexpr uint32_t IN_C3 = (1U << 26);  ///< Event Inputs {C3}
        constexpr uint32_t IN_D3 = (1U << 27);  ///< Event Inputs {D3}
        constexpr uint32_t Output_FSM3 = (3 << 28);  ///< Output Finite State Machine 3
        constexpr uint32_t Ev_Out3 = (1U << 31);  ///< Event Output 3
    }

    /// CRL Register bits
    namespace crl_bits {
        constexpr uint32_t Type0 = (2 << 0);  ///< Output Channel Type 0
        constexpr uint32_t OSE0 = (1U << 2);  ///< One-Shot Enable 0
        constexpr uint32_t DDB0 = (1U << 3);  ///< Disable Done Broadcast 0
        constexpr uint32_t RESERVED = (3 << 28);  ///< no description available
        constexpr uint32_t RO0 = (1U << 7);  ///< Read-Only 0
        constexpr uint32_t Type1 = (2 << 8);  ///< Output Channel Type 1
        constexpr uint32_t OSE1 = (1U << 10);  ///< One-Shot Enable 1
        constexpr uint32_t DDB1 = (1U << 11);  ///< Disable Done Broadcast 1
        constexpr uint32_t RO1 = (1U << 15);  ///< Read-Only 1
        constexpr uint32_t Type2 = (2 << 16);  ///< Output Channel Type 2
        constexpr uint32_t OSE2 = (1U << 18);  ///< One-Shot Enable 2
        constexpr uint32_t DDB2 = (1U << 19);  ///< Disable Done Broadcast 2
        constexpr uint32_t RO2 = (1U << 23);  ///< Read-Only 2
        constexpr uint32_t Type3 = (2 << 24);  ///< Output Channel Type 3
        constexpr uint32_t OSE3 = (1U << 26);  ///< One-Shot Enable 3
        constexpr uint32_t DDB3 = (1U << 27);  ///< Disable Done Broadcast 3
        constexpr uint32_t RO3 = (1U << 31);  ///< Read-Only 3
    }

    /// IMXCR%s Register bits
    namespace imxcr%s_bits {
        constexpr uint32_t D_Select = (4 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t C_Select = (4 << 8);  ///< no description available
        constexpr uint32_t B_Select = (4 << 16);  ///< no description available
        constexpr uint32_t A_Select = (4 << 24);  ///< no description available
    }

    /// BFECR%s Register bits
    namespace bfecr%s_bits {
        constexpr uint32_t PT3_DC = (2 << 0);  ///< Product Term 3, D input Configuration
        constexpr uint32_t PT3_CC = (2 << 2);  ///< Product Term 3, C input Configuration
        constexpr uint32_t PT3_BC = (2 << 4);  ///< Product Term 3, B input Configuration
        constexpr uint32_t PT3_AC = (2 << 6);  ///< Product Term 3, A input Configuration
        constexpr uint32_t PT2_DC = (2 << 8);  ///< Product Term 2, D input Configuration
        constexpr uint32_t PT2_CC = (2 << 10);  ///< Product Term 2, C input Configuration
        constexpr uint32_t PT2_BC = (2 << 12);  ///< Product Term 2, B input Configuration
        constexpr uint32_t PT2_AC = (2 << 14);  ///< Product Term 2, A input Configuration
        constexpr uint32_t PT1_DC = (2 << 16);  ///< Product Term 1, D input Configuration
        constexpr uint32_t PT1_CC = (2 << 18);  ///< Product Term 1, C input Configuration
        constexpr uint32_t PT1_BC = (2 << 20);  ///< Product Term 1, B input Configuration
        constexpr uint32_t PT1_AC = (2 << 22);  ///< Product Term 1, A input Configuration
        constexpr uint32_t PT0_DC = (2 << 24);  ///< Product Term 0, D input Configuration
        constexpr uint32_t PT0_CC = (2 << 26);  ///< Product Term 0, C input Configuration
        constexpr uint32_t PT0_BC = (2 << 28);  ///< Product Term 0, B input Configuration
        constexpr uint32_t PT0_AC = (2 << 30);  ///< Product Term 0, A input Configuration
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Bank 0 Control Register
        volatile uint32_t PFB1CR;  ///< Offset: 0x08 - Flash Bank 1 Control Register
        volatile uint32_t TAGVDW0S%s;  ///< Offset: 0x100 - Cache Tag Storage
        volatile uint32_t TAGVDW1S%s;  ///< Offset: 0x110 - Cache Tag Storage
        volatile uint32_t TAGVDW2S%s;  ///< Offset: 0x120 - Cache Tag Storage
        volatile uint32_t TAGVDW3S%s;  ///< Offset: 0x130 - Cache Tag Storage
        volatile uint32_t DATAW0S%sU;  ///< Offset: 0x200 - Cache Data Storage (upper word)
        volatile uint32_t DATAW0S%sL;  ///< Offset: 0x204 - Cache Data Storage (lower word)
        volatile uint32_t DATAW1S%sU;  ///< Offset: 0x220 - Cache Data Storage (upper word)
        volatile uint32_t DATAW1S%sL;  ///< Offset: 0x224 - Cache Data Storage (lower word)
        volatile uint32_t DATAW2S%sU;  ///< Offset: 0x240 - Cache Data Storage (upper word)
        volatile uint32_t DATAW2S%sL;  ///< Offset: 0x244 - Cache Data Storage (lower word)
        volatile uint32_t DATAW3S%sU;  ///< Offset: 0x260 - Cache Data Storage (upper word)
        volatile uint32_t DATAW3S%sL;  ///< Offset: 0x264 - Cache Data Storage (lower word)
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0SEBE = (1U << 0);  ///< Bank 0 Single Entry Buffer Enable
        constexpr uint32_t B0IPE = (1U << 1);  ///< Bank 0 Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Bank 0 Data Prefetch Enable
        constexpr uint32_t B0ICE = (1U << 3);  ///< Bank 0 Instruction Cache Enable
        constexpr uint32_t B0DCE = (1U << 4);  ///< Bank 0 Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t RESERVED = (1U << 16);  ///< no description available
        constexpr uint32_t B0MW = (2 << 17);  ///< Bank 0 Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Bank 0 Read Wait State Control
    }

    /// PFB1CR Register bits
    namespace pfb1cr_bits {
        constexpr uint32_t RESERVED = (9 << 19);  ///< no description available
        constexpr uint32_t B1MW = (2 << 17);  ///< Bank 1 Memory Width
        constexpr uint32_t B1RWSC = (4 << 28);  ///< Bank 1 Read Wait State Control
    }

    /// TAGVDW0S%s Register bits
    namespace tagvdw0s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (13 << 19);  ///< no description available
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW1S%s Register bits
    namespace tagvdw1s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (13 << 19);  ///< no description available
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW2S%s Register bits
    namespace tagvdw2s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (13 << 19);  ///< no description available
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW3S%s Register bits
    namespace tagvdw3s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t RESERVED = (13 << 19);  ///< no description available
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// DATAW0S%sU Register bits
    namespace dataw0s%su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW0S%sL Register bits
    namespace dataw0s%sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1S%sU Register bits
    namespace dataw1s%su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW1S%sL Register bits
    namespace dataw1s%sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2S%sU Register bits
    namespace dataw2s%su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW2S%sL Register bits
    namespace dataw2s%sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3S%sU Register bits
    namespace dataw3s%su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW3S%sL Register bits
    namespace dataw3s%sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40023000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL%s;  ///< Offset: 0x100 - Timer Load Value Register
        volatile uint32_t CVAL%s;  ///< Offset: 0x104 - Current Timer Value Register
        volatile uint32_t TCTRL%s;  ///< Offset: 0x108 - Timer Control Register
        volatile uint32_t TFLG%s;  ///< Offset: 0x10C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
        constexpr uint32_t RESERVED = (30 << 2);  ///< no description available
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL%s Register bits
    namespace ldval%s_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL%s Register bits
    namespace cval%s_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL%s Register bits
    namespace tctrl%s_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
        constexpr uint32_t RESERVED = (29 << 3);  ///< no description available
    }

    /// TFLG%s Register bits
    namespace tflg%s_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
        constexpr uint32_t RESERVED = (31 << 1);  ///< no description available
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40024000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCLL;  ///< Offset: 0x00 - CRC_CRCLL register.
        volatile uint32_t CRC;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t CRCL;  ///< Offset: 0x00 - CRC_CRCL register.
        volatile uint32_t CRCLU;  ///< Offset: 0x01 - CRC_CRCLU register.
        volatile uint32_t CRCHL;  ///< Offset: 0x02 - CRC_CRCHL register.
        volatile uint32_t CRCH;  ///< Offset: 0x02 - CRC_CRCH register.
        volatile uint32_t CRCHU;  ///< Offset: 0x03 - CRC_CRCHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCLL Register bits
    namespace crcll_bits {
        constexpr uint32_t CRCLL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit CRC
    }

    /// CRC Register bits
    namespace crc_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// CRCL Register bits
    namespace crcl_bits {
        constexpr uint32_t CRCL = (16 << 0);  ///< CRCL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// CRCLU Register bits
    namespace crclu_bits {
        constexpr uint32_t CRCLU = (8 << 0);  ///< CRCLL stores the second 8 bits of the 32 bit CRC
    }

    /// CRCHL Register bits
    namespace crchl_bits {
        constexpr uint32_t CRCHL = (8 << 0);  ///< CRCHL stores the third 8 bits of the 32 bit CRC
    }

    /// CRCH Register bits
    namespace crch_bits {
        constexpr uint32_t CRCH = (16 << 0);  ///< CRCL stores the high 16 bits of the 16/32 bit CRC
    }

    /// CRCHU Register bits
    namespace crchu_bits {
        constexpr uint32_t CRCHU = (8 << 0);  ///< CRCHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t TCRC = (1U << 24);  ///< no description available
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 3);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40025000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register
        volatile uint32_t CHDLY2;  ///< Offset: 0x20 - Channel n Delay 2 Register
        volatile uint32_t CHDLY3;  ///< Offset: 0x24 - Channel n Delay 3 Register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY2 Register bits
    namespace chdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY3 Register bits
    namespace chdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// PDB1 Peripheral
// ============================================================================

namespace pdb1 {
    /// Base addresses
    constexpr uint32_t PDB1_BASE = 0x40026000;

    /// PDB1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register
        volatile uint32_t CHDLY2;  ///< Offset: 0x20 - Channel n Delay 2 Register
        volatile uint32_t CHDLY3;  ///< Offset: 0x24 - Channel n Delay 3 Register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register
    };

    /// Peripheral instances
    inline Registers* PDB1 = reinterpret_cast<Registers*>(PDB1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY2 Register bits
    namespace chdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY3 Register bits
    namespace chdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// PDB2 Peripheral
// ============================================================================

namespace pdb2 {
    /// Base addresses
    constexpr uint32_t PDB2_BASE = 0x40027000;

    /// PDB2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register
        volatile uint32_t CHDLY2;  ///< Offset: 0x20 - Channel n Delay 2 Register
        volatile uint32_t CHDLY3;  ///< Offset: 0x24 - Channel n Delay 3 Register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register
    };

    /// Peripheral instances
    inline Registers* PDB2 = reinterpret_cast<Registers*>(PDB2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY2 Register bits
    namespace chdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY3 Register bits
    namespace chdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// PDB3 Peripheral
// ============================================================================

namespace pdb3 {
    /// Base addresses
    constexpr uint32_t PDB3_BASE = 0x40028000;

    /// PDB3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register
        volatile uint32_t CHDLY2;  ///< Offset: 0x20 - Channel n Delay 2 Register
        volatile uint32_t CHDLY3;  ///< Offset: 0x24 - Channel n Delay 3 Register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register
    };

    /// Peripheral instances
    inline Registers* PDB3 = reinterpret_cast<Registers*>(PDB3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY2 Register bits
    namespace chdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CHDLY3 Register bits
    namespace chdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40029000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x4002A000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x4002B000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM3 Peripheral
// ============================================================================

namespace ftm3 {
    /// Base addresses
    constexpr uint32_t FTM3_BASE = 0x4002C000;

    /// FTM3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM3 = reinterpret_cast<Registers*>(FTM3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t RESERVED = (20 << 12);  ///< no description available
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t RESERVED = (21 << 11);  ///< no description available
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t RESERVED = (11 << 21);  ///< no description available
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t RESERVED = (22 << 10);  ///< no description available
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4002D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - RTC Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - RTC Modulo Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - RTC Counter Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
        constexpr uint32_t RTCO = (1U << 4);  ///< Real-Time Counter Output
        constexpr uint32_t DMAE = (1U << 5);  ///< DMA Enable
        constexpr uint32_t RTIE = (1U << 6);  ///< Real-Time Interrupt Enable
        constexpr uint32_t RTIF = (1U << 7);  ///< Real-Time Interrupt Flag
        constexpr uint32_t RTCPS = (3 << 8);  ///< Real-Time Clock Prescaler Select
        constexpr uint32_t RTCLKS = (2 << 14);  ///< Real-Time Clock Source Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< RTC Modulo
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< RTC Count
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40030000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - General Control and Status Register
        volatile uint32_t SCANC;  ///< Offset: 0x04 - SCAN Control Register
        volatile uint32_t PEN;  ///< Offset: 0x08 - Pin Enable Register
        volatile uint32_t CNTR%s;  ///< Offset: 0x100 - Counter Register
        volatile uint32_t THRESHOLD;  ///< Offset: 0x120 - Low Power Channel Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t STPE = (1U << 0);  ///< no description available
        constexpr uint32_t STM = (1U << 1);  ///< Scan Trigger Mode. User is allowed to change this bit when TSI is not working in progress.
        constexpr uint32_t RESERVED = (8 << 24);  ///< no description available
        constexpr uint32_t ESOR = (1U << 4);  ///< End-of-Scan or Out-of-Range Interrupt select
        constexpr uint32_t ERIE = (1U << 5);  ///< Error Interrupt Enable
        constexpr uint32_t TSIIE = (1U << 6);  ///< Touch Sensing Input Interrupt Module Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t SWTS = (1U << 8);  ///< Software Trigger Start
        constexpr uint32_t SCNIP = (1U << 9);  ///< Scan In Progress status
        constexpr uint32_t OVRF = (1U << 12);  ///< Overrun error Flag. This flag is set when a scan trigger occurs while a scan is still in progress. Write "1", when this flag is set, to clear it..
        constexpr uint32_t EXTERF = (1U << 13);  ///< External Electrode error occurred
        constexpr uint32_t OUTRGF = (1U << 14);  ///< Out of Range Flag.
        constexpr uint32_t EOSF = (1U << 15);  ///< End of Scan Flag.
        constexpr uint32_t PS = (3 << 16);  ///< Electrode Oscillator prescaler. .
        constexpr uint32_t NSCN = (5 << 19);  ///< Number of Consecutive Scans per Electrode electrode.
    }

    /// SCANC Register bits
    namespace scanc_bits {
        constexpr uint32_t AMPSC = (3 << 0);  ///< Active Mode Prescaler
        constexpr uint32_t AMCLKS = (2 << 3);  ///< Active Mode Clock Source
        constexpr uint32_t RESERVED = (1U << 27);  ///< no description available
        constexpr uint32_t SMOD = (8 << 8);  ///< Scan Module
        constexpr uint32_t EXTCHRG = (3 << 16);  ///< External OSC Charge Current select
        constexpr uint32_t DVOLT = (2 << 20);  ///< no description available
        constexpr uint32_t REFCHRG = (3 << 24);  ///< Ref OSC Charge Current select
        constexpr uint32_t RW = (4 << 28);  ///< R/W
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN0 = (1U << 0);  ///< Touch Sensing Input Pin Enable Register 0
        constexpr uint32_t PEN1 = (1U << 1);  ///< Touch Sensing Input Pin Enable Register 1
        constexpr uint32_t PEN2 = (1U << 2);  ///< Touch Sensing Input Pin Enable Register 2
        constexpr uint32_t PEN3 = (1U << 3);  ///< Touch Sensing Input Pin Enable Register 3
        constexpr uint32_t PEN4 = (1U << 4);  ///< Touch Sensing Input Pin Enable Register 4
        constexpr uint32_t PEN5 = (1U << 5);  ///< Touch Sensing Input Pin Enable Register 5
        constexpr uint32_t PEN6 = (1U << 6);  ///< Touch Sensing Input Pin Enable Register 6
        constexpr uint32_t PEN7 = (1U << 7);  ///< Touch Sensing Input Pin Enable Register 7
        constexpr uint32_t PEN8 = (1U << 8);  ///< Touch Sensing Input Pin Enable Register 8
        constexpr uint32_t PEN9 = (1U << 9);  ///< Touch Sensing Input Pin Enable Register 9
        constexpr uint32_t PEN10 = (1U << 10);  ///< Touch Sensing Input Pin Enable Register 10
        constexpr uint32_t PEN11 = (1U << 11);  ///< Touch Sensing Input Pin Enable Register 11
        constexpr uint32_t PEN12 = (1U << 12);  ///< Touch Sensing Input Pin Enable Register 12
        constexpr uint32_t PEN13 = (1U << 13);  ///< Touch Sensing Input Pin Enable Register 13
        constexpr uint32_t PEN14 = (1U << 14);  ///< Touch Sensing Input Pin Enable Register 14
        constexpr uint32_t PEN15 = (1U << 15);  ///< Touch Sensing Input Pin Enable Register 15
        constexpr uint32_t LPSP = (4 << 16);  ///< Low Power Scan Pin
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
    }

    /// CNTR%s Register bits
    namespace cntr%s_bits {
        constexpr uint32_t CNTN1 = (16 << 0);  ///< TouchSensing Channel n-1 16-bit counter value
        constexpr uint32_t CNTN = (16 << 16);  ///< TouchSensing Channel n 16-bit counter value
    }

    /// THRESHOLD Register bits
    namespace threshold_bits {
        constexpr uint32_t HTHH = (16 << 0);  ///< Touch Sensing Channel High Threshold value
        constexpr uint32_t LTHH = (16 << 16);  ///< Touch Sensing Channel Low Threshold value
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40032000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT2;  ///< Offset: 0x04 - System Options Register 2
        volatile uint32_t SOPT3;  ///< Offset: 0x08 - System Options Register 3
        volatile uint32_t SOPT4;  ///< Offset: 0x0C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x10 - System Options Register 5
        volatile uint32_t SOPT6;  ///< Offset: 0x14 - System Options Register 6
        volatile uint32_t SOPT7;  ///< Offset: 0x18 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x24 - System Device Identification Register
        volatile uint32_t SCGC5;  ///< Offset: 0x38 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x3C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x40 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x44 - System Clock Divider Register 1
        volatile uint32_t UIDH;  ///< Offset: 0x54 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x58 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x5C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x60 - Unique Identification Register Low
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t FLLENSTOP4 = (1U << 0);  ///< no description available
        constexpr uint32_t RESETIFE = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (2 << 30);  ///< no description available
        constexpr uint32_t OBEPADSELA13 = (2 << 4);  ///< no description available
        constexpr uint32_t OBEPADSELA12 = (2 << 6);  ///< no description available
        constexpr uint32_t OBEPADSELA3 = (2 << 8);  ///< no description available
        constexpr uint32_t OBEPADSELA2 = (2 << 10);  ///< no description available
        constexpr uint32_t OBEPADSELE1 = (2 << 12);  ///< no description available
        constexpr uint32_t OBEPADSELE0 = (2 << 14);  ///< no description available
        constexpr uint32_t FBSL = (2 << 16);  ///< FlexBus security level
        constexpr uint32_t TRACECLKSEL = (1U << 18);  ///< Debug trace clock select
        constexpr uint32_t RAMSIZE = (1U << 21);  ///< The RAM size in the device.
        constexpr uint32_t FSIZE = (2 << 26);  ///< The flash size of the device.
        constexpr uint32_t TSIEN = (1U << 28);  ///< no description available
        constexpr uint32_t MAXCLK = (1U << 29);  ///< no description available
    }

    /// SOPT3 Register bits
    namespace sopt3_bits {
        constexpr uint32_t FTM0_PDB = (4 << 0);  ///< no description available
        constexpr uint32_t FTM1_PDB = (4 << 4);  ///< no description available
        constexpr uint32_t FTM2_PDB = (4 << 8);  ///< no description available
        constexpr uint32_t FTM3_PDB = (4 << 12);  ///< no description available
        constexpr uint32_t FTM_SYNC0 = (1U << 16);  ///< no description available
        constexpr uint32_t FTM_SYNC1 = (1U << 17);  ///< no description available
        constexpr uint32_t FTM_SYNC2 = (1U << 18);  ///< no description available
        constexpr uint32_t FTM_SYNC3 = (1U << 19);  ///< no description available
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM0FLT2 = (1U << 2);  ///< FTM0 Fault 2 Select
        constexpr uint32_t FTM0FLT3 = (1U << 3);  ///< FTM0 Fault 3 Select
        constexpr uint32_t RESERVED = (4 << 28);  ///< no description available
        constexpr uint32_t FTM3FLT0 = (1U << 12);  ///< FTM3 Fault 0 Select
        constexpr uint32_t FTM3FLT1 = (1U << 13);  ///< FTM3 Fault 1 Select
        constexpr uint32_t FTM3FLT2 = (1U << 14);  ///< FTM3 Fault 2 Select
        constexpr uint32_t FTM3FLT3 = (1U << 15);  ///< FTM3 Fault 3 Select
        constexpr uint32_t FTM1CH0SRC = (2 << 20);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM2CH0SRC = (2 << 22);  ///< FTM2 channel 0 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (1U << 26);  ///< FlexTimer 2 External Clock Pin Select
        constexpr uint32_t FTM3CLKSEL = (1U << 27);  ///< FlexTimer 3 External Clock Pin Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (2 << 0);  ///< UART 0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART 0 receive data source select
        constexpr uint32_t UART1TXSRC = (2 << 4);  ///< UART 1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART 1 receive data source select
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

    /// SOPT6 Register bits
    namespace sopt6_bits {
        constexpr uint32_t CLKDIV = (3 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
        constexpr uint32_t CLKOS = (4 << 4);  ///< Clock source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC1TRGSEL = (4 << 4);  ///< ADC1 trigger select
        constexpr uint32_t ADC2TRGSEL = (4 << 8);  ///< ADC2 trigger select
        constexpr uint32_t ADC3TRGSEL = (4 << 12);  ///< ADC3 trigger select
        constexpr uint32_t CMP0WS = (2 << 16);  ///< CMP0 windows select
        constexpr uint32_t CMP1WS = (2 << 18);  ///< CMP1 windows select
        constexpr uint32_t CMP2WS = (2 << 20);  ///< CMP2 windows select
        constexpr uint32_t CMP3WS = (2 << 22);  ///< CMP3 windows select
        constexpr uint32_t RESERVED = (4 << 24);  ///< no description available
        constexpr uint32_t ADC0ALTTRGEN = (1U << 28);  ///< ADC0 alternate trigger enable
        constexpr uint32_t ADC1ALTTRGEN = (1U << 29);  ///< ADC1 alternate trigger enable
        constexpr uint32_t ADC2ALTTRGEN = (1U << 30);  ///< ADC2 alternate trigger enable
        constexpr uint32_t ADC3ALTTRGEN = (1U << 31);  ///< ADC3 alternate trigger enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t BOID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t DIEID = (2 << 4);  ///< Device family identification
        constexpr uint32_t RESERVED = (16 << 16);  ///< no description available
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t RESERVED = (12 << 20);  ///< no description available
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t IIC0 = (1U << 7);  ///< IIC0 Clock Gate Control
        constexpr uint32_t IIC1 = (1U << 8);  ///< IIC1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 9);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 10);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 11);  ///< UART2 Clock Gate Control
        constexpr uint32_t UART3 = (1U << 12);  ///< UART3 Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 14);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 15);  ///< SPI1 Clock Gate Control
        constexpr uint32_t ACMP0 = (1U << 16);  ///< ACMP0 Clock Gate Control
        constexpr uint32_t ACMP1 = (1U << 17);  ///< ACMP1 Clock Gate Control
        constexpr uint32_t ACMP2 = (1U << 18);  ///< ACMP2 Clock Gate Control
        constexpr uint32_t ACMP3 = (1U << 19);  ///< ACMP3 Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMAMUX Clock Gate Control
        constexpr uint32_t PIT = (1U << 3);  ///< PIT Clock Gate Control
        constexpr uint32_t CRC = (1U << 4);  ///< CRC Clock Gate Control
        constexpr uint32_t PDB0 = (1U << 5);  ///< PDB0 Clock Gate Control
        constexpr uint32_t PDB1 = (1U << 6);  ///< PDB1 Clock Gate Control
        constexpr uint32_t PDB2 = (1U << 7);  ///< PDB2 Clock Gate Control
        constexpr uint32_t PDB3 = (1U << 8);  ///< PDB3 Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 9);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 10);  ///< FTM1 Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 11);  ///< FTM2 Clock Gate Control
        constexpr uint32_t FTM3 = (1U << 12);  ///< FTM3 Clock Gate Control
        constexpr uint32_t RTC = (1U << 13);  ///< RTC Clock Gate Control
        constexpr uint32_t TSI = (1U << 16);  ///< TSI Clock Gate Control
        constexpr uint32_t PORTA = (1U << 19);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 20);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 21);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 22);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 23);  ///< Port E Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t ADC1 = (1U << 28);  ///< ADC1 Clock Gate Control
        constexpr uint32_t ADC2 = (1U << 29);  ///< ADC2 Clock Gate Control
        constexpr uint32_t ADC3 = (1U << 30);  ///< ADC3 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus Clock Gate Control
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU Clock Gate Control
        constexpr uint32_t IEVT = (1U << 3);  ///< IEVT Clock Gate Control
        constexpr uint32_t RESERVED = (28 << 4);  ///< no description available
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t RESERVED = (2 << 30);  ///< no description available
        constexpr uint32_t OUTDIV5 = (2 << 12);  ///< Clock 5 output divider value
        constexpr uint32_t OUTDIV4 = (2 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (2 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (2 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (2 << 28);  ///< Clock 1 output divider value
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification (bits [63:32]
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40033000;
    constexpr uint32_t PORTB_BASE = 0x40034000;
    constexpr uint32_t PORTC_BASE = 0x40035000;
    constexpr uint32_t PORTD_BASE = 0x40036000;
    constexpr uint32_t PORTE_BASE = 0x40037000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR%s;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
        volatile uint32_t DFER;  ///< Offset: 0xC0 - Digital Filter Enable Register
        volatile uint32_t DFCR;  ///< Offset: 0xC4 - Digital Filter Clock Register
        volatile uint32_t DFWR;  ///< Offset: 0xC8 - Digital Filter Width Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);

    // Bit definitions
    /// PCR%s Register bits
    namespace pcr%s_bits {
        constexpr uint32_t RESERVED = (7 << 25);  ///< no description available
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

    /// DFER Register bits
    namespace dfer_bits {
        constexpr uint32_t DFE = (32 << 0);  ///< Digital Filter Enable
    }

    /// DFCR Register bits
    namespace dfcr_bits {
        constexpr uint32_t CS = (1U << 0);  ///< Clock Source
        constexpr uint32_t RESERVED = (31 << 1);  ///< no description available
    }

    /// DFWR Register bits
    namespace dfwr_bits {
        constexpr uint32_t FILT = (5 << 0);  ///< Filter Length
        constexpr uint32_t RESERVED = (27 << 5);  ///< no description available
    }

}

// ============================================================================
// FTMRA Peripheral
// ============================================================================

namespace ftmra {
    /// Base addresses
    constexpr uint32_t FTMRA_BASE = 0x40039000;

    /// FTMRA Register structure
    struct Registers {
        volatile uint32_t FSEC;  ///< Offset: 0x00 - Flash Security Register
        volatile uint32_t FCLKDIV;  ///< Offset: 0x01 - Flash Clock Divider Register
        volatile uint32_t FECCRIX;  ///< Offset: 0x02 - Flash ECCR Index Register
        volatile uint32_t FCCOBIX;  ///< Offset: 0x03 - Flash Common Command Object Index Register
        volatile uint32_t FERCNFG;  ///< Offset: 0x04 - Flash Error Configuration Register
        volatile uint32_t FCNFG;  ///< Offset: 0x05 - Flash Configuration Register
        volatile uint32_t FERSTAT;  ///< Offset: 0x06 - Flash Error Status Register
        volatile uint32_t FSTAT;  ///< Offset: 0x07 - Flash Status Register
        volatile uint32_t DFPROT;  ///< Offset: 0x08 - D-Flash Protection Register
        volatile uint32_t FPROT;  ///< Offset: 0x09 - P-Flash Protection Register
        volatile uint32_t FCCOBLO;  ///< Offset: 0x0A - Flash Common Command Object Low Register
        volatile uint32_t FCCOBHI;  ///< Offset: 0x0B - Flash Common Command Object High Register
        volatile uint32_t FECCRLO;  ///< Offset: 0x0E - Flash ECC Error Results Low Register
        volatile uint32_t FECCRHI;  ///< Offset: 0x0F - Flash ECC Error Results High Register
        volatile uint32_t FOPT;  ///< Offset: 0x11 - Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTMRA = reinterpret_cast<Registers*>(FTMRA_BASE);

    // Bit definitions
    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t RNV = (4 << 2);  ///< Reserved Nonvolatile Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FCLKDIV Register bits
    namespace fclkdiv_bits {
        constexpr uint32_t FDIV = (7 << 0);  ///< Clock Divider Bits
        constexpr uint32_t FDIVLD = (1U << 7);  ///< Clock Divider Loaded
    }

    /// FECCRIX Register bits
    namespace feccrix_bits {
        constexpr uint32_t ECCRIX = (3 << 0);  ///< ECC Error Register Index
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// FCCOBIX Register bits
    namespace fccobix_bits {
        constexpr uint32_t CCOBIX = (3 << 0);  ///< Common Command Register Index
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// FERCNFG Register bits
    namespace fercnfg_bits {
        constexpr uint32_t SFDIE = (1U << 0);  ///< Single Bit Fault Detect Interrupt Enable
        constexpr uint32_t DFDIE = (1U << 1);  ///< Double Bit Fault Detect Interrupt Enable
        constexpr uint32_t RESERVED = (6 << 2);  ///< no description available
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t FSFD = (1U << 0);  ///< Force Single Bit Fault Detect
        constexpr uint32_t FDFD = (1U << 1);  ///< Force Double Bit Fault Detect
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t IGNSF = (1U << 4);  ///< Ignore Single Bit Fault
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FERSTAT Register bits
    namespace ferstat_bits {
        constexpr uint32_t SFDIF = (1U << 0);  ///< Single Bit Fault Detect Interrupt Flag
        constexpr uint32_t DFDIF = (1U << 1);  ///< Double Bit Fault Detect Interrupt Flag
        constexpr uint32_t RESERVED = (6 << 2);  ///< no description available
    }

    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT = (2 << 0);  ///< MGATE Command Completion Status Flag
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t MGBUSY = (1U << 3);  ///< MGATE Busy Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// DFPROT Register bits
    namespace dfprot_bits {
        constexpr uint32_t DPS = (5 << 0);  ///< EraseD-Flash Protection Size
        constexpr uint32_t RESERVED = (2 << 5);  ///< no description available
        constexpr uint32_t DPOPEN = (1U << 7);  ///< D-Flash Protection Control
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t FPLS = (2 << 0);  ///< Flash Protection Lower Address Size
        constexpr uint32_t FPLDIS = (1U << 2);  ///< Flash Protection Lower Address Range Disable
        constexpr uint32_t FPHS = (2 << 3);  ///< Flash Protection Higher Address Size
        constexpr uint32_t FPHDIS = (1U << 5);  ///< Flash Protection Higher Address Range Disable
        constexpr uint32_t RNV = (1U << 6);  ///< Reserved Nonvolatile Bit
        constexpr uint32_t FPOPEN = (1U << 7);  ///< Flash Protection Operation Enable
    }

    /// FCCOBLO Register bits
    namespace fccoblo_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< no description available
    }

    /// FCCOBHI Register bits
    namespace fccobhi_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< no description available
    }

    /// FECCRLO Register bits
    namespace feccrlo_bits {
        constexpr uint32_t ECCR = (8 << 0);  ///< no description available
    }

    /// FECCRHI Register bits
    namespace feccrhi_bits {
        constexpr uint32_t ECCR = (8 << 0);  ///< no description available
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t NV = (8 << 0);  ///< Nonvolatile Bits
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x4003A000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< no description available
        constexpr uint32_t CLKSRC = (1U << 1);  ///< no description available
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< no description available
        constexpr uint32_t WINEN = (1U << 3);  ///< no description available
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< no description available
        constexpr uint32_t DBGEN = (1U << 5);  ///< no description available
        constexpr uint32_t STOPEN = (1U << 6);  ///< no description available
        constexpr uint32_t WAITEN = (1U << 7);  ///< no description available
        constexpr uint32_t STNDBYEN = (1U << 8);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 15);  ///< no description available
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< no description available
        constexpr uint32_t TESTSEL = (1U << 11);  ///< no description available
        constexpr uint32_t BYTESEL = (2 << 12);  ///< no description available
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< no description available
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t RESERVED = (15 << 0);  ///< no description available
        constexpr uint32_t INTFLG = (1U << 15);  ///< no description available
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< no description available
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< no description available
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< no description available
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< no description available
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< no description available
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< no description available
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< no description available
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< no description available
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< no description available
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t RESERVED = (5 << 11);  ///< no description available
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< no description available
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x4003C000;
    constexpr uint32_t ADC2_BASE = 0x4003D000;
    constexpr uint32_t ADC3_BASE = 0x4003E000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - Status and Control Register 1
        volatile uint32_t SC2;  ///< Offset: 0x02 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x04 - Status and Control Register 3
        volatile uint32_t SC4;  ///< Offset: 0x06 - Status and Control Register 4
        volatile uint32_t R;  ///< Offset: 0x08 - Conversion Result Register
        volatile uint32_t CVA;  ///< Offset: 0x0A - Compare Value Register A
        volatile uint32_t CVB;  ///< Offset: 0x0C - Compare Value Register B
        volatile uint32_t APCTL;  ///< Offset: 0x0E - Pin Control Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC3 = reinterpret_cast<Registers*>(ADC3_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input Channel Select
        constexpr uint32_t ADCO = (1U << 5);  ///< Continuous Conversion Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
        constexpr uint32_t FFULL = (1U << 2);  ///< Result FIFO full
        constexpr uint32_t FEMPTY = (1U << 3);  ///< Result FIFO empty
        constexpr uint32_t ACDSEL = (1U << 4);  ///< Compare Data Selection
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion Mode Selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Long Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
    }

    /// SC4 Register bits
    namespace sc4_bits {
        constexpr uint32_t AFDEP = (3 << 0);  ///< no description available
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
        constexpr uint32_t ACFSEL = (1U << 5);  ///< no description available
        constexpr uint32_t ASCANE = (1U << 6);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t ADR = (16 << 0);  ///< Conversion Result
    }

    /// CVA Register bits
    namespace cva_bits {
        constexpr uint32_t VA = (16 << 0);  ///< Lower limit compare value
    }

    /// CVB Register bits
    namespace cvb_bits {
        constexpr uint32_t VB = (16 << 0);  ///< Upper limit compare value
    }

    /// APCTL Register bits
    namespace apctl_bits {
        constexpr uint32_t ADPC0 = (1U << 0);  ///< ADC Pin Control 0
        constexpr uint32_t ADPC1 = (1U << 1);  ///< ADC Pin Control 1
        constexpr uint32_t ADPC2 = (1U << 2);  ///< ADC Pin Control 2
        constexpr uint32_t ADPC3 = (1U << 3);  ///< ADC Pin Control 3
        constexpr uint32_t ADPC4 = (1U << 4);  ///< ADC Pin Control 4
        constexpr uint32_t ADPC5 = (1U << 5);  ///< ADC Pin Control 5
        constexpr uint32_t ADPC6 = (1U << 6);  ///< ADC Pin Control 6
        constexpr uint32_t ADPC7 = (1U << 7);  ///< ADC Pin Control 7
        constexpr uint32_t ADPC8 = (1U << 8);  ///< ADC Pin Control 8
        constexpr uint32_t ADPC9 = (1U << 9);  ///< ADC Pin Control 9
        constexpr uint32_t ADPC10 = (1U << 10);  ///< ADC Pin Control 10
        constexpr uint32_t ADPC11 = (1U << 11);  ///< ADC Pin Control 11
        constexpr uint32_t RESERVED = (4 << 12);  ///< no description available
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40041000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< no description available
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< no description available
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40042000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access Register
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t RESERVED = (5 << 0);  ///< no description available
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< no description available
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< no description available
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< no description available
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< no description available
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t RESERVED = (7 << 1);  ///< no description available
    }

}

// ============================================================================
// ICS Peripheral
// ============================================================================

namespace ics {
    /// Base addresses
    constexpr uint32_t ICS_BASE = 0x40044000;

    /// ICS Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - ICS Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x01 - ICS Control Register 2
        volatile uint32_t C3;  ///< Offset: 0x02 - ICS Control Register 3
        volatile uint32_t C4;  ///< Offset: 0x03 - ICS Control Register 4
        volatile uint32_t S;  ///< Offset: 0x04 - ICS Status Register
    };

    /// Peripheral instances
    inline Registers* ICS = reinterpret_cast<Registers*>(ICS_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t RDIV = (3 << 3);  ///< Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t RESERVED = (2 << 0);  ///< no description available
        constexpr uint32_t FRDIV = (2 << 2);  ///< Fine Reference Divider
        constexpr uint32_t LP = (1U << 4);  ///< Low Power Select
        constexpr uint32_t BDIV = (3 << 5);  ///< Bus Frequency Divider
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t RESERVED = (4 << 1);  ///< no description available
        constexpr uint32_t CME = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t RLOLIE = (1U << 6);  ///< Loss of Rough Lock Interrupt Enable
        constexpr uint32_t FLOLIE = (1U << 7);  ///< Loss of Fine Lock Interrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RESERVED = (2 << 0);  ///< no description available
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t RLOCK = (1U << 5);  ///< Rough Lock Status
        constexpr uint32_t FLOCK = (1U << 6);  ///< Fine Lock Status
        constexpr uint32_t LOLS = (1U << 7);  ///< Loss of Lock Status
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40045000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OSCINIT = (1U << 0);  ///< OSC Initialization
        constexpr uint32_t HGO = (1U << 1);  ///< High Gain Oscillator Select
        constexpr uint32_t RESERVED = (1U << 6);  ///< no description available
        constexpr uint32_t OSCOS = (1U << 4);  ///< OSC Output Select
        constexpr uint32_t OSCSTEN = (1U << 5);  ///< OSC Enable in Stop mode
        constexpr uint32_t OSCEN = (1U << 7);  ///< OSC Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40047000;
    constexpr uint32_t I2C1_BASE = 0x40048000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t RESERVED = (1U << 0);  ///< no description available
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< no description available
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (5 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STOPIE = (1U << 5);  ///< I2C Bus Stop Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RESERVED = (1U << 0);  ///< no description available
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t RESERVED = (1U << 0);  ///< no description available
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40049000;
    constexpr uint32_t UART1_BASE = 0x4004A000;
    constexpr uint32_t UART2_BASE = 0x4004B000;
    constexpr uint32_t UART3_BASE = 0x4004C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt or DMA Request Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt DMA Transfer Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt or DMA Transfer Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 3);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< no description available
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RESERVED = (3 << 0);  ///< no description available
        constexpr uint32_t LBKDDMAS = (1U << 3);  ///< LIN Break Detect DMA Select Bit
        constexpr uint32_t ILDMAS = (1U << 4);  ///< Idle Line DMA Select
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TCDMAS = (1U << 6);  ///< Transmission Complete DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t RESERVED = (6 << 0);  ///< no description available
        constexpr uint32_t PARITYE = (1U << 6);  ///< no description available
        constexpr uint32_t NOISY = (1U << 7);  ///< no description available
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t RESERVED = (4 << 4);  ///< no description available
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXOFE = (1U << 2);  ///< Receive FIFO Overflow Interrupt Enable
        constexpr uint32_t RESERVED = (3 << 3);  ///< no description available
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXOF = (1U << 2);  ///< Receiver Buffer Overflow Flag
        constexpr uint32_t RESERVED = (3 << 3);  ///< no description available
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4004E000;
    constexpr uint32_t SPI1_BASE = 0x4004F000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - SPI control register 1
        volatile uint32_t C2;  ///< Offset: 0x01 - SPI control register 2
        volatile uint32_t BR;  ///< Offset: 0x02 - SPI baud rate register
        volatile uint32_t S;  ///< Offset: 0x03 - SPI status register
        volatile uint32_t DH;  ///< Offset: 0x04 - SPI data register high
        volatile uint32_t DL;  ///< Offset: 0x05 - SPI data register low
        volatile uint32_t MH;  ///< Offset: 0x06 - SPI match register high
        volatile uint32_t ML;  ///< Offset: 0x07 - SPI match register low
        volatile uint32_t C3;  ///< Offset: 0x08 - SPI control register 3
        volatile uint32_t CI;  ///< Offset: 0x09 - SPI clear interrupt register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t LSBFE = (1U << 0);  ///< LSB first (shifter direction)
        constexpr uint32_t SSOE = (1U << 1);  ///< Slave select output enable
        constexpr uint32_t CPHA = (1U << 2);  ///< Clock phase
        constexpr uint32_t CPOL = (1U << 3);  ///< Clock polarity
        constexpr uint32_t MSTR = (1U << 4);  ///< Master/slave mode select
        constexpr uint32_t SPTIE = (1U << 5);  ///< SPI transmit interrupt enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI system enable
        constexpr uint32_t SPIE = (1U << 7);  ///< SPI interrupt enable: for SPRF and MODF (when FIFO is not supported or not enabled) or for read FIFO (when FIFO is supported and enabled)
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SPC0 = (1U << 0);  ///< SPI pin control 0
        constexpr uint32_t SPISWAI = (1U << 1);  ///< SPI stop in wait mode
        constexpr uint32_t RXDMAE = (1U << 2);  ///< Receive DMA enable
        constexpr uint32_t BIDIROE = (1U << 3);  ///< Bidirectional mode output enable
        constexpr uint32_t MODFEN = (1U << 4);  ///< Master mode-fault function enable
        constexpr uint32_t TXDMAE = (1U << 5);  ///< Transmit DMA enable
        constexpr uint32_t SPIMODE = (1U << 6);  ///< SPI 8-bit or 16-bit mode
        constexpr uint32_t SPMIE = (1U << 7);  ///< SPI match interrupt enable
    }

    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t SPR = (4 << 0);  ///< SPI baud rate divisor
        constexpr uint32_t SPPR = (3 << 4);  ///< SPI baud rate prescale divisor
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RFIFOEF = (1U << 0);  ///< SPI read FIFO empty flag
        constexpr uint32_t TXFULLF = (1U << 1);  ///< Transmit FIFO full flag
        constexpr uint32_t TNEAREF = (1U << 2);  ///< Transmit FIFO nearly empty flag
        constexpr uint32_t RNFULLF = (1U << 3);  ///< Receive FIFO nearly full flag
        constexpr uint32_t MODF = (1U << 4);  ///< Master mode fault flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI transmit buffer empty flag (when FIFO is not supported or not enabled) or SPI transmit FIFO empty flag (when FIFO is supported and enabled)
        constexpr uint32_t SPMF = (1U << 6);  ///< SPI match flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI read buffer full flag (when FIFO is not supported or not enabled) or SPI read FIFO FULL flag (when FIFO is supported and enabled)
    }

    /// DH Register bits
    namespace dh_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (high byte)
    }

    /// DL Register bits
    namespace dl_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (low byte)
    }

    /// MH Register bits
    namespace mh_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (high byte)
    }

    /// ML Register bits
    namespace ml_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (low byte)
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t FIFOMODE = (1U << 0);  ///< FIFO mode enable
        constexpr uint32_t RNFULLIEN = (1U << 1);  ///< Receive FIFO nearly full interrupt enable
        constexpr uint32_t TNEARIEN = (1U << 2);  ///< Transmit FIFO nearly empty interrupt enable
        constexpr uint32_t INTCLR = (1U << 3);  ///< Interrupt clearing mechanism select
        constexpr uint32_t RNFULLF_MARK = (1U << 4);  ///< Receive FIFO nearly full watermark
        constexpr uint32_t TNEAREF_MARK = (1U << 5);  ///< Transmit FIFO nearly empty watermark
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
    }

    /// CI Register bits
    namespace ci_bits {
        constexpr uint32_t SPRFCI = (1U << 0);  ///< Receive FIFO full flag clear interrupt
        constexpr uint32_t SPTEFCI = (1U << 1);  ///< Transmit FIFO empty flag clear interrupt
        constexpr uint32_t RNFULLFCI = (1U << 2);  ///< Receive FIFO nearly full flag clear interrupt
        constexpr uint32_t TNEAREFCI = (1U << 3);  ///< Transmit FIFO nearly empty flag clear interrupt
        constexpr uint32_t RXFOF = (1U << 4);  ///< Receive FIFO overflow flag
        constexpr uint32_t TXFOF = (1U << 5);  ///< Transmit FIFO overflow flag
        constexpr uint32_t RXFERR = (1U << 6);  ///< Receive FIFO error flag
        constexpr uint32_t TXFERR = (1U << 7);  ///< Transmit FIFO error flag
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40050000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
        volatile uint32_t MUXPE;  ///< Offset: 0x06 - MUX Pin Enable Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (1U << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (2 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t PSEL = (2 << 4);  ///< Plus Input MUX Control
    }

    /// MUXPE Register bits
    namespace muxpe_bits {
        constexpr uint32_t INPE = (3 << 0);  ///< Positive Input Pin Enable
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40051000;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
        volatile uint32_t MUXPE;  ///< Offset: 0x06 - MUX Pin Enable Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (1U << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (2 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t PSEL = (2 << 4);  ///< Plus Input MUX Control
    }

    /// MUXPE Register bits
    namespace muxpe_bits {
        constexpr uint32_t INPE = (3 << 0);  ///< Positive Input Pin Enable
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40052000;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
        volatile uint32_t MUXPE;  ///< Offset: 0x06 - MUX Pin Enable Register
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (1U << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (2 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t PSEL = (2 << 4);  ///< Plus Input MUX Control
    }

    /// MUXPE Register bits
    namespace muxpe_bits {
        constexpr uint32_t INPE = (3 << 0);  ///< Positive Input Pin Enable
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

}

// ============================================================================
// CMP3 Peripheral
// ============================================================================

namespace cmp3 {
    /// Base addresses
    constexpr uint32_t CMP3_BASE = 0x40053000;

    /// CMP3 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
        volatile uint32_t MUXPE;  ///< Offset: 0x06 - MUX Pin Enable Register
    };

    /// Peripheral instances
    inline Registers* CMP3 = reinterpret_cast<Registers*>(CMP3_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (1U << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t RESERVED = (1U << 5);  ///< no description available
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (2 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t PSEL = (2 << 4);  ///< Plus Input MUX Control
    }

    /// MUXPE Register bits
    namespace muxpe_bits {
        constexpr uint32_t INPE = (3 << 0);  ///< Positive Input Pin Enable
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x40054000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t SPMSC1;  ///< Offset: 0x00 - System Power Management Status and Control 1 Register
        volatile uint32_t SPMSC2;  ///< Offset: 0x01 - System Power Management Status and Control 2 Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// SPMSC1 Register bits
    namespace spmsc1_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t BGBDS = (1U << 1);  ///< Bandgap Buffer Drive Select
        constexpr uint32_t LVDE = (1U << 2);  ///< Low-Voltage Detect Enable
        constexpr uint32_t LVDSE = (1U << 3);  ///< Low-Voltage Detect Stop Enable
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// SPMSC2 Register bits
    namespace spmsc2_bits {
        constexpr uint32_t RESERVED = (1U << 7);  ///< no description available
        constexpr uint32_t LVWV = (2 << 4);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVDV = (1U << 6);  ///< Low-Voltage Detect Voltage Select
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x40056000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - SMC Power Mode Protection Register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - SMC Power Mode Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - SMC Power Mode Status Register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very Low Power Stop Mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RESERVED = (3 << 5);  ///< no description available
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t RUN = (1U << 0);  ///< CurrCurrent Power mode is run
        constexpr uint32_t STOP = (1U << 1);  ///< Current Power mode is STOP
        constexpr uint32_t RESERVED = (3 << 5);  ///< no description available
        constexpr uint32_t VLPS = (1U << 4);  ///< Current Power mode is VLPS
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x40057000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRSL;  ///< Offset: 0x00 - RCM System Reset Status Low Register
        volatile uint32_t SRSH;  ///< Offset: 0x01 - RCM System Reset Status High Register
        volatile uint32_t RPFC;  ///< Offset: 0x04 - RCM RESETb Pin Filter Control Register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - RCM RESETb Pin Filter Width Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRSL Register bits
    namespace srsl_bits {
        constexpr uint32_t RESERVED = (2 << 3);  ///< no description available
        constexpr uint32_t LVD = (1U << 1);  ///< Low Voltage Detect
        constexpr uint32_t LOC = (1U << 2);  ///< Loss Of Clock Reset
        constexpr uint32_t COP = (1U << 5);  ///< COP Watchdog Reset
        constexpr uint32_t PIN = (1U << 6);  ///< External RESETb Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power On Reset
    }

    /// SRSH Register bits
    namespace srsh_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG Reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< CPU LOCKUP Reset
        constexpr uint32_t SW = (1U << 2);  ///< Software Reset
        constexpr uint32_t MDMAP = (1U << 3);  ///< MDM-AP system reset request
        constexpr uint32_t RESERVED = (2 << 6);  ///< no description available
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Modes
        constexpr uint32_t RESERVED = (5 << 3);  ///< no description available
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSS = (5 << 0);  ///< RESETb Pin bus clock filter width
        constexpr uint32_t RESERVED = (3 << 5);  ///< no description available
    }

}

// ============================================================================
// PTA Peripheral
// ============================================================================

namespace pta {
    /// Base addresses
    constexpr uint32_t PTA_BASE = 0x4007F000;

    /// PTA Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTA = reinterpret_cast<Registers*>(PTA_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port Data Direction
    }

}

// ============================================================================
// PTB Peripheral
// ============================================================================

namespace ptb {
    /// Base addresses
    constexpr uint32_t PTB_BASE = 0x4007F040;

    /// PTB Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTB = reinterpret_cast<Registers*>(PTB_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port Data Direction
    }

}

// ============================================================================
// PTC Peripheral
// ============================================================================

namespace ptc {
    /// Base addresses
    constexpr uint32_t PTC_BASE = 0x4007F080;

    /// PTC Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTC = reinterpret_cast<Registers*>(PTC_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port Data Direction
    }

}

// ============================================================================
// PTD Peripheral
// ============================================================================

namespace ptd {
    /// Base addresses
    constexpr uint32_t PTD_BASE = 0x4007F0C0;

    /// PTD Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTD = reinterpret_cast<Registers*>(PTD_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port Data Direction
    }

}

// ============================================================================
// PTE Peripheral
// ============================================================================

namespace pte {
    /// Base addresses
    constexpr uint32_t PTE_BASE = 0x4007F100;

    /// PTE Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTE = reinterpret_cast<Registers*>(PTE_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port Data Direction
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register,
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Registers
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disables interruption of multi-cycle instructions.
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disables write buffer use during default memory map accesses.
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disables folding of IT instructions.
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Indicates patch release: 0x0 = Patch 0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Indicates part number
        constexpr uint32_t RESERVED = (1U << 19);  ///< (Constant) Reads as 1
        constexpr uint32_t VARIANT = (4 << 20);  ///< Indicates processor revision: 0x2 = Revision 2
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RESERVED = (1U << 30);  ///< Reserved
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< no description available
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< no description available
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< no description available
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< no description available
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< no description available
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< no description available
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< no description available
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< no description available
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t RESERVED = (1U << 6);  ///< Reserved
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< no description available
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< no description available
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 14);  ///< Reserved
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< no description available
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< no description available
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< no description available
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< no description available
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< no description available
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to the STIR
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t RESERVED = (1U << 23);  ///< Reserved
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t RESERVED = (1U << 15);  ///< Reserved
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< no description available
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< no description available
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< no description available
        constexpr uint32_t MONITORACT = (1U << 8);  ///< no description available
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< no description available
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< no description available
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< no description available
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< no description available
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< no description available
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< no description available
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< no description available
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< no description available
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< no description available
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< no description available
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< no description available
        constexpr uint32_t MSTKERR = (1U << 4);  ///< no description available
        constexpr uint32_t MLSPERR = (1U << 5);  ///< no description available
        constexpr uint32_t MMARVALID = (1U << 7);  ///< no description available
        constexpr uint32_t IBUSERR = (1U << 8);  ///< no description available
        constexpr uint32_t PRECISERR = (1U << 9);  ///< no description available
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< no description available
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< no description available
        constexpr uint32_t STKERR = (1U << 12);  ///< no description available
        constexpr uint32_t LSPERR = (1U << 13);  ///< no description available
        constexpr uint32_t BFARVALID = (1U << 15);  ///< no description available
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< no description available
        constexpr uint32_t INVSTATE = (1U << 17);  ///< no description available
        constexpr uint32_t INVPC = (1U << 18);  ///< no description available
        constexpr uint32_t NOCP = (1U << 19);  ///< no description available
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< no description available
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< no description available
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t RESERVED = (1U << 29);  ///< Reserved
        constexpr uint32_t VECTTBL = (1U << 1);  ///< no description available
        constexpr uint32_t FORCED = (1U << 30);  ///< no description available
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< no description available
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< no description available
        constexpr uint32_t BKPT = (1U << 1);  ///< no description available
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< no description available
        constexpr uint32_t VCATCH = (1U << 3);  ///< no description available
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 31);  ///< Reserved
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of MemManage fault location
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of the BusFault location
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AUXFAULT = (32 << 0);  ///< Latched version of the AUXFAULT inputs
    }

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick Control and Status Register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick Reload Value Register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick Current Value Register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< no description available
        constexpr uint32_t TICKINT = (1U << 1);  ///< no description available
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< no description available
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< no description available
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the SysTick Current Value Register when the counter reaches 0
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current value at the time the register is accessed
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Reload value to use for 10ms timing
        constexpr uint32_t RESERVED = (1U << 29);  ///< no description available
        constexpr uint32_t SKEW = (1U << 30);  ///< no description available
        constexpr uint32_t NOREF = (1U << 31);  ///< no description available
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t NVICISER0;  ///< Offset: 0x00 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER1;  ///< Offset: 0x04 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER2;  ///< Offset: 0x08 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER3;  ///< Offset: 0x0C - Interrupt Set Enable Register n
        volatile uint32_t NVICICER0;  ///< Offset: 0x80 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER1;  ///< Offset: 0x84 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER2;  ///< Offset: 0x88 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER3;  ///< Offset: 0x8C - Interrupt Clear Enable Register n
        volatile uint32_t NVICISPR0;  ///< Offset: 0x100 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR1;  ///< Offset: 0x104 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR2;  ///< Offset: 0x108 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR3;  ///< Offset: 0x10C - Interrupt Set Pending Register n
        volatile uint32_t NVICICPR0;  ///< Offset: 0x180 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR1;  ///< Offset: 0x184 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR2;  ///< Offset: 0x188 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR3;  ///< Offset: 0x18C - Interrupt Clear Pending Register n
        volatile uint32_t NVICIABR0;  ///< Offset: 0x200 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR1;  ///< Offset: 0x204 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR2;  ///< Offset: 0x208 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR3;  ///< Offset: 0x20C - Interrupt Active bit Register n
        volatile uint32_t NVICIP0;  ///< Offset: 0x300 - Interrupt Priority Register n
        volatile uint32_t NVICIP1;  ///< Offset: 0x301 - Interrupt Priority Register n
        volatile uint32_t NVICIP2;  ///< Offset: 0x302 - Interrupt Priority Register n
        volatile uint32_t NVICIP3;  ///< Offset: 0x303 - Interrupt Priority Register n
        volatile uint32_t NVICIP4;  ///< Offset: 0x304 - Interrupt Priority Register n
        volatile uint32_t NVICIP5;  ///< Offset: 0x305 - Interrupt Priority Register n
        volatile uint32_t NVICIP6;  ///< Offset: 0x306 - Interrupt Priority Register n
        volatile uint32_t NVICIP7;  ///< Offset: 0x307 - Interrupt Priority Register n
        volatile uint32_t NVICIP8;  ///< Offset: 0x308 - Interrupt Priority Register n
        volatile uint32_t NVICIP9;  ///< Offset: 0x309 - Interrupt Priority Register n
        volatile uint32_t NVICIP10;  ///< Offset: 0x30A - Interrupt Priority Register n
        volatile uint32_t NVICIP11;  ///< Offset: 0x30B - Interrupt Priority Register n
        volatile uint32_t NVICIP12;  ///< Offset: 0x30C - Interrupt Priority Register n
        volatile uint32_t NVICIP13;  ///< Offset: 0x30D - Interrupt Priority Register n
        volatile uint32_t NVICIP14;  ///< Offset: 0x30E - Interrupt Priority Register n
        volatile uint32_t NVICIP15;  ///< Offset: 0x30F - Interrupt Priority Register n
        volatile uint32_t NVICIP16;  ///< Offset: 0x310 - Interrupt Priority Register n
        volatile uint32_t NVICIP17;  ///< Offset: 0x311 - Interrupt Priority Register n
        volatile uint32_t NVICIP18;  ///< Offset: 0x312 - Interrupt Priority Register n
        volatile uint32_t NVICIP19;  ///< Offset: 0x313 - Interrupt Priority Register n
        volatile uint32_t NVICIP20;  ///< Offset: 0x314 - Interrupt Priority Register n
        volatile uint32_t NVICIP21;  ///< Offset: 0x315 - Interrupt Priority Register n
        volatile uint32_t NVICIP22;  ///< Offset: 0x316 - Interrupt Priority Register n
        volatile uint32_t NVICIP23;  ///< Offset: 0x317 - Interrupt Priority Register n
        volatile uint32_t NVICIP24;  ///< Offset: 0x318 - Interrupt Priority Register n
        volatile uint32_t NVICIP25;  ///< Offset: 0x319 - Interrupt Priority Register n
        volatile uint32_t NVICIP26;  ///< Offset: 0x31A - Interrupt Priority Register n
        volatile uint32_t NVICIP27;  ///< Offset: 0x31B - Interrupt Priority Register n
        volatile uint32_t NVICIP28;  ///< Offset: 0x31C - Interrupt Priority Register n
        volatile uint32_t NVICIP29;  ///< Offset: 0x31D - Interrupt Priority Register n
        volatile uint32_t NVICIP30;  ///< Offset: 0x31E - Interrupt Priority Register n
        volatile uint32_t NVICIP31;  ///< Offset: 0x31F - Interrupt Priority Register n
        volatile uint32_t NVICIP32;  ///< Offset: 0x320 - Interrupt Priority Register n
        volatile uint32_t NVICIP33;  ///< Offset: 0x321 - Interrupt Priority Register n
        volatile uint32_t NVICIP34;  ///< Offset: 0x322 - Interrupt Priority Register n
        volatile uint32_t NVICIP35;  ///< Offset: 0x323 - Interrupt Priority Register n
        volatile uint32_t NVICIP36;  ///< Offset: 0x324 - Interrupt Priority Register n
        volatile uint32_t NVICIP37;  ///< Offset: 0x325 - Interrupt Priority Register n
        volatile uint32_t NVICIP38;  ///< Offset: 0x326 - Interrupt Priority Register n
        volatile uint32_t NVICIP39;  ///< Offset: 0x327 - Interrupt Priority Register n
        volatile uint32_t NVICIP40;  ///< Offset: 0x328 - Interrupt Priority Register n
        volatile uint32_t NVICIP41;  ///< Offset: 0x329 - Interrupt Priority Register n
        volatile uint32_t NVICIP42;  ///< Offset: 0x32A - Interrupt Priority Register n
        volatile uint32_t NVICIP43;  ///< Offset: 0x32B - Interrupt Priority Register n
        volatile uint32_t NVICIP44;  ///< Offset: 0x32C - Interrupt Priority Register n
        volatile uint32_t NVICIP45;  ///< Offset: 0x32D - Interrupt Priority Register n
        volatile uint32_t NVICIP46;  ///< Offset: 0x32E - Interrupt Priority Register n
        volatile uint32_t NVICIP47;  ///< Offset: 0x32F - Interrupt Priority Register n
        volatile uint32_t NVICIP48;  ///< Offset: 0x330 - Interrupt Priority Register n
        volatile uint32_t NVICIP49;  ///< Offset: 0x331 - Interrupt Priority Register n
        volatile uint32_t NVICIP50;  ///< Offset: 0x332 - Interrupt Priority Register n
        volatile uint32_t NVICIP51;  ///< Offset: 0x333 - Interrupt Priority Register n
        volatile uint32_t NVICIP52;  ///< Offset: 0x334 - Interrupt Priority Register n
        volatile uint32_t NVICIP53;  ///< Offset: 0x335 - Interrupt Priority Register n
        volatile uint32_t NVICIP54;  ///< Offset: 0x336 - Interrupt Priority Register n
        volatile uint32_t NVICIP55;  ///< Offset: 0x337 - Interrupt Priority Register n
        volatile uint32_t NVICIP56;  ///< Offset: 0x338 - Interrupt Priority Register n
        volatile uint32_t NVICIP57;  ///< Offset: 0x339 - Interrupt Priority Register n
        volatile uint32_t NVICIP58;  ///< Offset: 0x33A - Interrupt Priority Register n
        volatile uint32_t NVICIP59;  ///< Offset: 0x33B - Interrupt Priority Register n
        volatile uint32_t NVICIP60;  ///< Offset: 0x33C - Interrupt Priority Register n
        volatile uint32_t NVICIP61;  ///< Offset: 0x33D - Interrupt Priority Register n
        volatile uint32_t NVICIP62;  ///< Offset: 0x33E - Interrupt Priority Register n
        volatile uint32_t NVICIP63;  ///< Offset: 0x33F - Interrupt Priority Register n
        volatile uint32_t NVICIP64;  ///< Offset: 0x340 - Interrupt Priority Register n
        volatile uint32_t NVICIP65;  ///< Offset: 0x341 - Interrupt Priority Register n
        volatile uint32_t NVICIP66;  ///< Offset: 0x342 - Interrupt Priority Register n
        volatile uint32_t NVICIP67;  ///< Offset: 0x343 - Interrupt Priority Register n
        volatile uint32_t NVICIP68;  ///< Offset: 0x344 - Interrupt Priority Register n
        volatile uint32_t NVICIP69;  ///< Offset: 0x345 - Interrupt Priority Register n
        volatile uint32_t NVICIP70;  ///< Offset: 0x346 - Interrupt Priority Register n
        volatile uint32_t NVICIP71;  ///< Offset: 0x347 - Interrupt Priority Register n
        volatile uint32_t NVICIP72;  ///< Offset: 0x348 - Interrupt Priority Register n
        volatile uint32_t NVICIP73;  ///< Offset: 0x349 - Interrupt Priority Register n
        volatile uint32_t NVICIP74;  ///< Offset: 0x34A - Interrupt Priority Register n
        volatile uint32_t NVICIP75;  ///< Offset: 0x34B - Interrupt Priority Register n
        volatile uint32_t NVICIP76;  ///< Offset: 0x34C - Interrupt Priority Register n
        volatile uint32_t NVICIP77;  ///< Offset: 0x34D - Interrupt Priority Register n
        volatile uint32_t NVICIP78;  ///< Offset: 0x34E - Interrupt Priority Register n
        volatile uint32_t NVICIP79;  ///< Offset: 0x34F - Interrupt Priority Register n
        volatile uint32_t NVICIP80;  ///< Offset: 0x350 - Interrupt Priority Register n
        volatile uint32_t NVICIP81;  ///< Offset: 0x351 - Interrupt Priority Register n
        volatile uint32_t NVICIP82;  ///< Offset: 0x352 - Interrupt Priority Register n
        volatile uint32_t NVICIP83;  ///< Offset: 0x353 - Interrupt Priority Register n
        volatile uint32_t NVICIP84;  ///< Offset: 0x354 - Interrupt Priority Register n
        volatile uint32_t NVICIP85;  ///< Offset: 0x355 - Interrupt Priority Register n
        volatile uint32_t NVICIP86;  ///< Offset: 0x356 - Interrupt Priority Register n
        volatile uint32_t NVICIP87;  ///< Offset: 0x357 - Interrupt Priority Register n
        volatile uint32_t NVICIP88;  ///< Offset: 0x358 - Interrupt Priority Register n
        volatile uint32_t NVICIP89;  ///< Offset: 0x359 - Interrupt Priority Register n
        volatile uint32_t NVICIP90;  ///< Offset: 0x35A - Interrupt Priority Register n
        volatile uint32_t NVICIP91;  ///< Offset: 0x35B - Interrupt Priority Register n
        volatile uint32_t NVICIP92;  ///< Offset: 0x35C - Interrupt Priority Register n
        volatile uint32_t NVICIP93;  ///< Offset: 0x35D - Interrupt Priority Register n
        volatile uint32_t NVICIP94;  ///< Offset: 0x35E - Interrupt Priority Register n
        volatile uint32_t NVICIP95;  ///< Offset: 0x35F - Interrupt Priority Register n
        volatile uint32_t NVICIP96;  ///< Offset: 0x360 - Interrupt Priority Register n
        volatile uint32_t NVICIP97;  ///< Offset: 0x361 - Interrupt Priority Register n
        volatile uint32_t NVICIP98;  ///< Offset: 0x362 - Interrupt Priority Register n
        volatile uint32_t NVICIP99;  ///< Offset: 0x363 - Interrupt Priority Register n
        volatile uint32_t NVICIP100;  ///< Offset: 0x364 - Interrupt Priority Register n
        volatile uint32_t NVICIP101;  ///< Offset: 0x365 - Interrupt Priority Register n
        volatile uint32_t NVICIP102;  ///< Offset: 0x366 - Interrupt Priority Register n
        volatile uint32_t NVICIP103;  ///< Offset: 0x367 - Interrupt Priority Register n
        volatile uint32_t NVICIP104;  ///< Offset: 0x368 - Interrupt Priority Register n
        volatile uint32_t NVICIP105;  ///< Offset: 0x369 - Interrupt Priority Register n
        volatile uint32_t NVICSTIR;  ///< Offset: 0xE00 - Software Trigger Interrupt Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// NVICISER0 Register bits
    namespace nviciser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER1 Register bits
    namespace nviciser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER2 Register bits
    namespace nviciser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER3 Register bits
    namespace nviciser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICICER0 Register bits
    namespace nvicicer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER1 Register bits
    namespace nvicicer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER2 Register bits
    namespace nvicicer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER3 Register bits
    namespace nvicicer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICISPR0 Register bits
    namespace nvicispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR1 Register bits
    namespace nvicispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR2 Register bits
    namespace nvicispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR3 Register bits
    namespace nvicispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICICPR0 Register bits
    namespace nvicicpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR1 Register bits
    namespace nvicicpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR2 Register bits
    namespace nvicicpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR3 Register bits
    namespace nvicicpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICIABR0 Register bits
    namespace nviciabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR1 Register bits
    namespace nviciabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR2 Register bits
    namespace nviciabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR3 Register bits
    namespace nviciabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIP0 Register bits
    namespace nvicip0_bits {
        constexpr uint32_t PRI0 = (8 << 0);  ///< Priority of interrupt 0
    }

    /// NVICIP1 Register bits
    namespace nvicip1_bits {
        constexpr uint32_t PRI1 = (8 << 0);  ///< Priority of interrupt 1
    }

    /// NVICIP2 Register bits
    namespace nvicip2_bits {
        constexpr uint32_t PRI2 = (8 << 0);  ///< Priority of interrupt 2
    }

    /// NVICIP3 Register bits
    namespace nvicip3_bits {
        constexpr uint32_t PRI3 = (8 << 0);  ///< Priority of interrupt 3
    }

    /// NVICIP4 Register bits
    namespace nvicip4_bits {
        constexpr uint32_t PRI4 = (8 << 0);  ///< Priority of interrupt 4
    }

    /// NVICIP5 Register bits
    namespace nvicip5_bits {
        constexpr uint32_t PRI5 = (8 << 0);  ///< Priority of interrupt 5
    }

    /// NVICIP6 Register bits
    namespace nvicip6_bits {
        constexpr uint32_t PRI6 = (8 << 0);  ///< Priority of interrupt 6
    }

    /// NVICIP7 Register bits
    namespace nvicip7_bits {
        constexpr uint32_t PRI7 = (8 << 0);  ///< Priority of interrupt 7
    }

    /// NVICIP8 Register bits
    namespace nvicip8_bits {
        constexpr uint32_t PRI8 = (8 << 0);  ///< Priority of interrupt 8
    }

    /// NVICIP9 Register bits
    namespace nvicip9_bits {
        constexpr uint32_t PRI9 = (8 << 0);  ///< Priority of interrupt 9
    }

    /// NVICIP10 Register bits
    namespace nvicip10_bits {
        constexpr uint32_t PRI10 = (8 << 0);  ///< Priority of interrupt 10
    }

    /// NVICIP11 Register bits
    namespace nvicip11_bits {
        constexpr uint32_t PRI11 = (8 << 0);  ///< Priority of interrupt 11
    }

    /// NVICIP12 Register bits
    namespace nvicip12_bits {
        constexpr uint32_t PRI12 = (8 << 0);  ///< Priority of interrupt 12
    }

    /// NVICIP13 Register bits
    namespace nvicip13_bits {
        constexpr uint32_t PRI13 = (8 << 0);  ///< Priority of interrupt 13
    }

    /// NVICIP14 Register bits
    namespace nvicip14_bits {
        constexpr uint32_t PRI14 = (8 << 0);  ///< Priority of interrupt 14
    }

    /// NVICIP15 Register bits
    namespace nvicip15_bits {
        constexpr uint32_t PRI15 = (8 << 0);  ///< Priority of interrupt 15
    }

    /// NVICIP16 Register bits
    namespace nvicip16_bits {
        constexpr uint32_t PRI16 = (8 << 0);  ///< Priority of interrupt 16
    }

    /// NVICIP17 Register bits
    namespace nvicip17_bits {
        constexpr uint32_t PRI17 = (8 << 0);  ///< Priority of interrupt 17
    }

    /// NVICIP18 Register bits
    namespace nvicip18_bits {
        constexpr uint32_t PRI18 = (8 << 0);  ///< Priority of interrupt 18
    }

    /// NVICIP19 Register bits
    namespace nvicip19_bits {
        constexpr uint32_t PRI19 = (8 << 0);  ///< Priority of interrupt 19
    }

    /// NVICIP20 Register bits
    namespace nvicip20_bits {
        constexpr uint32_t PRI20 = (8 << 0);  ///< Priority of interrupt 20
    }

    /// NVICIP21 Register bits
    namespace nvicip21_bits {
        constexpr uint32_t PRI21 = (8 << 0);  ///< Priority of interrupt 21
    }

    /// NVICIP22 Register bits
    namespace nvicip22_bits {
        constexpr uint32_t PRI22 = (8 << 0);  ///< Priority of interrupt 22
    }

    /// NVICIP23 Register bits
    namespace nvicip23_bits {
        constexpr uint32_t PRI23 = (8 << 0);  ///< Priority of interrupt 23
    }

    /// NVICIP24 Register bits
    namespace nvicip24_bits {
        constexpr uint32_t PRI24 = (8 << 0);  ///< Priority of interrupt 24
    }

    /// NVICIP25 Register bits
    namespace nvicip25_bits {
        constexpr uint32_t PRI25 = (8 << 0);  ///< Priority of interrupt 25
    }

    /// NVICIP26 Register bits
    namespace nvicip26_bits {
        constexpr uint32_t PRI26 = (8 << 0);  ///< Priority of interrupt 26
    }

    /// NVICIP27 Register bits
    namespace nvicip27_bits {
        constexpr uint32_t PRI27 = (8 << 0);  ///< Priority of interrupt 27
    }

    /// NVICIP28 Register bits
    namespace nvicip28_bits {
        constexpr uint32_t PRI28 = (8 << 0);  ///< Priority of interrupt 28
    }

    /// NVICIP29 Register bits
    namespace nvicip29_bits {
        constexpr uint32_t PRI29 = (8 << 0);  ///< Priority of interrupt 29
    }

    /// NVICIP30 Register bits
    namespace nvicip30_bits {
        constexpr uint32_t PRI30 = (8 << 0);  ///< Priority of interrupt 30
    }

    /// NVICIP31 Register bits
    namespace nvicip31_bits {
        constexpr uint32_t PRI31 = (8 << 0);  ///< Priority of interrupt 31
    }

    /// NVICIP32 Register bits
    namespace nvicip32_bits {
        constexpr uint32_t PRI32 = (8 << 0);  ///< Priority of interrupt 32
    }

    /// NVICIP33 Register bits
    namespace nvicip33_bits {
        constexpr uint32_t PRI33 = (8 << 0);  ///< Priority of interrupt 33
    }

    /// NVICIP34 Register bits
    namespace nvicip34_bits {
        constexpr uint32_t PRI34 = (8 << 0);  ///< Priority of interrupt 34
    }

    /// NVICIP35 Register bits
    namespace nvicip35_bits {
        constexpr uint32_t PRI35 = (8 << 0);  ///< Priority of interrupt 35
    }

    /// NVICIP36 Register bits
    namespace nvicip36_bits {
        constexpr uint32_t PRI36 = (8 << 0);  ///< Priority of interrupt 36
    }

    /// NVICIP37 Register bits
    namespace nvicip37_bits {
        constexpr uint32_t PRI37 = (8 << 0);  ///< Priority of interrupt 37
    }

    /// NVICIP38 Register bits
    namespace nvicip38_bits {
        constexpr uint32_t PRI38 = (8 << 0);  ///< Priority of interrupt 38
    }

    /// NVICIP39 Register bits
    namespace nvicip39_bits {
        constexpr uint32_t PRI39 = (8 << 0);  ///< Priority of interrupt 39
    }

    /// NVICIP40 Register bits
    namespace nvicip40_bits {
        constexpr uint32_t PRI40 = (8 << 0);  ///< Priority of interrupt 40
    }

    /// NVICIP41 Register bits
    namespace nvicip41_bits {
        constexpr uint32_t PRI41 = (8 << 0);  ///< Priority of interrupt 41
    }

    /// NVICIP42 Register bits
    namespace nvicip42_bits {
        constexpr uint32_t PRI42 = (8 << 0);  ///< Priority of interrupt 42
    }

    /// NVICIP43 Register bits
    namespace nvicip43_bits {
        constexpr uint32_t PRI43 = (8 << 0);  ///< Priority of interrupt 43
    }

    /// NVICIP44 Register bits
    namespace nvicip44_bits {
        constexpr uint32_t PRI44 = (8 << 0);  ///< Priority of interrupt 44
    }

    /// NVICIP45 Register bits
    namespace nvicip45_bits {
        constexpr uint32_t PRI45 = (8 << 0);  ///< Priority of interrupt 45
    }

    /// NVICIP46 Register bits
    namespace nvicip46_bits {
        constexpr uint32_t PRI46 = (8 << 0);  ///< Priority of interrupt 46
    }

    /// NVICIP47 Register bits
    namespace nvicip47_bits {
        constexpr uint32_t PRI47 = (8 << 0);  ///< Priority of interrupt 47
    }

    /// NVICIP48 Register bits
    namespace nvicip48_bits {
        constexpr uint32_t PRI48 = (8 << 0);  ///< Priority of interrupt 48
    }

    /// NVICIP49 Register bits
    namespace nvicip49_bits {
        constexpr uint32_t PRI49 = (8 << 0);  ///< Priority of interrupt 49
    }

    /// NVICIP50 Register bits
    namespace nvicip50_bits {
        constexpr uint32_t PRI50 = (8 << 0);  ///< Priority of interrupt 50
    }

    /// NVICIP51 Register bits
    namespace nvicip51_bits {
        constexpr uint32_t PRI51 = (8 << 0);  ///< Priority of interrupt 51
    }

    /// NVICIP52 Register bits
    namespace nvicip52_bits {
        constexpr uint32_t PRI52 = (8 << 0);  ///< Priority of interrupt 52
    }

    /// NVICIP53 Register bits
    namespace nvicip53_bits {
        constexpr uint32_t PRI53 = (8 << 0);  ///< Priority of interrupt 53
    }

    /// NVICIP54 Register bits
    namespace nvicip54_bits {
        constexpr uint32_t PRI54 = (8 << 0);  ///< Priority of interrupt 54
    }

    /// NVICIP55 Register bits
    namespace nvicip55_bits {
        constexpr uint32_t PRI55 = (8 << 0);  ///< Priority of interrupt 55
    }

    /// NVICIP56 Register bits
    namespace nvicip56_bits {
        constexpr uint32_t PRI56 = (8 << 0);  ///< Priority of interrupt 56
    }

    /// NVICIP57 Register bits
    namespace nvicip57_bits {
        constexpr uint32_t PRI57 = (8 << 0);  ///< Priority of interrupt 57
    }

    /// NVICIP58 Register bits
    namespace nvicip58_bits {
        constexpr uint32_t PRI58 = (8 << 0);  ///< Priority of interrupt 58
    }

    /// NVICIP59 Register bits
    namespace nvicip59_bits {
        constexpr uint32_t PRI59 = (8 << 0);  ///< Priority of interrupt 59
    }

    /// NVICIP60 Register bits
    namespace nvicip60_bits {
        constexpr uint32_t PRI60 = (8 << 0);  ///< Priority of interrupt 60
    }

    /// NVICIP61 Register bits
    namespace nvicip61_bits {
        constexpr uint32_t PRI61 = (8 << 0);  ///< Priority of interrupt 61
    }

    /// NVICIP62 Register bits
    namespace nvicip62_bits {
        constexpr uint32_t PRI62 = (8 << 0);  ///< Priority of interrupt 62
    }

    /// NVICIP63 Register bits
    namespace nvicip63_bits {
        constexpr uint32_t PRI63 = (8 << 0);  ///< Priority of interrupt 63
    }

    /// NVICIP64 Register bits
    namespace nvicip64_bits {
        constexpr uint32_t PRI64 = (8 << 0);  ///< Priority of interrupt 64
    }

    /// NVICIP65 Register bits
    namespace nvicip65_bits {
        constexpr uint32_t PRI65 = (8 << 0);  ///< Priority of interrupt 65
    }

    /// NVICIP66 Register bits
    namespace nvicip66_bits {
        constexpr uint32_t PRI66 = (8 << 0);  ///< Priority of interrupt 66
    }

    /// NVICIP67 Register bits
    namespace nvicip67_bits {
        constexpr uint32_t PRI67 = (8 << 0);  ///< Priority of interrupt 67
    }

    /// NVICIP68 Register bits
    namespace nvicip68_bits {
        constexpr uint32_t PRI68 = (8 << 0);  ///< Priority of interrupt 68
    }

    /// NVICIP69 Register bits
    namespace nvicip69_bits {
        constexpr uint32_t PRI69 = (8 << 0);  ///< Priority of interrupt 69
    }

    /// NVICIP70 Register bits
    namespace nvicip70_bits {
        constexpr uint32_t PRI70 = (8 << 0);  ///< Priority of interrupt 70
    }

    /// NVICIP71 Register bits
    namespace nvicip71_bits {
        constexpr uint32_t PRI71 = (8 << 0);  ///< Priority of interrupt 71
    }

    /// NVICIP72 Register bits
    namespace nvicip72_bits {
        constexpr uint32_t PRI72 = (8 << 0);  ///< Priority of interrupt 72
    }

    /// NVICIP73 Register bits
    namespace nvicip73_bits {
        constexpr uint32_t PRI73 = (8 << 0);  ///< Priority of interrupt 73
    }

    /// NVICIP74 Register bits
    namespace nvicip74_bits {
        constexpr uint32_t PRI74 = (8 << 0);  ///< Priority of interrupt 74
    }

    /// NVICIP75 Register bits
    namespace nvicip75_bits {
        constexpr uint32_t PRI75 = (8 << 0);  ///< Priority of interrupt 75
    }

    /// NVICIP76 Register bits
    namespace nvicip76_bits {
        constexpr uint32_t PRI76 = (8 << 0);  ///< Priority of interrupt 76
    }

    /// NVICIP77 Register bits
    namespace nvicip77_bits {
        constexpr uint32_t PRI77 = (8 << 0);  ///< Priority of interrupt 77
    }

    /// NVICIP78 Register bits
    namespace nvicip78_bits {
        constexpr uint32_t PRI78 = (8 << 0);  ///< Priority of interrupt 78
    }

    /// NVICIP79 Register bits
    namespace nvicip79_bits {
        constexpr uint32_t PRI79 = (8 << 0);  ///< Priority of interrupt 79
    }

    /// NVICIP80 Register bits
    namespace nvicip80_bits {
        constexpr uint32_t PRI80 = (8 << 0);  ///< Priority of interrupt 80
    }

    /// NVICIP81 Register bits
    namespace nvicip81_bits {
        constexpr uint32_t PRI81 = (8 << 0);  ///< Priority of interrupt 81
    }

    /// NVICIP82 Register bits
    namespace nvicip82_bits {
        constexpr uint32_t PRI82 = (8 << 0);  ///< Priority of interrupt 82
    }

    /// NVICIP83 Register bits
    namespace nvicip83_bits {
        constexpr uint32_t PRI83 = (8 << 0);  ///< Priority of interrupt 83
    }

    /// NVICIP84 Register bits
    namespace nvicip84_bits {
        constexpr uint32_t PRI84 = (8 << 0);  ///< Priority of interrupt 84
    }

    /// NVICIP85 Register bits
    namespace nvicip85_bits {
        constexpr uint32_t PRI85 = (8 << 0);  ///< Priority of interrupt 85
    }

    /// NVICIP86 Register bits
    namespace nvicip86_bits {
        constexpr uint32_t PRI86 = (8 << 0);  ///< Priority of interrupt 86
    }

    /// NVICIP87 Register bits
    namespace nvicip87_bits {
        constexpr uint32_t PRI87 = (8 << 0);  ///< Priority of interrupt 87
    }

    /// NVICIP88 Register bits
    namespace nvicip88_bits {
        constexpr uint32_t PRI88 = (8 << 0);  ///< Priority of interrupt 88
    }

    /// NVICIP89 Register bits
    namespace nvicip89_bits {
        constexpr uint32_t PRI89 = (8 << 0);  ///< Priority of interrupt 89
    }

    /// NVICIP90 Register bits
    namespace nvicip90_bits {
        constexpr uint32_t PRI90 = (8 << 0);  ///< Priority of interrupt 90
    }

    /// NVICIP91 Register bits
    namespace nvicip91_bits {
        constexpr uint32_t PRI91 = (8 << 0);  ///< Priority of interrupt 91
    }

    /// NVICIP92 Register bits
    namespace nvicip92_bits {
        constexpr uint32_t PRI92 = (8 << 0);  ///< Priority of interrupt 92
    }

    /// NVICIP93 Register bits
    namespace nvicip93_bits {
        constexpr uint32_t PRI93 = (8 << 0);  ///< Priority of interrupt 93
    }

    /// NVICIP94 Register bits
    namespace nvicip94_bits {
        constexpr uint32_t PRI94 = (8 << 0);  ///< Priority of interrupt 94
    }

    /// NVICIP95 Register bits
    namespace nvicip95_bits {
        constexpr uint32_t PRI95 = (8 << 0);  ///< Priority of interrupt 95
    }

    /// NVICIP96 Register bits
    namespace nvicip96_bits {
        constexpr uint32_t PRI96 = (8 << 0);  ///< Priority of interrupt 96
    }

    /// NVICIP97 Register bits
    namespace nvicip97_bits {
        constexpr uint32_t PRI97 = (8 << 0);  ///< Priority of interrupt 97
    }

    /// NVICIP98 Register bits
    namespace nvicip98_bits {
        constexpr uint32_t PRI98 = (8 << 0);  ///< Priority of interrupt 98
    }

    /// NVICIP99 Register bits
    namespace nvicip99_bits {
        constexpr uint32_t PRI99 = (8 << 0);  ///< Priority of interrupt 99
    }

    /// NVICIP100 Register bits
    namespace nvicip100_bits {
        constexpr uint32_t PRI100 = (8 << 0);  ///< Priority of interrupt 100
    }

    /// NVICIP101 Register bits
    namespace nvicip101_bits {
        constexpr uint32_t PRI101 = (8 << 0);  ///< Priority of interrupt 101
    }

    /// NVICIP102 Register bits
    namespace nvicip102_bits {
        constexpr uint32_t PRI102 = (8 << 0);  ///< Priority of interrupt 102
    }

    /// NVICIP103 Register bits
    namespace nvicip103_bits {
        constexpr uint32_t PRI103 = (8 << 0);  ///< Priority of interrupt 103
    }

    /// NVICIP104 Register bits
    namespace nvicip104_bits {
        constexpr uint32_t PRI104 = (8 << 0);  ///< Priority of interrupt 104
    }

    /// NVICIP105 Register bits
    namespace nvicip105_bits {
        constexpr uint32_t PRI105 = (8 << 0);  ///< Priority of interrupt 105
    }

    /// NVICSTIR Register bits
    namespace nvicstir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t CR;  ///< Offset: 0x0C - Control Register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
        constexpr uint32_t RESERVED = (8 << 8);  ///< no description available
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESERVED = (1U << 31);  ///< no description available
        constexpr uint32_t CBRR = (1U << 9);  ///< Crossbar round-robin arbitration enable
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L Write Protect
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID And M1_PID For MPU
        constexpr uint32_t RESERVED = (24 << 8);  ///< no description available
    }

}


} // namespace alloy::generated::mke15d7

#endif // ALLOY_GENERATED_MKE15D7_PERIPHERALS_HPP