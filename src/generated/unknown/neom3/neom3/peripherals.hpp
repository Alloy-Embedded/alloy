/// Auto-generated code for NeoM3
/// Generated by Alloy Code Generator
/// Source: nxp_lpc178x.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:50
#ifndef ALLOY_GENERATED_NEOM3_PERIPHERALS_HPP
#define ALLOY_GENERATED_NEOM3_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::neom3 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_emc = true;
    constexpr uint32_t num_emc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 4;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 5;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 3;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_iocon = true;
    constexpr uint32_t num_iocon_instances = 1;
    constexpr bool has_ssp1 = true;
    constexpr uint32_t num_ssp1_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 5;
    constexpr bool has_ssp0 = true;
    constexpr uint32_t num_ssp0_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_ssp2 = true;
    constexpr uint32_t num_ssp2_instances = 1;
    constexpr bool has_qei = true;
    constexpr uint32_t num_qei_instances = 1;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 1;
    constexpr bool has_syscon = true;
    constexpr uint32_t num_syscon_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct emc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct iocon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ssp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ssp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct qei_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct syscon_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASHCTRL_BASE = 0x00200000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FMSSTART;  ///< Offset: 0x20 - Signature start address register
        volatile uint32_t FMSSTOP;  ///< Offset: 0x24 - Signature stop-address register
        volatile uint32_t FMSW0;  ///< Offset: 0x2C - 128-bit signature Word 0
        volatile uint32_t FMSW1;  ///< Offset: 0x30 - 128-bit signature Word 1
        volatile uint32_t FMSW2;  ///< Offset: 0x34 - 128-bit signature Word 2
        volatile uint32_t FMSW3;  ///< Offset: 0x38 - 128-bit signature Word 3
        volatile uint32_t EECMD;  ///< Offset: 0x80 - EEPROM command register
        volatile uint32_t EEWDATA;  ///< Offset: 0x88 - EEPROM write data register
        volatile uint32_t EERDATA;  ///< Offset: 0x8C - EEPROM read data register
        volatile uint32_t EEWSTATE;  ///< Offset: 0x90 - EEPROM wait state register
        volatile uint32_t EECLKDIV;  ///< Offset: 0x94 - EEPROM clock divider register
        volatile uint32_t EEPWRDWN;  ///< Offset: 0x98 - EEPROM power-down register
        volatile uint32_t STAT;  ///< Offset: 0xFE0 - Signature generation status register
        volatile uint32_t INTEN;  ///< Offset: 0xFE4 - EEPROM interrupt enable
        volatile uint32_t STATCLR;  ///< Offset: 0xFE8 - Signature generation status clear register
        volatile uint32_t ENCLR;  ///< Offset: 0xFD8 - EEPROM interrupt enable clear
        volatile uint32_t ENSET;  ///< Offset: 0xFDC - EEPROM interrupt enable set
    };

    /// Peripheral instances
    inline Registers* FLASHCTRL = reinterpret_cast<Registers*>(FLASHCTRL_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA_BASE = 0x20080000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t INTSTAT;  ///< Offset: 0x00 - DMA Interrupt Status Register
        volatile uint32_t INTTCSTAT;  ///< Offset: 0x04 - DMA Interrupt Terminal Count Request Status Register
        volatile uint32_t INTTCCLEAR;  ///< Offset: 0x08 - DMA Interrupt Terminal Count Request Clear Register
        volatile uint32_t INTERRSTAT;  ///< Offset: 0x0C - DMA Interrupt Error Status Register
        volatile uint32_t INTERRCLR;  ///< Offset: 0x10 - DMA Interrupt Error Clear Register
        volatile uint32_t RAWINTTCSTAT;  ///< Offset: 0x14 - DMA Raw Interrupt Terminal Count Status Register
        volatile uint32_t RAWINTERRSTAT;  ///< Offset: 0x18 - DMA Raw Error Interrupt Status Register
        volatile uint32_t ENBLDCHNS;  ///< Offset: 0x1C - DMA Enabled Channel Register
        volatile uint32_t SOFTBREQ;  ///< Offset: 0x20 - DMA Software Burst Request Register
        volatile uint32_t SOFTSREQ;  ///< Offset: 0x24 - DMA Software Single Request Register
        volatile uint32_t SOFTLBREQ;  ///< Offset: 0x28 - DMA Software Last Burst Request Register
        volatile uint32_t SOFTLSREQ;  ///< Offset: 0x2C - DMA Software Last Single Request Register
        volatile uint32_t CONFIG;  ///< Offset: 0x30 - DMA Configuration Register
        volatile uint32_t SYNC;  ///< Offset: 0x34 - DMA Synchronization Register
        volatile uint32_t SRCADDR%s;  ///< Offset: 0x100 - DMA Channel 0 Source Address Register
        volatile uint32_t DESTADDR%s;  ///< Offset: 0x104 - DMA Channel 0 Destination Address Register
        volatile uint32_t LLI%s;  ///< Offset: 0x108 - DMA Channel 0 Linked List Item Register
        volatile uint32_t CONTROL%s;  ///< Offset: 0x10C - DMA Channel 0 Control Register
        volatile uint32_t CONFIG%s;  ///< Offset: 0x110 - DMA Channel 0 Configuration Register[1]
    };

    /// Peripheral instances
    inline Registers* GPDMA = reinterpret_cast<Registers*>(GPDMA_BASE);

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETHERNET_BASE = 0x20084000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t MAC1;  ///< Offset: 0x00 - MAC configuration register 1.
        volatile uint32_t MAC2;  ///< Offset: 0x04 - MAC configuration register 2.
        volatile uint32_t IPGT;  ///< Offset: 0x08 - Back-to-Back Inter-Packet-Gap register.
        volatile uint32_t IPGR;  ///< Offset: 0x0C - Non Back-to-Back Inter-Packet-Gap register.
        volatile uint32_t CLRT;  ///< Offset: 0x10 - Collision window / Retry register.
        volatile uint32_t MAXF;  ///< Offset: 0x14 - Maximum Frame register.
        volatile uint32_t SUPP;  ///< Offset: 0x18 - PHY Support register.
        volatile uint32_t TEST;  ///< Offset: 0x1C - Test register.
        volatile uint32_t MCFG;  ///< Offset: 0x20 - MII Mgmt Configuration register.
        volatile uint32_t MCMD;  ///< Offset: 0x24 - MII Mgmt Command register.
        volatile uint32_t MADR;  ///< Offset: 0x28 - MII Mgmt Address register.
        volatile uint32_t MWTD;  ///< Offset: 0x2C - MII Mgmt Write Data register.
        volatile uint32_t MRDD;  ///< Offset: 0x30 - MII Mgmt Read Data register.
        volatile uint32_t MIND;  ///< Offset: 0x34 - MII Mgmt Indicators register.
        volatile uint32_t SA0;  ///< Offset: 0x40 - Station Address 0 register.
        volatile uint32_t SA1;  ///< Offset: 0x44 - Station Address 1 register.
        volatile uint32_t SA2;  ///< Offset: 0x48 - Station Address 2 register.
        volatile uint32_t COMMAND;  ///< Offset: 0x100 - Command register.
        volatile uint32_t STATUS;  ///< Offset: 0x104 - Status register.
        volatile uint32_t RXDESCRIPTOR;  ///< Offset: 0x108 - Receive descriptor base address register.
        volatile uint32_t RXSTATUS;  ///< Offset: 0x10C - Receive status base address register.
        volatile uint32_t RXDESCRIPTORNUMBER;  ///< Offset: 0x110 - Receive number of descriptors register.
        volatile uint32_t RXPRODUCEINDEX;  ///< Offset: 0x114 - Receive produce index register.
        volatile uint32_t RXCONSUMEINDEX;  ///< Offset: 0x118 - Receive consume index register.
        volatile uint32_t TXDESCRIPTOR;  ///< Offset: 0x11C - Transmit descriptor base address register.
        volatile uint32_t TXSTATUS;  ///< Offset: 0x120 - Transmit status base address register.
        volatile uint32_t TXDESCRIPTORNUMBER;  ///< Offset: 0x124 - Transmit number of descriptors register.
        volatile uint32_t TXPRODUCEINDEX;  ///< Offset: 0x128 - Transmit produce index register.
        volatile uint32_t TXCONSUMEINDEX;  ///< Offset: 0x12C - Transmit consume index register.
        volatile uint32_t TSV0;  ///< Offset: 0x158 - Transmit status vector 0 register.
        volatile uint32_t TSV1;  ///< Offset: 0x15C - Transmit status vector 1 register.
        volatile uint32_t RSV;  ///< Offset: 0x160 - Receive status vector register.
        volatile uint32_t FLOWCONTROLCOUNTER;  ///< Offset: 0x170 - Flow control counter register.
        volatile uint32_t FLOWCONTROLSTATUS;  ///< Offset: 0x174 - Flow control status register.
        volatile uint32_t RXFILTERCTRL;  ///< Offset: 0x200 - Receive filter control register.
        volatile uint32_t RXFILTERWOLSTATUS;  ///< Offset: 0x204 - Receive filter WoL status register.
        volatile uint32_t RXFILTERWOLCLEAR;  ///< Offset: 0x208 - Receive filter WoL clear register.
        volatile uint32_t HASHFILTERL;  ///< Offset: 0x210 - Hash filter table LSBs register.
        volatile uint32_t HASHFILTERH;  ///< Offset: 0x214 - Hash filter table MSBs register.
        volatile uint32_t INTSTATUS;  ///< Offset: 0xFE0 - Interrupt status register.
        volatile uint32_t INTENABLE;  ///< Offset: 0xFE4 - Interrupt enable register.
        volatile uint32_t INTCLEAR;  ///< Offset: 0xFE8 - Interrupt clear register.
        volatile uint32_t INTSET;  ///< Offset: 0xFEC - Interrupt set register.
        volatile uint32_t POWERDOWN;  ///< Offset: 0xFF4 - Power-down register.
    };

    /// Peripheral instances
    inline Registers* ETHERNET = reinterpret_cast<Registers*>(ETHERNET_BASE);

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x20088000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t TIMH;  ///< Offset: 0x00 - Horizontal Timing Control register
        volatile uint32_t TIMV;  ///< Offset: 0x04 - Vertical Timing Control register
        volatile uint32_t POL;  ///< Offset: 0x08 - Clock and Signal Polarity Control register
        volatile uint32_t LE;  ///< Offset: 0x0C - Line End Control register
        volatile uint32_t UPBASE;  ///< Offset: 0x10 - Upper Panel Frame Base Address register
        volatile uint32_t LPBASE;  ///< Offset: 0x14 - Lower Panel Frame Base Address register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LCD Control register
        volatile uint32_t INTMSK;  ///< Offset: 0x1C - Interrupt Mask register
        volatile uint32_t INTRAW;  ///< Offset: 0x20 - Raw Interrupt Status register
        volatile uint32_t INTSTAT;  ///< Offset: 0x24 - Masked Interrupt Status register
        volatile uint32_t INTCLR;  ///< Offset: 0x28 - Interrupt Clear register
        volatile uint32_t UPCURR;  ///< Offset: 0x2C - Upper Panel Current Address Value register
        volatile uint32_t LPCURR;  ///< Offset: 0x30 - Lower Panel Current Address Value register
        volatile uint32_t PAL[%s];  ///< Offset: 0x200 - 256x16-bit Color Palette registers
        volatile uint32_t CRSR_IMG[%s];  ///< Offset: 0x800 - Cursor Image registers
        volatile uint32_t CRSR_CTRL;  ///< Offset: 0xC00 - Cursor Control register
        volatile uint32_t CRSR_CFG;  ///< Offset: 0xC04 - Cursor Configuration register
        volatile uint32_t CRSR_PAL0;  ///< Offset: 0xC08 - Cursor Palette register 0
        volatile uint32_t CRSR_PAL1;  ///< Offset: 0xC0C - Cursor Palette register 1
        volatile uint32_t CRSR_XY;  ///< Offset: 0xC10 - Cursor XY Position register
        volatile uint32_t CRSR_CLIP;  ///< Offset: 0xC14 - Cursor Clip Position register
        volatile uint32_t CRSR_INTMSK;  ///< Offset: 0xC20 - Cursor Interrupt Mask register
        volatile uint32_t CRSR_INTCLR;  ///< Offset: 0xC24 - Cursor Interrupt Clear register
        volatile uint32_t CRSR_INTRAW;  ///< Offset: 0xC28 - Cursor Raw Interrupt Status register
        volatile uint32_t CRSR_INTSTAT;  ///< Offset: 0xC2C - Cursor Masked Interrupt Status register
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x2008C000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t INTST;  ///< Offset: 0x100 - OTG Interrupt Status
        volatile uint32_t INTEN;  ///< Offset: 0x104 - OTG Interrupt Enable
        volatile uint32_t INTSET;  ///< Offset: 0x108 - OTG Interrupt Set
        volatile uint32_t INTCLR;  ///< Offset: 0x10C - OTG Interrupt Clear
        volatile uint32_t STCTRL;  ///< Offset: 0x110 - OTG Status and Control and USB port select
        volatile uint32_t TMR;  ///< Offset: 0x114 - OTG Timer
        volatile uint32_t DEVINTST;  ///< Offset: 0x200 - USB Device Interrupt Status
        volatile uint32_t DEVINTEN;  ///< Offset: 0x204 - USB Device Interrupt Enable
        volatile uint32_t DEVINTCLR;  ///< Offset: 0x208 - USB Device Interrupt Clear
        volatile uint32_t DEVINTSET;  ///< Offset: 0x20C - USB Device Interrupt Set
        volatile uint32_t CMDCODE;  ///< Offset: 0x210 - USB Command Code
        volatile uint32_t CMDDATA;  ///< Offset: 0x214 - USB Command Data
        volatile uint32_t RXDATA;  ///< Offset: 0x218 - USB Receive Data
        volatile uint32_t TXDATA;  ///< Offset: 0x21C - USB Transmit Data
        volatile uint32_t RXPLEN;  ///< Offset: 0xDC - USB Receive Packet Length
        volatile uint32_t TXPLEN;  ///< Offset: 0x224 - USB Transmit Packet Length
        volatile uint32_t CTRL;  ///< Offset: 0x228 - USB Control
        volatile uint32_t DEVINTPRI;  ///< Offset: 0x22C - USB Device Interrupt Priority
        volatile uint32_t EPINTST;  ///< Offset: 0x230 - USB Endpoint Interrupt Status
        volatile uint32_t EPINTEN;  ///< Offset: 0x234 - USB Endpoint Interrupt Enable
        volatile uint32_t EPINTCLR;  ///< Offset: 0x238 - USB Endpoint Interrupt Clear
        volatile uint32_t EPINTSET;  ///< Offset: 0x23C - USB Endpoint Interrupt Set
        volatile uint32_t EPINTPRI;  ///< Offset: 0x240 - USB Endpoint Priority
        volatile uint32_t REEP;  ///< Offset: 0x244 - USB Realize Endpoint
        volatile uint32_t EPIND;  ///< Offset: 0x248 - USB Endpoint Index
        volatile uint32_t MAXPSIZE;  ///< Offset: 0x24C - USB MaxPacketSize
        volatile uint32_t DMARST;  ///< Offset: 0x250 - USB DMA Request Status
        volatile uint32_t DMARCLR;  ///< Offset: 0x254 - USB DMA Request Clear
        volatile uint32_t DMARSET;  ///< Offset: 0x258 - USB DMA Request Set
        volatile uint32_t UDCAH;  ///< Offset: 0x280 - USB UDCA Head
        volatile uint32_t EPDMAST;  ///< Offset: 0x284 - USB Endpoint DMA Status
        volatile uint32_t EPDMAEN;  ///< Offset: 0x288 - USB Endpoint DMA Enable
        volatile uint32_t EPDMADIS;  ///< Offset: 0x28C - USB Endpoint DMA Disable
        volatile uint32_t DMAINTST;  ///< Offset: 0x290 - USB DMA Interrupt Status
        volatile uint32_t DMAINTEN;  ///< Offset: 0x294 - USB DMA Interrupt Enable
        volatile uint32_t EOTINTST;  ///< Offset: 0x2A0 - USB End of Transfer Interrupt Status
        volatile uint32_t EOTINTCLR;  ///< Offset: 0x2A4 - USB End of Transfer Interrupt Clear
        volatile uint32_t EOTINTSET;  ///< Offset: 0x2A8 - USB End of Transfer Interrupt Set
        volatile uint32_t NDDRINTST;  ///< Offset: 0x2AC - USB New DD Request Interrupt Status
        volatile uint32_t NDDRINTCLR;  ///< Offset: 0x2B0 - USB New DD Request Interrupt Clear
        volatile uint32_t NDDRINTSET;  ///< Offset: 0x2B4 - USB New DD Request Interrupt Set
        volatile uint32_t SYSERRINTST;  ///< Offset: 0x2B8 - USB System Error Interrupt Status
        volatile uint32_t SYSERRINTCLR;  ///< Offset: 0x2BC - USB System Error Interrupt Clear
        volatile uint32_t SYSERRINTSET;  ///< Offset: 0x2C0 - USB System Error Interrupt Set
        volatile uint32_t I2C_RX;  ///< Offset: 0x300 - I2C Receive
        volatile uint32_t I2C_WO;  ///< Offset: 0x300 - I2C Transmit
        volatile uint32_t I2C_STS;  ///< Offset: 0x304 - I2C Status
        volatile uint32_t I2C_CTL;  ///< Offset: 0x308 - I2C Control
        volatile uint32_t I2C_CLKHI;  ///< Offset: 0x30C - I2C Clock High
        volatile uint32_t I2C_CLKLO;  ///< Offset: 0x310 - I2C Clock Low
        volatile uint32_t USBCLKCTRL;  ///< Offset: 0xFF4 - USB Clock Control
        volatile uint32_t OTGCLKCTRL;  ///< Offset: 0xFF4 - OTG clock controller
        volatile uint32_t USBCLKST;  ///< Offset: 0xFF8 - USB Clock Status
        volatile uint32_t OTGCLKST;  ///< Offset: 0xFF8 - OTG clock status
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x20090000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - CRC mode register
        volatile uint32_t SEED;  ///< Offset: 0x04 - CRC seed register
        volatile uint32_t SUM;  ///< Offset: 0x08 - CRC checksum register
        volatile uint32_t DATA;  ///< Offset: 0x08 - CRC data register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x20098000;
    constexpr uint32_t GPIOINT_BASE = 0x40028080;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DIR%s;  ///< Offset: 0x00 - GPIO Port0 Direction control register.
        volatile uint32_t MASK%s;  ///< Offset: 0x10 - Mask register for Port0.
        volatile uint32_t PIN%s;  ///< Offset: 0x14 - Port0 Pin value register using FIOMASK.
        volatile uint32_t SET%s;  ///< Offset: 0x18 - Port0 Output Set register using FIOMASK.
        volatile uint32_t CLR%s;  ///< Offset: 0x1C - Port0 Output Clear register using FIOMASK.
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIOINT = reinterpret_cast<Registers*>(GPIOINT_BASE);

}

// ============================================================================
// EMC Peripheral
// ============================================================================

namespace emc {
    /// Base addresses
    constexpr uint32_t EMC_BASE = 0x2009C000;

    /// EMC Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Controls operation of the memory controller.
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Provides EMC status information.
        volatile uint32_t CONFIG;  ///< Offset: 0x08 - Configures operation of the memory controller
        volatile uint32_t DYNAMICCONTROL;  ///< Offset: 0x20 - Controls dynamic memory operation.
        volatile uint32_t DYNAMICREFRESH;  ///< Offset: 0x24 - Configures dynamic memory refresh.
        volatile uint32_t DYNAMICREADCONFIG;  ///< Offset: 0x28 - Configures dynamic memory read strategy.
        volatile uint32_t DYNAMICRP;  ///< Offset: 0x30 - Precharge command period.
        volatile uint32_t DYNAMICRAS;  ///< Offset: 0x34 - Active to precharge command period.
        volatile uint32_t DYNAMICSREX;  ///< Offset: 0x38 - Self-refresh exit time.
        volatile uint32_t DYNAMICAPR;  ///< Offset: 0x3C - Last-data-out to active command time.
        volatile uint32_t DYNAMICDAL;  ///< Offset: 0x40 - Data-in to active command time.
        volatile uint32_t DYNAMICWR;  ///< Offset: 0x44 - Write recovery time.
        volatile uint32_t DYNAMICRC;  ///< Offset: 0x48 - Selects the active to active command period.
        volatile uint32_t DYNAMICRFC;  ///< Offset: 0x4C - Selects the auto-refresh period.
        volatile uint32_t DYNAMICXSR;  ///< Offset: 0x50 - Time for exit self-refresh to active command.
        volatile uint32_t DYNAMICRRD;  ///< Offset: 0x54 - Latency for active bank A to active bank B.
        volatile uint32_t DYNAMICMRD;  ///< Offset: 0x58 - Time for load mode register to active command.
        volatile uint32_t STATICEXTENDEDWAIT;  ///< Offset: 0x80 - Time for long static memory read and write transfers.
        volatile uint32_t DYNAMICCONFIG%s;  ///< Offset: 0x100 - Configuration information for EMC_DYCS0.
        volatile uint32_t DYNAMICRASCAS%s;  ///< Offset: 0x104 - RAS and CAS latencies for EMC_DYCS0.
        volatile uint32_t STATICCONFIG%s;  ///< Offset: 0x200 - Configuration for EMC_CS0.
        volatile uint32_t STATICWAITWEN%s;  ///< Offset: 0x204 - Delay from EMC_CS0 to write enable.
        volatile uint32_t STATICWAITOEN%s;  ///< Offset: 0x208 - Delay from EMC_CS0 or address change, whichever is...
        volatile uint32_t STATICWAITRD%s;  ///< Offset: 0x20C - Delay from EMC_CS0 to a read access.
        volatile uint32_t STATICWAITPAGE%s;  ///< Offset: 0x210 - Delay for asynchronous page mode sequential accesses for EMC_CS0.
        volatile uint32_t STATICWAITWR%s;  ///< Offset: 0x214 - Delay from EMC_CS0 to a write access.
        volatile uint32_t STATICWAITTURN%s;  ///< Offset: 0x218 - Number of bus turnaround cycles EMC_CS0.
    };

    /// Peripheral instances
    inline Registers* EMC = reinterpret_cast<Registers*>(EMC_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WWDT_BASE = 0x40000000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t MOD;  ///< Offset: 0x00 - Watchdog mode register. This register determines the...
        volatile uint32_t TC;  ///< Offset: 0x04 - Watchdog timer constant register. The value in this...
        volatile uint32_t FEED;  ///< Offset: 0x08 - Watchdog feed sequence register. Writing 0xAA followed...
        volatile uint32_t TV;  ///< Offset: 0x0C - Watchdog timer value register. This register reads out...
        volatile uint32_t WARNINT;  ///< Offset: 0x14 - Watchdog Warning Interrupt compare value.
        volatile uint32_t WINDOW;  ///< Offset: 0x18 - Watchdog Window compare value.
    };

    /// Peripheral instances
    inline Registers* WWDT = reinterpret_cast<Registers*>(WWDT_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40004000;
    constexpr uint32_t TIMER1_BASE = 0x40008000;
    constexpr uint32_t TIMER2_BASE = 0x40090000;
    constexpr uint32_t TIMER3_BASE = 0x40094000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32 bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. When the Prescale Counter (PC) is...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. The 32 bit PC is a counter which is...
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control if an...
        volatile uint32_t MR[%s];  ///< Offset: 0x18 - Match Register 0. MR0 can be enabled through the MCR to...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR[%s];  ///< Offset: 0x2C - Capture Register 0. CR0 is loaded with the value of TC...
        volatile uint32_t EMR;  ///< Offset: 0x3C - External Match Register. The EMR controls the external...
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);
    inline Registers* TIMER3 = reinterpret_cast<Registers*>(TIMER3_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4000C000;
    constexpr uint32_t UART1_BASE = 0x40010000;
    constexpr uint32_t UART2_BASE = 0x40098000;
    constexpr uint32_t UART3_BASE = 0x4009C000;
    constexpr uint32_t UART4_BASE = 0x400A4000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t RBR;  ///< Offset: 0x00 - Receiver Buffer Register. Contains the next received...
        volatile uint32_t THR;  ///< Offset: 0x00 - Transmit Holding Regiter. The next character to be...
        volatile uint32_t DLL;  ///< Offset: 0x00 - Divisor Latch LSB. Least significant byte of the baud...
        volatile uint32_t DLM;  ///< Offset: 0x04 - Divisor Latch MSB. Most significant byte of the baud...
        volatile uint32_t IER;  ///< Offset: 0x04 - Interrupt Enable Register. Contains individual interrupt...
        volatile uint32_t IIR;  ///< Offset: 0x08 - Interrupt ID Register. Identifies which interrupt(s) are pending.
        volatile uint32_t FCR;  ///< Offset: 0x08 - FIFO Control Register. Controls UART FIFO usage and modes.
        volatile uint32_t LCR;  ///< Offset: 0x0C - Line Control Register. Contains controls for frame...
        volatile uint32_t LSR;  ///< Offset: 0x14 - Line Status Register. Contains flags for transmit and...
        volatile uint32_t SCR;  ///< Offset: 0x1C - Scratch Pad Register. 8-bit temporary storage for software.
        volatile uint32_t ACR;  ///< Offset: 0x20 - Auto-baud Control Register. Contains controls for the...
        volatile uint32_t FDR;  ///< Offset: 0x28 - Fractional Divider Register. Generates a clock input for...
        volatile uint32_t TER;  ///< Offset: 0x30 - Transmit Enable Register. Turns off UART transmitter for...
        volatile uint32_t RS485CTRL;  ///< Offset: 0x4C - RS-485/EIA-485 Control. Contains controls to configure...
        volatile uint32_t RS485ADRMATCH;  ///< Offset: 0x50 - RS-485/EIA-485 address match. Contains the address match...
        volatile uint32_t RS485DLY;  ///< Offset: 0x54 - RS-485/EIA-485 direction control delay.
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t PWM0_BASE = 0x40014000;
    constexpr uint32_t PWM1_BASE = 0x40018000;
    constexpr uint32_t MCPWM_BASE = 0x400B8000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t IR;  ///< Offset: 0x00 - Interrupt Register. The IR can be written to clear...
        volatile uint32_t TCR;  ///< Offset: 0x04 - Timer Control Register. The TCR is used to control the...
        volatile uint32_t TC;  ///< Offset: 0x08 - Timer Counter. The 32 bit TC is incremented every PR+1...
        volatile uint32_t PR;  ///< Offset: 0x0C - Prescale Register. Determines how often the PWM counter...
        volatile uint32_t PC;  ///< Offset: 0x10 - Prescale Counter. Prescaler for the main PWM counter.
        volatile uint32_t MCR;  ///< Offset: 0x14 - Match Control Register. The MCR is used to control...
        volatile uint32_t MR%s;  ///< Offset: 0x40 - Match Register. Match registers are continuously...
        volatile uint32_t CCR;  ///< Offset: 0x28 - Capture Control Register. The CCR controls which edges...
        volatile uint32_t CR[%s];  ///< Offset: 0x2C - PWM Control Register. Enables PWM outputs and selects...
        volatile uint32_t PCR;  ///< Offset: 0x4C - PWM Control Register. Enables PWM outputs and selects...
        volatile uint32_t LER;  ///< Offset: 0x50 - Load Enable Register. Enables use of updated PWM match values.
        volatile uint32_t CTCR;  ///< Offset: 0x70 - Count Control Register. The CTCR selects between Timer...
    };

    /// Peripheral instances
    inline Registers* PWM0 = reinterpret_cast<Registers*>(PWM0_BASE);
    inline Registers* PWM1 = reinterpret_cast<Registers*>(PWM1_BASE);
    inline Registers* MCPWM = reinterpret_cast<Registers*>(MCPWM_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x4001C000;
    constexpr uint32_t I2C1_BASE = 0x4005C000;
    constexpr uint32_t I2C2_BASE = 0x400A0000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CONSET;  ///< Offset: 0x00 - I2C Control Set Register. When a one is written to a bit...
        volatile uint32_t STAT;  ///< Offset: 0x04 - I2C Status Register. During I2C operation, this register...
        volatile uint32_t DAT;  ///< Offset: 0x08 - I2C Data Register. During master or slave transmit mode,...
        volatile uint32_t ADR0;  ///< Offset: 0x0C - I2C Slave Address Register 0. Contains the 7-bit slave...
        volatile uint32_t SCLH;  ///< Offset: 0x10 - SCH Duty Cycle Register High Half Word. Determines the...
        volatile uint32_t SCLL;  ///< Offset: 0x14 - SCL Duty Cycle Register Low Half Word. Determines the...
        volatile uint32_t CONCLR;  ///< Offset: 0x18 - I2C Control Clear Register. When a one is written to a...
        volatile uint32_t MMCTRL;  ///< Offset: 0x1C - Monitor mode control register.
        volatile uint32_t ADR%s;  ///< Offset: 0x20 - I2C Slave Address Register. Contains the 7-bit slave...
        volatile uint32_t DATA_BUFFER;  ///< Offset: 0x2C - Data buffer register. The contents of the 8 MSBs of the...
        volatile uint32_t MASK[%s];  ///< Offset: 0x30 - I2C Slave address mask register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40024000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t ILR;  ///< Offset: 0x00 - Interrupt Location Register
        volatile uint32_t CCR;  ///< Offset: 0x08 - Clock Control Register
        volatile uint32_t CIIR;  ///< Offset: 0x0C - Counter Increment Interrupt Register
        volatile uint32_t AMR;  ///< Offset: 0x10 - Alarm Mask Register
        volatile uint32_t CTIME0;  ///< Offset: 0x14 - Consolidated Time Register 0
        volatile uint32_t CTIME1;  ///< Offset: 0x18 - Consolidated Time Register 1
        volatile uint32_t CTIME2;  ///< Offset: 0x1C - Consolidated Time Register 2
        volatile uint32_t SEC;  ///< Offset: 0x20 - Seconds Counter
        volatile uint32_t MIN;  ///< Offset: 0x24 - Minutes Register
        volatile uint32_t HRS;  ///< Offset: 0x28 - Hours Register
        volatile uint32_t DOM;  ///< Offset: 0x2C - Day of Month Register
        volatile uint32_t DOW;  ///< Offset: 0x30 - Day of Week Register
        volatile uint32_t DOY;  ///< Offset: 0x34 - Day of Year Register
        volatile uint32_t MONTH;  ///< Offset: 0x38 - Months Register
        volatile uint32_t YEAR;  ///< Offset: 0x3C - Years Register
        volatile uint32_t CALIBRATION;  ///< Offset: 0x40 - Calibration Value Register
        volatile uint32_t GPREG%s;  ///< Offset: 0x44 - General Purpose Register 0
        volatile uint32_t RTC_AUX;  ///< Offset: 0x5C - RTC Auxiliary control register
        volatile uint32_t RTC_AUXEN;  ///< Offset: 0x58 - RTC Auxiliary Enable register
        volatile uint32_t ASEC;  ///< Offset: 0x60 - Alarm value for Seconds
        volatile uint32_t AMIN;  ///< Offset: 0x64 - Alarm value for Minutes
        volatile uint32_t AHRS;  ///< Offset: 0x68 - Alarm value for Hours
        volatile uint32_t ADOM;  ///< Offset: 0x6C - Alarm value for Day of Month
        volatile uint32_t ADOW;  ///< Offset: 0x70 - Alarm value for Day of Week
        volatile uint32_t ADOY;  ///< Offset: 0x74 - Alarm value for Day of Year
        volatile uint32_t AMON;  ///< Offset: 0x78 - Alarm value for Months
        volatile uint32_t AYRS;  ///< Offset: 0x7C - Alarm value for Year
        volatile uint32_t ERCONTROL;  ///< Offset: 0x84 - Event Monitor/Recorder Control register. Contains bits...
        volatile uint32_t ERSTATUS;  ///< Offset: 0x80 - Event Monitor/Recorder Status register. Contains status...
        volatile uint32_t ERCOUNTERS;  ///< Offset: 0x88 - Event Monitor/Recorder Counters register. Allows reading...
        volatile uint32_t ERFIRSTSTAMP%s;  ///< Offset: 0x90 - Event Monitor/Recorder First Stamp register for channel...
        volatile uint32_t ERLASTSTAMP%s;  ///< Offset: 0xA0 - Event Monitor/Recorder Last Stamp register for channel...
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}

// ============================================================================
// IOCON Peripheral
// ============================================================================

namespace iocon {
    /// Base addresses
    constexpr uint32_t IOCON_BASE = 0x4002C000;

    /// IOCON Register structure
    struct Registers {
        volatile uint32_t P0_0;  ///< Offset: 0x00 - I/O configuration register for pin P0[0]
        volatile uint32_t P0_1;  ///< Offset: 0x04 - I/O configuration register for pin P0[1]
        volatile uint32_t P0_2;  ///< Offset: 0x08 - I/O configuration register for pin P0[2]
        volatile uint32_t P0_3;  ///< Offset: 0x0C - I/O configuration register for pin P0[3]
        volatile uint32_t P0_4;  ///< Offset: 0x10 - I/O configuration register for pin P0[4]
        volatile uint32_t P0_5;  ///< Offset: 0x14 - I/O configuration register for pin P0[5]
        volatile uint32_t P0_6;  ///< Offset: 0x18 - I/O configuration register for pin P0[6]
        volatile uint32_t P0_7;  ///< Offset: 0x1C - I/O configuration register for pin P0[7]
        volatile uint32_t P0_8;  ///< Offset: 0x20 - I/O configuration register for pin P0[8]
        volatile uint32_t P0_9;  ///< Offset: 0x24 - I/O configuration register for pin P0[9]
        volatile uint32_t P0_10;  ///< Offset: 0x28 - I/O configuration register for pin P0[10]
        volatile uint32_t P0_11;  ///< Offset: 0x2C - I/O configuration register for pin P0[11]
        volatile uint32_t P0_12;  ///< Offset: 0x30 - I/O configuration register for pin P0[12]
        volatile uint32_t P0_13;  ///< Offset: 0x34 - I/O configuration register for pin P0[13]
        volatile uint32_t P0_14;  ///< Offset: 0x38 - I/O configuration register for pin P0[14]
        volatile uint32_t P0_15;  ///< Offset: 0x3C - I/O configuration register for pin P0[15]
        volatile uint32_t P0_16;  ///< Offset: 0x40 - I/O configuration register for pin P0[16]
        volatile uint32_t P0_17;  ///< Offset: 0x44 - I/O configuration register for pin P0[17]
        volatile uint32_t P0_18;  ///< Offset: 0x48 - I/O configuration register for pin P0[18]
        volatile uint32_t P0_19;  ///< Offset: 0x4C - I/O configuration register for pin P0[19]
        volatile uint32_t P0_20;  ///< Offset: 0x50 - I/O configuration register for pin P0[20]
        volatile uint32_t P0_21;  ///< Offset: 0x54 - I/O configuration register for pin P0[21]
        volatile uint32_t P0_22;  ///< Offset: 0x58 - I/O configuration register for pin P0[22]
        volatile uint32_t P0_23;  ///< Offset: 0x5C - I/O configuration register for pin P0[23]
        volatile uint32_t P0_24;  ///< Offset: 0x60 - I/O configuration register for pin P0[24]
        volatile uint32_t P0_25;  ///< Offset: 0x64 - I/O configuration register for pin P0[25]
        volatile uint32_t P0_26;  ///< Offset: 0x68 - I/O configuration register for pin P0[26]
        volatile uint32_t P0_27;  ///< Offset: 0x6C - I/O configuration register for pin P0[27]
        volatile uint32_t P0_28;  ///< Offset: 0x70 - I/O configuration register for pin P0[28]
        volatile uint32_t P0_29;  ///< Offset: 0x74 - I/O configuration register for pin P0[29]
        volatile uint32_t P0_30;  ///< Offset: 0x78 - I/O configuration register for pin P0[30]
        volatile uint32_t P0_31;  ///< Offset: 0x7C - I/O configuration register for pin P0[31]
        volatile uint32_t P1_0;  ///< Offset: 0x80 - I/O configuration register for pin P1[0]
        volatile uint32_t P1_1;  ///< Offset: 0x84 - I/O configuration register for pin P1[1]
        volatile uint32_t P1_2;  ///< Offset: 0x88 - I/O configuration register for pin P1[2]
        volatile uint32_t P1_3;  ///< Offset: 0x8C - I/O configuration register for pin P1[3]
        volatile uint32_t P1_4;  ///< Offset: 0x90 - I/O configuration register for pin P1[4]
        volatile uint32_t P1_5;  ///< Offset: 0x94 - I/O configuration register for pin P1[5]
        volatile uint32_t P1_6;  ///< Offset: 0x98 - I/O configuration register for pin P1[6]
        volatile uint32_t P1_7;  ///< Offset: 0x9C - I/O configuration register for pin P1[7]
        volatile uint32_t P1_8;  ///< Offset: 0xA0 - I/O configuration register for pin P1[8]
        volatile uint32_t P1_9;  ///< Offset: 0xA4 - I/O configuration register for pin P1[9]
        volatile uint32_t P1_10;  ///< Offset: 0xA8 - I/O configuration register for pin P1[10]
        volatile uint32_t P1_11;  ///< Offset: 0xAC - I/O configuration register for pin P1[11]
        volatile uint32_t P1_12;  ///< Offset: 0xB0 - I/O configuration register for pin P1[12]
        volatile uint32_t P1_13;  ///< Offset: 0xB4 - I/O configuration register for pin P1[13]
        volatile uint32_t P1_14;  ///< Offset: 0xB8 - I/O configuration register for pin P1[14]
        volatile uint32_t P1_15;  ///< Offset: 0xBC - I/O configuration register for pin P1[15]
        volatile uint32_t P1_16;  ///< Offset: 0xC0 - I/O configuration register for pin P1[16]
        volatile uint32_t P1_17;  ///< Offset: 0xC4 - I/O configuration register for pin P1[17]
        volatile uint32_t P1_18;  ///< Offset: 0xC8 - I/O configuration register for pin P1[18]
        volatile uint32_t P1_19;  ///< Offset: 0xCC - I/O configuration register for pin P1[19]
        volatile uint32_t P1_20;  ///< Offset: 0xD0 - I/O configuration register for pin P1[20]
        volatile uint32_t P1_21;  ///< Offset: 0xD4 - I/O configuration register for pin P1[21]
        volatile uint32_t P1_22;  ///< Offset: 0xD8 - I/O configuration register for pin P1[22]
        volatile uint32_t P1_23;  ///< Offset: 0xDC - I/O configuration register for pin P1[23]
        volatile uint32_t P1_24;  ///< Offset: 0xE0 - I/O configuration register for pin P1[24]
        volatile uint32_t P1_25;  ///< Offset: 0xE4 - I/O configuration register for pin P1[25]
        volatile uint32_t P1_26;  ///< Offset: 0xE8 - I/O configuration register for pin P1[26]
        volatile uint32_t P1_27;  ///< Offset: 0xEC - I/O configuration register for pin P1[27]
        volatile uint32_t P1_28;  ///< Offset: 0xF0 - I/O configuration register for pin P1[28]
        volatile uint32_t P1_29;  ///< Offset: 0xF4 - I/O configuration register for pin P1[29]
        volatile uint32_t P1_30;  ///< Offset: 0xF8 - I/O configuration register for pin P1[30]
        volatile uint32_t P1_31;  ///< Offset: 0xFC - I/O configuration register for pin P1[31]
        volatile uint32_t P2_0;  ///< Offset: 0x100 - I/O configuration register for pin P2[0]
        volatile uint32_t P2_1;  ///< Offset: 0x104 - I/O configuration register for pin P2[1]
        volatile uint32_t P2_2;  ///< Offset: 0x108 - I/O configuration register for pin P2[2]
        volatile uint32_t P2_3;  ///< Offset: 0x10C - I/O configuration register for pin P2[3]
        volatile uint32_t P2_4;  ///< Offset: 0x110 - I/O configuration register for pin P2[4]
        volatile uint32_t P2_5;  ///< Offset: 0x114 - I/O configuration register for pin P2[5]
        volatile uint32_t P2_6;  ///< Offset: 0x118 - I/O configuration register for pin P2[6]
        volatile uint32_t P2_7;  ///< Offset: 0x11C - I/O configuration register for pin P2[7]
        volatile uint32_t P2_8;  ///< Offset: 0x120 - I/O configuration register for pin P2[8]
        volatile uint32_t P2_9;  ///< Offset: 0x124 - I/O configuration register for pin P2[9]
        volatile uint32_t P2_10;  ///< Offset: 0x128 - I/O configuration register for pin P2[10]
        volatile uint32_t P2_11;  ///< Offset: 0x12C - I/O configuration register for pin P2[11]
        volatile uint32_t P2_12;  ///< Offset: 0x130 - I/O configuration register for pin P2[12]
        volatile uint32_t P2_13;  ///< Offset: 0x134 - I/O configuration register for pin P2[13]
        volatile uint32_t P2_14;  ///< Offset: 0x138 - I/O configuration register for pin P2[14]
        volatile uint32_t P2_15;  ///< Offset: 0x13C - I/O configuration register for pin P2[15]
        volatile uint32_t P2_16;  ///< Offset: 0x140 - I/O configuration register for pin P2[16]
        volatile uint32_t P2_17;  ///< Offset: 0x144 - I/O configuration register for pin P2[17]
        volatile uint32_t P2_18;  ///< Offset: 0x148 - I/O configuration register for pin P2[18]
        volatile uint32_t P2_19;  ///< Offset: 0x14C - I/O configuration register for pin P2[19]
        volatile uint32_t P2_20;  ///< Offset: 0x150 - I/O configuration register for pin P2[20]
        volatile uint32_t P2_21;  ///< Offset: 0x154 - I/O configuration register for pin P2[21]
        volatile uint32_t P2_22;  ///< Offset: 0x158 - I/O configuration register for pin P2[22]
        volatile uint32_t P2_23;  ///< Offset: 0x15C - I/O configuration register for pin P2[23]
        volatile uint32_t P2_24;  ///< Offset: 0x160 - I/O configuration register for pin P2[24]
        volatile uint32_t P2_25;  ///< Offset: 0x164 - I/O configuration register for pin P2[25]
        volatile uint32_t P2_26;  ///< Offset: 0x168 - I/O configuration register for pin P2[26]
        volatile uint32_t P2_27;  ///< Offset: 0x16C - I/O configuration register for pin P2[27]
        volatile uint32_t P2_28;  ///< Offset: 0x170 - I/O configuration register for pin P2[28]
        volatile uint32_t P2_29;  ///< Offset: 0x174 - I/O configuration register for pin P2[29]
        volatile uint32_t P2_30;  ///< Offset: 0x178 - I/O configuration register for pin P2[30]
        volatile uint32_t P2_31;  ///< Offset: 0x17C - I/O configuration register for pin P2[31]
        volatile uint32_t P3_0;  ///< Offset: 0x180 - I/O configuration register for pin P3[0]
        volatile uint32_t P3_1;  ///< Offset: 0x184 - I/O configuration register for pin P3[1]
        volatile uint32_t P3_2;  ///< Offset: 0x188 - I/O configuration register for pin P3[2]
        volatile uint32_t P3_3;  ///< Offset: 0x18C - I/O configuration register for pin P3[3]
        volatile uint32_t P3_4;  ///< Offset: 0x190 - I/O configuration register for pin P3[4]
        volatile uint32_t P3_5;  ///< Offset: 0x194 - I/O configuration register for pin P3[5]
        volatile uint32_t P3_6;  ///< Offset: 0x198 - I/O configuration register for pin P3[6]
        volatile uint32_t P3_7;  ///< Offset: 0x19C - I/O configuration register for pin P3[7]
        volatile uint32_t P3_8;  ///< Offset: 0x1A0 - I/O configuration register for pin P3[8]
        volatile uint32_t P3_9;  ///< Offset: 0x1A4 - I/O configuration register for pin P3[9]
        volatile uint32_t P3_10;  ///< Offset: 0x1A8 - I/O configuration register for pin P3[10]
        volatile uint32_t P3_11;  ///< Offset: 0x1AC - I/O configuration register for pin P3[11]
        volatile uint32_t P3_12;  ///< Offset: 0x1B0 - I/O configuration register for pin P3[12]
        volatile uint32_t P3_13;  ///< Offset: 0x1B4 - I/O configuration register for pin P3[13]
        volatile uint32_t P3_14;  ///< Offset: 0x1B8 - I/O configuration register for pin P3[14]
        volatile uint32_t P3_15;  ///< Offset: 0x1BC - I/O configuration register for pin P3[15]
        volatile uint32_t P3_16;  ///< Offset: 0x1C0 - I/O configuration register for pin P3[16]
        volatile uint32_t P3_17;  ///< Offset: 0x1C4 - I/O configuration register for pin P3[17]
        volatile uint32_t P3_18;  ///< Offset: 0x1C8 - I/O configuration register for pin P3[18]
        volatile uint32_t P3_19;  ///< Offset: 0x1CC - I/O configuration register for pin P3[19]
        volatile uint32_t P3_20;  ///< Offset: 0x1D0 - I/O configuration register for pin P3[20]
        volatile uint32_t P3_21;  ///< Offset: 0x1D4 - I/O configuration register for pin P3[21]
        volatile uint32_t P3_22;  ///< Offset: 0x1D8 - I/O configuration register for pin P3[22]
        volatile uint32_t P3_23;  ///< Offset: 0x1DC - I/O configuration register for pin P3[23]
        volatile uint32_t P3_24;  ///< Offset: 0x1E0 - I/O configuration register for pin P3[24]
        volatile uint32_t P3_25;  ///< Offset: 0x1E4 - I/O configuration register for pin P3[25]
        volatile uint32_t P3_26;  ///< Offset: 0x1E8 - I/O configuration register for pin P3[26]
        volatile uint32_t P3_27;  ///< Offset: 0x1EC - I/O configuration register for pin P3[27]
        volatile uint32_t P3_28;  ///< Offset: 0x1F0 - I/O configuration register for pin P3[28]
        volatile uint32_t P3_29;  ///< Offset: 0x1F4 - I/O configuration register for pin P3[29]
        volatile uint32_t P3_30;  ///< Offset: 0x1F8 - I/O configuration register for pin P3[30]
        volatile uint32_t P3_31;  ///< Offset: 0x1FC - I/O configuration register for pin P3[31]
        volatile uint32_t P4_0;  ///< Offset: 0x200 - I/O configuration register for pin P4[0]
        volatile uint32_t P4_1;  ///< Offset: 0x204 - I/O configuration register for pin P4[1]
        volatile uint32_t P4_2;  ///< Offset: 0x208 - I/O configuration register for pin P4[2]
        volatile uint32_t P4_3;  ///< Offset: 0x20C - I/O configuration register for pin P4[3]
        volatile uint32_t P4_4;  ///< Offset: 0x210 - I/O configuration register for pin P4[4]
        volatile uint32_t P4_5;  ///< Offset: 0x214 - I/O configuration register for pin P4[5]
        volatile uint32_t P4_6;  ///< Offset: 0x218 - I/O configuration register for pin P4[6]
        volatile uint32_t P4_7;  ///< Offset: 0x21C - I/O configuration register for pin P4[7]
        volatile uint32_t P4_8;  ///< Offset: 0x220 - I/O configuration register for pin P4[8]
        volatile uint32_t P4_9;  ///< Offset: 0x224 - I/O configuration register for pin P4[9]
        volatile uint32_t P4_10;  ///< Offset: 0x228 - I/O configuration register for pin P4[10]
        volatile uint32_t P4_11;  ///< Offset: 0x22C - I/O configuration register for pin P4[11]
        volatile uint32_t P4_12;  ///< Offset: 0x230 - I/O configuration register for pin P4[12]
        volatile uint32_t P4_13;  ///< Offset: 0x234 - I/O configuration register for pin P4[13]
        volatile uint32_t P4_14;  ///< Offset: 0x238 - I/O configuration register for pin P4[14]
        volatile uint32_t P4_15;  ///< Offset: 0x23C - I/O configuration register for pin P4[15]
        volatile uint32_t P4_16;  ///< Offset: 0x240 - I/O configuration register for pin P4[16]
        volatile uint32_t P4_17;  ///< Offset: 0x244 - I/O configuration register for pin P4[17]
        volatile uint32_t P4_18;  ///< Offset: 0x248 - I/O configuration register for pin P4[18]
        volatile uint32_t P4_19;  ///< Offset: 0x24C - I/O configuration register for pin P4[19]
        volatile uint32_t P4_20;  ///< Offset: 0x250 - I/O configuration register for pin P4[20]
        volatile uint32_t P4_21;  ///< Offset: 0x254 - I/O configuration register for pin P4[21]
        volatile uint32_t P4_22;  ///< Offset: 0x258 - I/O configuration register for pin P4[22]
        volatile uint32_t P4_23;  ///< Offset: 0x25C - I/O configuration register for pin P4[23]
        volatile uint32_t P4_24;  ///< Offset: 0x260 - I/O configuration register for pin P4[24]
        volatile uint32_t P4_25;  ///< Offset: 0x264 - I/O configuration register for pin P4[25]
        volatile uint32_t P4_26;  ///< Offset: 0x268 - I/O configuration register for pin P4[26]
        volatile uint32_t P4_27;  ///< Offset: 0x26C - I/O configuration register for pin P4[27]
        volatile uint32_t P4_28;  ///< Offset: 0x270 - I/O configuration register for pin P4[28]
        volatile uint32_t P4_29;  ///< Offset: 0x274 - I/O configuration register for pin P4[29]
        volatile uint32_t P4_30;  ///< Offset: 0x278 - I/O configuration register for pin P4[30]
        volatile uint32_t P4_31;  ///< Offset: 0x27C - I/O configuration register for pin P4[31]
        volatile uint32_t P5_0;  ///< Offset: 0x280 - I/O configuration register for pin P5[0]
        volatile uint32_t P5_1;  ///< Offset: 0x284 - I/O configuration register for pin P5[1]
        volatile uint32_t P5_2;  ///< Offset: 0x288 - I/O configuration register for pin P5[2]
        volatile uint32_t P5_3;  ///< Offset: 0x28C - I/O configuration register for pin P5[3]
        volatile uint32_t P5_4;  ///< Offset: 0x290 - I/O configuration register for pin P5[4]
    };

    /// Peripheral instances
    inline Registers* IOCON = reinterpret_cast<Registers*>(IOCON_BASE);

}

// ============================================================================
// SSP1 Peripheral
// ============================================================================

namespace ssp1 {
    /// Base addresses
    constexpr uint32_t SSP1_BASE = 0x40030000;

    /// SSP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - Control Register 0. Selects the serial clock rate, bus...
        volatile uint32_t CR1;  ///< Offset: 0x04 - Control Register 1. Selects master/slave and other modes.
        volatile uint32_t DR;  ///< Offset: 0x08 - Data Register. Writes fill the transmit FIFO, and reads...
        volatile uint32_t SR;  ///< Offset: 0x0C - Status Register
        volatile uint32_t CPSR;  ///< Offset: 0x10 - Clock Prescale Register
        volatile uint32_t IMSC;  ///< Offset: 0x14 - Interrupt Mask Set and Clear Register
        volatile uint32_t RIS;  ///< Offset: 0x18 - Raw Interrupt Status Register
        volatile uint32_t MIS;  ///< Offset: 0x1C - Masked Interrupt Status Register
        volatile uint32_t ICR;  ///< Offset: 0x20 - SSPICR Interrupt Clear Register
        volatile uint32_t DMACR;  ///< Offset: 0x24 - SSP0 DMA control register
    };

    /// Peripheral instances
    inline Registers* SSP1 = reinterpret_cast<Registers*>(SSP1_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40034000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - A/D Control Register. The ADCR register must be written...
        volatile uint32_t GDR;  ///< Offset: 0x04 - A/D Global Data Register. This register contains the...
        volatile uint32_t INTEN;  ///< Offset: 0x0C - A/D Interrupt Enable Register. This register contains...
        volatile uint32_t DR[%s];  ///< Offset: 0x10 - A/D Channel 0 Data Register. This register contains the...
        volatile uint32_t STAT;  ///< Offset: 0x30 - A/D Status Register. This register contains DONE and...
        volatile uint32_t TRM;  ///< Offset: 0x34 - ADC trim register.
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CANAFRAM_BASE = 0x40038000;
    constexpr uint32_t CANAF_BASE = 0x4003C000;
    constexpr uint32_t CCAN_BASE = 0x40040000;
    constexpr uint32_t CAN1_BASE = 0x40044000;
    constexpr uint32_t CAN2_BASE = 0x40048000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MASK[%s];  ///< Offset: 0x00 - CAN AF ram access register
    };

    /// Peripheral instances
    inline Registers* CANAFRAM = reinterpret_cast<Registers*>(CANAFRAM_BASE);
    inline Registers* CANAF = reinterpret_cast<Registers*>(CANAF_BASE);
    inline Registers* CCAN = reinterpret_cast<Registers*>(CCAN_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);
    inline Registers* CAN2 = reinterpret_cast<Registers*>(CAN2_BASE);

}

// ============================================================================
// SSP0 Peripheral
// ============================================================================

namespace ssp0 {
    /// Base addresses
    constexpr uint32_t SSP0_BASE = 0x40088000;

    /// SSP0 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSP0 = reinterpret_cast<Registers*>(SSP0_BASE);

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x4008C000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - D/A Converter Register. This register contains the...
        volatile uint32_t CTRL;  ///< Offset: 0x04 - DAC Control register. This register controls DMA and...
        volatile uint32_t CNTVAL;  ///< Offset: 0x08 - DAC Counter Value register. This register contains the...
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S_BASE = 0x400A8000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t DAO;  ///< Offset: 0x00 - I2S Digital Audio Output Register. Contains control bits...
        volatile uint32_t DAI;  ///< Offset: 0x04 - I2S Digital Audio Input Register. Contains control bits...
        volatile uint32_t TXFIFO;  ///< Offset: 0x08 - I2S Transmit FIFO. Access register for the 8 x 32-bit...
        volatile uint32_t RXFIFO;  ///< Offset: 0x0C - I2S Receive FIFO. Access register for the 8 x 32-bit...
        volatile uint32_t STATE;  ///< Offset: 0x10 - I2S Status Feedback Register. Contains status...
        volatile uint32_t DMA1;  ///< Offset: 0x14 - I2S DMA Configuration Register 1. Contains control...
        volatile uint32_t DMA2;  ///< Offset: 0x18 - I2S DMA Configuration Register 2. Contains control...
        volatile uint32_t IRQ;  ///< Offset: 0x1C - I2S Interrupt Request Control Register. Contains bits...
        volatile uint32_t TXRATE;  ///< Offset: 0x20 - I2S Transmit MCLK divider. This register determines the...
        volatile uint32_t RXRATE;  ///< Offset: 0x24 - I2S Receive MCLK divider. This register determines the...
        volatile uint32_t TXBITRATE;  ///< Offset: 0x28 - I2S Transmit bit rate divider. This register determines...
        volatile uint32_t RXBITRATE;  ///< Offset: 0x2C - I2S Receive bit rate divider. This register determines...
        volatile uint32_t TXMODE;  ///< Offset: 0x30 - I2S Transmit mode control.
        volatile uint32_t RXMODE;  ///< Offset: 0x34 - I2S Receive mode control.
    };

    /// Peripheral instances
    inline Registers* I2S = reinterpret_cast<Registers*>(I2S_BASE);

}

// ============================================================================
// SSP2 Peripheral
// ============================================================================

namespace ssp2 {
    /// Base addresses
    constexpr uint32_t SSP2_BASE = 0x400AC000;

    /// SSP2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SSP2 = reinterpret_cast<Registers*>(SSP2_BASE);

}

// ============================================================================
// QEI Peripheral
// ============================================================================

namespace qei {
    /// Base addresses
    constexpr uint32_t QEI_BASE = 0x400BC000;

    /// QEI Register structure
    struct Registers {
        volatile uint32_t CON;  ///< Offset: 0x00 - Control register
        volatile uint32_t CONF;  ///< Offset: 0x08 - Configuration register
        volatile uint32_t STAT;  ///< Offset: 0x04 - Status register
        volatile uint32_t POS;  ///< Offset: 0x0C - Position register
        volatile uint32_t MAXPOS;  ///< Offset: 0x10 - Maximum position register
        volatile uint32_t CMPOS0;  ///< Offset: 0x14 - Position compare register 0
        volatile uint32_t CMPOS1;  ///< Offset: 0x18 - Position compare register 1
        volatile uint32_t CMPOS2;  ///< Offset: 0x1C - Position compare register 2
        volatile uint32_t INXCNT;  ///< Offset: 0x20 - Index count register 0
        volatile uint32_t INXCMP0;  ///< Offset: 0x24 - Index compare register 0
        volatile uint32_t LOAD;  ///< Offset: 0x28 - Velocity timer reload register
        volatile uint32_t TIME;  ///< Offset: 0x2C - Velocity timer register
        volatile uint32_t VEL;  ///< Offset: 0x30 - Velocity counter register
        volatile uint32_t CAP;  ///< Offset: 0x34 - Velocity capture register
        volatile uint32_t VELCOMP;  ///< Offset: 0x38 - Velocity compare register
        volatile uint32_t FILTERPHA;  ///< Offset: 0x3C - Digital filter register on PHA
        volatile uint32_t FILTERPHB;  ///< Offset: 0x40 - Digital filter register on PHB
        volatile uint32_t FILTERINX;  ///< Offset: 0x44 - Digital filter register on IDX
        volatile uint32_t WINDOW;  ///< Offset: 0x48 - Index acceptance window register
        volatile uint32_t INXCMP1;  ///< Offset: 0x4C - Index compare register 1
        volatile uint32_t INXCMP2;  ///< Offset: 0x50 - Index compare register 2
        volatile uint32_t INTSTAT;  ///< Offset: 0xFE0 - Interrupt status register
        volatile uint32_t SET;  ///< Offset: 0xFEC - Interrupt status set register
        volatile uint32_t CLR;  ///< Offset: 0xFE8 - Interrupt status clear register
        volatile uint32_t IE;  ///< Offset: 0xFE4 - Interrupt enable register
        volatile uint32_t IES;  ///< Offset: 0xFDC - Interrupt enable set register
        volatile uint32_t IEC;  ///< Offset: 0xFD8 - Interrupt enable clear register
    };

    /// Peripheral instances
    inline Registers* QEI = reinterpret_cast<Registers*>(QEI_BASE);

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_BASE = 0x400C0000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t PWR;  ///< Offset: 0x00 - Power control register.
        volatile uint32_t CLOCK;  ///< Offset: 0x04 - Clock control register.
        volatile uint32_t ARGUMENT;  ///< Offset: 0x08 - Argument register.
        volatile uint32_t COMMAND;  ///< Offset: 0x0C - Command register.
        volatile uint32_t RESPCMD;  ///< Offset: 0x10 - Response command register.
        volatile uint32_t RESPONSE%s;  ///< Offset: 0x14 - Response register.
        volatile uint32_t DATATIMER;  ///< Offset: 0x24 - Data Timer.
        volatile uint32_t DATALENGTH;  ///< Offset: 0x28 - Data length register.
        volatile uint32_t DATACTRL;  ///< Offset: 0x2C - Data control register.
        volatile uint32_t DATACNT;  ///< Offset: 0x30 - Data counter.
        volatile uint32_t STATUS;  ///< Offset: 0x34 - Status register.
        volatile uint32_t CLEAR;  ///< Offset: 0x38 - Clear register.
        volatile uint32_t MASK0;  ///< Offset: 0x3C - Interrupt 0 mask register.
        volatile uint32_t FIFOCNT;  ///< Offset: 0x48 - FIFO Counter.
        volatile uint32_t FIFO%s;  ///< Offset: 0x80 - Data FIFO Register.
    };

    /// Peripheral instances
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x400FC000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t FLASHCFG;  ///< Offset: 0x00 - Flash Accelerator Configuration Register. Controls flash...
        volatile uint32_t PLL%sCON;  ///< Offset: 0x80 - PLL0 Control register
        volatile uint32_t PLL%sCFG;  ///< Offset: 0x84 - PLL0 Configuration register
        volatile uint32_t PLL%sSTAT;  ///< Offset: 0x88 - PLL0 Status register
        volatile uint32_t PLL%sFEED;  ///< Offset: 0x8C - PLL0 Feed register
        volatile uint32_t PCON;  ///< Offset: 0xC0 - Power Control register
        volatile uint32_t PCONP;  ///< Offset: 0xC4 - Power Control for Peripherals
        volatile uint32_t EMCCLKSEL;  ///< Offset: 0x100 - External Memory Controller Clock Selection register
        volatile uint32_t CCLKSEL;  ///< Offset: 0x104 - CPU Clock Selection register
        volatile uint32_t USBCLKSEL;  ///< Offset: 0x108 - USB Clock Selection register
        volatile uint32_t CLKSRCSEL;  ///< Offset: 0x10C - Clock Source Select Register
        volatile uint32_t CANSLEEPCLR;  ///< Offset: 0x110 - Allows clearing the current CAN channel sleep state as...
        volatile uint32_t CANWAKEFLAGS;  ///< Offset: 0x114 - Allows reading the wake-up state of the CAN channels.
        volatile uint32_t EXTINT;  ///< Offset: 0x140 - External Interrupt Flag Register
        volatile uint32_t EXTMODE;  ///< Offset: 0x148 - External Interrupt Mode register
        volatile uint32_t EXTPOLAR;  ///< Offset: 0x14C - External Interrupt Polarity Register
        volatile uint32_t RSID;  ///< Offset: 0x180 - Reset Source Identification Register
        volatile uint32_t MATRIXARB;  ///< Offset: 0x188 - Matrix arbitration register
        volatile uint32_t SCS;  ///< Offset: 0x1A0 - System Control and Status
        volatile uint32_t PCLKSEL;  ///< Offset: 0x1A8 - Peripheral Clock Selection register
        volatile uint32_t PBOOST;  ///< Offset: 0x1B0 - Power boost register
        volatile uint32_t SPIFICLKSEL;  ///< Offset: 0x1B4 - SPIFI Clock Selection register
        volatile uint32_t LCD_CFG;  ///< Offset: 0x1B8 - LCD Clock configuration register
        volatile uint32_t USBINTST;  ///< Offset: 0x1C0 - USB Interrupt Status
        volatile uint32_t DMACREQSEL;  ///< Offset: 0x1C4 - Selects between alternative requests on DMA channels 0...
        volatile uint32_t CLKOUTCFG;  ///< Offset: 0x1C8 - Clock Output Configuration register
        volatile uint32_t RSTCON0;  ///< Offset: 0x1CC - Individual peripheral reset control bits
        volatile uint32_t RSTCON1;  ///< Offset: 0x1D0 - Individual peripheral reset control bits
        volatile uint32_t EMCDLYCTL;  ///< Offset: 0x1DC - Values for the 4 programmable delays associated with...
        volatile uint32_t EMCCAL;  ///< Offset: 0x1E0 - Controls the calibration counter for programmable delays...
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

}


} // namespace alloy::generated::neom3

#endif // ALLOY_GENERATED_NEOM3_PERIPHERALS_HPP