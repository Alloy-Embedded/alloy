/// Auto-generated code for S6E1A1
/// Generated by Alloy Code Generator
/// Source: fujitsu_s6e1a1.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:34
#ifndef ALLOY_GENERATED_S6E1A1_PERIPHERALS_HPP
#define ALLOY_GENERATED_S6E1A1_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::s6e1a1 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_IF_BASE = 0x40000000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FRWTR;  ///< Offset: 0x04 - Flash Read Wait Register
        volatile uint32_t FSTR;  ///< Offset: 0x08 - Flash Status Register
        volatile uint32_t FSYNDN;  ///< Offset: 0x10 - Flash Sync Down Register
        volatile uint32_t FICR;  ///< Offset: 0x20 - Flash Interrupt Control Register
        volatile uint32_t FISR;  ///< Offset: 0x24 - Flash Interrupt Status Register
        volatile uint32_t FICLR;  ///< Offset: 0x28 - Flash Interrupt Clear Register
        volatile uint32_t CRTRMM;  ///< Offset: 0x100 - CR Trimming Data Mirror Register
    };

    /// Peripheral instances
    inline Registers* FLASH_IF = reinterpret_cast<Registers*>(FLASH_IF_BASE);

    // Bit definitions
    /// FRWTR Register bits
    namespace frwtr_bits {
        constexpr uint32_t RWT = (2 << 0);  ///< Read Wait Cycle
    }

    /// FSTR Register bits
    namespace fstr_bits {
        constexpr uint32_t PGMS = (1U << 5);  ///< Flash Program Status
        constexpr uint32_t SERS = (1U << 4);  ///< Flash Sector Erase Status
        constexpr uint32_t ESPS = (1U << 3);  ///< Flash Erase Suspend Status
        constexpr uint32_t CERS = (1U << 2);  ///< Flash Chip Erase Status
        constexpr uint32_t HNG = (1U << 1);  ///< Flash Hang Status
        constexpr uint32_t RDY = (1U << 0);  ///< Flash Ready Status
    }

    /// FSYNDN Register bits
    namespace fsyndn_bits {
        constexpr uint32_t SD = (4 << 0);  ///< Sync Down
    }

    /// FICR Register bits
    namespace ficr_bits {
        constexpr uint32_t HANGIE = (1U << 1);  ///< HANG Interrupt Enable
        constexpr uint32_t RDYIE = (1U << 0);  ///< RDY Interrupt Enable
    }

    /// FISR Register bits
    namespace fisr_bits {
        constexpr uint32_t HANGIF = (1U << 1);  ///< HANG Interrupt Flag
        constexpr uint32_t RDYIF = (1U << 0);  ///< RDY Interrupt Flag
    }

    /// FICLR Register bits
    namespace ficlr_bits {
        constexpr uint32_t HANGIC = (1U << 1);  ///< HANG Interrupt Clear
        constexpr uint32_t RDYIC = (1U << 0);  ///< RDY Interrupt Clear
    }

    /// CRTRMM Register bits
    namespace crtrmm_bits {
        constexpr uint32_t TTRMM = (5 << 16);  ///< CR Temperature Trimming Data Mirror Bit
        constexpr uint32_t TRMM = (10 << 0);  ///< CR Trimming Data Mirror Bit
    }

}

// ============================================================================
// UNIQUE Peripheral
// ============================================================================

namespace unique {
    /// Base addresses
    constexpr uint32_t UNIQUE_ID_BASE = 0x40000200;

    /// UNIQUE Register structure
    struct Registers {
        volatile uint32_t UIDR0;  ///< Offset: 0x00 - Unique ID Register 0
        volatile uint32_t UIDR1;  ///< Offset: 0x04 - Unique ID Register 1
    };

    /// Peripheral instances
    inline Registers* UNIQUE_ID = reinterpret_cast<Registers*>(UNIQUE_ID_BASE);

    // Bit definitions
    /// UIDR0 Register bits
    namespace uidr0_bits {
        constexpr uint32_t UID = (28 << 4);  ///< Unique ID 27 through Unique ID 0
    }

    /// UIDR1 Register bits
    namespace uidr1_bits {
        constexpr uint32_t UID = (13 << 0);  ///< Unique ID 40 through Unique ID 28
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t CLOCK_BASE = 0x40010000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t SCM_CTL;  ///< Offset: 0x00 - System Clock Mode Control Register
        volatile uint32_t SCM_STR;  ///< Offset: 0x04 - System Clock Mode Status Register
        volatile uint32_t BSC_PSR;  ///< Offset: 0x10 - Base Clock Prescaler Register
        volatile uint32_t APBC0_PSR;  ///< Offset: 0x14 - APB0 Prescaler Register
        volatile uint32_t APBC1_PSR;  ///< Offset: 0x18 - APB1 Prescaler Register
        volatile uint32_t SWC_PSR;  ///< Offset: 0x20 - Software Watchdog Clock Prescaler Register
        volatile uint32_t CSW_TMR;  ///< Offset: 0x30 - Clock Stabilization Wait Time Register
        volatile uint32_t PSW_TMR;  ///< Offset: 0x34 - PLL Clock Stabilization Wait Time Setup Register
        volatile uint32_t PLL_CTL1;  ///< Offset: 0x38 - PLL Control Register 1
        volatile uint32_t PLL_CTL2;  ///< Offset: 0x3C - PLL Control Register 2
        volatile uint32_t DBWDT_CTL;  ///< Offset: 0x54 - Debug Break Watchdog Timer Control Register
        volatile uint32_t INT_ENR;  ///< Offset: 0x60 - Interrupt Enable Register
        volatile uint32_t INT_STR;  ///< Offset: 0x64 - Interrupt Status Register
        volatile uint32_t INT_CLR;  ///< Offset: 0x68 - Interrupt Clear Register
        volatile uint32_t STB_CTL;  ///< Offset: 0x08 - Standby Mode Control Register
        volatile uint32_t RST_STR;  ///< Offset: 0x0C - Reset Cause Register
        volatile uint32_t CSV_CTL;  ///< Offset: 0x40 - CSV control register
        volatile uint32_t CSV_STR;  ///< Offset: 0x44 - CSV status register
        volatile uint32_t FCSWH_CTL;  ///< Offset: 0x48 - Frequency detection window setting register
        volatile uint32_t FCSWL_CTL;  ///< Offset: 0x4C - Frequency detection window setting register
        volatile uint32_t FCSWD_CTL;  ///< Offset: 0x50 - Frequency detection counter register
    };

    /// Peripheral instances
    inline Registers* CLOCK = reinterpret_cast<Registers*>(CLOCK_BASE);

    // Bit definitions
    /// SCM_CTL Register bits
    namespace scm_ctl_bits {
        constexpr uint32_t RCS = (3 << 5);  ///< Master clock switch control bits
        constexpr uint32_t PLLE = (1U << 4);  ///< PLL oscillation enable bit
        constexpr uint32_t SOSCE = (1U << 3);  ///< Sub clock oscillation enable bit
        constexpr uint32_t MOSCE = (1U << 1);  ///< Main clock oscillation enable bit
        constexpr uint32_t HCRE = (1U << 0);  ///< High-speed CR clock oscillation enable bit
    }

    /// SCM_STR Register bits
    namespace scm_str_bits {
        constexpr uint32_t RCM = (3 << 5);  ///< Master clock selection bits
        constexpr uint32_t PLRDY = (1U << 4);  ///< PLL oscillation stable bit
        constexpr uint32_t SORDY = (1U << 3);  ///< Sub clock oscillation stable bit
        constexpr uint32_t MORDY = (1U << 1);  ///< Main clock oscillation stable bit
        constexpr uint32_t HCRDY = (1U << 0);  ///< High-speed CR clock oscillation stable bit
    }

    /// BSC_PSR Register bits
    namespace bsc_psr_bits {
        constexpr uint32_t BSR = (3 << 0);  ///< Base clock frequency division ratio setting bits
    }

    /// APBC0_PSR Register bits
    namespace apbc0_psr_bits {
        constexpr uint32_t APBC0 = (2 << 0);  ///< APB0 bus clock frequency division ratio setting bits
    }

    /// APBC1_PSR Register bits
    namespace apbc1_psr_bits {
        constexpr uint32_t APBC1EN = (1U << 7);  ///< APB1 clock enable bit
        constexpr uint32_t APBC1RST = (1U << 4);  ///< APB1 bus reset control bit
        constexpr uint32_t APBC1 = (2 << 0);  ///< APB1 bus clock frequency division ratio setting bits
    }

    /// SWC_PSR Register bits
    namespace swc_psr_bits {
        constexpr uint32_t TESTB = (1U << 7);  ///< TEST bit
        constexpr uint32_t SWDS = (2 << 0);  ///< Software watchdog clock frequency division ratio setting bits
    }

    /// CSW_TMR Register bits
    namespace csw_tmr_bits {
        constexpr uint32_t SOWT = (4 << 4);  ///< Sub clock stabilization wait time setup bits
        constexpr uint32_t MOWT = (4 << 0);  ///< Main clock stabilization wait time setup bits
    }

    /// PSW_TMR Register bits
    namespace psw_tmr_bits {
        constexpr uint32_t PINC = (1U << 4);  ///< PLL input clock select bit
        constexpr uint32_t POWT = (3 << 0);  ///< Main PLL clock stabilization wait time setup bits
    }

    /// PLL_CTL1 Register bits
    namespace pll_ctl1_bits {
        constexpr uint32_t PLLK = (4 << 4);  ///< PLL input clock frequency division ratio setting bits
        constexpr uint32_t PLLM = (4 << 0);  ///< PLL VCO clock frequency division ratio setting bits
    }

    /// PLL_CTL2 Register bits
    namespace pll_ctl2_bits {
        constexpr uint32_t PLLN = (6 << 0);  ///< PLL feedback frequency division ratio setting bits
    }

    /// DBWDT_CTL Register bits
    namespace dbwdt_ctl_bits {
        constexpr uint32_t DPHWBE = (1U << 7);  ///< HW-WDG debug mode break bit
        constexpr uint32_t DPSWBE = (1U << 5);  ///< SW-WDG debug mode break bit
    }

    /// INT_ENR Register bits
    namespace int_enr_bits {
        constexpr uint32_t FCSE = (1U << 5);  ///< Anomalous frequency detection interrupt enable bit
        constexpr uint32_t PCSE = (1U << 2);  ///< PLL oscillation stabilization wait completion interrupt enable bit
        constexpr uint32_t SCSE = (1U << 1);  ///< Sub clock oscillation stabilization wait completion interrupt enable bit
        constexpr uint32_t MCSE = (1U << 0);  ///< Main clock oscillation stabilization wait completion interrupt enable bit
    }

    /// INT_STR Register bits
    namespace int_str_bits {
        constexpr uint32_t FCSI = (1U << 5);  ///< Anomalous frequency detection interrupt status bit
        constexpr uint32_t PCSI = (1U << 2);  ///< PLL oscillation stabilization wait completion interrupt status bit
        constexpr uint32_t SCSI = (1U << 1);  ///< Sub clock oscillation stabilization wait completion interrupt status bit
        constexpr uint32_t MCSI = (1U << 0);  ///< Main clock oscillation stabilization wait completion interrupt status bit
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t FCSC = (1U << 5);  ///< Anomalous frequency detection interrupt factor clear bit
        constexpr uint32_t PCSC = (1U << 2);  ///< PLL oscillation stabilization wait completion interrupt factor clear bit
        constexpr uint32_t SCSC = (1U << 1);  ///< Sub clock oscillation stabilization wait completion interrupt factor clear bit
        constexpr uint32_t MCSC = (1U << 0);  ///< Main clock oscillation stabilization wait completion interrupt factor clear bit
    }

    /// STB_CTL Register bits
    namespace stb_ctl_bits {
        constexpr uint32_t KEY = (16 << 16);  ///< Standby mode control write control bits
        constexpr uint32_t SPL = (1U << 4);  ///< Standby pin level setting bit
        constexpr uint32_t DSTM = (1U << 2);  ///< Deep standby mode select bit
        constexpr uint32_t STM = (2 << 0);  ///< Standby mode selection bits
    }

    /// RST_STR Register bits
    namespace rst_str_bits {
        constexpr uint32_t SRST = (1U << 8);  ///< Software reset flag
        constexpr uint32_t FCSR = (1U << 7);  ///< Flag for anomalous frequency detection reset
        constexpr uint32_t CSVR = (1U << 6);  ///< Clock failure detection reset flag
        constexpr uint32_t HWDT = (1U << 5);  ///< Hardware watchdog reset flag
        constexpr uint32_t SWDT = (1U << 4);  ///< Software watchdog reset flag
        constexpr uint32_t INITX = (1U << 1);  ///< INITX pin input reset flag
        constexpr uint32_t PONR = (1U << 0);  ///< Power-on reset/low-voltage detection reset flag
    }

    /// CSV_CTL Register bits
    namespace csv_ctl_bits {
        constexpr uint32_t FCD = (3 << 12);  ///< FCS count cycle setting bits
        constexpr uint32_t FCSRE = (1U << 9);  ///< FCS reset output enable bit
        constexpr uint32_t FCSDE = (1U << 8);  ///< FCS function enable bit
        constexpr uint32_t SCSVE = (1U << 1);  ///< Sub CSV function enable bit
        constexpr uint32_t MCSVE = (1U << 0);  ///< Main CSV function enable bit
    }

    /// CSV_STR Register bits
    namespace csv_str_bits {
        constexpr uint32_t SCMF = (1U << 1);  ///< Sub clock failure detection flag
        constexpr uint32_t MCMF = (1U << 0);  ///< Main clock failure detection flag
    }

    /// FCSWH_CTL Register bits
    namespace fcswh_ctl_bits {
        constexpr uint32_t FWH = (16 << 0);  ///< Frequency detection window setting bits (Upper)
    }

    /// FCSWL_CTL Register bits
    namespace fcswl_ctl_bits {
        constexpr uint32_t FWL = (16 << 0);  ///< Frequency detection window setting bits (Lower)
    }

    /// FCSWD_CTL Register bits
    namespace fcswd_ctl_bits {
        constexpr uint32_t FWD = (16 << 0);  ///< Frequency detection count data
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t HWWDT_BASE = 0x40011000;
    constexpr uint32_t SWWDT_BASE = 0x40012000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDG_LDR;  ///< Offset: 0x00 - Hardware Watchdog Timer Load Register
        volatile uint32_t WDG_VLR;  ///< Offset: 0x04 - Hardware Watchdog Timer Value Register
        volatile uint32_t WDG_CTL;  ///< Offset: 0x08 - Hardware Watchdog Timer Control Register
        volatile uint32_t WDG_ICL;  ///< Offset: 0x0C - Hardware Watchdog Timer Clear Register
        volatile uint32_t WDG_RIS;  ///< Offset: 0x10 - Hardware Watchdog Timer Interrupt Status Register
        volatile uint32_t WDG_LCK;  ///< Offset: 0xC00 - Hardware Watchdog Timer Lock Register
    };

    /// Peripheral instances
    inline Registers* HWWDT = reinterpret_cast<Registers*>(HWWDT_BASE);
    inline Registers* SWWDT = reinterpret_cast<Registers*>(SWWDT_BASE);

    // Bit definitions
    /// WDG_CTL Register bits
    namespace wdg_ctl_bits {
        constexpr uint32_t RESEN = (1U << 1);  ///< Hardware watchdog reset enable bit
        constexpr uint32_t INTEN = (1U << 0);  ///< Hardware watchdog interrupt and counter enable bit
    }

    /// WDG_RIS Register bits
    namespace wdg_ris_bits {
        constexpr uint32_t RIS = (1U << 0);  ///< Hardware watchdog interrupt status bit
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t DTIM_BASE = 0x40015000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIMER1LOAD;  ///< Offset: 0x00 - Load Register
        volatile uint32_t TIMER1VALUE;  ///< Offset: 0x04 - Value Register
        volatile uint32_t TIMER1CONTROL;  ///< Offset: 0x08 - Control Register
        volatile uint32_t TIMER1INTCLR;  ///< Offset: 0x0C - Interrupt Clear Register
        volatile uint32_t TIMER1RIS;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t TIMER1MIS;  ///< Offset: 0x14 - Masked Interrupt Status Register
        volatile uint32_t TIMER1BGLOAD;  ///< Offset: 0x18 - Background Load Register
        volatile uint32_t TIMER2LOAD;  ///< Offset: 0x20 - Load Register
        volatile uint32_t TIMER2VALUE;  ///< Offset: 0x24 - Value Register
        volatile uint32_t TIMER2CONTROL;  ///< Offset: 0x28 - Control Register
        volatile uint32_t TIMER2INTCLR;  ///< Offset: 0x2C - Interrupt Clear Register
        volatile uint32_t TIMER2RIS;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t TIMER2MIS;  ///< Offset: 0x34 - Masked Interrupt Status Register
        volatile uint32_t TIMER2BGLOAD;  ///< Offset: 0x38 - Background Load Register
    };

    /// Peripheral instances
    inline Registers* DTIM = reinterpret_cast<Registers*>(DTIM_BASE);

    // Bit definitions
    /// TIMER1CONTROL Register bits
    namespace timer1control_bits {
        constexpr uint32_t TimerEn = (1U << 7);  ///< Enable bit
        constexpr uint32_t TimerMode = (1U << 6);  ///< Mode bit
        constexpr uint32_t IntEnable = (1U << 5);  ///< Interrupt enable bit
        constexpr uint32_t TimerPre = (2 << 2);  ///< Prescale bits
        constexpr uint32_t TimerSize = (1U << 1);  ///< Counter size bit
        constexpr uint32_t OneShot = (1U << 0);  ///< One-shot mode bit
    }

    /// TIMER1RIS Register bits
    namespace timer1ris_bits {
        constexpr uint32_t TIMER1RIS = (1U << 0);  ///< Interrupt Status Register bit
    }

    /// TIMER1MIS Register bits
    namespace timer1mis_bits {
        constexpr uint32_t TIMER1MIS = (1U << 0);  ///< Masked Interrupt Status bit
    }

}

// ============================================================================
// MFT0 Peripheral
// ============================================================================

namespace mft0 {
    /// Base addresses
    constexpr uint32_t MFT0_BASE = 0x40020000;

    /// MFT0 Register structure
    struct Registers {
        volatile uint32_t FRT_TCCP0;  ///< Offset: 0x142 - FRT-ch.0 Cycle Setting Register
        volatile uint32_t FRT_TCDT0;  ///< Offset: 0x146 - FRT-ch.0 Count Value Register
        volatile uint32_t FRT_TCSA0;  ///< Offset: 0x148 - FRT-ch.0 Control Register A
        volatile uint32_t FRT_TCSC0;  ///< Offset: 0x14A - FRT-ch.0 Control Register C
        volatile uint32_t FRT_TCCP1;  ///< Offset: 0x14E - FRT-ch.1 Cycle Setting Register
        volatile uint32_t FRT_TCDT1;  ///< Offset: 0x152 - FRT-ch.1 Count Value Register
        volatile uint32_t FRT_TCSA1;  ///< Offset: 0x154 - FRT-ch.1 Control Register A
        volatile uint32_t FRT_TCSC1;  ///< Offset: 0x156 - FRT-ch.1 Control Register C
        volatile uint32_t FRT_TCCP2;  ///< Offset: 0x15A - FRT-ch.2 Cycle Setting Register
        volatile uint32_t FRT_TCDT2;  ///< Offset: 0x15E - FRT-ch.2 Count Value Register
        volatile uint32_t FRT_TCSA2;  ///< Offset: 0x160 - FRT-ch.2 Control Register A
        volatile uint32_t FRT_TCSC2;  ///< Offset: 0x162 - FRT-ch.2 Control Register C
        volatile uint32_t FRT_TCAL;  ///< Offset: 0x164 - FRT Simultaneous Start Control Register
        volatile uint32_t OCU_OCCP0;  ///< Offset: 0x102 - OCU ch.0 Compare Value Store Register
        volatile uint32_t OCU_OCCP1;  ///< Offset: 0x106 - OCU ch.1 Compare Value Store Register
        volatile uint32_t OCU_OCCP2;  ///< Offset: 0x10A - OCU ch.2 Compare Value Store Register
        volatile uint32_t OCU_OCCP3;  ///< Offset: 0x10E - OCU ch.3 Compare Value Store Register
        volatile uint32_t OCU_OCCP4;  ///< Offset: 0x112 - OCU ch.4 Compare Value Store Register
        volatile uint32_t OCU_OCCP5;  ///< Offset: 0x116 - OCU ch.5 Compare Value Store Register
        volatile uint32_t OCU_OCSA10;  ///< Offset: 0x118 - OCU ch.0/1 Control Register A
        volatile uint32_t OCU_OCSB10;  ///< Offset: 0x119 - OCU ch.0/1 Control Register B
        volatile uint32_t OCU_OCSD10;  ///< Offset: 0x11A - OCU ch.0/1 Control Register D
        volatile uint32_t OCU_OCSA32;  ///< Offset: 0x11C - OCU ch.2/3 Control Register A
        volatile uint32_t OCU_OCSB32;  ///< Offset: 0x11D - OCU ch.2/3 Control Register B
        volatile uint32_t OCU_OCSD32;  ///< Offset: 0x11E - OCU ch.2/3 Control Register D
        volatile uint32_t OCU_OCSA54;  ///< Offset: 0x120 - OCU ch.4/5 Control Register A
        volatile uint32_t OCU_OCSB54;  ///< Offset: 0x121 - OCU ch.4/5 Control Register B
        volatile uint32_t OCU_OCSD54;  ///< Offset: 0x122 - OCU ch.4/5 Control Register D
        volatile uint32_t OCU_OCSC;  ///< Offset: 0x125 - OCU Control Register C
        volatile uint32_t OCU_OCSE0;  ///< Offset: 0x128 - OCU ch.0 Control Register E
        volatile uint32_t OCU_OCSE1;  ///< Offset: 0x12C - OCU ch.1 Control Register E
        volatile uint32_t OCU_OCSE2;  ///< Offset: 0x130 - OCU ch.2 Control Register E
        volatile uint32_t OCU_OCSE3;  ///< Offset: 0x134 - OCU ch.3 Control Register E
        volatile uint32_t OCU_OCSE4;  ///< Offset: 0x138 - OCU ch.4 Control Register E
        volatile uint32_t OCU_OCSE5;  ///< Offset: 0x13C - OCU ch.5 Control Register E
        volatile uint32_t OCU_OCFS10;  ///< Offset: 0x168 - OCU ch.0/1 Connecting FRT Select Register
        volatile uint32_t OCU_OCFS32;  ///< Offset: 0x169 - OCU ch.2/3 Connecting FRT Select Register
        volatile uint32_t OCU_OCFS54;  ///< Offset: 0x16A - OCU ch.4/5 Connecting FRT Select Register
        volatile uint32_t WFG_WFTF10;  ///< Offset: 0x18E - Pulse Counter Value Register for WFG ch.0/1
        volatile uint32_t WFG_WFTA10;  ///< Offset: 0x190 - WFG Timer Value Register for WFG ch.0/1
        volatile uint32_t WFG_WFTB10;  ///< Offset: 0x192 - WFG Timer Value Register for WFG ch.0/1
        volatile uint32_t WFG_WFTF32;  ///< Offset: 0x196 - Pulse Counter Value Register for WFG ch.2/3
        volatile uint32_t WFG_WFTA32;  ///< Offset: 0x198 - WFG Timer Value Register for WFG ch.2/3
        volatile uint32_t WFG_WFTB32;  ///< Offset: 0x19A - WFG Timer Value Register for WFG ch.2/3
        volatile uint32_t WFG_WFTF54;  ///< Offset: 0x19E - Pulse Counter Value Register for WFG ch.4/5
        volatile uint32_t WFG_WFTA54;  ///< Offset: 0x1A0 - WFG Timer Value Register for WFG ch.4/5
        volatile uint32_t WFG_WFTB54;  ///< Offset: 0x1A2 - WFG Timer Value Register for WFG ch.4/5
        volatile uint32_t WFG_WFSA10;  ///< Offset: 0x1A4 - WFG Control Register A for WFG ch.0/1
        volatile uint32_t WFG_WFSA32;  ///< Offset: 0x1A8 - WFG Control Register A for WFG ch.2/3
        volatile uint32_t WFG_WFSA54;  ///< Offset: 0x1AC - WFG Control Register A for WFG ch.4/5
        volatile uint32_t WFG_WFIR;  ///< Offset: 0x1B0 - WFG Interrupt Control Register
        volatile uint32_t WFG_NZCL;  ///< Offset: 0x1B4 - NZCL Control Register
        volatile uint32_t ICU_ICFS10;  ///< Offset: 0x16C - ICU ch.0/1 Connecting FRT Select Register
        volatile uint32_t ICU_ICFS32;  ///< Offset: 0x16D - ICU ch.2/3 Connecting FRT Select Register
        volatile uint32_t ICU_ICCP0;  ///< Offset: 0x176 - ICU-ch.0 Capture Value Store Register
        volatile uint32_t ICU_ICCP1;  ///< Offset: 0x17A - ICU-ch.1 Capture Value Store Register
        volatile uint32_t ICU_ICCP2;  ///< Offset: 0x17E - ICU-ch.2 Capture Value Store Register
        volatile uint32_t ICU_ICCP3;  ///< Offset: 0x182 - ICU-ch.3 Capture Value Store Register
        volatile uint32_t ICU_ICSA10;  ///< Offset: 0x184 - ICU ch.0/1 Control Register A
        volatile uint32_t ICU_ICSB10;  ///< Offset: 0x185 - ICU ch.0/1 Control Register B
        volatile uint32_t ICU_ICSA32;  ///< Offset: 0x188 - ICU ch.2/3 Control Register A
        volatile uint32_t ICU_ICSB32;  ///< Offset: 0x189 - ICU ch.2/3 Control Register B
        volatile uint32_t ADCMP_ACFS10;  ///< Offset: 0x170 - ADCMP ch.0/1 Connecting FRT Select Register
        volatile uint32_t ADCMP_ACFS32;  ///< Offset: 0x171 - ADCMP ch.2/3 Connecting FRT Select Register
        volatile uint32_t ADCMP_ACFS54;  ///< Offset: 0x172 - ADCMP ch.4/5 Connecting FRT Select Register
        volatile uint32_t ADCMP_ACMP0;  ///< Offset: 0x1BA - ADCMP ch.0 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP1;  ///< Offset: 0x1BE - ADCMP ch.1 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP2;  ///< Offset: 0x1C2 - ADCMP ch.2 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP3;  ///< Offset: 0x1C6 - ADCMP ch.3 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP4;  ///< Offset: 0x1CA - ADCMP ch.4 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP5;  ///< Offset: 0x1CE - ADCMP ch.5 Compare Value Store Register
        volatile uint32_t ADCMP_ACSA;  ///< Offset: 0x1D0 - ADCMP Control Register A
        volatile uint32_t ADCMP_ACSC0;  ///< Offset: 0x1D4 - ADCMP ch.0 Control Register C
        volatile uint32_t ADCMP_ACSD0;  ///< Offset: 0x1D5 - ADCMP ch.0 Control Register D
        volatile uint32_t ADCMP_ACSC1;  ///< Offset: 0x1D8 - ADCMP ch.1 Control Register C
        volatile uint32_t ADCMP_ACSD1;  ///< Offset: 0x1D9 - ADCMP ch.1 Control Register D
        volatile uint32_t ADCMP_ACSC2;  ///< Offset: 0x1DC - ADCMP ch.2 Control Register C
        volatile uint32_t ADCMP_ACSD2;  ///< Offset: 0x1DD - ADCMP ch.2 Control Register D
        volatile uint32_t ADCMP_ACSC3;  ///< Offset: 0x1E0 - ADCMP ch.3 Control Register C
        volatile uint32_t ADCMP_ACSD3;  ///< Offset: 0x1E1 - ADCMP ch.3 Control Register D
        volatile uint32_t ADCMP_ACSC4;  ///< Offset: 0x1E4 - ADCMP ch.4 Control Register C
        volatile uint32_t ADCMP_ACSD4;  ///< Offset: 0x1E5 - ADCMP ch.4 Control Register D
        volatile uint32_t ADCMP_ACSC5;  ///< Offset: 0x1E8 - ADCMP ch.5 Control Register C
        volatile uint32_t ADCMP_ACSD5;  ///< Offset: 0x1E9 - ADCMP ch.5 Control Register D
    };

    /// Peripheral instances
    inline Registers* MFT0 = reinterpret_cast<Registers*>(MFT0_BASE);

    // Bit definitions
    /// FRT_TCSA0 Register bits
    namespace frt_tcsa0_bits {
        constexpr uint32_t ECKE = (1U << 15);  ///< Uses an external input clock (FRCK) as FRT's count clock
        constexpr uint32_t IRQZF = (1U << 14);  ///< Zero interrupt flag
        constexpr uint32_t IRQZE = (1U << 13);  ///< Generates interrupt@ when "1" is set to TCSA.IRQZF
        constexpr uint32_t ICLR = (1U << 9);  ///< Interrupt flag
        constexpr uint32_t ICRE = (1U << 8);  ///< Generates interrupt when "1" is set to TCSA.ICLR
        constexpr uint32_t BFE = (1U << 7);  ///< Enables TCCP's buffer function
        constexpr uint32_t STOP = (1U << 6);  ///< Puts FRT in stopping state
        constexpr uint32_t MODE = (1U << 5);  ///< FRT's count mode
        constexpr uint32_t SCLR = (1U << 4);  ///< FRT operation state initialization request
        constexpr uint32_t CLK = (4 << 0);  ///< FRT clock cycle
    }

    /// FRT_TCSC0 Register bits
    namespace frt_tcsc0_bits {
        constexpr uint32_t MSPC = (4 << 12);  ///< Reads the current counter value from a Peak value detection mask counter
        constexpr uint32_t MSZC = (4 << 8);  ///< Reads the current counter value from a Zero value detection mask counter
        constexpr uint32_t MSPI = (4 << 4);  ///< Sets the number of masked Peak value detections
        constexpr uint32_t MSZI = (4 << 0);  ///< Sets the number of masked Zero value detections
    }

    /// FRT_TCAL Register bits
    namespace frt_tcal_bits {
        constexpr uint32_t SCLR22 = (1U << 24);  ///< Mirror register of the SCLR bit located in TCSA2 register of MFT-unit2
        constexpr uint32_t SCLR21 = (1U << 23);  ///< Mirror register of the SCLR bit located in TCSA1 register of MFT-unit2
        constexpr uint32_t SCLR20 = (1U << 22);  ///< Mirror register of the SCLR bit located in TCSA0 register of MFT-unit2
        constexpr uint32_t SCLR12 = (1U << 21);  ///< Mirror register of the SCLR bit located in TCSA2 register of MFT-unit1
        constexpr uint32_t SCLR11 = (1U << 20);  ///< Mirror register of the SCLR bit located in TCSA1 register of MFT-unit1
        constexpr uint32_t SCLR10 = (1U << 19);  ///< Mirror register of the SCLR bit located in TCSA0 register of MFT-unit1
        constexpr uint32_t SCLR02 = (1U << 18);  ///< Mirror register of the SCLR bit located in TCSA2 register of MFT-unit0
        constexpr uint32_t SCLR01 = (1U << 17);  ///< Mirror register of the SCLR bit located in TCSA1 register of MFT-unit0
        constexpr uint32_t SCLR00 = (1U << 16);  ///< Mirror register of the SCLR bit located in TCSA0 register of MFT-unit0
        constexpr uint32_t STOP22 = (1U << 8);  ///< Mirror register of the STOP bit located in TCSA2 register of MFT-unit2
        constexpr uint32_t STOP21 = (1U << 7);  ///< Mirror register of the STOP bit located in TCSA1 register of MFT-unit2
        constexpr uint32_t STOP20 = (1U << 6);  ///< Mirror register of the STOP bit located in TCSA0 register of MFT-unit2
        constexpr uint32_t STOP12 = (1U << 5);  ///< Mirror register of the STOP bit located in TCSA2 register of MFT-unit1
        constexpr uint32_t STOP11 = (1U << 4);  ///< Mirror register of the STOP bit located in TCSA1 register of MFT-unit1
        constexpr uint32_t STOP10 = (1U << 3);  ///< Mirror register of the STOP bit located in TCSA0 register of MFT-unit1
        constexpr uint32_t STOP02 = (1U << 2);  ///< Mirror register of the STOP bit located in TCSA2 register of MFT-unit0
        constexpr uint32_t STOP01 = (1U << 1);  ///< Mirror register of the STOP bit located in TCSA1 register of MFT-unit0
        constexpr uint32_t STOP00 = (1U << 0);  ///< Mirror register of the STOP bit located in TCSA0 register of MFT-unit0
    }

    /// OCU_OCSA10 Register bits
    namespace ocu_ocsa10_bits {
        constexpr uint32_t IOP1 = (1U << 7);  ///< Indicates that a match has already been detected between FRT's count value and OCCP(1) value at OCU ch.(1).
        constexpr uint32_t IOP0 = (1U << 6);  ///< Indicates that a match has already been detected between FRT's count value and OCCP(0) value at OCU ch.(0).
        constexpr uint32_t IOE1 = (1U << 5);  ///< Generates interrupt@ when "1" is set to OCSA.IOP1
        constexpr uint32_t IOE0 = (1U << 4);  ///< Generates interrupt@ when "1" is set to OCSA.IOP0
        constexpr uint32_t CST1 = (1U << 1);  ///< Enables the operation of OCU ch.(1)
        constexpr uint32_t CST0 = (1U << 0);  ///< Enables the operation of OCU ch.(0)
    }

    /// OCU_OCSB10 Register bits
    namespace ocu_ocsb10_bits {
        constexpr uint32_t FM4 = (1U << 7);  ///< Selects FM4 mode for operating mode
        constexpr uint32_t CMOD = (1U << 4);  ///< Selects OCU's operation mode in combination with OCSC.MOD0 to MOD5
        constexpr uint32_t OTD1 = (1U << 1);  ///< Indicates that the RT(1) output pin is in the High-level output state.
        constexpr uint32_t OTD0 = (1U << 0);  ///< Indicates that the RT(0) output pin is in the High-level output state.
    }

    /// OCU_OCSD10 Register bits
    namespace ocu_ocsd10_bits {
        constexpr uint32_t OCSE1BUFE = (2 << 6);  ///< Enable buffer register function of OCSE(1)
        constexpr uint32_t OCSE0BUFE = (2 << 4);  ///< Enable buffer register function of OCSE(0)
        constexpr uint32_t OCCP1BUFE = (2 << 2);  ///< Enable buffer register function of OCCP(1)
        constexpr uint32_t OCCP0BUFE = (2 << 0);  ///< Enable buffer register function of OCCP(0)
    }

    /// OCU_OCSC Register bits
    namespace ocu_ocsc_bits {
        constexpr uint32_t MOD5 = (1U << 5);  ///< OCSC.MOD4 and OCSC.MOD5 determine the operation mode of OCU ch.4/ch.5 in combination with OCSB54.CMOD
        constexpr uint32_t MOD4 = (1U << 4);  ///< OCSC.MOD4 and OCSC.MOD5 determine the operation mode of OCU ch.4/ch.5 in combination with OCSB54.CMOD
        constexpr uint32_t MOD3 = (1U << 3);  ///< OCSC.MOD2 and OCSC.MOD3 determine the operation mode of OCU ch.2/ch.3 in combination with OCSB32.CMOD
        constexpr uint32_t MOD2 = (1U << 2);  ///< OCSC.MOD2 and OCSC.MOD3 determine the operation mode of OCU ch.2/ch.3 in combination with OCSB32.CMOD
        constexpr uint32_t MOD1 = (1U << 1);  ///< OCSC.MOD0 and OCSC.MOD1 determine the operation mode of OCU ch.0/ch.1 in combination with OCSB10.CMOD
        constexpr uint32_t MOD0 = (1U << 0);  ///< OCSC.MOD0 and OCSC.MOD1 determine the operation mode of OCU ch.0/ch.1 in combination with OCSB10.CMOD
    }

    /// OCU_OCSE0 Register bits
    namespace ocu_ocse0_bits {
        constexpr uint32_t OCSE = (16 << 0);  ///< Specify the setting conditions of the OCU's matching detection register (IOP0)
    }

    /// OCU_OCSE1 Register bits
    namespace ocu_ocse1_bits {
        constexpr uint32_t OCSE = (32 << 0);  ///< Specify the setting conditions of the OCU's matching detection register (IOP0/IOP1)
    }

    /// OCU_OCFS10 Register bits
    namespace ocu_ocfs10_bits {
        constexpr uint32_t FSO1 = (4 << 4);  ///< Connects FRT ch.x to OCU ch.1
        constexpr uint32_t FSO0 = (4 << 0);  ///< Connects FRT ch.x to OCU ch.0
    }

    /// WFG_WFSA10 Register bits
    namespace wfg_wfsa10_bits {
        constexpr uint32_t DMOD = (2 << 12);  ///< Specifies polarity for RTO(0) and RTO(1) signal outputs
        constexpr uint32_t PGEN = (2 << 10);  ///< Specifies how to reflect the CH_PPG signal for each channel of the WFG
        constexpr uint32_t PSEL = (2 << 8);  ///< Select the PPG timer unit to be used for each channel of the WFG
        constexpr uint32_t GTEN = (2 << 6);  ///< Selects the output conditions for the CH_GATE output signal of the WFG
        constexpr uint32_t TMD = (3 << 3);  ///< Select the WFG's operation mode
        constexpr uint32_t DCK = (3 << 0);  ///< Set the count clock cycle for the WFG timer and Pulse counter
    }

    /// WFG_WFIR Register bits
    namespace wfg_wfir_bits {
        constexpr uint32_t TMIS54 = (1U << 15);  ///< Stops the WFG54 reload timer and clears TMIF54
        constexpr uint32_t TMIE54 = (1U << 14);  ///< Starts WFG54 reload timer and checks the operation state of it
        constexpr uint32_t TMIC54 = (1U << 13);  ///< Clears TIMF54 bit
        constexpr uint32_t TMIF54 = (1U << 12);  ///< Detects the event of WFG54 reload timer interrupt occurrence
        constexpr uint32_t TMIS32 = (1U << 11);  ///< Stops the WFG32 reload timer and clears TMIF32
        constexpr uint32_t TMIE32 = (1U << 10);  ///< Starts WFG32 reload timer and checks the operation state of it
        constexpr uint32_t TMIC32 = (1U << 9);  ///< Clears TIMF32 bit
        constexpr uint32_t TMIF32 = (1U << 8);  ///< Detects the event of WFG32 reload timer interrupt occurrence
        constexpr uint32_t TMIS10 = (1U << 7);  ///< Stops the WFG10 reload timer and clears TMIF10
        constexpr uint32_t TMIE10 = (1U << 6);  ///< Starts WFG10 reload timer and checks the operation state of it
        constexpr uint32_t TMIC10 = (1U << 5);  ///< Clears TIMF10 bit
        constexpr uint32_t TMIF10 = (1U << 4);  ///< Detects the event of WFG10 reload timer interrupt occurrence
        constexpr uint32_t DTICB = (1U << 3);  ///< Clears DTIFB bit
        constexpr uint32_t DTIFB = (1U << 2);  ///< Detects DTTIX signal input via analog noise filter
        constexpr uint32_t DTICA = (1U << 1);  ///< Clears the DTIFA interrupt flag
        constexpr uint32_t DTIFA = (1U << 0);  ///< Detects the event of DTTIX signal input via digital noise-canceller
    }

    /// WFG_NZCL Register bits
    namespace wfg_nzcl_bits {
        constexpr uint32_t WIM54 = (1U << 14);  ///< Selects whether a WFG54 reload timer interrupt is masked when the WFIR.TMIF54 flag is set
        constexpr uint32_t WIM32 = (1U << 13);  ///< Selects whether a WFG32 reload timer interrupt is masked when the WFIR.TMIF32 flag is set
        constexpr uint32_t WIM10 = (1U << 12);  ///< Selects whether a WFG10 reload timer interrupt is masked when the WFIR.TMIF10 flag is set
        constexpr uint32_t DIMB = (1U << 9);  ///< Selects whether a DTIF interrupt is masked when the WFIR.TIFDTIFB flag is set
        constexpr uint32_t DIMA = (1U << 8);  ///< Selects whether a DTIF interrupt is masked when the WFIR.DTIFA flag is set
        constexpr uint32_t DTIEB = (1U << 5);  ///< Selects whether to set the WFIR.DTIFB flag for the path from the DTTIX pin for input signal to an analog noise filter
        constexpr uint32_t SDTI = (1U << 4);  ///< Sets the WFIR.DTIFA register by writing to the register from the CPU
        constexpr uint32_t NWS = (3 << 1);  ///< Set the noise-canceling width for a digital noise-canceller
        constexpr uint32_t DTIEA = (1U << 0);  ///< Selects whether the WFIR.DTIFA register is set for the path via digital noise filter from the DTTIX input pin
    }

    /// ICU_ICFS10 Register bits
    namespace icu_icfs10_bits {
        constexpr uint32_t FSI1 = (4 << 4);  ///< Connects FRT ch.x to ICU ch.(1)
        constexpr uint32_t FSI0 = (4 << 0);  ///< Connects FRT ch.x to ICU ch.(0)
    }

    /// ICU_ICSA10 Register bits
    namespace icu_icsa10_bits {
        constexpr uint32_t ICP1 = (1U << 7);  ///< Indicates that a valid edge has been detected at ICU ch.(1) and the capture operation has been performed
        constexpr uint32_t ICP0 = (1U << 6);  ///< Indicates that a valid edge has been detected at ICU ch.(0) and the capture operation has been performed
        constexpr uint32_t ICE1 = (1U << 5);  ///< Generates interrupt@ when "1" is set to ICSA.ICP1.
        constexpr uint32_t ICE0 = (1U << 4);  ///< Generates interrupt@ when "1" is set to ICSA.ICP0.
        constexpr uint32_t EG1 = (2 << 2);  ///< Enables/disables the operation of ICU-ch.(1) and selects a valid edge(s)
        constexpr uint32_t EG0 = (2 << 0);  ///< Enables/disables the operation of ICU-ch.(0) and selects a valid edge(s)
    }

    /// ICU_ICSB10 Register bits
    namespace icu_icsb10_bits {
        constexpr uint32_t IEI1 = (1U << 1);  ///< Indicates the latest valid edge of ICU ch.(1)
        constexpr uint32_t IEI0 = (1U << 0);  ///< Indicates the latest valid edge of ICU ch.(0)
    }

    /// ADCMP_ACFS10 Register bits
    namespace adcmp_acfs10_bits {
        constexpr uint32_t FSA1 = (4 << 4);  ///< Specify the FRT to be connected to ADCMP ch.(1)
        constexpr uint32_t FSA0 = (4 << 0);  ///< Specify the FRT to be connected to ADCMP ch.(0)
    }

    /// ADCMP_ACMP0 Register bits
    namespace adcmp_acmp0_bits {
        constexpr uint32_t ACMP = (16 << 0);  ///< Specifies an AD conversion start time
    }

    /// ADCMP_ACSA Register bits
    namespace adcmp_acsa_bits {
        constexpr uint32_t SEL54 = (2 << 12);  ///< Selects compatible operation of ADCMP ch.5 and ch.4 with FM3 Family products
        constexpr uint32_t SEL32 = (2 << 10);  ///< Selects compatible operation of ADCMP ch.3 and ch.2 with FM3 Family products
        constexpr uint32_t SEL10 = (2 << 8);  ///< Selects compatible operation of ADCMP ch.1 and ch.0 with FM3 Family products
        constexpr uint32_t CE54 = (2 << 4);  ///< Enables/disables compatibility of ADCMP ch.5 and ch.4 with FM3 Family products
        constexpr uint32_t CE32 = (2 << 2);  ///< Enables/disables compatibility of ADCMP ch.3 and ch.2 with FM3 Family products
        constexpr uint32_t CE10 = (2 << 0);  ///< Enables/disables compatibility of ADCMP ch.1 and ch.0 with FM3 Family products
    }

    /// ADCMP_ACSC0 Register bits
    namespace adcmp_acsc0_bits {
        constexpr uint32_t ADSEL = (3 << 2);  ///< Specify the destinations of ADC start signals that are output by ADCMP
        constexpr uint32_t BUFE = (2 << 0);  ///< Select enable/disable and transfer timing for buffer function of the ACMP register
    }

    /// ADCMP_ACSD0 Register bits
    namespace adcmp_acsd0_bits {
        constexpr uint32_t ZE = (1U << 7);  ///< Enables/disables the operation of the ADCMP when the FRT is "0x0000"
        constexpr uint32_t UE = (1U << 6);  ///< Enables/disables the operation of the ADCMP that is counting up for the connected FRT
        constexpr uint32_t PE = (1U << 5);  ///< Enables/disables the operation of the ADCMP that is counting down at the Peak value of the connected FRT
        constexpr uint32_t DE = (1U << 4);  ///< Enables/disables the operation of the ADCMP that is counting down for the connected FRT
        constexpr uint32_t OCUS = (1U << 1);  ///< Selects the OCU OCCP register that will become the start for offset start
        constexpr uint32_t AMOD = (1U << 0);  ///< Selects operation mode for ADCMP
    }

}

// ============================================================================
// MFT Peripheral
// ============================================================================

namespace mft {
    /// Base addresses
    constexpr uint32_t MFT_PPG_BASE = 0x40024000;

    /// MFT Register structure
    struct Registers {
        volatile uint32_t TTCR0;  ///< Offset: 0x00 - PPG Start Trigger Control Register 0
        volatile uint32_t TTCR1;  ///< Offset: 0x20 - PPG Start Trigger Control Register 1
        volatile uint32_t TTCR2;  ///< Offset: 0x40 - PPG Start Trigger Control Register 2
        volatile uint32_t COMP0;  ///< Offset: 0x09 - PPG Compare Register 0
        volatile uint32_t COMP2;  ///< Offset: 0x0C - PPG Compare Register 2
        volatile uint32_t COMP4;  ///< Offset: 0x11 - PPG Compare Register 4
        volatile uint32_t COMP6;  ///< Offset: 0x14 - PPG Compare Register 6
        volatile uint32_t COMP1;  ///< Offset: 0x29 - PPG Compare Register 1
        volatile uint32_t COMP3;  ///< Offset: 0x2C - PPG Compare Register 3
        volatile uint32_t COMP5;  ///< Offset: 0x31 - PPG Compare Register 5
        volatile uint32_t COMP7;  ///< Offset: 0x34 - PPG Compare Register 7
        volatile uint32_t COMP8;  ///< Offset: 0x49 - PPG Compare Register 8
        volatile uint32_t COMP10;  ///< Offset: 0x4C - PPG Compare Register 10
        volatile uint32_t COMP12;  ///< Offset: 0x51 - PPG Compare Register 12
        volatile uint32_t COMP14;  ///< Offset: 0x54 - PPG Compare Register 14
        volatile uint32_t TRG0;  ///< Offset: 0x100 - PPG Start Register 0
        volatile uint32_t TRG1;  ///< Offset: 0x140 - PPG Start Register 1
        volatile uint32_t REVC0;  ///< Offset: 0x104 - Output Reverse Register 0
        volatile uint32_t REVC1;  ///< Offset: 0x144 - Output Reverse Register 1
        volatile uint32_t PPGC0;  ///< Offset: 0x201 - PPG Operation Mode Control Register 0
        volatile uint32_t PPGC1;  ///< Offset: 0x200 - PPG Operation Mode Control Register 1
        volatile uint32_t PPGC2;  ///< Offset: 0x205 - PPG Operation Mode Control Register 2
        volatile uint32_t PPGC3;  ///< Offset: 0x204 - PPG Operation Mode Control Register 3
        volatile uint32_t PPGC4;  ///< Offset: 0x241 - PPG Operation Mode Control Register 4
        volatile uint32_t PPGC5;  ///< Offset: 0x240 - PPG Operation Mode Control Register 5
        volatile uint32_t PPGC6;  ///< Offset: 0x245 - PPG Operation Mode Control Register 6
        volatile uint32_t PPGC7;  ///< Offset: 0x244 - PPG Operation Mode Control Register 7
        volatile uint32_t PPGC8;  ///< Offset: 0x281 - PPG Operation Mode Control Register 8
        volatile uint32_t PPGC9;  ///< Offset: 0x280 - PPG Operation Mode Control Register 9
        volatile uint32_t PPGC10;  ///< Offset: 0x285 - PPG Operation Mode Control Register 10
        volatile uint32_t PPGC11;  ///< Offset: 0x284 - PPG Operation Mode Control Register 11
        volatile uint32_t PPGC12;  ///< Offset: 0x2C1 - PPG Operation Mode Control Register 12
        volatile uint32_t PPGC13;  ///< Offset: 0x2C0 - PPG Operation Mode Control Register 13
        volatile uint32_t PPGC14;  ///< Offset: 0x2C5 - PPG Operation Mode Control Register 14
        volatile uint32_t PPGC15;  ///< Offset: 0x2C4 - PPG Operation Mode Control Register 15
        volatile uint32_t PPGC16;  ///< Offset: 0x301 - PPG Operation Mode Control Register 16
        volatile uint32_t PPGC17;  ///< Offset: 0x300 - PPG Operation Mode Control Register 17
        volatile uint32_t PPGC18;  ///< Offset: 0x305 - PPG Operation Mode Control Register 18
        volatile uint32_t PPGC19;  ///< Offset: 0x304 - PPG Operation Mode Control Register 19
        volatile uint32_t PPGC20;  ///< Offset: 0x341 - PPG Operation Mode Control Register 20
        volatile uint32_t PPGC21;  ///< Offset: 0x340 - PPG Operation Mode Control Register 21
        volatile uint32_t PPGC22;  ///< Offset: 0x345 - PPG Operation Mode Control Register 22
        volatile uint32_t PPGC23;  ///< Offset: 0x344 - PPG Operation Mode Control Register 23
        volatile uint32_t PRLH0;  ///< Offset: 0x209 - PPG0 Reload Registers High
        volatile uint32_t PRLL0;  ///< Offset: 0x208 - PPG0 Reload Registers Low
        volatile uint32_t PRLH1;  ///< Offset: 0x20D - PPG1 Reload Registers High
        volatile uint32_t PRLL1;  ///< Offset: 0x20C - PPG1 Reload Registers Low
        volatile uint32_t PRLH2;  ///< Offset: 0x211 - PPG2 Reload Registers High
        volatile uint32_t PRLL2;  ///< Offset: 0x210 - PPG2 Reload Registers Low
        volatile uint32_t PRLH3;  ///< Offset: 0x215 - PPG3 Reload Registers High
        volatile uint32_t PRLL3;  ///< Offset: 0x214 - PPG3 Reload Registers Low
        volatile uint32_t PRLH4;  ///< Offset: 0x249 - PPG4 Reload Registers High
        volatile uint32_t PRLL4;  ///< Offset: 0x248 - PPG4 Reload Registers Low
        volatile uint32_t PRLH5;  ///< Offset: 0x24D - PPG5 Reload Registers High
        volatile uint32_t PRLL5;  ///< Offset: 0x24C - PPG5 Reload Registers Low
        volatile uint32_t PRLH6;  ///< Offset: 0x251 - PPG6 Reload Registers High
        volatile uint32_t PRLL6;  ///< Offset: 0x250 - PPG6 Reload Registers Low
        volatile uint32_t PRLH7;  ///< Offset: 0x255 - PPG7 Reload Registers High
        volatile uint32_t PRLL7;  ///< Offset: 0x254 - PPG7 Reload Registers Low
        volatile uint32_t PRLH8;  ///< Offset: 0x289 - PPG8 Reload Registers High
        volatile uint32_t PRLL8;  ///< Offset: 0x288 - PPG8 Reload Registers Low
        volatile uint32_t PRLH9;  ///< Offset: 0x28D - PPG9 Reload Registers High
        volatile uint32_t PRLL9;  ///< Offset: 0x28C - PPG9 Reload Registers Low
        volatile uint32_t PRLH10;  ///< Offset: 0x291 - PPG10 Reload Registers High
        volatile uint32_t PRLL10;  ///< Offset: 0x290 - PPG10 Reload Registers Low
        volatile uint32_t PRLH11;  ///< Offset: 0x295 - PPG11 Reload Registers High
        volatile uint32_t PRLL11;  ///< Offset: 0x294 - PPG11 Reload Registers Low
        volatile uint32_t PRLH12;  ///< Offset: 0x2C9 - PPG12 Reload Registers High
        volatile uint32_t PRLL12;  ///< Offset: 0x2C8 - PPG12 Reload Registers Low
        volatile uint32_t PRLH13;  ///< Offset: 0x2CD - PPG13 Reload Registers High
        volatile uint32_t PRLL13;  ///< Offset: 0x2CC - PPG13 Reload Registers Low
        volatile uint32_t PRLH14;  ///< Offset: 0x2D1 - PPG14 Reload Registers High
        volatile uint32_t PRLL14;  ///< Offset: 0x2D0 - PPG14 Reload Registers Low
        volatile uint32_t PRLH15;  ///< Offset: 0x2D5 - PPG15 Reload Registers High
        volatile uint32_t PRLL15;  ///< Offset: 0x2D4 - PPG15 Reload Registers Low
        volatile uint32_t PRLH16;  ///< Offset: 0x309 - PPG16 Reload Registers High
        volatile uint32_t PRLL16;  ///< Offset: 0x308 - PPG16 Reload Registers Low
        volatile uint32_t PRLH17;  ///< Offset: 0x30D - PPG17 Reload Registers High
        volatile uint32_t PRLL17;  ///< Offset: 0x30C - PPG17 Reload Registers Low
        volatile uint32_t PRLH18;  ///< Offset: 0x311 - PPG18 Reload Registers High
        volatile uint32_t PRLL18;  ///< Offset: 0x310 - PPG18 Reload Registers Low
        volatile uint32_t PRLH19;  ///< Offset: 0x315 - PPG19 Reload Registers High
        volatile uint32_t PRLL19;  ///< Offset: 0x314 - PPG19 Reload Registers Low
        volatile uint32_t PRLH20;  ///< Offset: 0x349 - PPG20 Reload Registers High
        volatile uint32_t PRLL20;  ///< Offset: 0x348 - PPG20 Reload Registers Low
        volatile uint32_t PRLH21;  ///< Offset: 0x34D - PPG21 Reload Registers High
        volatile uint32_t PRLL21;  ///< Offset: 0x34C - PPG21 Reload Registers Low
        volatile uint32_t PRLH22;  ///< Offset: 0x351 - PPG22 Reload Registers High
        volatile uint32_t PRLL22;  ///< Offset: 0x350 - PPG22 Reload Registers Low
        volatile uint32_t PRLH23;  ///< Offset: 0x355 - PPG23 Reload Registers High
        volatile uint32_t PRLL23;  ///< Offset: 0x354 - PPG23 Reload Registers Low
        volatile uint32_t GATEC0;  ///< Offset: 0x218 - PPG Gate Function Control Register 0
        volatile uint32_t GATEC4;  ///< Offset: 0x258 - PPG Gate Function Control Register 4
        volatile uint32_t GATEC8;  ///< Offset: 0x298 - PPG Gate Function Control Register 8
        volatile uint32_t GATEC12;  ///< Offset: 0x2D8 - PPG Gate Function Control Register 12
        volatile uint32_t GATEC16;  ///< Offset: 0x318 - PPG Gate Function Control Register 16
        volatile uint32_t GATEC20;  ///< Offset: 0x358 - PPG Gate Function Control Register 20
        volatile uint32_t IGBTC;  ///< Offset: 0x380 - IGBT Mode Control Register
    };

    /// Peripheral instances
    inline Registers* MFT_PPG = reinterpret_cast<Registers*>(MFT_PPG_BASE);

    // Bit definitions
    /// TTCR0 Register bits
    namespace ttcr0_bits {
        constexpr uint32_t TRG6O = (1U << 15);  ///< PPG6 trigger stop bit
        constexpr uint32_t TRG4O = (1U << 14);  ///< PPG4 trigger stop bit
        constexpr uint32_t TRG2O = (1U << 13);  ///< PPG2 trigger stop bit
        constexpr uint32_t TRG0O = (1U << 12);  ///< PPG0 trigger stop bit
        constexpr uint32_t CS0 = (2 << 10);  ///< 8-bit UP counter clock select bits for comparison
        constexpr uint32_t MONI0 = (1U << 9);  ///< 8-bit UP counter operation state monitor bit for comparison
        constexpr uint32_t STR0 = (1U << 8);  ///< 8-bit UP counter operation enable bit for comparison
    }

    /// TTCR1 Register bits
    namespace ttcr1_bits {
        constexpr uint32_t TRG7O = (1U << 15);  ///< PPG7 trigger stop bit
        constexpr uint32_t TRG5O = (1U << 14);  ///< PPG5 trigger stop bit
        constexpr uint32_t TRG3O = (1U << 13);  ///< PPG3 trigger stop bit
        constexpr uint32_t TRG1O = (1U << 12);  ///< PPG1 trigger stop bit
        constexpr uint32_t CS1 = (2 << 10);  ///< 8-bit UP counter clock select bits for comparison
        constexpr uint32_t MONI1 = (1U << 9);  ///< 8-bit UP counter operation state monitor bit for comparison
        constexpr uint32_t STR1 = (1U << 8);  ///< 8-bit UP counter operation enable bit for comparison
    }

    /// TTCR2 Register bits
    namespace ttcr2_bits {
        constexpr uint32_t TRG22O = (1U << 15);  ///< PPG22 trigger stop bit
        constexpr uint32_t TRG20O = (1U << 14);  ///< PPG20 trigger stop bit
        constexpr uint32_t TRG18O = (1U << 13);  ///< PPG18 trigger stop bit
        constexpr uint32_t TRG16O = (1U << 12);  ///< PPG16 trigger stop bit
        constexpr uint32_t CS2 = (2 << 10);  ///< 8-bit UP counter clock select bits for comparison
        constexpr uint32_t MONI2 = (1U << 9);  ///< 8-bit UP counter operation state monitor bit for comparison
        constexpr uint32_t STR2 = (1U << 8);  ///< 8-bit UP counter operation enable bit for comparison
    }

    /// TRG0 Register bits
    namespace trg0_bits {
        constexpr uint32_t PEN15 = (1U << 15);  ///< PPG15 Start Trigger bit
        constexpr uint32_t PEN14 = (1U << 14);  ///< PPG14 Start Trigger bit
        constexpr uint32_t PEN13 = (1U << 13);  ///< PPG13 Start Trigger bit
        constexpr uint32_t PEN12 = (1U << 12);  ///< PPG12 Start Trigger bit
        constexpr uint32_t PEN11 = (1U << 11);  ///< PPG11 Start Trigger bit
        constexpr uint32_t PEN10 = (1U << 10);  ///< PPG10 Start Trigger bit
        constexpr uint32_t PEN09 = (1U << 9);  ///< PPG9 Start Trigger bit
        constexpr uint32_t PEN08 = (1U << 8);  ///< PPG8 Start Trigger bit
        constexpr uint32_t PEN07 = (1U << 7);  ///< PPG7 Start Trigger bit
        constexpr uint32_t PEN06 = (1U << 6);  ///< PPG6 Start Trigger bit
        constexpr uint32_t PEN05 = (1U << 5);  ///< PPG5 Start Trigger bit
        constexpr uint32_t PEN04 = (1U << 4);  ///< PPG4 Start Trigger bit
        constexpr uint32_t PEN03 = (1U << 3);  ///< PPG3 Start Trigger bit
        constexpr uint32_t PEN02 = (1U << 2);  ///< PPG2 Start Trigger bit
        constexpr uint32_t PEN01 = (1U << 1);  ///< PPG1 Start Trigger bit
        constexpr uint32_t PEN00 = (1U << 0);  ///< PPG0 Start Trigger bit
    }

    /// TRG1 Register bits
    namespace trg1_bits {
        constexpr uint32_t PEN23 = (1U << 7);  ///< PPG23 Start Trigger bit
        constexpr uint32_t PEN22 = (1U << 6);  ///< PPG22 Start Trigger bit
        constexpr uint32_t PEN21 = (1U << 5);  ///< PPG21 Start Trigger bit
        constexpr uint32_t PEN20 = (1U << 4);  ///< PPG20 Start Trigger bit
        constexpr uint32_t PEN19 = (1U << 3);  ///< PPG19 Start Trigger bit
        constexpr uint32_t PEN18 = (1U << 2);  ///< PPG18 Start Trigger bit
        constexpr uint32_t PEN17 = (1U << 1);  ///< PPG17 Start Trigger bit
        constexpr uint32_t PEN16 = (1U << 0);  ///< PPG16 Start Trigger bit
    }

    /// REVC0 Register bits
    namespace revc0_bits {
        constexpr uint32_t REV15 = (1U << 15);  ///< PPG15 Output Reverse Enable bit
        constexpr uint32_t REV14 = (1U << 14);  ///< PPG14 Output Reverse Enable bit
        constexpr uint32_t REV13 = (1U << 13);  ///< PPG13 Output Reverse Enable bit
        constexpr uint32_t REV12 = (1U << 12);  ///< PPG12 Output Reverse Enable bit
        constexpr uint32_t REV11 = (1U << 11);  ///< PPG11 Output Reverse Enable bit
        constexpr uint32_t REV10 = (1U << 10);  ///< PPG10 Output Reverse Enable bit
        constexpr uint32_t REV09 = (1U << 9);  ///< PPG9 Output Reverse Enable bit
        constexpr uint32_t REV08 = (1U << 8);  ///< PPG8 Output Reverse Enable bit
        constexpr uint32_t REV07 = (1U << 7);  ///< PPG7 Output Reverse Enable bit
        constexpr uint32_t REV06 = (1U << 6);  ///< PPG6 Output Reverse Enable bit
        constexpr uint32_t REV05 = (1U << 5);  ///< PPG5 Output Reverse Enable bit
        constexpr uint32_t REV04 = (1U << 4);  ///< PPG4 Output Reverse Enable bit
        constexpr uint32_t REV03 = (1U << 3);  ///< PPG3 Output Reverse Enable bit
        constexpr uint32_t REV02 = (1U << 2);  ///< PPG2 Output Reverse Enable bit
        constexpr uint32_t REV01 = (1U << 1);  ///< PPG1 Output Reverse Enable bit
        constexpr uint32_t REV00 = (1U << 0);  ///< PPG0 Output Reverse Enable bit
    }

    /// REVC1 Register bits
    namespace revc1_bits {
        constexpr uint32_t REV23 = (1U << 7);  ///< PPG23 Output Reverse Enable bit
        constexpr uint32_t REV22 = (1U << 6);  ///< PPG22 Output Reverse Enable bit
        constexpr uint32_t REV21 = (1U << 5);  ///< PPG21 Output Reverse Enable bit
        constexpr uint32_t REV20 = (1U << 4);  ///< PPG20 Output Reverse Enable bit
        constexpr uint32_t REV19 = (1U << 3);  ///< PPG19 Output Reverse Enable bit
        constexpr uint32_t REV18 = (1U << 2);  ///< PPG18 Output Reverse Enable bit
        constexpr uint32_t REV17 = (1U << 1);  ///< PPG17 Output Reverse Enable bit
        constexpr uint32_t REV16 = (1U << 0);  ///< PPG16 Output Reverse Enable bit
    }

    /// PPGC0 Register bits
    namespace ppgc0_bits {
        constexpr uint32_t PIE = (1U << 7);  ///< PPG Interrupt Enable bit
        constexpr uint32_t PUF = (1U << 6);  ///< PPG Counter Underflow bit
        constexpr uint32_t INTM = (1U << 5);  ///< Interrupt Mode Select bit
        constexpr uint32_t PCS = (2 << 3);  ///< PPG DOWN Counter Operation Clock Select bits
        constexpr uint32_t MD = (2 << 1);  ///< PPG Operation Mode Set bits
        constexpr uint32_t TTRG = (1U << 0);  ///< PPG start trigger select bit
    }

    /// PPGC1 Register bits
    namespace ppgc1_bits {
        constexpr uint32_t PIE = (1U << 7);  ///< PPG Interrupt Enable bit
        constexpr uint32_t PUF = (1U << 6);  ///< PPG Counter Underflow bit
        constexpr uint32_t INTM = (1U << 5);  ///< Interrupt Mode Select bit
        constexpr uint32_t PCS = (2 << 3);  ///< PPG DOWN Counter Operation Clock Select bits
        constexpr uint32_t MD = (2 << 1);  ///< PPG Operation Mode Set bits
    }

    /// PRLH0 Register bits
    namespace prlh0_bits {
        constexpr uint32_t PRLH = (8 << 0);  ///< Reload Registers High
    }

    /// PRLL0 Register bits
    namespace prll0_bits {
        constexpr uint32_t PRLL = (8 << 0);  ///< Reload Registers Low
    }

    /// GATEC0 Register bits
    namespace gatec0_bits {
        constexpr uint32_t STRG2 = (1U << 5);  ///< Select trigger bit for PPG2
        constexpr uint32_t EDGE2 = (1U << 4);  ///< Start Effective Level Select bit for PPG2
        constexpr uint32_t STRG0 = (1U << 1);  ///< Select trigger bit for PPG0
        constexpr uint32_t EDGE0 = (1U << 0);  ///< Start Effective Level Select bit for PPG0
    }

    /// GATEC4 Register bits
    namespace gatec4_bits {
        constexpr uint32_t STRG6 = (1U << 5);  ///< Select trigger bit for PPG6
        constexpr uint32_t EDGE6 = (1U << 4);  ///< Start Effective Level Select bit for PPG6
        constexpr uint32_t STRG4 = (1U << 1);  ///< Select trigger bit for PPG4
        constexpr uint32_t EDGE4 = (1U << 0);  ///< Start Effective Level Select bit for PPG4
    }

    /// GATEC8 Register bits
    namespace gatec8_bits {
        constexpr uint32_t STRG10 = (1U << 5);  ///< Select trigger bit for PPG10
        constexpr uint32_t EDGE10 = (1U << 4);  ///< Start Effective Level Select bit for PPG10
        constexpr uint32_t STRG8 = (1U << 1);  ///< Select trigger bit for PPG8
        constexpr uint32_t EDGE8 = (1U << 0);  ///< Start Effective Level Select bit for PPG8
    }

    /// GATEC12 Register bits
    namespace gatec12_bits {
        constexpr uint32_t STRG14 = (1U << 5);  ///< Select trigger bit for PPG14
        constexpr uint32_t EDGE14 = (1U << 4);  ///< Start Effective Level Select bit for PPG14
        constexpr uint32_t STRG12 = (1U << 1);  ///< Select trigger bit for PPG12
        constexpr uint32_t EDGE12 = (1U << 0);  ///< Start Effective Level Select bit for PPG12
    }

    /// GATEC16 Register bits
    namespace gatec16_bits {
        constexpr uint32_t STRG18 = (1U << 5);  ///< Select trigger bit for PPG18
        constexpr uint32_t EDGE18 = (1U << 4);  ///< Start Effective Level Select bit for PPG18
        constexpr uint32_t STRG16 = (1U << 1);  ///< Select trigger bit for PPG16
        constexpr uint32_t EDGE16 = (1U << 0);  ///< Start Effective Level Select bit for PPG16
    }

    /// GATEC20 Register bits
    namespace gatec20_bits {
        constexpr uint32_t STRG22 = (1U << 5);  ///< Select trigger bit for PPG22
        constexpr uint32_t EDGE22 = (1U << 4);  ///< Start Effective Level Select bit for PPG22
        constexpr uint32_t STRG20 = (1U << 1);  ///< Select trigger bit for PPG20
        constexpr uint32_t EDGE20 = (1U << 0);  ///< Start Effective Level Select bit for PPG20
    }

    /// IGBTC Register bits
    namespace igbtc_bits {
        constexpr uint32_t IGATIH = (1U << 7);  ///< Stop prohibition mode selection in output active bit
        constexpr uint32_t IGNFW = (3 << 4);  ///< Noise filter width selection bit
        constexpr uint32_t IGOSEL = (2 << 2);  ///< Output level selection bit
        constexpr uint32_t IGTRGLV = (1U << 1);  ///< Trigger input level selection bit
        constexpr uint32_t IGBTMD = (1U << 0);  ///< IGBT mode selection bit
    }

}

// ============================================================================
// BT0 Peripheral
// ============================================================================

namespace bt0 {
    /// Base addresses
    constexpr uint32_t BT0_BASE = 0x40025000;

    /// BT0 Register structure
    struct Registers {
        volatile uint32_t PWM_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PWM_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PWM_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PWM_PCSR;  ///< Offset: 0x00 - PWM Cycle Set Register
        volatile uint32_t PWM_PDUT;  ///< Offset: 0x04 - PWM Duty Set Register
        volatile uint32_t PWM_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t PPG_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PPG_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PPG_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PPG_PRLL;  ///< Offset: 0x00 - LOW Width Reload Register
        volatile uint32_t PPG_PRLH;  ///< Offset: 0x04 - HIGH Width Reload Register
        volatile uint32_t PPG_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t RT_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t RT_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t RT_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t RT_PCSR;  ///< Offset: 0x00 - Cycle Set Register
        volatile uint32_t RT_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t PWC_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PWC_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PWC_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PWC_DTBF;  ///< Offset: 0x04 - Data Buffer Register
    };

    /// Peripheral instances
    inline Registers* BT0 = reinterpret_cast<Registers*>(BT0_BASE);

    // Bit definitions
    /// PWM_TMCR Register bits
    namespace pwm_tmcr_bits {
        constexpr uint32_t CKS = (3 << 12);  ///< Count clock selection bits
        constexpr uint32_t RTGEN = (1U << 11);  ///< Restart enable bit
        constexpr uint32_t PMSK = (1U << 10);  ///< Pulse output mask bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Count operation enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// PWM_TMCR2 Register bits
    namespace pwm_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PWM_STC Register bits
    namespace pwm_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t DTIE = (1U << 5);  ///< Duty match interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t DTIR = (1U << 1);  ///< Duty match interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// PPG_TMCR Register bits
    namespace ppg_tmcr_bits {
        constexpr uint32_t CKS = (3 << 12);  ///< Count clock selection bits
        constexpr uint32_t RTGEN = (1U << 11);  ///< Restart enable bit
        constexpr uint32_t PMSK = (1U << 10);  ///< Pulse output mask bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Count operation enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// PPG_TMCR2 Register bits
    namespace ppg_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PPG_STC Register bits
    namespace ppg_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// RT_TMCR Register bits
    namespace rt_tmcr_bits {
        constexpr uint32_t CKS = (3 << 12);  ///< Count clock selection bits
        constexpr uint32_t EGS = (2 << 8);  ///< Slection bits of trigger input edge and gate function level
        constexpr uint32_t T32 = (1U << 7);  ///< 32-bit timer selection bit
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Timer enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// RT_TMCR2 Register bits
    namespace rt_tmcr2_bits {
        constexpr uint32_t GATE = (1U << 7);  ///< Gate Input Enable bit
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// RT_STC Register bits
    namespace rt_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// PWC_TMCR Register bits
    namespace pwc_tmcr_bits {
        constexpr uint32_t CKS = (3 << 12);  ///< Count clock selection bits
        constexpr uint32_t EGS = (3 << 8);  ///< Measurement edge selection bits
        constexpr uint32_t T32 = (1U << 7);  ///< 32-bit timer selection bit
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Timer enable bit
    }

    /// PWC_TMCR2 Register bits
    namespace pwc_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PWC_STC Register bits
    namespace pwc_stc_bits {
        constexpr uint32_t ERR = (1U << 7);  ///< Error flag bit
        constexpr uint32_t EDIE = (1U << 6);  ///< Measurement completion interrupt request enable bit
        constexpr uint32_t OVIE = (1U << 4);  ///< Overflow interrupt request enable bit
        constexpr uint32_t EDIR = (1U << 2);  ///< Measurement completion interrupt request bit
        constexpr uint32_t OVIR = (1U << 0);  ///< Overflow interrupt request bit
    }

}

// ============================================================================
// BT1 Peripheral
// ============================================================================

namespace bt1 {
    /// Base addresses
    constexpr uint32_t BT1_BASE = 0x40025040;

    /// BT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT1 = reinterpret_cast<Registers*>(BT1_BASE);

}

// ============================================================================
// BT2 Peripheral
// ============================================================================

namespace bt2 {
    /// Base addresses
    constexpr uint32_t BT2_BASE = 0x40025080;

    /// BT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT2 = reinterpret_cast<Registers*>(BT2_BASE);

}

// ============================================================================
// BT3 Peripheral
// ============================================================================

namespace bt3 {
    /// Base addresses
    constexpr uint32_t BT3_BASE = 0x400250C0;

    /// BT3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT3 = reinterpret_cast<Registers*>(BT3_BASE);

}

// ============================================================================
// BTIOSEL03 Peripheral
// ============================================================================

namespace btiosel03 {
    /// Base addresses
    constexpr uint32_t BTIOSEL03_BASE = 0x40025100;

    /// BTIOSEL03 Register structure
    struct Registers {
        volatile uint32_t BTSEL0123;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSEL03 = reinterpret_cast<Registers*>(BTIOSEL03_BASE);

    // Bit definitions
    /// BTSEL0123 Register bits
    namespace btsel0123_bits {
        constexpr uint32_t SEL23 = (4 << 12);  ///< I/O select bits for Ch.2/Ch.3
        constexpr uint32_t SEL01 = (4 << 8);  ///< I/O select bits for Ch.0/Ch.1
    }

}

// ============================================================================
// SBSSR Peripheral
// ============================================================================

namespace sbssr {
    /// Base addresses
    constexpr uint32_t SBSSR_BASE = 0x40025F00;

    /// SBSSR Register structure
    struct Registers {
        volatile uint32_t BTSSSR;  ///< Offset: 0xFC - Software-based Simultaneous Startup Register
    };

    /// Peripheral instances
    inline Registers* SBSSR = reinterpret_cast<Registers*>(SBSSR_BASE);

    // Bit definitions
    /// BTSSSR Register bits
    namespace btsssr_bits {
        constexpr uint32_t SSSR3 = (1U << 3);  ///< Software-based simultaneous startup bit of Ch.3
        constexpr uint32_t SSSR2 = (1U << 2);  ///< Software-based simultaneous startup bit of Ch.2
        constexpr uint32_t SSSR1 = (1U << 1);  ///< Software-based simultaneous startup bit of Ch.1
        constexpr uint32_t SSSR0 = (1U << 0);  ///< Software-based simultaneous startup bit of Ch.0
    }

}

// ============================================================================
// QPRC0 Peripheral
// ============================================================================

namespace qprc0 {
    /// Base addresses
    constexpr uint32_t QPRC0_BASE = 0x40026000;
    constexpr uint32_t QPRC0_NF_BASE = 0x40026100;

    /// QPRC0 Register structure
    struct Registers {
        volatile uint32_t QPCR;  ///< Offset: 0x00 - QPRC Position Count Register
        volatile uint32_t QRCR;  ///< Offset: 0x04 - QPRC Revolution Count Register
        volatile uint32_t QPCCR;  ///< Offset: 0x08 - QPRC Position Counter Compare Register
        volatile uint32_t QPRCR;  ///< Offset: 0x0C - QPRC Position and Revolution Counter Compare Register
        volatile uint32_t QCRH;  ///< Offset: 0x19 - High-Order Bytes of QPRC Control Register
        volatile uint32_t QCRL;  ///< Offset: 0x18 - Low-Order Bytes of QPRC Control Register
        volatile uint32_t QECR;  ///< Offset: 0x1C - QPRC Extension Control Register
        volatile uint32_t QICRL;  ///< Offset: 0x14 - Low-Order Bytes of QPRC Interrupt Control Register
        volatile uint32_t QICRH;  ///< Offset: 0x15 - High-Order Bytes of QPRC Interrupt Control Register
        volatile uint32_t QMPR;  ///< Offset: 0x10 - QPRC Maximum Position Register
        volatile uint32_t QPRCRR;  ///< Offset: 0x3C - Quad Counter Position Rotation Count Register
    };

    /// Peripheral instances
    inline Registers* QPRC0 = reinterpret_cast<Registers*>(QPRC0_BASE);
    inline Registers* QPRC0_NF = reinterpret_cast<Registers*>(QPRC0_NF_BASE);

    // Bit definitions
    /// QCRH Register bits
    namespace qcrh_bits {
        constexpr uint32_t CGE = (2 << 6);  ///< Detection edge selection bits
        constexpr uint32_t BES = (2 << 4);  ///< BIN detection edge selection bits
        constexpr uint32_t AES = (2 << 2);  ///< AIN detection edge selection bits
        constexpr uint32_t PCRM = (2 << 0);  ///< Position counter reset mask bits
    }

    /// QCRL Register bits
    namespace qcrl_bits {
        constexpr uint32_t SWAP = (1U << 7);  ///< Swap bit
        constexpr uint32_t RSEL = (1U << 6);  ///< Register function selection bit
        constexpr uint32_t CGSC = (1U << 5);  ///< Count clear or gate selection bit
        constexpr uint32_t PSTP = (1U << 4);  ///< Position counter stop bit
        constexpr uint32_t RCM = (2 << 2);  ///< Revolution counter mode bits
        constexpr uint32_t PCM = (2 << 0);  ///< Position counter mode bits
    }

    /// QECR Register bits
    namespace qecr_bits {
        constexpr uint32_t ORNGIE = (1U << 2);  ///< Outrange interrupt enable bit
        constexpr uint32_t ORNGF = (1U << 1);  ///< Outrange interrupt request flag bit
        constexpr uint32_t ORNGMD = (1U << 0);  ///< Outrange mode selection bit
    }

    /// QICRL Register bits
    namespace qicrl_bits {
        constexpr uint32_t ZIIF = (1U << 7);  ///< Zero index interrupt request flag bit
        constexpr uint32_t OFDF = (1U << 6);  ///< Overflow interrupt request flag bit
        constexpr uint32_t UFDF = (1U << 5);  ///< Underflow interrupt request flag bit
        constexpr uint32_t OUZIE = (1U << 4);  ///< Overflow@ underflow@ or zero index interrupt enable bit
        constexpr uint32_t QPRCMF = (1U << 3);  ///< PC and RC match interrupt request flag bit
        constexpr uint32_t QPRCMIE = (1U << 2);  ///< PC and RC match interrupt enable bit
        constexpr uint32_t QPCMF = (1U << 1);  ///< PC match interrupt request flag bit
        constexpr uint32_t QPCMIE = (1U << 0);  ///< PC match interrupt enable bit
    }

    /// QICRH Register bits
    namespace qicrh_bits {
        constexpr uint32_t QPCNRCMF = (1U << 5);  ///< PC match and RC match interrupt request flag bit
        constexpr uint32_t QPCNRCMIE = (1U << 4);  ///< PC match and RC match interrupt enable bit
        constexpr uint32_t DIROU = (1U << 3);  ///< Last position counter flow direction bit
        constexpr uint32_t DIRPC = (1U << 2);  ///< Last position counter direction bit
        constexpr uint32_t CDCF = (1U << 1);  ///< Count inversion interrupt request flag bit
        constexpr uint32_t CDCIE = (1U << 0);  ///< Count inversion interrupt enable bit
    }

    /// QPRCRR Register bits
    namespace qprcrr_bits {
        constexpr uint32_t QRCRR = (16 << 16);  ///< Quad counter rotation count display bit
        constexpr uint32_t QPCRR = (16 << 0);  ///< Quad counter position count display bit
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x40027000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCR;  ///< Offset: 0x01 - A/D Control Register
        volatile uint32_t ADSR;  ///< Offset: 0x00 - A/D Status Register
        volatile uint32_t SCCR;  ///< Offset: 0x09 - Scan Conversion Control Register
        volatile uint32_t SFNS;  ///< Offset: 0x08 - Scan Conversion FIFO Stage Count Setup Register
        volatile uint32_t SCFD;  ///< Offset: 0x0C - Scan Conversion FIFO Data Register
        volatile uint32_t SCIS3;  ///< Offset: 0x11 - Scan Conversion Input Selection Register 3
        volatile uint32_t SCIS2;  ///< Offset: 0x10 - Scan Conversion Input Selection Register 2
        volatile uint32_t SCIS1;  ///< Offset: 0x15 - Scan Conversion Input Selection Register 1
        volatile uint32_t SCIS0;  ///< Offset: 0x14 - Scan Conversion Input Selection Register 0
        volatile uint32_t PFNS;  ///< Offset: 0x18 - Priority Conversion FIFO Stage Count Setup Register
        volatile uint32_t PCCR;  ///< Offset: 0x19 - Priority Conversion Control Register
        volatile uint32_t PCFD;  ///< Offset: 0x1C - Priority Conversion FIFO Data Register
        volatile uint32_t PCIS;  ///< Offset: 0x20 - Priority Conversion Input Selection Register
        volatile uint32_t CMPCR;  ///< Offset: 0x24 - A/D Comparison Control Register
        volatile uint32_t CMPD;  ///< Offset: 0x26 - A/D Comparison Value Setup Register
        volatile uint32_t ADSS3;  ///< Offset: 0x29 - Sampling Time Selection Register 3
        volatile uint32_t ADSS2;  ///< Offset: 0x28 - Sampling Time Selection Register 2
        volatile uint32_t ADSS1;  ///< Offset: 0x2D - Sampling Time Selection Register 1
        volatile uint32_t ADSS0;  ///< Offset: 0x2C - Sampling Time Selection Register 0
        volatile uint32_t ADST1;  ///< Offset: 0x30 - Sampling Time Setup Register 1
        volatile uint32_t ADST0;  ///< Offset: 0x31 - Sampling Time Setup Register 0
        volatile uint32_t ADCT;  ///< Offset: 0x34 - Frequency Division Ratio Setup Register
        volatile uint32_t PRTSL;  ///< Offset: 0x38 - Priority Conversion Timer Trigger Selection Register
        volatile uint32_t SCTSL;  ///< Offset: 0x39 - Scan Conversion Timer Trigger Selection Register
        volatile uint32_t ADCEN;  ///< Offset: 0x3C - A/D Operation Enable Setup Register
        volatile uint32_t WCMRCIF;  ///< Offset: 0x44 - Range Comparison Flag Register
        volatile uint32_t WCMRCOT;  ///< Offset: 0x48 - Range Comparison Threshold Excess Flag Register
        volatile uint32_t WCMPCR;  ///< Offset: 0x4C - Range Comparison Control Register
        volatile uint32_t WCMPSR;  ///< Offset: 0x4D - Range Comparison Channel Select Register
        volatile uint32_t WCMPDL;  ///< Offset: 0x50 - Lower Limit Threshold Setup Register
        volatile uint32_t WCMPDH;  ///< Offset: 0x52 - Upper Limit Setup Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// ADCR Register bits
    namespace adcr_bits {
        constexpr uint32_t SCIF = (1U << 7);  ///< Scan conversion interrupt request bit
        constexpr uint32_t PCIF = (1U << 6);  ///< Priority conversion interrupt request bit
        constexpr uint32_t CMPIF = (1U << 5);  ///< Conversion result comparison interrupt request bit
        constexpr uint32_t SCIE = (1U << 3);  ///< Scan conversion interrupt enable bit
        constexpr uint32_t PCIE = (1U << 2);  ///< Priority conversion interrupt enable bit
        constexpr uint32_t CMPIE = (1U << 1);  ///< Conversion result comparison interrupt enable bit
        constexpr uint32_t OVRIE = (1U << 0);  ///< FIFO overrun interrupt enable bit
    }

    /// ADSR Register bits
    namespace adsr_bits {
        constexpr uint32_t ADSTP = (1U << 7);  ///< A/D conversion forced stop bit
        constexpr uint32_t FDAS = (1U << 6);  ///< FIFO data placement selection bit
        constexpr uint32_t PCNS = (1U << 2);  ///< Priority conversion pending flag
        constexpr uint32_t PCS = (1U << 1);  ///< Priority conversion status flag
        constexpr uint32_t SCS = (1U << 0);  ///< Scan conversion status flag
    }

    /// SCCR Register bits
    namespace sccr_bits {
        constexpr uint32_t SEMP = (1U << 7);  ///< Scan conversion FIFO empty bit
        constexpr uint32_t SFUL = (1U << 6);  ///< Scan conversion FIFO full bit
        constexpr uint32_t SOVR = (1U << 5);  ///< Scan conversion overrun flag
        constexpr uint32_t SFCLR = (1U << 4);  ///< Scan conversion FIFO clear bit
        constexpr uint32_t RPT = (1U << 2);  ///< Scan conversion repeat bit
        constexpr uint32_t SHEN = (1U << 1);  ///< Scan conversion timer start enable bit
        constexpr uint32_t SSTR = (1U << 0);  ///< Scan conversion start bit
    }

    /// SFNS Register bits
    namespace sfns_bits {
        constexpr uint32_t SFS = (4 << 0);  ///< Scan conversion FIFO stage count setting bits
    }

    /// SCFD Register bits
    namespace scfd_bits {
        constexpr uint32_t SD = (12 << 20);  ///< Scan conversion result
        constexpr uint32_t INVL = (1U << 12);  ///< A/D conversion result disable bit
        constexpr uint32_t RS = (2 << 8);  ///< Scan conversion start factor
        constexpr uint32_t SC = (5 << 0);  ///< Conversion input channel bits
    }

    /// SCIS3 Register bits
    namespace scis3_bits {
        constexpr uint32_t AN31 = (1U << 7);  ///< AN31 analog input selection bit
        constexpr uint32_t AN30 = (1U << 6);  ///< AN30 analog input selection bit
        constexpr uint32_t AN29 = (1U << 5);  ///< AN29 analog input selection bit
        constexpr uint32_t AN28 = (1U << 4);  ///< AN28 analog input selection bit
        constexpr uint32_t AN27 = (1U << 3);  ///< AN27 analog input selection bit
        constexpr uint32_t AN26 = (1U << 2);  ///< AN26 analog input selection bit
        constexpr uint32_t AN25 = (1U << 1);  ///< AN25 analog input selection bit
        constexpr uint32_t AN24 = (1U << 0);  ///< AN24 analog input selection bit
    }

    /// SCIS2 Register bits
    namespace scis2_bits {
        constexpr uint32_t AN23 = (1U << 7);  ///< AN23 analog input selection bit
        constexpr uint32_t AN22 = (1U << 6);  ///< AN22 analog input selection bit
        constexpr uint32_t AN21 = (1U << 5);  ///< AN21 analog input selection bit
        constexpr uint32_t AN20 = (1U << 4);  ///< AN20 analog input selection bit
        constexpr uint32_t AN19 = (1U << 3);  ///< AN19 analog input selection bit
        constexpr uint32_t AN18 = (1U << 2);  ///< AN18 analog input selection bit
        constexpr uint32_t AN17 = (1U << 1);  ///< AN17 analog input selection bit
        constexpr uint32_t AN16 = (1U << 0);  ///< AN16 analog input selection bit
    }

    /// SCIS1 Register bits
    namespace scis1_bits {
        constexpr uint32_t AN15 = (1U << 7);  ///< AN15 analog input selection bit
        constexpr uint32_t AN14 = (1U << 6);  ///< AN14 analog input selection bit
        constexpr uint32_t AN13 = (1U << 5);  ///< AN13 analog input selection bit
        constexpr uint32_t AN12 = (1U << 4);  ///< AN12 analog input selection bit
        constexpr uint32_t AN11 = (1U << 3);  ///< AN11 analog input selection bit
        constexpr uint32_t AN10 = (1U << 2);  ///< AN10 analog input selection bit
        constexpr uint32_t AN9 = (1U << 1);  ///< AN9 analog input selection bit
        constexpr uint32_t AN8 = (1U << 0);  ///< AN8 analog input selection bit
    }

    /// SCIS0 Register bits
    namespace scis0_bits {
        constexpr uint32_t AN7 = (1U << 7);  ///< AN7 analog input selection bit
        constexpr uint32_t AN6 = (1U << 6);  ///< AN6 analog input selection bit
        constexpr uint32_t AN5 = (1U << 5);  ///< AN5 analog input selection bit
        constexpr uint32_t AN4 = (1U << 4);  ///< AN4 analog input selection bit
        constexpr uint32_t AN3 = (1U << 3);  ///< AN3 analog input selection bit
        constexpr uint32_t AN2 = (1U << 2);  ///< AN2 analog input selection bit
        constexpr uint32_t AN1 = (1U << 1);  ///< AN1 analog input selection bit
        constexpr uint32_t AN0 = (1U << 0);  ///< AN0 analog input selection bit
    }

    /// PFNS Register bits
    namespace pfns_bits {
        constexpr uint32_t TEST = (2 << 4);  ///< Test bits
        constexpr uint32_t PFS = (2 << 0);  ///< Priority conversion FIFO stage count setting bits
    }

    /// PCCR Register bits
    namespace pccr_bits {
        constexpr uint32_t PEMP = (1U << 7);  ///< Priority conversion FIFO empty bit
        constexpr uint32_t PFUL = (1U << 6);  ///< Priority conversion FIFO full bit
        constexpr uint32_t POVR = (1U << 5);  ///< Priority conversion overrun flag
        constexpr uint32_t PFCLR = (1U << 4);  ///< Priority conversion FIFO clear bit
        constexpr uint32_t ESCE = (1U << 3);  ///< External trigger analog input selection bit
        constexpr uint32_t PEEN = (1U << 2);  ///< Priority conversion external start enable bit
        constexpr uint32_t PHEN = (1U << 1);  ///< Priority conversion timer start enable bit
        constexpr uint32_t PSTR = (1U << 0);  ///< Priority conversion start bit
    }

    /// PCFD Register bits
    namespace pcfd_bits {
        constexpr uint32_t PD = (12 << 20);  ///< Priority conversion result
        constexpr uint32_t INVL = (1U << 12);  ///< A/D conversion result disable bit
        constexpr uint32_t RS = (3 << 8);  ///< Scan conversion start factor
        constexpr uint32_t PC = (5 << 0);  ///< Conversion input channel bits
    }

    /// PCIS Register bits
    namespace pcis_bits {
        constexpr uint32_t P2A = (5 << 3);  ///< Priority level 2 analog input selection
        constexpr uint32_t P1A = (3 << 0);  ///< Priority level 1 analog input selection
    }

    /// CMPCR Register bits
    namespace cmpcr_bits {
        constexpr uint32_t CMPEN = (1U << 7);  ///< Conversion result comparison function operation enable bit
        constexpr uint32_t CMD1 = (1U << 6);  ///< Comparison mode 1
        constexpr uint32_t CMD0 = (1U << 5);  ///< Comparison mode 0
        constexpr uint32_t CCH = (5 << 0);  ///< Comparison target analog input channel
    }

    /// CMPD Register bits
    namespace cmpd_bits {
        constexpr uint32_t CMAD = (10 << 6);  ///< A/D conversion compare value setting bits
    }

    /// ADSS3 Register bits
    namespace adss3_bits {
        constexpr uint32_t TS31 = (1U << 7);  ///< AN31 sampling time selection bit
        constexpr uint32_t TS30 = (1U << 6);  ///< AN30 sampling time selection bit
        constexpr uint32_t TS29 = (1U << 5);  ///< AN29 sampling time selection bit
        constexpr uint32_t TS28 = (1U << 4);  ///< AN28 sampling time selection bit
        constexpr uint32_t TS27 = (1U << 3);  ///< AN27 sampling time selection bit
        constexpr uint32_t TS26 = (1U << 2);  ///< AN26 sampling time selection bit
        constexpr uint32_t TS25 = (1U << 1);  ///< AN25 sampling time selection bit
        constexpr uint32_t TS24 = (1U << 0);  ///< AN24 sampling time selection bit
    }

    /// ADSS2 Register bits
    namespace adss2_bits {
        constexpr uint32_t TS23 = (1U << 7);  ///< AN23 sampling time selection bit
        constexpr uint32_t TS22 = (1U << 6);  ///< AN22 sampling time selection bit
        constexpr uint32_t TS21 = (1U << 5);  ///< AN21 sampling time selection bit
        constexpr uint32_t TS20 = (1U << 4);  ///< AN20 sampling time selection bit
        constexpr uint32_t TS19 = (1U << 3);  ///< AN19 sampling time selection bit
        constexpr uint32_t TS18 = (1U << 2);  ///< AN18 sampling time selection bit
        constexpr uint32_t TS17 = (1U << 1);  ///< AN17 sampling time selection bit
        constexpr uint32_t TS16 = (1U << 0);  ///< AN16 sampling time selection bit
    }

    /// ADSS1 Register bits
    namespace adss1_bits {
        constexpr uint32_t TS15 = (1U << 7);  ///< AN15 sampling time selection bit
        constexpr uint32_t TS14 = (1U << 6);  ///< AN14 sampling time selection bit
        constexpr uint32_t TS13 = (1U << 5);  ///< AN13 sampling time selection bit
        constexpr uint32_t TS12 = (1U << 4);  ///< AN12 sampling time selection bit
        constexpr uint32_t TS11 = (1U << 3);  ///< AN11 sampling time selection bit
        constexpr uint32_t TS10 = (1U << 2);  ///< AN10 sampling time selection bit
        constexpr uint32_t TS9 = (1U << 1);  ///< AN9 sampling time selection bit
        constexpr uint32_t TS8 = (1U << 0);  ///< AN8 sampling time selection bit
    }

    /// ADSS0 Register bits
    namespace adss0_bits {
        constexpr uint32_t TS7 = (1U << 7);  ///< AN7 sampling time selection bit
        constexpr uint32_t TS6 = (1U << 6);  ///< AN6 sampling time selection bit
        constexpr uint32_t TS5 = (1U << 5);  ///< AN5 sampling time selection bit
        constexpr uint32_t TS4 = (1U << 4);  ///< AN4 sampling time selection bit
        constexpr uint32_t TS3 = (1U << 3);  ///< AN3 sampling time selection bit
        constexpr uint32_t TS2 = (1U << 2);  ///< AN2 sampling time selection bit
        constexpr uint32_t TS1 = (1U << 1);  ///< AN1 sampling time selection bit
        constexpr uint32_t TS0 = (1U << 0);  ///< AN0 sampling time selection bit
    }

    /// ADST1 Register bits
    namespace adst1_bits {
        constexpr uint32_t STX1 = (3 << 5);  ///< Sampling time N times setting bits
        constexpr uint32_t ST1 = (5 << 0);  ///< Sampling time setting bits
    }

    /// ADST0 Register bits
    namespace adst0_bits {
        constexpr uint32_t STX0 = (3 << 5);  ///< Sampling time N times setting bits
        constexpr uint32_t ST0 = (5 << 0);  ///< Sampling time setting bits
    }

    /// ADCT Register bits
    namespace adct_bits {
        constexpr uint32_t CT = (8 << 0);  ///< Frequency division ratio setting bits
    }

    /// PRTSL Register bits
    namespace prtsl_bits {
        constexpr uint32_t PRTSL = (4 << 0);  ///< Priority conversion timer trigger selection bits
    }

    /// SCTSL Register bits
    namespace sctsl_bits {
        constexpr uint32_t SCTSL = (4 << 0);  ///< Scan conversion timer trigger selection bits
    }

    /// ADCEN Register bits
    namespace adcen_bits {
        constexpr uint32_t ENBLTIME = (8 << 8);  ///< Operation enable state transition cycle selection bits
        constexpr uint32_t READY = (1U << 1);  ///< A/D operation enable state bit
        constexpr uint32_t ENBL = (1U << 0);  ///< A/D operation enable bit
    }

    /// WCMRCIF Register bits
    namespace wcmrcif_bits {
        constexpr uint32_t RCINT = (1U << 0);  ///< Range comparison interrupt factor flag bit
    }

    /// WCMRCOT Register bits
    namespace wcmrcot_bits {
        constexpr uint32_t RCOOF = (1U << 0);  ///< Threshold excess flag bit
    }

    /// WCMPCR Register bits
    namespace wcmpcr_bits {
        constexpr uint32_t RCOCD = (3 << 5);  ///< Continuous detection specification count/state indication bits
        constexpr uint32_t RCOIRS = (1U << 4);  ///< Selection bit of within-range and out-of- range confirmation
        constexpr uint32_t RCOIE = (1U << 3);  ///< Range comparison interrupt request enable bit
        constexpr uint32_t RCOE = (1U << 2);  ///< Range comparison execution enable bit
    }

    /// WCMPSR Register bits
    namespace wcmpsr_bits {
        constexpr uint32_t WCMD = (1U << 5);  ///< Comparison mode select bit
        constexpr uint32_t WCCH = (5 << 0);  ///< Comparison target analog input channel
    }

    /// WCMPDL Register bits
    namespace wcmpdl_bits {
        constexpr uint32_t CMLD = (10 << 6);  ///< Lower limit threshold bits
    }

    /// WCMPDH Register bits
    namespace wcmpdh_bits {
        constexpr uint32_t CMHD = (10 << 6);  ///< Upper limit threshold bits
    }

}

// ============================================================================
// CRTRIM Peripheral
// ============================================================================

namespace crtrim {
    /// Base addresses
    constexpr uint32_t CRTRIM_BASE = 0x4002E000;

    /// CRTRIM Register structure
    struct Registers {
        volatile uint32_t MCR_PSR;  ///< Offset: 0x00 - High-speed CR Oscillation Frequency Division Setup Register
        volatile uint32_t MCR_FTRM;  ///< Offset: 0x04 - High-speed CR Oscillation Frequency Trimming Register
        volatile uint32_t MCR_TTRM;  ///< Offset: 0x08 - High-speed CR Oscillation Temperature Trimming Setup Register
        volatile uint32_t MCR_RLR;  ///< Offset: 0x0C - High-Speed CR Oscillation Register Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* CRTRIM = reinterpret_cast<Registers*>(CRTRIM_BASE);

    // Bit definitions
    /// MCR_PSR Register bits
    namespace mcr_psr_bits {
        constexpr uint32_t CSR = (3 << 0);  ///< High-speed CR oscillation frequency division ratio setting bits
    }

    /// MCR_FTRM Register bits
    namespace mcr_ftrm_bits {
        constexpr uint32_t TRD = (10 << 0);  ///< Frequency trimming setup bits
    }

    /// MCR_TTRM Register bits
    namespace mcr_ttrm_bits {
        constexpr uint32_t TRT = (5 << 0);  ///< Temperature trimming setup bits
    }

    /// MCR_RLR Register bits
    namespace mcr_rlr_bits {
        constexpr uint32_t TRMLCK = (32 << 0);  ///< Register write-protect bits
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40030000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t ENIR;  ///< Offset: 0x00 - External Interrupt Enable Register
        volatile uint32_t EIRR;  ///< Offset: 0x04 - External Interrupt Factor Register
        volatile uint32_t EICL;  ///< Offset: 0x08 - External Interrupt Factor Clear Register
        volatile uint32_t ELVR;  ///< Offset: 0x0C - External Interrupt Factor Level Register
        volatile uint32_t ELVR1;  ///< Offset: 0x10 - External Interrupt Factor Level Register 1
        volatile uint32_t NMIRR;  ///< Offset: 0x14 - Non Maskable Interrupt Factor Register
        volatile uint32_t NMICL;  ///< Offset: 0x18 - Non Maskable Interrupt Factor Clear Register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// ENIR Register bits
    namespace enir_bits {
        constexpr uint32_t EN31 = (1U << 31);  ///< External interrupt Ch.31 enable bit
        constexpr uint32_t EN30 = (1U << 30);  ///< External interrupt Ch.30 enable bit
        constexpr uint32_t EN29 = (1U << 29);  ///< External interrupt Ch.29 enable bit
        constexpr uint32_t EN28 = (1U << 28);  ///< External interrupt Ch.28 enable bit
        constexpr uint32_t EN27 = (1U << 27);  ///< External interrupt Ch.27 enable bit
        constexpr uint32_t EN26 = (1U << 26);  ///< External interrupt Ch.26 enable bit
        constexpr uint32_t EN25 = (1U << 25);  ///< External interrupt Ch.25 enable bit
        constexpr uint32_t EN24 = (1U << 24);  ///< External interrupt Ch.24 enable bit
        constexpr uint32_t EN23 = (1U << 23);  ///< External interrupt Ch.23 enable bit
        constexpr uint32_t EN22 = (1U << 22);  ///< External interrupt Ch.22 enable bit
        constexpr uint32_t EN21 = (1U << 21);  ///< External interrupt Ch.21 enable bit
        constexpr uint32_t EN20 = (1U << 20);  ///< External interrupt Ch.20 enable bit
        constexpr uint32_t EN19 = (1U << 19);  ///< External interrupt Ch.19 enable bit
        constexpr uint32_t EN18 = (1U << 18);  ///< External interrupt Ch.18 enable bit
        constexpr uint32_t EN17 = (1U << 17);  ///< External interrupt Ch.17 enable bit
        constexpr uint32_t EN16 = (1U << 16);  ///< External interrupt Ch.16 enable bit
        constexpr uint32_t EN15 = (1U << 15);  ///< External interrupt Ch.15 enable bit
        constexpr uint32_t EN14 = (1U << 14);  ///< External interrupt Ch.14 enable bit
        constexpr uint32_t EN13 = (1U << 13);  ///< External interrupt Ch.13 enable bit
        constexpr uint32_t EN12 = (1U << 12);  ///< External interrupt Ch.12 enable bit
        constexpr uint32_t EN11 = (1U << 11);  ///< External interrupt Ch.11 enable bit
        constexpr uint32_t EN10 = (1U << 10);  ///< External interrupt Ch.10 enable bit
        constexpr uint32_t EN9 = (1U << 9);  ///< External interrupt Ch.9 enable bit
        constexpr uint32_t EN8 = (1U << 8);  ///< External interrupt Ch.8 enable bit
        constexpr uint32_t EN7 = (1U << 7);  ///< External interrupt Ch.7 enable bit
        constexpr uint32_t EN6 = (1U << 6);  ///< External interrupt Ch.6 enable bit
        constexpr uint32_t EN5 = (1U << 5);  ///< External interrupt Ch.5 enable bit
        constexpr uint32_t EN4 = (1U << 4);  ///< External interrupt Ch.4 enable bit
        constexpr uint32_t EN3 = (1U << 3);  ///< External interrupt Ch.3 enable bit
        constexpr uint32_t EN2 = (1U << 2);  ///< External interrupt Ch.2 enable bit
        constexpr uint32_t EN1 = (1U << 1);  ///< External interrupt Ch.1 enable bit
        constexpr uint32_t EN0 = (1U << 0);  ///< External interrupt Ch.0 enable bit
    }

    /// EIRR Register bits
    namespace eirr_bits {
        constexpr uint32_t ER31 = (1U << 31);  ///< External interrupt Ch.31 request detection bit
        constexpr uint32_t ER30 = (1U << 30);  ///< External interrupt Ch.30 request detection bit
        constexpr uint32_t ER29 = (1U << 29);  ///< External interrupt Ch.29 request detection bit
        constexpr uint32_t ER28 = (1U << 28);  ///< External interrupt Ch.28 request detection bit
        constexpr uint32_t ER27 = (1U << 27);  ///< External interrupt Ch.27 request detection bit
        constexpr uint32_t ER26 = (1U << 26);  ///< External interrupt Ch.26 request detection bit
        constexpr uint32_t ER25 = (1U << 25);  ///< External interrupt Ch.25 request detection bit
        constexpr uint32_t ER24 = (1U << 24);  ///< External interrupt Ch.24 request detection bit
        constexpr uint32_t ER23 = (1U << 23);  ///< External interrupt Ch.23 request detection bit
        constexpr uint32_t ER22 = (1U << 22);  ///< External interrupt Ch.22 request detection bit
        constexpr uint32_t ER21 = (1U << 21);  ///< External interrupt Ch.21 request detection bit
        constexpr uint32_t ER20 = (1U << 20);  ///< External interrupt Ch.20 request detection bit
        constexpr uint32_t ER19 = (1U << 19);  ///< External interrupt Ch.19 request detection bit
        constexpr uint32_t ER18 = (1U << 18);  ///< External interrupt Ch.18 request detection bit
        constexpr uint32_t ER17 = (1U << 17);  ///< External interrupt Ch.17 request detection bit
        constexpr uint32_t ER16 = (1U << 16);  ///< External interrupt Ch.16 request detection bit
        constexpr uint32_t ER15 = (1U << 15);  ///< External interrupt Ch.15 request detection bit
        constexpr uint32_t ER14 = (1U << 14);  ///< External interrupt Ch.14 request detection bit
        constexpr uint32_t ER13 = (1U << 13);  ///< External interrupt Ch.13 request detection bit
        constexpr uint32_t ER12 = (1U << 12);  ///< External interrupt Ch.12 request detection bit
        constexpr uint32_t ER11 = (1U << 11);  ///< External interrupt Ch.11 request detection bit
        constexpr uint32_t ER10 = (1U << 10);  ///< External interrupt Ch.10 request detection bit
        constexpr uint32_t ER9 = (1U << 9);  ///< External interrupt Ch.9 request detection bit
        constexpr uint32_t ER8 = (1U << 8);  ///< External interrupt Ch.8 request detection bit
        constexpr uint32_t ER7 = (1U << 7);  ///< External interrupt Ch.7 request detection bit
        constexpr uint32_t ER6 = (1U << 6);  ///< External interrupt Ch.6 request detection bit
        constexpr uint32_t ER5 = (1U << 5);  ///< External interrupt Ch.5 request detection bit
        constexpr uint32_t ER4 = (1U << 4);  ///< External interrupt Ch.4 request detection bit
        constexpr uint32_t ER3 = (1U << 3);  ///< External interrupt Ch.3 request detection bit
        constexpr uint32_t ER2 = (1U << 2);  ///< External interrupt Ch.2 request detection bit
        constexpr uint32_t ER1 = (1U << 1);  ///< External interrupt Ch.1 request detection bit
        constexpr uint32_t ER0 = (1U << 0);  ///< External interrupt Ch.0 request detection bit
    }

    /// EICL Register bits
    namespace eicl_bits {
        constexpr uint32_t ECL31 = (1U << 31);  ///< External interrupt Ch.31 factor clear bit
        constexpr uint32_t ECL30 = (1U << 30);  ///< External interrupt Ch.30 factor clear bit
        constexpr uint32_t ECL29 = (1U << 29);  ///< External interrupt Ch.29 factor clear bit
        constexpr uint32_t ECL28 = (1U << 28);  ///< External interrupt Ch.28 factor clear bit
        constexpr uint32_t ECL27 = (1U << 27);  ///< External interrupt Ch.27 factor clear bit
        constexpr uint32_t ECL26 = (1U << 26);  ///< External interrupt Ch.26 factor clear bit
        constexpr uint32_t ECL25 = (1U << 25);  ///< External interrupt Ch.25 factor clear bit
        constexpr uint32_t ECL24 = (1U << 24);  ///< External interrupt Ch.24 factor clear bit
        constexpr uint32_t ECL23 = (1U << 23);  ///< External interrupt Ch.23 factor clear bit
        constexpr uint32_t ECL22 = (1U << 22);  ///< External interrupt Ch.22 factor clear bit
        constexpr uint32_t ECL21 = (1U << 21);  ///< External interrupt Ch.21 factor clear bit
        constexpr uint32_t ECL20 = (1U << 20);  ///< External interrupt Ch.20 factor clear bit
        constexpr uint32_t ECL19 = (1U << 19);  ///< External interrupt Ch.19 factor clear bit
        constexpr uint32_t ECL18 = (1U << 18);  ///< External interrupt Ch.18 factor clear bit
        constexpr uint32_t ECL17 = (1U << 17);  ///< External interrupt Ch.17 factor clear bit
        constexpr uint32_t ECL16 = (1U << 16);  ///< External interrupt Ch.16 factor clear bit
        constexpr uint32_t ECL15 = (1U << 15);  ///< External interrupt Ch.15 factor clear bit
        constexpr uint32_t ECL14 = (1U << 14);  ///< External interrupt Ch.14 factor clear bit
        constexpr uint32_t ECL13 = (1U << 13);  ///< External interrupt Ch.13 factor clear bit
        constexpr uint32_t ECL12 = (1U << 12);  ///< External interrupt Ch.12 factor clear bit
        constexpr uint32_t ECL11 = (1U << 11);  ///< External interrupt Ch.11 factor clear bit
        constexpr uint32_t ECL10 = (1U << 10);  ///< External interrupt Ch.10 factor clear bit
        constexpr uint32_t ECL9 = (1U << 9);  ///< External interrupt Ch.9 factor clear bit
        constexpr uint32_t ECL8 = (1U << 8);  ///< External interrupt Ch.8 factor clear bit
        constexpr uint32_t ECL7 = (1U << 7);  ///< External interrupt Ch.7 factor clear bit
        constexpr uint32_t ECL6 = (1U << 6);  ///< External interrupt Ch.6 factor clear bit
        constexpr uint32_t ECL5 = (1U << 5);  ///< External interrupt Ch.5 factor clear bit
        constexpr uint32_t ECL4 = (1U << 4);  ///< External interrupt Ch.4 factor clear bit
        constexpr uint32_t ECL3 = (1U << 3);  ///< External interrupt Ch.3 factor clear bit
        constexpr uint32_t ECL2 = (1U << 2);  ///< External interrupt Ch.2 factor clear bit
        constexpr uint32_t ECL1 = (1U << 1);  ///< External interrupt Ch.1 factor clear bit
        constexpr uint32_t ECL0 = (1U << 0);  ///< External interrupt Ch.0 factor clear bit
    }

    /// ELVR Register bits
    namespace elvr_bits {
        constexpr uint32_t LB15 = (1U << 31);  ///< Bit31 of ELVR
        constexpr uint32_t LA15 = (1U << 30);  ///< Bit30 of ELVR
        constexpr uint32_t LB14 = (1U << 29);  ///< Bit29 of ELVR
        constexpr uint32_t LA14 = (1U << 28);  ///< Bit28 of ELVR
        constexpr uint32_t LB13 = (1U << 27);  ///< Bit27 of ELVR
        constexpr uint32_t LA13 = (1U << 26);  ///< Bit26 of ELVR
        constexpr uint32_t LB12 = (1U << 25);  ///< Bit25 of ELVR
        constexpr uint32_t LA12 = (1U << 24);  ///< Bit24 of ELVR
        constexpr uint32_t LB11 = (1U << 23);  ///< Bit23 of ELVR
        constexpr uint32_t LA11 = (1U << 22);  ///< Bit22 of ELVR
        constexpr uint32_t LB10 = (1U << 21);  ///< Bit21 of ELVR
        constexpr uint32_t LA10 = (1U << 20);  ///< Bit20 of ELVR
        constexpr uint32_t LB9 = (1U << 19);  ///< Bit19 of ELVR
        constexpr uint32_t LA9 = (1U << 18);  ///< Bit18 of ELVR
        constexpr uint32_t LB8 = (1U << 17);  ///< Bit17 of ELVR
        constexpr uint32_t LA8 = (1U << 16);  ///< Bit16 of ELVR
        constexpr uint32_t LB7 = (1U << 15);  ///< Bit15 of ELVR
        constexpr uint32_t LA7 = (1U << 14);  ///< Bit14 of ELVR
        constexpr uint32_t LB6 = (1U << 13);  ///< Bit13 of ELVR
        constexpr uint32_t LA6 = (1U << 12);  ///< Bit12 of ELVR
        constexpr uint32_t LB5 = (1U << 11);  ///< Bit11 of ELVR
        constexpr uint32_t LA5 = (1U << 10);  ///< Bit10 of ELVR
        constexpr uint32_t LB4 = (1U << 9);  ///< Bit9 of ELVR
        constexpr uint32_t LA4 = (1U << 8);  ///< Bit8 of ELVR
        constexpr uint32_t LB3 = (1U << 7);  ///< Bit7 of ELVR
        constexpr uint32_t LA3 = (1U << 6);  ///< Bit6 of ELVR
        constexpr uint32_t LB2 = (1U << 5);  ///< Bit5 of ELVR
        constexpr uint32_t LA2 = (1U << 4);  ///< Bit4 of ELVR
        constexpr uint32_t LB1 = (1U << 3);  ///< Bit3 of ELVR
        constexpr uint32_t LA1 = (1U << 2);  ///< Bit2 of ELVR
        constexpr uint32_t LB0 = (1U << 1);  ///< Bit1 of ELVR
        constexpr uint32_t LA0 = (1U << 0);  ///< Bit0 of ELVR
    }

    /// ELVR1 Register bits
    namespace elvr1_bits {
        constexpr uint32_t LB31 = (1U << 31);  ///< Bit31 of ELVR1
        constexpr uint32_t LA31 = (1U << 30);  ///< Bit30 of ELVR1
        constexpr uint32_t LB30 = (1U << 29);  ///< Bit29 of ELVR1
        constexpr uint32_t LA30 = (1U << 28);  ///< Bit28 of ELVR1
        constexpr uint32_t LB29 = (1U << 27);  ///< Bit27 of ELVR1
        constexpr uint32_t LA29 = (1U << 26);  ///< Bit26 of ELVR1
        constexpr uint32_t LB28 = (1U << 25);  ///< Bit25 of ELVR1
        constexpr uint32_t LA28 = (1U << 24);  ///< Bit24 of ELVR1
        constexpr uint32_t LB27 = (1U << 23);  ///< Bit23 of ELVR1
        constexpr uint32_t LA27 = (1U << 22);  ///< Bit22 of ELVR1
        constexpr uint32_t LB26 = (1U << 21);  ///< Bit21 of ELVR1
        constexpr uint32_t LA26 = (1U << 20);  ///< Bit20 of ELVR1
        constexpr uint32_t LB25 = (1U << 19);  ///< Bit19 of ELVR1
        constexpr uint32_t LA25 = (1U << 18);  ///< Bit18 of ELVR1
        constexpr uint32_t LB24 = (1U << 17);  ///< Bit17 of ELVR1
        constexpr uint32_t LA24 = (1U << 16);  ///< Bit16 of ELVR1
        constexpr uint32_t LB23 = (1U << 15);  ///< Bit15 of ELVR1
        constexpr uint32_t LA23 = (1U << 14);  ///< Bit14 of ELVR1
        constexpr uint32_t LB22 = (1U << 13);  ///< Bit13 of ELVR1
        constexpr uint32_t LA22 = (1U << 12);  ///< Bit12 of ELVR1
        constexpr uint32_t LB21 = (1U << 11);  ///< Bit11 of ELVR1
        constexpr uint32_t LA21 = (1U << 10);  ///< Bit10 of ELVR1
        constexpr uint32_t LB20 = (1U << 9);  ///< Bit9 of ELVR1
        constexpr uint32_t LA20 = (1U << 8);  ///< Bit8 of ELVR1
        constexpr uint32_t LB19 = (1U << 7);  ///< Bit7 of ELVR1
        constexpr uint32_t LA19 = (1U << 6);  ///< Bit6 of ELVR1
        constexpr uint32_t LB18 = (1U << 5);  ///< Bit5 of ELVR1
        constexpr uint32_t LA18 = (1U << 4);  ///< Bit4 of ELVR1
        constexpr uint32_t LB17 = (1U << 3);  ///< Bit3 of ELVR1
        constexpr uint32_t LA17 = (1U << 2);  ///< Bit2 of ELVR1
        constexpr uint32_t LB16 = (1U << 1);  ///< Bit1 of ELVR1
        constexpr uint32_t LA16 = (1U << 0);  ///< Bit0 of ELVR1
    }

    /// NMIRR Register bits
    namespace nmirr_bits {
        constexpr uint32_t NR = (1U << 0);  ///< NMI interrupt request detection bit
    }

    /// NMICL Register bits
    namespace nmicl_bits {
        constexpr uint32_t NCL = (1U << 0);  ///< NMI interrupt factor clear bit
    }

}

// ============================================================================
// INTREQ Peripheral
// ============================================================================

namespace intreq {
    /// Base addresses
    constexpr uint32_t INTREQ_BASE = 0x40031000;

    /// INTREQ Register structure
    struct Registers {
        volatile uint32_t DRQSEL;  ///< Offset: 0x00 - DMA Request Selection Register
        volatile uint32_t IRQCMODE;  ///< Offset: 0x0C - Interrupt Factor Vector Relocate Setting Register
        volatile uint32_t EXC02MON;  ///< Offset: 0x10 - EXC02 Batch Read Register
        volatile uint32_t IRQ00MON;  ///< Offset: 0x14 - IRQ00 Batch Read Register
        volatile uint32_t IRQ01MON;  ///< Offset: 0x18 - IRQ01 Batch Read Register
        volatile uint32_t IRQ02MON;  ///< Offset: 0x1C - IRQ02 Batch Read Register
        volatile uint32_t IRQ03MON;  ///< Offset: 0x20 - IRQ03 Batch Read Register
        volatile uint32_t IRQ04MON;  ///< Offset: 0x24 - IRQ04 Batch Read Register
        volatile uint32_t IRQ05MON;  ///< Offset: 0x28 - IRQ05 Batch Read Register
        volatile uint32_t IRQ06MON;  ///< Offset: 0x2C - IRQ06 Batch Read Register
        volatile uint32_t IRQ07MON;  ///< Offset: 0x30 - IRQ07 Batch Read Register
        volatile uint32_t IRQ08MON;  ///< Offset: 0x34 - IRQ08 Batch Read Register
        volatile uint32_t IRQ09MON;  ///< Offset: 0x38 - IRQ09 Batch Read Register
        volatile uint32_t IRQ10MON;  ///< Offset: 0x3C - IRQ10 Batch Read Register
        volatile uint32_t IRQ11MON;  ///< Offset: 0x40 - IRQ11 Batch Read Register
        volatile uint32_t IRQ12MON;  ///< Offset: 0x44 - IRQ12 Batch Read Register
        volatile uint32_t IRQ13MON;  ///< Offset: 0x48 - IRQ13 Batch Read Register
        volatile uint32_t IRQ14MON;  ///< Offset: 0x4C - IRQ14 Batch Read Register
        volatile uint32_t IRQ15MON;  ///< Offset: 0x50 - IRQ15 Batch Read Register
        volatile uint32_t IRQ16MON;  ///< Offset: 0x54 - IRQ16 Batch Read Register
        volatile uint32_t IRQ17MON;  ///< Offset: 0x58 - IRQ17 Batch Read Register
        volatile uint32_t IRQ18MON;  ///< Offset: 0x5C - IRQ18 Batch Read Register
        volatile uint32_t IRQ19MON;  ///< Offset: 0x60 - IRQ19 Batch Read Register
        volatile uint32_t IRQ20MON;  ///< Offset: 0x64 - IRQ20 Batch Read Register
        volatile uint32_t IRQ21MON;  ///< Offset: 0x68 - IRQ21 Batch Read Register
        volatile uint32_t IRQ22MON;  ///< Offset: 0x6C - IRQ22 Batch Read Register
        volatile uint32_t IRQ23MON;  ///< Offset: 0x70 - IRQ23 Batch Read Register
        volatile uint32_t IRQ24MON;  ///< Offset: 0x74 - IRQ24 Batch Read Register
        volatile uint32_t IRQ25MON;  ///< Offset: 0x78 - IRQ25 Batch Read Register
        volatile uint32_t IRQ26MON;  ///< Offset: 0x7C - IRQ26 Batch Read Register
        volatile uint32_t IRQ27MON;  ///< Offset: 0x80 - IRQ27 Batch Read Register
        volatile uint32_t IRQ28MON;  ///< Offset: 0x84 - IRQ28 Batch Read Register
        volatile uint32_t IRQ29MON;  ///< Offset: 0x88 - IRQ29 Batch Read Register
        volatile uint32_t IRQ30MON;  ///< Offset: 0x8C - IRQ30 Batch Read Register
        volatile uint32_t IRQ31MON;  ///< Offset: 0x90 - IRQ31 Batch Read Register
        volatile uint32_t RCINTSEL0;  ///< Offset: 0x210 - Interrupt Factor Selection Register 0
        volatile uint32_t RCINTSEL1;  ///< Offset: 0x214 - Interrupt Factor Selection Register 1
    };

    /// Peripheral instances
    inline Registers* INTREQ = reinterpret_cast<Registers*>(INTREQ_BASE);

    // Bit definitions
    /// DRQSEL Register bits
    namespace drqsel_bits {
        constexpr uint32_t EXINT3 = (1U << 31);  ///< The interrupt signal of the external interrupt ch.3 is output as a transfer request to the DMAC
        constexpr uint32_t EXINT2 = (1U << 30);  ///< The interrupt signal of the external interrupt ch.2 is output as a transfer request to the DMAC
        constexpr uint32_t EXINT1 = (1U << 29);  ///< The interrupt signal of the external interrupt ch.1 is output as a transfer request to the DMAC
        constexpr uint32_t EXINT0 = (1U << 28);  ///< The interrupt signal of the external interrupt ch.0 is output as a transfer request to the DMAC
        constexpr uint32_t MFS7TX = (1U << 27);  ///< The transmission interrupt signal of the MFS ch.7 is output as a transfer request to the DMAC
        constexpr uint32_t MFS7RX = (1U << 26);  ///< The reception interrupt signal of the MFS ch.7 is output as a transfer request to the DMAC
        constexpr uint32_t MFS6TX = (1U << 25);  ///< The transmission interrupt signal of the MFS ch.6 is output as a transfer request to the DMAC
        constexpr uint32_t MFS6RX = (1U << 24);  ///< The reception interrupt signal of the MFS ch.6 is output as a transfer request to the DMAC
        constexpr uint32_t MFS5TX = (1U << 23);  ///< The transmission interrupt signal of the MFS ch.5 is output as a transfer request to the DMAC
        constexpr uint32_t MFS5RX = (1U << 22);  ///< The reception interrupt signal of the MFS ch.5 is output as a transfer request to the DMAC
        constexpr uint32_t MFS4TX = (1U << 21);  ///< The transmission interrupt signal of the MFS ch.4 is output as a transfer request to the DMAC
        constexpr uint32_t MFS4RX = (1U << 20);  ///< The reception interrupt signal of the MFS ch.4 is output as a transfer request to the DMAC
        constexpr uint32_t MFS3TX = (1U << 19);  ///< The transmission interrupt signal of the MFS ch.3 is output as a transfer request to the DMAC
        constexpr uint32_t MFS3RX = (1U << 18);  ///< The reception interrupt signal of the MFS ch.3 is output as a transfer request to the DMAC
        constexpr uint32_t MFS2TX = (1U << 17);  ///< The transmission interrupt signal of the MFS ch.2 is output as a transfer request to the DMAC
        constexpr uint32_t MFS2RX = (1U << 16);  ///< The reception interrupt signal of the MFS ch.2 is output as a transfer request to the DMAC
        constexpr uint32_t MFS1TX = (1U << 15);  ///< The transmission interrupt signal of the MFS ch.1 is output as a transfer request to the DMAC
        constexpr uint32_t MFS1RX = (1U << 14);  ///< The reception interrupt signal of the MFS ch.1 is output as a transfer request to the DMAC
        constexpr uint32_t MFS0TX = (1U << 13);  ///< The transmission interrupt signal of the MFS ch.0 is output as a transfer request to the DMAC
        constexpr uint32_t MFS0RX = (1U << 12);  ///< The reception interrupt signal of the MFS ch.0 is output as a transfer request to the DMAC
        constexpr uint32_t IRQ0BT6 = (1U << 11);  ///< The IRQ0 interrupt signal of the base timer ch.6 is output as a transfer request to the DMAC
        constexpr uint32_t IRQ0BT4 = (1U << 10);  ///< The IRQ0 interrupt signal of the base timer ch.4 is output as a transfer request to the DMAC
        constexpr uint32_t IRQ0BT2 = (1U << 9);  ///< The IRQ0 interrupt signal of the base timer ch.2 is output as a transfer request to the DMAC
        constexpr uint32_t IRQ0BT0 = (1U << 8);  ///< The IRQ0 interrupt signal of the base timer ch.0 is output as a transfer request to the DMAC
        constexpr uint32_t ADCSCAN2 = (1U << 7);  ///< The scan conversion interrupt signal of the A/D converter unit 2 is output as a transfer request to the DMAC
        constexpr uint32_t ADCSCAN1 = (1U << 6);  ///< The scan conversion interrupt signal of the A/D converter unit 1 is output as a transfer request to the DMAC
        constexpr uint32_t ADCSCAN0 = (1U << 5);  ///< The scan conversion interrupt signal of the A/D converter unit 0 is output as a transfer request to the DMAC
    }

    /// IRQCMODE Register bits
    namespace irqcmode_bits {
        constexpr uint32_t IRQCMODE = (1U << 0);  ///< Assigns the interrupt factor vector according to Table 1-1 in chapter "Interrupt B"
    }

    /// EXC02MON Register bits
    namespace exc02mon_bits {
        constexpr uint32_t HWINT = (1U << 1);  ///< Hardware watchdog timer interrupt request
        constexpr uint32_t NMI = (1U << 0);  ///< NMIX external pin interrupt request
    }

    /// IRQ00MON Register bits
    namespace irq00mon_bits {
        constexpr uint32_t FCSINT = (1U << 0);  ///< Anomalous frequency detection by CSV interrupt request
    }

    /// IRQ01MON Register bits
    namespace irq01mon_bits {
        constexpr uint32_t SWWDTINT = (1U << 0);  ///< Software watchdog timer interrupt request
    }

    /// IRQ02MON Register bits
    namespace irq02mon_bits {
        constexpr uint32_t LVDINT = (1U << 0);  ///< Low voltage detection (LVD) interrupt request
    }

    /// IRQ03MON Register bits
    namespace irq03mon_bits {
        constexpr uint32_t WAVE2INT3 = (1U << 11);  ///< WFG timer 54 interrupt request in MFT unit 2
        constexpr uint32_t WAVE2INT2 = (1U << 10);  ///< WFG timer 32 interrupt request in MFT unit 2
        constexpr uint32_t WAVE2INT1 = (1U << 9);  ///< WFG timer 10 interrupt request in MFT unit 2
        constexpr uint32_t WAVE2INT0 = (1U << 8);  ///< DTIF (motor emergency stop) interrupt request in MFT unit 2
        constexpr uint32_t WAVE1INT3 = (1U << 7);  ///< WFG timer 54 interrupt request in MFT unit 1
        constexpr uint32_t WAVE1INT2 = (1U << 6);  ///< WFG timer 32 interrupt request in MFT unit 1
        constexpr uint32_t WAVE1INT1 = (1U << 5);  ///< WFG timer 10 interrupt request in MFT unit 1
        constexpr uint32_t WAVE1INT0 = (1U << 4);  ///< DTIF (motor emergency stop) interrupt request in MFT unit 1
        constexpr uint32_t WAVE0INT3 = (1U << 3);  ///< WFG timer 54 interrupt request in MFT unit 0
        constexpr uint32_t WAVE0INT2 = (1U << 2);  ///< WFG timer 32 interrupt request in MFT unit 0
        constexpr uint32_t WAVE0INT1 = (1U << 1);  ///< WFG timer 10 interrupt request in MFT unit 0
        constexpr uint32_t WAVE0INT0 = (1U << 0);  ///< DTIF (motor emergency stop) interrupt request in MFT unit 0
    }

    /// IRQ04MON Register bits
    namespace irq04mon_bits {
        constexpr uint32_t EXTINT7 = (1U << 7);  ///< Interrupt request of external interrupt ch.7
        constexpr uint32_t EXTINT6 = (1U << 6);  ///< Interrupt request of external interrupt ch.6
        constexpr uint32_t EXTINT5 = (1U << 5);  ///< Interrupt request of external interrupt ch.5
        constexpr uint32_t EXTINT4 = (1U << 4);  ///< Interrupt request of external interrupt ch.4
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request of external interrupt ch.3
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request of external interrupt ch.2
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request of external interrupt ch.1
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request of external interrupt ch.0
    }

    /// IRQ05MON Register bits
    namespace irq05mon_bits {
        constexpr uint32_t EXTINT31 = (1U << 23);  ///< Interrupt request of external interrupt ch.31
        constexpr uint32_t EXTINT30 = (1U << 22);  ///< Interrupt request of external interrupt ch.30
        constexpr uint32_t EXTINT29 = (1U << 21);  ///< Interrupt request of external interrupt ch.29
        constexpr uint32_t EXTINT28 = (1U << 20);  ///< Interrupt request of external interrupt ch.28
        constexpr uint32_t EXTINT27 = (1U << 19);  ///< Interrupt request of external interrupt ch.27
        constexpr uint32_t EXTINT26 = (1U << 18);  ///< Interrupt request of external interrupt ch.26
        constexpr uint32_t EXTINT25 = (1U << 17);  ///< Interrupt request of external interrupt ch.25
        constexpr uint32_t EXTINT24 = (1U << 16);  ///< Interrupt request of external interrupt ch.24
        constexpr uint32_t EXTINT23 = (1U << 15);  ///< Interrupt request of external interrupt ch.23
        constexpr uint32_t EXTINT22 = (1U << 14);  ///< Interrupt request of external interrupt ch.22
        constexpr uint32_t EXTINT21 = (1U << 13);  ///< Interrupt request of external interrupt ch.21
        constexpr uint32_t EXTINT20 = (1U << 12);  ///< Interrupt request of external interrupt ch.20
        constexpr uint32_t EXTINT19 = (1U << 11);  ///< Interrupt request of external interrupt ch.19
        constexpr uint32_t EXTINT18 = (1U << 10);  ///< Interrupt request of external interrupt ch.18
        constexpr uint32_t EXTINT17 = (1U << 9);  ///< Interrupt request of external interrupt ch.17
        constexpr uint32_t EXTINT16 = (1U << 8);  ///< Interrupt request of external interrupt ch.16
        constexpr uint32_t EXTINT15 = (1U << 7);  ///< Interrupt request of external interrupt ch.15
        constexpr uint32_t EXTINT14 = (1U << 6);  ///< Interrupt request of external interrupt ch.14
        constexpr uint32_t EXTINT13 = (1U << 5);  ///< Interrupt request of external interrupt ch.13
        constexpr uint32_t EXTINT12 = (1U << 4);  ///< Interrupt request of external interrupt ch.12
        constexpr uint32_t EXTINT11 = (1U << 3);  ///< Interrupt request of external interrupt ch.11
        constexpr uint32_t EXTINT10 = (1U << 2);  ///< Interrupt request of external interrupt ch.10
        constexpr uint32_t EXTINT9 = (1U << 1);  ///< Interrupt request of external interrupt ch.9
        constexpr uint32_t EXTINT8 = (1U << 0);  ///< Interrupt request of external interrupt ch.8
    }

    /// IRQ06MON Register bits
    namespace irq06mon_bits {
        constexpr uint32_t QUD2INT5 = (1U << 19);  ///< PC match and RC match interrupt request of QPRC ch.2
        constexpr uint32_t QUD2INT4 = (1U << 18);  ///< Interrupt request detected RC out of range of QPRC ch.2
        constexpr uint32_t QUD2INT3 = (1U << 17);  ///< PC count invert interrupt request of QPRC ch.2
        constexpr uint32_t QUD2INT2 = (1U << 16);  ///< Overflow/underflow/zero index interrupt request of QPRC ch.2
        constexpr uint32_t QUD2INT1 = (1U << 15);  ///< PC and RC match interrupt request of QPRC ch.2
        constexpr uint32_t QUD2INT0 = (1U << 14);  ///< PC match interrupt request of QPRC ch.2
        constexpr uint32_t QUD1INT5 = (1U << 13);  ///< PC match and RC match interrupt request of QPRC ch.1
        constexpr uint32_t QUD1INT4 = (1U << 12);  ///< Interrupt request detected RC out of range of QPRC ch.1
        constexpr uint32_t QUD1INT3 = (1U << 11);  ///< PC count invert interrupt request of QPRC ch.1
        constexpr uint32_t QUD1INT2 = (1U << 10);  ///< Overflow/underflow/zero index interrupt request of QPRC ch.1
        constexpr uint32_t QUD1INT1 = (1U << 9);  ///< PC and RC match interrupt request of QPRC ch.1
        constexpr uint32_t QUD1INT0 = (1U << 8);  ///< PC match interrupt request of QPRC ch.1
        constexpr uint32_t QUD0INT5 = (1U << 7);  ///< PC match and RC match interrupt request of QPRC ch.0
        constexpr uint32_t QUD0INT4 = (1U << 6);  ///< Interrupt request detected RC out of range of QPRC ch.0
        constexpr uint32_t QUD0INT3 = (1U << 5);  ///< PC count invert interrupt request of QPRC ch.0
        constexpr uint32_t QUD0INT2 = (1U << 4);  ///< Overflow/underflow/zero index interrupt request of QPRC ch.0
        constexpr uint32_t QUD0INT1 = (1U << 3);  ///< PC and RC match interrupt request of QPRC ch.0
        constexpr uint32_t QUD0INT0 = (1U << 2);  ///< PC match interrupt request of QPRC ch.0
        constexpr uint32_t TIMINT2 = (1U << 1);  ///< Dual timer TIMINT2 interrupt request
        constexpr uint32_t TIMINT1 = (1U << 0);  ///< Dual timer TIMINT1 interrupt request
    }

    /// IRQ07MON Register bits
    namespace irq07mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 8
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 0
    }

    /// IRQ08MON Register bits
    namespace irq08mon_bits {
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 8
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 8
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 0
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 0
    }

    /// IRQ09MON Register bits
    namespace irq09mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 9
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 1
    }

    /// IRQ10MON Register bits
    namespace irq10mon_bits {
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 9
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 9
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 1
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 1
    }

    /// IRQ11MON Register bits
    namespace irq11mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 10
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 2
    }

    /// IRQ12MON Register bits
    namespace irq12mon_bits {
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 10
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 10
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 2
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 2
    }

    /// IRQ13MON Register bits
    namespace irq13mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 11
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 3
    }

    /// IRQ14MON Register bits
    namespace irq14mon_bits {
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 11
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 11
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 3
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 3
    }

    /// IRQ15MON Register bits
    namespace irq15mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 12
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 4
    }

    /// IRQ16MON Register bits
    namespace irq16mon_bits {
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 12
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 12
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 4
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 4
    }

    /// IRQ17MON Register bits
    namespace irq17mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 13
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 5
    }

    /// IRQ18MON Register bits
    namespace irq18mon_bits {
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 13
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 13
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 5
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 5
    }

    /// IRQ19MON Register bits
    namespace irq19mon_bits {
        constexpr uint32_t DMAINT = (1U << 4);  ///< Interrupt request of DMAC ch.0
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 14
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 6
    }

    /// IRQ20MON Register bits
    namespace irq20mon_bits {
        constexpr uint32_t DMAINT = (1U << 4);  ///< Interrupt request of DMAC ch.1
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 14
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 14
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 6
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 6
    }

    /// IRQ21MON Register bits
    namespace irq21mon_bits {
        constexpr uint32_t DMAINT = (1U << 4);  ///< Interrupt request of DMAC ch.2
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Reception interrupt request of MFS channel 15
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Reception interrupt request of MFS channel 7
    }

    /// IRQ22MON Register bits
    namespace irq22mon_bits {
        constexpr uint32_t DMAINT = (1U << 4);  ///< Interrupt request of DMAC ch.3
        constexpr uint32_t MFSINT3 = (1U << 3);  ///< Status interrupt request of MFS channel 15
        constexpr uint32_t MFSINT2 = (1U << 2);  ///< Transmission interrupt request of MFS channel 15
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of MFS channel 7
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of MFS channel 7
    }

    /// IRQ23MON Register bits
    namespace irq23mon_bits {
        constexpr uint32_t PPGINT8 = (1U << 8);  ///< Interrupt request of PPG ch.20
        constexpr uint32_t PPGINT7 = (1U << 7);  ///< Interrupt request of PPG ch.18
        constexpr uint32_t PPGINT6 = (1U << 6);  ///< Interrupt request of PPG ch.16
        constexpr uint32_t PPGINT5 = (1U << 5);  ///< Interrupt request of PPG ch.12
        constexpr uint32_t PPGINT4 = (1U << 4);  ///< Interrupt request of PPG ch.10
        constexpr uint32_t PPGINT3 = (1U << 3);  ///< Interrupt request of PPG ch.8
        constexpr uint32_t PPGINT2 = (1U << 2);  ///< Interrupt request of PPG ch.4
        constexpr uint32_t PPGINT1 = (1U << 1);  ///< Interrupt request of PPG ch.2
        constexpr uint32_t PPGINT0 = (1U << 0);  ///< Interrupt request of PPG ch.0
    }

    /// IRQ24MON Register bits
    namespace irq24mon_bits {
        constexpr uint32_t RTCINT = (1U << 5);  ///< RTC interrupt request
        constexpr uint32_t WCINT = (1U << 4);  ///< Watch counter interrupt request
        constexpr uint32_t MPLLINT = (1U << 2);  ///< Stabilization wait completion interrupt request for main PLL oscillation
        constexpr uint32_t SOSCINT = (1U << 1);  ///< Stabilization wait completion interrupt request for sub-clock oscillation
        constexpr uint32_t MOSCINT = (1U << 0);  ///< Stabilization wait completion interrupt request for main clock oscillation
    }

    /// IRQ25MON Register bits
    namespace irq25mon_bits {
        constexpr uint32_t ADCINT4 = (1U << 4);  ///< Range comparison result interrupt request in the A/D converter unit 0
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request in the A/D converter unit 0
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request in the A/D converter unit 0
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request in the A/D converter unit 0
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request in the A/D converter unit 0
    }

    /// IRQ26MON Register bits
    namespace irq26mon_bits {
        constexpr uint32_t ADCINT4 = (1U << 4);  ///< Range comparison result interrupt request in the A/D converter unit 1
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request in the A/D converter unit 1
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request in the A/D converter unit 1
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request in the A/D converter unit 1
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request in the A/D converter unit 1
    }

    /// IRQ27MON Register bits
    namespace irq27mon_bits {
        constexpr uint32_t LCDCINT = (1U << 5);  ///< Interrupt request for LCD controller
        constexpr uint32_t ADCINT4 = (1U << 4);  ///< Range comparison result interrupt request in the A/D converter unit 2
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request in the A/D converter unit 2
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request in the A/D converter unit 2
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request in the A/D converter unit 2
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request in the A/D converter unit 2
    }

    /// IRQ28MON Register bits
    namespace irq28mon_bits {
        constexpr uint32_t FRT2INT5 = (1U << 17);  ///< Zero detection interrupt request of the free run timer ch.2 in the MFT unit 2
        constexpr uint32_t FRT2INT4 = (1U << 16);  ///< Zero detection interrupt request of the free run timer ch.1 in the MFT unit 2
        constexpr uint32_t FRT2INT3 = (1U << 15);  ///< Zero detection interrupt request of the free run timer ch.0 in the MFT unit 2
        constexpr uint32_t FRT2INT2 = (1U << 14);  ///< Peak value detection interrupt request of the free run timer ch.2 in the MFT unit 2
        constexpr uint32_t FRT2INT1 = (1U << 13);  ///< Peak value detection interrupt request of the free run timer ch.1 in the MFT unit 2
        constexpr uint32_t FRT2INT0 = (1U << 12);  ///< Peak value detection interrupt request of the free run timer ch.0 in the MFT unit 2
        constexpr uint32_t FRT1INT5 = (1U << 11);  ///< Zero detection interrupt request of the free run timer ch.2 in the MFT unit 1
        constexpr uint32_t FRT1INT4 = (1U << 10);  ///< Zero detection interrupt request of the free run timer ch.1 in the MFT unit 1
        constexpr uint32_t FRT1INT3 = (1U << 9);  ///< Zero detection interrupt request of the free run timer ch.0 in the MFT unit 1
        constexpr uint32_t FRT1INT2 = (1U << 8);  ///< Peak value detection interrupt request of the free run timer ch.2 in the MFT unit 1
        constexpr uint32_t FRT1INT1 = (1U << 7);  ///< Peak value detection interrupt request of the free run timer ch.1 in the MFT unit 1
        constexpr uint32_t FRT1INT0 = (1U << 6);  ///< Peak value detection interrupt request of the free run timer ch.0 in the MFT unit 1
        constexpr uint32_t FRT0INT5 = (1U << 5);  ///< Zero detection interrupt request of the free run timer ch.2 in the MFT unit 0
        constexpr uint32_t FRT0INT4 = (1U << 4);  ///< Zero detection interrupt request of the free run timer ch.1 in the MFT unit 0
        constexpr uint32_t FRT0INT3 = (1U << 3);  ///< Zero detection interrupt request of the free run timer ch.0 in the MFT unit 0
        constexpr uint32_t FRT0INT2 = (1U << 2);  ///< Peak value detection interrupt request of the free run timer ch.2 in the MFT unit 0
        constexpr uint32_t FRT0INT1 = (1U << 1);  ///< Peak value detection interrupt request of the free run timer ch.1 in the MFT unit 0
        constexpr uint32_t FRT0INT0 = (1U << 0);  ///< Peak value detection interrupt request of the free run timer ch.0 in the MFT unit 0
    }

    /// IRQ29MON Register bits
    namespace irq29mon_bits {
        constexpr uint32_t ICU2INT3 = (1U << 11);  ///< Interrupt request of the input capture ch.3 in the MFT unit 2
        constexpr uint32_t ICU2INT2 = (1U << 10);  ///< Interrupt request of the input capture ch.2 in the MFT unit 2
        constexpr uint32_t ICU2INT1 = (1U << 9);  ///< Interrupt request of the input capture ch.1 in the MFT unit 2
        constexpr uint32_t ICU2INT0 = (1U << 8);  ///< Interrupt request of the input capture ch.0 in the MFT unit 2
        constexpr uint32_t ICU1INT3 = (1U << 7);  ///< Interrupt request of the input capture ch.3 in the MFT unit 1
        constexpr uint32_t ICU1INT2 = (1U << 6);  ///< Interrupt request of the input capture ch.2 in the MFT unit 1
        constexpr uint32_t ICU1INT1 = (1U << 5);  ///< Interrupt request of the input capture ch.1 in the MFT unit 1
        constexpr uint32_t ICU1INT0 = (1U << 4);  ///< Interrupt request of the input capture ch.0 in the MFT unit 1
        constexpr uint32_t ICU0INT3 = (1U << 3);  ///< Interrupt request of the input capture ch.3 in the MFT unit 0
        constexpr uint32_t ICU0INT2 = (1U << 2);  ///< Interrupt request of the input capture ch.2 in the MFT unit 0
        constexpr uint32_t ICU0INT1 = (1U << 1);  ///< Interrupt request of the input capture ch.1 in the MFT unit 0
        constexpr uint32_t ICU0INT0 = (1U << 0);  ///< Interrupt request of the input capture ch.0 in the MFT unit 0
    }

    /// IRQ30MON Register bits
    namespace irq30mon_bits {
        constexpr uint32_t OCU2INT5 = (1U << 17);  ///< Interrupt request of the output compare ch.5 in the MFT unit 2
        constexpr uint32_t OCU2INT4 = (1U << 16);  ///< Interrupt request of the output compare ch.4 in the MFT unit 2
        constexpr uint32_t OCU2INT3 = (1U << 15);  ///< Interrupt request of the output compare ch.3 in the MFT unit 2
        constexpr uint32_t OCU2INT2 = (1U << 14);  ///< Interrupt request of the output compare ch.2 in the MFT unit 2
        constexpr uint32_t OCU2INT1 = (1U << 13);  ///< Interrupt request of the output compare ch.1 in the MFT unit 2
        constexpr uint32_t OCU2INT0 = (1U << 12);  ///< Interrupt request of the output compare ch.0 in the MFT unit 2
        constexpr uint32_t OCU1INT5 = (1U << 11);  ///< Interrupt request of the output compare ch.5 in the MFT unit 1
        constexpr uint32_t OCU1INT4 = (1U << 10);  ///< Interrupt request of the output compare ch.4 in the MFT unit 1
        constexpr uint32_t OCU1INT3 = (1U << 9);  ///< Interrupt request of the output compare ch.3 in the MFT unit 1
        constexpr uint32_t OCU1INT2 = (1U << 8);  ///< Interrupt request of the output compare ch.2 in the MFT unit 1
        constexpr uint32_t OCU1INT1 = (1U << 7);  ///< Interrupt request of the output compare ch.1 in the MFT unit 1
        constexpr uint32_t OCU1INT0 = (1U << 6);  ///< Interrupt request of the output compare ch.0 in the MFT unit 1
        constexpr uint32_t OCU0INT5 = (1U << 5);  ///< Interrupt request of the output compare ch.5 in the MFT unit 0
        constexpr uint32_t OCU0INT4 = (1U << 4);  ///< Interrupt request of the output compare ch.4 in the MFT unit 0
        constexpr uint32_t OCU0INT3 = (1U << 3);  ///< Interrupt request of the output compare ch.3 in the MFT unit 0
        constexpr uint32_t OCU0INT2 = (1U << 2);  ///< Interrupt request of the output compare ch.2 in the MFT unit 0
        constexpr uint32_t OCU0INT1 = (1U << 1);  ///< Interrupt request of the output compare ch.1 in the MFT unit 0
        constexpr uint32_t OCU0INT0 = (1U << 0);  ///< Interrupt request of the output compare ch.0 in the MFT unit 0
    }

    /// IRQ31MON Register bits
    namespace irq31mon_bits {
        constexpr uint32_t FLASHINT = (1U << 27);  ///< RDY/HANG interrupt request for f lash memory
        constexpr uint32_t BTINT15 = (1U << 15);  ///< IRQ1 interrupt request of the base timer ch.7
        constexpr uint32_t BTINT14 = (1U << 14);  ///< IRQ0 interrupt request of the base timer ch.7
        constexpr uint32_t BTINT13 = (1U << 13);  ///< IRQ1 interrupt request of the base timer ch.6
        constexpr uint32_t BTINT12 = (1U << 12);  ///< IRQ0 interrupt request of the base timer ch.6
        constexpr uint32_t BTINT11 = (1U << 11);  ///< IRQ1 interrupt request of the base timer ch.5
        constexpr uint32_t BTINT10 = (1U << 10);  ///< IRQ0 interrupt request of the base timer ch.5
        constexpr uint32_t BTINT9 = (1U << 9);  ///< IRQ1 interrupt request of the base timer ch.4
        constexpr uint32_t BTINT8 = (1U << 8);  ///< IRQ0 interrupt request of the base timer ch.4
        constexpr uint32_t BTINT7 = (1U << 7);  ///< IRQ1 interrupt request of the base timer ch.3
        constexpr uint32_t BTINT6 = (1U << 6);  ///< IRQ0 interrupt request of the base timer ch.3
        constexpr uint32_t BTINT5 = (1U << 5);  ///< IRQ1 interrupt request of the base timer ch.2
        constexpr uint32_t BTINT4 = (1U << 4);  ///< IRQ0 interrupt request of the base timer ch.2
        constexpr uint32_t BTINT3 = (1U << 3);  ///< IRQ1 interrupt request of the base timer ch.1
        constexpr uint32_t BTINT2 = (1U << 2);  ///< IRQ0 interrupt request of the base timer ch.1
        constexpr uint32_t BTINT1 = (1U << 1);  ///< IRQ1 interrupt request of the base timer ch.0
        constexpr uint32_t BTINT0 = (1U << 0);  ///< IRQ0 interrupt request of the base timer ch.0
    }

    /// RCINTSEL0 Register bits
    namespace rcintsel0_bits {
        constexpr uint32_t INTSEL3 = (8 << 24);  ///< Select the interrupt factor for the interrupt vector No.22
        constexpr uint32_t INTSEL2 = (8 << 16);  ///< Select the interrupt factor for the interrupt vector No.21
        constexpr uint32_t INTSEL1 = (8 << 8);  ///< Select the interrupt factor for the interrupt vector No.20
        constexpr uint32_t INTSEL0 = (8 << 0);  ///< Select the interrupt factor for the interrupt vector No.19
    }

    /// RCINTSEL1 Register bits
    namespace rcintsel1_bits {
        constexpr uint32_t INTSEL7 = (8 << 24);  ///< Select the interrupt factor for the interrupt vector No.26
        constexpr uint32_t INTSEL6 = (8 << 16);  ///< Select the interrupt factor for the interrupt vector No.25
        constexpr uint32_t INTSEL5 = (8 << 8);  ///< Select the interrupt factor for the interrupt vector No.24
        constexpr uint32_t INTSEL4 = (8 << 0);  ///< Select the interrupt factor for the interrupt vector No.23
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x40033000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PFR0;  ///< Offset: 0x00 - Port Function Setting Register 0
        volatile uint32_t PFR1;  ///< Offset: 0x04 - Port Function Setting Register 1
        volatile uint32_t PFR2;  ///< Offset: 0x08 - Port Function Setting Register 2
        volatile uint32_t PFR3;  ///< Offset: 0x0C - Port Function Setting Register 3
        volatile uint32_t PFR4;  ///< Offset: 0x10 - Port Function Setting Register 4
        volatile uint32_t PFR5;  ///< Offset: 0x14 - Port Function Setting Register 5
        volatile uint32_t PFR6;  ///< Offset: 0x18 - Port Function Setting Register 6
        volatile uint32_t PFR8;  ///< Offset: 0x20 - Port Function Setting Register 8
        volatile uint32_t PFRE;  ///< Offset: 0x38 - Port Function Setting Register E
        volatile uint32_t PCR0;  ///< Offset: 0x100 - Pull-up Setting Register 0
        volatile uint32_t PCR1;  ///< Offset: 0x104 - Pull-up Setting Register 1
        volatile uint32_t PCR2;  ///< Offset: 0x108 - Pull-up Setting Register 2
        volatile uint32_t PCR3;  ///< Offset: 0x10C - Pull-up Setting Register 3
        volatile uint32_t PCR4;  ///< Offset: 0x110 - Pull-up Setting Register 4
        volatile uint32_t PCR5;  ///< Offset: 0x114 - Pull-up Setting Register 5
        volatile uint32_t PCR6;  ///< Offset: 0x118 - Pull-up Setting Register 6
        volatile uint32_t PCR8;  ///< Offset: 0x120 - Pull-up Setting Register 8
        volatile uint32_t PCRE;  ///< Offset: 0x138 - Pull-up Setting Register E
        volatile uint32_t DDR0;  ///< Offset: 0x200 - Port input/output Direction Setting Register 0
        volatile uint32_t DDR1;  ///< Offset: 0x204 - Port input/output Direction Setting Register 1
        volatile uint32_t DDR2;  ///< Offset: 0x208 - Port input/output Direction Setting Register 2
        volatile uint32_t DDR3;  ///< Offset: 0x20C - Port input/output Direction Setting Register 3
        volatile uint32_t DDR4;  ///< Offset: 0x210 - Port input/output Direction Setting Register 4
        volatile uint32_t DDR5;  ///< Offset: 0x214 - Port input/output Direction Setting Register 5
        volatile uint32_t DDR6;  ///< Offset: 0x218 - Port input/output Direction Setting Register 6
        volatile uint32_t DDR8;  ///< Offset: 0x220 - Port input/output Direction Setting Register 8
        volatile uint32_t DDRE;  ///< Offset: 0x238 - Port input/output Direction Setting Register E
        volatile uint32_t PDIR0;  ///< Offset: 0x300 - Port Input Data Register 0
        volatile uint32_t PDIR1;  ///< Offset: 0x304 - Port Input Data Register 1
        volatile uint32_t PDIR2;  ///< Offset: 0x308 - Port Input Data Register 2
        volatile uint32_t PDIR3;  ///< Offset: 0x30C - Port Input Data Register 3
        volatile uint32_t PDIR4;  ///< Offset: 0x310 - Port Input Data Register 4
        volatile uint32_t PDIR5;  ///< Offset: 0x314 - Port Input Data Register 5
        volatile uint32_t PDIR6;  ///< Offset: 0x318 - Port Input Data Register 6
        volatile uint32_t PDIR8;  ///< Offset: 0x320 - Port Input Data Register 8
        volatile uint32_t PDIRE;  ///< Offset: 0x338 - Port Input Data Register E
        volatile uint32_t PDOR0;  ///< Offset: 0x400 - Port Output Data Register 0
        volatile uint32_t PDOR1;  ///< Offset: 0x404 - Port Output Data Register 1
        volatile uint32_t PDOR2;  ///< Offset: 0x408 - Port Output Data Register 2
        volatile uint32_t PDOR3;  ///< Offset: 0x40C - Port Output Data Register 3
        volatile uint32_t PDOR4;  ///< Offset: 0x410 - Port Output Data Register 4
        volatile uint32_t PDOR5;  ///< Offset: 0x414 - Port Output Data Register 5
        volatile uint32_t PDOR6;  ///< Offset: 0x418 - Port Output Data Register 6
        volatile uint32_t PDOR8;  ///< Offset: 0x420 - Port Output Data Register 8
        volatile uint32_t PDORE;  ///< Offset: 0x438 - Port Output Data Register E
        volatile uint32_t ADE;  ///< Offset: 0x500 - Analog Input Setting Register
        volatile uint32_t SPSR;  ///< Offset: 0x580 - Special Port Setting Register
        volatile uint32_t EPFR00;  ///< Offset: 0x600 - Extended Pin Function Setting Register 00
        volatile uint32_t EPFR01;  ///< Offset: 0x604 - Extended Pin Function Setting Register 01
        volatile uint32_t EPFR02;  ///< Offset: 0x608 - Extended Pin Function Setting Register 02
        volatile uint32_t EPFR03;  ///< Offset: 0x60C - Extended Pin Function Setting Register 03
        volatile uint32_t EPFR04;  ///< Offset: 0x610 - Extended Pin Function Setting Register 04
        volatile uint32_t EPFR05;  ///< Offset: 0x614 - Extended Pin Function Setting Register 05
        volatile uint32_t EPFR06;  ///< Offset: 0x618 - Extended Pin Function Setting Register 06
        volatile uint32_t EPFR07;  ///< Offset: 0x61C - Extended Pin Function Setting Register 07
        volatile uint32_t EPFR08;  ///< Offset: 0x620 - Extended Pin Function Setting Register 08
        volatile uint32_t EPFR09;  ///< Offset: 0x624 - Extended Pin Function Setting Register 09
        volatile uint32_t EPFR12;  ///< Offset: 0x630 - Extended Pin Function Setting Register 12
        volatile uint32_t EPFR13;  ///< Offset: 0x634 - Extended Pin Function Setting Register 13
        volatile uint32_t EPFR14;  ///< Offset: 0x638 - Extended Pin Function Setting Register 14
        volatile uint32_t EPFR15;  ///< Offset: 0x63C - Extended Pin Function Setting Register 15
        volatile uint32_t EPFR16;  ///< Offset: 0x640 - Extended Pin Function Setting Register 16
        volatile uint32_t EPFR17;  ///< Offset: 0x644 - Extended Pin Function Setting Register 17
        volatile uint32_t EPFR18;  ///< Offset: 0x648 - Extended Pin Function Setting Register 18
        volatile uint32_t EPFR21;  ///< Offset: 0x654 - Extended Pin Function Setting Register 21
        volatile uint32_t EPFR22;  ///< Offset: 0x658 - Extended Pin Function Setting Register 22
        volatile uint32_t PZR0;  ///< Offset: 0x700 - Port Pseudo Open Drain Setting Register 0
        volatile uint32_t PZR1;  ///< Offset: 0x704 - Port Pseudo Open Drain Setting Register 1
        volatile uint32_t PZR2;  ///< Offset: 0x708 - Port Pseudo Open Drain Setting Register 2
        volatile uint32_t PZR3;  ///< Offset: 0x70C - Port Pseudo Open Drain Setting Register 3
        volatile uint32_t PZR4;  ///< Offset: 0x710 - Port Pseudo Open Drain Setting Register 4
        volatile uint32_t PZR5;  ///< Offset: 0x714 - Port Pseudo Open Drain Setting Register 5
        volatile uint32_t PZR6;  ///< Offset: 0x718 - Port Pseudo Open Drain Setting Register 6
        volatile uint32_t PZR8;  ///< Offset: 0x720 - Port Pseudo Open Drain Setting Register 8
        volatile uint32_t PZRE;  ///< Offset: 0x738 - Port Pseudo Open Drain Setting Register E
        volatile uint32_t FPOER0;  ///< Offset: 0x900 - Fast GPIO Output Enable Register 0
        volatile uint32_t FPOER1;  ///< Offset: 0x904 - Fast GPIO Output Enable Register 1
        volatile uint32_t FPOER2;  ///< Offset: 0x908 - Fast GPIO Output Enable Register 2
        volatile uint32_t FPOER3;  ///< Offset: 0x90C - Fast GPIO Output Enable Register 3
        volatile uint32_t FPOER4;  ///< Offset: 0x910 - Fast GPIO Output Enable Register 4
        volatile uint32_t FPOER5;  ///< Offset: 0x914 - Fast GPIO Output Enable Register 5
        volatile uint32_t FPOER6;  ///< Offset: 0x918 - Fast GPIO Output Enable Register 6
        volatile uint32_t FPOER8;  ///< Offset: 0x920 - Fast GPIO Output Enable Register 8
        volatile uint32_t FPOERE;  ///< Offset: 0x938 - Fast GPIO Output Enable Register E
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// PFR0 Register bits
    namespace pfr0_bits {
        constexpr uint32_t P0F = (1U << 15);  ///< Bit15 of PFR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of PFR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of PFR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of PFR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of PFR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of PFR0
    }

    /// PFR1 Register bits
    namespace pfr1_bits {
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of PFR1
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of PFR1
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of PFR1
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of PFR1
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of PFR1
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of PFR1
    }

    /// PFR2 Register bits
    namespace pfr2_bits {
        constexpr uint32_t P23 = (1U << 3);  ///< Bit3 of PFR2
        constexpr uint32_t P22 = (1U << 2);  ///< Bit2 of PFR2
        constexpr uint32_t P21 = (1U << 1);  ///< Bit1 of PFR2
    }

    /// PFR3 Register bits
    namespace pfr3_bits {
        constexpr uint32_t P3F = (1U << 15);  ///< Bit15 of PFR3
        constexpr uint32_t P3E = (1U << 14);  ///< Bit14 of PFR3
        constexpr uint32_t P3D = (1U << 13);  ///< Bit13 of PFR3
        constexpr uint32_t P3C = (1U << 12);  ///< Bit12 of PFR3
        constexpr uint32_t P3B = (1U << 11);  ///< Bit11 of PFR3
        constexpr uint32_t P3A = (1U << 10);  ///< Bit10 of PFR3
        constexpr uint32_t P39 = (1U << 9);  ///< Bit9 of PFR3
    }

    /// PFR4 Register bits
    namespace pfr4_bits {
        constexpr uint32_t P4A = (1U << 10);  ///< Bit10 of PFR4
        constexpr uint32_t P49 = (1U << 9);  ///< Bit9 of PFR4
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of PFR4
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of PFR4
    }

    /// PFR5 Register bits
    namespace pfr5_bits {
        constexpr uint32_t P52 = (1U << 2);  ///< Bit2 of PFR5
        constexpr uint32_t P51 = (1U << 1);  ///< Bit1 of PFR5
        constexpr uint32_t P50 = (1U << 0);  ///< Bit0 of PFR5
    }

    /// PFR6 Register bits
    namespace pfr6_bits {
        constexpr uint32_t P61 = (1U << 1);  ///< Bit1 of PFR6
        constexpr uint32_t P60 = (1U << 0);  ///< Bit0 of PFR6
    }

    /// PFR8 Register bits
    namespace pfr8_bits {
        constexpr uint32_t P82 = (1U << 2);  ///< Bit2 of PFR8
        constexpr uint32_t P81 = (1U << 1);  ///< Bit1 of PFR8
        constexpr uint32_t P80 = (1U << 0);  ///< Bit0 of PFR8
    }

    /// PFRE Register bits
    namespace pfre_bits {
        constexpr uint32_t PE3 = (1U << 3);  ///< Bit3 of PFRE
        constexpr uint32_t PE2 = (1U << 2);  ///< Bit2 of PFRE
        constexpr uint32_t PE0 = (1U << 0);  ///< Bit0 of PFRE
    }

    /// DDR0 Register bits
    namespace ddr0_bits {
        constexpr uint32_t P0F = (1U << 15);  ///< Bit15 of DDR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of DDR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of DDR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of DDR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of DDR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of DDR0
    }

    /// PDIR0 Register bits
    namespace pdir0_bits {
        constexpr uint32_t P0F = (1U << 15);  ///< Bit15 of PDIR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of PDIR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of PDIR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of PDIR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of PDIR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of PDIR0
    }

    /// PDIR1 Register bits
    namespace pdir1_bits {
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of PDIR1
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of PDIR1
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of PDIR1
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of PDIR1
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of PDIR1
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of PDIR1
    }

    /// PDIR2 Register bits
    namespace pdir2_bits {
        constexpr uint32_t P23 = (1U << 3);  ///< Bit3 of PDIR2
        constexpr uint32_t P22 = (1U << 2);  ///< Bit2 of PDIR2
        constexpr uint32_t P21 = (1U << 1);  ///< Bit1 of PDIR2
    }

    /// PDIR3 Register bits
    namespace pdir3_bits {
        constexpr uint32_t P3F = (1U << 15);  ///< Bit15 of PDIR3
        constexpr uint32_t P3E = (1U << 14);  ///< Bit14 of PDIR3
        constexpr uint32_t P3D = (1U << 13);  ///< Bit13 of PDIR3
        constexpr uint32_t P3C = (1U << 12);  ///< Bit12 of PDIR3
        constexpr uint32_t P3B = (1U << 11);  ///< Bit11 of PDIR3
        constexpr uint32_t P3A = (1U << 10);  ///< Bit10 of PDIR3
        constexpr uint32_t P39 = (1U << 9);  ///< Bit9 of PDIR3
    }

    /// PDIR4 Register bits
    namespace pdir4_bits {
        constexpr uint32_t P4A = (1U << 10);  ///< Bit10 of PDIR4
        constexpr uint32_t P49 = (1U << 9);  ///< Bit9 of PDIR4
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of PDIR4
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of PDIR4
    }

    /// PDIR5 Register bits
    namespace pdir5_bits {
        constexpr uint32_t P52 = (1U << 2);  ///< Bit2 of PDIR5
        constexpr uint32_t P51 = (1U << 1);  ///< Bit1 of PDIR5
        constexpr uint32_t P50 = (1U << 0);  ///< Bit0 of PDIR5
    }

    /// PDIR6 Register bits
    namespace pdir6_bits {
        constexpr uint32_t P61 = (1U << 1);  ///< Bit1 of PDIR6
        constexpr uint32_t P60 = (1U << 0);  ///< Bit0 of PDIR6
    }

    /// PDIR8 Register bits
    namespace pdir8_bits {
        constexpr uint32_t P82 = (1U << 2);  ///< Bit2 of PDIR8
        constexpr uint32_t P81 = (1U << 1);  ///< Bit1 of PDIR8
        constexpr uint32_t P80 = (1U << 0);  ///< Bit0 of PDIR8
    }

    /// PDIRE Register bits
    namespace pdire_bits {
        constexpr uint32_t PE3 = (1U << 3);  ///< Bit3 of PDIRE
        constexpr uint32_t PE2 = (1U << 2);  ///< Bit2 of PDIRE
        constexpr uint32_t PE0 = (1U << 0);  ///< Bit0 of PDIRE
    }

    /// ADE Register bits
    namespace ade_bits {
        constexpr uint32_t AN31 = (1U << 31);  ///< Analog Input Ch.31 Setting Register
        constexpr uint32_t AN30 = (1U << 30);  ///< Analog Input Ch.30 Setting Register
        constexpr uint32_t AN29 = (1U << 29);  ///< Analog Input Ch.29 Setting Register
        constexpr uint32_t AN28 = (1U << 28);  ///< Analog Input Ch.28 Setting Register
        constexpr uint32_t AN27 = (1U << 27);  ///< Analog Input Ch.27 Setting Register
        constexpr uint32_t AN26 = (1U << 26);  ///< Analog Input Ch.26 Setting Register
        constexpr uint32_t AN25 = (1U << 25);  ///< Analog Input Ch.25 Setting Register
        constexpr uint32_t AN24 = (1U << 24);  ///< Analog Input Ch.24 Setting Register
        constexpr uint32_t AN23 = (1U << 23);  ///< Analog Input Ch.23 Setting Register
        constexpr uint32_t AN22 = (1U << 22);  ///< Analog Input Ch.22 Setting Register
        constexpr uint32_t AN21 = (1U << 21);  ///< Analog Input Ch.21 Setting Register
        constexpr uint32_t AN20 = (1U << 20);  ///< Analog Input Ch.20 Setting Register
        constexpr uint32_t AN19 = (1U << 19);  ///< Analog Input Ch.19 Setting Register
        constexpr uint32_t AN18 = (1U << 18);  ///< Analog Input Ch.18 Setting Register
        constexpr uint32_t AN17 = (1U << 17);  ///< Analog Input Ch.17 Setting Register
        constexpr uint32_t AN16 = (1U << 16);  ///< Analog Input Ch.16 Setting Register
        constexpr uint32_t AN15 = (1U << 15);  ///< Analog Input Ch.15 Setting Register
        constexpr uint32_t AN14 = (1U << 14);  ///< Analog Input Ch.14 Setting Register
        constexpr uint32_t AN13 = (1U << 13);  ///< Analog Input Ch.13 Setting Register
        constexpr uint32_t AN12 = (1U << 12);  ///< Analog Input Ch.12 Setting Register
        constexpr uint32_t AN11 = (1U << 11);  ///< Analog Input Ch.11 Setting Register
        constexpr uint32_t AN10 = (1U << 10);  ///< Analog Input Ch.10 Setting Register
        constexpr uint32_t AN09 = (1U << 9);  ///< Analog Input Ch.9 Setting Register
        constexpr uint32_t AN08 = (1U << 8);  ///< Analog Input Ch.8 Setting Register
        constexpr uint32_t AN07 = (1U << 7);  ///< Analog Input Ch.7 Setting Register
        constexpr uint32_t AN06 = (1U << 6);  ///< Analog Input Ch.6 Setting Register
        constexpr uint32_t AN05 = (1U << 5);  ///< Analog Input Ch.5 Setting Register
        constexpr uint32_t AN04 = (1U << 4);  ///< Analog Input Ch.4 Setting Register
        constexpr uint32_t AN03 = (1U << 3);  ///< Analog Input Ch.3 Setting Register
        constexpr uint32_t AN02 = (1U << 2);  ///< Analog Input Ch.2 Setting Register
        constexpr uint32_t AN01 = (1U << 1);  ///< Analog Input Ch.1 Setting Register
        constexpr uint32_t AN00 = (1U << 0);  ///< Analog Input Ch.0 Setting Register
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t MAINXC = (2 << 2);  ///< Main Clock (Oscillation) Pin Setting Register
        constexpr uint32_t SUBXC = (2 << 0);  ///< Sub Clock (Oscillation) Pin Setting Register
    }

    /// EPFR00 Register bits
    namespace epfr00_bits {
        constexpr uint32_t SWDEN = (1U << 16);  ///< Serial Wire Debug Function Select bit
        constexpr uint32_t SUBOUTE = (2 << 6);  ///< Sub clock divide output function select bit
        constexpr uint32_t RTCCOE = (2 << 4);  ///< RTC clock output select bit
        constexpr uint32_t CROUTE = (2 << 1);  ///< Internal high-speed CR Oscillation Output Function Select bit
        constexpr uint32_t NMIS = (1U << 0);  ///< NMIX Function Select bit
    }

    /// EPFR01 Register bits
    namespace epfr01_bits {
        constexpr uint32_t IC03S = (3 << 29);  ///< IC03 Input Select bits
        constexpr uint32_t IC02S = (3 << 26);  ///< IC02 Input Select bits
        constexpr uint32_t IC01S = (3 << 23);  ///< IC01 Input Select bits
        constexpr uint32_t IC00S = (3 << 20);  ///< IC00 Input Select bits
        constexpr uint32_t FRCK0S = (2 << 18);  ///< FRCK0 Input Select bits
        constexpr uint32_t DTTI0S = (2 << 16);  ///< DTTIX0 Input Select bits
        constexpr uint32_t DTTI0C = (1U << 12);  ///< DTTIX0 Function Select bit
        constexpr uint32_t RTO05E = (2 << 10);  ///< RTO05 Output Select bits
        constexpr uint32_t RTO04E = (2 << 8);  ///< RTO04 Output Select bits
        constexpr uint32_t RTO03E = (2 << 6);  ///< RTO03 Output Select bits
        constexpr uint32_t RTO02E = (2 << 4);  ///< RTO02 Output Select bits
        constexpr uint32_t RTO01E = (2 << 2);  ///< RTO01 Output Select bits
        constexpr uint32_t RTO00E = (2 << 0);  ///< RTO00 Output Select bits
    }

    /// EPFR02 Register bits
    namespace epfr02_bits {
        constexpr uint32_t IC13S = (3 << 29);  ///< IC13 Input Select bits
        constexpr uint32_t IC12S = (3 << 26);  ///< IC12 Input Select bits
        constexpr uint32_t IC11S = (3 << 23);  ///< IC11 Input Select bits
        constexpr uint32_t IC10S = (3 << 20);  ///< IC10 Input Select bits
        constexpr uint32_t FRCK1S = (2 << 18);  ///< FRCK1 Input Select bits
        constexpr uint32_t DTTI1S = (2 << 16);  ///< DTTIX1 Input Select bits
        constexpr uint32_t IGTRG0 = (1U << 13);  ///< IGTRG0 Input Select bit
        constexpr uint32_t DTTI1C = (1U << 12);  ///< DTTIX1 Function Select bit
        constexpr uint32_t RTO15E = (2 << 10);  ///< RTO15 Output Select bits
        constexpr uint32_t RTO14E = (2 << 8);  ///< RTO14 Output Select bits
        constexpr uint32_t RTO13E = (2 << 6);  ///< RTO13 Output Select bits
        constexpr uint32_t RTO12E = (2 << 4);  ///< RTO12 Output Select bits
        constexpr uint32_t RTO11E = (2 << 2);  ///< RTO11 Output Select bits
        constexpr uint32_t RTO10E = (2 << 0);  ///< RTO10 Output Select bits
    }

    /// EPFR03 Register bits
    namespace epfr03_bits {
        constexpr uint32_t IC23S = (3 << 29);  ///< IC23 Input Select bits
        constexpr uint32_t IC22S = (3 << 26);  ///< IC22 Input Select bits
        constexpr uint32_t IC21S = (3 << 23);  ///< IC21 Input Select bits
        constexpr uint32_t IC20S = (3 << 20);  ///< IC20 Input Select bits
        constexpr uint32_t FRCK2S = (2 << 18);  ///< FRCK2 Input Select bits
        constexpr uint32_t DTTI2S = (2 << 16);  ///< DTTIX2 Input Select bits
        constexpr uint32_t DTTI2C = (1U << 12);  ///< DTTIX2 Function Select bit
        constexpr uint32_t RTO25E = (2 << 10);  ///< RTO25 Output Select bits
        constexpr uint32_t RTO24E = (2 << 8);  ///< RTO24 Output Select bits
        constexpr uint32_t RTO23E = (2 << 6);  ///< RTO23 Output Select bits
        constexpr uint32_t RTO22E = (2 << 4);  ///< RTO22 Output Select bits
        constexpr uint32_t RTO21E = (2 << 2);  ///< RTO21 Output Select bits
        constexpr uint32_t RTO20E = (2 << 0);  ///< RTO20 Output Select bits
    }

    /// EPFR04 Register bits
    namespace epfr04_bits {
        constexpr uint32_t TIOB3S = (2 << 28);  ///< TIOB3 Input Select bits
        constexpr uint32_t TIOA3E = (2 << 26);  ///< TIOA3 Output Select bits
        constexpr uint32_t TIOA3S = (2 << 24);  ///< TIOA3 Input Select bits
        constexpr uint32_t TIOB2S = (2 << 20);  ///< TIOB2 Input Select bits
        constexpr uint32_t TIOA2E = (2 << 18);  ///< TIOA2 Output Select bits
        constexpr uint32_t TIOB1S = (2 << 12);  ///< TIOB1 Input Select bits
        constexpr uint32_t TIOA1E = (2 << 10);  ///< TIOA1 Output Select bits
        constexpr uint32_t TIOA1S = (2 << 8);  ///< TIOA1 Input Select bits
        constexpr uint32_t TIOB0S = (3 << 4);  ///< TIOB0 Input Select bits
        constexpr uint32_t TIOA0E = (2 << 2);  ///< TIOA0 Output Select bits
    }

    /// EPFR05 Register bits
    namespace epfr05_bits {
        constexpr uint32_t TIOB7S = (2 << 28);  ///< TIOB7 Input Select bits
        constexpr uint32_t TIOA7E = (2 << 26);  ///< TIOA7 Output Select bits
        constexpr uint32_t TIOA7S = (2 << 24);  ///< TIOA7 Input Select bits
        constexpr uint32_t TIOB6S = (2 << 20);  ///< TIOB6 Input Select bits
        constexpr uint32_t TIOA6E = (2 << 18);  ///< TIOA6 Output Select bits
        constexpr uint32_t TIOB5S = (2 << 12);  ///< TIOB5 Input Select bits
        constexpr uint32_t TIOA5E = (2 << 10);  ///< TIOA5 Output Select bits
        constexpr uint32_t TIOA5S = (2 << 8);  ///< TIOA5 Input Select bits
        constexpr uint32_t TIOB4S = (2 << 4);  ///< TIOB4 Input Select bits
        constexpr uint32_t TIOA4E = (2 << 2);  ///< TIOA4 Output Select bits
    }

    /// EPFR06 Register bits
    namespace epfr06_bits {
        constexpr uint32_t EINT15S = (2 << 30);  ///< External Interrupt 15 Input Select bits
        constexpr uint32_t EINT14S = (2 << 28);  ///< External Interrupt 14 Input Select bits
        constexpr uint32_t EINT13S = (2 << 26);  ///< External Interrupt 13 Input Select bits
        constexpr uint32_t EINT12S = (2 << 24);  ///< External Interrupt 12 Input Select bits
        constexpr uint32_t EINT11S = (2 << 22);  ///< External Interrupt 11 Input Select bits
        constexpr uint32_t EINT10S = (2 << 20);  ///< External Interrupt 10 Input Select bits
        constexpr uint32_t EINT09S = (2 << 18);  ///< External Interrupt 09 Input Select bits
        constexpr uint32_t EINT08S = (2 << 16);  ///< External Interrupt 08 Input Select bits
        constexpr uint32_t EINT07S = (2 << 14);  ///< External Interrupt 07 Input Select bits
        constexpr uint32_t EINT06S = (2 << 12);  ///< External Interrupt 06 Input Select bits
        constexpr uint32_t EINT05S = (2 << 10);  ///< External Interrupt 05 Input Select bits
        constexpr uint32_t EINT04S = (2 << 8);  ///< External Interrupt 04 Input Select bits
        constexpr uint32_t EINT03S = (2 << 6);  ///< External Interrupt 03 Input Select bits
        constexpr uint32_t EINT02S = (2 << 4);  ///< External Interrupt 02 Input Select bits
        constexpr uint32_t EINT01S = (2 << 2);  ///< External Interrupt 01 Input Select bits
        constexpr uint32_t EINT00S = (2 << 0);  ///< External Interrupt 00 Input Select bits
    }

    /// EPFR07 Register bits
    namespace epfr07_bits {
        constexpr uint32_t SCK3B = (2 << 26);  ///< SCK3 Input/Output Select bits
        constexpr uint32_t SOT3B = (2 << 24);  ///< SOT3 Input/Output Select bits
        constexpr uint32_t SIN3S = (2 << 22);  ///< SIN3 Input Select bits
        constexpr uint32_t SCK2B = (2 << 20);  ///< SCK2 Input/Output Select bits
        constexpr uint32_t SOT2B = (2 << 18);  ///< SOT2 Input/Output Select bits
        constexpr uint32_t SIN2S = (2 << 16);  ///< SIN2 Input Select bits
        constexpr uint32_t SCK1B = (2 << 14);  ///< SCK1 Input/Output Select bits
        constexpr uint32_t SOT1B = (2 << 12);  ///< SOT1 Input/Output Select bits
        constexpr uint32_t SIN1S = (2 << 10);  ///< SIN1 Input Select bits
        constexpr uint32_t SCK0B = (2 << 8);  ///< SCK0 Input/Output Select bits
        constexpr uint32_t SOT0B = (2 << 6);  ///< SOT0 Input/Output Select bits
        constexpr uint32_t SIN0S = (2 << 4);  ///< SIN0 Input Select bits
    }

    /// EPFR08 Register bits
    namespace epfr08_bits {
        constexpr uint32_t SCK7B = (2 << 26);  ///< SCK7 Input/Output Select bits
        constexpr uint32_t SOT7B = (2 << 24);  ///< SOT7 Input/Output Select bits
        constexpr uint32_t SIN7S = (2 << 22);  ///< SIN7 Input Select bits
        constexpr uint32_t SCK6B = (2 << 20);  ///< SCK6 Input/Output Select bits
        constexpr uint32_t SOT6B = (2 << 18);  ///< SOT6 Input/Output Select bits
        constexpr uint32_t SIN6S = (2 << 16);  ///< SIN6 Input Select bits
        constexpr uint32_t SCK5B = (2 << 14);  ///< SCK5 Input/Output Select bits
        constexpr uint32_t SOT5B = (2 << 12);  ///< SOT5 Input/Output Select bits
        constexpr uint32_t SIN5S = (2 << 10);  ///< SIN5 Input Select bits
        constexpr uint32_t SCK4B = (2 << 8);  ///< SCK4 Input/Output Select bits
        constexpr uint32_t SOT4B = (2 << 6);  ///< SOT4 Input/Output Select bits
        constexpr uint32_t SIN4S = (2 << 4);  ///< SIN4 Input Select bits
        constexpr uint32_t CTS4S = (2 << 2);  ///< CTS4 Input Select bits
        constexpr uint32_t RTS4E = (2 << 0);  ///< RTS4 Output Select bits
    }

    /// EPFR09 Register bits
    namespace epfr09_bits {
        constexpr uint32_t CTX1E = (2 << 30);  ///< CTX1E Output Select bits
        constexpr uint32_t CRX1S = (2 << 28);  ///< CRX1S Input Select bits
        constexpr uint32_t CTX0E = (2 << 26);  ///< CTX0E Output Select bits
        constexpr uint32_t CRX0S = (2 << 24);  ///< CRX0S Input Select bits
        constexpr uint32_t ADTRG2S = (4 << 20);  ///< ADTRG2 Input Select bits
        constexpr uint32_t ADTRG1S = (4 << 16);  ///< ADTRG1 Input Select bits
        constexpr uint32_t ADTRG0S = (4 << 12);  ///< ADTRG0 Input Select bits
        constexpr uint32_t QZIN1S = (2 << 10);  ///< QZIN1S Input Select bits
        constexpr uint32_t QBIN1S = (2 << 8);  ///< QBIN1S Input Select bits
        constexpr uint32_t QAIN1S = (2 << 6);  ///< QAIN1S Input Select bits
        constexpr uint32_t QZIN0S = (2 << 4);  ///< QZIN0S Input Select bits
        constexpr uint32_t QBIN0S = (2 << 2);  ///< QBIN0S Input Select bits
        constexpr uint32_t QAIN0S = (2 << 0);  ///< QAIN0S Input Select bits
    }

    /// EPFR12 Register bits
    namespace epfr12_bits {
        constexpr uint32_t TIOB11S = (2 << 28);  ///< TIOB11 Input Select bits
        constexpr uint32_t TIOA11E = (2 << 26);  ///< TIOA11 Output Select bits
        constexpr uint32_t TIOA11S = (2 << 24);  ///< TIOA11 Input Select bits
        constexpr uint32_t TIOB10S = (2 << 20);  ///< TIOB10 Input Select bits
        constexpr uint32_t TIOA10E = (2 << 18);  ///< TIOA10 Output Select bits
        constexpr uint32_t TIOB9S = (2 << 12);  ///< TIOB9 Input Select bits
        constexpr uint32_t TIOA9E = (2 << 10);  ///< TIOA9 Output Select bits
        constexpr uint32_t TIOA9S = (2 << 8);  ///< TIOA9 Input Select bits
        constexpr uint32_t TIOB8S = (2 << 4);  ///< TIOB8 Input Select bits
        constexpr uint32_t TIOA8E = (2 << 2);  ///< TIOA8 Output Select bits
    }

    /// EPFR13 Register bits
    namespace epfr13_bits {
        constexpr uint32_t TIOB15S = (2 << 28);  ///< TIOB15 Input Select bits
        constexpr uint32_t TIOA15E = (2 << 26);  ///< TIOA15 Output Select bits
        constexpr uint32_t TIOA15S = (2 << 24);  ///< TIOA15 Input Select bits
        constexpr uint32_t TIOB14S = (2 << 20);  ///< TIOB14 Input Select bits
        constexpr uint32_t TIOA14E = (2 << 18);  ///< TIOA14 Output Select bits
        constexpr uint32_t TIOB13S = (2 << 12);  ///< TIOB13 Input Select bits
        constexpr uint32_t TIOA13E = (2 << 10);  ///< TIOA13 Output Select bits
        constexpr uint32_t TIOA13S = (2 << 8);  ///< TIOA13 Input Select bits
        constexpr uint32_t TIOB12S = (2 << 4);  ///< TIOB12 Input Select bits
        constexpr uint32_t TIOA12E = (2 << 2);  ///< TIOA12 Output Select bits
    }

    /// EPFR14 Register bits
    namespace epfr14_bits {
        constexpr uint32_t QZIN2S = (2 << 4);  ///< QPRC-ch.2 ZIN Input Pin bits
        constexpr uint32_t QBIN2S = (2 << 2);  ///< QPRC-ch.2 BIN Input Pin bits
        constexpr uint32_t QAIN2S = (2 << 0);  ///< QPRC-ch.2 AIN Input Pin bits
    }

    /// EPFR15 Register bits
    namespace epfr15_bits {
        constexpr uint32_t EINT31S = (2 << 30);  ///< External Interrupt 31 Input Select bits
        constexpr uint32_t EINT30S = (2 << 28);  ///< External Interrupt 30 Input Select bits
        constexpr uint32_t EINT29S = (2 << 26);  ///< External Interrupt 29 Input Select bits
        constexpr uint32_t EINT28S = (2 << 24);  ///< External Interrupt 28 Input Select bits
        constexpr uint32_t EINT27S = (2 << 22);  ///< External Interrupt 27 Input Select bits
        constexpr uint32_t EINT26S = (2 << 20);  ///< External Interrupt 26 Input Select bits
        constexpr uint32_t EINT25S = (2 << 18);  ///< External Interrupt 25 Input Select bits
        constexpr uint32_t EINT24S = (2 << 16);  ///< External Interrupt 24 Input Select bits
        constexpr uint32_t EINT23S = (2 << 14);  ///< External Interrupt 23 Input Select bits
        constexpr uint32_t EINT22S = (2 << 12);  ///< External Interrupt 22 Input Select bits
        constexpr uint32_t EINT21S = (2 << 10);  ///< External Interrupt 21 Input Select bits
        constexpr uint32_t EINT20S = (2 << 8);  ///< External Interrupt 20 Input Select bits
        constexpr uint32_t EINT19S = (2 << 6);  ///< External Interrupt 19 Input Select bits
        constexpr uint32_t EINT18S = (2 << 4);  ///< External Interrupt 18 Input Select bits
        constexpr uint32_t EINT17S = (2 << 2);  ///< External Interrupt 17 Input Select bits
        constexpr uint32_t EINT16S = (2 << 0);  ///< External Interrupt 16 Input Select bits
    }

    /// EPFR16 Register bits
    namespace epfr16_bits {
        constexpr uint32_t SCK11B = (2 << 26);  ///< SCK11 Input/Output Select bits
        constexpr uint32_t SOT11B = (2 << 24);  ///< SOT11 Input/Output Select bits
        constexpr uint32_t SIN11S = (2 << 22);  ///< SIN11 Input Select bits
        constexpr uint32_t SCK10B = (2 << 20);  ///< SCK10 Input/Output Select bits
        constexpr uint32_t SOT10B = (2 << 18);  ///< SOT10 Input/Output Select bits
        constexpr uint32_t SIN10S = (2 << 16);  ///< SIN10 Input Select bits
        constexpr uint32_t SCK9B = (2 << 14);  ///< SCK9 Input/Output Select bits
        constexpr uint32_t SOT9B = (2 << 12);  ///< SOT9 Input/Output Select bits
        constexpr uint32_t SIN9S = (2 << 10);  ///< SIN9 Input Select bits
        constexpr uint32_t SCK8B = (2 << 8);  ///< SCK8 Input/Output Select bits
        constexpr uint32_t SOT8B = (2 << 6);  ///< SOT8 Input/Output Select bits
        constexpr uint32_t SIN8S = (2 << 4);  ///< SIN8 Input Select bits
    }

    /// EPFR17 Register bits
    namespace epfr17_bits {
        constexpr uint32_t SCK15B = (2 << 26);  ///< SCK15 Input/Output Select bits
        constexpr uint32_t SOT15B = (2 << 24);  ///< SOT15 Input/Output Select bits
        constexpr uint32_t SIN15S = (2 << 22);  ///< SIN15 Input Select bits
        constexpr uint32_t SCK14B = (2 << 20);  ///< SCK14 Input/Output Select bits
        constexpr uint32_t SOT14B = (2 << 18);  ///< SOT14 Input/Output Select bits
        constexpr uint32_t SIN14S = (2 << 16);  ///< SIN14 Input Select bits
        constexpr uint32_t SCK13B = (2 << 14);  ///< SCK13 Input/Output Select bits
        constexpr uint32_t SOT13B = (2 << 12);  ///< SOT13 Input/Output Select bits
        constexpr uint32_t SIN13S = (2 << 10);  ///< SIN13 Input Select bits
        constexpr uint32_t SCK12B = (2 << 8);  ///< SCK12 Input/Output Select bits
        constexpr uint32_t SOT12B = (2 << 6);  ///< SOT12 Input/Output Select bits
        constexpr uint32_t SIN12S = (2 << 4);  ///< SIN12 Input Select bits
    }

    /// EPFR18 Register bits
    namespace epfr18_bits {
        constexpr uint32_t CECR1B = (2 << 2);  ///< CEC1 input/output selection bits
        constexpr uint32_t CECR0B = (2 << 0);  ///< CEC0 input/output selection bits
    }

    /// EPFR21 Register bits
    namespace epfr21_bits {
        constexpr uint32_t QZIN0S = (1U << 2);  ///< QPRC-ch.0 ZIN Input Pin bits
        constexpr uint32_t QBIN0S = (1U << 1);  ///< QPRC-ch.0 BIN Input Pin bits
        constexpr uint32_t QAIN0S = (1U << 0);  ///< QPRC-ch.0 AIN Input Pin bits
    }

    /// EPFR22 Register bits
    namespace epfr22_bits {
        constexpr uint32_t SCS31E = (2 << 14);  ///< SCS31 Output Select bits
        constexpr uint32_t SCS30B = (2 << 12);  ///< SCS30 Input/Output Select bits
        constexpr uint32_t SCS11E = (2 << 6);  ///< SCS11 Output Select bits
        constexpr uint32_t SCS10B = (2 << 4);  ///< SCS10 Input/Output Select bits
    }

    /// FPOER0 Register bits
    namespace fpoer0_bits {
        constexpr uint32_t P0F = (1U << 15);  ///< Bit15 of FPOER0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of FPOER0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of FPOER0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of FPOER0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of FPOER0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of FPOER0
    }

    /// FPOER1 Register bits
    namespace fpoer1_bits {
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of FPOER1
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of FPOER1
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of FPOER1
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of FPOER1
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of FPOER1
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of FPOER1
    }

    /// FPOER2 Register bits
    namespace fpoer2_bits {
        constexpr uint32_t P23 = (1U << 3);  ///< Bit3 of FPOER2
        constexpr uint32_t P22 = (1U << 2);  ///< Bit2 of FPOER2
        constexpr uint32_t P21 = (1U << 1);  ///< Bit1 of FPOER2
    }

    /// FPOER3 Register bits
    namespace fpoer3_bits {
        constexpr uint32_t P3F = (1U << 15);  ///< Bit15 of FPOER3
        constexpr uint32_t P3E = (1U << 14);  ///< Bit14 of FPOER3
        constexpr uint32_t P3D = (1U << 13);  ///< Bit13 of FPOER3
        constexpr uint32_t P3C = (1U << 12);  ///< Bit12 of FPOER3
        constexpr uint32_t P3B = (1U << 11);  ///< Bit11 of FPOER3
        constexpr uint32_t P3A = (1U << 10);  ///< Bit10 of FPOER3
        constexpr uint32_t P39 = (1U << 9);  ///< Bit9 of FPOER3
    }

    /// FPOER4 Register bits
    namespace fpoer4_bits {
        constexpr uint32_t P4A = (1U << 10);  ///< Bit10 of FPOER4
        constexpr uint32_t P49 = (1U << 9);  ///< Bit9 of FPOER4
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of FPOER4
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of FPOER4
    }

    /// FPOER5 Register bits
    namespace fpoer5_bits {
        constexpr uint32_t P52 = (1U << 2);  ///< Bit2 of FPOER5
        constexpr uint32_t P51 = (1U << 1);  ///< Bit1 of FPOER5
        constexpr uint32_t P50 = (1U << 0);  ///< Bit0 of FPOER5
    }

    /// FPOER6 Register bits
    namespace fpoer6_bits {
        constexpr uint32_t P61 = (1U << 1);  ///< Bit1 of FPOER6
        constexpr uint32_t P60 = (1U << 0);  ///< Bit0 of FPOER6
    }

    /// FPOER8 Register bits
    namespace fpoer8_bits {
        constexpr uint32_t P82 = (1U << 2);  ///< Bit2 of FPOER8
        constexpr uint32_t P81 = (1U << 1);  ///< Bit1 of FPOER8
        constexpr uint32_t P80 = (1U << 0);  ///< Bit0 of FPOER8
    }

    /// FPOERE Register bits
    namespace fpoere_bits {
        constexpr uint32_t PE3 = (1U << 3);  ///< Bit3 of FPOERE
        constexpr uint32_t PE2 = (1U << 2);  ///< Bit2 of FPOERE
        constexpr uint32_t PE0 = (1U << 0);  ///< Bit0 of FPOERE
    }

}

// ============================================================================
// LVD Peripheral
// ============================================================================

namespace lvd {
    /// Base addresses
    constexpr uint32_t LVD_BASE = 0x40035000;

    /// LVD Register structure
    struct Registers {
        volatile uint32_t LVD_CTL;  ///< Offset: 0x00 - Low-voltage Detection Voltage Control Register
        volatile uint32_t LVD_STR;  ///< Offset: 0x04 - Low-voltage Detection Interrupt Factor Register
        volatile uint32_t LVD_CLR;  ///< Offset: 0x08 - Low-voltage Detection Interrupt Factor Clear Register
        volatile uint32_t LVD_RLR;  ///< Offset: 0x0C - Low-voltage Detection Voltage Protection Register
        volatile uint32_t LVD_STR2;  ///< Offset: 0x10 - Low-voltage Detection Circuit Status Register
    };

    /// Peripheral instances
    inline Registers* LVD = reinterpret_cast<Registers*>(LVD_BASE);

    // Bit definitions
    /// LVD_CTL Register bits
    namespace lvd_ctl_bits {
        constexpr uint32_t LVDRE = (1U << 15);  ///< Low-voltage detection reset operation enable bit
        constexpr uint32_t SVHR = (5 << 10);  ///< Low-voltage detection reset voltage setting bits
        constexpr uint32_t LVDIE = (1U << 7);  ///< Low-voltage detection interrupt enable bit
        constexpr uint32_t SVHI = (5 << 2);  ///< Low-voltage detection interrupt voltage setting bits
    }

    /// LVD_STR Register bits
    namespace lvd_str_bits {
        constexpr uint32_t LVDIR = (1U << 7);  ///< Low-voltage detection interrupt factor bit
    }

    /// LVD_CLR Register bits
    namespace lvd_clr_bits {
        constexpr uint32_t LVDCL = (1U << 7);  ///< Low-voltage detection interrupt factor clear bit
    }

    /// LVD_RLR Register bits
    namespace lvd_rlr_bits {
        constexpr uint32_t LVDLCK = (32 << 0);  ///< Low-voltage Detection Voltage Control Register protection bits
    }

    /// LVD_STR2 Register bits
    namespace lvd_str2_bits {
        constexpr uint32_t LVDIRDY = (1U << 7);  ///< Low-voltage detection interrupt status flag
        constexpr uint32_t LVDRRDY = (1U << 6);  ///< Low-voltage detection reset status flag
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x40035100;

    /// DS Register structure
    struct Registers {
        volatile uint32_t REG_CTL;  ///< Offset: 0x00 - Sub Oscillation Circuit Power Supply Control Register
        volatile uint32_t RCK_CTL;  ///< Offset: 0x04 - Sub Clock Control Register
        volatile uint32_t PMD_CTL;  ///< Offset: 0x700 - RTC Mode Control Register
        volatile uint32_t WRFSR;  ///< Offset: 0x704 - Deep Standby Return Factor Register 1
        volatile uint32_t WIFSR;  ///< Offset: 0x708 - Deep Standby Return Factor Register 2
        volatile uint32_t WIER;  ///< Offset: 0x70C - Deep Standby Return Enable Register
        volatile uint32_t WILVR;  ///< Offset: 0x710 - WKUP Pin Input Level Register
        volatile uint32_t DSRAMR;  ///< Offset: 0x714 - Deep Standby RAM Retention Register
        volatile uint32_t BUR01;  ///< Offset: 0x800 - Backup Register 01
        volatile uint32_t BUR02;  ///< Offset: 0x801 - Backup Register 02
        volatile uint32_t BUR03;  ///< Offset: 0x802 - Backup Register 03
        volatile uint32_t BUR04;  ///< Offset: 0x803 - Backup Register 04
        volatile uint32_t BUR05;  ///< Offset: 0x804 - Backup Register 05
        volatile uint32_t BUR06;  ///< Offset: 0x805 - Backup Register 06
        volatile uint32_t BUR07;  ///< Offset: 0x806 - Backup Register 07
        volatile uint32_t BUR08;  ///< Offset: 0x807 - Backup Register 08
        volatile uint32_t BUR09;  ///< Offset: 0x808 - Backup Register 09
        volatile uint32_t BUR10;  ///< Offset: 0x809 - Backup Register 10
        volatile uint32_t BUR11;  ///< Offset: 0x80A - Backup Register 11
        volatile uint32_t BUR12;  ///< Offset: 0x80B - Backup Register 12
        volatile uint32_t BUR13;  ///< Offset: 0x80C - Backup Register 13
        volatile uint32_t BUR14;  ///< Offset: 0x80D - Backup Register 14
        volatile uint32_t BUR15;  ///< Offset: 0x80E - Backup Register 15
        volatile uint32_t BUR16;  ///< Offset: 0x80F - Backup Register 16
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// REG_CTL Register bits
    namespace reg_ctl_bits {
        constexpr uint32_t ISUBSEL = (2 << 1);  ///< Sub oscillation circuit current setting bits
    }

    /// RCK_CTL Register bits
    namespace rck_ctl_bits {
        constexpr uint32_t CECCKE = (1U << 1);  ///< CEC clock control bit
        constexpr uint32_t RTCCKE = (1U << 0);  ///< RTC clock control bit
    }

    /// PMD_CTL Register bits
    namespace pmd_ctl_bits {
        constexpr uint32_t RTCE = (1U << 0);  ///< RTC mode control bit
    }

    /// WRFSR Register bits
    namespace wrfsr_bits {
        constexpr uint32_t WLVDH = (1U << 1);  ///< Low-voltage detection reset return bit
        constexpr uint32_t WINITX = (1U << 0);  ///< INITX pin input reset return bit
    }

    /// WIFSR Register bits
    namespace wifsr_bits {
        constexpr uint32_t WCEC1I = (1U << 9);  ///< CEC ch.1 interrupt return bit
        constexpr uint32_t WCEC0I = (1U << 8);  ///< CEC ch.0 interrupt return bit
        constexpr uint32_t WUI5 = (1U << 7);  ///< WKUP5 pin input return bit
        constexpr uint32_t WUI4 = (1U << 6);  ///< WKUP4 pin input return bit
        constexpr uint32_t WUI3 = (1U << 5);  ///< WKUP3 pin input return bit
        constexpr uint32_t WUI2 = (1U << 4);  ///< WKUP2 pin input return bit
        constexpr uint32_t WUI1 = (1U << 3);  ///< WKUP1 pin input return bit
        constexpr uint32_t WUI0 = (1U << 2);  ///< WKUP0 pin input return bit
        constexpr uint32_t WLVDI = (1U << 1);  ///< LVD interrupt return bit
        constexpr uint32_t WRTCI = (1U << 0);  ///< RTC interrupt return bit
    }

    /// WIER Register bits
    namespace wier_bits {
        constexpr uint32_t WCEC1E = (1U << 9);  ///< HDMI-CEC/ Remote Control Reception ch.1 interrupt return enable bit
        constexpr uint32_t WCEC0E = (1U << 8);  ///< HDMI-CEC/ Remote Control Reception ch.0 interrupt return enable bit
        constexpr uint32_t WUI5E = (1U << 7);  ///< WKUP5 pin input return enable bit
        constexpr uint32_t WUI4E = (1U << 6);  ///< WKUP4 pin input return enable bit
        constexpr uint32_t WUI3E = (1U << 5);  ///< WKUP3 pin input return enable bit
        constexpr uint32_t WUI2E = (1U << 4);  ///< WKUP2 pin input return enable bit
        constexpr uint32_t WUI1E = (1U << 3);  ///< WKUP1 pin input return enable bit
        constexpr uint32_t WLVDE = (1U << 1);  ///< LVD interrupt return enable bit
        constexpr uint32_t WRTCE = (1U << 0);  ///< RTC interrupt return enable bit
    }

    /// WILVR Register bits
    namespace wilvr_bits {
        constexpr uint32_t WUI5LV = (1U << 4);  ///< WKUP5 pin input level select bit
        constexpr uint32_t WUI4LV = (1U << 3);  ///< WKUP4 pin input level select bit
        constexpr uint32_t WUI3LV = (1U << 2);  ///< WKUP3 pin input level select bit
        constexpr uint32_t WUI2LV = (1U << 1);  ///< WKUP2 pin input level select bit
        constexpr uint32_t WUI1LV = (1U << 0);  ///< WKUP1 pin input level select bit
    }

    /// DSRAMR Register bits
    namespace dsramr_bits {
        constexpr uint32_t SRAMR = (2 << 0);  ///< On-chip SRAM retention control bits
    }

}

// ============================================================================
// MFS0 Peripheral
// ============================================================================

namespace mfs0 {
    /// Base addresses
    constexpr uint32_t MFS0_BASE = 0x40038000;

    /// MFS0 Register structure
    struct Registers {
        volatile uint32_t UART_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t UART_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t UART_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t UART_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t UART_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t UART_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t UART_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t UART_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t UART_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t UART_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t UART_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t CSIO_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t CSIO_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t CSIO_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t CSIO_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t CSIO_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t CSIO_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t CSIO_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t CSIO_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t CSIO_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t CSIO_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t CSIO_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t CSIO_SCSTR0;  ///< Offset: 0x1C - Serial Chip Select Timing Register 0
        volatile uint32_t CSIO_SCSTR1;  ///< Offset: 0x1D - Serial Chip Select Timing Register 1
        volatile uint32_t CSIO_SCSTR2;  ///< Offset: 0x20 - Serial Chip Select Timing Registers 2/3
        volatile uint32_t CSIO_SACSR;  ///< Offset: 0x24 - Serial Support Control Register
        volatile uint32_t CSIO_STMR;  ///< Offset: 0x28 - Serial Timer Register
        volatile uint32_t CSIO_STMCR;  ///< Offset: 0x2C - Serial Timer Comparison Register
        volatile uint32_t CSIO_SCSCR;  ///< Offset: 0x30 - Serial Chip Select Control Status Register
        volatile uint32_t CSIO_SCSFR0;  ///< Offset: 0x34 - Serial Chip Select Format Register 0
        volatile uint32_t CSIO_SCSFR1;  ///< Offset: 0x35 - Serial Chip Select Format Register 1
        volatile uint32_t CSIO_SCSFR2;  ///< Offset: 0x38 - Serial Chip Select Format Register 0
        volatile uint32_t CSIO_TBYTE0;  ///< Offset: 0x3C - Transfer Byte Register 0
        volatile uint32_t CSIO_TBYTE1;  ///< Offset: 0x3D - Transfer Byte Register 1
        volatile uint32_t CSIO_TBYTE2;  ///< Offset: 0x40 - Transfer Byte Register 2
        volatile uint32_t CSIO_TBYTE3;  ///< Offset: 0x41 - Transfer Byte Register 3
        volatile uint32_t LIN_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t LIN_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t LIN_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t LIN_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t LIN_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t LIN_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t LIN_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t LIN_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t LIN_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t LIN_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t LIN_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t I2C_IBCR;  ///< Offset: 0x01 - I2C Bus Control Register
        volatile uint32_t I2C_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t I2C_IBSR;  ///< Offset: 0x04 - I2C Bus Status Register
        volatile uint32_t I2C_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t I2C_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t I2C_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t I2C_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t I2C_ISMK;  ///< Offset: 0x11 - 7-bit Slave Address Mask Register
        volatile uint32_t I2C_ISBA;  ///< Offset: 0x10 - 7-bit Slave Address Register
        volatile uint32_t I2C_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t I2C_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t I2C_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t I2C_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t I2C_NFCR;  ///< Offset: 0x1C - Noise Filter Control Register
        volatile uint32_t I2C_EIBCR;  ///< Offset: 0x1D - Extension I2C Bus Control Register
    };

    /// Peripheral instances
    inline Registers* MFS0 = reinterpret_cast<Registers*>(MFS0_BASE);

    // Bit definitions
    /// UART_SCR Register bits
    namespace uart_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable Clear bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Received operation enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Transmission operation enable bit
    }

    /// UART_SMR Register bits
    namespace uart_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bit
        constexpr uint32_t SBL = (1U << 3);  ///< Stop bit length select bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// UART_SSR Register bits
    namespace uart_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t PE = (1U << 5);  ///< Parity error flag bit (only functions in operation mode 0)
        constexpr uint32_t FRE = (1U << 4);  ///< Framing error flag bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag
    }

    /// UART_ESCR Register bits
    namespace uart_escr_bits {
        constexpr uint32_t FLWEN = (1U << 7);  ///< Flow control enable bit
        constexpr uint32_t ESBL = (1U << 6);  ///< Extension stop bit length select bit
        constexpr uint32_t INV = (1U << 5);  ///< Inverted serial data format bit
        constexpr uint32_t PEN = (1U << 4);  ///< Parity enable bit (only functions in operation mode 0)
        constexpr uint32_t P = (1U << 3);  ///< Parity select bit (only functions in operation mode 0)
        constexpr uint32_t L = (3 << 0);  ///< Data length select bit
    }

    /// UART_RDR Register bits
    namespace uart_rdr_bits {
        constexpr uint32_t D = (9 << 0);  ///< Data
    }

    /// UART_TDR Register bits
    namespace uart_tdr_bits {
        constexpr uint32_t D = (9 << 0);  ///< Data
    }

    /// UART_BGR Register bits
    namespace uart_bgr_bits {
        constexpr uint32_t EXT = (1U << 15);  ///< External clock select bit
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Register 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Register 0
    }

    /// UART_FCR1 Register bits
    namespace uart_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// UART_FCR0 Register bits
    namespace uart_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// CSIO_SCR Register bits
    namespace csio_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable clear bit
        constexpr uint32_t MS = (1U << 6);  ///< Master/Slave function select bit
        constexpr uint32_t SPI = (1U << 5);  ///< SPI corresponding bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Data received enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Data transmission enable bit
    }

    /// CSIO_SMR Register bits
    namespace csio_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bits
        constexpr uint32_t SCINV = (1U << 3);  ///< Serial clock invert bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SCKE = (1U << 1);  ///< Master mode serial clock output enable bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// CSIO_SSR Register bits
    namespace csio_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit
    }

    /// CSIO_ESCR Register bits
    namespace csio_escr_bits {
        constexpr uint32_t SOP = (1U << 7);  ///< Serial output pin set bit
        constexpr uint32_t L3 = (1U << 6);  ///< Bit3 of Data length select bits
        constexpr uint32_t CSFE = (1U << 5);  ///< Serial Chip Select Format enable bit
        constexpr uint32_t WT = (2 << 3);  ///< Data transmit/received wait select bits
        constexpr uint32_t L = (3 << 0);  ///< Bit0-2 of Data length select bits
    }

    /// CSIO_RDR Register bits
    namespace csio_rdr_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data
    }

    /// CSIO_TDR Register bits
    namespace csio_tdr_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data
    }

    /// CSIO_BGR Register bits
    namespace csio_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Register 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Register 0
    }

    /// CSIO_FCR1 Register bits
    namespace csio_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// CSIO_FCR0 Register bits
    namespace csio_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// CSIO_SCSTR0 Register bits
    namespace csio_scstr0_bits {
        constexpr uint32_t CSHD = (8 << 0);  ///< Serial Chip Select Hold Delay bits
    }

    /// CSIO_SCSTR1 Register bits
    namespace csio_scstr1_bits {
        constexpr uint32_t CSSU = (8 << 0);  ///< Serial Chip Select Setup Delay bits
    }

    /// CSIO_SCSTR2 Register bits
    namespace csio_scstr2_bits {
        constexpr uint32_t CSDS = (16 << 0);  ///< Serial Chip Deselect bits
    }

    /// CSIO_SACSR Register bits
    namespace csio_sacsr_bits {
        constexpr uint32_t TBEEN = (1U << 13);  ///< Transfer Byte Error Enable bit
        constexpr uint32_t CSEIE = (1U << 12);  ///< Chip Select Error Interupt Enable bit
        constexpr uint32_t CSE = (1U << 11);  ///< Chip Select Error Flag
        constexpr uint32_t TINT = (1U << 8);  ///< Timer Interrupt Flag
        constexpr uint32_t TINTE = (1U << 7);  ///< Timer Interrupt Enable bit
        constexpr uint32_t TSYNE = (1U << 6);  ///< Synchronous Transmission Enable bit
        constexpr uint32_t TDIV = (4 << 1);  ///< Timer Operation Clock Division bit
        constexpr uint32_t TMRE = (1U << 0);  ///< Serial Timer Enable bit
    }

    /// CSIO_STMR Register bits
    namespace csio_stmr_bits {
        constexpr uint32_t TM = (16 << 0);  ///< Timer Data bits
    }

    /// CSIO_STMCR Register bits
    namespace csio_stmcr_bits {
        constexpr uint32_t TC = (16 << 0);  ///< Compare bits
    }

    /// CSIO_SCSCR Register bits
    namespace csio_scscr_bits {
        constexpr uint32_t SST = (2 << 14);  ///< Serial Chip Select Active Start bit
        constexpr uint32_t SED = (2 << 12);  ///< Serial Chip Select Active End bit
        constexpr uint32_t SCD = (2 << 10);  ///< Serial Chip Select Active Display bit
        constexpr uint32_t SCAM = (1U << 9);  ///< Serial Chip Select Active Hold bit
        constexpr uint32_t CDIV = (3 << 6);  ///< Serial Chip Select Timing Operation Clock Division bit
        constexpr uint32_t CSLVL = (1U << 5);  ///< Serial Chip Select Level Setting bit
        constexpr uint32_t CSEN3 = (1U << 4);  ///< Serial Chip Select Enable bit
        constexpr uint32_t CSEN2 = (1U << 3);  ///< Serial Chip Select Enable bit
        constexpr uint32_t CSEN1 = (1U << 2);  ///< Serial Chip Select Enable bit
        constexpr uint32_t CSEN0 = (1U << 1);  ///< Serial Chip Select Enable bit
        constexpr uint32_t CSOE = (1U << 0);  ///< Serial Chip Select Output Enable bit
    }

    /// CSIO_SCSFR0 Register bits
    namespace csio_scsfr0_bits {
        constexpr uint32_t CS1CSLVL = (1U << 7);  ///< Serial Chip Select 1 Level Setting bit
        constexpr uint32_t CS1SCINV = (1U << 6);  ///< Serial Clock Invert bit of Serial Chip Select 1
        constexpr uint32_t CS1SPI = (1U << 5);  ///< SPI corresponding bit of Serial Chip Select 1
        constexpr uint32_t CS1BDS = (1U << 4);  ///< Transfer direction select bit of Serial Chip Select 1
        constexpr uint32_t CS1L = (4 << 0);  ///< Data length select bits of Serial Chip Select 1
    }

    /// CSIO_SCSFR1 Register bits
    namespace csio_scsfr1_bits {
        constexpr uint32_t CS2CSLVL = (1U << 7);  ///< Serial Chip Select 2 Level Setting bit
        constexpr uint32_t CS2SCINV = (1U << 6);  ///< Serial Clock Invert bit of Serial Chip Select 2
        constexpr uint32_t CS2SPI = (1U << 5);  ///< SPI corresponding bit of Serial Chip Select 2
        constexpr uint32_t CS2BDS = (1U << 4);  ///< Transfer direction select bit of Serial Chip Select 2
        constexpr uint32_t CS2L = (4 << 0);  ///< Data length select bits of Serial Chip Select 2
    }

    /// CSIO_SCSFR2 Register bits
    namespace csio_scsfr2_bits {
        constexpr uint32_t CS0CSLVL = (1U << 7);  ///< Serial Chip Select 0 Level Setting bit
        constexpr uint32_t CS0SCINV = (1U << 6);  ///< Serial Clock Invert bit of Serial Chip Select 0
        constexpr uint32_t CS0SPI = (1U << 5);  ///< SPI corresponding bit of Serial Chip Select 0
        constexpr uint32_t CS0BDS = (1U << 4);  ///< Transfer direction select bit of Serial Chip Select 0
        constexpr uint32_t CS0L = (4 << 0);  ///< Data length select bits of Serial Chip Select 0
    }

    /// LIN_SCR Register bits
    namespace lin_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable clear bit
        constexpr uint32_t MS = (1U << 6);  ///< Master/Slave function select bit
        constexpr uint32_t LBR = (1U << 5);  ///< LIN Break Field setting bit (valid in master mode only)
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Data reception enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Data transmission enable bit
    }

    /// LIN_SMR Register bits
    namespace lin_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode setting bits
        constexpr uint32_t SBL = (1U << 3);  ///< Stop bit length select bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// LIN_SSR Register bits
    namespace lin_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received Error flag clear bit
        constexpr uint32_t LBD = (1U << 5);  ///< LIN Break field detection flag bit
        constexpr uint32_t FRE = (1U << 4);  ///< Framing error flag bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit
    }

    /// LIN_ESCR Register bits
    namespace lin_escr_bits {
        constexpr uint32_t ESBL = (1U << 6);  ///< Extended stop bit length select bit
        constexpr uint32_t LBIE = (1U << 4);  ///< LIN Break field detect interrupt enable bit
        constexpr uint32_t LBL = (2 << 2);  ///< LIN Break field length select bits (valid in master mode only)
        constexpr uint32_t DEL = (2 << 0);  ///< LIN Break delimiter length select bits (valid in master mode only)
    }

    /// LIN_RDR Register bits
    namespace lin_rdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// LIN_TDR Register bits
    namespace lin_tdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// LIN_BGR Register bits
    namespace lin_bgr_bits {
        constexpr uint32_t EXT = (1U << 15);  ///< External clock select bit
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// LIN_FCR1 Register bits
    namespace lin_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// LIN_FCR0 Register bits
    namespace lin_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// I2C_IBCR Register bits
    namespace i2c_ibcr_bits {
        constexpr uint32_t MSS = (1U << 7);  ///< Master/slave select bit
        constexpr uint32_t ACT_SCC = (1U << 6);  ///< Operation flag/iteration start condition generation bit
        constexpr uint32_t ACKE = (1U << 5);  ///< Data byte acknowledge enable bit
        constexpr uint32_t WSEL = (1U << 4);  ///< Wait selection bit
        constexpr uint32_t CNDE = (1U << 3);  ///< Condition detection interrupt enable bit
        constexpr uint32_t INTE = (1U << 2);  ///< Interrupt enable bit
        constexpr uint32_t BER = (1U << 1);  ///< Bus error flag bit
        constexpr uint32_t INT = (1U << 0);  ///< Interrupt flag bit
    }

    /// I2C_SMR Register bits
    namespace i2c_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bits
        constexpr uint32_t RIE = (1U << 3);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 2);  ///< Transmit interrupt enable bit
    }

    /// I2C_IBSR Register bits
    namespace i2c_ibsr_bits {
        constexpr uint32_t FBT = (1U << 7);  ///< First byte bit
        constexpr uint32_t RACK = (1U << 6);  ///< Acknowledge flag bit
        constexpr uint32_t RSA = (1U << 5);  ///< Reserved address detection bit
        constexpr uint32_t TRX = (1U << 4);  ///< Data direction bit
        constexpr uint32_t AL = (1U << 3);  ///< Arbitration lost bit
        constexpr uint32_t RSC = (1U << 2);  ///< Iteration start condition check bit
        constexpr uint32_t SPC = (1U << 1);  ///< Stop condition check bit
        constexpr uint32_t BB = (1U << 0);  ///< Bus state bit
    }

    /// I2C_SSR Register bits
    namespace i2c_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t TSET = (1U << 6);  ///< Transmit empty flag set bit
        constexpr uint32_t DMA = (1U << 5);  ///< DMA mode enable bit
        constexpr uint32_t TBIE = (1U << 4);  ///< Transmit bus idle interrupt enable bit (Effective only when DMA mode is enabled)
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit (Effective only when DMA mode is enabled)
    }

    /// I2C_RDR Register bits
    namespace i2c_rdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// I2C_TDR Register bits
    namespace i2c_tdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// I2C_BGR Register bits
    namespace i2c_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Register 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Register 0
    }

    /// I2C_ISMK Register bits
    namespace i2c_ismk_bits {
        constexpr uint32_t EN = (1U << 7);  ///< I2C interface operation enable bit
        constexpr uint32_t SM = (7 << 0);  ///< Slave address mask bits
    }

    /// I2C_ISBA Register bits
    namespace i2c_isba_bits {
        constexpr uint32_t SAEN = (1U << 7);  ///< Slave address enable bit
        constexpr uint32_t SA = (7 << 0);  ///< 7-bit slave address
    }

    /// I2C_FCR1 Register bits
    namespace i2c_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// I2C_FCR0 Register bits
    namespace i2c_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// I2C_NFCR Register bits
    namespace i2c_nfcr_bits {
        constexpr uint32_t NFT = (5 << 0);  ///< Noise Filter Time Select bits
    }

    /// I2C_EIBCR Register bits
    namespace i2c_eibcr_bits {
        constexpr uint32_t SDAS = (1U << 5);  ///< SDA status bit
        constexpr uint32_t SCLS = (1U << 4);  ///< SCL status bit
        constexpr uint32_t SDAC = (1U << 3);  ///< SDA output control bit
        constexpr uint32_t SCLC = (1U << 2);  ///< SCL output control bit
        constexpr uint32_t SOCE = (1U << 1);  ///< Serial output enabled bit
        constexpr uint32_t BEC = (1U << 0);  ///< Bus error control bit
    }

}

// ============================================================================
// MFS1 Peripheral
// ============================================================================

namespace mfs1 {
    /// Base addresses
    constexpr uint32_t MFS1_BASE = 0x40038100;

    /// MFS1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS1 = reinterpret_cast<Registers*>(MFS1_BASE);

}

// ============================================================================
// MFS3 Peripheral
// ============================================================================

namespace mfs3 {
    /// Base addresses
    constexpr uint32_t MFS3_BASE = 0x40038300;

    /// MFS3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS3 = reinterpret_cast<Registers*>(MFS3_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40039000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR;  ///< Offset: 0x00 - CRC Control Register
        volatile uint32_t CRCINIT;  ///< Offset: 0x04 - Initial Value Register
        volatile uint32_t CRCIN;  ///< Offset: 0x08 - Input Data Register
        volatile uint32_t CRCR;  ///< Offset: 0x0C - CRC Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR Register bits
    namespace crccr_bits {
        constexpr uint32_t FXOR = (1U << 6);  ///< Final XOR control bit
        constexpr uint32_t CRCLSF = (1U << 5);  ///< CRC result bit-order setting bit
        constexpr uint32_t CRCLTE = (1U << 4);  ///< CRC result byte-order setting bit
        constexpr uint32_t LSBFST = (1U << 3);  ///< Bit-order setting bit
        constexpr uint32_t LTLEND = (1U << 2);  ///< Byte-order setting bit
        constexpr uint32_t CRC32 = (1U << 1);  ///< CRC mode selection bit
        constexpr uint32_t INIT = (1U << 0);  ///< Initialization bit
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t D = (32 << 0);  ///< Initial value bits
    }

    /// CRCIN Register bits
    namespace crcin_bits {
        constexpr uint32_t D = (32 << 0);  ///< Input data bits
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t D = (32 << 0);  ///< CRC bits
    }

}

// ============================================================================
// WC Peripheral
// ============================================================================

namespace wc {
    /// Base addresses
    constexpr uint32_t WC_BASE = 0x4003A000;

    /// WC Register structure
    struct Registers {
        volatile uint32_t WCRD;  ///< Offset: 0x00 - Watch Counter Read Register
        volatile uint32_t WCRL;  ///< Offset: 0x01 - Watch Counter Reload Register
        volatile uint32_t WCCR;  ///< Offset: 0x02 - Watch Counter Control Register
        volatile uint32_t CLK_SEL;  ///< Offset: 0x10 - Clock Selection Register
        volatile uint32_t CLK_EN;  ///< Offset: 0x14 - Division Clock Enable Register
    };

    /// Peripheral instances
    inline Registers* WC = reinterpret_cast<Registers*>(WC_BASE);

    // Bit definitions
    /// WCRD Register bits
    namespace wcrd_bits {
        constexpr uint32_t CTR = (6 << 0);  ///< Counter read bits
    }

    /// WCRL Register bits
    namespace wcrl_bits {
        constexpr uint32_t RLC = (6 << 0);  ///< Counter reload value setting bits
    }

    /// WCCR Register bits
    namespace wccr_bits {
        constexpr uint32_t WCEN = (1U << 7);  ///< Watch counter operation enable bit
        constexpr uint32_t WCOP = (1U << 6);  ///< Watch counter operating state flag
        constexpr uint32_t CS = (2 << 2);  ///< Count clock select bits
        constexpr uint32_t WCIE = (1U << 1);  ///< Interrupt request enable bit
        constexpr uint32_t WCIF = (1U << 0);  ///< Interrupt request flag bit
    }

    /// CLK_SEL Register bits
    namespace clk_sel_bits {
        constexpr uint32_t SEL_OUT = (3 << 8);  ///< Output clock selection bit
        constexpr uint32_t SEL_IN = (2 << 0);  ///< Input clock selection bit
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN_R = (1U << 1);  ///< Division clock enable read bit
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Division clock enable bit
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003B000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t WTCR1;  ///< Offset: 0x00 - Control Register 1
        volatile uint32_t WTCR2;  ///< Offset: 0x04 - Control Register 2
        volatile uint32_t WTBR;  ///< Offset: 0x08 - Counter Cycle Setting Register
        volatile uint32_t WTDR;  ///< Offset: 0x0F - Date Register
        volatile uint32_t WTHR;  ///< Offset: 0x0E - Hour register
        volatile uint32_t WTMIR;  ///< Offset: 0x0D - Minute Register
        volatile uint32_t WTSR;  ///< Offset: 0x0C - Second Register
        volatile uint32_t WTYR;  ///< Offset: 0x12 - Year Register
        volatile uint32_t WTMOR;  ///< Offset: 0x11 - Month Register
        volatile uint32_t WTDW;  ///< Offset: 0x10 - Day of the Week Register
        volatile uint32_t ALDR;  ///< Offset: 0x17 - Alarm Date Register
        volatile uint32_t ALHR;  ///< Offset: 0x16 - Alarm Hour Register
        volatile uint32_t ALMIR;  ///< Offset: 0x15 - Alarm Minute Register
        volatile uint32_t ALYR;  ///< Offset: 0x1A - Alarm Years Register
        volatile uint32_t ALMOR;  ///< Offset: 0x19 - Alarm Month Register
        volatile uint32_t WTTR;  ///< Offset: 0x1C - Timer Setting Register
        volatile uint32_t WTCLKS;  ///< Offset: 0x20 - Clock Selection Register
        volatile uint32_t WTCLKM;  ///< Offset: 0x21 - Selection Clock Status Register
        volatile uint32_t WTCAL;  ///< Offset: 0x24 - Frequency Correction Value Setting Register
        volatile uint32_t WTCALEN;  ///< Offset: 0x26 - Frequency Correction Enable Register
        volatile uint32_t WTDIV;  ///< Offset: 0x28 - Divider Ratio Setting Register
        volatile uint32_t WTDIVEN;  ///< Offset: 0x29 - Divider Output Enable Register
        volatile uint32_t WTCALPRD;  ///< Offset: 0x2C - Frequency Correction Cycle Setting Register
        volatile uint32_t WTCOSEL;  ///< Offset: 0x30 - RTCCO Output Selection Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// WTCR1 Register bits
    namespace wtcr1_bits {
        constexpr uint32_t INTCRIE = (1U << 31);  ///< Year/month/date/hour/minute/second/day of the week counter value read completion interrupt enable bit
        constexpr uint32_t INTERIE = (1U << 30);  ///< Time rewrite error interrupt enable bit
        constexpr uint32_t INTALIE = (1U << 29);  ///< Alarm interrupt enable bit
        constexpr uint32_t INTTMIE = (1U << 28);  ///< Timer interrupt enable bit
        constexpr uint32_t INTHIE = (1U << 27);  ///< 1-hour interrupt enable bit
        constexpr uint32_t INTMIE = (1U << 26);  ///< 1-minute interrupt enable bit
        constexpr uint32_t INTSIE = (1U << 25);  ///< 1-second interrupt enable bit
        constexpr uint32_t INTSSIE = (1U << 24);  ///< 0.5-second interrupt enable bit
        constexpr uint32_t INTCRI = (1U << 23);  ///< Year/month/date/hour/minute/second/day of the week counter value read completion interrupt flag bit
        constexpr uint32_t INTERI = (1U << 22);  ///< Time rewrite error interrupt flag bit
        constexpr uint32_t INTALI = (1U << 21);  ///< Alarm interrupt flag bit
        constexpr uint32_t INTTMI = (1U << 20);  ///< Timer interrupt flag bit
        constexpr uint32_t INTHI = (1U << 19);  ///< 1-hour interrupt flag bit
        constexpr uint32_t INTMI = (1U << 18);  ///< 1-minute interrupt flag bit
        constexpr uint32_t INTSI = (1U << 17);  ///< 1-second interrupt flag bit
        constexpr uint32_t INTSSI = (1U << 16);  ///< 0.5-second interrupt flag bit
        constexpr uint32_t YEN = (1U << 12);  ///< Alarm year register enable bit
        constexpr uint32_t MOEN = (1U << 11);  ///< Alarm month register enable bit
        constexpr uint32_t DEN = (1U << 10);  ///< Alarm date register enable bit
        constexpr uint32_t HEN = (1U << 9);  ///< Alarm hour register enable bit
        constexpr uint32_t MIEN = (1U << 8);  ///< Alarm minute register enable bit
        constexpr uint32_t BUSY = (1U << 6);  ///< Busy bit
        constexpr uint32_t SCRST = (1U << 5);  ///< Sub second generation/1-second generation counter reset bit
        constexpr uint32_t SCST = (1U << 4);  ///< 1-second clock output stop bit
        constexpr uint32_t SRST = (1U << 3);  ///< RTC reset bit
        constexpr uint32_t RUN = (1U << 2);  ///< RTC count block operation bit
        constexpr uint32_t ST = (1U << 0);  ///< Start bit
    }

    /// WTCR2 Register bits
    namespace wtcr2_bits {
        constexpr uint32_t TMRUN = (1U << 10);  ///< Timer counter operation bit
        constexpr uint32_t TMEN = (1U << 9);  ///< Timer counter control bit
        constexpr uint32_t TMST = (1U << 8);  ///< Timer counter start bit
        constexpr uint32_t CREAD = (1U << 0);  ///< Year/month/date/hour/minute/second/day of the week counter value read control bit
    }

    /// WTBR Register bits
    namespace wtbr_bits {
        constexpr uint32_t BR23 = (1U << 23);  ///< Bit23 of WTBR
        constexpr uint32_t BR22 = (1U << 22);  ///< Bit22 of WTBR
        constexpr uint32_t BR21 = (1U << 21);  ///< Bit21 of WTBR
        constexpr uint32_t BR20 = (1U << 20);  ///< Bit20 of WTBR
        constexpr uint32_t BR19 = (1U << 19);  ///< Bit19 of WTBR
        constexpr uint32_t BR18 = (1U << 18);  ///< Bit18 of WTBR
        constexpr uint32_t BR17 = (1U << 17);  ///< Bit17 of WTBR
        constexpr uint32_t BR16 = (1U << 16);  ///< Bit16 of WTBR
        constexpr uint32_t BR15 = (1U << 15);  ///< Bit15 of WTBR
        constexpr uint32_t BR14 = (1U << 14);  ///< Bit14 of WTBR
        constexpr uint32_t BR13 = (1U << 13);  ///< Bit13 of WTBR
        constexpr uint32_t BR12 = (1U << 12);  ///< Bit12 of WTBR
        constexpr uint32_t BR11 = (1U << 11);  ///< Bit11 of WTBR
        constexpr uint32_t BR10 = (1U << 10);  ///< Bit10 of WTBR
        constexpr uint32_t BR9 = (1U << 9);  ///< Bit9 of WTBR
        constexpr uint32_t BR8 = (1U << 8);  ///< Bit8 of WTBR
        constexpr uint32_t BR7 = (1U << 7);  ///< Bit7 of WTBR
        constexpr uint32_t BR6 = (1U << 6);  ///< Bit6 of WTBR
        constexpr uint32_t BR5 = (1U << 5);  ///< Bit5 of WTBR
        constexpr uint32_t BR4 = (1U << 4);  ///< Bit4 of WTBR
        constexpr uint32_t BR3 = (1U << 3);  ///< Bit3 of WTBR
        constexpr uint32_t BR2 = (1U << 2);  ///< Bit2 of WTBR
        constexpr uint32_t BR1 = (1U << 1);  ///< Bit1 of WTBR
        constexpr uint32_t BR0 = (1U << 0);  ///< Bit0 of WTBR
    }

    /// WTDR Register bits
    namespace wtdr_bits {
        constexpr uint32_t TD = (2 << 4);  ///< The second digit of the date
        constexpr uint32_t D = (4 << 0);  ///< The first digit of the date
    }

    /// WTHR Register bits
    namespace wthr_bits {
        constexpr uint32_t TH = (2 << 4);  ///< The second digit of the hour
        constexpr uint32_t H = (4 << 0);  ///< The first digit of the hour
    }

    /// WTMIR Register bits
    namespace wtmir_bits {
        constexpr uint32_t TMI = (3 << 4);  ///< The second digit of the minute
        constexpr uint32_t MI = (4 << 0);  ///< The first digit of the minute
    }

    /// WTSR Register bits
    namespace wtsr_bits {
        constexpr uint32_t TS = (3 << 4);  ///< The second digit of the second
        constexpr uint32_t S = (4 << 0);  ///< The first digit of the second
    }

    /// WTYR Register bits
    namespace wtyr_bits {
        constexpr uint32_t TY = (4 << 4);  ///< The second digit of the year
        constexpr uint32_t Y = (4 << 0);  ///< The first digit of the year
    }

    /// WTMOR Register bits
    namespace wtmor_bits {
        constexpr uint32_t TMO0 = (1U << 4);  ///< The second digit in the month
        constexpr uint32_t MO = (4 << 0);  ///< The first digit of the month
    }

    /// WTDW Register bits
    namespace wtdw_bits {
        constexpr uint32_t DW = (3 << 0);  ///< Day of the week
    }

    /// ALDR Register bits
    namespace aldr_bits {
        constexpr uint32_t TAD = (2 << 4);  ///< The second digit of the alarm-set date
        constexpr uint32_t AD = (4 << 0);  ///< The first digit of the alarm-set date
    }

    /// ALHR Register bits
    namespace alhr_bits {
        constexpr uint32_t TAH = (2 << 4);  ///< The second digit of the alarm-set hour
        constexpr uint32_t AH = (4 << 0);  ///< The first digit of the alarm-set hour
    }

    /// ALMIR Register bits
    namespace almir_bits {
        constexpr uint32_t TAMI = (3 << 4);  ///< The second digit of the alarm-set minute
        constexpr uint32_t AMI = (4 << 0);  ///< The first digit of the alarm-set minute
    }

    /// ALYR Register bits
    namespace alyr_bits {
        constexpr uint32_t TAY = (4 << 4);  ///< The second digit of the alarm-set year
        constexpr uint32_t AY = (4 << 0);  ///< The first digit of the alarm-set year
    }

    /// ALMOR Register bits
    namespace almor_bits {
        constexpr uint32_t TAMO0 = (1U << 4);  ///< The second digit of the alarm-set month
        constexpr uint32_t AMO = (4 << 0);  ///< The first digit of the alarm-set month
    }

    /// WTTR Register bits
    namespace wttr_bits {
        constexpr uint32_t TM = (18 << 0);  ///< Timer setting register
    }

    /// WTCLKS Register bits
    namespace wtclks_bits {
        constexpr uint32_t WTCLKS = (1U << 0);  ///< Input clock selection bit
    }

    /// WTCLKM Register bits
    namespace wtclkm_bits {
        constexpr uint32_t WTCLKM = (2 << 0);  ///< Clock selection status bits
    }

    /// WTCAL Register bits
    namespace wtcal_bits {
        constexpr uint32_t WTCAL = (10 << 0);  ///< Frequency correction value setting bits
    }

    /// WTCALEN Register bits
    namespace wtcalen_bits {
        constexpr uint32_t WTCALEN = (1U << 0);  ///< Frequency correction enable bit
    }

    /// WTDIV Register bits
    namespace wtdiv_bits {
        constexpr uint32_t WTDIV = (4 << 0);  ///< Divider ratio setting bits
    }

    /// WTDIVEN Register bits
    namespace wtdiven_bits {
        constexpr uint32_t WTDIVRDY = (1U << 1);  ///< Divider status bit
        constexpr uint32_t WTDIVEN = (1U << 0);  ///< Divider enable bit
    }

    /// WTCALPRD Register bits
    namespace wtcalprd_bits {
        constexpr uint32_t WTCALPRD = (6 << 0);  ///< Frequency correction value setting bits
    }

    /// WTCOSEL Register bits
    namespace wtcosel_bits {
        constexpr uint32_t WTCOSEL = (1U << 0);  ///< RTCCO output selection bit
    }

}

// ============================================================================
// LSCRP Peripheral
// ============================================================================

namespace lscrp {
    /// Base addresses
    constexpr uint32_t LSCRP_BASE = 0x4003C000;

    /// LSCRP Register structure
    struct Registers {
        volatile uint32_t LCR_PRSLD;  ///< Offset: 0x00 - Low-speed CR Prescaler Control Register
    };

    /// Peripheral instances
    inline Registers* LSCRP = reinterpret_cast<Registers*>(LSCRP_BASE);

    // Bit definitions
    /// LCR_PRSLD Register bits
    namespace lcr_prsld_bits {
        constexpr uint32_t LCR_PRSLD = (6 << 0);  ///< Low-speed CR Prescaler Load
    }

}

// ============================================================================
// PCG Peripheral
// ============================================================================

namespace pcg {
    /// Base addresses
    constexpr uint32_t PCG_BASE = 0x4003C100;

    /// PCG Register structure
    struct Registers {
        volatile uint32_t CKEN0;  ///< Offset: 0x00 - Peripheral Function Clock Control Register 0
        volatile uint32_t MRST0;  ///< Offset: 0x04 - Peripheral Function Reset Control Register 0
        volatile uint32_t CKEN1;  ///< Offset: 0x10 - Peripheral Function Clock Control Register 1
        volatile uint32_t MRST1;  ///< Offset: 0x14 - Peripheral Function Reset Control Register 1
        volatile uint32_t CKEN2;  ///< Offset: 0x20 - Peripheral Function Clock Control Register 2
        volatile uint32_t MRST2;  ///< Offset: 0x24 - Peripheral Function Reset Control Register 2
    };

    /// Peripheral instances
    inline Registers* PCG = reinterpret_cast<Registers*>(PCG_BASE);

    // Bit definitions
    /// CKEN0 Register bits
    namespace cken0_bits {
        constexpr uint32_t GIOCK = (1U << 28);  ///< Software clock control of GPIO/Fast GPIO function
        constexpr uint32_t DMACK = (1U << 24);  ///< Supplying and gating settings of DMAC operation clock
        constexpr uint32_t ADCCK3 = (1U << 19);  ///< Settings for operation clock supplying and gating to A/D converter unit 3
        constexpr uint32_t ADCCK2 = (1U << 18);  ///< Settings for operation clock supplying and gating to A/D converter unit 2
        constexpr uint32_t ADCCK1 = (1U << 17);  ///< Settings for operation clock supplying and gating to A/D converter unit 1
        constexpr uint32_t ADCCK0 = (1U << 16);  ///< Settings for operation clock supplying and gating to A/D converter unit 0
        constexpr uint32_t MFSCK15 = (1U << 15);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.15
        constexpr uint32_t MFSCK14 = (1U << 14);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.14
        constexpr uint32_t MFSCK13 = (1U << 13);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.13
        constexpr uint32_t MFSCK12 = (1U << 12);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.12
        constexpr uint32_t MFSCK11 = (1U << 11);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.11
        constexpr uint32_t MFSCK10 = (1U << 10);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.10
        constexpr uint32_t MFSCK9 = (1U << 9);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.9
        constexpr uint32_t MFSCK8 = (1U << 8);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.8
        constexpr uint32_t MFSCK7 = (1U << 7);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.7
        constexpr uint32_t MFSCK6 = (1U << 6);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.6
        constexpr uint32_t MFSCK5 = (1U << 5);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.5
        constexpr uint32_t MFSCK4 = (1U << 4);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.4
        constexpr uint32_t MFSCK3 = (1U << 3);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.3
        constexpr uint32_t MFSCK2 = (1U << 2);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.2
        constexpr uint32_t MFSCK1 = (1U << 1);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.1
        constexpr uint32_t MFSCK0 = (1U << 0);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.0
    }

    /// MRST0 Register bits
    namespace mrst0_bits {
        constexpr uint32_t DMARST = (1U << 24);  ///< Reset control of DMAC
        constexpr uint32_t ADCRST3 = (1U << 19);  ///< Reset control of A/D converter unit 3
        constexpr uint32_t ADCRST2 = (1U << 18);  ///< Reset control of A/D converter unit 2
        constexpr uint32_t ADCRST1 = (1U << 17);  ///< Reset control of A/D converter unit 1
        constexpr uint32_t ADCRST0 = (1U << 16);  ///< Reset control of A/D converter unit 0
        constexpr uint32_t MFSRST15 = (1U << 15);  ///< Control of software reset of multi-function serial interface ch.15
        constexpr uint32_t MFSRST14 = (1U << 14);  ///< Control of software reset of multi-function serial interface ch.14
        constexpr uint32_t MFSRST13 = (1U << 13);  ///< Control of software reset of multi-function serial interface ch.13
        constexpr uint32_t MFSRST12 = (1U << 12);  ///< Control of software reset of multi-function serial interface ch.12
        constexpr uint32_t MFSRST11 = (1U << 11);  ///< Control of software reset of multi-function serial interface ch.11
        constexpr uint32_t MFSRST10 = (1U << 10);  ///< Control of software reset of multi-function serial interface ch.10
        constexpr uint32_t MFSRST9 = (1U << 9);  ///< Control of software reset of multi-function serial interface ch.9
        constexpr uint32_t MFSRST8 = (1U << 8);  ///< Control of software reset of multi-function serial interface ch.8
        constexpr uint32_t MFSRST7 = (1U << 7);  ///< Control of software reset of multi-function serial interface ch.7
        constexpr uint32_t MFSRST6 = (1U << 6);  ///< Control of software reset of multi-function serial interface ch.6
        constexpr uint32_t MFSRST5 = (1U << 5);  ///< Control of software reset of multi-function serial interface ch.5
        constexpr uint32_t MFSRST4 = (1U << 4);  ///< Control of software reset of multi-function serial interface ch.4
        constexpr uint32_t MFSRST3 = (1U << 3);  ///< Control of software reset of multi-function serial interface ch.3
        constexpr uint32_t MFSRST2 = (1U << 2);  ///< Control of software reset of multi-function serial interface ch.2
        constexpr uint32_t MFSRST1 = (1U << 1);  ///< Control of software reset of multi-function serial interface ch.1
        constexpr uint32_t MFSRST0 = (1U << 0);  ///< Control of software reset of multi-function serial interface ch.0
    }

    /// CKEN1 Register bits
    namespace cken1_bits {
        constexpr uint32_t QDUCK3 = (1U << 19);  ///< Settings for operation clock supply and gating of quad counter unit 3
        constexpr uint32_t QDUCK2 = (1U << 18);  ///< Settings for operation clock supply and gating of quad counter unit 2
        constexpr uint32_t QDUCK1 = (1U << 17);  ///< Settings for operation clock supply and gating of quad counter unit 1
        constexpr uint32_t QDUCK0 = (1U << 16);  ///< Settings for operation clock supply and gating of quad counter unit 0
        constexpr uint32_t MFTCK3 = (1U << 11);  ///< Settings for operation clock supply and gating of multi-function timer 3 and PPG 24/26/28/30
        constexpr uint32_t MFTCK2 = (1U << 10);  ///< Settings for operation clock supply and gating of multi-function timer 2 and PPG 16/18/20/22
        constexpr uint32_t MFTCK1 = (1U << 9);  ///< Settings for operation clock supply and gating of multi-function timer 1 and PPG 8/10/12/14
        constexpr uint32_t MFTCK0 = (1U << 8);  ///< Settings for operation clock supply and gating of multi-function timer 0 and PPG 0/2/4/6
        constexpr uint32_t BTMCK3 = (1U << 3);  ///< Settings operation clock supply and gating to base timer 12/13/14/15
        constexpr uint32_t BTMCK2 = (1U << 2);  ///< Settings operation clock supply and gating to base timer 8/9/10/11
        constexpr uint32_t BTMCK1 = (1U << 1);  ///< Settings operation clock supply and gating to base timer 4/5/6/7
        constexpr uint32_t BTMCK0 = (1U << 0);  ///< Settings operation clock supply and gating to base timer 0/1/2/3
    }

    /// MRST1 Register bits
    namespace mrst1_bits {
        constexpr uint32_t QDURST3 = (1U << 19);  ///< Reset control of quad counter unit 3
        constexpr uint32_t QDURST2 = (1U << 18);  ///< Reset control of quad counter unit 2
        constexpr uint32_t QDURST1 = (1U << 17);  ///< Reset control of quad counter unit 1
        constexpr uint32_t QDURST0 = (1U << 16);  ///< Reset control of quad counter unit 0
        constexpr uint32_t MFTRST3 = (1U << 11);  ///< Control of multi-function timer 3 and PPG 24/26/28/30 reset control
        constexpr uint32_t MFTRST2 = (1U << 10);  ///< Control of multi-function timer 2 and PPG 16/18/20/22 reset control
        constexpr uint32_t MFTRST1 = (1U << 9);  ///< Control of multi-function timer 1 and PPG 8/10/12/14 reset control
        constexpr uint32_t MFTRST0 = (1U << 8);  ///< Control of multi-function timer 0 and PPG 0/2/4/6 reset control
        constexpr uint32_t BTMRST3 = (1U << 3);  ///< Reset control of base timer 12/13/14/15
        constexpr uint32_t BTMRST2 = (1U << 2);  ///< Reset control of base timer 8/9/10/11
        constexpr uint32_t BTMRST1 = (1U << 1);  ///< Reset control of base timer 4/5/6/7
        constexpr uint32_t BTMRST0 = (1U << 0);  ///< Reset control of base timer 0/1/2/3
    }

    /// CKEN2 Register bits
    namespace cken2_bits {
        constexpr uint32_t CANCK1 = (1U << 5);  ///< Peripheral Function Clock Control Register 2
        constexpr uint32_t CANCK0 = (1U << 4);  ///< $
    }

    /// MRST2 Register bits
    namespace mrst2_bits {
        constexpr uint32_t CANRST1 = (1U << 5);  ///< Peripheral Function Reset Control Register 2
        constexpr uint32_t CANRST0 = (1U << 4);  ///< $
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x40060000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMACR;  ///< Offset: 0x00 - Entire DMAC Configuration Register
        volatile uint32_t DMACA0;  ///< Offset: 0x10 - Configuration A Register
        volatile uint32_t DMACB0;  ///< Offset: 0x14 - Configuration B Register
        volatile uint32_t DMACSA0;  ///< Offset: 0x18 - Transfer Source Address Register 0
        volatile uint32_t DMACDA0;  ///< Offset: 0x1C - Transfer Destination Address Register 0
        volatile uint32_t DMACA1;  ///< Offset: 0x20 - Configuration A Register 1
        volatile uint32_t DMACB1;  ///< Offset: 0x24 - Configuration B Register 1
        volatile uint32_t DMACSA1;  ///< Offset: 0x28 - Transfer Source Address Register 1
        volatile uint32_t DMACDA1;  ///< Offset: 0x2C - Transfer Destination Address Register 1
        volatile uint32_t DMACA2;  ///< Offset: 0x30 - Configuration A Register 2
        volatile uint32_t DMACB2;  ///< Offset: 0x34 - Configuration B Register 2
        volatile uint32_t DMACSA2;  ///< Offset: 0x38 - Transfer Source Address Register 2
        volatile uint32_t DMACDA2;  ///< Offset: 0x3C - Transfer Destination Address Register 2
        volatile uint32_t DMACA3;  ///< Offset: 0x40 - Configuration A Register 3
        volatile uint32_t DMACB3;  ///< Offset: 0x44 - Configuration B Register 3
        volatile uint32_t DMACSA3;  ///< Offset: 0x48 - Transfer Source Address Register 3
        volatile uint32_t DMACDA3;  ///< Offset: 0x4C - Transfer Destination Address Register 3
        volatile uint32_t DMACA4;  ///< Offset: 0x50 - Configuration A Register 4
        volatile uint32_t DMACB4;  ///< Offset: 0x54 - Configuration B Register 4
        volatile uint32_t DMACSA4;  ///< Offset: 0x58 - Transfer Source Address Register 4
        volatile uint32_t DMACDA4;  ///< Offset: 0x5C - Transfer Destination Address Register 4
        volatile uint32_t DMACA5;  ///< Offset: 0x60 - Configuration A Register 5
        volatile uint32_t DMACB5;  ///< Offset: 0x64 - Configuration B Register 5
        volatile uint32_t DMACSA5;  ///< Offset: 0x68 - Transfer Source Address Register 5
        volatile uint32_t DMACDA5;  ///< Offset: 0x6C - Transfer Destination Address Register 5
        volatile uint32_t DMACA6;  ///< Offset: 0x70 - Configuration A Register 6
        volatile uint32_t DMACB6;  ///< Offset: 0x74 - Configuration B Register 6
        volatile uint32_t DMACSA6;  ///< Offset: 0x78 - Transfer Source Address Register 6
        volatile uint32_t DMACDA6;  ///< Offset: 0x7C - Transfer Destination Address Register 6
        volatile uint32_t DMACA7;  ///< Offset: 0x80 - Configuration A Register 7
        volatile uint32_t DMACB7;  ///< Offset: 0x84 - Configuration B Register 7
        volatile uint32_t DMACSA7;  ///< Offset: 0x88 - Transfer Source Address Register 7
        volatile uint32_t DMACDA7;  ///< Offset: 0x8C - Transfer Destination Address Register 7
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

    // Bit definitions
    /// DMACR Register bits
    namespace dmacr_bits {
        constexpr uint32_t DE = (1U << 31);  ///< DMA Enable (all-channel operation enable bit)
        constexpr uint32_t DS = (1U << 30);  ///< DMA Stop
        constexpr uint32_t PR = (1U << 28);  ///< Priority Rotation
        constexpr uint32_t DH = (4 << 24);  ///< DMA Halt (All-channel pause bit)
    }

    /// DMACA0 Register bits
    namespace dmaca0_bits {
        constexpr uint32_t EB = (1U << 31);  ///< Enable bit (individual-channel operation enable bit)
        constexpr uint32_t PB = (1U << 30);  ///< Pause bit (individual-channel pause bit)
        constexpr uint32_t ST = (1U << 29);  ///< Software Trigger
        constexpr uint32_t IS = (6 << 23);  ///< Input Select
        constexpr uint32_t BC = (4 << 16);  ///< Block Count
        constexpr uint32_t TC = (16 << 0);  ///< Transfer Count
    }

    /// DMACB0 Register bits
    namespace dmacb0_bits {
        constexpr uint32_t MS = (2 << 28);  ///< Mode Select
        constexpr uint32_t TW = (2 << 26);  ///< Transfer Width
        constexpr uint32_t FS = (1U << 25);  ///< Fixed Source
        constexpr uint32_t FD = (1U << 24);  ///< Fixed Destination
        constexpr uint32_t RC = (1U << 23);  ///< Reload Count (BC/TC reload)
        constexpr uint32_t RS = (1U << 22);  ///< Reload Source
        constexpr uint32_t RD = (1U << 21);  ///< Reload Destination
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt (unsuccessful transfer completion interrupt enable)
        constexpr uint32_t CI = (1U << 19);  ///< Completion Interrupt (successful transfer completion interrupt enable)
        constexpr uint32_t SS = (3 << 16);  ///< Stop Status (stop status notification)
        constexpr uint32_t EM = (1U << 0);  ///< Enable bit Mask (EB bit clear mask)
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_DWT_BASE = 0xF0001000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t CMP_ADDR_START;  ///< Offset: 0x00 - MTB_DWT Address Compare Start trace Register
        volatile uint32_t CMP_DATA_START;  ///< Offset: 0x04 - MTB_DWT Data Compare Start trace Register
        volatile uint32_t CMP_MASK_START;  ///< Offset: 0x08 - MTB_DWT Mask Data Compare Start Trace Register
        volatile uint32_t CMP_ADDR_STOP;  ///< Offset: 0x10 - MTB_DWT Address Compare Stop trace Register
        volatile uint32_t CMP_DATA_STOP;  ///< Offset: 0x14 - MTB_DWT Data Compare Stop trace Register
        volatile uint32_t CMP_MASK_STOP;  ///< Offset: 0x18 - MTB_DWT Mask Data Compare Stop Trace Register
        volatile uint32_t FCT;  ///< Offset: 0x20 - MTB_DWT Function Register
        volatile uint32_t PID4;  ///< Offset: 0xFD0 - Peripheral ID4 Register
        volatile uint32_t PID5;  ///< Offset: 0xFD4 - Peripheral ID5 Register
        volatile uint32_t PID6;  ///< Offset: 0xFD8 - Peripheral ID6 Register
        volatile uint32_t PID7;  ///< Offset: 0xFDC - Peripheral ID7 Register
        volatile uint32_t PID0;  ///< Offset: 0xFE0 - Peripheral ID0 Register
        volatile uint32_t PID1;  ///< Offset: 0xFE4 - Peripheral ID1 Register
        volatile uint32_t PID2;  ///< Offset: 0xFE8 - Peripheral ID2 Register
        volatile uint32_t PID3;  ///< Offset: 0xFEC - Peripheral ID3 Register
        volatile uint32_t CID0;  ///< Offset: 0xFF0 - Component ID0 Register
        volatile uint32_t CID1;  ///< Offset: 0xFF4 - Component ID1 Register
        volatile uint32_t CID2;  ///< Offset: 0xFF8 - Component ID2 Register
        volatile uint32_t CID3;  ///< Offset: 0xFFC - Component ID3 Register
    };

    /// Peripheral instances
    inline Registers* MTB_DWT = reinterpret_cast<Registers*>(MTB_DWT_BASE);

    // Bit definitions
    /// CMP_ADDR_START Register bits
    namespace cmp_addr_start_bits {
        constexpr uint32_t ADCMP_STA = (32 << 0);  ///< MTB_DWT address comparison start trace bits
    }

    /// CMP_DATA_START Register bits
    namespace cmp_data_start_bits {
        constexpr uint32_t DTCMP_STA = (32 << 0);  ///< MTB_DWT data comparison start trace bits
    }

    /// CMP_MASK_START Register bits
    namespace cmp_mask_start_bits {
        constexpr uint32_t MSK_STA = (32 << 0);  ///< MTB_DWT data compare start trace register mask bits
    }

    /// CMP_ADDR_STOP Register bits
    namespace cmp_addr_stop_bits {
        constexpr uint32_t ADCMP_STO = (32 << 0);  ///< MTB_DWT address comparison stop trace bits
    }

    /// CMP_DATA_STOP Register bits
    namespace cmp_data_stop_bits {
        constexpr uint32_t DTCMP_STO = (32 << 0);  ///< MTB_DWT data comparison stop trace bits
    }

    /// CMP_MASK_STOP Register bits
    namespace cmp_mask_stop_bits {
        constexpr uint32_t MSK_STO = (32 << 0);  ///< MTB_DWT data compare stop trace register mask bits
    }

    /// FCT Register bits
    namespace fct_bits {
        constexpr uint32_t DSTP = (2 << 6);  ///< Data size stop bits
        constexpr uint32_t DSTA = (2 << 4);  ///< Data size start bits
        constexpr uint32_t STPEN = (2 << 2);  ///< Enable MTB_DWT stop MTB function bits
        constexpr uint32_t STAEN = (2 << 0);  ///< Enable MTB_DWT start MTB function bits
    }

    /// PID4 Register bits
    namespace pid4_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID5 Register bits
    namespace pid5_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID6 Register bits
    namespace pid6_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID7 Register bits
    namespace pid7_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID0 Register bits
    namespace pid0_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID1 Register bits
    namespace pid1_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID2 Register bits
    namespace pid2_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// PID3 Register bits
    namespace pid3_bits {
        constexpr uint32_t PERID = (32 << 0);  ///< Peripheral ID bits
    }

    /// CID0 Register bits
    namespace cid0_bits {
        constexpr uint32_t CPNTID = (32 << 0);  ///< Component ID bits
    }

    /// CID1 Register bits
    namespace cid1_bits {
        constexpr uint32_t CPNTID = (32 << 0);  ///< Component ID bits
    }

    /// CID2 Register bits
    namespace cid2_bits {
        constexpr uint32_t CPNTID = (32 << 0);  ///< Component ID bits
    }

    /// CID3 Register bits
    namespace cid3_bits {
        constexpr uint32_t CPNTID = (32 << 0);  ///< Component ID bits
    }

}

// ============================================================================
// FASTIO Peripheral
// ============================================================================

namespace fastio {
    /// Base addresses
    constexpr uint32_t FASTIO_BASE = 0xF8000000;

    /// FASTIO Register structure
    struct Registers {
        volatile uint32_t FPDIR0;  ///< Offset: 0x00 - Fast GPIO Input Data Register 0
        volatile uint32_t FPDIR1;  ///< Offset: 0x04 - Fast GPIO Input Data Register 1
        volatile uint32_t FPDIR2;  ///< Offset: 0x08 - Fast GPIO Input Data Register 2
        volatile uint32_t FPDIR3;  ///< Offset: 0x0C - Fast GPIO Input Data Register 3
        volatile uint32_t FPDIR4;  ///< Offset: 0x10 - Fast GPIO Input Data Register 4
        volatile uint32_t FPDIR5;  ///< Offset: 0x14 - Fast GPIO Input Data Register 5
        volatile uint32_t FPDIR6;  ///< Offset: 0x18 - Fast GPIO Input Data Register 6
        volatile uint32_t FPDIR8;  ///< Offset: 0x20 - Fast GPIO Input Data Register 8
        volatile uint32_t FPDIRE;  ///< Offset: 0x38 - Fast GPIO Input Data Register E
        volatile uint32_t FPDOR0;  ///< Offset: 0x40 - Fast GPIO Output Data Register 0
        volatile uint32_t FPDOR1;  ///< Offset: 0x44 - Fast GPIO Output Data Register 1
        volatile uint32_t FPDOR2;  ///< Offset: 0x48 - Fast GPIO Output Data Register 2
        volatile uint32_t FPDOR3;  ///< Offset: 0x4C - Fast GPIO Output Data Register 3
        volatile uint32_t FPDOR4;  ///< Offset: 0x50 - Fast GPIO Output Data Register 4
        volatile uint32_t FPDOR5;  ///< Offset: 0x54 - Fast GPIO Output Data Register 5
        volatile uint32_t FPDOR6;  ///< Offset: 0x58 - Fast GPIO Output Data Register 6
        volatile uint32_t FPDOR8;  ///< Offset: 0x60 - Fast GPIO Output Data Register 8
        volatile uint32_t FPDORE;  ///< Offset: 0x78 - Fast GPIO Output Data Register E
        volatile uint32_t M_FPDIR0;  ///< Offset: 0x80 - Mirror Fast GPIO Input Data Register 0
        volatile uint32_t M_FPDIR1;  ///< Offset: 0x84 - Mirror Fast GPIO Input Data Register 1
        volatile uint32_t M_FPDOR0;  ///< Offset: 0xC0 - Mirror Fast GPIO Output Data Register 0
        volatile uint32_t M_FPDOR1;  ///< Offset: 0xC4 - Mirror Fast GPIO Output Data Register 1
    };

    /// Peripheral instances
    inline Registers* FASTIO = reinterpret_cast<Registers*>(FASTIO_BASE);

    // Bit definitions
    /// FPDIR0 Register bits
    namespace fpdir0_bits {
        constexpr uint32_t P0F = (1U << 15);  ///< Bit15 of FPDIR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of FPDIR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of FPDIR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of FPDIR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of FPDIR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of FPDIR0
    }

    /// FPDIR1 Register bits
    namespace fpdir1_bits {
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of FPDIR1
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of FPDIR1
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of FPDIR1
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of FPDIR1
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of FPDIR1
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of FPDIR1
    }

    /// FPDIR2 Register bits
    namespace fpdir2_bits {
        constexpr uint32_t P23 = (1U << 3);  ///< Bit3 of FPDIR2
        constexpr uint32_t P22 = (1U << 2);  ///< Bit2 of FPDIR2
        constexpr uint32_t P21 = (1U << 1);  ///< Bit1 of FPDIR2
    }

    /// FPDIR3 Register bits
    namespace fpdir3_bits {
        constexpr uint32_t P3F = (1U << 15);  ///< Bit15 of FPDIR3
        constexpr uint32_t P3E = (1U << 14);  ///< Bit14 of FPDIR3
        constexpr uint32_t P3D = (1U << 13);  ///< Bit13 of FPDIR3
        constexpr uint32_t P3C = (1U << 12);  ///< Bit12 of FPDIR3
        constexpr uint32_t P3B = (1U << 11);  ///< Bit11 of FPDIR3
        constexpr uint32_t P3A = (1U << 10);  ///< Bit10 of FPDIR3
        constexpr uint32_t P39 = (1U << 9);  ///< Bit9 of FPDIR3
    }

    /// FPDIR4 Register bits
    namespace fpdir4_bits {
        constexpr uint32_t P4A = (1U << 10);  ///< Bit10 of FPDIR4
        constexpr uint32_t P49 = (1U << 9);  ///< Bit9 of FPDIR4
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of FPDIR4
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of FPDIR4
    }

    /// FPDIR5 Register bits
    namespace fpdir5_bits {
        constexpr uint32_t P52 = (1U << 2);  ///< Bit2 of FPDIR5
        constexpr uint32_t P51 = (1U << 1);  ///< Bit1 of FPDIR5
        constexpr uint32_t P50 = (1U << 0);  ///< Bit0 of FPDIR5
    }

    /// FPDIR6 Register bits
    namespace fpdir6_bits {
        constexpr uint32_t P61 = (1U << 1);  ///< Bit1 of FPDIR6
        constexpr uint32_t P60 = (1U << 0);  ///< Bit0 of FPDIR6
    }

    /// FPDIR8 Register bits
    namespace fpdir8_bits {
        constexpr uint32_t P82 = (1U << 2);  ///< Bit2 of FPDIR8
        constexpr uint32_t P81 = (1U << 1);  ///< Bit1 of FPDIR8
        constexpr uint32_t P80 = (1U << 0);  ///< Bit0 of FPDIR8
    }

    /// FPDIRE Register bits
    namespace fpdire_bits {
        constexpr uint32_t PE3 = (1U << 3);  ///< Bit3 of FPDIRE
        constexpr uint32_t PE2 = (1U << 2);  ///< Bit2 of FPDIRE
        constexpr uint32_t PE0 = (1U << 0);  ///< Bit0 of FPDIRE
    }

    /// FPDOR0 Register bits
    namespace fpdor0_bits {
        constexpr uint32_t P0F = (1U << 15);  ///< Bit15 of FPDOR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of FPDOR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of FPDOR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of FPDOR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of FPDOR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of FPDOR0
    }

    /// FPDOR1 Register bits
    namespace fpdor1_bits {
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of FPDOR1
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of FPDOR1
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of FPDOR1
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of FPDOR1
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of FPDOR1
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of FPDOR1
    }

    /// FPDOR2 Register bits
    namespace fpdor2_bits {
        constexpr uint32_t P23 = (1U << 3);  ///< Bit3 of FPDOR2
        constexpr uint32_t P22 = (1U << 2);  ///< Bit2 of FPDOR2
        constexpr uint32_t P21 = (1U << 1);  ///< Bit1 of FPDOR2
    }

    /// FPDOR3 Register bits
    namespace fpdor3_bits {
        constexpr uint32_t P3F = (1U << 15);  ///< Bit15 of FPDOR3
        constexpr uint32_t P3E = (1U << 14);  ///< Bit14 of FPDOR3
        constexpr uint32_t P3D = (1U << 13);  ///< Bit13 of FPDOR3
        constexpr uint32_t P3C = (1U << 12);  ///< Bit12 of FPDOR3
        constexpr uint32_t P3B = (1U << 11);  ///< Bit11 of FPDOR3
        constexpr uint32_t P3A = (1U << 10);  ///< Bit10 of FPDOR3
        constexpr uint32_t P39 = (1U << 9);  ///< Bit9 of FPDOR3
    }

    /// FPDOR4 Register bits
    namespace fpdor4_bits {
        constexpr uint32_t P4A = (1U << 10);  ///< Bit10 of FPDOR4
        constexpr uint32_t P49 = (1U << 9);  ///< Bit9 of FPDOR4
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of FPDOR4
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of FPDOR4
    }

    /// FPDOR5 Register bits
    namespace fpdor5_bits {
        constexpr uint32_t P52 = (1U << 2);  ///< Bit2 of FPDOR5
        constexpr uint32_t P51 = (1U << 1);  ///< Bit1 of FPDOR5
        constexpr uint32_t P50 = (1U << 0);  ///< Bit0 of FPDOR5
    }

    /// FPDOR6 Register bits
    namespace fpdor6_bits {
        constexpr uint32_t P61 = (1U << 1);  ///< Bit1 of FPDOR6
        constexpr uint32_t P60 = (1U << 0);  ///< Bit0 of FPDOR6
    }

    /// FPDOR8 Register bits
    namespace fpdor8_bits {
        constexpr uint32_t P82 = (1U << 2);  ///< Bit2 of FPDOR8
        constexpr uint32_t P81 = (1U << 1);  ///< Bit1 of FPDOR8
        constexpr uint32_t P80 = (1U << 0);  ///< Bit0 of FPDOR8
    }

    /// FPDORE Register bits
    namespace fpdore_bits {
        constexpr uint32_t PE3 = (1U << 3);  ///< Bit3 of FPDORE
        constexpr uint32_t PE2 = (1U << 2);  ///< Bit2 of FPDORE
        constexpr uint32_t PE0 = (1U << 0);  ///< Bit0 of FPDORE
    }

    /// M_FPDIR0 Register bits
    namespace m_fpdir0_bits {
        constexpr uint32_t P22 = (1U << 7);  ///< Bit7 of M_FPDIR0
        constexpr uint32_t P23 = (1U << 6);  ///< Bit6 of M_FPDIR0
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of M_FPDIR0
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of M_FPDIR0
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of M_FPDIR0
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of M_FPDIR0
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of M_FPDIR0
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of M_FPDIR0
    }

    /// M_FPDIR1 Register bits
    namespace m_fpdir1_bits {
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of M_FPDIR1
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of M_FPDIR1
        constexpr uint32_t P3F = (1U << 5);  ///< Bit5 of M_FPDIR1
        constexpr uint32_t P3E = (1U << 4);  ///< Bit4 of M_FPDIR1
        constexpr uint32_t P3D = (1U << 3);  ///< Bit3 of M_FPDIR1
        constexpr uint32_t P3C = (1U << 2);  ///< Bit2 of M_FPDIR1
        constexpr uint32_t P3B = (1U << 1);  ///< Bit1 of M_FPDIR1
        constexpr uint32_t P3A = (1U << 0);  ///< Bit0 of M_FPDIR1
    }

    /// M_FPDOR0 Register bits
    namespace m_fpdor0_bits {
        constexpr uint32_t P22 = (1U << 7);  ///< Bit7 of M_FPDOR0
        constexpr uint32_t P23 = (1U << 6);  ///< Bit6 of M_FPDOR0
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of M_FPDOR0
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of M_FPDOR0
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of M_FPDOR0
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of M_FPDOR0
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of M_FPDOR0
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of M_FPDOR0
    }

    /// M_FPDOR1 Register bits
    namespace m_fpdor1_bits {
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of M_FPDOR1
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of M_FPDOR1
        constexpr uint32_t P3F = (1U << 5);  ///< Bit5 of M_FPDOR1
        constexpr uint32_t P3E = (1U << 4);  ///< Bit4 of M_FPDOR1
        constexpr uint32_t P3D = (1U << 3);  ///< Bit3 of M_FPDOR1
        constexpr uint32_t P3C = (1U << 2);  ///< Bit2 of M_FPDOR1
        constexpr uint32_t P3B = (1U << 1);  ///< Bit1 of M_FPDOR1
        constexpr uint32_t P3A = (1U << 0);  ///< Bit0 of M_FPDOR1
    }

}


} // namespace alloy::generated::s6e1a1

#endif // ALLOY_GENERATED_S6E1A1_PERIPHERALS_HPP