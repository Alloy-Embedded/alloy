/// Auto-generated code for S6E2CC
/// Generated by Alloy Code Generator
/// Source: fujitsu_s6e2cc.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:07
#ifndef ALLOY_GENERATED_S6E2CC_PERIPHERALS_HPP
#define ALLOY_GENERATED_S6E2CC_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::s6e2cc {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_unique = true;
    constexpr uint32_t num_unique_instances = 1;
    constexpr bool has_ecc = true;
    constexpr uint32_t num_ecc_instances = 1;
    constexpr bool has_crg = true;
    constexpr uint32_t num_crg_instances = 1;
    constexpr bool has_crtrim = true;
    constexpr uint32_t num_crtrim_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_mft0 = true;
    constexpr uint32_t num_mft0_instances = 1;
    constexpr bool has_mft1 = true;
    constexpr uint32_t num_mft1_instances = 1;
    constexpr bool has_mft2 = true;
    constexpr uint32_t num_mft2_instances = 1;
    constexpr bool has_mft = true;
    constexpr uint32_t num_mft_instances = 1;
    constexpr bool has_btiosel03 = true;
    constexpr uint32_t num_btiosel03_instances = 1;
    constexpr bool has_btiosel47 = true;
    constexpr uint32_t num_btiosel47_instances = 1;
    constexpr bool has_btiosel8b = true;
    constexpr uint32_t num_btiosel8b_instances = 1;
    constexpr bool has_btioselcf = true;
    constexpr uint32_t num_btioselcf_instances = 1;
    constexpr bool has_sbssr = true;
    constexpr uint32_t num_sbssr_instances = 1;
    constexpr bool has_bt0 = true;
    constexpr uint32_t num_bt0_instances = 1;
    constexpr bool has_bt1 = true;
    constexpr uint32_t num_bt1_instances = 1;
    constexpr bool has_bt2 = true;
    constexpr uint32_t num_bt2_instances = 1;
    constexpr bool has_bt3 = true;
    constexpr uint32_t num_bt3_instances = 1;
    constexpr bool has_bt4 = true;
    constexpr uint32_t num_bt4_instances = 1;
    constexpr bool has_bt5 = true;
    constexpr uint32_t num_bt5_instances = 1;
    constexpr bool has_bt6 = true;
    constexpr uint32_t num_bt6_instances = 1;
    constexpr bool has_bt7 = true;
    constexpr uint32_t num_bt7_instances = 1;
    constexpr bool has_bt8 = true;
    constexpr uint32_t num_bt8_instances = 1;
    constexpr bool has_bt9 = true;
    constexpr uint32_t num_bt9_instances = 1;
    constexpr bool has_bt10 = true;
    constexpr uint32_t num_bt10_instances = 1;
    constexpr bool has_bt11 = true;
    constexpr uint32_t num_bt11_instances = 1;
    constexpr bool has_bt12 = true;
    constexpr uint32_t num_bt12_instances = 1;
    constexpr bool has_bt13 = true;
    constexpr uint32_t num_bt13_instances = 1;
    constexpr bool has_bt14 = true;
    constexpr uint32_t num_bt14_instances = 1;
    constexpr bool has_bt15 = true;
    constexpr uint32_t num_bt15_instances = 1;
    constexpr bool has_qprc0 = true;
    constexpr uint32_t num_qprc0_instances = 2;
    constexpr bool has_qprc1 = true;
    constexpr uint32_t num_qprc1_instances = 2;
    constexpr bool has_qprc2 = true;
    constexpr uint32_t num_qprc2_instances = 2;
    constexpr bool has_qprc3 = true;
    constexpr uint32_t num_qprc3_instances = 2;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 3;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_intreq = true;
    constexpr uint32_t num_intreq_instances = 1;
    constexpr bool has_hdmicec0 = true;
    constexpr uint32_t num_hdmicec0_instances = 1;
    constexpr bool has_hdmicec1 = true;
    constexpr uint32_t num_hdmicec1_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_lvd = true;
    constexpr uint32_t num_lvd_instances = 1;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_mfs0 = true;
    constexpr uint32_t num_mfs0_instances = 1;
    constexpr bool has_mfs1 = true;
    constexpr uint32_t num_mfs1_instances = 1;
    constexpr bool has_mfs2 = true;
    constexpr uint32_t num_mfs2_instances = 1;
    constexpr bool has_mfs3 = true;
    constexpr uint32_t num_mfs3_instances = 1;
    constexpr bool has_mfs4 = true;
    constexpr uint32_t num_mfs4_instances = 1;
    constexpr bool has_mfs5 = true;
    constexpr uint32_t num_mfs5_instances = 1;
    constexpr bool has_mfs6 = true;
    constexpr uint32_t num_mfs6_instances = 1;
    constexpr bool has_mfs7 = true;
    constexpr uint32_t num_mfs7_instances = 1;
    constexpr bool has_mfs8 = true;
    constexpr uint32_t num_mfs8_instances = 1;
    constexpr bool has_mfs9 = true;
    constexpr uint32_t num_mfs9_instances = 1;
    constexpr bool has_mfs10 = true;
    constexpr uint32_t num_mfs10_instances = 1;
    constexpr bool has_mfs11 = true;
    constexpr uint32_t num_mfs11_instances = 1;
    constexpr bool has_mfs12 = true;
    constexpr uint32_t num_mfs12_instances = 1;
    constexpr bool has_mfs13 = true;
    constexpr uint32_t num_mfs13_instances = 1;
    constexpr bool has_mfs14 = true;
    constexpr uint32_t num_mfs14_instances = 1;
    constexpr bool has_mfs15 = true;
    constexpr uint32_t num_mfs15_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_wc = true;
    constexpr uint32_t num_wc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_lcr = true;
    constexpr uint32_t num_lcr_instances = 1;
    constexpr bool has_clk = true;
    constexpr uint32_t num_clk_instances = 1;
    constexpr bool has_pll = true;
    constexpr uint32_t num_pll_instances = 1;
    constexpr bool has_exbus = true;
    constexpr uint32_t num_exbus_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 3;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_dstc = true;
    constexpr uint32_t num_dstc_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 4;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 2;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 2;
    constexpr bool has_sdif = true;
    constexpr uint32_t num_sdif_instances = 1;
    constexpr bool has_pcrc = true;
    constexpr uint32_t num_pcrc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct unique_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crtrim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mft0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mft1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mft2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mft_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btiosel03_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btiosel47_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btiosel8b_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct btioselcf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sbssr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt8_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt9_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt10_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt11_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt12_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt13_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt14_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bt15_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct qprc0_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct qprc1_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct qprc2_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct qprc3_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct intreq_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hdmicec0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hdmicec1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lvd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs8_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs9_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs10_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs11_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs12_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs13_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs14_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mfs15_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct clk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pll_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exbus_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dstc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sdif_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcrc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_IF_BASE = 0x40000000;
    constexpr uint32_t DUALFLASH_IF_BASE = 0x40000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FASZR;  ///< Offset: 0x00 - Flash Access Size Register
        volatile uint32_t FRWTR;  ///< Offset: 0x04 - Flash Read Wait Register
        volatile uint32_t FSTR;  ///< Offset: 0x08 - Flash Status Register
        volatile uint32_t FSYNDN;  ///< Offset: 0x10 - Flash Sync Down Register
        volatile uint32_t FBFCR;  ///< Offset: 0x14 - Flash Buffer Control Register
        volatile uint32_t FICR;  ///< Offset: 0x20 - Flash Interrupt Control Register
        volatile uint32_t FISR;  ///< Offset: 0x24 - Flash Interrupt Status Register
        volatile uint32_t FICLR;  ///< Offset: 0x28 - Flash Interrupt Clear Register
        volatile uint32_t DFCTRLR;  ///< Offset: 0x30 - Dual Flash mode Control Register
        volatile uint32_t CRTRMM;  ///< Offset: 0x100 - CR Trimming Data Mirror Register
        volatile uint32_t FGPDM1;  ///< Offset: 0x110 - Flash General Purpose Data Mirror Register1
        volatile uint32_t FGPDM2;  ///< Offset: 0x114 - Flash General Purpose Data Mirror Register2
        volatile uint32_t FGPDM3;  ///< Offset: 0x118 - Flash General Purpose Data Mirror Register3
        volatile uint32_t FGPDM4;  ///< Offset: 0x11C - Flash General Purpose Data Mirror Register4
    };

    /// Peripheral instances
    inline Registers* FLASH_IF = reinterpret_cast<Registers*>(FLASH_IF_BASE);
    inline Registers* DUALFLASH_IF = reinterpret_cast<Registers*>(DUALFLASH_IF_BASE);

    // Bit definitions
    /// FASZR Register bits
    namespace faszr_bits {
        constexpr uint32_t ASZ = (2 << 0);  ///< Access Size
    }

    /// FRWTR Register bits
    namespace frwtr_bits {
        constexpr uint32_t RWT = (2 << 0);  ///< Read Wait Cycle
    }

    /// FSTR Register bits
    namespace fstr_bits {
        constexpr uint32_t ERR = (1U << 2);  ///< Flash ECC Error
        constexpr uint32_t HNG = (1U << 1);  ///< Flash Hang
        constexpr uint32_t RDY = (1U << 0);  ///< Flash Rdy
    }

    /// FSYNDN Register bits
    namespace fsyndn_bits {
        constexpr uint32_t SD = (3 << 0);  ///< Sync Down
    }

    /// FBFCR Register bits
    namespace fbfcr_bits {
        constexpr uint32_t BS = (1U << 1);  ///< Buffer Status
        constexpr uint32_t BE = (1U << 0);  ///< Buffer Enable
    }

    /// FICR Register bits
    namespace ficr_bits {
        constexpr uint32_t ERRIE = (1U << 2);  ///< Flash ECC Error Interrupt Enable
        constexpr uint32_t HANGIE = (1U << 1);  ///< Flash HANG Interrupt Enable
        constexpr uint32_t RDYIE = (1U << 0);  ///< Flash RDY Interrupt Enable
    }

    /// FISR Register bits
    namespace fisr_bits {
        constexpr uint32_t ERRIF = (1U << 2);  ///< Flash ECC Error Interrupt Flag
        constexpr uint32_t HANGIF = (1U << 1);  ///< Flash HANG Interrupt Flag
        constexpr uint32_t RDYIF = (1U << 0);  ///< Flash RDY Interrupt Flag
    }

    /// FICLR Register bits
    namespace ficlr_bits {
        constexpr uint32_t ERRIC = (1U << 2);  ///< Flash ECC Error Interrupt Clear
        constexpr uint32_t HANGIC = (1U << 1);  ///< Flash HANG Interrupt Clear
        constexpr uint32_t RDYIC = (1U << 0);  ///< Flash RDY Interrupt Clear
    }

    /// DFCTRLR Register bits
    namespace dfctrlr_bits {
        constexpr uint32_t WKEY = (16 << 16);  ///< Write Key
        constexpr uint32_t RME = (1U << 1);  ///< Re-Map Enable
        constexpr uint32_t DFE = (1U << 0);  ///< Dual Flash mode Enable
    }

    /// CRTRMM Register bits
    namespace crtrmm_bits {
        constexpr uint32_t TTRMM = (5 << 16);  ///< Temperature CR Trimming Data Mirror
        constexpr uint32_t TRMM = (10 << 0);  ///< CR Trimming Data Mirror
    }

    /// FGPDM1 Register bits
    namespace fgpdm1_bits {
        constexpr uint32_t GPD1 = (32 << 0);  ///< General Purpose Data1
    }

    /// FGPDM2 Register bits
    namespace fgpdm2_bits {
        constexpr uint32_t GPD2 = (32 << 0);  ///< General Purpose Data2
    }

    /// FGPDM3 Register bits
    namespace fgpdm3_bits {
        constexpr uint32_t GPD3 = (32 << 0);  ///< General Purpose Data3
    }

    /// FGPDM4 Register bits
    namespace fgpdm4_bits {
        constexpr uint32_t GPD4 = (32 << 0);  ///< General Purpose Data4
    }

}

// ============================================================================
// UNIQUE Peripheral
// ============================================================================

namespace unique {
    /// Base addresses
    constexpr uint32_t UNIQUE_ID_BASE = 0x40000200;

    /// UNIQUE Register structure
    struct Registers {
        volatile uint32_t UIDR0;  ///< Offset: 0x00 - Unique ID Register 0
        volatile uint32_t UIDR1;  ///< Offset: 0x04 - Unique ID Register 1
    };

    /// Peripheral instances
    inline Registers* UNIQUE_ID = reinterpret_cast<Registers*>(UNIQUE_ID_BASE);

    // Bit definitions
    /// UIDR0 Register bits
    namespace uidr0_bits {
        constexpr uint32_t UID = (28 << 4);  ///< Unique ID 27 through 0
    }

    /// UIDR1 Register bits
    namespace uidr1_bits {
        constexpr uint32_t UID = (13 << 0);  ///< Unique ID 40 through 28
    }

}

// ============================================================================
// ECC Peripheral
// ============================================================================

namespace ecc {
    /// Base addresses
    constexpr uint32_t ECC_CAPTURE_BASE = 0x40000300;

    /// ECC Register structure
    struct Registers {
        volatile uint32_t FERRAD;  ///< Offset: 0x00 - Flash ECC Error Address Capture Register
    };

    /// Peripheral instances
    inline Registers* ECC_CAPTURE = reinterpret_cast<Registers*>(ECC_CAPTURE_BASE);

    // Bit definitions
    /// FERRAD Register bits
    namespace ferrad_bits {
        constexpr uint32_t ERRAD = (23 << 0);  ///< Flash ECC Error Address Capture
    }

}

// ============================================================================
// CRG Peripheral
// ============================================================================

namespace crg {
    /// Base addresses
    constexpr uint32_t CRG_BASE = 0x40010000;

    /// CRG Register structure
    struct Registers {
        volatile uint32_t SCM_CTL;  ///< Offset: 0x00 - System Clock Mode Control Register
        volatile uint32_t SCM_STR;  ///< Offset: 0x04 - System Clock Mode Status Register
        volatile uint32_t STB_CTL;  ///< Offset: 0x08 - Standby Mode Control Register
        volatile uint32_t RST_STR;  ///< Offset: 0x0C - Reset Cause Register
        volatile uint32_t BSC_PSR;  ///< Offset: 0x10 - Base Clock Prescaler Register
        volatile uint32_t APBC0_PSR;  ///< Offset: 0x14 - APB0 Prescaler Register
        volatile uint32_t APBC1_PSR;  ///< Offset: 0x18 - APB1 Prescaler Register
        volatile uint32_t APBC2_PSR;  ///< Offset: 0x1C - APB2 Prescaler Register
        volatile uint32_t SWC_PSR;  ///< Offset: 0x20 - Software Watchdog Clock Prescaler Register
        volatile uint32_t TTC_PSR;  ///< Offset: 0x28 - Trace Clock Prescaler Register
        volatile uint32_t CSW_TMR;  ///< Offset: 0x30 - Clock Stabilization Wait Time Register
        volatile uint32_t PSW_TMR;  ///< Offset: 0x34 - PLL Clock Stabilization Wait Time Setup Register
        volatile uint32_t PLL_CTL1;  ///< Offset: 0x38 - PLL Control Register 1
        volatile uint32_t PLL_CTL2;  ///< Offset: 0x3C - PLL Control Register 2
        volatile uint32_t CSV_CTL;  ///< Offset: 0x40 - CSV control register
        volatile uint32_t CSV_STR;  ///< Offset: 0x44 - CSV status register
        volatile uint32_t FCSWH_CTL;  ///< Offset: 0x48 - Frequency detection window setting register
        volatile uint32_t FCSWL_CTL;  ///< Offset: 0x4C - Frequency detection window setting register
        volatile uint32_t FCSWD_CTL;  ///< Offset: 0x50 - Frequency detection counter register
        volatile uint32_t DBWDT_CTL;  ///< Offset: 0x54 - Debug Break Watchdog Timer Control Register
        volatile uint32_t INT_ENR;  ///< Offset: 0x60 - Interrupt Enable Register
        volatile uint32_t INT_STR;  ///< Offset: 0x64 - Interrupt Status Register
        volatile uint32_t INT_CLR;  ///< Offset: 0x68 - Interrupt Clear Register
    };

    /// Peripheral instances
    inline Registers* CRG = reinterpret_cast<Registers*>(CRG_BASE);

    // Bit definitions
    /// SCM_CTL Register bits
    namespace scm_ctl_bits {
        constexpr uint32_t RCS = (3 << 5);  ///< Master clock switch control bits
        constexpr uint32_t PLLE = (1U << 4);  ///< PLL oscillation enable bit
        constexpr uint32_t SOSCE = (1U << 3);  ///< Sub clock oscillation enable bit
        constexpr uint32_t MOSCE = (1U << 1);  ///< Main clock oscillation enable bit
    }

    /// SCM_STR Register bits
    namespace scm_str_bits {
        constexpr uint32_t RCM = (3 << 5);  ///< Master clock selection bits
        constexpr uint32_t PLRDY = (1U << 4);  ///< PLL oscillation stable bit
        constexpr uint32_t SORDY = (1U << 3);  ///< Sub clock oscillation stable bit
        constexpr uint32_t MORDY = (1U << 1);  ///< Main clock oscillation stable bit
    }

    /// STB_CTL Register bits
    namespace stb_ctl_bits {
        constexpr uint32_t KEY = (16 << 16);  ///< Standby mode control write control bit
        constexpr uint32_t SPL = (1U << 4);  ///< Standby pin level setting bit
        constexpr uint32_t DSTM = (1U << 2);  ///< Deep standby mode select bit
        constexpr uint32_t STM = (2 << 0);  ///< Standby mode selection bit
    }

    /// RST_STR Register bits
    namespace rst_str_bits {
        constexpr uint32_t SRST = (1U << 8);  ///< Software reset flag
        constexpr uint32_t FCSR = (1U << 7);  ///< Flag for anomalous frequency detection reset
        constexpr uint32_t CSVR = (1U << 6);  ///< Clock failure detection reset flag
        constexpr uint32_t HWDT = (1U << 5);  ///< Hardware watchdog reset flag
        constexpr uint32_t SWDT = (1U << 4);  ///< Software watchdog reset flag
        constexpr uint32_t INITX = (1U << 1);  ///< INITX pin input reset flag
        constexpr uint32_t PONR = (1U << 0);  ///< Power-on reset/low-voltage detection reset flag
    }

    /// BSC_PSR Register bits
    namespace bsc_psr_bits {
        constexpr uint32_t BSR = (3 << 0);  ///< Base clock frequency division ratio setting bit
    }

    /// APBC0_PSR Register bits
    namespace apbc0_psr_bits {
        constexpr uint32_t APBC0 = (2 << 0);  ///< APB0 bus clock frequency division ratio setting bit
    }

    /// APBC1_PSR Register bits
    namespace apbc1_psr_bits {
        constexpr uint32_t APBC1EN = (1U << 7);  ///< APB1 clock enable bit
        constexpr uint32_t APBC1RST = (1U << 4);  ///< APB1 bus reset control bit
        constexpr uint32_t APBC1 = (2 << 0);  ///< APB1 bus clock frequency division ratio setting bit
    }

    /// APBC2_PSR Register bits
    namespace apbc2_psr_bits {
        constexpr uint32_t APBC2EN = (1U << 7);  ///< APB2 clock enable bit
        constexpr uint32_t APBC2RST = (1U << 4);  ///< APB2 bus reset control bit
        constexpr uint32_t APBC2 = (2 << 0);  ///< APB2 bus clock frequency division ratio setting bit
    }

    /// SWC_PSR Register bits
    namespace swc_psr_bits {
        constexpr uint32_t SWDS = (2 << 0);  ///< Software watchdog clock frequency division ratio setting bit
    }

    /// TTC_PSR Register bits
    namespace ttc_psr_bits {
        constexpr uint32_t TTC = (2 << 0);  ///< Trace clock frequency division ratio setting bit
    }

    /// CSW_TMR Register bits
    namespace csw_tmr_bits {
        constexpr uint32_t SOWT = (4 << 4);  ///< Sub clock stabilization wait time setup bit
        constexpr uint32_t MOWT = (4 << 0);  ///< Main clock stabilization wait time setup bit
    }

    /// PSW_TMR Register bits
    namespace psw_tmr_bits {
        constexpr uint32_t PINC = (1U << 4);  ///< PLL input clock select bit
        constexpr uint32_t POWT = (3 << 0);  ///< PLL clock stabilization wait time setup bit
    }

    /// PLL_CTL1 Register bits
    namespace pll_ctl1_bits {
        constexpr uint32_t PLLK = (4 << 4);  ///< PLL input clock frequency division ratio setting bit
        constexpr uint32_t PLLM = (4 << 0);  ///< PLL VCO clock frequency division ratio setting bit
    }

    /// PLL_CTL2 Register bits
    namespace pll_ctl2_bits {
        constexpr uint32_t PLLN = (6 << 0);  ///< PLL feedback frequency division ratio setting bit
    }

    /// CSV_CTL Register bits
    namespace csv_ctl_bits {
        constexpr uint32_t FCD = (3 << 12);  ///< FCS count cycle setting bits
        constexpr uint32_t FCSRE = (1U << 9);  ///< FCS reset output enable bit
        constexpr uint32_t FCSDE = (1U << 8);  ///< FCS function enable bit
        constexpr uint32_t SCSVE = (1U << 1);  ///< Sub CSV function enable bit
        constexpr uint32_t MCSVE = (1U << 0);  ///< Main CSV function enable bit
    }

    /// CSV_STR Register bits
    namespace csv_str_bits {
        constexpr uint32_t SCMF = (1U << 1);  ///< Sub clock failure detection flag
        constexpr uint32_t MCMF = (1U << 0);  ///< Main clock failure detection flag
    }

    /// FCSWH_CTL Register bits
    namespace fcswh_ctl_bits {
        constexpr uint32_t FWH = (16 << 0);  ///< Frequency detection window setting bits (Upper)
    }

    /// FCSWL_CTL Register bits
    namespace fcswl_ctl_bits {
        constexpr uint32_t FWL = (16 << 0);  ///< Frequency detection window setting bits (Lower)
    }

    /// FCSWD_CTL Register bits
    namespace fcswd_ctl_bits {
        constexpr uint32_t FWD = (16 << 0);  ///< Frequency detection count data
    }

    /// DBWDT_CTL Register bits
    namespace dbwdt_ctl_bits {
        constexpr uint32_t DPHWBE = (1U << 7);  ///< HW-WDG debug mode break bit
        constexpr uint32_t DPSWBE = (1U << 5);  ///< SW-WDG debug mode break bit
    }

    /// INT_ENR Register bits
    namespace int_enr_bits {
        constexpr uint32_t FCSE = (1U << 5);  ///< Anomalous frequency detection interrupt enable bit
        constexpr uint32_t PCSE = (1U << 2);  ///< PLL oscillation stabilization completion interrupt enable bit
        constexpr uint32_t SCSE = (1U << 1);  ///< Sub oscillation stabilization completion interrupt enable bit
        constexpr uint32_t MCSE = (1U << 0);  ///< Main oscillation stabilization completion interrupt enable bit
    }

    /// INT_STR Register bits
    namespace int_str_bits {
        constexpr uint32_t FCSI = (1U << 5);  ///< Anomalous frequency detection interrupt status bit
        constexpr uint32_t PCSI = (1U << 2);  ///< PLL oscillation stabilization completion interrupt status bit
        constexpr uint32_t SCSI = (1U << 1);  ///< Sub oscillation stabilization completion interrupt status bit
        constexpr uint32_t MCSI = (1U << 0);  ///< Main oscillation stabilization completion interrupt status bit
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t FCSC = (1U << 5);  ///< Anomalous frequency detection interrupt cause clear bit
        constexpr uint32_t PCSC = (1U << 2);  ///< PLL oscillation stabilization completion interrupt cause clear bit
        constexpr uint32_t SCSC = (1U << 1);  ///< Sub oscillation stabilization completion interrupt cause clear bit
        constexpr uint32_t MCSC = (1U << 0);  ///< Main oscillation stabilization completion interrupt cause clear bit
    }

}

// ============================================================================
// CRTRIM Peripheral
// ============================================================================

namespace crtrim {
    /// Base addresses
    constexpr uint32_t CRTRIM_BASE = 0x4002E000;

    /// CRTRIM Register structure
    struct Registers {
        volatile uint32_t MCR_PSR;  ///< Offset: 0x00 - High-speed CR oscillation Frequency Division Setup Register
        volatile uint32_t MCR_FTRM;  ///< Offset: 0x04 - High-speed CR oscillation Frequency Trimming Register
        volatile uint32_t MCR_TTRM;  ///< Offset: 0x08 - High-speed CR oscillation Temperature Trimming Register
        volatile uint32_t MCR_RLR;  ///< Offset: 0x0C - High-Speed CR Oscillation Register Write-Protect Register
    };

    /// Peripheral instances
    inline Registers* CRTRIM = reinterpret_cast<Registers*>(CRTRIM_BASE);

    // Bit definitions
    /// MCR_PSR Register bits
    namespace mcr_psr_bits {
        constexpr uint32_t CSR = (3 << 0);  ///< High-speed CR oscillation frequency division ratio setting bits
    }

    /// MCR_FTRM Register bits
    namespace mcr_ftrm_bits {
        constexpr uint32_t TRD = (10 << 0);  ///< Frequency trimming setup bits
    }

    /// MCR_TTRM Register bits
    namespace mcr_ttrm_bits {
        constexpr uint32_t TRT = (5 << 0);  ///< Temperature trimming setup bits
    }

    /// MCR_RLR Register bits
    namespace mcr_rlr_bits {
        constexpr uint32_t TRMLCK = (32 << 0);  ///< Register write-protect bits
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t SWWDT_BASE = 0x40012000;
    constexpr uint32_t HWWDT_BASE = 0x40011000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDOGLOAD;  ///< Offset: 0x00 - Software Watchdog Timer Load Register
        volatile uint32_t WDOGVALUE;  ///< Offset: 0x04 - Software Watchdog Timer Value Register
        volatile uint32_t WDOGCONTROL;  ///< Offset: 0x08 - Software Watchdog Timer Control Register
        volatile uint32_t WDOGINTCLR;  ///< Offset: 0x0C - Software Watchdog Timer Clear Register
        volatile uint32_t WDOGRIS;  ///< Offset: 0x10 - Software Watchdog Timer Interrupt Status Register
        volatile uint32_t WDOGSPMC;  ///< Offset: 0x18 - Software Watchdog Timer Window Watchdog Mode Control Register
        volatile uint32_t WDOGLOCK;  ///< Offset: 0xC00 - Software Watchdog Timer Lock Register
    };

    /// Peripheral instances
    inline Registers* SWWDT = reinterpret_cast<Registers*>(SWWDT_BASE);
    inline Registers* HWWDT = reinterpret_cast<Registers*>(HWWDT_BASE);

    // Bit definitions
    /// WDOGCONTROL Register bits
    namespace wdogcontrol_bits {
        constexpr uint32_t SPM = (1U << 4);  ///< Software Watchdog window watchdog mode enable bit
        constexpr uint32_t TWD = (2 << 2);  ///< Timing window setting bit of the software watchdog
        constexpr uint32_t RESEN = (1U << 1);  ///< Reset enable bit of the software watchdog
        constexpr uint32_t INTEN = (1U << 0);  ///< Interrupt and counter enable bit of the software watchdog
    }

    /// WDOGRIS Register bits
    namespace wdogris_bits {
        constexpr uint32_t RIS = (1U << 0);  ///< Software watchdog interrupt status bit
    }

    /// WDOGSPMC Register bits
    namespace wdogspmc_bits {
        constexpr uint32_t TGR = (1U << 0);  ///< Software watchdog trigger type bit
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t DTIM_BASE = 0x40015000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIMER1LOAD;  ///< Offset: 0x00 - Load Register
        volatile uint32_t TIMER1VALUE;  ///< Offset: 0x04 - Value Register
        volatile uint32_t TIMER1CONTROL;  ///< Offset: 0x08 - Control Register
        volatile uint32_t TIMER1INTCLR;  ///< Offset: 0x0C - Interrupt Clear Register
        volatile uint32_t TIMER1RIS;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t TIMER1MIS;  ///< Offset: 0x14 - Masked Interrupt Status Register
        volatile uint32_t TIMER1BGLOAD;  ///< Offset: 0x18 - Background Load Register
        volatile uint32_t TIMER2LOAD;  ///< Offset: 0x20 - Load Register
        volatile uint32_t TIMER2VALUE;  ///< Offset: 0x24 - Value Register
        volatile uint32_t TIMER2CONTROL;  ///< Offset: 0x28 - Control Register
        volatile uint32_t TIMER2INTCLR;  ///< Offset: 0x2C - Interrupt Clear Register
        volatile uint32_t TIMER2RIS;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t TIMER2MIS;  ///< Offset: 0x34 - Masked Interrupt Status Register
        volatile uint32_t TIMER2BGLOAD;  ///< Offset: 0x38 - Background Load Register
    };

    /// Peripheral instances
    inline Registers* DTIM = reinterpret_cast<Registers*>(DTIM_BASE);

    // Bit definitions
    /// TIMER1CONTROL Register bits
    namespace timer1control_bits {
        constexpr uint32_t TimerEn = (1U << 7);  ///< Enable bit
        constexpr uint32_t TimerMode = (1U << 6);  ///< Mode bit
        constexpr uint32_t IntEnable = (1U << 5);  ///< Interrupt enable bit
        constexpr uint32_t TimerPre = (2 << 2);  ///< Prescale bits
        constexpr uint32_t TimerSize = (1U << 1);  ///< Counter size bit
        constexpr uint32_t OneShot = (1U << 0);  ///< One-shot mode bit
    }

    /// TIMER1RIS Register bits
    namespace timer1ris_bits {
        constexpr uint32_t TIMER1RIS = (1U << 0);  ///< Interrupt Status Register bit
    }

    /// TIMER1MIS Register bits
    namespace timer1mis_bits {
        constexpr uint32_t TIMER1MIS = (1U << 0);  ///< Masked Interrupt Status bit
    }

}

// ============================================================================
// MFT0 Peripheral
// ============================================================================

namespace mft0 {
    /// Base addresses
    constexpr uint32_t MFT0_BASE = 0x40020000;

    /// MFT0 Register structure
    struct Registers {
        volatile uint32_t FRT_TCCP0;  ///< Offset: 0x142 - FRT-ch.0 Cycle Setting Register
        volatile uint32_t FRT_TCDT0;  ///< Offset: 0x146 - FRT-ch.0 Count Value Register
        volatile uint32_t FRT_TCSA0;  ///< Offset: 0x148 - FRT-ch.0 Control Register A
        volatile uint32_t FRT_TCSC0;  ///< Offset: 0x14A - FRT-ch.0 Control Register C
        volatile uint32_t FRT_TCCP1;  ///< Offset: 0x14E - FRT-ch.1 Cycle Setting Register
        volatile uint32_t FRT_TCDT1;  ///< Offset: 0x152 - FRT-ch.1 Count Value Register
        volatile uint32_t FRT_TCSA1;  ///< Offset: 0x154 - FRT-ch.1 Control Register A
        volatile uint32_t FRT_TCSC1;  ///< Offset: 0x156 - FRT-ch.1 Control Register C
        volatile uint32_t FRT_TCCP2;  ///< Offset: 0x15A - FRT-ch.2 Cycle Setting Register
        volatile uint32_t FRT_TCDT2;  ///< Offset: 0x15E - FRT-ch.2 Count Value Register
        volatile uint32_t FRT_TCSA2;  ///< Offset: 0x160 - FRT-ch.2 Control Register A
        volatile uint32_t FRT_TCSC2;  ///< Offset: 0x162 - FRT-ch.2 Control Register C
        volatile uint32_t FRT_TCAL;  ///< Offset: 0x164 - FRT Simultaneous Start Control Register
        volatile uint32_t OCU_OCCP0;  ///< Offset: 0x102 - OCU ch.0 Compare Value Store Register
        volatile uint32_t OCU_OCCP1;  ///< Offset: 0x106 - OCU ch.1 Compare Value Store Register
        volatile uint32_t OCU_OCCP2;  ///< Offset: 0x10A - OCU ch.2 Compare Value Store Register
        volatile uint32_t OCU_OCCP3;  ///< Offset: 0x10E - OCU ch.3 Compare Value Store Register
        volatile uint32_t OCU_OCCP4;  ///< Offset: 0x112 - OCU ch.4 Compare Value Store Register
        volatile uint32_t OCU_OCCP5;  ///< Offset: 0x116 - OCU ch.5 Compare Value Store Register
        volatile uint32_t OCU_OCSA10;  ///< Offset: 0x118 - OCU ch.0/1 Control Register A
        volatile uint32_t OCU_OCSB10;  ///< Offset: 0x119 - OCU ch.0/1 Control Register B
        volatile uint32_t OCU_OCSD10;  ///< Offset: 0x11A - OCU ch.0/1 Control Register D
        volatile uint32_t OCU_OCSA32;  ///< Offset: 0x11C - OCU ch.2/3 Control Register A
        volatile uint32_t OCU_OCSB32;  ///< Offset: 0x11D - OCU ch.2/3 Control Register B
        volatile uint32_t OCU_OCSD32;  ///< Offset: 0x11E - OCU ch.2/3 Control Register D
        volatile uint32_t OCU_OCSA54;  ///< Offset: 0x120 - OCU ch.4/5 Control Register A
        volatile uint32_t OCU_OCSB54;  ///< Offset: 0x121 - OCU ch.4/5 Control Register B
        volatile uint32_t OCU_OCSD54;  ///< Offset: 0x122 - OCU ch.4/5 Control Register D
        volatile uint32_t OCU_OCSC;  ///< Offset: 0x124 - OCU Control Register C
        volatile uint32_t OCU_OCSE0;  ///< Offset: 0x128 - OCU ch.0 Control Register E
        volatile uint32_t OCU_OCSE1;  ///< Offset: 0x12C - OCU ch.1 Control Register E
        volatile uint32_t OCU_OCSE2;  ///< Offset: 0x130 - OCU ch.2 Control Register E
        volatile uint32_t OCU_OCSE3;  ///< Offset: 0x134 - OCU ch.3 Control Register E
        volatile uint32_t OCU_OCSE4;  ///< Offset: 0x138 - OCU ch.4 Control Register E
        volatile uint32_t OCU_OCSE5;  ///< Offset: 0x13C - OCU ch.5 Control Register E
        volatile uint32_t OCU_OCFS10;  ///< Offset: 0x168 - OCU ch.0/1 Connecting FRT Select Register
        volatile uint32_t OCU_OCFS32;  ///< Offset: 0x169 - OCU ch.2/3 Connecting FRT Select Register
        volatile uint32_t OCU_OCFS54;  ///< Offset: 0x16A - OCU ch.4/5 Connecting FRT Select Register
        volatile uint32_t WFG_WFTF10;  ///< Offset: 0x18E - Pulse Counter Value Register for WFG ch.0/1
        volatile uint32_t WFG_WFTA10;  ///< Offset: 0x190 - WFG Timer Value Register for WFG ch.0/1
        volatile uint32_t WFG_WFTB10;  ///< Offset: 0x192 - WFG Timer Value Register for WFG ch.0/1
        volatile uint32_t WFG_WFTF32;  ///< Offset: 0x196 - Pulse Counter Value Register for WFG ch.2/3
        volatile uint32_t WFG_WFTA32;  ///< Offset: 0x198 - WFG Timer Value Register for WFG ch.2/3
        volatile uint32_t WFG_WFTB32;  ///< Offset: 0x19A - WFG Timer Value Register for WFG ch.2/3
        volatile uint32_t WFG_WFTF54;  ///< Offset: 0x19E - Pulse Counter Value Register for WFG ch.4/5
        volatile uint32_t WFG_WFTA54;  ///< Offset: 0x1A0 - WFG Timer Value Register for WFG ch.4/5
        volatile uint32_t WFG_WFTB54;  ///< Offset: 0x1A2 - WFG Timer Value Register for WFG ch.4/5
        volatile uint32_t WFG_WFSA10;  ///< Offset: 0x1A4 - WFG Control Register A for WFG ch.0/1
        volatile uint32_t WFG_WFSA32;  ///< Offset: 0x1A8 - WFG Control Register A for WFG ch.2/3
        volatile uint32_t WFG_WFSA54;  ///< Offset: 0x1AC - WFG Control Register A for WFG ch.4/5
        volatile uint32_t WFG_WFIR;  ///< Offset: 0x1B0 - WFG Interrupt Control Register
        volatile uint32_t WFG_NZCL;  ///< Offset: 0x1B4 - NZCL Control Register
        volatile uint32_t ICU_ICFS10;  ///< Offset: 0x16C - ICU ch.0/1 Connecting FRT Select Register
        volatile uint32_t ICU_ICFS32;  ///< Offset: 0x16D - ICU ch.2/3 Connecting FRT Select Register
        volatile uint32_t ICU_ICCP0;  ///< Offset: 0x176 - ICU-ch.0 Capture Value Store Register
        volatile uint32_t ICU_ICCP1;  ///< Offset: 0x17A - ICU-ch.1 Capture Value Store Register
        volatile uint32_t ICU_ICCP2;  ///< Offset: 0x17E - ICU-ch.2 Capture Value Store Register
        volatile uint32_t ICU_ICCP3;  ///< Offset: 0x182 - ICU-ch.3 Capture Value Store Register
        volatile uint32_t ICU_ICSA10;  ///< Offset: 0x184 - ICU ch.0/1 Control Register A
        volatile uint32_t ICU_ICSB10;  ///< Offset: 0x185 - ICU ch.0/1 Control Register B
        volatile uint32_t ICU_ICSA32;  ///< Offset: 0x188 - ICU ch.2/3 Control Register A
        volatile uint32_t ICU_ICSB32;  ///< Offset: 0x189 - ICU ch.2/3 Control Register B
        volatile uint32_t ADCMP_ACFS10;  ///< Offset: 0x170 - ADCMP ch.0/1 Connecting FRT Select Register
        volatile uint32_t ADCMP_ACFS32;  ///< Offset: 0x171 - ADCMP ch.2/3 Connecting FRT Select Register
        volatile uint32_t ADCMP_ACFS54;  ///< Offset: 0x172 - ADCMP ch.4/5 Connecting FRT Select Register
        volatile uint32_t ADCMP_ACMP0;  ///< Offset: 0x1BA - ADCMP ch.0 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP1;  ///< Offset: 0x1BE - ADCMP ch.1 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP2;  ///< Offset: 0x1C2 - ADCMP ch.2 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP3;  ///< Offset: 0x1C6 - ADCMP ch.3 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP4;  ///< Offset: 0x1CA - ADCMP ch.4 Compare Value Store Register
        volatile uint32_t ADCMP_ACMP5;  ///< Offset: 0x1CE - ADCMP ch.5 Compare Value Store Register
        volatile uint32_t ADCMP_ACSA;  ///< Offset: 0x1D0 - ADCMP Control Register A
        volatile uint32_t ADCMP_ACSC0;  ///< Offset: 0x1D4 - ADCMP ch.0 Control Register C
        volatile uint32_t ADCMP_ACSD0;  ///< Offset: 0x1D5 - ADCMP ch.0 Control Register D
        volatile uint32_t ADCMP_ACMC0;  ///< Offset: 0x1D6 - ADCMP ch.0 Mask Compare Value Storage Register
        volatile uint32_t ADCMP_ACSC1;  ///< Offset: 0x1D8 - ADCMP ch.1 Control Register C
        volatile uint32_t ADCMP_ACSD1;  ///< Offset: 0x1D9 - ADCMP ch.1 Control Register D
        volatile uint32_t ADCMP_ACMC1;  ///< Offset: 0x1DA - ADCMP ch.1 Mask Compare Value Storage Register
        volatile uint32_t ADCMP_ACSC2;  ///< Offset: 0x1DC - ADCMP ch.2 Control Register C
        volatile uint32_t ADCMP_ACSD2;  ///< Offset: 0x1DD - ADCMP ch.2 Control Register D
        volatile uint32_t ADCMP_ACMC2;  ///< Offset: 0x1DE - ADCMP ch.2 Mask Compare Value Storage Register
        volatile uint32_t ADCMP_ACSC3;  ///< Offset: 0x1E0 - ADCMP ch.3 Control Register C
        volatile uint32_t ADCMP_ACSD3;  ///< Offset: 0x1E1 - ADCMP ch.3 Control Register D
        volatile uint32_t ADCMP_ACMC3;  ///< Offset: 0x1E2 - ADCMP ch.3 Mask Compare Value Storage Register
        volatile uint32_t ADCMP_ACSC4;  ///< Offset: 0x1E4 - ADCMP ch.4 Control Register C
        volatile uint32_t ADCMP_ACSD4;  ///< Offset: 0x1E5 - ADCMP ch.4 Control Register D
        volatile uint32_t ADCMP_ACMC4;  ///< Offset: 0x1E6 - ADCMP ch.4 Mask Compare Value Storage Register
        volatile uint32_t ADCMP_ACSC5;  ///< Offset: 0x1E8 - ADCMP ch.5 Control Register C
        volatile uint32_t ADCMP_ACSD5;  ///< Offset: 0x1E9 - ADCMP ch.5 Control Register D
        volatile uint32_t ADCMP_ACMC5;  ///< Offset: 0x1EA - ADCMP ch.5 Mask Compare Value Storage Register
        volatile uint32_t FRT_TCSD;  ///< Offset: 0x1EC - ERROR!!!!!!!!!!!!!!!!!!!!
    };

    /// Peripheral instances
    inline Registers* MFT0 = reinterpret_cast<Registers*>(MFT0_BASE);

    // Bit definitions
    /// FRT_TCSA0 Register bits
    namespace frt_tcsa0_bits {
        constexpr uint32_t ECKE = (1U << 15);  ///< Uses an external input clock (FRCK) as FRT's count clock
        constexpr uint32_t IRQZF = (1U << 14);  ///< zero interrupt flag
        constexpr uint32_t IRQZE = (1U << 13);  ///< "Generates interrupt, when ""1"" is set to TCSA.IRQZF"
        constexpr uint32_t ICLR = (1U << 9);  ///< interrupt flag
        constexpr uint32_t ICRE = (1U << 8);  ///< "Generates interrupt when ""1"" is set to TCSA.ICLR"
        constexpr uint32_t BFE = (1U << 7);  ///< Enables TCCP's buffer function
        constexpr uint32_t STOP = (1U << 6);  ///< Puts FRT in stopping state
        constexpr uint32_t MODE = (1U << 5);  ///< FRT's count mode
        constexpr uint32_t SCLR = (1U << 4);  ///< FRT operation state initialization request
        constexpr uint32_t CLK = (4 << 0);  ///< FRT clock cycle
    }

    /// FRT_TCSC0 Register bits
    namespace frt_tcsc0_bits {
        constexpr uint32_t MSPC = (4 << 12);  ///< Current counter value of a Peak value detection mask counter
        constexpr uint32_t MSZC = (4 << 8);  ///< Current counter value of a Zero value detection mask counter
        constexpr uint32_t MSPI = (4 << 4);  ///< Masked Peak value detection number
        constexpr uint32_t MSZI = (4 << 0);  ///< Masked Zero value detection number
    }

    /// FRT_TCAL Register bits
    namespace frt_tcal_bits {
        constexpr uint32_t SCLR22 = (1U << 24);  ///< Mirror register of the SCLR bit located in TCSA2 register of MFT-unit2
        constexpr uint32_t SCLR21 = (1U << 23);  ///< Mirror register of the SCLR bit located in TCSA1 register of MFT-unit2
        constexpr uint32_t SCLR20 = (1U << 22);  ///< Mirror register of the SCLR bit located in TCSA0 register of MFT-unit2
        constexpr uint32_t SCLR12 = (1U << 21);  ///< Mirror register of the SCLR bit located in TCSA2 register of MFT-unit1
        constexpr uint32_t SCLR11 = (1U << 20);  ///< Mirror register of the SCLR bit located in TCSA1 register of MFT-unit1
        constexpr uint32_t SCLR10 = (1U << 19);  ///< Mirror register of the SCLR bit located in TCSA0 register of MFT-unit1
        constexpr uint32_t SCLR02 = (1U << 18);  ///< Mirror register of the SCLR bit located in TCSA2 register of MFT-unit0
        constexpr uint32_t SCLR01 = (1U << 17);  ///< Mirror register of the SCLR bit located in TCSA1 register of MFT-unit0
        constexpr uint32_t SCLR00 = (1U << 16);  ///< Mirror register of the SCLR bit located in TCSA0 register of MFT-unit0
        constexpr uint32_t STOP22 = (1U << 8);  ///< Mirror register of the STOP bit located in TCSA2 register of MFT-unit2
        constexpr uint32_t STOP21 = (1U << 7);  ///< Mirror register of the STOP bit located in TCSA1 register of MFT-unit2
        constexpr uint32_t STOP20 = (1U << 6);  ///< Mirror register of the STOP bit located in TCSA0 register of MFT-unit2
        constexpr uint32_t STOP12 = (1U << 5);  ///< Mirror register of the STOP bit located in TCSA2 register of MFT-unit1
        constexpr uint32_t STOP11 = (1U << 4);  ///< Mirror register of the STOP bit located in TCSA1 register of MFT-unit1
        constexpr uint32_t STOP10 = (1U << 3);  ///< Mirror register of the STOP bit located in TCSA0 register of MFT-unit1
        constexpr uint32_t STOP02 = (1U << 2);  ///< Mirror register of the STOP bit located in TCSA2 register of MFT-unit0
        constexpr uint32_t STOP01 = (1U << 1);  ///< Mirror register of the STOP bit located in TCSA1 register of MFT-unit0
        constexpr uint32_t STOP00 = (1U << 0);  ///< Mirror register of the STOP bit located in TCSA0 register of MFT-unit0
    }

    /// OCU_OCSA10 Register bits
    namespace ocu_ocsa10_bits {
        constexpr uint32_t IOP1 = (1U << 7);  ///< Indicates that a match has already been detected between FRT's count value and OCCP(1) value at OCU ch.(1).
        constexpr uint32_t IOP0 = (1U << 6);  ///< Indicates that a match has already been detected between FRT's count value and OCCP(0) value at OCU ch.(0).
        constexpr uint32_t IOE1 = (1U << 5);  ///< "Generates interrupt, when ""1"" is set to OCSA.IOP1"
        constexpr uint32_t IOE0 = (1U << 4);  ///< "Generates interrupt, when ""1"" is set to OCSA.IOP0"
        constexpr uint32_t CST1 = (1U << 1);  ///< Enables the operation of OCU ch.(1)
        constexpr uint32_t CST0 = (1U << 0);  ///< Enables the operation of OCU ch.(0)
    }

    /// OCU_OCSB10 Register bits
    namespace ocu_ocsb10_bits {
        constexpr uint32_t FM4 = (1U << 7);  ///< selects FM4 mode for operating mode
        constexpr uint32_t CMOD = (1U << 4);  ///< selects OCU's operation mode in combination with OCSC.MOD0 to MOD5
        constexpr uint32_t OTD1 = (1U << 1);  ///< Indicates that the RT(1) output pin is in the High-level output state.
        constexpr uint32_t OTD0 = (1U << 0);  ///< Indicates that the RT(0) output pin is in the High-level output state.
    }

    /// OCU_OCSD10 Register bits
    namespace ocu_ocsd10_bits {
        constexpr uint32_t OFEX1 = (1U << 13);  ///< extends the matching determination conditions of the connected FRT with the OCCP(1) register value
        constexpr uint32_t OFEX0 = (1U << 12);  ///< extends the matching determination conditions of the connected FRT with the OCCP(0) register value
        constexpr uint32_t OEBM1 = (1U << 11);  ///< sets the linked transfer settings with the FRT interrupt mask counter
        constexpr uint32_t OEBM0 = (1U << 10);  ///< sets the linked transfer settings with the FRT interrupt mask counter
        constexpr uint32_t OPBM1 = (1U << 9);  ///< sets the linked transfer settings with the FRT interrupt mask counter
        constexpr uint32_t OPBM0 = (1U << 8);  ///< sets the linked transfer settings with the FRT interrupt mask counter
        constexpr uint32_t OCSE1BUFE = (2 << 6);  ///< Enable buffer register function of OCSE(1)
        constexpr uint32_t OCSE0BUFE = (2 << 4);  ///< Enable buffer register function of OCSE(0)
        constexpr uint32_t OCCP1BUFE = (2 << 2);  ///< Enable buffer register function of OCCP(1)
        constexpr uint32_t OCCP0BUFE = (2 << 0);  ///< Enable buffer register function of OCCP(0)
    }

    /// OCU_OCSC Register bits
    namespace ocu_ocsc_bits {
        constexpr uint32_t MOD5 = (1U << 13);  ///< OCSC.MOD4 and OCSC.MOD5 determine the operation mode of OCU ch.4/ch.5 in combination with OCSB54.CMOD
        constexpr uint32_t MOD4 = (1U << 12);  ///< OCSC.MOD4 and OCSC.MOD5 determine the operation mode of OCU ch.4/ch.5 in combination with OCSB54.CMOD
        constexpr uint32_t MOD3 = (1U << 11);  ///< OCSC.MOD2 and OCSC.MOD3 determine the operation mode of OCU ch.2/ch.3 in combination with OCSB32.CMOD
        constexpr uint32_t MOD2 = (1U << 10);  ///< OCSC.MOD2 and OCSC.MOD3 determine the operation mode of OCU ch.2/ch.3 in combination with OCSB32.CMOD
        constexpr uint32_t MOD1 = (1U << 9);  ///< OCSC.MOD0 and OCSC.MOD1 determine the operation mode of OCU ch.0/ch.1 in combination with OCSB10.CMOD
        constexpr uint32_t MOD0 = (1U << 8);  ///< OCSC.MOD0 and OCSC.MOD1 determine the operation mode of OCU ch.0/ch.1 in combination with OCSB10.CMOD
    }

    /// OCU_OCSE0 Register bits
    namespace ocu_ocse0_bits {
        constexpr uint32_t OCSE = (16 << 0);  ///< specify the setting conditions of the OCU's matching detection register (IOP0)
    }

    /// OCU_OCSE1 Register bits
    namespace ocu_ocse1_bits {
        constexpr uint32_t OCSE = (32 << 0);  ///< specify the setting conditions of the OCU's matching detection register (IOP0/IOP1)
    }

    /// OCU_OCFS10 Register bits
    namespace ocu_ocfs10_bits {
        constexpr uint32_t FSO1 = (4 << 4);  ///< Connects FRT ch.x to OCU ch.1
        constexpr uint32_t FSO0 = (4 << 0);  ///< Connects FRT ch.x to OCU ch.0
    }

    /// WFG_WFSA10 Register bits
    namespace wfg_wfsa10_bits {
        constexpr uint32_t DMOD = (2 << 12);  ///< 1specifies polarity for RTO(0) and RTO(1) signal outputs
        constexpr uint32_t PGEN = (2 << 10);  ///< specifies how to reflect the CH_PPG signal for each channel of the WFG
        constexpr uint32_t PSEL = (2 << 8);  ///< select the PPG timer unit to be used for each channel of the WFG
        constexpr uint32_t GTEN = (2 << 6);  ///< selects the output conditions for the CH_GATE output signal of the WFG
        constexpr uint32_t TMD = (3 << 3);  ///< select the WFG's operation mode
        constexpr uint32_t DCK = (3 << 0);  ///< set the count clock cycle for the WFG timer and Pulse counter
    }

    /// WFG_WFIR Register bits
    namespace wfg_wfir_bits {
        constexpr uint32_t TMIS54 = (1U << 15);  ///< stops the WFG54 reload timer and clears TMIF54
        constexpr uint32_t TMIE54 = (1U << 14);  ///< stops the WFG54 reload timer and clears TMIF54
        constexpr uint32_t TMIC54 = (1U << 13);  ///< clears TIMF54 bit
        constexpr uint32_t TMIF54 = (1U << 12);  ///< detects the event of WFG54 reload timer interrupt occurrence
        constexpr uint32_t TMIS32 = (1U << 11);  ///< stops the WFG32 reload timer and clears TMIF32
        constexpr uint32_t TMIE32 = (1U << 10);  ///< 1stops the WFG32 reload timer and clears TMIF32
        constexpr uint32_t TMIC32 = (1U << 9);  ///< clears TIMF32 bit
        constexpr uint32_t TMIF32 = (1U << 8);  ///< detects the event of WFG32 reload timer interrupt occurrence
        constexpr uint32_t TMIS10 = (1U << 7);  ///< stops the WFG10 reload timer and clears TMIF10
        constexpr uint32_t TMIE10 = (1U << 6);  ///< starts WFG10 reload timer and checks the operation state of it.
        constexpr uint32_t TMIC10 = (1U << 5);  ///< clears TIMF10 bit
        constexpr uint32_t TMIF10 = (1U << 4);  ///< detects the event of WFG10 reload timer interrupt occurrence
        constexpr uint32_t DTICB = (1U << 3);  ///< clears DTIFB bit.
        constexpr uint32_t DTIFB = (1U << 2);  ///< detects DTTIX signal input via analog noise filter
        constexpr uint32_t DTICA = (1U << 1);  ///< clears the DTIFA interrupt flag
        constexpr uint32_t DTIFA = (1U << 0);  ///< detects the event of DTTIX signal input via digital noise-canceller
    }

    /// WFG_NZCL Register bits
    namespace wfg_nzcl_bits {
        constexpr uint32_t WIM54 = (1U << 14);  ///< selects whether a WFG54 reload timer interrupt is masked when the WFIR.TMIF54 flag is set
        constexpr uint32_t WIM32 = (1U << 13);  ///< selects whether a WFG32 reload timer interrupt is masked when the WFIR.TMIF32 flag is set
        constexpr uint32_t WIM10 = (1U << 12);  ///< selects whether a WFG10 reload timer interrupt is masked when the WFIR.TMIF10 flag is set
        constexpr uint32_t DIMB = (1U << 9);  ///< selects whether a DTIF interrupt is masked when the WFIR.TIFDTIFB flag is set
        constexpr uint32_t DIMA = (1U << 8);  ///< selects whether a DTIF interrupt is masked when the WFIR.DTIFA flag is set
        constexpr uint32_t DHOLD = (1U << 7);  ///< selects whether the RTO output signal of WFG is held when the DTIF interrupt signal is asserted
        constexpr uint32_t DTIEB = (1U << 5);  ///< Enables the path from DTTIX pin to analog noise filter
        constexpr uint32_t SDTI = (1U << 4);  ///< sets the WFIR.DTIFA register by writing to the register from the CPU
        constexpr uint32_t NWS = (3 << 1);  ///< set the noise-canceling width for a digital noise-canceller
        constexpr uint32_t DTIEA = (1U << 0);  ///< Enables the path for digital noise filter from DTTIX pin
    }

    /// ICU_ICFS10 Register bits
    namespace icu_icfs10_bits {
        constexpr uint32_t FSI1 = (4 << 4);  ///< Connects FRT ch.x to ICU ch.(1)
        constexpr uint32_t FSI0 = (4 << 0);  ///< Connects FRT ch.x to ICU ch.(0)
    }

    /// ICU_ICSA10 Register bits
    namespace icu_icsa10_bits {
        constexpr uint32_t ICP1 = (1U << 7);  ///< Indicates that a valid edge has been detected at ICU ch.(1) and the capture operation has been performed
        constexpr uint32_t ICP0 = (1U << 6);  ///< Indicates that a valid edge has been detected at ICU ch.(0) and the capture operation has been performed
        constexpr uint32_t ICE1 = (1U << 5);  ///< "Generates interrupt, when ""1"" is set to ICSA.ICP1."
        constexpr uint32_t ICE0 = (1U << 4);  ///< "Generates interrupt, when ""1"" is set to ICSA.ICP0."
        constexpr uint32_t EG1 = (2 << 2);  ///< enables/disables the operation of ICU-ch.(1) and selects a valid edge(s)
        constexpr uint32_t EG0 = (2 << 0);  ///< enables/disables the operation of ICU-ch.(0) and selects a valid edge(s)
    }

    /// ICU_ICSB10 Register bits
    namespace icu_icsb10_bits {
        constexpr uint32_t IEI1 = (1U << 1);  ///< indicates the latest valid edge of ICU ch.(1)
        constexpr uint32_t IEI0 = (1U << 0);  ///< indicates the latest valid edge of ICU ch.(0)
    }

    /// ADCMP_ACFS10 Register bits
    namespace adcmp_acfs10_bits {
        constexpr uint32_t FSA1 = (4 << 4);  ///< specify the FRT to be connected to ADCMP ch.(1)
        constexpr uint32_t FSA0 = (4 << 0);  ///< specify the FRT to be connected to ADCMP ch.(0)
    }

    /// ADCMP_ACMP0 Register bits
    namespace adcmp_acmp0_bits {
        constexpr uint32_t ACMP = (16 << 0);  ///< 0
    }

    /// ADCMP_ACSA Register bits
    namespace adcmp_acsa_bits {
        constexpr uint32_t SEL54 = (2 << 12);  ///< selects compatible operation of ADCMP ch.5 and ch.4 with FM3 Family products
        constexpr uint32_t SEL32 = (2 << 10);  ///< selects compatible operation of ADCMP ch.3 and ch.2 with FM3 Family products
        constexpr uint32_t SEL10 = (2 << 8);  ///< selects compatible operation of ADCMP ch.1 and ch.0 with FM3 Family products
        constexpr uint32_t CE54 = (2 << 4);  ///< enables/disables compatibility of ADCMP ch.5 and ch.4 with FM3 Family products
        constexpr uint32_t CE32 = (2 << 2);  ///< enables/disables compatibility of ADCMP ch.3 and ch.2 with FM3 Family products
        constexpr uint32_t CE10 = (2 << 0);  ///< enables/disables compatibility of ADCMP ch.1 and ch.0 with FM3 Family products
    }

    /// ADCMP_ACSC0 Register bits
    namespace adcmp_acsc0_bits {
        constexpr uint32_t APBM = (1U << 5);  ///< sets the linked transfer with the FRT interrupt mask counter
        constexpr uint32_t ADSEL = (3 << 2);  ///< specify the destinations of ADC start signals that are output by ADCMP
        constexpr uint32_t BUFE = (2 << 0);  ///< select enable/disable and transfer timing for buffer function of the ACMP register.
    }

    /// ADCMP_ACSD0 Register bits
    namespace adcmp_acsd0_bits {
        constexpr uint32_t ZE = (1U << 7);  ///< enables/disables the operation of the ADCMP when the FRT is "0x0000"
        constexpr uint32_t UE = (1U << 6);  ///< enables/disables the operation of the ADCMP that is counting up for the connected FRT
        constexpr uint32_t PE = (1U << 5);  ///< enables/disables the operation of the ADCMP that is counting down at the Peak value of the connected FRT
        constexpr uint32_t DE = (1U << 4);  ///< enables/disables the operation of the ADCMP that is counting down for the connected FRT
        constexpr uint32_t OCUS = (1U << 1);  ///< selects the OCU OCCP register that will become the start for offset start
        constexpr uint32_t AMOD = (1U << 0);  ///< selects operation mode for ADCMP
    }

    /// ADCMP_ACMC0 Register bits
    namespace adcmp_acmc0_bits {
        constexpr uint32_t MPCE = (1U << 7);  ///< specifies whether a comparison is performed with the FRT peak interrupt mask counter
        constexpr uint32_t MZCE = (1U << 6);  ///< specifies whether a comparison is performed with the FRT zero interrupt mask counter
        constexpr uint32_t AMC = (4 << 0);  ///< specifies the value to be compared with the FRT interrupt mask counter
    }

    /// FRT_TCSD Register bits
    namespace frt_tcsd_bits {
        constexpr uint32_t OFMD2 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t OFMD1 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

}

// ============================================================================
// MFT1 Peripheral
// ============================================================================

namespace mft1 {
    /// Base addresses
    constexpr uint32_t MFT1_BASE = 0x40021000;

    /// MFT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFT1 = reinterpret_cast<Registers*>(MFT1_BASE);

}

// ============================================================================
// MFT2 Peripheral
// ============================================================================

namespace mft2 {
    /// Base addresses
    constexpr uint32_t MFT2_BASE = 0x40022000;

    /// MFT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFT2 = reinterpret_cast<Registers*>(MFT2_BASE);

}

// ============================================================================
// MFT Peripheral
// ============================================================================

namespace mft {
    /// Base addresses
    constexpr uint32_t MFT_PPG_BASE = 0x40024000;

    /// MFT Register structure
    struct Registers {
        volatile uint32_t TTCR0;  ///< Offset: 0x00 - PPG Start Trigger Control Register 0
        volatile uint32_t TTCR1;  ///< Offset: 0x20 - PPG Start Trigger Control Register 1
        volatile uint32_t TTCR2;  ///< Offset: 0x40 - PPG Start Trigger Control Register 2
        volatile uint32_t COMP0;  ///< Offset: 0x08 - PPG Compare Register 0
        volatile uint32_t COMP2;  ///< Offset: 0x0C - PPG Compare Register 2
        volatile uint32_t COMP4;  ///< Offset: 0x10 - PPG Compare Register 4
        volatile uint32_t COMP6;  ///< Offset: 0x14 - PPG Compare Register 6
        volatile uint32_t COMP1;  ///< Offset: 0x28 - PPG Compare Register 1
        volatile uint32_t COMP3;  ///< Offset: 0x2C - PPG Compare Register 3
        volatile uint32_t COMP5;  ///< Offset: 0x30 - PPG Compare Register 5
        volatile uint32_t COMP7;  ///< Offset: 0x34 - PPG Compare Register 7
        volatile uint32_t COMP8;  ///< Offset: 0x48 - PPG Compare Register 8
        volatile uint32_t COMP10;  ///< Offset: 0x4C - PPG Compare Register 10
        volatile uint32_t COMP12;  ///< Offset: 0x50 - PPG Compare Register 12
        volatile uint32_t COMP14;  ///< Offset: 0x54 - PPG Compare Register 14
        volatile uint32_t TRG;  ///< Offset: 0x100 - PPG Start Register 0
        volatile uint32_t TRG1;  ///< Offset: 0x140 - PPG Start Register 1
        volatile uint32_t REVC;  ///< Offset: 0x104 - Output Reverse Register 0
        volatile uint32_t REVC1;  ///< Offset: 0x144 - Output Reverse Register 1
        volatile uint32_t PPGC0;  ///< Offset: 0x201 - PPG Operation Mode Control Register 0
        volatile uint32_t PPGC1;  ///< Offset: 0x200 - PPG Operation Mode Control Register 1
        volatile uint32_t PPGC2;  ///< Offset: 0x205 - PPG Operation Mode Control Register 2
        volatile uint32_t PPGC3;  ///< Offset: 0x204 - PPG Operation Mode Control Register 3
        volatile uint32_t PPGC4;  ///< Offset: 0x241 - PPG Operation Mode Control Register 4
        volatile uint32_t PPGC5;  ///< Offset: 0x240 - PPG Operation Mode Control Register 5
        volatile uint32_t PPGC6;  ///< Offset: 0x245 - PPG Operation Mode Control Register 6
        volatile uint32_t PPGC7;  ///< Offset: 0x244 - PPG Operation Mode Control Register 7
        volatile uint32_t PPGC8;  ///< Offset: 0x281 - PPG Operation Mode Control Register 8
        volatile uint32_t PPGC9;  ///< Offset: 0x280 - PPG Operation Mode Control Register 9
        volatile uint32_t PPGC10;  ///< Offset: 0x285 - PPG Operation Mode Control Register 10
        volatile uint32_t PPGC11;  ///< Offset: 0x284 - PPG Operation Mode Control Register 11
        volatile uint32_t PPGC12;  ///< Offset: 0x2C1 - PPG Operation Mode Control Register 12
        volatile uint32_t PPGC13;  ///< Offset: 0x2C0 - PPG Operation Mode Control Register 13
        volatile uint32_t PPGC14;  ///< Offset: 0x2C5 - PPG Operation Mode Control Register 14
        volatile uint32_t PPGC15;  ///< Offset: 0x2C4 - PPG Operation Mode Control Register 15
        volatile uint32_t PPGC16;  ///< Offset: 0x301 - PPG Operation Mode Control Register 16
        volatile uint32_t PPGC17;  ///< Offset: 0x300 - PPG Operation Mode Control Register 17
        volatile uint32_t PPGC18;  ///< Offset: 0x305 - PPG Operation Mode Control Register 18
        volatile uint32_t PPGC19;  ///< Offset: 0x304 - PPG Operation Mode Control Register 19
        volatile uint32_t PPGC20;  ///< Offset: 0x341 - PPG Operation Mode Control Register 20
        volatile uint32_t PPGC21;  ///< Offset: 0x340 - PPG Operation Mode Control Register 21
        volatile uint32_t PPGC22;  ///< Offset: 0x345 - PPG Operation Mode Control Register 22
        volatile uint32_t PPGC23;  ///< Offset: 0x344 - PPG Operation Mode Control Register 23
        volatile uint32_t PRLH0;  ///< Offset: 0x209 - PPG0 Reload Registers High
        volatile uint32_t PRLL0;  ///< Offset: 0x208 - PPG0 Reload Registers Low
        volatile uint32_t PRLH1;  ///< Offset: 0x20D - PPG1 Reload Registers High
        volatile uint32_t PRLL1;  ///< Offset: 0x20C - PPG1 Reload Registers Low
        volatile uint32_t PRLH2;  ///< Offset: 0x211 - PPG2 Reload Registers High
        volatile uint32_t PRLL2;  ///< Offset: 0x210 - PPG2 Reload Registers Low
        volatile uint32_t PRLH3;  ///< Offset: 0x215 - PPG3 Reload Registers High
        volatile uint32_t PRLL3;  ///< Offset: 0x214 - PPG3 Reload Registers Low
        volatile uint32_t PRLH4;  ///< Offset: 0x249 - PPG4 Reload Registers High
        volatile uint32_t PRLL4;  ///< Offset: 0x248 - PPG4 Reload Registers Low
        volatile uint32_t PRLH5;  ///< Offset: 0x24D - PPG5 Reload Registers High
        volatile uint32_t PRLL5;  ///< Offset: 0x24C - PPG5 Reload Registers Low
        volatile uint32_t PRLH6;  ///< Offset: 0x251 - PPG6 Reload Registers High
        volatile uint32_t PRLL6;  ///< Offset: 0x250 - PPG6 Reload Registers Low
        volatile uint32_t PRLH7;  ///< Offset: 0x255 - PPG7 Reload Registers High
        volatile uint32_t PRLL7;  ///< Offset: 0x254 - PPG7 Reload Registers Low
        volatile uint32_t PRLH8;  ///< Offset: 0x289 - PPG8 Reload Registers High
        volatile uint32_t PRLL8;  ///< Offset: 0x288 - PPG8 Reload Registers Low
        volatile uint32_t PRLH9;  ///< Offset: 0x28D - PPG9 Reload Registers High
        volatile uint32_t PRLL9;  ///< Offset: 0x28C - PPG9 Reload Registers Low
        volatile uint32_t PRLH10;  ///< Offset: 0x291 - PPG10 Reload Registers High
        volatile uint32_t PRLL10;  ///< Offset: 0x290 - PPG10 Reload Registers Low
        volatile uint32_t PRLH11;  ///< Offset: 0x295 - PPG11 Reload Registers High
        volatile uint32_t PRLL11;  ///< Offset: 0x294 - PPG11 Reload Registers Low
        volatile uint32_t PRLH12;  ///< Offset: 0x2C9 - PPG12 Reload Registers High
        volatile uint32_t PRLL12;  ///< Offset: 0x2C8 - PPG12 Reload Registers Low
        volatile uint32_t PRLH13;  ///< Offset: 0x2CD - PPG13 Reload Registers High
        volatile uint32_t PRLL13;  ///< Offset: 0x2CC - PPG13 Reload Registers Low
        volatile uint32_t PRLH14;  ///< Offset: 0x2D1 - PPG14 Reload Registers High
        volatile uint32_t PRLL14;  ///< Offset: 0x2D0 - PPG14 Reload Registers Low
        volatile uint32_t PRLH15;  ///< Offset: 0x2D5 - PPG15 Reload Registers High
        volatile uint32_t PRLL15;  ///< Offset: 0x2D4 - PPG15 Reload Registers Low
        volatile uint32_t PRLH16;  ///< Offset: 0x309 - PPG16 Reload Registers High
        volatile uint32_t PRLL16;  ///< Offset: 0x308 - PPG16 Reload Registers Low
        volatile uint32_t PRLH17;  ///< Offset: 0x30D - PPG17 Reload Registers High
        volatile uint32_t PRLL17;  ///< Offset: 0x30C - PPG17 Reload Registers Low
        volatile uint32_t PRLH18;  ///< Offset: 0x311 - PPG18 Reload Registers High
        volatile uint32_t PRLL18;  ///< Offset: 0x310 - PPG18 Reload Registers Low
        volatile uint32_t PRLH19;  ///< Offset: 0x315 - PPG19 Reload Registers High
        volatile uint32_t PRLL19;  ///< Offset: 0x314 - PPG19 Reload Registers Low
        volatile uint32_t PRLH20;  ///< Offset: 0x349 - PPG20 Reload Registers High
        volatile uint32_t PRLL20;  ///< Offset: 0x348 - PPG20 Reload Registers Low
        volatile uint32_t PRLH21;  ///< Offset: 0x34D - PPG21 Reload Registers High
        volatile uint32_t PRLL21;  ///< Offset: 0x34C - PPG21 Reload Registers Low
        volatile uint32_t PRLH22;  ///< Offset: 0x351 - PPG22 Reload Registers High
        volatile uint32_t PRLL22;  ///< Offset: 0x350 - PPG22 Reload Registers Low
        volatile uint32_t PRLH23;  ///< Offset: 0x355 - PPG23 Reload Registers High
        volatile uint32_t PRLL23;  ///< Offset: 0x354 - PPG23 Reload Registers Low
        volatile uint32_t GATEC0;  ///< Offset: 0x218 - PPG Gate Function Control Registers 0
        volatile uint32_t GATEC4;  ///< Offset: 0x258 - PPG Gate Function Control Registers 4
        volatile uint32_t GATEC8;  ///< Offset: 0x298 - PPG Gate Function Control Registers 8
        volatile uint32_t GATEC12;  ///< Offset: 0x2D8 - PPG Gate Function Control Registers 12
        volatile uint32_t GATEC16;  ///< Offset: 0x318 - PPG Gate Function Control Registers 16
        volatile uint32_t GATEC20;  ///< Offset: 0x358 - PPG Gate Function Control Registers 20
    };

    /// Peripheral instances
    inline Registers* MFT_PPG = reinterpret_cast<Registers*>(MFT_PPG_BASE);

    // Bit definitions
    /// TTCR0 Register bits
    namespace ttcr0_bits {
        constexpr uint32_t TRG6O = (1U << 15);  ///< PPG6 trigger stop bit
        constexpr uint32_t TRG4O = (1U << 14);  ///< PPG4 trigger stop bit
        constexpr uint32_t TRG2O = (1U << 13);  ///< PPG2 trigger stop bit
        constexpr uint32_t TRG0O = (1U << 12);  ///< PPG0 trigger stop bit
        constexpr uint32_t CS0 = (2 << 10);  ///< 8-bit UP counter clock select bits for comparison
        constexpr uint32_t MONI0 = (1U << 9);  ///< 8-bit UP counter operation state monitor bit for comparison
        constexpr uint32_t STR0 = (1U << 8);  ///< 8-bit UP counter operation enable bit for comparison
    }

    /// TTCR1 Register bits
    namespace ttcr1_bits {
        constexpr uint32_t TRG7O = (1U << 15);  ///< PPG7 trigger stop bit
        constexpr uint32_t TRG5O = (1U << 14);  ///< PPG5 trigger stop bit
        constexpr uint32_t TRG3O = (1U << 13);  ///< PPG3 trigger stop bit
        constexpr uint32_t TRG1O = (1U << 12);  ///< PPG1 trigger stop bit
        constexpr uint32_t CS1 = (2 << 10);  ///< 8-bit UP counter clock select bits for comparison
        constexpr uint32_t MONI1 = (1U << 9);  ///< 8-bit UP counter operation state monitor bit for comparison
        constexpr uint32_t STR1 = (1U << 8);  ///< 8-bit UP counter operation enable bit for comparison
    }

    /// TTCR2 Register bits
    namespace ttcr2_bits {
        constexpr uint32_t TRG22O = (1U << 15);  ///< PPG22 trigger stop bit
        constexpr uint32_t TRG20O = (1U << 14);  ///< PPG20 trigger stop bit
        constexpr uint32_t TRG18O = (1U << 13);  ///< PPG18 trigger stop bit
        constexpr uint32_t TRG16O = (1U << 12);  ///< PPG16 trigger stop bit
        constexpr uint32_t CS2 = (2 << 10);  ///< 8-bit UP counter clock select bits for comparison
        constexpr uint32_t MONI2 = (1U << 9);  ///< 8-bit UP counter operation state monitor bit for comparison
        constexpr uint32_t STR2 = (1U << 8);  ///< 8-bit UP counter operation enable bit for comparison
    }

    /// TRG Register bits
    namespace trg_bits {
        constexpr uint32_t PEN15 = (1U << 15);  ///< PPG15 Start Trigger bit
        constexpr uint32_t PEN14 = (1U << 14);  ///< PPG14 Start Trigger bit
        constexpr uint32_t PEN13 = (1U << 13);  ///< PPG13 Start Trigger bit
        constexpr uint32_t PEN12 = (1U << 12);  ///< PPG12 Start Trigger bit
        constexpr uint32_t PEN11 = (1U << 11);  ///< PPG11 Start Trigger bit
        constexpr uint32_t PEN10 = (1U << 10);  ///< PPG10 Start Trigger bit
        constexpr uint32_t PEN09 = (1U << 9);  ///< PPG9 Start Trigger bit
        constexpr uint32_t PEN08 = (1U << 8);  ///< PPG8 Start Trigger bit
        constexpr uint32_t PEN07 = (1U << 7);  ///< PPG7 Start Trigger bit
        constexpr uint32_t PEN06 = (1U << 6);  ///< PPG6 Start Trigger bit
        constexpr uint32_t PEN05 = (1U << 5);  ///< PPG5 Start Trigger bit
        constexpr uint32_t PEN04 = (1U << 4);  ///< PPG4 Start Trigger bit
        constexpr uint32_t PEN03 = (1U << 3);  ///< PPG3 Start Trigger bit
        constexpr uint32_t PEN02 = (1U << 2);  ///< PPG2 Start Trigger bit
        constexpr uint32_t PEN01 = (1U << 1);  ///< PPG1 Start Trigger bit
        constexpr uint32_t PEN00 = (1U << 0);  ///< PPG0 Start Trigger bit
    }

    /// TRG1 Register bits
    namespace trg1_bits {
        constexpr uint32_t PEN23 = (1U << 7);  ///< PPG23 Start Trigger bit
        constexpr uint32_t PEN22 = (1U << 6);  ///< PPG22 Start Trigger bit
        constexpr uint32_t PEN21 = (1U << 5);  ///< PPG21 Start Trigger bit
        constexpr uint32_t PEN20 = (1U << 4);  ///< PPG20 Start Trigger bit
        constexpr uint32_t PEN19 = (1U << 3);  ///< PPG19 Start Trigger bit
        constexpr uint32_t PEN18 = (1U << 2);  ///< PPG18 Start Trigger bit
        constexpr uint32_t PEN17 = (1U << 1);  ///< PPG17 Start Trigger bit
        constexpr uint32_t PEN16 = (1U << 0);  ///< PPG16 Start Trigger bit
    }

    /// REVC Register bits
    namespace revc_bits {
        constexpr uint32_t REV15 = (1U << 15);  ///< PPG15 Output Reverse Enable bit
        constexpr uint32_t REV14 = (1U << 14);  ///< PPG14 Output Reverse Enable bit
        constexpr uint32_t REV13 = (1U << 13);  ///< PPG13 Output Reverse Enable bit
        constexpr uint32_t REV12 = (1U << 12);  ///< PPG12 Output Reverse Enable bit
        constexpr uint32_t REV11 = (1U << 11);  ///< PPG11 Output Reverse Enable bit
        constexpr uint32_t REV10 = (1U << 10);  ///< PPG10 Output Reverse Enable bit
        constexpr uint32_t REV09 = (1U << 9);  ///< PPG9 Output Reverse Enable bit
        constexpr uint32_t REV08 = (1U << 8);  ///< PPG8 Output Reverse Enable bit
        constexpr uint32_t REV07 = (1U << 7);  ///< PPG7 Output Reverse Enable bit
        constexpr uint32_t REV06 = (1U << 6);  ///< PPG6 Output Reverse Enable bit
        constexpr uint32_t REV05 = (1U << 5);  ///< PPG5 Output Reverse Enable bit
        constexpr uint32_t REV04 = (1U << 4);  ///< PPG4 Output Reverse Enable bit
        constexpr uint32_t REV03 = (1U << 3);  ///< PPG3 Output Reverse Enable bit
        constexpr uint32_t REV02 = (1U << 2);  ///< PPG2 Output Reverse Enable bit
        constexpr uint32_t REV01 = (1U << 1);  ///< PPG1 Output Reverse Enable bit
        constexpr uint32_t REV00 = (1U << 0);  ///< PPG0 Output Reverse Enable bit
    }

    /// REVC1 Register bits
    namespace revc1_bits {
        constexpr uint32_t REV23 = (1U << 7);  ///< PPG23 Output Reverse Enable bit
        constexpr uint32_t REV22 = (1U << 6);  ///< PPG22 Output Reverse Enable bit
        constexpr uint32_t REV21 = (1U << 5);  ///< PPG21 Output Reverse Enable bit
        constexpr uint32_t REV20 = (1U << 4);  ///< PPG20 Output Reverse Enable bit
        constexpr uint32_t REV19 = (1U << 3);  ///< PPG19 Output Reverse Enable bit
        constexpr uint32_t REV18 = (1U << 2);  ///< PPG18 Output Reverse Enable bit
        constexpr uint32_t REV17 = (1U << 1);  ///< PPG17 Output Reverse Enable bit
        constexpr uint32_t REV16 = (1U << 0);  ///< PPG16 Output Reverse Enable bit
    }

    /// PPGC0 Register bits
    namespace ppgc0_bits {
        constexpr uint32_t PIE = (1U << 7);  ///< PPG Interrupt Enable bit
        constexpr uint32_t PUF = (1U << 6);  ///< PPG Counter Underflow bit
        constexpr uint32_t INTM = (1U << 5);  ///< Interrupt Mode Select bit
        constexpr uint32_t PCS = (2 << 3);  ///< PPG DOWN Counter Operation Clock Select bits
        constexpr uint32_t MD = (2 << 1);  ///< PPG Operation Mode Set bits
        constexpr uint32_t TTRG = (1U << 0);  ///< PPG start trigger select bit
    }

    /// PRLH0 Register bits
    namespace prlh0_bits {
        constexpr uint32_t PRLH = (8 << 0);  ///< Reload Registers High
    }

    /// PRLL0 Register bits
    namespace prll0_bits {
        constexpr uint32_t PRLL = (8 << 0);  ///< Reload Registers Low
    }

    /// GATEC0 Register bits
    namespace gatec0_bits {
        constexpr uint32_t STRG2 = (1U << 5);  ///< Select a trigger for PPG2
        constexpr uint32_t EDGE2 = (1U << 4);  ///< Select Start Effective Level for PPG2
        constexpr uint32_t STRG0 = (1U << 1);  ///< Select a trigger for PPG0
        constexpr uint32_t EDGE0 = (1U << 0);  ///< Select Start Effective Level for PPG0
    }

    /// GATEC4 Register bits
    namespace gatec4_bits {
        constexpr uint32_t STRG6 = (1U << 5);  ///< Select a trigger for PPG6
        constexpr uint32_t EDGE6 = (1U << 4);  ///< Select Start Effective Level for PPG6
        constexpr uint32_t STRG4 = (1U << 1);  ///< Select a trigger for PPG4
        constexpr uint32_t EDGE4 = (1U << 0);  ///< Select Start Effective Level for PPG4
    }

    /// GATEC8 Register bits
    namespace gatec8_bits {
        constexpr uint32_t STRG10 = (1U << 5);  ///< Select a trigger for PPG10
        constexpr uint32_t EDGE10 = (1U << 4);  ///< Select Start Effective Level for PPG10
        constexpr uint32_t STRG8 = (1U << 1);  ///< Select a trigger for PPG8
        constexpr uint32_t EDGE8 = (1U << 0);  ///< Select Start Effective Level for PPG8
    }

    /// GATEC12 Register bits
    namespace gatec12_bits {
        constexpr uint32_t STRG14 = (1U << 5);  ///< Select a trigger for PPG14
        constexpr uint32_t EDGE14 = (1U << 4);  ///< Select Start Effective Level for PPG14
        constexpr uint32_t STRG12 = (1U << 1);  ///< Select a trigger for PPG12
        constexpr uint32_t EDGE12 = (1U << 0);  ///< Select Start Effective Level for PPG12
    }

    /// GATEC16 Register bits
    namespace gatec16_bits {
        constexpr uint32_t STRG18 = (1U << 5);  ///< Select a trigger for PPG18
        constexpr uint32_t EDGE18 = (1U << 4);  ///< Select Start Effective Level for PPG18
        constexpr uint32_t STRG16 = (1U << 1);  ///< Select a trigger for PPG16
        constexpr uint32_t EDGE16 = (1U << 0);  ///< Select Start Effective Level for PPG16
    }

    /// GATEC20 Register bits
    namespace gatec20_bits {
        constexpr uint32_t STRG22 = (1U << 5);  ///< Select a trigger for PPG22
        constexpr uint32_t EDGE22 = (1U << 4);  ///< Select Start Effective Level for PPG22
        constexpr uint32_t STRG20 = (1U << 1);  ///< Select a trigger for PPG20
        constexpr uint32_t EDGE20 = (1U << 0);  ///< Select Start Effective Level for PPG20
    }

}

// ============================================================================
// BTIOSEL03 Peripheral
// ============================================================================

namespace btiosel03 {
    /// Base addresses
    constexpr uint32_t BTIOSEL03_BASE = 0x40025100;

    /// BTIOSEL03 Register structure
    struct Registers {
        volatile uint32_t BTSEL0123;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSEL03 = reinterpret_cast<Registers*>(BTIOSEL03_BASE);

    // Bit definitions
    /// BTSEL0123 Register bits
    namespace btsel0123_bits {
        constexpr uint32_t SEL23_ = (4 << 12);  ///< I/O select bits for Ch.2/Ch.3
        constexpr uint32_t SEL01_ = (4 << 8);  ///< I/O select bits for Ch.0/Ch.1
    }

}

// ============================================================================
// BTIOSEL47 Peripheral
// ============================================================================

namespace btiosel47 {
    /// Base addresses
    constexpr uint32_t BTIOSEL47_BASE = 0x40025300;

    /// BTIOSEL47 Register structure
    struct Registers {
        volatile uint32_t BTSEL4567;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSEL47 = reinterpret_cast<Registers*>(BTIOSEL47_BASE);

    // Bit definitions
    /// BTSEL4567 Register bits
    namespace btsel4567_bits {
        constexpr uint32_t SEL67_ = (4 << 12);  ///< I/O select bits for Ch.6/Ch.7
        constexpr uint32_t SEL45_ = (4 << 8);  ///< I/O select bits for Ch.4/Ch.5
    }

}

// ============================================================================
// BTIOSEL8B Peripheral
// ============================================================================

namespace btiosel8b {
    /// Base addresses
    constexpr uint32_t BTIOSEL8B_BASE = 0x40025500;

    /// BTIOSEL8B Register structure
    struct Registers {
        volatile uint32_t BTSEL89AB;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSEL8B = reinterpret_cast<Registers*>(BTIOSEL8B_BASE);

    // Bit definitions
    /// BTSEL89AB Register bits
    namespace btsel89ab_bits {
        constexpr uint32_t SELAB_ = (4 << 12);  ///< I/O select bits for Ch.A/Ch.B
        constexpr uint32_t SEL89_ = (4 << 8);  ///< I/O select bits for Ch.8/Ch.9
    }

}

// ============================================================================
// BTIOSELCF Peripheral
// ============================================================================

namespace btioselcf {
    /// Base addresses
    constexpr uint32_t BTIOSELCF_BASE = 0x40025700;

    /// BTIOSELCF Register structure
    struct Registers {
        volatile uint32_t BTSELCDEF;  ///< Offset: 0x00 - I/O Select Register
    };

    /// Peripheral instances
    inline Registers* BTIOSELCF = reinterpret_cast<Registers*>(BTIOSELCF_BASE);

    // Bit definitions
    /// BTSELCDEF Register bits
    namespace btselcdef_bits {
        constexpr uint32_t SELEF_ = (4 << 12);  ///< I/O select bits for Ch.E/Ch.F
        constexpr uint32_t SELCD_ = (4 << 8);  ///< I/O select bits for Ch.C/Ch.D
    }

}

// ============================================================================
// SBSSR Peripheral
// ============================================================================

namespace sbssr {
    /// Base addresses
    constexpr uint32_t SBSSR_BASE = 0x40025F00;

    /// SBSSR Register structure
    struct Registers {
        volatile uint32_t BTSSSR;  ///< Offset: 0xFC - Software-based Simultaneous Startup Register
    };

    /// Peripheral instances
    inline Registers* SBSSR = reinterpret_cast<Registers*>(SBSSR_BASE);

    // Bit definitions
    /// BTSSSR Register bits
    namespace btsssr_bits {
        constexpr uint32_t SSSR15 = (1U << 15);  ///< Bit15 of BTSSSR
        constexpr uint32_t SSSR14 = (1U << 14);  ///< Bit14 of BTSSSR
        constexpr uint32_t SSSR13 = (1U << 13);  ///< Bit13 of BTSSSR
        constexpr uint32_t SSSR12 = (1U << 12);  ///< Bit12 of BTSSSR
        constexpr uint32_t SSSR11 = (1U << 11);  ///< Bit11 of BTSSSR
        constexpr uint32_t SSSR10 = (1U << 10);  ///< Bit10 of BTSSSR
        constexpr uint32_t SSSR9 = (1U << 9);  ///< Bit9 of BTSSSR
        constexpr uint32_t SSSR8 = (1U << 8);  ///< Bit8 of BTSSSR
        constexpr uint32_t SSSR7 = (1U << 7);  ///< Bit7 of BTSSSR
        constexpr uint32_t SSSR6 = (1U << 6);  ///< Bit6 of BTSSSR
        constexpr uint32_t SSSR5 = (1U << 5);  ///< Bit5 of BTSSSR
        constexpr uint32_t SSSR4 = (1U << 4);  ///< Bit4 of BTSSSR
        constexpr uint32_t SSSR3 = (1U << 3);  ///< Bit3 of BTSSSR
        constexpr uint32_t SSSR2 = (1U << 2);  ///< Bit2 of BTSSSR
        constexpr uint32_t SSSR1 = (1U << 1);  ///< Bit1 of BTSSSR
        constexpr uint32_t SSSR0 = (1U << 0);  ///< Bit0 of BTSSSR
    }

}

// ============================================================================
// BT0 Peripheral
// ============================================================================

namespace bt0 {
    /// Base addresses
    constexpr uint32_t BT0_BASE = 0x40025000;

    /// BT0 Register structure
    struct Registers {
        volatile uint32_t PWM_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PWM_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PWM_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PWM_PCSR;  ///< Offset: 0x00 - PWM Cycle Set Register
        volatile uint32_t PWM_PDUT;  ///< Offset: 0x04 - PWM Duty Set Register
        volatile uint32_t PWM_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t PPG_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PPG_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PPG_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PPG_PRLL;  ///< Offset: 0x00 - LOW Width Reload Register
        volatile uint32_t PPG_PRLH;  ///< Offset: 0x04 - HIGH Width Reload Register
        volatile uint32_t PPG_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t RT_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t RT_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t RT_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t RT_PCSR;  ///< Offset: 0x00 - PWM Cycle Set Register
        volatile uint32_t RT_TMR;  ///< Offset: 0x08 - Timer Register
        volatile uint32_t PWC_TMCR;  ///< Offset: 0x0C - Timer Control Register
        volatile uint32_t PWC_TMCR2;  ///< Offset: 0x11 - Timer Control Register 2
        volatile uint32_t PWC_STC;  ///< Offset: 0x10 - Status Control Register
        volatile uint32_t PWC_DTBF;  ///< Offset: 0x04 - Data Buffer Register
    };

    /// Peripheral instances
    inline Registers* BT0 = reinterpret_cast<Registers*>(BT0_BASE);

    // Bit definitions
    /// PWM_TMCR Register bits
    namespace pwm_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t RTGEN = (1U << 11);  ///< Restart enable bit
        constexpr uint32_t PMSK = (1U << 10);  ///< Pulse output mask bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Count operation enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// PWM_TMCR2 Register bits
    namespace pwm_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PWM_STC Register bits
    namespace pwm_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t DTIE = (1U << 5);  ///< Duty match interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t DTIR = (1U << 1);  ///< Duty match interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// PPG_TMCR Register bits
    namespace ppg_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t RTGEN = (1U << 11);  ///< Restart enable bit
        constexpr uint32_t PMSK = (1U << 10);  ///< Pulse output mask bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Count operation enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// PPG_TMCR2 Register bits
    namespace ppg_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PPG_STC Register bits
    namespace ppg_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// RT_TMCR Register bits
    namespace rt_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t EGS = (2 << 8);  ///< Trigger input edge selection bits
        constexpr uint32_t T32 = (1U << 7);  ///< 32-bit timer selection bit
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t OSEL = (1U << 3);  ///< Output polarity specification bit
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Timer enable bit
        constexpr uint32_t STRG = (1U << 0);  ///< Software trigger bit
    }

    /// RT_TMCR2 Register bits
    namespace rt_tmcr2_bits {
        constexpr uint32_t GATE = (1U << 7);  ///< Gate Input Enable bit
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// RT_STC Register bits
    namespace rt_stc_bits {
        constexpr uint32_t TGIE = (1U << 6);  ///< Trigger interrupt request enable bit
        constexpr uint32_t UDIE = (1U << 4);  ///< Underflow interrupt request enable bit
        constexpr uint32_t TGIR = (1U << 2);  ///< Trigger interrupt request bit
        constexpr uint32_t UDIR = (1U << 0);  ///< Underflow interrupt request bit
    }

    /// PWC_TMCR Register bits
    namespace pwc_tmcr_bits {
        constexpr uint32_t CKS2_0 = (3 << 12);  ///< Count clock selection bit
        constexpr uint32_t EGS = (3 << 8);  ///< Measurement edge selection bits
        constexpr uint32_t T32 = (1U << 7);  ///< 32-bit timer selection bit
        constexpr uint32_t FMD = (3 << 4);  ///< Timer function selection bits
        constexpr uint32_t MDSE = (1U << 2);  ///< Mode selection bit
        constexpr uint32_t CTEN = (1U << 1);  ///< Timer enable bit
    }

    /// PWC_TMCR2 Register bits
    namespace pwc_tmcr2_bits {
        constexpr uint32_t CKS3 = (1U << 0);  ///< Count clock selection bit
    }

    /// PWC_STC Register bits
    namespace pwc_stc_bits {
        constexpr uint32_t ERR = (1U << 7);  ///< Error flag bit
        constexpr uint32_t EDIE = (1U << 6);  ///< Measurement completion interrupt request enable bit
        constexpr uint32_t OVIE = (1U << 4);  ///< Overflow interrupt request enable bit
        constexpr uint32_t EDIR = (1U << 2);  ///< Measurement completion interrupt request bit
        constexpr uint32_t OVIR = (1U << 0);  ///< Overflow interrupt request bit
    }

}

// ============================================================================
// BT1 Peripheral
// ============================================================================

namespace bt1 {
    /// Base addresses
    constexpr uint32_t BT1_BASE = 0x40025040;

    /// BT1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT1 = reinterpret_cast<Registers*>(BT1_BASE);

}

// ============================================================================
// BT2 Peripheral
// ============================================================================

namespace bt2 {
    /// Base addresses
    constexpr uint32_t BT2_BASE = 0x40025080;

    /// BT2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT2 = reinterpret_cast<Registers*>(BT2_BASE);

}

// ============================================================================
// BT3 Peripheral
// ============================================================================

namespace bt3 {
    /// Base addresses
    constexpr uint32_t BT3_BASE = 0x400250C0;

    /// BT3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT3 = reinterpret_cast<Registers*>(BT3_BASE);

}

// ============================================================================
// BT4 Peripheral
// ============================================================================

namespace bt4 {
    /// Base addresses
    constexpr uint32_t BT4_BASE = 0x40025200;

    /// BT4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT4 = reinterpret_cast<Registers*>(BT4_BASE);

}

// ============================================================================
// BT5 Peripheral
// ============================================================================

namespace bt5 {
    /// Base addresses
    constexpr uint32_t BT5_BASE = 0x40025240;

    /// BT5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT5 = reinterpret_cast<Registers*>(BT5_BASE);

}

// ============================================================================
// BT6 Peripheral
// ============================================================================

namespace bt6 {
    /// Base addresses
    constexpr uint32_t BT6_BASE = 0x40025280;

    /// BT6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT6 = reinterpret_cast<Registers*>(BT6_BASE);

}

// ============================================================================
// BT7 Peripheral
// ============================================================================

namespace bt7 {
    /// Base addresses
    constexpr uint32_t BT7_BASE = 0x400252C0;

    /// BT7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT7 = reinterpret_cast<Registers*>(BT7_BASE);

}

// ============================================================================
// BT8 Peripheral
// ============================================================================

namespace bt8 {
    /// Base addresses
    constexpr uint32_t BT8_BASE = 0x40025400;

    /// BT8 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT8 = reinterpret_cast<Registers*>(BT8_BASE);

}

// ============================================================================
// BT9 Peripheral
// ============================================================================

namespace bt9 {
    /// Base addresses
    constexpr uint32_t BT9_BASE = 0x40025440;

    /// BT9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT9 = reinterpret_cast<Registers*>(BT9_BASE);

}

// ============================================================================
// BT10 Peripheral
// ============================================================================

namespace bt10 {
    /// Base addresses
    constexpr uint32_t BT10_BASE = 0x40025480;

    /// BT10 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT10 = reinterpret_cast<Registers*>(BT10_BASE);

}

// ============================================================================
// BT11 Peripheral
// ============================================================================

namespace bt11 {
    /// Base addresses
    constexpr uint32_t BT11_BASE = 0x400254C0;

    /// BT11 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT11 = reinterpret_cast<Registers*>(BT11_BASE);

}

// ============================================================================
// BT12 Peripheral
// ============================================================================

namespace bt12 {
    /// Base addresses
    constexpr uint32_t BT12_BASE = 0x40025600;

    /// BT12 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT12 = reinterpret_cast<Registers*>(BT12_BASE);

}

// ============================================================================
// BT13 Peripheral
// ============================================================================

namespace bt13 {
    /// Base addresses
    constexpr uint32_t BT13_BASE = 0x40025640;

    /// BT13 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT13 = reinterpret_cast<Registers*>(BT13_BASE);

}

// ============================================================================
// BT14 Peripheral
// ============================================================================

namespace bt14 {
    /// Base addresses
    constexpr uint32_t BT14_BASE = 0x40025680;

    /// BT14 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT14 = reinterpret_cast<Registers*>(BT14_BASE);

}

// ============================================================================
// BT15 Peripheral
// ============================================================================

namespace bt15 {
    /// Base addresses
    constexpr uint32_t BT15_BASE = 0x400256C0;

    /// BT15 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* BT15 = reinterpret_cast<Registers*>(BT15_BASE);

}

// ============================================================================
// QPRC0 Peripheral
// ============================================================================

namespace qprc0 {
    /// Base addresses
    constexpr uint32_t QPRC0_BASE = 0x40026000;
    constexpr uint32_t QPRC0_NF_BASE = 0x40026100;

    /// QPRC0 Register structure
    struct Registers {
        volatile uint32_t QPCR;  ///< Offset: 0x00 - QPRC Position Count Register
        volatile uint32_t QRCR;  ///< Offset: 0x04 - QPRC Revolution Count Register
        volatile uint32_t QPCCR;  ///< Offset: 0x08 - QPRC Position Counter Compare Register
        volatile uint32_t QPRCR;  ///< Offset: 0x0C - QPRC Position and Revolution Counter Compare Register
        volatile uint32_t QMPR;  ///< Offset: 0x10 - QPRC Maximum Position Register
        volatile uint32_t QICRL;  ///< Offset: 0x14 - Low-Order Bytes of QPRC Interrupt Control Register
        volatile uint32_t QICRH;  ///< Offset: 0x15 - High-Order Bytes of QPRC Interrupt Control Register
        volatile uint32_t QCR;  ///< Offset: 0x18 - QPRC Control Register
        volatile uint32_t QECR;  ///< Offset: 0x1C - QPRC Extension Control Register
        volatile uint32_t QPRCRR;  ///< Offset: 0x3C - Quad Counter Position Rotation Count Register
    };

    /// Peripheral instances
    inline Registers* QPRC0 = reinterpret_cast<Registers*>(QPRC0_BASE);
    inline Registers* QPRC0_NF = reinterpret_cast<Registers*>(QPRC0_NF_BASE);

    // Bit definitions
    /// QICRL Register bits
    namespace qicrl_bits {
        constexpr uint32_t ZIIF = (1U << 7);  ///< Zero index interrupt request flag bit
        constexpr uint32_t OFDF = (1U << 6);  ///< Overflow interrupt request flag bit
        constexpr uint32_t UFDF = (1U << 5);  ///< Underflow interrupt request flag bit
        constexpr uint32_t OUZIE = (1U << 4);  ///< "Overflow, underflow, or zero index interrupt enable bit"
        constexpr uint32_t QPRCMF = (1U << 3);  ///< PC and RC match interrupt request flag bit
        constexpr uint32_t QPRCMIE = (1U << 2);  ///< PC and RC match interrupt enable bit
        constexpr uint32_t QPCMF = (1U << 1);  ///< PC match interrupt request flag bit
        constexpr uint32_t QPCMIE = (1U << 0);  ///< PC match interrupt enable bit
    }

    /// QICRH Register bits
    namespace qicrh_bits {
        constexpr uint32_t QPCNRCMF = (1U << 5);  ///< PC match and RC match interrupt request flag bit
        constexpr uint32_t QPCNRCMIE = (1U << 4);  ///< PC match and RC match interrupt enable bit
        constexpr uint32_t DIROU = (1U << 3);  ///< Last position counter flow direction bit
        constexpr uint32_t DIRPC = (1U << 2);  ///< Last position counter direction bit
        constexpr uint32_t CDCF = (1U << 1);  ///< Count inversion interrupt request flag bit
        constexpr uint32_t CDCIE = (1U << 0);  ///< Count inversion interrupt enable bit
    }

    /// QCR Register bits
    namespace qcr_bits {
        constexpr uint32_t CGE = (2 << 14);  ///< Detection edge selection bits
        constexpr uint32_t BES = (2 << 12);  ///< BIN detection edge selection bits
        constexpr uint32_t AES = (2 << 10);  ///< AIN detection edge selection bits
        constexpr uint32_t PCRM = (2 << 8);  ///< Position counter reset mask bits
        constexpr uint32_t SWAP = (1U << 7);  ///< Swap bit
        constexpr uint32_t RSEL = (1U << 6);  ///< Register function selection bit
        constexpr uint32_t CGSC = (1U << 5);  ///< Count clear or gate selection bit
        constexpr uint32_t PSTP = (1U << 4);  ///< Position counter stop bit
        constexpr uint32_t RCM = (2 << 2);  ///< Revolution counter mode bits
        constexpr uint32_t PCM = (2 << 0);  ///< Position counter mode bits
    }

    /// QECR Register bits
    namespace qecr_bits {
        constexpr uint32_t PEC = (1U << 3);  ///< Phase edge change bit
        constexpr uint32_t ORNGIE = (1U << 2);  ///< Outrange interrupt enable bit
        constexpr uint32_t ORNGF = (1U << 1);  ///< Outrange interrupt request flag bit
        constexpr uint32_t ORNGMD = (1U << 0);  ///< Outrange mode selection bit
    }

    /// QPRCRR Register bits
    namespace qprcrr_bits {
        constexpr uint32_t QRCRR = (16 << 16);  ///< Quad counter rotation count display bit
        constexpr uint32_t QPCRR = (16 << 0);  ///< Quad counter position count display bit
    }

}

// ============================================================================
// QPRC1 Peripheral
// ============================================================================

namespace qprc1 {
    /// Base addresses
    constexpr uint32_t QPRC1_BASE = 0x40026040;
    constexpr uint32_t QPRC1_NF_BASE = 0x40026110;

    /// QPRC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* QPRC1 = reinterpret_cast<Registers*>(QPRC1_BASE);
    inline Registers* QPRC1_NF = reinterpret_cast<Registers*>(QPRC1_NF_BASE);

}

// ============================================================================
// QPRC2 Peripheral
// ============================================================================

namespace qprc2 {
    /// Base addresses
    constexpr uint32_t QPRC2_BASE = 0x40026080;
    constexpr uint32_t QPRC2_NF_BASE = 0x40026120;

    /// QPRC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* QPRC2 = reinterpret_cast<Registers*>(QPRC2_BASE);
    inline Registers* QPRC2_NF = reinterpret_cast<Registers*>(QPRC2_NF_BASE);

}

// ============================================================================
// QPRC3 Peripheral
// ============================================================================

namespace qprc3 {
    /// Base addresses
    constexpr uint32_t QPRC3_BASE = 0x400260C0;
    constexpr uint32_t QPRC3_NF_BASE = 0x40026130;

    /// QPRC3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* QPRC3 = reinterpret_cast<Registers*>(QPRC3_BASE);
    inline Registers* QPRC3_NF = reinterpret_cast<Registers*>(QPRC3_NF_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x40027000;
    constexpr uint32_t ADC1_BASE = 0x40027100;
    constexpr uint32_t ADC2_BASE = 0x40027200;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADCR;  ///< Offset: 0x01 - A/D Control Register
        volatile uint32_t ADSR;  ///< Offset: 0x00 - A/D Status Register
        volatile uint32_t SCCR;  ///< Offset: 0x09 - Scan Conversion Control Register
        volatile uint32_t SFNS;  ///< Offset: 0x08 - Scan Conversion FIFO Stage Count Setup Register
        volatile uint32_t SCFD;  ///< Offset: 0x0C - Scan Conversion FIFO Data Register
        volatile uint32_t SCIS3;  ///< Offset: 0x11 - Scan Conversion Input Selection Register 3
        volatile uint32_t SCIS2;  ///< Offset: 0x10 - Scan Conversion Input Selection Register 2
        volatile uint32_t SCIS1;  ///< Offset: 0x15 - Scan Conversion Input Selection Register 1
        volatile uint32_t SCIS0;  ///< Offset: 0x14 - Scan Conversion Input Selection Register 0
        volatile uint32_t PFNS;  ///< Offset: 0x18 - Priority Conversion FIFO Stage Count Setup Register
        volatile uint32_t PCCR;  ///< Offset: 0x19 - Priority Conversion Control Register
        volatile uint32_t PCFD;  ///< Offset: 0x1C - Priority Conversion FIFO Data Register
        volatile uint32_t PCIS;  ///< Offset: 0x20 - Priority Conversion Input Selection Register
        volatile uint32_t CMPCR;  ///< Offset: 0x24 - A/D Comparison Control Register
        volatile uint32_t CMPD;  ///< Offset: 0x26 - A/D Comparison Value Setup Register
        volatile uint32_t ADSS3;  ///< Offset: 0x29 - Sampling Time Selection Register 3
        volatile uint32_t ADSS2;  ///< Offset: 0x28 - Sampling Time Selection Register 2
        volatile uint32_t ADSS1;  ///< Offset: 0x2D - Sampling Time Selection Register 1
        volatile uint32_t ADSS0;  ///< Offset: 0x2C - Sampling Time Selection Register 0
        volatile uint32_t ADST1;  ///< Offset: 0x30 - Sampling Time Setup Register 1
        volatile uint32_t ADST0;  ///< Offset: 0x31 - Sampling Time Setup Register 0
        volatile uint32_t ADCT;  ///< Offset: 0x34 - Frequency Division Ratio Setup Register
        volatile uint32_t PRTSL;  ///< Offset: 0x38 - Priority Conversion Timer Trigger Selection Register
        volatile uint32_t SCTSL;  ///< Offset: 0x39 - Scan Conversion Timer Trigger Selection Register
        volatile uint32_t ADCEN;  ///< Offset: 0x3C - A/D Operation Enable Setup Register
        volatile uint32_t WCMRCOT;  ///< Offset: 0x44 - Range Comparison Threshold Excess Flag Register
        volatile uint32_t WCMRCIF;  ///< Offset: 0x48 - Range Comparison Flag Register
        volatile uint32_t WCMPCR;  ///< Offset: 0x4C - Range Comparison Control Register
        volatile uint32_t WCMPSR;  ///< Offset: 0x4D - Range Comparison Channel Select Register
        volatile uint32_t WCMPDL;  ///< Offset: 0x50 - Lower Limit Threshold Setup Register
        volatile uint32_t WCMPDH;  ///< Offset: 0x52 - Upper Limit Setup Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);

    // Bit definitions
    /// ADCR Register bits
    namespace adcr_bits {
        constexpr uint32_t SCIF = (1U << 7);  ///< Scan conversion interrupt request bit
        constexpr uint32_t PCIF = (1U << 6);  ///< Priority conversion interrupt request bit
        constexpr uint32_t CMPIF = (1U << 5);  ///< Conversion result comparison interrupt request bit
        constexpr uint32_t SCIE = (1U << 3);  ///< Scan conversion interrupt enable bit
        constexpr uint32_t PCIE = (1U << 2);  ///< Priority conversion interrupt enable bit
        constexpr uint32_t CMPIE = (1U << 1);  ///< Conversion result comparison interrupt enable bit
        constexpr uint32_t OVRIE = (1U << 0);  ///< FIFO overrun interrupt enable bit
    }

    /// ADSR Register bits
    namespace adsr_bits {
        constexpr uint32_t ADSTP = (1U << 7);  ///< A/D conversion forced stop bit
        constexpr uint32_t FDAS = (1U << 6);  ///< FIFO data placement selection bit
        constexpr uint32_t PCNS = (1U << 2);  ///< Priority conversion pending flag
        constexpr uint32_t PCS = (1U << 1);  ///< Priority conversion status flag
        constexpr uint32_t SCS = (1U << 0);  ///< Scan conversion status flag
    }

    /// SCCR Register bits
    namespace sccr_bits {
        constexpr uint32_t SEMP = (1U << 7);  ///< Scan conversion FIFO empty bit
        constexpr uint32_t SFUL = (1U << 6);  ///< Scan conversion FIFO full bit
        constexpr uint32_t SOVR = (1U << 5);  ///< Scan conversion overrun flag
        constexpr uint32_t SFCLR = (1U << 4);  ///< Scan conversion FIFO clear bit
        constexpr uint32_t RPT = (1U << 2);  ///< Scan conversion repeat bit
        constexpr uint32_t SHEN = (1U << 1);  ///< Scan conversion timer start enable bit
        constexpr uint32_t SSTR = (1U << 0);  ///< Scan conversion start bit
    }

    /// SFNS Register bits
    namespace sfns_bits {
        constexpr uint32_t SFS = (4 << 0);  ///< Scan conversion FIFO stage count setting bit
    }

    /// SCFD Register bits
    namespace scfd_bits {
        constexpr uint32_t SD = (12 << 20);  ///< Scan conversion result
        constexpr uint32_t INVL = (1U << 12);  ///< A/D conversion result disable bit
        constexpr uint32_t RS = (2 << 8);  ///< Scan conversion start factor
        constexpr uint32_t SC = (5 << 0);  ///< Conversion input channel bits
    }

    /// SCIS3 Register bits
    namespace scis3_bits {
        constexpr uint32_t AN31 = (1U << 7);  ///< Bit7 of SCIS3
        constexpr uint32_t AN30 = (1U << 6);  ///< Bit6 of SCIS3
        constexpr uint32_t AN29 = (1U << 5);  ///< Bit5 of SCIS3
        constexpr uint32_t AN28 = (1U << 4);  ///< Bit4 of SCIS3
        constexpr uint32_t AN27 = (1U << 3);  ///< Bit3 of SCIS3
        constexpr uint32_t AN26 = (1U << 2);  ///< Bit2 of SCIS3
        constexpr uint32_t AN25 = (1U << 1);  ///< Bit1 of SCIS3
        constexpr uint32_t AN24 = (1U << 0);  ///< Bit0 of SCIS3
    }

    /// SCIS2 Register bits
    namespace scis2_bits {
        constexpr uint32_t AN23 = (1U << 7);  ///< Bit7 of SCIS2
        constexpr uint32_t AN22 = (1U << 6);  ///< Bit6 of SCIS2
        constexpr uint32_t AN21 = (1U << 5);  ///< Bit5 of SCIS2
        constexpr uint32_t AN20 = (1U << 4);  ///< Bit4 of SCIS2
        constexpr uint32_t AN19 = (1U << 3);  ///< Bit3 of SCIS2
        constexpr uint32_t AN18 = (1U << 2);  ///< Bit2 of SCIS2
        constexpr uint32_t AN17 = (1U << 1);  ///< Bit1 of SCIS2
        constexpr uint32_t AN16 = (1U << 0);  ///< Bit0 of SCIS2
    }

    /// SCIS1 Register bits
    namespace scis1_bits {
        constexpr uint32_t AN15 = (1U << 7);  ///< Bit7 of SCIS1
        constexpr uint32_t AN14 = (1U << 6);  ///< Bit6 of SCIS1
        constexpr uint32_t AN13 = (1U << 5);  ///< Bit5 of SCIS1
        constexpr uint32_t AN12 = (1U << 4);  ///< Bit4 of SCIS1
        constexpr uint32_t AN11 = (1U << 3);  ///< Bit3 of SCIS1
        constexpr uint32_t AN10 = (1U << 2);  ///< Bit2 of SCIS1
        constexpr uint32_t AN9 = (1U << 1);  ///< Bit1 of SCIS1
        constexpr uint32_t AN8 = (1U << 0);  ///< Bit0 of SCIS1
    }

    /// SCIS0 Register bits
    namespace scis0_bits {
        constexpr uint32_t AN7 = (1U << 7);  ///< Bit7 of SCIS0
        constexpr uint32_t AN6 = (1U << 6);  ///< Bit6 of SCIS0
        constexpr uint32_t AN5 = (1U << 5);  ///< Bit5 of SCIS0
        constexpr uint32_t AN4 = (1U << 4);  ///< Bit4 of SCIS0
        constexpr uint32_t AN3 = (1U << 3);  ///< Bit3 of SCIS0
        constexpr uint32_t AN2 = (1U << 2);  ///< Bit2 of SCIS0
        constexpr uint32_t AN1 = (1U << 1);  ///< Bit1 of SCIS0
        constexpr uint32_t AN0 = (1U << 0);  ///< Bit0 of SCIS0
    }

    /// PFNS Register bits
    namespace pfns_bits {
        constexpr uint32_t TEST = (2 << 4);  ///< Test bits
        constexpr uint32_t PFS = (2 << 0);  ///< Priority conversion FIFO stage count setting bits
    }

    /// PCCR Register bits
    namespace pccr_bits {
        constexpr uint32_t PEMP = (1U << 7);  ///< Priority conversion FIFO empty bit
        constexpr uint32_t PFUL = (1U << 6);  ///< Priority conversion FIFO full bit
        constexpr uint32_t POVR = (1U << 5);  ///< Priority conversion overrun flag
        constexpr uint32_t PFCLR = (1U << 4);  ///< Priority conversion FIFO clear bit
        constexpr uint32_t ESCE = (1U << 3);  ///< External trigger analog input selection bit
        constexpr uint32_t PEEN = (1U << 2);  ///< Priority conversion external start enable bit
        constexpr uint32_t PHEN = (1U << 1);  ///< Priority conversion timer start enable bit
        constexpr uint32_t PSTR = (1U << 0);  ///< Priority conversion start bit
    }

    /// PCFD Register bits
    namespace pcfd_bits {
        constexpr uint32_t PD = (12 << 20);  ///< Priority conversion result
        constexpr uint32_t INVL = (1U << 12);  ///< A/D conversion result disable bit
        constexpr uint32_t RS = (3 << 8);  ///< Scan conversion start factor
        constexpr uint32_t PC = (5 << 0);  ///< Conversion input channel bits
    }

    /// PCIS Register bits
    namespace pcis_bits {
        constexpr uint32_t P2A = (5 << 3);  ///< Priority level 2 analog input selection
        constexpr uint32_t P1A = (3 << 0);  ///< Priority level 1 analog input selection
    }

    /// CMPCR Register bits
    namespace cmpcr_bits {
        constexpr uint32_t CMPEN = (1U << 7);  ///< Conversion result comparison function operation enable bit
        constexpr uint32_t CMD1 = (1U << 6);  ///< Comparison mode 1
        constexpr uint32_t CMD0 = (1U << 5);  ///< Comparison mode 0
        constexpr uint32_t CCH = (5 << 0);  ///< Comparison target analog input channel
    }

    /// CMPD Register bits
    namespace cmpd_bits {
        constexpr uint32_t CMAD = (10 << 6);  ///< A/D conversion result value setting bits
    }

    /// ADSS3 Register bits
    namespace adss3_bits {
        constexpr uint32_t TS31 = (1U << 7);  ///< Bit7 of ADSS3
        constexpr uint32_t TS30 = (1U << 6);  ///< Bit6 of ADSS3
        constexpr uint32_t TS29 = (1U << 5);  ///< Bit5 of ADSS3
        constexpr uint32_t TS28 = (1U << 4);  ///< Bit4 of ADSS3
        constexpr uint32_t TS27 = (1U << 3);  ///< Bit3 of ADSS3
        constexpr uint32_t TS26 = (1U << 2);  ///< Bit2 of ADSS3
        constexpr uint32_t TS25 = (1U << 1);  ///< Bit1 of ADSS3
        constexpr uint32_t TS24 = (1U << 0);  ///< Bit0 of ADSS3
    }

    /// ADSS2 Register bits
    namespace adss2_bits {
        constexpr uint32_t TS23 = (1U << 7);  ///< Bit7 of ADSS2
        constexpr uint32_t TS22 = (1U << 6);  ///< Bit6 of ADSS2
        constexpr uint32_t TS21 = (1U << 5);  ///< Bit5 of ADSS2
        constexpr uint32_t TS20 = (1U << 4);  ///< Bit4 of ADSS2
        constexpr uint32_t TS19 = (1U << 3);  ///< Bit3 of ADSS2
        constexpr uint32_t TS18 = (1U << 2);  ///< Bit2 of ADSS2
        constexpr uint32_t TS17 = (1U << 1);  ///< Bit1 of ADSS2
        constexpr uint32_t TS16 = (1U << 0);  ///< Bit0 of ADSS2
    }

    /// ADSS1 Register bits
    namespace adss1_bits {
        constexpr uint32_t TS15 = (1U << 7);  ///< Bit7 of ADSS1
        constexpr uint32_t TS14 = (1U << 6);  ///< Bit6 of ADSS1
        constexpr uint32_t TS13 = (1U << 5);  ///< Bit5 of ADSS1
        constexpr uint32_t TS12 = (1U << 4);  ///< Bit4 of ADSS1
        constexpr uint32_t TS11 = (1U << 3);  ///< Bit3 of ADSS1
        constexpr uint32_t TS10 = (1U << 2);  ///< Bit2 of ADSS1
        constexpr uint32_t TS9 = (1U << 1);  ///< Bit1 of ADSS1
        constexpr uint32_t TS8 = (1U << 0);  ///< Bit0 of ADSS1
    }

    /// ADSS0 Register bits
    namespace adss0_bits {
        constexpr uint32_t TS7 = (1U << 7);  ///< Bit7 of ADSS0
        constexpr uint32_t TS6 = (1U << 6);  ///< Bit6 of ADSS0
        constexpr uint32_t TS5 = (1U << 5);  ///< Bit5 of ADSS0
        constexpr uint32_t TS4 = (1U << 4);  ///< Bit4 of ADSS0
        constexpr uint32_t TS3 = (1U << 3);  ///< Bit3 of ADSS0
        constexpr uint32_t TS2 = (1U << 2);  ///< Bit2 of ADSS0
        constexpr uint32_t TS1 = (1U << 1);  ///< Bit1 of ADSS0
        constexpr uint32_t TS0 = (1U << 0);  ///< Bit0 of ADSS0
    }

    /// ADST1 Register bits
    namespace adst1_bits {
        constexpr uint32_t STX1 = (3 << 5);  ///< Sampling time N times setting bits
        constexpr uint32_t ST1 = (5 << 0);  ///< Sampling time setting bits
    }

    /// ADST0 Register bits
    namespace adst0_bits {
        constexpr uint32_t STX0 = (3 << 5);  ///< Sampling time N times setting bits
        constexpr uint32_t ST0 = (5 << 0);  ///< Sampling time setting bits
    }

    /// ADCT Register bits
    namespace adct_bits {
        constexpr uint32_t CT = (8 << 0);  ///< Frequency division ratio setting bits
    }

    /// PRTSL Register bits
    namespace prtsl_bits {
        constexpr uint32_t PRTSL = (4 << 0);  ///< Priority conversion timer trigger selection bit
    }

    /// SCTSL Register bits
    namespace sctsl_bits {
        constexpr uint32_t SCTSL = (4 << 0);  ///< Scan conversion timer trigger selection bit
    }

    /// ADCEN Register bits
    namespace adcen_bits {
        constexpr uint32_t ENBLTIME = (8 << 8);  ///< Operation enable state transition cycle selection bits
        constexpr uint32_t READY = (1U << 1);  ///< A/D operation enable state bit
        constexpr uint32_t ENBL = (1U << 0);  ///< A/D operation enable bit
    }

    /// WCMRCOT Register bits
    namespace wcmrcot_bits {
        constexpr uint32_t RCOOF = (1U << 0);  ///< Threshold excess flag bit
    }

    /// WCMRCIF Register bits
    namespace wcmrcif_bits {
        constexpr uint32_t RCINT = (1U << 0);  ///< Range comparison interrupt factor flag
    }

    /// WCMPCR Register bits
    namespace wcmpcr_bits {
        constexpr uint32_t RCOCD = (3 << 5);  ///< Continuous detection specification count/state indication bits
        constexpr uint32_t RCOIRS = (1U << 4);  ///< Selection bit of within-range and out-of- range confirmation
        constexpr uint32_t RCOIE = (1U << 3);  ///< Range comparison interrupt request enable bit
        constexpr uint32_t RCOE = (1U << 2);  ///< Range comparison execution enable bit
    }

    /// WCMPSR Register bits
    namespace wcmpsr_bits {
        constexpr uint32_t WCMD = (1U << 5);  ///< Comparison mode select bit
        constexpr uint32_t WCCH = (5 << 0);  ///< Comparison target analog input channel
    }

    /// WCMPDL Register bits
    namespace wcmpdl_bits {
        constexpr uint32_t CMLD = (10 << 6);  ///< Lower limit threshold bits
    }

    /// WCMPDH Register bits
    namespace wcmpdh_bits {
        constexpr uint32_t CMHD = (10 << 6);  ///< Upper limit threshold bits
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x40033000;
    constexpr uint32_t DAC1_BASE = 0x40033008;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DACR;  ///< Offset: 0x00 - D/A Control Register
        volatile uint32_t DADR;  ///< Offset: 0x04 - D/A Data Register
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);

    // Bit definitions
    /// DACR Register bits
    namespace dacr_bits {
        constexpr uint32_t DDAS = (1U << 5);  ///< 10-bit mode data allocation selection bit
        constexpr uint32_t DAC10 = (1U << 4);  ///< 10-bit mode
        constexpr uint32_t DRDY = (1U << 1);  ///< D/A converter operation enable state bit
        constexpr uint32_t DAE = (1U << 0);  ///< D/A converter operating enable bit
    }

    /// DADR Register bits
    namespace dadr_bits {
        constexpr uint32_t DA = (12 << 0);  ///< D/A Data Register
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40030000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t ENIR;  ///< Offset: 0x00 - Enable Interrupt Request Register
        volatile uint32_t EIRR;  ///< Offset: 0x04 - External Interrupt Request Register
        volatile uint32_t EICL;  ///< Offset: 0x08 - External Interrupt Clear Register
        volatile uint32_t ELVR;  ///< Offset: 0x0C - External Interrupt Level Register
        volatile uint32_t ELVR1;  ///< Offset: 0x10 - External Interrupt Level Register 1
        volatile uint32_t NMIRR;  ///< Offset: 0x14 - Non Maskable Interrupt Request Register
        volatile uint32_t NMICL;  ///< Offset: 0x18 - Non Maskable Interrupt Clear Register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// ENIR Register bits
    namespace enir_bits {
        constexpr uint32_t EN31 = (1U << 31);  ///< Bit31 of ENIR
        constexpr uint32_t EN30 = (1U << 30);  ///< Bit30 of ENIR
        constexpr uint32_t EN29 = (1U << 29);  ///< Bit29 of ENIR
        constexpr uint32_t EN28 = (1U << 28);  ///< Bit28 of ENIR
        constexpr uint32_t EN27 = (1U << 27);  ///< Bit27 of ENIR
        constexpr uint32_t EN26 = (1U << 26);  ///< Bit26 of ENIR
        constexpr uint32_t EN25 = (1U << 25);  ///< Bit25 of ENIR
        constexpr uint32_t EN24 = (1U << 24);  ///< Bit24 of ENIR
        constexpr uint32_t EN23 = (1U << 23);  ///< Bit23 of ENIR
        constexpr uint32_t EN22 = (1U << 22);  ///< Bit22 of ENIR
        constexpr uint32_t EN21 = (1U << 21);  ///< Bit21 of ENIR
        constexpr uint32_t EN20 = (1U << 20);  ///< Bit20 of ENIR
        constexpr uint32_t EN19 = (1U << 19);  ///< Bit19 of ENIR
        constexpr uint32_t EN18 = (1U << 18);  ///< Bit18 of ENIR
        constexpr uint32_t EN17 = (1U << 17);  ///< Bit17 of ENIR
        constexpr uint32_t EN16 = (1U << 16);  ///< Bit16 of ENIR
        constexpr uint32_t EN15 = (1U << 15);  ///< Bit15 of ENIR
        constexpr uint32_t EN14 = (1U << 14);  ///< Bit14 of ENIR
        constexpr uint32_t EN13 = (1U << 13);  ///< Bit13 of ENIR
        constexpr uint32_t EN12 = (1U << 12);  ///< Bit12 of ENIR
        constexpr uint32_t EN11 = (1U << 11);  ///< Bit11 of ENIR
        constexpr uint32_t EN10 = (1U << 10);  ///< Bit10 of ENIR
        constexpr uint32_t EN9 = (1U << 9);  ///< Bit9 of ENIR
        constexpr uint32_t EN8 = (1U << 8);  ///< Bit8 of ENIR
        constexpr uint32_t EN7 = (1U << 7);  ///< Bit7 of ENIR
        constexpr uint32_t EN6 = (1U << 6);  ///< Bit6 of ENIR
        constexpr uint32_t EN5 = (1U << 5);  ///< Bit5 of ENIR
        constexpr uint32_t EN4 = (1U << 4);  ///< Bit4 of ENIR
        constexpr uint32_t EN3 = (1U << 3);  ///< Bit3 of ENIR
        constexpr uint32_t EN2 = (1U << 2);  ///< Bit2 of ENIR
        constexpr uint32_t EN1 = (1U << 1);  ///< Bit1 of ENIR
        constexpr uint32_t EN0 = (1U << 0);  ///< Bit0 of ENIR
    }

    /// EIRR Register bits
    namespace eirr_bits {
        constexpr uint32_t ER31 = (1U << 31);  ///< Bit31 of EIRR
        constexpr uint32_t ER30 = (1U << 30);  ///< Bit30 of EIRR
        constexpr uint32_t ER29 = (1U << 29);  ///< Bit29 of EIRR
        constexpr uint32_t ER28 = (1U << 28);  ///< Bit28 of EIRR
        constexpr uint32_t ER27 = (1U << 27);  ///< Bit27 of EIRR
        constexpr uint32_t ER26 = (1U << 26);  ///< Bit26 of EIRR
        constexpr uint32_t ER25 = (1U << 25);  ///< Bit25 of EIRR
        constexpr uint32_t ER24 = (1U << 24);  ///< Bit24 of EIRR
        constexpr uint32_t ER23 = (1U << 23);  ///< Bit23 of EIRR
        constexpr uint32_t ER22 = (1U << 22);  ///< Bit22 of EIRR
        constexpr uint32_t ER21 = (1U << 21);  ///< Bit21 of EIRR
        constexpr uint32_t ER20 = (1U << 20);  ///< Bit20 of EIRR
        constexpr uint32_t ER19 = (1U << 19);  ///< Bit19 of EIRR
        constexpr uint32_t ER18 = (1U << 18);  ///< Bit18 of EIRR
        constexpr uint32_t ER17 = (1U << 17);  ///< Bit17 of EIRR
        constexpr uint32_t ER16 = (1U << 16);  ///< Bit16 of EIRR
        constexpr uint32_t ER15 = (1U << 15);  ///< Bit15 of EIRR
        constexpr uint32_t ER14 = (1U << 14);  ///< Bit14 of EIRR
        constexpr uint32_t ER13 = (1U << 13);  ///< Bit13 of EIRR
        constexpr uint32_t ER12 = (1U << 12);  ///< Bit12 of EIRR
        constexpr uint32_t ER11 = (1U << 11);  ///< Bit11 of EIRR
        constexpr uint32_t ER10 = (1U << 10);  ///< Bit10 of EIRR
        constexpr uint32_t ER9 = (1U << 9);  ///< Bit9 of EIRR
        constexpr uint32_t ER8 = (1U << 8);  ///< Bit8 of EIRR
        constexpr uint32_t ER7 = (1U << 7);  ///< Bit7 of EIRR
        constexpr uint32_t ER6 = (1U << 6);  ///< Bit6 of EIRR
        constexpr uint32_t ER5 = (1U << 5);  ///< Bit5 of EIRR
        constexpr uint32_t ER4 = (1U << 4);  ///< Bit4 of EIRR
        constexpr uint32_t ER3 = (1U << 3);  ///< Bit3 of EIRR
        constexpr uint32_t ER2 = (1U << 2);  ///< Bit2 of EIRR
        constexpr uint32_t ER1 = (1U << 1);  ///< Bit1 of EIRR
        constexpr uint32_t ER0 = (1U << 0);  ///< Bit0 of EIRR
    }

    /// EICL Register bits
    namespace eicl_bits {
        constexpr uint32_t ECL31 = (1U << 31);  ///< Bit31 of EICL
        constexpr uint32_t ECL30 = (1U << 30);  ///< Bit30 of EICL
        constexpr uint32_t ECL29 = (1U << 29);  ///< Bit29 of EICL
        constexpr uint32_t ECL28 = (1U << 28);  ///< Bit28 of EICL
        constexpr uint32_t ECL27 = (1U << 27);  ///< Bit27 of EICL
        constexpr uint32_t ECL26 = (1U << 26);  ///< Bit26 of EICL
        constexpr uint32_t ECL25 = (1U << 25);  ///< Bit25 of EICL
        constexpr uint32_t ECL24 = (1U << 24);  ///< Bit24 of EICL
        constexpr uint32_t ECL23 = (1U << 23);  ///< Bit23 of EICL
        constexpr uint32_t ECL22 = (1U << 22);  ///< Bit22 of EICL
        constexpr uint32_t ECL21 = (1U << 21);  ///< Bit21 of EICL
        constexpr uint32_t ECL20 = (1U << 20);  ///< Bit20 of EICL
        constexpr uint32_t ECL19 = (1U << 19);  ///< Bit19 of EICL
        constexpr uint32_t ECL18 = (1U << 18);  ///< Bit18 of EICL
        constexpr uint32_t ECL17 = (1U << 17);  ///< Bit17 of EICL
        constexpr uint32_t ECL16 = (1U << 16);  ///< Bit16 of EICL
        constexpr uint32_t ECL15 = (1U << 15);  ///< Bit15 of EICL
        constexpr uint32_t ECL14 = (1U << 14);  ///< Bit14 of EICL
        constexpr uint32_t ECL13 = (1U << 13);  ///< Bit13 of EICL
        constexpr uint32_t ECL12 = (1U << 12);  ///< Bit12 of EICL
        constexpr uint32_t ECL11 = (1U << 11);  ///< Bit11 of EICL
        constexpr uint32_t ECL10 = (1U << 10);  ///< Bit10 of EICL
        constexpr uint32_t ECL9 = (1U << 9);  ///< Bit9 of EICL
        constexpr uint32_t ECL8 = (1U << 8);  ///< Bit8 of EICL
        constexpr uint32_t ECL7 = (1U << 7);  ///< Bit7 of EICL
        constexpr uint32_t ECL6 = (1U << 6);  ///< Bit6 of EICL
        constexpr uint32_t ECL5 = (1U << 5);  ///< Bit5 of EICL
        constexpr uint32_t ECL4 = (1U << 4);  ///< Bit4 of EICL
        constexpr uint32_t ECL3 = (1U << 3);  ///< Bit3 of EICL
        constexpr uint32_t ECL2 = (1U << 2);  ///< Bit2 of EICL
        constexpr uint32_t ECL1 = (1U << 1);  ///< Bit1 of EICL
        constexpr uint32_t ECL0 = (1U << 0);  ///< Bit0 of EICL
    }

    /// ELVR Register bits
    namespace elvr_bits {
        constexpr uint32_t LB15 = (1U << 31);  ///< Bit31 of ELVR
        constexpr uint32_t LA15 = (1U << 30);  ///< Bit30 of ELVR
        constexpr uint32_t LB14 = (1U << 29);  ///< Bit29 of ELVR
        constexpr uint32_t LA14 = (1U << 28);  ///< Bit28 of ELVR
        constexpr uint32_t LB13 = (1U << 27);  ///< Bit27 of ELVR
        constexpr uint32_t LA13 = (1U << 26);  ///< Bit26 of ELVR
        constexpr uint32_t LB12 = (1U << 25);  ///< Bit25 of ELVR
        constexpr uint32_t LA12 = (1U << 24);  ///< Bit24 of ELVR
        constexpr uint32_t LB11 = (1U << 23);  ///< Bit23 of ELVR
        constexpr uint32_t LA11 = (1U << 22);  ///< Bit22 of ELVR
        constexpr uint32_t LB10 = (1U << 21);  ///< Bit21 of ELVR
        constexpr uint32_t LA10 = (1U << 20);  ///< Bit20 of ELVR
        constexpr uint32_t LB9 = (1U << 19);  ///< Bit19 of ELVR
        constexpr uint32_t LA9 = (1U << 18);  ///< Bit18 of ELVR
        constexpr uint32_t LB8 = (1U << 17);  ///< Bit17 of ELVR
        constexpr uint32_t LA8 = (1U << 16);  ///< Bit16 of ELVR
        constexpr uint32_t LB7 = (1U << 15);  ///< Bit15 of ELVR
        constexpr uint32_t LA7 = (1U << 14);  ///< Bit14 of ELVR
        constexpr uint32_t LB6 = (1U << 13);  ///< Bit13 of ELVR
        constexpr uint32_t LA6 = (1U << 12);  ///< Bit12 of ELVR
        constexpr uint32_t LB5 = (1U << 11);  ///< Bit11 of ELVR
        constexpr uint32_t LA5 = (1U << 10);  ///< Bit10 of ELVR
        constexpr uint32_t LB4 = (1U << 9);  ///< Bit9 of ELVR
        constexpr uint32_t LA4 = (1U << 8);  ///< Bit8 of ELVR
        constexpr uint32_t LB3 = (1U << 7);  ///< Bit7 of ELVR
        constexpr uint32_t LA3 = (1U << 6);  ///< Bit6 of ELVR
        constexpr uint32_t LB2 = (1U << 5);  ///< Bit5 of ELVR
        constexpr uint32_t LA2 = (1U << 4);  ///< Bit4 of ELVR
        constexpr uint32_t LB1 = (1U << 3);  ///< Bit3 of ELVR
        constexpr uint32_t LA1 = (1U << 2);  ///< Bit2 of ELVR
        constexpr uint32_t LB0 = (1U << 1);  ///< Bit1 of ELVR
        constexpr uint32_t LA0 = (1U << 0);  ///< Bit0 of ELVR
    }

    /// ELVR1 Register bits
    namespace elvr1_bits {
        constexpr uint32_t LB31 = (1U << 31);  ///< Bit31 of ELVR1
        constexpr uint32_t LA31 = (1U << 30);  ///< Bit30 of ELVR1
        constexpr uint32_t LB30 = (1U << 29);  ///< Bit29 of ELVR1
        constexpr uint32_t LA30 = (1U << 28);  ///< Bit28 of ELVR1
        constexpr uint32_t LB29 = (1U << 27);  ///< Bit27 of ELVR1
        constexpr uint32_t LA29 = (1U << 26);  ///< Bit26 of ELVR1
        constexpr uint32_t LB28 = (1U << 25);  ///< Bit25 of ELVR1
        constexpr uint32_t LA28 = (1U << 24);  ///< Bit24 of ELVR1
        constexpr uint32_t LB27 = (1U << 23);  ///< Bit23 of ELVR1
        constexpr uint32_t LA27 = (1U << 22);  ///< Bit22 of ELVR1
        constexpr uint32_t LB26 = (1U << 21);  ///< Bit21 of ELVR1
        constexpr uint32_t LA26 = (1U << 20);  ///< Bit20 of ELVR1
        constexpr uint32_t LB25 = (1U << 19);  ///< Bit19 of ELVR1
        constexpr uint32_t LA25 = (1U << 18);  ///< Bit18 of ELVR1
        constexpr uint32_t LB24 = (1U << 17);  ///< Bit17 of ELVR1
        constexpr uint32_t LA24 = (1U << 16);  ///< Bit16 of ELVR1
        constexpr uint32_t LB23 = (1U << 15);  ///< Bit15 of ELVR1
        constexpr uint32_t LA23 = (1U << 14);  ///< Bit14 of ELVR1
        constexpr uint32_t LB22 = (1U << 13);  ///< Bit13 of ELVR1
        constexpr uint32_t LA22 = (1U << 12);  ///< Bit12 of ELVR1
        constexpr uint32_t LB21 = (1U << 11);  ///< Bit11 of ELVR1
        constexpr uint32_t LA21 = (1U << 10);  ///< Bit10 of ELVR1
        constexpr uint32_t LB20 = (1U << 9);  ///< Bit9 of ELVR1
        constexpr uint32_t LA20 = (1U << 8);  ///< Bit8 of ELVR1
        constexpr uint32_t LB19 = (1U << 7);  ///< Bit7 of ELVR1
        constexpr uint32_t LA19 = (1U << 6);  ///< Bit6 of ELVR1
        constexpr uint32_t LB18 = (1U << 5);  ///< Bit5 of ELVR1
        constexpr uint32_t LA18 = (1U << 4);  ///< Bit4 of ELVR1
        constexpr uint32_t LB17 = (1U << 3);  ///< Bit3 of ELVR1
        constexpr uint32_t LA17 = (1U << 2);  ///< Bit2 of ELVR1
        constexpr uint32_t LB16 = (1U << 1);  ///< Bit1 of ELVR1
        constexpr uint32_t LA16 = (1U << 0);  ///< Bit0 of ELVR1
    }

    /// NMIRR Register bits
    namespace nmirr_bits {
        constexpr uint32_t NR = (1U << 0);  ///< NMI interrupt request detection bit
    }

    /// NMICL Register bits
    namespace nmicl_bits {
        constexpr uint32_t NCL = (1U << 0);  ///< NMI interrupt cause clear bit
    }

}

// ============================================================================
// INTREQ Peripheral
// ============================================================================

namespace intreq {
    /// Base addresses
    constexpr uint32_t INTREQ_BASE = 0x40031000;

    /// INTREQ Register structure
    struct Registers {
        volatile uint32_t DRQSEL;  ///< Offset: 0x00 - DMA Request Selection Register
        volatile uint32_t ODDPKS;  ///< Offset: 0x10 - USB ch.0 Odd Packet Size DMA Enable Register
        volatile uint32_t ODDPKS1;  ///< Offset: 0x14 - USB ch.1 Odd Packet Size DMA Enable Register
        volatile uint32_t IRQ003SEL;  ///< Offset: 0x110 - Relocate Interrupt Selection Register (IRQ003)
        volatile uint32_t IRQ004SEL;  ///< Offset: 0x114 - Relocate Interrupt Selection Register (IRQ004)
        volatile uint32_t IRQ005SEL;  ///< Offset: 0x118 - Relocate Interrupt Selection Register (IRQ005)
        volatile uint32_t IRQ006SEL;  ///< Offset: 0x11C - Relocate Interrupt Selection Register (IRQ006)
        volatile uint32_t IRQ007SEL;  ///< Offset: 0x120 - Relocate Interrupt Selection Register (IRQ007)
        volatile uint32_t IRQ008SEL;  ///< Offset: 0x124 - Relocate Interrupt Selection Register (IRQ008)
        volatile uint32_t IRQ009SEL;  ///< Offset: 0x128 - Relocate Interrupt Selection Register (IRQ009)
        volatile uint32_t IRQ010SEL;  ///< Offset: 0x12C - Relocate Interrupt Selection Register (IRQ010)
        volatile uint32_t EXC02MON;  ///< Offset: 0x200 - EXC02 batch read register
        volatile uint32_t IRQ000MON;  ///< Offset: 0x204 - IRQ000 Batch Read Register
        volatile uint32_t IRQ001MON;  ///< Offset: 0x208 - IRQ001 Batch Read Register
        volatile uint32_t IRQ002MON;  ///< Offset: 0x20C - IRQ002 Batch Read Register
        volatile uint32_t IRQ003MON;  ///< Offset: 0x210 - IRQ003 Batch Read Register
        volatile uint32_t IRQ004MON;  ///< Offset: 0x214 - IRQ004 Batch Read Register
        volatile uint32_t IRQ005MON;  ///< Offset: 0x218 - IRQ005 Batch Read Register
        volatile uint32_t IRQ006MON;  ///< Offset: 0x21C - IRQ006 Batch Read Register
        volatile uint32_t IRQ007MON;  ///< Offset: 0x220 - IRQ007 Batch Read Register
        volatile uint32_t IRQ008MON;  ///< Offset: 0x224 - IRQ008 Batch Read Register
        volatile uint32_t IRQ009MON;  ///< Offset: 0x228 - IRQ009 Batch Read Register
        volatile uint32_t IRQ010MON;  ///< Offset: 0x22C - IRQ010 Batch Read Register
        volatile uint32_t IRQ011MON;  ///< Offset: 0x230 - IRQ011 Batch Read Register
        volatile uint32_t IRQ012MON;  ///< Offset: 0x234 - IRQ012 Batch Read Register
        volatile uint32_t IRQ013MON;  ///< Offset: 0x238 - IRQ013 Batch Read Register
        volatile uint32_t IRQ014MON;  ///< Offset: 0x23C - IRQ014 Batch Read Register
        volatile uint32_t IRQ015MON;  ///< Offset: 0x240 - IRQ015 Batch Read Register
        volatile uint32_t IRQ016MON;  ///< Offset: 0x244 - IRQ016 Batch Read Register
        volatile uint32_t IRQ017MON;  ///< Offset: 0x248 - IRQ017 Batch Read Register
        volatile uint32_t IRQ018MON;  ///< Offset: 0x24C - IRQ018 Batch Read Register
        volatile uint32_t IRQ019MON;  ///< Offset: 0x250 - IRQ019 Batch Read Register
        volatile uint32_t IRQ020MON;  ///< Offset: 0x254 - IRQ020 Batch Read Register
        volatile uint32_t IRQ021MON;  ///< Offset: 0x258 - IRQ021 Batch Read Register
        volatile uint32_t IRQ022MON;  ///< Offset: 0x25C - IRQ022 Batch Read Register
        volatile uint32_t IRQ023MON;  ///< Offset: 0x260 - IRQ023 Batch Read Register
        volatile uint32_t IRQ024MON;  ///< Offset: 0x264 - IRQ024 Batch Read Register
        volatile uint32_t IRQ025MON;  ///< Offset: 0x268 - IRQ025 Batch Read Register
        volatile uint32_t IRQ026MON;  ///< Offset: 0x26C - IRQ026 Batch Read Register
        volatile uint32_t IRQ027MON;  ///< Offset: 0x270 - IRQ027 Batch Read Register
        volatile uint32_t IRQ028MON;  ///< Offset: 0x274 - IRQ028 Batch Read Register
        volatile uint32_t IRQ029MON;  ///< Offset: 0x278 - IRQ029 Batch Read Register
        volatile uint32_t IRQ030MON;  ///< Offset: 0x27C - IRQ030 Batch Read Register
        volatile uint32_t IRQ031MON;  ///< Offset: 0x280 - IRQ031 Batch Read Register
        volatile uint32_t IRQ032MON;  ///< Offset: 0x284 - IRQ032 Batch Read Register
        volatile uint32_t IRQ033MON;  ///< Offset: 0x288 - IRQ033 Batch Read Register
        volatile uint32_t IRQ034MON;  ///< Offset: 0x28C - IRQ034 Batch Read Register
        volatile uint32_t IRQ035MON;  ///< Offset: 0x290 - IRQ035 Batch Read Register
        volatile uint32_t IRQ036MON;  ///< Offset: 0x294 - IRQ036 Batch Read Register
        volatile uint32_t IRQ037MON;  ///< Offset: 0x298 - IRQ037 Batch Read Register
        volatile uint32_t IRQ038MON;  ///< Offset: 0x29C - IRQ038 Batch Read Register
        volatile uint32_t IRQ039MON;  ///< Offset: 0x2A0 - IRQ039 Batch Read Register
        volatile uint32_t IRQ040MON;  ///< Offset: 0x2A4 - IRQ040 Batch Read Register
        volatile uint32_t IRQ041MON;  ///< Offset: 0x2A8 - IRQ041 Batch Read Register
        volatile uint32_t IRQ042MON;  ///< Offset: 0x2AC - IRQ042 Batch Read Register
        volatile uint32_t IRQ043MON;  ///< Offset: 0x2B0 - IRQ043 Batch Read Register
        volatile uint32_t IRQ044MON;  ///< Offset: 0x2B4 - IRQ044 Batch Read Register
        volatile uint32_t IRQ045MON;  ///< Offset: 0x2B8 - IRQ045 Batch Read Register
        volatile uint32_t IRQ046MON;  ///< Offset: 0x2BC - IRQ046 Batch Read Register
        volatile uint32_t IRQ047MON;  ///< Offset: 0x2C0 - IRQ047 Batch Read Register
        volatile uint32_t IRQ048MON;  ///< Offset: 0x2C4 - IRQ048 Batch Read Register
        volatile uint32_t IRQ049MON;  ///< Offset: 0x2C8 - IRQ049 Batch Read Register
        volatile uint32_t IRQ050MON;  ///< Offset: 0x2CC - IRQ050 Batch Read Register
        volatile uint32_t IRQ051MON;  ///< Offset: 0x2D0 - IRQ051 Batch Read Register
        volatile uint32_t IRQ052MON;  ///< Offset: 0x2D4 - IRQ052 Batch Read Register
        volatile uint32_t IRQ053MON;  ///< Offset: 0x2D8 - IRQ053 Batch Read Register
        volatile uint32_t IRQ054MON;  ///< Offset: 0x2DC - IRQ054 Batch Read Register
        volatile uint32_t IRQ055MON;  ///< Offset: 0x2E0 - IRQ055 Batch Read Register
        volatile uint32_t IRQ056MON;  ///< Offset: 0x2E4 - IRQ056 Batch Read Register
        volatile uint32_t IRQ057MON;  ///< Offset: 0x2E8 - IRQ057 Batch Read Register
        volatile uint32_t IRQ058MON;  ///< Offset: 0x2EC - IRQ058 Batch Read Register
        volatile uint32_t IRQ059MON;  ///< Offset: 0x2F0 - IRQ059 Batch Read Register
        volatile uint32_t IRQ060MON;  ///< Offset: 0x2F4 - IRQ060 Batch Read Register
        volatile uint32_t IRQ061MON;  ///< Offset: 0x2F8 - IRQ061 Batch Read Register
        volatile uint32_t IRQ062MON;  ///< Offset: 0x2FC - IRQ062 Batch Read Register
        volatile uint32_t IRQ063MON;  ///< Offset: 0x300 - IRQ063 Batch Read Register
        volatile uint32_t IRQ064MON;  ///< Offset: 0x304 - IRQ064 Batch Read Register
        volatile uint32_t IRQ065MON;  ///< Offset: 0x308 - IRQ065 Batch Read Register
        volatile uint32_t IRQ066MON;  ///< Offset: 0x30C - IRQ066 Batch Read Register
        volatile uint32_t IRQ067MON;  ///< Offset: 0x310 - IRQ067 Batch Read Register
        volatile uint32_t IRQ068MON;  ///< Offset: 0x314 - IRQ068 Batch Read Register
        volatile uint32_t IRQ069MON;  ///< Offset: 0x318 - IRQ069 Batch Read Register
        volatile uint32_t IRQ070MON;  ///< Offset: 0x31C - IRQ070 Batch Read Register
        volatile uint32_t IRQ071MON;  ///< Offset: 0x320 - IRQ071 Batch Read Register
        volatile uint32_t IRQ072MON;  ///< Offset: 0x324 - IRQ072 Batch Read Register
        volatile uint32_t IRQ073MON;  ///< Offset: 0x328 - IRQ073 Batch Read Register
        volatile uint32_t IRQ074MON;  ///< Offset: 0x32C - IRQ074 Batch Read Register
        volatile uint32_t IRQ075MON;  ///< Offset: 0x330 - IRQ075 Batch Read Register
        volatile uint32_t IRQ076MON;  ///< Offset: 0x334 - IRQ076 Batch Read Register
        volatile uint32_t IRQ077MON;  ///< Offset: 0x338 - IRQ077 Batch Read Register
        volatile uint32_t IRQ078MON;  ///< Offset: 0x33C - IRQ078 Batch Read Register
        volatile uint32_t IRQ079MON;  ///< Offset: 0x340 - IRQ079 Batch Read Register
        volatile uint32_t IRQ080MON;  ///< Offset: 0x344 - IRQ080 Batch Read Register
        volatile uint32_t IRQ081MON;  ///< Offset: 0x348 - IRQ081 Batch Read Register
        volatile uint32_t IRQ082MON;  ///< Offset: 0x34C - IRQ082 Batch Read Register
        volatile uint32_t IRQ083MON;  ///< Offset: 0x350 - IRQ083 Batch Read Register
        volatile uint32_t IRQ084MON;  ///< Offset: 0x354 - IRQ084 Batch Read Register
        volatile uint32_t IRQ085MON;  ///< Offset: 0x358 - IRQ085 Batch Read Register
        volatile uint32_t IRQ086MON;  ///< Offset: 0x35C - IRQ086 Batch Read Register
        volatile uint32_t IRQ087MON;  ///< Offset: 0x360 - IRQ087 Batch Read Register
        volatile uint32_t IRQ088MON;  ///< Offset: 0x364 - IRQ088 Batch Read Register
        volatile uint32_t IRQ089MON;  ///< Offset: 0x368 - IRQ089 Batch Read Register
        volatile uint32_t IRQ090MON;  ///< Offset: 0x36C - IRQ090 Batch Read Register
        volatile uint32_t IRQ091MON;  ///< Offset: 0x370 - IRQ091 Batch Read Register
        volatile uint32_t IRQ092MON;  ///< Offset: 0x374 - IRQ092 Batch Read Register
        volatile uint32_t IRQ093MON;  ///< Offset: 0x378 - IRQ093 Batch Read Register
        volatile uint32_t IRQ094MON;  ///< Offset: 0x37C - IRQ094 Batch Read Register
        volatile uint32_t IRQ095MON;  ///< Offset: 0x380 - IRQ095 Batch Read Register
        volatile uint32_t IRQ096MON;  ///< Offset: 0x384 - IRQ096 Batch Read Register
        volatile uint32_t IRQ097MON;  ///< Offset: 0x388 - IRQ097 Batch Read Register
        volatile uint32_t IRQ098MON;  ///< Offset: 0x38C - IRQ098 Batch Read Register
        volatile uint32_t IRQ099MON;  ///< Offset: 0x390 - IRQ099 Batch Read Register
        volatile uint32_t IRQ100MON;  ///< Offset: 0x394 - IRQ100 Batch Read Register
        volatile uint32_t IRQ101MON;  ///< Offset: 0x398 - IRQ101 Batch Read Register
        volatile uint32_t IRQ102MON;  ///< Offset: 0x39C - IRQ102 Batch Read Register
        volatile uint32_t IRQ103MON;  ///< Offset: 0x3A0 - IRQ103 Batch Read Register
        volatile uint32_t IRQ104MON;  ///< Offset: 0x3A4 - IRQ104 Batch Read Register
        volatile uint32_t IRQ105MON;  ///< Offset: 0x3A8 - IRQ105 Batch Read Register
        volatile uint32_t IRQ106MON;  ///< Offset: 0x3AC - IRQ106 Batch Read Register
        volatile uint32_t IRQ107MON;  ///< Offset: 0x3B0 - IRQ107 Batch Read Register
        volatile uint32_t IRQ108MON;  ///< Offset: 0x3B4 - IRQ108 Batch Read Register
        volatile uint32_t IRQ109MON;  ///< Offset: 0x3B8 - IRQ109 Batch Read Register
        volatile uint32_t IRQ110MON;  ///< Offset: 0x3BC - IRQ110 Batch Read Register
        volatile uint32_t IRQ111MON;  ///< Offset: 0x3C0 - IRQ111 Batch Read Register
        volatile uint32_t IRQ112MON;  ///< Offset: 0x3C4 - IRQ112 Batch Read Register
        volatile uint32_t IRQ113MON;  ///< Offset: 0x3C8 - IRQ113 Batch Read Register
        volatile uint32_t IRQ114MON;  ///< Offset: 0x3CC - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ115MON;  ///< Offset: 0x3D0 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ116MON;  ///< Offset: 0x3D4 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ117MON;  ///< Offset: 0x3D8 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ118MON;  ///< Offset: 0x3DC - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ119MON;  ///< Offset: 0x3E0 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ120MON;  ///< Offset: 0x3E4 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ121MON;  ///< Offset: 0x3E8 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ122MON;  ///< Offset: 0x3EC - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ123MON;  ///< Offset: 0x3F0 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ124MON;  ///< Offset: 0x3F4 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ125MON;  ///< Offset: 0x3F8 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ126MON;  ///< Offset: 0x3FC - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t IRQ127MON;  ///< Offset: 0x400 - ERROR!!!!!!!!!!!!!!!!!!!!
    };

    /// Peripheral instances
    inline Registers* INTREQ = reinterpret_cast<Registers*>(INTREQ_BASE);

    // Bit definitions
    /// DRQSEL Register bits
    namespace drqsel_bits {
        constexpr uint32_t EXINT3 = (1U << 31);  ///< External pin interrupt ch.3
        constexpr uint32_t EXINT2 = (1U << 30);  ///< External pin interrupt ch.2
        constexpr uint32_t EXINT1 = (1U << 29);  ///< External pin interrupt ch.1
        constexpr uint32_t EXINT0 = (1U << 28);  ///< External pin interrupt ch.0
        constexpr uint32_t MFS7TX = (1U << 27);  ///< MFS ch.7 transmission interrupt
        constexpr uint32_t MFS7RX = (1U << 26);  ///< MFS ch.7 reception interrupt
        constexpr uint32_t MFS6TX = (1U << 25);  ///< MFS ch.6 transmission interrupt
        constexpr uint32_t MFS6RX = (1U << 24);  ///< MFS ch.6 reception interrupt
        constexpr uint32_t MFS5TX = (1U << 23);  ///< MFS ch.5 transmission interrupt
        constexpr uint32_t MFS5RX = (1U << 22);  ///< MFS ch.5 reception interrupt
        constexpr uint32_t MFS4TX = (1U << 21);  ///< MFS ch.4 transmission interrupt
        constexpr uint32_t MFS4RX = (1U << 20);  ///< MFS ch.4 reception interrupt
        constexpr uint32_t MFS3TX = (1U << 19);  ///< MFS ch.3 transmission interrupt
        constexpr uint32_t MFS3RX = (1U << 18);  ///< MFS ch.3 reception interrupt
        constexpr uint32_t MFS2TX = (1U << 17);  ///< MFS ch.2 transmission interrupt
        constexpr uint32_t MFS2RX = (1U << 16);  ///< MFS ch.2 reception interrupt
        constexpr uint32_t MFS1TX = (1U << 15);  ///< MFS ch.1 transmission interrupt
        constexpr uint32_t MFS1RX = (1U << 14);  ///< MFS ch.1 reception interrupt
        constexpr uint32_t MFS0TX = (1U << 13);  ///< MFS ch.0 transmission interrupt
        constexpr uint32_t MFS0RX = (1U << 12);  ///< MFS ch.0 reception interrupt.
        constexpr uint32_t IRQ0BT6 = (1U << 11);  ///< Base timer ch.6 source 0 (IRQ0) interrupt
        constexpr uint32_t IRQ0BT4 = (1U << 10);  ///< Base timer ch.4 source 0 (IRQ0) interrupt
        constexpr uint32_t IRQ0BT2 = (1U << 9);  ///< Base timer ch.2 source 0 (IRQ0) interrupt
        constexpr uint32_t IRQ0BT0 = (1U << 8);  ///< Base timer ch.6 source 0 (IRQ0) interrupt
        constexpr uint32_t ADCSCAN2 = (1U << 7);  ///< A/D converter unit 2 scan conversion interrupt
        constexpr uint32_t ADCSCAN1 = (1U << 6);  ///< A/D converter unit 1 scan conversion interrupt
        constexpr uint32_t ADCSCAN0 = (1U << 5);  ///< A/D converter unit 0 scan conversion interrupt
        constexpr uint32_t USBEP5 = (1U << 4);  ///< USB ch.0 function endpoint 5 DRQ interrupt
        constexpr uint32_t USBEP4 = (1U << 3);  ///< USB ch.0 function endpoint 4 DRQ interrupt
        constexpr uint32_t USBEP3 = (1U << 2);  ///< USB ch.0 function endpoint 3 DRQ interrupt
        constexpr uint32_t USBEP2 = (1U << 1);  ///< USB ch.0 function endpoint 2 DRQ interrupt
        constexpr uint32_t USBEP1 = (1U << 0);  ///< USB ch.0 function endpoint 1 DRQ interrupt
    }

    /// ODDPKS Register bits
    namespace oddpks_bits {
        constexpr uint32_t ODDPKS4 = (1U << 4);  ///< "If the transfer destination address of DMAC is USB.EP5DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS3 = (1U << 3);  ///< "If the transfer destination address of DMAC is USB.EP4DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS2 = (1U << 2);  ///< "If the transfer destination address of DMAC is USB.EP3DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS1 = (1U << 1);  ///< "If the transfer destination address of DMAC is USB.EP2DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS0 = (1U << 0);  ///< "If the transfer destination address of DMAC is USB.EP1DT, the bit width of the last transfer data is converted to Byte."
    }

    /// ODDPKS1 Register bits
    namespace oddpks1_bits {
        constexpr uint32_t ODDPKS14 = (1U << 4);  ///< "If the transfer destination address of DMAC is USB.EP5DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS13 = (1U << 3);  ///< "If the transfer destination address of DMAC is USB.EP4DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS12 = (1U << 2);  ///< "If the transfer destination address of DMAC is USB.EP3DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS11 = (1U << 1);  ///< "If the transfer destination address of DMAC is USB.EP2DT, the bit width of the last transfer data is converted to Byte."
        constexpr uint32_t ODDPKS10 = (1U << 0);  ///< "If the transfer destination address of DMAC is USB.EP1DT, the bit width of the last transfer data is converted to Byte."
    }

    /// IRQ003SEL Register bits
    namespace irq003sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ004SEL Register bits
    namespace irq004sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ005SEL Register bits
    namespace irq005sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ006SEL Register bits
    namespace irq006sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ007SEL Register bits
    namespace irq007sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ008SEL Register bits
    namespace irq008sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ009SEL Register bits
    namespace irq009sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// IRQ010SEL Register bits
    namespace irq010sel_bits {
        constexpr uint32_t SELBIT = (8 << 16);  ///< Bit7 of the interrupt source is moved to bit7 of the relocate interrupt.
        constexpr uint32_t SELIRQ = (8 << 0);  ///< specify the IRQ no. of a peripheral interrupt to be relocated
    }

    /// EXC02MON Register bits
    namespace exc02mon_bits {
        constexpr uint32_t HWINT = (1U << 1);  ///< Interrupt request of the hardware watchdog timer
        constexpr uint32_t NMI = (1U << 0);  ///< Interrupt request of the NMIX external pin
    }

    /// IRQ000MON Register bits
    namespace irq000mon_bits {
        constexpr uint32_t FCSINT = (1U << 0);  ///< Interrupt request of the anomalous frequency detected by the CSV
    }

    /// IRQ001MON Register bits
    namespace irq001mon_bits {
        constexpr uint32_t SWWDTINT = (1U << 0);  ///< interrupt request of the software watchdog timer
    }

    /// IRQ002MON Register bits
    namespace irq002mon_bits {
        constexpr uint32_t LVDINT = (1U << 0);  ///< Low-voltage detection (LVD) interrupt request
    }

    /// IRQ003MON Register bits
    namespace irq003mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ003SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ003SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ003SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ003SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ003SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ003SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ003SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ003SEL Register
    }

    /// IRQ004MON Register bits
    namespace irq004mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ004SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ004SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ004SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ004SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ004SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ004SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ004SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ004SEL Register
    }

    /// IRQ005MON Register bits
    namespace irq005mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ005SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ005SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ005SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ005SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ005SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ005SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ005SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ005SEL Register
    }

    /// IRQ006MON Register bits
    namespace irq006mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ006SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ006SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ006SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ006SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ006SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ006SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ006SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ006SEL Register
    }

    /// IRQ007MON Register bits
    namespace irq007mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ007SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ007SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ007SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ007SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ007SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ007SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ007SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ007SEL Register
    }

    /// IRQ008MON Register bits
    namespace irq008mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ008SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ008SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ008SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ008SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ008SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ008SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ008SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ008SEL Register
    }

    /// IRQ009MON Register bits
    namespace irq009mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ009SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ009SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ009SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ009SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ009SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ009SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ009SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ009SEL Register
    }

    /// IRQ010MON Register bits
    namespace irq010mon_bits {
        constexpr uint32_t IRQBIT7 = (1U << 7);  ///< interrupt request of the interrupt selected in bit7 of IRQ010SEL Register
        constexpr uint32_t IRQBIT6 = (1U << 6);  ///< interrupt request of the interrupt selected in bit6 of IRQ010SEL Register
        constexpr uint32_t IRQBIT5 = (1U << 5);  ///< interrupt request of the interrupt selected in bit5 of IRQ010SEL Register
        constexpr uint32_t IRQBIT4 = (1U << 4);  ///< interrupt request of the interrupt selected in bit4 of IRQ010SEL Register
        constexpr uint32_t IRQBIT3 = (1U << 3);  ///< interrupt request of the interrupt selected in bit3 of IRQ010SEL Register
        constexpr uint32_t IRQBIT2 = (1U << 2);  ///< interrupt request of the interrupt selected in bit2 of IRQ010SEL Register
        constexpr uint32_t IRQBIT1 = (1U << 1);  ///< interrupt request of the interrupt selected in bit1 of IRQ010SEL Register
        constexpr uint32_t IRQBIT0 = (1U << 0);  ///< interrupt request of the interrupt selected in bit0 of IRQ010SEL Register
    }

    /// IRQ011MON Register bits
    namespace irq011mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.0
    }

    /// IRQ012MON Register bits
    namespace irq012mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.1
    }

    /// IRQ013MON Register bits
    namespace irq013mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.2
    }

    /// IRQ014MON Register bits
    namespace irq014mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.3
    }

    /// IRQ015MON Register bits
    namespace irq015mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.4
    }

    /// IRQ016MON Register bits
    namespace irq016mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.5
    }

    /// IRQ017MON Register bits
    namespace irq017mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.6
    }

    /// IRQ018MON Register bits
    namespace irq018mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.7
    }

    /// IRQ019MON Register bits
    namespace irq019mon_bits {
        constexpr uint32_t QUDINT5 = (1U << 5);  ///< PC match and RC match interrupt request of QPRC ch.0
        constexpr uint32_t QUDINT4 = (1U << 4);  ///< Out-of-range interrupt request of QPRC ch.0QPRC ch.0
        constexpr uint32_t QUDINT3 = (1U << 3);  ///< Count inversion interrupt request of QPRC ch.0
        constexpr uint32_t QUDINT2 = (1U << 2);  ///< Overflow / underflow / zero index interrupt request of QPRC ch.0
        constexpr uint32_t QUDINT1 = (1U << 1);  ///< PC and RC match interrupt request of QPRC ch.0
        constexpr uint32_t QUDINT0 = (1U << 0);  ///< PC match interrupt request of QPRC ch.0
    }

    /// IRQ020MON Register bits
    namespace irq020mon_bits {
        constexpr uint32_t QUDINT5 = (1U << 5);  ///< PC match and RC match interrupt request of QPRC ch.1
        constexpr uint32_t QUDINT4 = (1U << 4);  ///< Out-of-range interrupt request of QPRC ch.1QPRC ch.1
        constexpr uint32_t QUDINT3 = (1U << 3);  ///< Count inversion interrupt request of QPRC ch.1
        constexpr uint32_t QUDINT2 = (1U << 2);  ///< Overflow / underflow / zero index interrupt request of QPRC ch.1
        constexpr uint32_t QUDINT1 = (1U << 1);  ///< PC and RC match interrupt request of QPRC ch.1
        constexpr uint32_t QUDINT0 = (1U << 0);  ///< PC match interrupt request of QPRC ch.1
    }

    /// IRQ021MON Register bits
    namespace irq021mon_bits {
        constexpr uint32_t WAVEINT3 = (1U << 3);  ///< Interrupt request of WFG timer 54 of the MFT unit 0
        constexpr uint32_t WAVEINT2 = (1U << 2);  ///< Interrupt request of WFG timer 32 of the MFT unit 0
        constexpr uint32_t WAVEINT1 = (1U << 1);  ///< Interrupt request of WFG timer 10 of the MFT unit 0
        constexpr uint32_t WAVEINT0 = (1U << 0);  ///< Interrupt request of the DTIF (motor emergency stop) of the MFT unit 0
    }

    /// IRQ022MON Register bits
    namespace irq022mon_bits {
        constexpr uint32_t WAVEINT3 = (1U << 3);  ///< Interrupt request of WFG timer 54 of the MFT unit 1
        constexpr uint32_t WAVEINT2 = (1U << 2);  ///< Interrupt request of WFG timer 32 of the MFT unit 1
        constexpr uint32_t WAVEINT1 = (1U << 1);  ///< Interrupt request of WFG timer 10 of the MFT unit 1
        constexpr uint32_t WAVEINT0 = (1U << 0);  ///< Interrupt request of the DTIF (motor emergency stop) of the MFT unit 1
    }

    /// IRQ023MON Register bits
    namespace irq023mon_bits {
        constexpr uint32_t WAVEINT3 = (1U << 3);  ///< Interrupt request of WFG timer 54 of the MFT unit 2
        constexpr uint32_t WAVEINT2 = (1U << 2);  ///< Interrupt request of WFG timer 32 of the MFT unit 2
        constexpr uint32_t WAVEINT1 = (1U << 1);  ///< Interrupt request of WFG timer 10 of the MFT unit 2
        constexpr uint32_t WAVEINT0 = (1U << 0);  ///< Interrupt request of the DTIF (motor emergency stop) of the MFT unit 2
    }

    /// IRQ024MON Register bits
    namespace irq024mon_bits {
        constexpr uint32_t FRT_PEAK_INT2 = (1U << 2);  ///< FRT ch.2 peak value detection interrupt request of the MFT unit 0
        constexpr uint32_t FRT_PEAK_INT1 = (1U << 1);  ///< FRT ch.1 peak value detection interrupt request of the MFT unit 0
        constexpr uint32_t FRT_PEAK_INT0 = (1U << 0);  ///< FRT ch.0 peak value detection interrupt request of the MFT unit 0
    }

    /// IRQ025MON Register bits
    namespace irq025mon_bits {
        constexpr uint32_t FRT_ZERO_INT2 = (1U << 2);  ///< FRT ch.2 zero detection interrupt request of the MFT unit 0
        constexpr uint32_t FRT_ZERO_INT1 = (1U << 1);  ///< FRT ch.1 zero detection interrupt request of the MFT unit 0
        constexpr uint32_t FRT_ZERO_INT0 = (1U << 0);  ///< FRT ch.0 zero detection interrupt request of the MFT unit 0
    }

    /// IRQ026MON Register bits
    namespace irq026mon_bits {
        constexpr uint32_t ICUINT3 = (1U << 3);  ///< ICU ch.3 input edge detection interrupt request of the MFT unit 0
        constexpr uint32_t ICUINT2 = (1U << 2);  ///< ICU ch.2 input edge detection interrupt request of the MFT unit 0
        constexpr uint32_t ICUINT1 = (1U << 1);  ///< ICU ch.1 input edge detection interrupt request of the MFT unit 0
        constexpr uint32_t ICUINT0 = (1U << 0);  ///< ICU ch.0 input edge detection interrupt request of the MFT unit 0
    }

    /// IRQ027MON Register bits
    namespace irq027mon_bits {
        constexpr uint32_t OCUINT5 = (1U << 5);  ///< OCU ch.5 match detection interrupt request of the MFT unit 0
        constexpr uint32_t OCUINT4 = (1U << 4);  ///< OCU ch.4 match detection interrupt request of the MFT unit 0
        constexpr uint32_t OCUINT3 = (1U << 3);  ///< OCU ch.3 match detection interrupt request of the MFT unit 0
        constexpr uint32_t OCUINT2 = (1U << 2);  ///< OCU ch.2 match detection interrupt request of the MFT unit 0
        constexpr uint32_t OCUINT1 = (1U << 1);  ///< OCU ch.1 match detection interrupt request of the MFT unit 0
        constexpr uint32_t OCUINT0 = (1U << 0);  ///< OCU ch.0 match detection interrupt request of the MFT unit 0
    }

    /// IRQ028MON Register bits
    namespace irq028mon_bits {
        constexpr uint32_t FRT_PEAK_INT2 = (1U << 2);  ///< FRT ch.2 peak value detection interrupt request of the MFT unit 1
        constexpr uint32_t FRT_PEAK_INT1 = (1U << 1);  ///< FRT ch.1 peak value detection interrupt request of the MFT unit 1
        constexpr uint32_t FRT_PEAK_INT0 = (1U << 0);  ///< FRT ch.0 peak value detection interrupt request of the MFT unit 1
    }

    /// IRQ029MON Register bits
    namespace irq029mon_bits {
        constexpr uint32_t FRT_ZERO_INT2 = (1U << 2);  ///< FRT ch.2 zero detection interrupt request of the MFT unit 1
        constexpr uint32_t FRT_ZERO_INT1 = (1U << 1);  ///< FRT ch.1 zero detection interrupt request of the MFT unit 1
        constexpr uint32_t FRT_ZERO_INT0 = (1U << 0);  ///< FRT ch.0 zero detection interrupt request of the MFT unit 1
    }

    /// IRQ030MON Register bits
    namespace irq030mon_bits {
        constexpr uint32_t ICUINT3 = (1U << 3);  ///< ICU ch.3 input edge detection interrupt request of the MFT unit 1
        constexpr uint32_t ICUINT2 = (1U << 2);  ///< ICU ch.2 input edge detection interrupt request of the MFT unit 1
        constexpr uint32_t ICUINT1 = (1U << 1);  ///< ICU ch.1 input edge detection interrupt request of the MFT unit 1
        constexpr uint32_t ICUINT0 = (1U << 0);  ///< ICU ch.0 input edge detection interrupt request of the MFT unit 1
    }

    /// IRQ031MON Register bits
    namespace irq031mon_bits {
        constexpr uint32_t OCUINT5 = (1U << 5);  ///< OCU ch.5 match detection interrupt request of the MFT unit 1
        constexpr uint32_t OCUINT4 = (1U << 4);  ///< OCU ch.4 match detection interrupt request of the MFT unit 1
        constexpr uint32_t OCUINT3 = (1U << 3);  ///< OCU ch.3 match detection interrupt request of the MFT unit 1
        constexpr uint32_t OCUINT2 = (1U << 2);  ///< OCU ch.2 match detection interrupt request of the MFT unit 1
        constexpr uint32_t OCUINT1 = (1U << 1);  ///< OCU ch.1 match detection interrupt request of the MFT unit 1
        constexpr uint32_t OCUINT0 = (1U << 0);  ///< OCU ch.0 match detection interrupt request of the MFT unit 1
    }

    /// IRQ032MON Register bits
    namespace irq032mon_bits {
        constexpr uint32_t FRT_PEAK_INT2 = (1U << 2);  ///< FRT ch.2 peak value detection interrupt request of the MFT unit 2
        constexpr uint32_t FRT_PEAK_INT1 = (1U << 1);  ///< FRT ch.1 peak value detection interrupt request of the MFT unit 2
        constexpr uint32_t FRT_PEAK_INT0 = (1U << 0);  ///< FRT ch.0 peak value detection interrupt request of the MFT unit 2
    }

    /// IRQ033MON Register bits
    namespace irq033mon_bits {
        constexpr uint32_t FRT_ZERO_INT2 = (1U << 2);  ///< FRT ch.2 zero detection interrupt request of the MFT unit 2
        constexpr uint32_t FRT_ZERO_INT1 = (1U << 1);  ///< FRT ch.1 zero detection interrupt request of the MFT unit 2
        constexpr uint32_t FRT_ZERO_INT0 = (1U << 0);  ///< FRT ch.0 zero detection interrupt request of the MFT unit 2
    }

    /// IRQ034MON Register bits
    namespace irq034mon_bits {
        constexpr uint32_t ICUINT3 = (1U << 3);  ///< ICU ch.3 input edge detection interrupt request of the MFT unit 2
        constexpr uint32_t ICUINT2 = (1U << 2);  ///< ICU ch.2 input edge detection interrupt request of the MFT unit 2
        constexpr uint32_t ICUINT1 = (1U << 1);  ///< ICU ch.1 input edge detection interrupt request of the MFT unit 2
        constexpr uint32_t ICUINT0 = (1U << 0);  ///< ICU ch.0 input edge detection interrupt request of the MFT unit 2
    }

    /// IRQ035MON Register bits
    namespace irq035mon_bits {
        constexpr uint32_t OCUINT5 = (1U << 5);  ///< OCU ch.5 match detection interrupt request of the MFT unit 2
        constexpr uint32_t OCUINT4 = (1U << 4);  ///< OCU ch.4 match detection interrupt request of the MFT unit 2
        constexpr uint32_t OCUINT3 = (1U << 3);  ///< OCU ch.3 match detection interrupt request of the MFT unit 2
        constexpr uint32_t OCUINT2 = (1U << 2);  ///< OCU ch.2 match detection interrupt request of the MFT unit 2
        constexpr uint32_t OCUINT1 = (1U << 1);  ///< OCU ch.1 match detection interrupt request of the MFT unit 2
        constexpr uint32_t OCUINT0 = (1U << 0);  ///< OCU ch.0 match detection interrupt request of the MFT unit 2
    }

    /// IRQ036MON Register bits
    namespace irq036mon_bits {
        constexpr uint32_t PPGINT2 = (1U << 2);  ///< Interrupt request of the PPG ch.4
        constexpr uint32_t PPGINT1 = (1U << 1);  ///< Interrupt request of the PPG ch.2
        constexpr uint32_t PPGINT0 = (1U << 0);  ///< Interrupt request of the PPG ch.0
    }

    /// IRQ037MON Register bits
    namespace irq037mon_bits {
        constexpr uint32_t PPGINT2 = (1U << 2);  ///< Interrupt request of the PPG ch.12
        constexpr uint32_t PPGINT1 = (1U << 1);  ///< Interrupt request of the PPG ch.10
        constexpr uint32_t PPGINT0 = (1U << 0);  ///< Interrupt request of the PPG ch.8
    }

    /// IRQ038MON Register bits
    namespace irq038mon_bits {
        constexpr uint32_t PPGINT2 = (1U << 2);  ///< Interrupt request of the PPG ch.20
        constexpr uint32_t PPGINT1 = (1U << 1);  ///< Interrupt request of the PPG ch.18
        constexpr uint32_t PPGINT0 = (1U << 0);  ///< Interrupt request of the PPG ch.16
    }

    /// IRQ039MON Register bits
    namespace irq039mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.0
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.0
    }

    /// IRQ040MON Register bits
    namespace irq040mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.1
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.1
    }

    /// IRQ041MON Register bits
    namespace irq041mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.2
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.2
    }

    /// IRQ042MON Register bits
    namespace irq042mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.3
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.3
    }

    /// IRQ043MON Register bits
    namespace irq043mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.4
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.4
    }

    /// IRQ044MON Register bits
    namespace irq044mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.5
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.5
    }

    /// IRQ045MON Register bits
    namespace irq045mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.6
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.6
    }

    /// IRQ046MON Register bits
    namespace irq046mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.7
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.7
    }

    /// IRQ047MON Register bits
    namespace irq047mon_bits {
        constexpr uint32_t TIMINT2 = (1U << 1);  ///< Dual timer TIMINT2 interrupt request
        constexpr uint32_t TIMINT1 = (1U << 0);  ///< Dual timer TIMINT1 interrupt request
    }

    /// IRQ048MON Register bits
    namespace irq048mon_bits {
        constexpr uint32_t WCINT = (1U << 0);  ///< Interrupt request of the watch counter
    }

    /// IRQ049MON Register bits
    namespace irq049mon_bits {
        constexpr uint32_t BMEMCS = (1U << 0);  ///< External bus output error interrupt request
    }

    /// IRQ050MON Register bits
    namespace irq050mon_bits {
        constexpr uint32_t RTCINT = (1U << 0);  ///< Interrupt request of the RTC$
    }

    /// IRQ051MON Register bits
    namespace irq051mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.8
    }

    /// IRQ052MON Register bits
    namespace irq052mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.9
    }

    /// IRQ053MON Register bits
    namespace irq053mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.10
    }

    /// IRQ054MON Register bits
    namespace irq054mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.11
    }

    /// IRQ055MON Register bits
    namespace irq055mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.12
    }

    /// IRQ056MON Register bits
    namespace irq056mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.13
    }

    /// IRQ057MON Register bits
    namespace irq057mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.14
    }

    /// IRQ058MON Register bits
    namespace irq058mon_bits {
        constexpr uint32_t EXTINT = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.15
    }

    /// IRQ059MON Register bits
    namespace irq059mon_bits {
        constexpr uint32_t IPLLINT = (1U << 4);  ///< PLL of I2S oscillation stabilization wait completion interrupt
        constexpr uint32_t UPLLINT = (1U << 3);  ///< PLL of USB / Ethernet oscillation stabilization wait completion interrupt
        constexpr uint32_t MPLLINT = (1U << 2);  ///< Main PLL oscillation stabilization wait completion interrupt
        constexpr uint32_t SOSCINT = (1U << 1);  ///< Sub clock oscillation stabilization wait completion interrupt
        constexpr uint32_t MOSCINT = (1U << 0);  ///< Main clock oscillation stabilization wait completion interrupt
    }

    /// IRQ060MON Register bits
    namespace irq060mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.0
    }

    /// IRQ061MON Register bits
    namespace irq061mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.0
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.0
    }

    /// IRQ062MON Register bits
    namespace irq062mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.1
    }

    /// IRQ063MON Register bits
    namespace irq063mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.1
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.1
    }

    /// IRQ064MON Register bits
    namespace irq064mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.2
    }

    /// IRQ065MON Register bits
    namespace irq065mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.2
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.2
    }

    /// IRQ066MON Register bits
    namespace irq066mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.3
    }

    /// IRQ067MON Register bits
    namespace irq067mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.3
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.3
    }

    /// IRQ068MON Register bits
    namespace irq068mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.4
    }

    /// IRQ069MON Register bits
    namespace irq069mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.4
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.4
    }

    /// IRQ070MON Register bits
    namespace irq070mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.5
    }

    /// IRQ071MON Register bits
    namespace irq071mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.5
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.5
    }

    /// IRQ072MON Register bits
    namespace irq072mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.6
    }

    /// IRQ073MON Register bits
    namespace irq073mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.6
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.6
    }

    /// IRQ074MON Register bits
    namespace irq074mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.7
    }

    /// IRQ075MON Register bits
    namespace irq075mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.7
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.7
    }

    /// IRQ076MON Register bits
    namespace irq076mon_bits {
        constexpr uint32_t ADCINT4 = (1U << 4);  ///< Range comparison result interrupt request of the A/D converter unit 0
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request of the A/D converter unit 0
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request of the A/D converter unit 0
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request of the A/D converter unit 0
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request of the A/D converter unit 0
    }

    /// IRQ077MON Register bits
    namespace irq077mon_bits {
        constexpr uint32_t ADCINT4 = (1U << 4);  ///< Range comparison result interrupt request of the A/D converter unit 1
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request of the A/D converter unit 1
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request of the A/D converter unit 1
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request of the A/D converter unit 1
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request of the A/D converter unit 1
    }

    /// IRQ078MON Register bits
    namespace irq078mon_bits {
        constexpr uint32_t USB_DRQ_INT4 = (1U << 4);  ///< Endpoint 5 DRQ interrupt request of the USB ch.0
        constexpr uint32_t USB_DRQ_INT3 = (1U << 3);  ///< Endpoint 4 DRQ interrupt request of the USB ch.0
        constexpr uint32_t USB_DRQ_INT2 = (1U << 2);  ///< Endpoint 3 DRQ interrupt request of the USB ch.0
        constexpr uint32_t USB_DRQ_INT1 = (1U << 1);  ///< Endpoint 2 DRQ interrupt request of the USB ch.0
        constexpr uint32_t USB_DRQ_INT0 = (1U << 0);  ///< Endpoint 1 DRQ interrupt request of the USB ch.0
    }

    /// IRQ079MON Register bits
    namespace irq079mon_bits {
        constexpr uint32_t USB_INT5 = (1U << 5);  ///< SOFIRQ/CMPIRQ interrupt request of the USB ch.0
        constexpr uint32_t USB_INT4 = (1U << 4);  ///< DIRQ/URPIRQ/RWKIRQ/CNNIRQ interrupt request of the USB ch.0
        constexpr uint32_t USB_INT3 = (1U << 3);  ///< SPK interrupt request of the USB ch.0
        constexpr uint32_t USB_INT2 = (1U << 2);  ///< SUSP/SOF/BRST/CONF/WKUP interrupt request of the USB ch.0
        constexpr uint32_t USB_INT1 = (1U << 1);  ///< Endpoint 0 DRQO interrupt request of the USB ch.0
        constexpr uint32_t USB_INT0 = (1U << 0);  ///< Endpoint 0 DRQI interrupt request of the USB ch.0
    }

    /// IRQ080MON Register bits
    namespace irq080mon_bits {
        constexpr uint32_t CANINT = (1U << 0);  ///< Interrupt request of the CAN ch.0
    }

    /// IRQ081MON Register bits
    namespace irq081mon_bits {
        constexpr uint32_t CAN1INT = (1U << 4);  ///< CAN-FD 1 interrupt request
        constexpr uint32_t CAN0INT = (1U << 3);  ///< CAN-FD 0 interrupt request
        constexpr uint32_t CANSEINT = (1U << 2);  ///< Single bit error interrupt request of the CAN-FD
        constexpr uint32_t CANDEINT = (1U << 1);  ///< Double bit error interrupt request of the CAN-FD
        constexpr uint32_t CANINT = (1U << 0);  ///< Interrupt request of the CAN ch.1
    }

    /// IRQ082MON Register bits
    namespace irq082mon_bits {
        constexpr uint32_t MACLPI = (1U << 2);  ///< LPI interrupt request of the Ethernet MAC
        constexpr uint32_t MACPMT = (1U << 1);  ///< PMT interrupt request of the Ethernet MAC
        constexpr uint32_t MACSBD = (1U << 0);  ///< SBD interrupt request of the Ethernet MAC
    }

    /// IRQ083MON Register bits
    namespace irq083mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.0
    }

    /// IRQ084MON Register bits
    namespace irq084mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.1
    }

    /// IRQ085MON Register bits
    namespace irq085mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.2
    }

    /// IRQ086MON Register bits
    namespace irq086mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.3
    }

    /// IRQ087MON Register bits
    namespace irq087mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.4
    }

    /// IRQ088MON Register bits
    namespace irq088mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.5
    }

    /// IRQ089MON Register bits
    namespace irq089mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.6
    }

    /// IRQ090MON Register bits
    namespace irq090mon_bits {
        constexpr uint32_t DMACINT = (1U << 0);  ///< Interrupt request of the DMAC ch.7
    }

    /// IRQ091MON Register bits
    namespace irq091mon_bits {
        constexpr uint32_t DSTCINT1 = (1U << 1);  ///< DSTC ERINT interrupt request
        constexpr uint32_t DSTCINT0 = (1U << 0);  ///< DSTC SWINT interrupt request
    }

    /// IRQ092MON Register bits
    namespace irq092mon_bits {
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request of the external pin interrupt ch.19
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request of the external pin interrupt ch.18
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request of the external pin interrupt ch.17
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.16
    }

    /// IRQ093MON Register bits
    namespace irq093mon_bits {
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request of the external pin interrupt ch.23
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request of the external pin interrupt ch.22
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request of the external pin interrupt ch.21
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.20
    }

    /// IRQ094MON Register bits
    namespace irq094mon_bits {
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request of the external pin interrupt ch.27
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request of the external pin interrupt ch.26
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request of the external pin interrupt ch.25
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.24
    }

    /// IRQ095MON Register bits
    namespace irq095mon_bits {
        constexpr uint32_t EXTINT3 = (1U << 3);  ///< Interrupt request of the external pin interrupt ch.31
        constexpr uint32_t EXTINT2 = (1U << 2);  ///< Interrupt request of the external pin interrupt ch.30
        constexpr uint32_t EXTINT1 = (1U << 1);  ///< Interrupt request of the external pin interrupt ch.29
        constexpr uint32_t EXTINT0 = (1U << 0);  ///< Interrupt request of the external pin interrupt ch.28
    }

    /// IRQ096MON Register bits
    namespace irq096mon_bits {
        constexpr uint32_t QUDINT5 = (1U << 5);  ///< PC match and RC match interrupt request of QPRC ch.2
        constexpr uint32_t QUDINT4 = (1U << 4);  ///< Out-of-range interrupt request of QPRC ch.2QPRC ch.2
        constexpr uint32_t QUDINT3 = (1U << 3);  ///< Count inversion interrupt request of QPRC ch.2
        constexpr uint32_t QUDINT2 = (1U << 2);  ///< Overflow / underflow / zero index interrupt request of QPRC ch.2
        constexpr uint32_t QUDINT1 = (1U << 1);  ///< PC and RC match interrupt request of QPRC ch.2
        constexpr uint32_t QUDINT0 = (1U << 0);  ///< PC match interrupt request of QPRC ch.2
    }

    /// IRQ097MON Register bits
    namespace irq097mon_bits {
        constexpr uint32_t QUDINT5 = (1U << 5);  ///< PC match and RC match interrupt request of QPRC ch.3
        constexpr uint32_t QUDINT4 = (1U << 4);  ///< Out-of-range interrupt request of QPRC ch.3QPRC ch.3
        constexpr uint32_t QUDINT3 = (1U << 3);  ///< Count inversion interrupt request of QPRC ch.3
        constexpr uint32_t QUDINT2 = (1U << 2);  ///< Overflow / underflow / zero index interrupt request of QPRC ch.3
        constexpr uint32_t QUDINT1 = (1U << 1);  ///< PC and RC match interrupt request of QPRC ch.3
        constexpr uint32_t QUDINT0 = (1U << 0);  ///< PC match interrupt request of QPRC ch.3
    }

    /// IRQ098MON Register bits
    namespace irq098mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.8
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.8
    }

    /// IRQ099MON Register bits
    namespace irq099mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.9
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.9
    }

    /// IRQ100MON Register bits
    namespace irq100mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.10
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.10
    }

    /// IRQ101MON Register bits
    namespace irq101mon_bits {
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.11
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.11
    }

    /// IRQ102MON Register bits
    namespace irq102mon_bits {
        constexpr uint32_t BTINT7 = (1U << 7);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.15
        constexpr uint32_t BTINT6 = (1U << 6);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.15
        constexpr uint32_t BTINT5 = (1U << 5);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.14
        constexpr uint32_t BTINT4 = (1U << 4);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.14
        constexpr uint32_t BTINT3 = (1U << 3);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.13
        constexpr uint32_t BTINT2 = (1U << 2);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.13
        constexpr uint32_t BTINT1 = (1U << 1);  ///< Interrupt request of source 1 (IRQ1) of the base timer ch.12
        constexpr uint32_t BTINT0 = (1U << 0);  ///< Interrupt request of source 0 (IRQ0) of the base timer ch.12
    }

    /// IRQ103MON Register bits
    namespace irq103mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.8
    }

    /// IRQ104MON Register bits
    namespace irq104mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.8
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.8
    }

    /// IRQ105MON Register bits
    namespace irq105mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.9
    }

    /// IRQ106MON Register bits
    namespace irq106mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.9
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.9
    }

    /// IRQ107MON Register bits
    namespace irq107mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.10
    }

    /// IRQ108MON Register bits
    namespace irq108mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.10
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.10
    }

    /// IRQ109MON Register bits
    namespace irq109mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< Reception interrupt request of the MFS ch.11
    }

    /// IRQ110MON Register bits
    namespace irq110mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< Status interrupt request of the MFS ch.11
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< Transmission interrupt request of the MFS ch.11
    }

    /// IRQ111MON Register bits
    namespace irq111mon_bits {
        constexpr uint32_t ADCINT4 = (1U << 4);  ///< Range comparison result interrupt request of the A/D converter unit 2
        constexpr uint32_t ADCINT3 = (1U << 3);  ///< Conversion result comparison interrupt request of the A/D converter unit 2
        constexpr uint32_t ADCINT2 = (1U << 2);  ///< FIFO overrun interrupt request of the A/D converter unit 2
        constexpr uint32_t ADCINT1 = (1U << 1);  ///< Scan conversion interrupt request of the A/D converter unit 2
        constexpr uint32_t ADCINT0 = (1U << 0);  ///< Priority conversion interrupt request of the A/D converter unit 2
    }

    /// IRQ112MON Register bits
    namespace irq112mon_bits {
        constexpr uint32_t CANDINT = (1U << 5);  ///< Interrupt request of DSTC transfer end interrupt of CAN-FD
        constexpr uint32_t PCRCDINT = (1U << 4);  ///< Interrupt request of DSTC transfer end interrupt of Programmable CRC
        constexpr uint32_t QSPIDINT1 = (1U << 3);  ///< Interrupt request of DSTC transfer end interrupt of Quad SPI(transmission)
        constexpr uint32_t QSPIDINT0 = (1U << 2);  ///< Interrupt request of DSTC transfer end interrupt of Quad SPI(reception)
        constexpr uint32_t I2SDINT1 = (1U << 1);  ///< Interrupt request of DSTC transfer end interrupt of I2S(transmission)
        constexpr uint32_t I2SDINT0 = (1U << 0);  ///< Interrupt request of DSTC transfer end interrupt of I2S(reception)
    }

    /// IRQ113MON Register bits
    namespace irq113mon_bits {
        constexpr uint32_t RCEC0INT = (1U << 5);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_DRQ_INT4 = (1U << 4);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_DRQ_INT3 = (1U << 3);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_DRQ_INT2 = (1U << 2);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_DRQ_INT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_DRQ_INT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ114MON Register bits
    namespace irq114mon_bits {
        constexpr uint32_t RCEC1INT = (1U << 6);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_INT5 = (1U << 5);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_INT4 = (1U << 4);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_INT3 = (1U << 3);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_INT2 = (1U << 2);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_INT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t USB_INT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ115MON Register bits
    namespace irq115mon_bits {
        constexpr uint32_t QSPIINT2 = (1U << 2);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t QSPIINT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t QSPIINT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ117MON Register bits
    namespace irq117mon_bits {
        constexpr uint32_t PRGCRC = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t I2SINT = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ118MON Register bits
    namespace irq118mon_bits {
        constexpr uint32_t SDINT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t SDINT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ119MON Register bits
    namespace irq119mon_bits {
        constexpr uint32_t FLINT = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ120MON Register bits
    namespace irq120mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ121MON Register bits
    namespace irq121mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ122MON Register bits
    namespace irq122mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ123MON Register bits
    namespace irq123mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ124MON Register bits
    namespace irq124mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ125MON Register bits
    namespace irq125mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ126MON Register bits
    namespace irq126mon_bits {
        constexpr uint32_t MFSRINT = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// IRQ127MON Register bits
    namespace irq127mon_bits {
        constexpr uint32_t MFSINT1 = (1U << 1);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
        constexpr uint32_t MFSINT0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

}

// ============================================================================
// HDMICEC0 Peripheral
// ============================================================================

namespace hdmicec0 {
    /// Base addresses
    constexpr uint32_t HDMICEC0_BASE = 0x40034000;

    /// HDMICEC0 Register structure
    struct Registers {
        volatile uint32_t TXCTRL;  ///< Offset: 0x00 - Transmission Control Register
        volatile uint32_t TXDATA;  ///< Offset: 0x04 - Transmission Data Register
        volatile uint32_t TXSTS;  ///< Offset: 0x08 - Transmission Status Register
        volatile uint32_t SFREE;  ///< Offset: 0x0C - Signal Free Time Setting Register
        volatile uint32_t RCST;  ///< Offset: 0x40 - Reception Interrupt Control Register
        volatile uint32_t RCCR;  ///< Offset: 0x41 - Reception Control Register
        volatile uint32_t RCDAHW;  ///< Offset: 0x44 - "H" Width Setting Register A
        volatile uint32_t RCSHW;  ///< Offset: 0x45 - Start Bit "H" Width Setting Register
        volatile uint32_t RCDBHW;  ///< Offset: 0x49 - "H" Width Setting Register B
        volatile uint32_t RCADR2;  ///< Offset: 0x4C - Device Address Setting Register 2
        volatile uint32_t RCADR1;  ///< Offset: 0x4D - Device Address Setting Register 1
        volatile uint32_t RCDTHL;  ///< Offset: 0x50 - Data Save Register (High-Low)
        volatile uint32_t RCDTHH;  ///< Offset: 0x51 - Data Save Register (High-High)
        volatile uint32_t RCDTLL;  ///< Offset: 0x54 - Data Save Register (Low-Low)
        volatile uint32_t RCDTLH;  ///< Offset: 0x55 - Data Save Register (Low-High)
        volatile uint32_t RCCKD;  ///< Offset: 0x58 - Clock Division Setting Register
        volatile uint32_t RCRHW;  ///< Offset: 0x5C - Repeat Code "H" Width Setting Register
        volatile uint32_t RCRC;  ///< Offset: 0x5D - Repeat Code Interrupt Control Register
        volatile uint32_t RCLE;  ///< Offset: 0x61 - Data Bit Width Violation Control Register
        volatile uint32_t RCLESW;  ///< Offset: 0x64 - Minimum Data Bit Width Setting Register
        volatile uint32_t RCLELW;  ///< Offset: 0x65 - Maximum Data Bit Width Setting Register
    };

    /// Peripheral instances
    inline Registers* HDMICEC0 = reinterpret_cast<Registers*>(HDMICEC0_BASE);

    // Bit definitions
    /// TXCTRL Register bits
    namespace txctrl_bits {
        constexpr uint32_t IBREN = (1U << 5);  ///< Bus error detection interrupt enable bit
        constexpr uint32_t ITSTEN = (1U << 4);  ///< transmission status interrupt enable bit
        constexpr uint32_t EOM = (1U << 3);  ///< EOM setting bit
        constexpr uint32_t START = (1U << 2);  ///< START setting bit
        constexpr uint32_t TXEN = (1U << 0);  ///< Transmission operation enable bit
    }

    /// TXDATA Register bits
    namespace txdata_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< Transmission Data
    }

    /// TXSTS Register bits
    namespace txsts_bits {
        constexpr uint32_t IBR = (1U << 5);  ///< Bus error detection interrupt request bit
        constexpr uint32_t ITST = (1U << 4);  ///< Transmission status interrupt request bit
        constexpr uint32_t ACKSV = (1U << 0);  ///< ACK cycle value bit
    }

    /// SFREE Register bits
    namespace sfree_bits {
        constexpr uint32_t SFREE = (4 << 0);  ///< Signal free time setting bits
    }

    /// RCST Register bits
    namespace rcst_bits {
        constexpr uint32_t STIE = (1U << 7);  ///< Start bit interrupt enable bit
        constexpr uint32_t ACKIE = (1U << 6);  ///< ACK interrupt enable bit
        constexpr uint32_t OVFIE = (1U << 5);  ///< Counter overflow interrupt enable bit
        constexpr uint32_t OVFSEL = (1U << 4);  ///< Counter overflow detection condition setting bit
        constexpr uint32_t ST = (1U << 3);  ///< Start bit detection bit
        constexpr uint32_t ACK = (1U << 2);  ///< ACK: ACK detection bit
        constexpr uint32_t EOM = (1U << 1);  ///< EOM detection bit
        constexpr uint32_t OVF = (1U << 0);  ///< Counter overflow detection bit
    }

    /// RCCR Register bits
    namespace rccr_bits {
        constexpr uint32_t THSEL = (1U << 7);  ///< Threshold selection bit
        constexpr uint32_t ADRCE = (1U << 3);  ///< Address comparison enable bit
        constexpr uint32_t MOD = (2 << 1);  ///< Operation mode setting bits
        constexpr uint32_t EN = (1U << 0);  ///< Operation enable bit
    }

    /// RCDAHW Register bits
    namespace rcdahw_bits {
        constexpr uint32_t RCDAHW = (8 << 0);  ///< "H" Width Setting A
    }

    /// RCSHW Register bits
    namespace rcshw_bits {
        constexpr uint32_t RCSHW = (8 << 0);  ///< Start Bit "H" Width Setting
    }

    /// RCDBHW Register bits
    namespace rcdbhw_bits {
        constexpr uint32_t RCDBHW = (8 << 0);  ///< "H" Width Setting B
    }

    /// RCADR2 Register bits
    namespace rcadr2_bits {
        constexpr uint32_t RCADR2 = (5 << 0);  ///< Device Address 2
    }

    /// RCADR1 Register bits
    namespace rcadr1_bits {
        constexpr uint32_t RCADR1 = (5 << 0);  ///< Device Address 1
    }

    /// RCDTHL Register bits
    namespace rcdthl_bits {
        constexpr uint32_t RCDTHL = (8 << 0);  ///< RCDTHL
    }

    /// RCDTHH Register bits
    namespace rcdthh_bits {
        constexpr uint32_t RCDTHH = (8 << 0);  ///< RCDTHH
    }

    /// RCDTLL Register bits
    namespace rcdtll_bits {
        constexpr uint32_t RCDTLL = (8 << 0);  ///< RCDTLL
    }

    /// RCDTLH Register bits
    namespace rcdtlh_bits {
        constexpr uint32_t RCDTLH = (8 << 0);  ///< RCDTLH
    }

    /// RCCKD Register bits
    namespace rcckd_bits {
        constexpr uint32_t CKSEL = (1U << 12);  ///< Operating clock selection bit
        constexpr uint32_t CKDIV = (12 << 0);  ///< Operating clock division setting bits
    }

    /// RCRHW Register bits
    namespace rcrhw_bits {
        constexpr uint32_t RCRHW = (8 << 0);  ///< "Repeat code "H" width setting bits"
    }

    /// RCRC Register bits
    namespace rcrc_bits {
        constexpr uint32_t RCIE = (1U << 4);  ///< Repeat Code Interrupt enable bit
        constexpr uint32_t RC = (1U << 0);  ///< Repeat code detection flag bit
    }

    /// RCLE Register bits
    namespace rcle_bits {
        constexpr uint32_t LELIE = (1U << 7);  ///< Maximum data bit width violation interrupt enable bit
        constexpr uint32_t LESIE = (1U << 6);  ///< Minimum data bit width violation interrupt enable bit
        constexpr uint32_t LELE = (1U << 5);  ///< Maximum data bit width violation detection enable bit
        constexpr uint32_t LESE = (1U << 4);  ///< Minimum data bit width violation detection enable bit
        constexpr uint32_t EPE = (1U << 3);  ///< Error pulse output enable bit
        constexpr uint32_t LEL = (1U << 1);  ///< Maximum data bit width violation detection flag bit
        constexpr uint32_t LES = (1U << 0);  ///< Minimum data bit width violation detection flag bit
    }

    /// RCLESW Register bits
    namespace rclesw_bits {
        constexpr uint32_t RCLESW = (8 << 0);  ///< Minimum data bit width setting bits
    }

    /// RCLELW Register bits
    namespace rclelw_bits {
        constexpr uint32_t RCLELW = (8 << 0);  ///< Maximum data bit width setting bits
    }

}

// ============================================================================
// HDMICEC1 Peripheral
// ============================================================================

namespace hdmicec1 {
    /// Base addresses
    constexpr uint32_t HDMICEC1_BASE = 0x40034100;

    /// HDMICEC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HDMICEC1 = reinterpret_cast<Registers*>(HDMICEC1_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x4006F000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PFR0;  ///< Offset: 0x00 - Port Function Setting Register 0
        volatile uint32_t PFR1;  ///< Offset: 0x04 - Port Function Setting Register 1
        volatile uint32_t PFR2;  ///< Offset: 0x08 - Port Function Setting Register 2
        volatile uint32_t PFR3;  ///< Offset: 0x0C - Port Function Setting Register 3
        volatile uint32_t PFR4;  ///< Offset: 0x10 - Port Function Setting Register 4
        volatile uint32_t PFR5;  ///< Offset: 0x14 - Port Function Setting Register 5
        volatile uint32_t PFR6;  ///< Offset: 0x18 - Port Function Setting Register 6
        volatile uint32_t PFR7;  ///< Offset: 0x1C - Port Function Setting Register 7
        volatile uint32_t PFR8;  ///< Offset: 0x20 - Port Function Setting Register 8
        volatile uint32_t PFR9;  ///< Offset: 0x24 - 32
        volatile uint32_t PFRA;  ///< Offset: 0x28 - 32
        volatile uint32_t PFRB;  ///< Offset: 0x2C - 32
        volatile uint32_t PFRC;  ///< Offset: 0x30 - 32
        volatile uint32_t PFRD;  ///< Offset: 0x34 - 32
        volatile uint32_t PFRE;  ///< Offset: 0x38 - Port Function Setting Register E
        volatile uint32_t PFRF;  ///< Offset: 0x3C - 32
        volatile uint32_t PCR0;  ///< Offset: 0x100 - Pull-up Setting Register 0
        volatile uint32_t PCR1;  ///< Offset: 0x104 - Pull-up Setting Register 1
        volatile uint32_t PCR2;  ///< Offset: 0x108 - Pull-up Setting Register 2
        volatile uint32_t PCR3;  ///< Offset: 0x10C - Pull-up Setting Register 3
        volatile uint32_t PCR4;  ///< Offset: 0x110 - Pull-up Setting Register 4
        volatile uint32_t PCR5;  ///< Offset: 0x114 - Pull-up Setting Register 5
        volatile uint32_t PCR6;  ///< Offset: 0x118 - Pull-up Setting Register 6
        volatile uint32_t PCR7;  ///< Offset: 0x11C - Pull-up Setting Register 7
        volatile uint32_t PCR8;  ///< Offset: 0x120 - Pull-up Setting Register 8
        volatile uint32_t PCR9;  ///< Offset: 0x124 - Pull-up Setting Register 9
        volatile uint32_t PCRA;  ///< Offset: 0x128 - Pull-up Setting Register A
        volatile uint32_t PCRB;  ///< Offset: 0x12C - Pull-up Setting Register B
        volatile uint32_t PCRC;  ///< Offset: 0x130 - Pull-up Setting Register C
        volatile uint32_t PCRD;  ///< Offset: 0x134 - Pull-up Setting Register D
        volatile uint32_t PCRE;  ///< Offset: 0x138 - Pull-up Setting Register E
        volatile uint32_t PCRF;  ///< Offset: 0x13C - Pull-up Setting Register F
        volatile uint32_t DDR0;  ///< Offset: 0x200 - Port input/output Direction Setting Register 0
        volatile uint32_t DDR1;  ///< Offset: 0x204 - Port input/output Direction Setting Register 1
        volatile uint32_t DDR2;  ///< Offset: 0x208 - Port input/output Direction Setting Register 2
        volatile uint32_t DDR3;  ///< Offset: 0x20C - Port input/output Direction Setting Register 3
        volatile uint32_t DDR4;  ///< Offset: 0x210 - Port input/output Direction Setting Register 4
        volatile uint32_t DDR5;  ///< Offset: 0x214 - Port input/output Direction Setting Register 5
        volatile uint32_t DDR6;  ///< Offset: 0x218 - Port input/output Direction Setting Register 6
        volatile uint32_t DDR7;  ///< Offset: 0x21C - Port input/output Direction Setting Register 7
        volatile uint32_t DDR8;  ///< Offset: 0x220 - Port input/output Direction Setting Register 8
        volatile uint32_t DDR9;  ///< Offset: 0x224 - Port input/output Direction Setting Register 9
        volatile uint32_t DDRA;  ///< Offset: 0x228 - Port input/output Direction Setting Register A
        volatile uint32_t DDRB;  ///< Offset: 0x22C - Port input/output Direction Setting Register B
        volatile uint32_t DDRC;  ///< Offset: 0x230 - Port input/output Direction Setting Register C
        volatile uint32_t DDRD;  ///< Offset: 0x234 - Port input/output Direction Setting Register D
        volatile uint32_t DDRE;  ///< Offset: 0x238 - Port input/output Direction Setting Register E
        volatile uint32_t DDRF;  ///< Offset: 0x23C - Port input/output Direction Setting Register F
        volatile uint32_t PDIR0;  ///< Offset: 0x300 - Port Input Data Register 0
        volatile uint32_t PDIR1;  ///< Offset: 0x304 - Port Input Data Register 1
        volatile uint32_t PDIR2;  ///< Offset: 0x308 - Port Input Data Register 2
        volatile uint32_t PDIR3;  ///< Offset: 0x30C - Port Input Data Register 3
        volatile uint32_t PDIR4;  ///< Offset: 0x310 - Port Input Data Register 4
        volatile uint32_t PDIR5;  ///< Offset: 0x314 - Port Input Data Register 5
        volatile uint32_t PDIR6;  ///< Offset: 0x318 - Port Input Data Register 6
        volatile uint32_t PDIR7;  ///< Offset: 0x31C - Port Input Data Register 7
        volatile uint32_t PDIR8;  ///< Offset: 0x320 - Port Input Data Register 8
        volatile uint32_t PDIR9;  ///< Offset: 0x324 - Port Input Data Register 9
        volatile uint32_t PDIRA;  ///< Offset: 0x328 - Port Input Data Register A
        volatile uint32_t PDIRB;  ///< Offset: 0x32C - Port Input Data Register B
        volatile uint32_t PDIRC;  ///< Offset: 0x330 - Port Input Data Register C
        volatile uint32_t PDIRD;  ///< Offset: 0x334 - Port Input Data Register D
        volatile uint32_t PDIRE;  ///< Offset: 0x338 - Port Input Data Register E
        volatile uint32_t PDIRF;  ///< Offset: 0x33C - Port Input Data Register F
        volatile uint32_t PDOR0;  ///< Offset: 0x400 - Port Output Data Register 0
        volatile uint32_t PDOR1;  ///< Offset: 0x404 - Port Output Data Register 1
        volatile uint32_t PDOR2;  ///< Offset: 0x408 - Port Output Data Register 2
        volatile uint32_t PDOR3;  ///< Offset: 0x40C - Port Output Data Register 3
        volatile uint32_t PDOR4;  ///< Offset: 0x410 - Port Output Data Register 4
        volatile uint32_t PDOR5;  ///< Offset: 0x414 - Port Output Data Register 5
        volatile uint32_t PDOR6;  ///< Offset: 0x418 - Port Output Data Register 6
        volatile uint32_t PDOR7;  ///< Offset: 0x41C - Port Output Data Register 7
        volatile uint32_t PDOR8;  ///< Offset: 0x420 - Port Output Data Register 8
        volatile uint32_t PDOR9;  ///< Offset: 0x424 - Port Output Data Register 9
        volatile uint32_t PDORA;  ///< Offset: 0x428 - Port Output Data Register A
        volatile uint32_t PDORB;  ///< Offset: 0x42C - Port Output Data Register B
        volatile uint32_t PDORC;  ///< Offset: 0x430 - Port Output Data Register C
        volatile uint32_t PDORD;  ///< Offset: 0x434 - Port Output Data Register D
        volatile uint32_t PDORE;  ///< Offset: 0x438 - Port Output Data Register E
        volatile uint32_t PDORF;  ///< Offset: 0x43C - Port Output Data Register F
        volatile uint32_t ADE;  ///< Offset: 0x500 - Analog Input Setting Register
        volatile uint32_t SPSR;  ///< Offset: 0x580 - Special Port Setting Register
        volatile uint32_t EPFR00;  ///< Offset: 0x600 - Extended Pin Function Setting Register 00
        volatile uint32_t EPFR01;  ///< Offset: 0x604 - Extended Pin Function Setting Register 01
        volatile uint32_t EPFR02;  ///< Offset: 0x608 - Extended Pin Function Setting Register 02
        volatile uint32_t EPFR03;  ///< Offset: 0x60C - Extended Pin Function Setting Register 03
        volatile uint32_t EPFR04;  ///< Offset: 0x610 - Extended Pin Function Setting Register 04
        volatile uint32_t EPFR05;  ///< Offset: 0x614 - Extended Pin Function Setting Register 05
        volatile uint32_t EPFR06;  ///< Offset: 0x618 - Extended Pin Function Setting Register 06
        volatile uint32_t EPFR07;  ///< Offset: 0x61C - Extended Pin Function Setting Register 07
        volatile uint32_t EPFR08;  ///< Offset: 0x620 - Extended Pin Function Setting Register 08
        volatile uint32_t EPFR09;  ///< Offset: 0x624 - Extended Pin Function Setting Register 09
        volatile uint32_t EPFR10;  ///< Offset: 0x628 - Extended Pin Function Setting Register 10
        volatile uint32_t EPFR11;  ///< Offset: 0x62C - Extended Pin Function Setting Register 11
        volatile uint32_t EPFR12;  ///< Offset: 0x630 - Extended Pin Function Setting Register 12
        volatile uint32_t EPFR13;  ///< Offset: 0x634 - Extended Pin Function Setting Register 13
        volatile uint32_t EPFR14;  ///< Offset: 0x638 - Extended Pin Function Setting Register 14
        volatile uint32_t EPFR15;  ///< Offset: 0x63C - Extended Pin Function Setting Register 15
        volatile uint32_t EPFR16;  ///< Offset: 0x640 - Extended Pin Function Setting Register 16
        volatile uint32_t EPFR17;  ///< Offset: 0x644 - Extended Pin Function Setting Register 17
        volatile uint32_t EPFR18;  ///< Offset: 0x648 - Extended Pin Function Setting Register 18
        volatile uint32_t EPFR19;  ///< Offset: 0x64C - Extended Pin Function Setting Register 19
        volatile uint32_t EPFR20;  ///< Offset: 0x650 - Extended Pin Function Setting Register 20
        volatile uint32_t EPFR21;  ///< Offset: 0x654 - Extended Pin Function Setting Register 21
        volatile uint32_t EPFR22;  ///< Offset: 0x658 - Extended Pin Function Setting Register 22
        volatile uint32_t EPFR23;  ///< Offset: 0x65C - Extended Pin Function Setting Register 23
        volatile uint32_t EPFR24;  ///< Offset: 0x660 - Extended Pin Function Setting Register 24
        volatile uint32_t EPFR25;  ///< Offset: 0x664 - Extended Pin Function Setting Register 25
        volatile uint32_t EPFR26;  ///< Offset: 0x668 - Extended Pin Function Setting Register 26
        volatile uint32_t PZR0;  ///< Offset: 0x700 - Port Pseudo Open Drain Setting Register 0
        volatile uint32_t PZR1;  ///< Offset: 0x704 - Port Pseudo Open Drain Setting Register 1
        volatile uint32_t PZR2;  ///< Offset: 0x708 - Port Pseudo Open Drain Setting Register 2
        volatile uint32_t PZR3;  ///< Offset: 0x70C - Port Pseudo Open Drain Setting Register 3
        volatile uint32_t PZR4;  ///< Offset: 0x710 - Port Pseudo Open Drain Setting Register 4
        volatile uint32_t PZR5;  ///< Offset: 0x714 - Port Pseudo Open Drain Setting Register 5
        volatile uint32_t PZR6;  ///< Offset: 0x718 - Port Pseudo Open Drain Setting Register 6
        volatile uint32_t PZR7;  ///< Offset: 0x71C - Port Pseudo Open Drain Setting Register 7
        volatile uint32_t PZR8;  ///< Offset: 0x720 - Port Pseudo Open Drain Setting Register 8
        volatile uint32_t PZR9;  ///< Offset: 0x724 - Port Pseudo Open Drain Setting Register 9
        volatile uint32_t PZRA;  ///< Offset: 0x728 - Port Pseudo Open Drain Setting Register A
        volatile uint32_t PZRB;  ///< Offset: 0x72C - Port Pseudo Open Drain Setting Register B
        volatile uint32_t PZRC;  ///< Offset: 0x730 - Port Pseudo Open Drain Setting Register C
        volatile uint32_t PZRD;  ///< Offset: 0x734 - Port Pseudo Open Drain Setting Register D
        volatile uint32_t PZRE;  ///< Offset: 0x738 - Port Pseudo Open Drain Setting Register E
        volatile uint32_t PZRF;  ///< Offset: 0x73C - Port Pseudo Open Drain Setting Register F
        volatile uint32_t PDSR0;  ///< Offset: 0x740 - /dr
        volatile uint32_t PDSR1;  ///< Offset: 0x744 - /dr
        volatile uint32_t PDSR2;  ///< Offset: 0x748 - /dr
        volatile uint32_t PDSR3;  ///< Offset: 0x74C - /dr
        volatile uint32_t PDSR4;  ///< Offset: 0x750 - /dr
        volatile uint32_t PDSR5;  ///< Offset: 0x754 - /dr
        volatile uint32_t PDSR6;  ///< Offset: 0x758 - /dr
        volatile uint32_t PDSR7;  ///< Offset: 0x75C - /dr
        volatile uint32_t PDSR8;  ///< Offset: 0x760 - /dr
        volatile uint32_t PDSR9;  ///< Offset: 0x764 - /dr
        volatile uint32_t PDSRA;  ///< Offset: 0x768 - /dr
        volatile uint32_t PDSRB;  ///< Offset: 0x76C - /dr
        volatile uint32_t PDSRC;  ///< Offset: 0x770 - /dr
        volatile uint32_t PDSRD;  ///< Offset: 0x774 - /dr
        volatile uint32_t PDSRE;  ///< Offset: 0x778 - /dr
        volatile uint32_t PDSRF;  ///< Offset: 0x77C - /dr
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// PFR0 Register bits
    namespace pfr0_bits {
        constexpr uint32_t P0A = (1U << 10);  ///< Bit10 of PFR0
        constexpr uint32_t P09 = (1U << 9);  ///< Bit9 of PFR0
        constexpr uint32_t P08 = (1U << 8);  ///< Bit8 of PFR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of PFR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of PFR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of PFR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of PFR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of PFR0
    }

    /// PFR1 Register bits
    namespace pfr1_bits {
        constexpr uint32_t P1F = (1U << 15);  ///< Bit15 of PFR1
        constexpr uint32_t P1E = (1U << 14);  ///< Bit14 of PFR1
        constexpr uint32_t P1D = (1U << 13);  ///< Bit13 of PFR1
        constexpr uint32_t P1C = (1U << 12);  ///< Bit12 of PFR1
        constexpr uint32_t P1B = (1U << 11);  ///< Bit11 of PFR1
        constexpr uint32_t P1A = (1U << 10);  ///< Bit10 of PFR1
        constexpr uint32_t P19 = (1U << 9);  ///< Bit9 of PFR1
        constexpr uint32_t P18 = (1U << 8);  ///< Bit8 of PFR1
        constexpr uint32_t P17 = (1U << 7);  ///< Bit7 of PFR1
        constexpr uint32_t P16 = (1U << 6);  ///< Bit6 of PFR1
        constexpr uint32_t P15 = (1U << 5);  ///< Bit5 of PFR1
        constexpr uint32_t P14 = (1U << 4);  ///< Bit4 of PFR1
        constexpr uint32_t P13 = (1U << 3);  ///< Bit3 of PFR1
        constexpr uint32_t P12 = (1U << 2);  ///< Bit2 of PFR1
        constexpr uint32_t P11 = (1U << 1);  ///< Bit1 of PFR1
        constexpr uint32_t P10 = (1U << 0);  ///< Bit0 of PFR1
    }

    /// PFR2 Register bits
    namespace pfr2_bits {
        constexpr uint32_t P2A = (1U << 10);  ///< Bit10 of PFR2
        constexpr uint32_t P29 = (1U << 9);  ///< Bit9 of PFR2
        constexpr uint32_t P28 = (1U << 8);  ///< Bit8 of PFR2
        constexpr uint32_t P27 = (1U << 7);  ///< Bit7 of PFR2
        constexpr uint32_t P26 = (1U << 6);  ///< Bit6 of PFR2
        constexpr uint32_t P25 = (1U << 5);  ///< Bit5 of PFR2
        constexpr uint32_t P24 = (1U << 4);  ///< Bit4 of PFR2
        constexpr uint32_t P23 = (1U << 3);  ///< Bit3 of PFR2
        constexpr uint32_t P22 = (1U << 2);  ///< Bit2 of PFR2
        constexpr uint32_t P21 = (1U << 1);  ///< Bit1 of PFR2
        constexpr uint32_t P20 = (1U << 0);  ///< Bit0 of PFR2
    }

    /// PFR3 Register bits
    namespace pfr3_bits {
        constexpr uint32_t P3E = (1U << 14);  ///< Bit14 of PFR3
        constexpr uint32_t P3D = (1U << 13);  ///< Bit13 of PFR3
        constexpr uint32_t P3C = (1U << 12);  ///< Bit12 of PFR3
        constexpr uint32_t P3B = (1U << 11);  ///< Bit11 of PFR3
        constexpr uint32_t P3A = (1U << 10);  ///< Bit10 of PFR3
        constexpr uint32_t P39 = (1U << 9);  ///< Bit9 of PFR3
        constexpr uint32_t P38 = (1U << 8);  ///< Bit8 of PFR3
        constexpr uint32_t P37 = (1U << 7);  ///< Bit7 of PFR3
        constexpr uint32_t P36 = (1U << 6);  ///< Bit6 of PFR3
        constexpr uint32_t P35 = (1U << 5);  ///< Bit5 of PFR3
        constexpr uint32_t P34 = (1U << 4);  ///< Bit4 of PFR3
        constexpr uint32_t P33 = (1U << 3);  ///< Bit3 of PFR3
        constexpr uint32_t P32 = (1U << 2);  ///< Bit2 of PFR3
        constexpr uint32_t P31 = (1U << 1);  ///< Bit1 of PFR3
        constexpr uint32_t P30 = (1U << 0);  ///< Bit0 of PFR3
    }

    /// PFR4 Register bits
    namespace pfr4_bits {
        constexpr uint32_t P4E = (1U << 14);  ///< Bit14 of PFR4
        constexpr uint32_t P4D = (1U << 13);  ///< Bit13 of PFR4
        constexpr uint32_t P4C = (1U << 12);  ///< Bit12 of PFR4
        constexpr uint32_t P4B = (1U << 11);  ///< Bit11 of PFR4
        constexpr uint32_t P4A = (1U << 10);  ///< Bit10 of PFR4
        constexpr uint32_t P49 = (1U << 9);  ///< Bit9 of PFR4
        constexpr uint32_t P48 = (1U << 8);  ///< Bit8 of PFR4
        constexpr uint32_t P47 = (1U << 7);  ///< Bit7 of PFR4
        constexpr uint32_t P46 = (1U << 6);  ///< Bit6 of PFR4
        constexpr uint32_t P45 = (1U << 5);  ///< Bit5 of PFR4
        constexpr uint32_t P44 = (1U << 4);  ///< Bit4 of PFR4
        constexpr uint32_t P43 = (1U << 3);  ///< Bit3 of PFR4
        constexpr uint32_t P42 = (1U << 2);  ///< Bit2 of PFR4
        constexpr uint32_t P41 = (1U << 1);  ///< Bit1 of PFR4
        constexpr uint32_t P40 = (1U << 0);  ///< Bit0 of PFR4
    }

    /// PFR5 Register bits
    namespace pfr5_bits {
        constexpr uint32_t P5F = (1U << 15);  ///< Bit15 of PFR5
        constexpr uint32_t P5E = (1U << 14);  ///< Bit14 of PFR5
        constexpr uint32_t P5D = (1U << 13);  ///< Bit13 of PFR5
        constexpr uint32_t P5C = (1U << 12);  ///< Bit12 of PFR5
        constexpr uint32_t P5B = (1U << 11);  ///< Bit11 of PFR5
        constexpr uint32_t P5A = (1U << 10);  ///< Bit10 of PFR5
        constexpr uint32_t P59 = (1U << 9);  ///< Bit9 of PFR5
        constexpr uint32_t P58 = (1U << 8);  ///< Bit8 of PFR5
        constexpr uint32_t P57 = (1U << 7);  ///< Bit7 of PFR5
        constexpr uint32_t P56 = (1U << 6);  ///< Bit6 of PFR5
        constexpr uint32_t P55 = (1U << 5);  ///< Bit5 of PFR5
        constexpr uint32_t P54 = (1U << 4);  ///< Bit4 of PFR5
        constexpr uint32_t P53 = (1U << 3);  ///< Bit3 of PFR5
        constexpr uint32_t P52 = (1U << 2);  ///< Bit2 of PFR5
        constexpr uint32_t P51 = (1U << 1);  ///< Bit1 of PFR5
        constexpr uint32_t P50 = (1U << 0);  ///< Bit0 of PFR5
    }

    /// PFR6 Register bits
    namespace pfr6_bits {
        constexpr uint32_t P6E = (1U << 14);  ///< Bit14 of PFR6
        constexpr uint32_t P6D = (1U << 13);  ///< Bit13 of PFR6
        constexpr uint32_t P6C = (1U << 12);  ///< Bit12 of PFR6
        constexpr uint32_t P6B = (1U << 11);  ///< Bit11 of PFR6
        constexpr uint32_t P6A = (1U << 10);  ///< Bit10 of PFR6
        constexpr uint32_t P69 = (1U << 9);  ///< Bit9 of PFR6
        constexpr uint32_t P68 = (1U << 8);  ///< Bit8 of PFR6
        constexpr uint32_t P67 = (1U << 7);  ///< Bit7 of PFR6
        constexpr uint32_t P66 = (1U << 6);  ///< Bit6 of PFR6
        constexpr uint32_t P65 = (1U << 5);  ///< Bit5 of PFR6
        constexpr uint32_t P64 = (1U << 4);  ///< Bit4 of PFR6
        constexpr uint32_t P63 = (1U << 3);  ///< Bit3 of PFR6
        constexpr uint32_t P62 = (1U << 2);  ///< Bit2 of PFR6
        constexpr uint32_t P61 = (1U << 1);  ///< Bit1 of PFR6
        constexpr uint32_t P60 = (1U << 0);  ///< Bit0 of PFR6
    }

    /// PFR7 Register bits
    namespace pfr7_bits {
        constexpr uint32_t P7E = (1U << 14);  ///< Bit14 of PFR7
        constexpr uint32_t P7D = (1U << 13);  ///< Bit13 of PFR7
        constexpr uint32_t P7C = (1U << 12);  ///< Bit12 of PFR7
        constexpr uint32_t P7B = (1U << 11);  ///< Bit11 of PFR7
        constexpr uint32_t P7A = (1U << 10);  ///< Bit10 of PFR7
        constexpr uint32_t P79 = (1U << 9);  ///< Bit9 of PFR7
        constexpr uint32_t P78 = (1U << 8);  ///< Bit8 of PFR7
        constexpr uint32_t P77 = (1U << 7);  ///< Bit7 of PFR7
        constexpr uint32_t P76 = (1U << 6);  ///< Bit6 of PFR7
        constexpr uint32_t P75 = (1U << 5);  ///< Bit5 of PFR7
        constexpr uint32_t P74 = (1U << 4);  ///< Bit4 of PFR7
        constexpr uint32_t P73 = (1U << 3);  ///< Bit3 of PFR7
        constexpr uint32_t P72 = (1U << 2);  ///< Bit2 of PFR7
        constexpr uint32_t P71 = (1U << 1);  ///< Bit1 of PFR7
        constexpr uint32_t P70 = (1U << 0);  ///< Bit0 of PFR7
    }

    /// PFR8 Register bits
    namespace pfr8_bits {
        constexpr uint32_t P83 = (1U << 3);  ///< Bit3 of PFR8
        constexpr uint32_t P82 = (1U << 2);  ///< Bit2 of PFR8
        constexpr uint32_t P81 = (1U << 1);  ///< Bit1 of PFR8
        constexpr uint32_t P80 = (1U << 0);  ///< Bit0 of PFR8
    }

    /// PFR9 Register bits
    namespace pfr9_bits {
        constexpr uint32_t P97 = (1U << 7);  ///< Bit7 of PFR9
        constexpr uint32_t P96 = (1U << 6);  ///< Bit6 of PFR9
        constexpr uint32_t P95 = (1U << 5);  ///< Bit5 of PFR9
        constexpr uint32_t P94 = (1U << 4);  ///< Bit4 of PFR9
        constexpr uint32_t P93 = (1U << 3);  ///< Bit3 of PFR9
        constexpr uint32_t P92 = (1U << 2);  ///< Bit2 of PFR9
        constexpr uint32_t P91 = (1U << 1);  ///< Bit1 of PFR9
        constexpr uint32_t P90 = (1U << 0);  ///< Bit0 of PFR9
    }

    /// PFRA Register bits
    namespace pfra_bits {
        constexpr uint32_t PAF = (1U << 15);  ///< Bit15 of PFRA
        constexpr uint32_t PAE = (1U << 14);  ///< Bit14 of PFRA
        constexpr uint32_t PAD = (1U << 13);  ///< Bit13 of PFRA
        constexpr uint32_t PAC = (1U << 12);  ///< Bit12 of PFRA
        constexpr uint32_t PAB = (1U << 11);  ///< Bit11 of PFRA
        constexpr uint32_t PAA = (1U << 10);  ///< Bit10 of PFRA
        constexpr uint32_t PA9 = (1U << 9);  ///< Bit9 of PFRA
        constexpr uint32_t PA8 = (1U << 8);  ///< Bit8 of PFRA
        constexpr uint32_t PA7 = (1U << 7);  ///< Bit7 of PFRA
        constexpr uint32_t PA6 = (1U << 6);  ///< Bit6 of PFRA
        constexpr uint32_t PA5 = (1U << 5);  ///< Bit5 of PFRA
        constexpr uint32_t PA4 = (1U << 4);  ///< Bit4 of PFRA
        constexpr uint32_t PA3 = (1U << 3);  ///< Bit3 of PFRA
        constexpr uint32_t PA2 = (1U << 2);  ///< Bit2 of PFRA
        constexpr uint32_t PA1 = (1U << 1);  ///< Bit1 of PFRA
        constexpr uint32_t PA0 = (1U << 0);  ///< Bit0 of PFRA
    }

    /// PFRB Register bits
    namespace pfrb_bits {
        constexpr uint32_t PBF = (1U << 15);  ///< Bit15 of PFRB
        constexpr uint32_t PBE = (1U << 14);  ///< Bit14 of PFRB
        constexpr uint32_t PBD = (1U << 13);  ///< Bit13 of PFRB
        constexpr uint32_t PBC = (1U << 12);  ///< Bit12 of PFRB
        constexpr uint32_t PBB = (1U << 11);  ///< Bit11 of PFRB
        constexpr uint32_t PBA = (1U << 10);  ///< Bit10 of PFRB
        constexpr uint32_t PB9 = (1U << 9);  ///< Bit9 of PFRB
        constexpr uint32_t PB8 = (1U << 8);  ///< Bit8 of PFRB
        constexpr uint32_t PB7 = (1U << 7);  ///< Bit7 of PFRB
        constexpr uint32_t PB6 = (1U << 6);  ///< Bit6 of PFRB
        constexpr uint32_t PB5 = (1U << 5);  ///< Bit5 of PFRB
        constexpr uint32_t PB4 = (1U << 4);  ///< Bit4 of PFRB
        constexpr uint32_t PB3 = (1U << 3);  ///< Bit3 of PFRB
        constexpr uint32_t PB2 = (1U << 2);  ///< Bit2 of PFRB
        constexpr uint32_t PB1 = (1U << 1);  ///< Bit1 of PFRB
        constexpr uint32_t PB0 = (1U << 0);  ///< Bit0 of PFRB
    }

    /// PFRC Register bits
    namespace pfrc_bits {
        constexpr uint32_t PCF = (1U << 15);  ///< Bit15 of PFRC
        constexpr uint32_t PCE = (1U << 14);  ///< Bit14 of PFRC
        constexpr uint32_t PCD = (1U << 13);  ///< Bit13 of PFRC
        constexpr uint32_t PCC = (1U << 12);  ///< Bit12 of PFRC
        constexpr uint32_t PCB = (1U << 11);  ///< Bit11 of PFRC
        constexpr uint32_t PCA = (1U << 10);  ///< Bit10 of PFRC
        constexpr uint32_t PC9 = (1U << 9);  ///< Bit9 of PFRC
        constexpr uint32_t PC8 = (1U << 8);  ///< Bit8 of PFRC
        constexpr uint32_t PC7 = (1U << 7);  ///< Bit7 of PFRC
        constexpr uint32_t PC6 = (1U << 6);  ///< Bit6 of PFRC
        constexpr uint32_t PC5 = (1U << 5);  ///< Bit5 of PFRC
        constexpr uint32_t PC4 = (1U << 4);  ///< Bit4 of PFRC
        constexpr uint32_t PC3 = (1U << 3);  ///< Bit3 of PFRC
        constexpr uint32_t PC2 = (1U << 2);  ///< Bit2 of PFRC
        constexpr uint32_t PC1 = (1U << 1);  ///< Bit1 of PFRC
        constexpr uint32_t PC0 = (1U << 0);  ///< Bit0 of PFRC
    }

    /// PFRD Register bits
    namespace pfrd_bits {
        constexpr uint32_t PD2 = (1U << 2);  ///< Bit2 of PFRD
        constexpr uint32_t PD1 = (1U << 1);  ///< Bit1 of PFRD
        constexpr uint32_t PD0 = (1U << 0);  ///< Bit0 of PFRD
    }

    /// PFRE Register bits
    namespace pfre_bits {
        constexpr uint32_t PE3 = (1U << 3);  ///< Bit3 of PFRE
        constexpr uint32_t PE2 = (1U << 2);  ///< Bit2 of PFRE
        constexpr uint32_t PE0 = (1U << 0);  ///< Bit0 of PFRE
    }

    /// PFRF Register bits
    namespace pfrf_bits {
        constexpr uint32_t PFC = (1U << 12);  ///< Bit12 of PFRF
        constexpr uint32_t PFB = (1U << 11);  ///< Bit11 of PFRF
        constexpr uint32_t PFA = (1U << 10);  ///< Bit10 of PFRF
        constexpr uint32_t PF9 = (1U << 9);  ///< Bit9 of PFRF
        constexpr uint32_t PF8 = (1U << 8);  ///< Bit8 of PFRF
        constexpr uint32_t PF7 = (1U << 7);  ///< Bit7 of PFRF
        constexpr uint32_t PF6 = (1U << 6);  ///< Bit6 of PFRF
        constexpr uint32_t PF5 = (1U << 5);  ///< Bit5 of PFRF
        constexpr uint32_t PF4 = (1U << 4);  ///< Bit4 of PFRF
        constexpr uint32_t PF3 = (1U << 3);  ///< Bit3 of PFRF
        constexpr uint32_t PF2 = (1U << 2);  ///< Bit2 of PFRF
        constexpr uint32_t PF1 = (1U << 1);  ///< Bit1 of PFRF
        constexpr uint32_t PF0 = (1U << 0);  ///< Bit0 of PFRF
    }

    /// DDR0 Register bits
    namespace ddr0_bits {
        constexpr uint32_t P0E = (1U << 14);  ///< Bit14 of DDR0
        constexpr uint32_t P0D = (1U << 13);  ///< Bit13 of DDR0
        constexpr uint32_t P0C = (1U << 12);  ///< Bit12 of DDR0
        constexpr uint32_t P0B = (1U << 11);  ///< Bit11 of DDR0
        constexpr uint32_t P0A = (1U << 10);  ///< Bit10 of DDR0
        constexpr uint32_t P09 = (1U << 9);  ///< Bit9 of DDR0
        constexpr uint32_t P08 = (1U << 8);  ///< Bit8 of DDR0
        constexpr uint32_t P07 = (1U << 7);  ///< Bit7 of DDR0
        constexpr uint32_t P06 = (1U << 6);  ///< Bit6 of DDR0
        constexpr uint32_t P05 = (1U << 5);  ///< Bit5 of DDR0
        constexpr uint32_t P04 = (1U << 4);  ///< Bit4 of DDR0
        constexpr uint32_t P03 = (1U << 3);  ///< Bit3 of DDR0
        constexpr uint32_t P02 = (1U << 2);  ///< Bit2 of DDR0
        constexpr uint32_t P01 = (1U << 1);  ///< Bit1 of DDR0
        constexpr uint32_t P00 = (1U << 0);  ///< Bit0 of DDR0
    }

    /// ADE Register bits
    namespace ade_bits {
        constexpr uint32_t AN31 = (1U << 31);  ///< Bit31 of ADE
        constexpr uint32_t AN30 = (1U << 30);  ///< Bit30 of ADE
        constexpr uint32_t AN29 = (1U << 29);  ///< Bit29 of ADE
        constexpr uint32_t AN28 = (1U << 28);  ///< Bit28 of ADE
        constexpr uint32_t AN27 = (1U << 27);  ///< Bit27 of ADE
        constexpr uint32_t AN26 = (1U << 26);  ///< Bit26 of ADE
        constexpr uint32_t AN25 = (1U << 25);  ///< Bit25 of ADE
        constexpr uint32_t AN24 = (1U << 24);  ///< Bit24 of ADE
        constexpr uint32_t AN23 = (1U << 23);  ///< Bit23 of ADE
        constexpr uint32_t AN22 = (1U << 22);  ///< Bit22 of ADE
        constexpr uint32_t AN21 = (1U << 21);  ///< Bit21 of ADE
        constexpr uint32_t AN20 = (1U << 20);  ///< Bit20 of ADE
        constexpr uint32_t AN19 = (1U << 19);  ///< Bit19 of ADE
        constexpr uint32_t AN18 = (1U << 18);  ///< Bit18 of ADE
        constexpr uint32_t AN17 = (1U << 17);  ///< Bit17 of ADE
        constexpr uint32_t AN16 = (1U << 16);  ///< Bit16 of ADE
        constexpr uint32_t AN15 = (1U << 15);  ///< Bit15 of ADE
        constexpr uint32_t AN14 = (1U << 14);  ///< Bit14 of ADE
        constexpr uint32_t AN13 = (1U << 13);  ///< Bit13 of ADE
        constexpr uint32_t AN12 = (1U << 12);  ///< Bit12 of ADE
        constexpr uint32_t AN11 = (1U << 11);  ///< Bit11 of ADE
        constexpr uint32_t AN10 = (1U << 10);  ///< Bit10 of ADE
        constexpr uint32_t AN09 = (1U << 9);  ///< Bit9 of ADE
        constexpr uint32_t AN08 = (1U << 8);  ///< Bit8 of ADE
        constexpr uint32_t AN07 = (1U << 7);  ///< Bit7 of ADE
        constexpr uint32_t AN06 = (1U << 6);  ///< Bit6 of ADE
        constexpr uint32_t AN05 = (1U << 5);  ///< Bit5 of ADE
        constexpr uint32_t AN04 = (1U << 4);  ///< Bit4 of ADE
        constexpr uint32_t AN03 = (1U << 3);  ///< Bit3 of ADE
        constexpr uint32_t AN02 = (1U << 2);  ///< Bit2 of ADE
        constexpr uint32_t AN01 = (1U << 1);  ///< Bit1 of ADE
        constexpr uint32_t AN00 = (1U << 0);  ///< Bit0 of ADE
    }

    /// SPSR Register bits
    namespace spsr_bits {
        constexpr uint32_t USB1C = (1U << 5);  ///< USB (ch.1) Pin Setting bit
        constexpr uint32_t USB0C = (1U << 4);  ///< USB (ch.0) Pin Setting bit
        constexpr uint32_t MAINXC = (2 << 2);  ///< Main Clock (Oscillation) Pin Setting bits
    }

    /// EPFR00 Register bits
    namespace epfr00_bits {
        constexpr uint32_t TRC3E = (1U << 27);  ///< TRACED Function Select bit 3
        constexpr uint32_t TRC2E = (1U << 26);  ///< TRACED Function Select bit 2
        constexpr uint32_t TRC1E = (1U << 25);  ///< TRACED Function Select bit 1
        constexpr uint32_t TRC0E = (1U << 24);  ///< TRACED Function Select bit 0
        constexpr uint32_t JTAGEN1S = (1U << 17);  ///< JTAG Function Select bit 1
        constexpr uint32_t JTAGEN0B = (1U << 16);  ///< JTAG Function Select bit 0
        constexpr uint32_t USBP1E = (1U << 13);  ///< USB ch.1 Function Select bit 1
        constexpr uint32_t USBP0E = (1U << 9);  ///< USB ch.0 Function Select bit 1
        constexpr uint32_t SUBOUTE = (2 << 6);  ///< Sub clock divide output function select bit
        constexpr uint32_t RTCCOE = (2 << 4);  ///< RTC clock output select bit
        constexpr uint32_t CROUTE = (2 << 1);  ///< Internal high-speed CR Oscillation Output Function Select bit
        constexpr uint32_t NMIS = (1U << 0);  ///< NMIX Function Select bit
    }

    /// EPFR01 Register bits
    namespace epfr01_bits {
        constexpr uint32_t IC03S = (3 << 29);  ///< IC03 Input Select bits
        constexpr uint32_t IC02S = (3 << 26);  ///< IC02 Input Select bits
        constexpr uint32_t IC01S = (3 << 23);  ///< IC01 Input Select bits
        constexpr uint32_t IC00S = (3 << 20);  ///< IC00 Input Select bits
        constexpr uint32_t FRCK0S = (2 << 18);  ///< FRCK0 Input Select bits
        constexpr uint32_t DTTI0S = (2 << 16);  ///< DTTIX0 Input Select bits
        constexpr uint32_t DTTI0C = (1U << 12);  ///< DTTIX0 Function Select bit
        constexpr uint32_t RTO05E = (2 << 10);  ///< RTO05 Output Select bits
        constexpr uint32_t RTO04E = (2 << 8);  ///< RTO04 Output Select bits
        constexpr uint32_t RTO03E = (2 << 6);  ///< RTO03 Output Select bits
        constexpr uint32_t RTO02E = (2 << 4);  ///< RTO02 Output Select bits
        constexpr uint32_t RTO01E = (2 << 2);  ///< RTO01 Output Select bits
        constexpr uint32_t RTO00E = (2 << 0);  ///< RTO00 Output Select bits
    }

    /// EPFR02 Register bits
    namespace epfr02_bits {
        constexpr uint32_t IC13S = (3 << 29);  ///< IC13 Input Select bits
        constexpr uint32_t IC12S = (3 << 26);  ///< IC13 Input Select bits
        constexpr uint32_t IC11S = (3 << 23);  ///< IC13 Input Select bits
        constexpr uint32_t IC10S = (3 << 20);  ///< IC13 Input Select bits
        constexpr uint32_t FRCK1S = (2 << 18);  ///< FRCK1 Input Select bits
        constexpr uint32_t DTTI1S = (2 << 16);  ///< DTTIX1 Input Select bits
        constexpr uint32_t DTTI1C = (1U << 12);  ///< DTTIX1 Function Select bit
        constexpr uint32_t RTO15E = (2 << 10);  ///< RTO15 Output Select bits
        constexpr uint32_t RTO14E = (2 << 8);  ///< RTO14 Output Select bits
        constexpr uint32_t RTO13E = (2 << 6);  ///< RTO13 Output Select bits
        constexpr uint32_t RTO12E = (2 << 4);  ///< RTO12 Output Select bits
        constexpr uint32_t RTO11E = (2 << 2);  ///< RTO11 Output Select bits
        constexpr uint32_t RTO10E = (2 << 0);  ///< RTO10 Output Select bits
    }

    /// EPFR03 Register bits
    namespace epfr03_bits {
        constexpr uint32_t IC23S = (3 << 29);  ///< IC23 Input Select bits
        constexpr uint32_t IC22S = (3 << 26);  ///< IC23 Input Select bits
        constexpr uint32_t IC21S = (3 << 23);  ///< IC23 Input Select bits
        constexpr uint32_t IC20S = (3 << 20);  ///< IC23 Input Select bits
        constexpr uint32_t FRCK2S = (2 << 18);  ///< FRCK2 Input Select bits
        constexpr uint32_t DTTI2S = (2 << 16);  ///< DTTIX2 Input Select bits
        constexpr uint32_t DTTI2C = (1U << 12);  ///< DTTIX2 Function Select bit
        constexpr uint32_t RTO25E = (2 << 10);  ///< RTO25 Output Select bits
        constexpr uint32_t RTO24E = (2 << 8);  ///< RTO24 Output Select bits
        constexpr uint32_t RTO23E = (2 << 6);  ///< RTO23 Output Select bits
        constexpr uint32_t RTO22E = (2 << 4);  ///< RTO22 Output Select bits
        constexpr uint32_t RTO21E = (2 << 2);  ///< RTO21 Output Select bits
        constexpr uint32_t RTO20E = (2 << 0);  ///< RTO20 Output Select bits
    }

    /// EPFR04 Register bits
    namespace epfr04_bits {
        constexpr uint32_t TIOB3S = (2 << 28);  ///< TIOB3 Input Select bits
        constexpr uint32_t TIOA3E = (2 << 26);  ///< TIOA3 Output Select bits
        constexpr uint32_t TIOA3S = (2 << 24);  ///< TIOA3 Input Select bits
        constexpr uint32_t TIOB2S = (2 << 20);  ///< TIOB2 Input Select bits
        constexpr uint32_t TIOA2E = (2 << 18);  ///< TIOA2 Output Select bits
        constexpr uint32_t TIOB1S = (2 << 12);  ///< TIOB1 Input Select bits
        constexpr uint32_t TIOA1E = (2 << 10);  ///< TIOA1 Output Select bits
        constexpr uint32_t TIOA1S = (2 << 8);  ///< TIOA1 Input Select bits
        constexpr uint32_t TIOB0S = (3 << 4);  ///< TIOB0 Input Select bits
        constexpr uint32_t TIOA0E = (2 << 2);  ///< TIOA0 Output Select bits
    }

    /// EPFR05 Register bits
    namespace epfr05_bits {
        constexpr uint32_t TIOB7S = (2 << 28);  ///< TIOB7 Input Select bits
        constexpr uint32_t TIOA7E = (2 << 26);  ///< TIOA7 Output Select bits
        constexpr uint32_t TIOA7S = (2 << 24);  ///< TIOA7 Input Select bits
        constexpr uint32_t TIOB6S = (2 << 20);  ///< TIOB6 Input Select bits
        constexpr uint32_t TIOA6E = (2 << 18);  ///< TIOA6 Output Select bits
        constexpr uint32_t TIOB5S = (2 << 12);  ///< TIOB5 Input Select bits
        constexpr uint32_t TIOA5E = (2 << 10);  ///< TIOA5 Output Select bits
        constexpr uint32_t TIOA5S = (2 << 8);  ///< TIOA5 Input Select bits
        constexpr uint32_t TIOB4S = (2 << 4);  ///< TIOB4 Input Select bits
        constexpr uint32_t TIOA4E = (2 << 2);  ///< TIOA4 Output Select bits
    }

    /// EPFR06 Register bits
    namespace epfr06_bits {
        constexpr uint32_t EINT15S = (2 << 30);  ///< External Interrupt 15 Input Select bits
        constexpr uint32_t EINT14S = (2 << 28);  ///< External Interrupt 14 Input Select bits
        constexpr uint32_t EINT13S = (2 << 26);  ///< External Interrupt 13 Input Select bits
        constexpr uint32_t EINT12S = (2 << 24);  ///< External Interrupt 12 Input Select bits
        constexpr uint32_t EINT11S = (2 << 22);  ///< External Interrupt 11 Input Select bits
        constexpr uint32_t EINT10S = (2 << 20);  ///< External Interrupt 10 Input Select bits
        constexpr uint32_t EINT09S = (2 << 18);  ///< External Interrupt 09 Input Select bits
        constexpr uint32_t EINT08S = (2 << 16);  ///< External Interrupt 08 Input Select bits
        constexpr uint32_t EINT07S = (2 << 14);  ///< External Interrupt 07 Input Select bits
        constexpr uint32_t EINT06S = (2 << 12);  ///< External Interrupt 06 Input Select bits
        constexpr uint32_t EINT05S = (2 << 10);  ///< External Interrupt 05 Input Select bits
        constexpr uint32_t EINT04S = (2 << 8);  ///< External Interrupt 04 Input Select bits
        constexpr uint32_t EINT03S = (2 << 6);  ///< External Interrupt 03 Input Select bits
        constexpr uint32_t EINT02S = (2 << 4);  ///< External Interrupt 02 Input Select bits
        constexpr uint32_t EINT01S = (2 << 2);  ///< External Interrupt 01 Input Select bits
        constexpr uint32_t EINT00S = (2 << 0);  ///< External Interrupt 00 Input Select bits
    }

    /// EPFR07 Register bits
    namespace epfr07_bits {
        constexpr uint32_t SCK3B = (2 << 26);  ///< SCK3 Input/Output Select bits
        constexpr uint32_t SOT3B = (2 << 24);  ///< SOT3 Input/Output Select bits
        constexpr uint32_t SIN3S = (2 << 22);  ///< SIN3 Input Select bits
        constexpr uint32_t SCK2B = (2 << 20);  ///< SCK2 Input/Output Select bits
        constexpr uint32_t SOT2B = (2 << 18);  ///< SOT2 Input/Output Select bits
        constexpr uint32_t SIN2S = (2 << 16);  ///< SIN2 Input Select bits
        constexpr uint32_t SCK1B = (2 << 14);  ///< SCK1 Input/Output Select bits
        constexpr uint32_t SOT1B = (2 << 12);  ///< SOT1 Input/Output Select bits
        constexpr uint32_t SIN1S = (2 << 10);  ///< SIN1 Input Select bits
        constexpr uint32_t SCK0B = (2 << 8);  ///< SCK0 Input/Output Select bits
        constexpr uint32_t SOT0B = (2 << 6);  ///< SOT0 Input/Output Select bits
        constexpr uint32_t SIN0S = (2 << 4);  ///< SIN0 Input Select bits
    }

    /// EPFR08 Register bits
    namespace epfr08_bits {
        constexpr uint32_t CTS5S = (2 << 30);  ///< CTS5 Input/Output Select bits
        constexpr uint32_t RTS5E = (2 << 28);  ///< RTS5 Input/Output Select bits
        constexpr uint32_t SCK7B = (2 << 26);  ///< SCK7 Input/Output Select bits
        constexpr uint32_t SOT7B = (2 << 24);  ///< SOT7 Input/Output Select bits
        constexpr uint32_t SIN7S = (2 << 22);  ///< SIN7 Input Select bits
        constexpr uint32_t SCK6B = (2 << 20);  ///< SCK6 Input/Output Select bits
        constexpr uint32_t SOT6B = (2 << 18);  ///< SOT6 Input/Output Select bits
        constexpr uint32_t SIN6S = (2 << 16);  ///< SIN6 Input Select bits
        constexpr uint32_t SCK5B = (2 << 14);  ///< SCK5 Input/Output Select bits
        constexpr uint32_t SOT5B = (2 << 12);  ///< SOT5 Input/Output Select bits
        constexpr uint32_t SIN5S = (2 << 10);  ///< SIN5 Input Select bits
        constexpr uint32_t SCK4B = (2 << 8);  ///< SCK4 Input/Output Select bits
        constexpr uint32_t SOT4B = (2 << 6);  ///< SOT4 Input/Output Select bits
        constexpr uint32_t SIN4S = (2 << 4);  ///< SIN4 Input Select bits
        constexpr uint32_t CTS4S = (2 << 2);  ///< CTS4 Input/Output Select bits
        constexpr uint32_t RTS4E = (2 << 0);  ///< RTS4 Input/Output Select bits
    }

    /// EPFR09 Register bits
    namespace epfr09_bits {
        constexpr uint32_t CTX1E = (2 << 30);  ///< CTX1E Output Select bits
        constexpr uint32_t CRX1S = (2 << 28);  ///< CRX1S Input Select bits
        constexpr uint32_t CTX0E = (2 << 26);  ///< CTX0E Output Select bits
        constexpr uint32_t CRX0S = (2 << 24);  ///< CRX0S Input Select bits
        constexpr uint32_t ADTRG2S = (4 << 20);  ///< ADTRG2 Input Select bits
        constexpr uint32_t ADTRG1S = (4 << 16);  ///< ADTRG1 Input Select bits
        constexpr uint32_t ADTRG0S = (4 << 12);  ///< ADTRG0 Input Select bits
        constexpr uint32_t QZIN1S = (2 << 10);  ///< QZIN1S Input Select bits
        constexpr uint32_t QBIN1S = (2 << 8);  ///< QBIN1S Input Select bits
        constexpr uint32_t QAIN1S = (2 << 6);  ///< QAIN1S Input Select bits
        constexpr uint32_t QZIN0S = (2 << 4);  ///< QZIN0S Input Select bits
        constexpr uint32_t QBIN0S = (2 << 2);  ///< QBIN0S Input Select bits
        constexpr uint32_t QAIN0S = (2 << 0);  ///< QAIN0S Input Select bits$
    }

    /// EPFR10 Register bits
    namespace epfr10_bits {
        constexpr uint32_t UEA24E = (1U << 31);  ///< UEA24E Output Select bit
        constexpr uint32_t UEA23E = (1U << 30);  ///< UEA23E Output Select bit
        constexpr uint32_t UEA22E = (1U << 29);  ///< UEA22E Output Select bit
        constexpr uint32_t UEA21E = (1U << 28);  ///< UEA21E Output Select bit
        constexpr uint32_t UEA20E = (1U << 27);  ///< UEA20E Output Select bit
        constexpr uint32_t UEA19E = (1U << 26);  ///< UEA19E Output Select bit
        constexpr uint32_t UEA18E = (1U << 25);  ///< UEA18E Output Select bit
        constexpr uint32_t UEA17E = (1U << 24);  ///< UEA17E Output Select bit
        constexpr uint32_t UEA16E = (1U << 23);  ///< UEA16E Output Select bit
        constexpr uint32_t UEA15E = (1U << 22);  ///< UEA15E Output Select bit
        constexpr uint32_t UEA14E = (1U << 21);  ///< UEA14E Output Select bit
        constexpr uint32_t UEA13E = (1U << 20);  ///< UEA13E Output Select bit
        constexpr uint32_t UEA12E = (1U << 19);  ///< UEA12E Output Select bit
        constexpr uint32_t UEA11E = (1U << 18);  ///< UEA11E Output Select bit
        constexpr uint32_t UEA10E = (1U << 17);  ///< UEA10E Output Select bit
        constexpr uint32_t UEA09E = (1U << 16);  ///< UEA09E Output Select bit
        constexpr uint32_t UEA08E = (1U << 15);  ///< UEA08E Output Select bit
        constexpr uint32_t UEAOOE = (1U << 14);  ///< UEAOOE Output Select bit
        constexpr uint32_t UECS7E = (1U << 13);  ///< UECS7E Output Select bit
        constexpr uint32_t UECS6E = (1U << 12);  ///< UECS6E Output Select bit
        constexpr uint32_t UECS5E = (1U << 11);  ///< UECS5E Output Select bit
        constexpr uint32_t UECS4E = (1U << 10);  ///< UECS4E Output Select bit
        constexpr uint32_t UECS3E = (1U << 9);  ///< UECS3E Output Select bit
        constexpr uint32_t UECS2E = (1U << 8);  ///< UECS2E Output Select bit
        constexpr uint32_t UECS1E = (1U << 7);  ///< UECS1E Output Select bit
        constexpr uint32_t UEFLSE = (1U << 6);  ///< UEFLSE Output Select bit
        constexpr uint32_t UEOEXE = (1U << 5);  ///< UEOEXE Output Select bit
        constexpr uint32_t UEDQME = (1U << 4);  ///< UEDQME Output Select bit
        constexpr uint32_t UEWEXE = (1U << 3);  ///< UEWEXE Output Select bit
        constexpr uint32_t UECLKE = (1U << 2);  ///< UECLKE Output Select bit
        constexpr uint32_t UEDTHB = (1U << 1);  ///< UEDTHB Input/Output Select bit
        constexpr uint32_t UEDEFB = (1U << 0);  ///< UEDEFB Input/Output Select bit
    }

    /// EPFR11 Register bits
    namespace epfr11_bits {
        constexpr uint32_t UERLC = (1U << 25);  ///< UERLC relocation select bit
        constexpr uint32_t UED15B = (1U << 24);  ///< UED15B Input/Output Select bit
        constexpr uint32_t UED14B = (1U << 23);  ///< UED14B Input/Output Select bit
        constexpr uint32_t UED13B = (1U << 22);  ///< UED13B Input/Output Select bit
        constexpr uint32_t UED12B = (1U << 21);  ///< UED12B Input/Output Select bit
        constexpr uint32_t UED11B = (1U << 20);  ///< UED11B Input/Output Select bit
        constexpr uint32_t UED10B = (1U << 19);  ///< UED10B Input/Output Select bit
        constexpr uint32_t UED09B = (1U << 18);  ///< UED09B Input/Output Select bit
        constexpr uint32_t UED08B = (1U << 17);  ///< UED08B Input/Output Select bit
        constexpr uint32_t UED07B = (1U << 16);  ///< UED07B Input/Output Select bit
        constexpr uint32_t UED06B = (1U << 15);  ///< UED06B Input/Output Select bit
        constexpr uint32_t UED05B = (1U << 14);  ///< UED05B Input/Output Select bit
        constexpr uint32_t UED04B = (1U << 13);  ///< UED04B Input/Output Select bit
        constexpr uint32_t UED03B = (1U << 12);  ///< UED03B Input/Output Select bit
        constexpr uint32_t UED02B = (1U << 11);  ///< UED02B Input/Output Select bit
        constexpr uint32_t UED01B = (1U << 10);  ///< UED01B Input/Output Select bit
        constexpr uint32_t UED00B = (1U << 9);  ///< UED00B Input/Output Select bit
        constexpr uint32_t UEA07E = (1U << 8);  ///< UEA07E Output Select bit
        constexpr uint32_t UEA06E = (1U << 7);  ///< UEA06E Output Select bit
        constexpr uint32_t UEA05E = (1U << 6);  ///< UEA05E Output Select bit
        constexpr uint32_t UEA04E = (1U << 5);  ///< UEA04E Output Select bit
        constexpr uint32_t UEA03E = (1U << 4);  ///< UEA03E Output Select bit
        constexpr uint32_t UEA02E = (1U << 3);  ///< UEA02E Output Select bit
        constexpr uint32_t UEA01E = (1U << 2);  ///< UEA01E Output Select bit
        constexpr uint32_t UECS0E = (1U << 1);  ///< UEA00E Output Select bit
        constexpr uint32_t UEALEE = (1U << 0);  ///< UEALEE Output Select bit
    }

    /// EPFR12 Register bits
    namespace epfr12_bits {
        constexpr uint32_t TIOB11S = (2 << 28);  ///< TIOB11 Input Select bits
        constexpr uint32_t TIOA11E = (2 << 26);  ///< TIOA11 Output Select bits
        constexpr uint32_t TIOA11S = (2 << 24);  ///< TIOA11 Input Select bits
        constexpr uint32_t TIOB10S = (2 << 20);  ///< TIOB10 Input Select bits
        constexpr uint32_t TIOA10E = (2 << 18);  ///< TIOA10 Output Select bits
        constexpr uint32_t TIOB9S = (2 << 12);  ///< TIOB9 Input Select bits
        constexpr uint32_t TIOA9E = (2 << 10);  ///< TIOA9 Output Select bits
        constexpr uint32_t TIOA9S = (2 << 8);  ///< TIOA9 Input Select bits
        constexpr uint32_t TIOB8S = (2 << 4);  ///< TIOB8 Input Select bits
        constexpr uint32_t TIOA8E = (2 << 2);  ///< TIOA8 Output Select bits
    }

    /// EPFR13 Register bits
    namespace epfr13_bits {
        constexpr uint32_t TIOB15S = (2 << 28);  ///< TIOB15 Input Select bits
        constexpr uint32_t TIOA15E = (2 << 26);  ///< TIOA15 Output Select bits
        constexpr uint32_t TIOA15S = (2 << 24);  ///< TIOA15 Input Select bits
        constexpr uint32_t TIOB14S = (2 << 20);  ///< TIOB14 Input Select bits
        constexpr uint32_t TIOA14E = (2 << 18);  ///< TIOA14 Output Select bits
        constexpr uint32_t TIOB13S = (2 << 12);  ///< TIOB13 Input Select bits
        constexpr uint32_t TIOA13E = (2 << 10);  ///< TIOA13 Output Select bits
        constexpr uint32_t TIOA13S = (2 << 8);  ///< TIOA13 Input Select bits
        constexpr uint32_t TIOB12S = (2 << 4);  ///< TIOB12 Input Select bits
        constexpr uint32_t TIOA12E = (2 << 2);  ///< TIOA12 Output Select bits
    }

    /// EPFR14 Register bits
    namespace epfr14_bits {
        constexpr uint32_t E_SPLC = (2 << 28);  ///< Input cutoff Select bit in Standby of input Pin for Ethernet-MAC
        constexpr uint32_t E_PSE = (1U << 27);  ///< PPS0_PPS1 Output Select bit for Ethernet-MAC
        constexpr uint32_t E_CKE = (1U << 26);  ///< E_COUT Output Select bit
        constexpr uint32_t E_MD1B = (1U << 25);  ///< E_MDO1 I/O Select bit
        constexpr uint32_t E_MD0B = (1U << 24);  ///< E_MDO0 I/O Select bit
        constexpr uint32_t E_MC1B = (1U << 23);  ///< E_MDC1 I/O Select bit
        constexpr uint32_t E_MC0E = (1U << 22);  ///< E_MDC0 Output Select bit
        constexpr uint32_t E_TE1E = (1U << 21);  ///< E_TXER0_TXEN1 Output Select bit
        constexpr uint32_t E_TE0E = (1U << 20);  ///< E_TXEN0 Output Select bit
        constexpr uint32_t E_TD1E = (1U << 19);  ///< E_TX02_TX10, E_TX03_TX11 Output Select bit
        constexpr uint32_t E_TD0E = (1U << 18);  ///< E_TX00, E_TX01 Output Select bit
        constexpr uint32_t QZIN2S = (2 << 4);  ///< QDU-ch.2 ZIN Input Pin bits
        constexpr uint32_t QBIN2S = (2 << 2);  ///< QDU-ch.2 BIN Input Pin bits
        constexpr uint32_t QAIN2S = (2 << 0);  ///< QDU-ch.2 AIN Input Pin bits
    }

    /// EPFR15 Register bits
    namespace epfr15_bits {
        constexpr uint32_t EINT31S = (2 << 30);  ///< External Interrupt 31 Input Select bits
        constexpr uint32_t EINT30S = (2 << 28);  ///< External Interrupt 30 Input Select bits
        constexpr uint32_t EINT29S = (2 << 26);  ///< External Interrupt 29 Input Select bits
        constexpr uint32_t EINT28S = (2 << 24);  ///< External Interrupt 28 Input Select bits
        constexpr uint32_t EINT27S = (2 << 22);  ///< External Interrupt 27 Input Select bits
        constexpr uint32_t EINT26S = (2 << 20);  ///< External Interrupt 26 Input Select bits
        constexpr uint32_t EINT25S = (2 << 18);  ///< External Interrupt 25 Input Select bits
        constexpr uint32_t EINT24S = (2 << 16);  ///< External Interrupt 24 Input Select bits
        constexpr uint32_t EINT23S = (2 << 14);  ///< External Interrupt 23 Input Select bits
        constexpr uint32_t EINT22S = (2 << 12);  ///< External Interrupt 22 Input Select bits
        constexpr uint32_t EINT21S = (2 << 10);  ///< External Interrupt 21 Input Select bits
        constexpr uint32_t EINT20S = (2 << 8);  ///< External Interrupt 20 Input Select bits
        constexpr uint32_t EINT19S = (2 << 6);  ///< External Interrupt 19 Input Select bits
        constexpr uint32_t EINT18S = (2 << 4);  ///< External Interrupt 18 Input Select bits
        constexpr uint32_t EINT17S = (2 << 2);  ///< External Interrupt 17 Input Select bits
        constexpr uint32_t EINT16S = (2 << 0);  ///< External Interrupt 16 Input Select bits
    }

    /// EPFR16 Register bits
    namespace epfr16_bits {
        constexpr uint32_t SFMPBC = (1U << 29);  ///< MFS ch.B I2C FastMode+ Select bit
        constexpr uint32_t SFMPAC = (1U << 28);  ///< MFS ch.A I2C FastMode+ Select bit
        constexpr uint32_t SCK11B = (2 << 26);  ///< SCK11 Input/Output Select bits
        constexpr uint32_t SOT11B = (2 << 24);  ///< SOT11 Input/Output Select bits
        constexpr uint32_t SIN11S = (2 << 22);  ///< SIN11 Input Select bits
        constexpr uint32_t SCK10B = (2 << 20);  ///< SCK10 Input/Output Select bits
        constexpr uint32_t SOT10B = (2 << 18);  ///< SOT10 Input/Output Select bits
        constexpr uint32_t SIN10S = (2 << 16);  ///< SIN10 Input Select bits
        constexpr uint32_t SCK9B = (2 << 14);  ///< SCK9 Input/Output Select bits
        constexpr uint32_t SOT9B = (2 << 12);  ///< SOT9 Input/Output Select bits
        constexpr uint32_t SIN9S = (2 << 10);  ///< SIN9 Input Select bits
        constexpr uint32_t SCK8B = (2 << 8);  ///< SCK8 Input/Output Select bits
        constexpr uint32_t SOT8B = (2 << 6);  ///< SOT8 Input/Output Select bits
        constexpr uint32_t SIN8S = (2 << 4);  ///< SIN8 Input Select bits
        constexpr uint32_t SCS7B = (2 << 2);  ///< SCS7 Input/Output Select bits
        constexpr uint32_t SCS6B = (2 << 0);  ///< SCS6 Select bits
    }

    /// EPFR17 Register bits
    namespace epfr17_bits {
        constexpr uint32_t SCK15B = (2 << 26);  ///< SCK15 Input/Output Select bits
        constexpr uint32_t SOT15B = (2 << 24);  ///< SOT15 Input/Output Select bits
        constexpr uint32_t SIN15S = (2 << 22);  ///< SIN15 Input Select bits
        constexpr uint32_t SCK14B = (2 << 20);  ///< SCK14 Input/Output Select bits
        constexpr uint32_t SOT14B = (2 << 18);  ///< SOT14 Input/Output Select bits
        constexpr uint32_t SIN14S = (2 << 16);  ///< SIN14 Input Select bits
        constexpr uint32_t SCK13B = (2 << 14);  ///< SCK13 Input/Output Select bits
        constexpr uint32_t SOT13B = (2 << 12);  ///< SOT13 Input/Output Select bits
        constexpr uint32_t SIN13S = (2 << 10);  ///< SIN13 Input Select bits
        constexpr uint32_t SCK12B = (2 << 8);  ///< SCK12 Input/Output Select bits
        constexpr uint32_t SOT12B = (2 << 6);  ///< SOT12 Input/Output Select bits
        constexpr uint32_t SIN12S = (2 << 4);  ///< SIN12 Input Select bits
    }

    /// EPFR18 Register bits
    namespace epfr18_bits {
        constexpr uint32_t SDWPS = (2 << 28);  ///< S_WP input select bits
        constexpr uint32_t SDCDS = (2 << 26);  ///< S_CD input select bits
        constexpr uint32_t SDDATA3B = (2 << 24);  ///< S_CD input select bits
        constexpr uint32_t SDDATA2B = (2 << 22);  ///< S_CD input select bits
        constexpr uint32_t SDDATA1B = (2 << 20);  ///< S_CD input select bits
        constexpr uint32_t SDDATA0B = (2 << 18);  ///< S_CD input select bits
        constexpr uint32_t SDCMDB = (2 << 16);  ///< S_CMD input/output select bits
        constexpr uint32_t SDCLKE = (2 << 14);  ///< S_CLK output select bits
        constexpr uint32_t QZIN3S = (2 << 8);  ///< QDU-ch3 ZIN input select bits
        constexpr uint32_t QBIN3S = (2 << 6);  ///< QDU-ch3 BIN input select bits
        constexpr uint32_t QAIN3S = (2 << 4);  ///< QDU-ch3 AIN input select bits
        constexpr uint32_t CECR1B = (2 << 2);  ///< CEC1 Input/Output Select bit
        constexpr uint32_t CECR0B = (2 << 0);  ///< CEC0 Input/Output Select bit
    }

    /// EPFR20 Register bits
    namespace epfr20_bits {
        constexpr uint32_t UED31B = (1U << 24);  ///< UED31B input/output select bit
        constexpr uint32_t UED30B = (1U << 23);  ///< UED30B input/output select bit
        constexpr uint32_t UED29B = (1U << 22);  ///< UED29B input/output select bit
        constexpr uint32_t UED28B = (1U << 21);  ///< UED28B input/output select bit
        constexpr uint32_t UED27B = (1U << 20);  ///< UED27B input/output select bit
        constexpr uint32_t UED26B = (1U << 19);  ///< UED26B input/output select bit
        constexpr uint32_t UED25B = (1U << 18);  ///< UED25B input/output select bit
        constexpr uint32_t UED24B = (1U << 17);  ///< UED24B input/output select bit
        constexpr uint32_t UED23B = (1U << 16);  ///< UED23B input/output select bit
        constexpr uint32_t UED22B = (1U << 15);  ///< UED22B input/output select bit
        constexpr uint32_t UED21B = (1U << 14);  ///< UED21B input/output select bit
        constexpr uint32_t UED20B = (1U << 13);  ///< UED20B input/output select bit
        constexpr uint32_t UED19B = (1U << 12);  ///< UED19B input/output select bit
        constexpr uint32_t UED18B = (1U << 11);  ///< UED18B input/output select bit
        constexpr uint32_t UED17B = (1U << 10);  ///< UED17B input/output select bit
        constexpr uint32_t UED16B = (1U << 9);  ///< UED16B input/output select bit
        constexpr uint32_t UEDTHHB = (1U << 8);  ///< UEDTHHB input/output select bit
        constexpr uint32_t UEDQM3E = (1U << 7);  ///< UEDQM3E output select bit
        constexpr uint32_t UEDQM2E = (1U << 6);  ///< UEDQM2E output select bit
        constexpr uint32_t UECSXE = (1U << 5);  ///< UECSXE output select bit
        constexpr uint32_t UEDWEXE = (1U << 4);  ///< UEDWEXE output select bit
        constexpr uint32_t UECASE = (1U << 3);  ///< UECASE output select bit
        constexpr uint32_t UERASE = (1U << 2);  ///< UERASE output select bit
        constexpr uint32_t UESMCEE = (1U << 1);  ///< UESMCEE output select bit
        constexpr uint32_t UESMCKE = (1U << 0);  ///< UESMCKE output select bit
    }

    /// EPFR23 Register bits
    namespace epfr23_bits {
        constexpr uint32_t SCS73E = (2 << 14);  ///< SCS73 Input Select bits
        constexpr uint32_t SCS72E = (2 << 12);  ///< SCS72 Input Select bits
        constexpr uint32_t SCS71E = (2 << 10);  ///< SCS71 Input Select bits
        constexpr uint32_t SCS70E = (2 << 8);  ///< SCS70 Input Select bits
        constexpr uint32_t SCS63E = (2 << 6);  ///< SCS63 Input Select bits
        constexpr uint32_t SCS62E = (2 << 4);  ///< SCS62 Input Select bits
        constexpr uint32_t SCS61E = (2 << 2);  ///< SCS61 Input Select bits
        constexpr uint32_t SCS60E = (2 << 0);  ///< SCS60 Input Select bits
    }

    /// EPFR24 Register bits
    namespace epfr24_bits {
        constexpr uint32_t I2SM4_SDO0E = (2 << 10);  ///< I2SDO0 Output Select bits
        constexpr uint32_t I2SM4_SDI0S = (2 << 8);  ///< I2SDI0 Input Select bits
        constexpr uint32_t I2SM4_WS0B = (2 << 6);  ///< I2SWS0 Input/Output Select bits
        constexpr uint32_t I2SM4_SCK0B = (2 << 4);  ///< I2SCK0 Input/Output Select bits
        constexpr uint32_t I2SM4_MCLK0E = (2 << 2);  ///< I2SMCLK0 Output Select bits
        constexpr uint32_t I2SM4_MCLK0S = (2 << 0);  ///< I2SMCLK0 Input Select bits
    }

    /// EPFR25 Register bits
    namespace epfr25_bits {
        constexpr uint32_t MCTX2E = (2 << 2);  ///< TX2 Output Select bits
        constexpr uint32_t MCRX2S = (2 << 0);  ///< RX2 Input Select bits
    }

    /// EPFR26 Register bits
    namespace epfr26_bits {
        constexpr uint32_t Q_IO3B = (2 << 16);  ///< Q_IO3 Input Select bits
        constexpr uint32_t Q_IO2B = (2 << 14);  ///< Q_IO2 Input Select bits
        constexpr uint32_t Q_IO1B = (2 << 12);  ///< Q_IO1 Input Select bits
        constexpr uint32_t Q_IO0B = (2 << 10);  ///< Q_IO0 Input Select bits
        constexpr uint32_t Q_CS3E = (2 << 8);  ///< Q_CS3 Input Select bits
        constexpr uint32_t Q_CS2E = (2 << 6);  ///< Q_CS2 Input Select bits
        constexpr uint32_t Q_CS1E = (2 << 4);  ///< Q_CS1 Input Select bits
        constexpr uint32_t Q_CS0E = (2 << 2);  ///< Q_CS0 Input Select bits
        constexpr uint32_t Q_SCKE = (2 << 0);  ///< Q_SCK Input Select bits
    }

}

// ============================================================================
// LVD Peripheral
// ============================================================================

namespace lvd {
    /// Base addresses
    constexpr uint32_t LVD_BASE = 0x40035000;

    /// LVD Register structure
    struct Registers {
        volatile uint32_t LVD_CTL;  ///< Offset: 0x00 - Low-voltage Detection Voltage Control Register
        volatile uint32_t LVD_STR;  ///< Offset: 0x04 - Low-voltage Detection Interrupt Factor Register
        volatile uint32_t LVD_CLR;  ///< Offset: 0x08 - Low-voltage Detection Interrupt Factor Clear Register
        volatile uint32_t LVD_RLR;  ///< Offset: 0x0C - Low-voltage Detection Voltage Protection Register
        volatile uint32_t LVD_STR2;  ///< Offset: 0x10 - Low-voltage Detection Circuit Status Register
    };

    /// Peripheral instances
    inline Registers* LVD = reinterpret_cast<Registers*>(LVD_BASE);

    // Bit definitions
    /// LVD_CTL Register bits
    namespace lvd_ctl_bits {
        constexpr uint32_t LVDIE = (1U << 7);  ///< Low-voltage detection interrupt enable bit
        constexpr uint32_t SVHI = (5 << 2);  ///< Low-voltage detection interrupt voltage setting bits
    }

    /// LVD_STR Register bits
    namespace lvd_str_bits {
        constexpr uint32_t LVDIR = (1U << 7);  ///< Low-voltage detection interrupt factor bit
    }

    /// LVD_CLR Register bits
    namespace lvd_clr_bits {
        constexpr uint32_t LVDCL = (1U << 7);  ///< Low-voltage detection interrupt factor clear bit
    }

    /// LVD_RLR Register bits
    namespace lvd_rlr_bits {
        constexpr uint32_t LVDLCK = (32 << 0);  ///< Low-voltage Detection Voltage Control Register protection bits
    }

    /// LVD_STR2 Register bits
    namespace lvd_str2_bits {
        constexpr uint32_t LVDIRDY = (1U << 7);  ///< Low-voltage detection interrupt status flag
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x40035100;

    /// DS Register structure
    struct Registers {
        volatile uint32_t RCK_CTL;  ///< Offset: 0x04 - Sub Clock Control Register
        volatile uint32_t PMD_CTL;  ///< Offset: 0x700 - RTC Mode Control Register
        volatile uint32_t WRFSR;  ///< Offset: 0x704 - Deep Standby Return Cause Register 1
        volatile uint32_t WIFSR;  ///< Offset: 0x708 - Deep Standby Return Cause Register 2
        volatile uint32_t WIER;  ///< Offset: 0x70C - Deep Standby Return Enable Register
        volatile uint32_t WILVR;  ///< Offset: 0x710 - WKUP Pin Input Level Register
        volatile uint32_t DSRAMR;  ///< Offset: 0x714 - Deep Standby RAM Retention Register
        volatile uint32_t BUR01;  ///< Offset: 0x800 - Backup Registers from 1
        volatile uint32_t BUR02;  ///< Offset: 0x801 - Backup Registers from 2
        volatile uint32_t BUR03;  ///< Offset: 0x802 - Backup Registers from 3
        volatile uint32_t BUR04;  ///< Offset: 0x803 - Backup Registers from 4
        volatile uint32_t BUR05;  ///< Offset: 0x804 - Backup Registers from 5
        volatile uint32_t BUR06;  ///< Offset: 0x805 - Backup Registers from 6
        volatile uint32_t BUR07;  ///< Offset: 0x806 - Backup Registers from 7
        volatile uint32_t BUR08;  ///< Offset: 0x807 - Backup Registers from 8
        volatile uint32_t BUR09;  ///< Offset: 0x808 - Backup Registers from 9
        volatile uint32_t BUR10;  ///< Offset: 0x809 - Backup Registers from 10
        volatile uint32_t BUR11;  ///< Offset: 0x80A - Backup Registers from 11
        volatile uint32_t BUR12;  ///< Offset: 0x80B - Backup Registers from 12
        volatile uint32_t BUR13;  ///< Offset: 0x80C - Backup Registers from 13
        volatile uint32_t BUR14;  ///< Offset: 0x80D - Backup Registers from 14
        volatile uint32_t BUR15;  ///< Offset: 0x80E - Backup Registers from 15
        volatile uint32_t BUR16;  ///< Offset: 0x80F - Backup Registers from 16
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// RCK_CTL Register bits
    namespace rck_ctl_bits {
        constexpr uint32_t CECCKE = (1U << 1);  ///< CEC clock control bit
        constexpr uint32_t RTCCKE = (1U << 0);  ///< RTC clock control bit
    }

    /// PMD_CTL Register bits
    namespace pmd_ctl_bits {
        constexpr uint32_t RTCE = (1U << 0);  ///< RTC mode control bit
    }

    /// WRFSR Register bits
    namespace wrfsr_bits {
        constexpr uint32_t WLVDH = (1U << 1);  ///< Low-voltage detection reset return bit
        constexpr uint32_t WINITX = (1U << 0);  ///< INITX pin input reset return bit
    }

    /// WIFSR Register bits
    namespace wifsr_bits {
        constexpr uint32_t WUI5 = (1U << 7);  ///< WKUP pin input return bit 5
        constexpr uint32_t WUI4 = (1U << 6);  ///< WKUP pin input return bit 4
        constexpr uint32_t WUI3 = (1U << 5);  ///< WKUP pin input return bit 3
        constexpr uint32_t WUI2 = (1U << 4);  ///< WKUP pin input return bit 2
        constexpr uint32_t WUI1 = (1U << 3);  ///< WKUP pin input return bit 1
        constexpr uint32_t WUI0 = (1U << 2);  ///< WKUP pin input return bit 0
        constexpr uint32_t WLVDI = (1U << 1);  ///< LVD interrupt return bit
        constexpr uint32_t WRTCI = (1U << 0);  ///< RTC interrupt return bit
    }

    /// WIER Register bits
    namespace wier_bits {
        constexpr uint32_t WUI5E = (1U << 7);  ///< WKUP pin input return enable bit 5
        constexpr uint32_t WUI4E = (1U << 6);  ///< WKUP pin input return enable bit 4
        constexpr uint32_t WUI3E = (1U << 5);  ///< WKUP pin input return enable bit 3
        constexpr uint32_t WUI2E = (1U << 4);  ///< WKUP pin input return enable bit 2
        constexpr uint32_t WUI1E = (1U << 3);  ///< WKUP pin input return enable bit 1
        constexpr uint32_t WLVDE = (1U << 1);  ///< LVD interrupt return enable bit
        constexpr uint32_t WRTCE = (1U << 0);  ///< RTC interrupt return enable bit
    }

    /// WILVR Register bits
    namespace wilvr_bits {
        constexpr uint32_t WUI5LV = (1U << 4);  ///< WKUP pin input level select bit 5
        constexpr uint32_t WUI4LV = (1U << 3);  ///< WKUP pin input level select bit 4
        constexpr uint32_t WUI3LV = (1U << 2);  ///< WKUP pin input level select bit 3
        constexpr uint32_t WUI2LV = (1U << 1);  ///< WKUP pin input level select bit 2
        constexpr uint32_t WUI1LV = (1U << 0);  ///< WKUP pin input level select bit 1
    }

    /// DSRAMR Register bits
    namespace dsramr_bits {
        constexpr uint32_t SRAMR = (2 << 0);  ///< On-chip SRAM retention control bits
    }

}

// ============================================================================
// MFS0 Peripheral
// ============================================================================

namespace mfs0 {
    /// Base addresses
    constexpr uint32_t MFS0_BASE = 0x40038000;

    /// MFS0 Register structure
    struct Registers {
        volatile uint32_t UART_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t UART_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t UART_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t UART_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t UART_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t UART_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t UART_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t UART_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t UART_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t UART_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t UART_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t CSIO_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t CSIO_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t CSIO_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t CSIO_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t CSIO_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t CSIO_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t CSIO_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t CSIO_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t CSIO_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t CSIO_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t CSIO_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t CSIO_SCSTR0;  ///< Offset: 0x1C - Serial Chip Select Timing Register 0
        volatile uint32_t CSIO_SCSTR1;  ///< Offset: 0x1D - Serial Chip Select Timing Register 1
        volatile uint32_t CSIO_SCSTR2;  ///< Offset: 0x20 - Serial Chip Select Timing Registers 2/3
        volatile uint32_t CSIO_SCSTR3;  ///< Offset: 0x21 - Serial Chip Select Timing Registers 3
        volatile uint32_t CSIO_SACSR;  ///< Offset: 0x24 - Serial Support Control Register
        volatile uint32_t CSIO_STMR;  ///< Offset: 0x28 - Serial Timer Register
        volatile uint32_t CSIO_STMCR;  ///< Offset: 0x2C - Serial Timer Comparison Register
        volatile uint32_t CSIO_SCSCR;  ///< Offset: 0x30 - Serial Chip Select Control Status Register
        volatile uint32_t CSIO_SCSFR0;  ///< Offset: 0x34 - Serial Chip Select Format Register 0
        volatile uint32_t CSIO_SCSFR1;  ///< Offset: 0x35 - Serial Chip Select Format Register 1
        volatile uint32_t CSIO_SCSFR2;  ///< Offset: 0x38 - Serial Chip Select Format Register 2
        volatile uint32_t CSIO_TBYTE0;  ///< Offset: 0x3C - Transfer Byte Register 0
        volatile uint32_t CSIO_TBYTE1;  ///< Offset: 0x3D - Transfer Byte Register 1
        volatile uint32_t CSIO_TBYTE2;  ///< Offset: 0x40 - Transfer Byte Register 2
        volatile uint32_t CSIO_TBYTE3;  ///< Offset: 0x41 - Transfer Byte Register 3
        volatile uint32_t LIN_SCR;  ///< Offset: 0x01 - Serial Control Register
        volatile uint32_t LIN_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t LIN_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t LIN_ESCR;  ///< Offset: 0x04 - Extended Communication Control Register
        volatile uint32_t LIN_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t LIN_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t LIN_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t LIN_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t LIN_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t LIN_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t LIN_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t I2C_IBCR;  ///< Offset: 0x01 - I2C Bus Control Register
        volatile uint32_t I2C_SMR;  ///< Offset: 0x00 - Serial Mode Register
        volatile uint32_t I2C_IBSR;  ///< Offset: 0x04 - I2C Bus Status Register
        volatile uint32_t I2C_SSR;  ///< Offset: 0x05 - Serial Status Register
        volatile uint32_t I2C_RDR;  ///< Offset: 0x08 - Received Data Register
        volatile uint32_t I2C_TDR;  ///< Offset: 0x08 - Transmit Data Register
        volatile uint32_t I2C_BGR;  ///< Offset: 0x0C - Baud Rate Generator Registers
        volatile uint32_t I2C_ISMK;  ///< Offset: 0x11 - 7-bit Slave Address Mask Register
        volatile uint32_t I2C_ISBA;  ///< Offset: 0x10 - 7-bit Slave Address Register
        volatile uint32_t I2C_FCR1;  ///< Offset: 0x15 - FIFO Control Register 1
        volatile uint32_t I2C_FCR0;  ///< Offset: 0x14 - FIFO Control Register 0
        volatile uint32_t I2C_FBYTE1;  ///< Offset: 0x18 - FIFO Byte Register 1
        volatile uint32_t I2C_FBYTE2;  ///< Offset: 0x19 - FIFO Byte Register 2
        volatile uint32_t I2C_NFCR;  ///< Offset: 0x1C - Noise Filter Control Register
        volatile uint32_t I2C_EIBCR;  ///< Offset: 0x1D - Extension I2C Bus Control Register
    };

    /// Peripheral instances
    inline Registers* MFS0 = reinterpret_cast<Registers*>(MFS0_BASE);

    // Bit definitions
    /// UART_SCR Register bits
    namespace uart_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable Clear bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Received operation enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Transmission operation enable bit
    }

    /// UART_SMR Register bits
    namespace uart_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bit
        constexpr uint32_t SBL = (1U << 3);  ///< Stop bit length select bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// UART_SSR Register bits
    namespace uart_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t PE = (1U << 5);  ///< Parity error flag bit (only functions in operation mode 0)
        constexpr uint32_t FRE = (1U << 4);  ///< Framing error flag bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag
    }

    /// UART_ESCR Register bits
    namespace uart_escr_bits {
        constexpr uint32_t FLWEN = (1U << 7);  ///< Flow control enable bit
        constexpr uint32_t ESBL = (1U << 6);  ///< Extension stop bit length select bit
        constexpr uint32_t INV = (1U << 5);  ///< Inverted serial data format bit
        constexpr uint32_t PEN = (1U << 4);  ///< Parity enable bit (only functions in operation mode 0)
        constexpr uint32_t P = (1U << 3);  ///< Parity select bit (only functions in operation mode 0)
        constexpr uint32_t L = (3 << 0);  ///< Data length select bit
    }

    /// UART_RDR Register bits
    namespace uart_rdr_bits {
        constexpr uint32_t D = (9 << 0);  ///< Data
    }

    /// UART_TDR Register bits
    namespace uart_tdr_bits {
        constexpr uint32_t D = (9 << 0);  ///< Data
    }

    /// UART_BGR Register bits
    namespace uart_bgr_bits {
        constexpr uint32_t EXT = (1U << 15);  ///< External clock select bit
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// UART_FCR1 Register bits
    namespace uart_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// UART_FCR0 Register bits
    namespace uart_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// CSIO_SCR Register bits
    namespace csio_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable clear bit
        constexpr uint32_t MS = (1U << 6);  ///< Master/Slave function select bit
        constexpr uint32_t SPI = (1U << 5);  ///< SPI corresponding bit
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Data received enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Data transmission enable bit
    }

    /// CSIO_SMR Register bits
    namespace csio_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode set bits
        constexpr uint32_t SCINV = (1U << 3);  ///< Serial clock invert bit
        constexpr uint32_t BDS = (1U << 2);  ///< Transfer direction select bit
        constexpr uint32_t SCKE = (1U << 1);  ///< Master mode serial clock output enable bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// CSIO_SSR Register bits
    namespace csio_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t AWC = (1U << 4);  ///< Access Width Control bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit
    }

    /// CSIO_ESCR Register bits
    namespace csio_escr_bits {
        constexpr uint32_t SOP = (1U << 7);  ///< Serial output pin set bit
        constexpr uint32_t L3 = (1U << 6);  ///< Bit3 of Data length select bits
        constexpr uint32_t CSFE = (1U << 5);  ///< Serial Chip Select Format enable bit
        constexpr uint32_t WT = (2 << 3);  ///< Data transmit/received wait select bits
        constexpr uint32_t L = (3 << 0);  ///< Data length select bits
    }

    /// CSIO_RDR Register bits
    namespace csio_rdr_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data
    }

    /// CSIO_TDR Register bits
    namespace csio_tdr_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data
    }

    /// CSIO_BGR Register bits
    namespace csio_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// CSIO_FCR1 Register bits
    namespace csio_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// CSIO_FCR0 Register bits
    namespace csio_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// CSIO_SCSTR0 Register bits
    namespace csio_scstr0_bits {
        constexpr uint32_t CSHD = (8 << 0);  ///< Serial Chip Select Hold Delay bits
    }

    /// CSIO_SCSTR1 Register bits
    namespace csio_scstr1_bits {
        constexpr uint32_t CSSU = (8 << 0);  ///< Serial Chip Select Setup Delay bits
    }

    /// CSIO_SCSTR2 Register bits
    namespace csio_scstr2_bits {
        constexpr uint32_t CSDS = (16 << 0);  ///< Serial Chip Deselect bits
    }

    /// CSIO_SACSR Register bits
    namespace csio_sacsr_bits {
        constexpr uint32_t TBEEN = (1U << 13);  ///< Transfer Byte Error Enable bit
        constexpr uint32_t CSEIE = (1U << 12);  ///< Chip Select Error Interupt Enable bit
        constexpr uint32_t CSE = (1U << 11);  ///< Chip Select Error Flag
        constexpr uint32_t TINT = (1U << 8);  ///< Timer Interrupt Flag
        constexpr uint32_t TINTE = (1U << 7);  ///< Timer Interrupt Enable bit
        constexpr uint32_t TSYNE = (1U << 6);  ///< Synchronous Transmission Enable bit
        constexpr uint32_t TDIV = (4 << 1);  ///< Timer Operation Clock Division bit
        constexpr uint32_t TMRE = (1U << 0);  ///< Serial Timer Enable bit
    }

    /// CSIO_STMR Register bits
    namespace csio_stmr_bits {
        constexpr uint32_t TM = (16 << 0);  ///< Timer Data bits
    }

    /// CSIO_STMCR Register bits
    namespace csio_stmcr_bits {
        constexpr uint32_t TC = (16 << 0);  ///< Compare bits
    }

    /// CSIO_SCSCR Register bits
    namespace csio_scscr_bits {
        constexpr uint32_t SST = (2 << 14);  ///< Serial Chip Select Active Start bit
        constexpr uint32_t SED = (2 << 12);  ///< Serial Chip Select Active End bit
        constexpr uint32_t SCD = (2 << 10);  ///< Serial Chip Select Active Display bit
        constexpr uint32_t SCAM = (1U << 9);  ///< Serial Chip Select Active Hold bit
        constexpr uint32_t CDIV = (3 << 6);  ///< Serial Chip Select Timing Operation Clock Division bit
        constexpr uint32_t CSLVL = (1U << 5);  ///< Serial Chip Select Level Setting bit
        constexpr uint32_t CSEN3 = (1U << 4);  ///< Serial Chip Select Enable bit with SCS3 pin
        constexpr uint32_t CSEN2 = (1U << 3);  ///< Serial Chip Select Enable bit with SCS2 pin
        constexpr uint32_t CSEN1 = (1U << 2);  ///< Serial Chip Select Enable bit with SCS1 pin
        constexpr uint32_t CSEN0 = (1U << 1);  ///< Serial Chip Select Enable bit with SCS0 pin
        constexpr uint32_t CSOE = (1U << 0);  ///< Serial Chip Select Output Enable bit
    }

    /// CSIO_SCSFR0 Register bits
    namespace csio_scsfr0_bits {
        constexpr uint32_t CS1CSLVL = (1U << 7);  ///< Serial Chip Select 1 Level Setting bit
        constexpr uint32_t CS1SCINV = (1U << 6);  ///< Serial Clock Invert bit of Serial Chip Select 1
        constexpr uint32_t CS1SPI = (1U << 5);  ///< SPI corresponding bit of Serial Chip Select 1
        constexpr uint32_t CS1L = (5 << 0);  ///< Transfer direction select bit of Serial Chip Select 1
    }

    /// CSIO_SCSFR1 Register bits
    namespace csio_scsfr1_bits {
        constexpr uint32_t CS2CSLVL = (1U << 7);  ///< Serial Chip Select 2 Level Setting bit
        constexpr uint32_t CS2SCINV = (1U << 6);  ///< Serial Clock Invert bit of Serial Chip Select 2
        constexpr uint32_t CS2SPI = (1U << 5);  ///< SPI corresponding bit of Serial Chip Select 2
        constexpr uint32_t CS2L = (5 << 0);  ///< Transfer direction select bit of Serial Chip Select 2
    }

    /// CSIO_SCSFR2 Register bits
    namespace csio_scsfr2_bits {
        constexpr uint32_t CS3CSLVL = (1U << 7);  ///< Serial Chip Select 3 Level Setting bit
        constexpr uint32_t CS3SCINV = (1U << 6);  ///< Serial Clock Invert bit of Serial Chip Select 3
        constexpr uint32_t CS3SPI = (1U << 5);  ///< SPI corresponding bit of Serial Chip Select 3
        constexpr uint32_t CS3L = (5 << 0);  ///< Transfer direction select bit of Serial Chip Select 3
    }

    /// LIN_SCR Register bits
    namespace lin_scr_bits {
        constexpr uint32_t UPCL = (1U << 7);  ///< Programmable clear bit
        constexpr uint32_t MS = (1U << 6);  ///< Master/Slave function select bit
        constexpr uint32_t LBR = (1U << 5);  ///< LIN Break Field setting bit (valid in master mode only)
        constexpr uint32_t RIE = (1U << 4);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 3);  ///< Transmit interrupt enable bit
        constexpr uint32_t TBIE = (1U << 2);  ///< Transmit bus idle interrupt enable bit
        constexpr uint32_t RXE = (1U << 1);  ///< Data reception enable bit
        constexpr uint32_t TXE = (1U << 0);  ///< Data transmission enable bit
    }

    /// LIN_SMR Register bits
    namespace lin_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< Operation mode setting bits
        constexpr uint32_t WUCR = (1U << 4);  ///< Wake-up control bit
        constexpr uint32_t SBL = (1U << 3);  ///< Stop bit length select bit
        constexpr uint32_t SOE = (1U << 0);  ///< Serial data output enable bit
    }

    /// LIN_SSR Register bits
    namespace lin_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received Error flag clear bit
        constexpr uint32_t LBD = (1U << 5);  ///< LIN Break field detection flag bit
        constexpr uint32_t FRE = (1U << 4);  ///< Framing error flag bit
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit
    }

    /// LIN_ESCR Register bits
    namespace lin_escr_bits {
        constexpr uint32_t ESBL = (1U << 6);  ///< Extended stop bit length select bit
        constexpr uint32_t LBIE = (1U << 4);  ///< LIN Break field detect interrupt enable bit
        constexpr uint32_t LBL = (2 << 2);  ///< LIN Break field length select bits (valid in master mode only)
        constexpr uint32_t DEL = (2 << 0);  ///< LIN Break delimiter length select bits (valid in master mode only)
    }

    /// LIN_RDR Register bits
    namespace lin_rdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// LIN_TDR Register bits
    namespace lin_tdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// LIN_BGR Register bits
    namespace lin_bgr_bits {
        constexpr uint32_t EXT = (1U << 15);  ///< External clock select bit
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// LIN_FCR1 Register bits
    namespace lin_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// LIN_FCR0 Register bits
    namespace lin_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// I2C_IBCR Register bits
    namespace i2c_ibcr_bits {
        constexpr uint32_t MSS = (1U << 7);  ///< Master/slave select bit
        constexpr uint32_t ACT_SCC = (1U << 6);  ///< Operation flag/iteration start condition generation bit
        constexpr uint32_t ACKE = (1U << 5);  ///< Data byte acknowledge enable bit
        constexpr uint32_t WSEL = (1U << 4);  ///< Wait selection bit
        constexpr uint32_t CNDE = (1U << 3);  ///< Condition detection interrupt enable bit
        constexpr uint32_t INTE = (1U << 2);  ///< Interrupt enable bit
        constexpr uint32_t BER = (1U << 1);  ///< Bus error flag bit
        constexpr uint32_t INT_ = (1U << 0);  ///< interrupt flag bit (renamed from INT_)
    }

    /// I2C_SMR Register bits
    namespace i2c_smr_bits {
        constexpr uint32_t MD = (3 << 5);  ///< operation mode set bits
        constexpr uint32_t RIE = (1U << 3);  ///< Received interrupt enable bit
        constexpr uint32_t TIE = (1U << 2);  ///< Transmit interrupt enable bit
    }

    /// I2C_IBSR Register bits
    namespace i2c_ibsr_bits {
        constexpr uint32_t FBT = (1U << 7);  ///< First byte bit
        constexpr uint32_t RACK = (1U << 6);  ///< Acknowledge flag bit
        constexpr uint32_t RSA = (1U << 5);  ///< Reserved address detection bit
        constexpr uint32_t TRX = (1U << 4);  ///< Data direction bit
        constexpr uint32_t AL = (1U << 3);  ///< Arbitration lost bit
        constexpr uint32_t RSC = (1U << 2);  ///< Iteration start condition check bit
        constexpr uint32_t SPC = (1U << 1);  ///< Stop condition check bit
        constexpr uint32_t BB = (1U << 0);  ///< Bus state bit
    }

    /// I2C_SSR Register bits
    namespace i2c_ssr_bits {
        constexpr uint32_t REC = (1U << 7);  ///< Received error flag clear bit
        constexpr uint32_t TSET = (1U << 6);  ///< Transmit empty flag set bit
        constexpr uint32_t DMA = (1U << 5);  ///< DMA mode enable bit
        constexpr uint32_t TBIE = (1U << 4);  ///< Transmit bus idle interrupt enable bit (Effective only when DMA mode is enabled)
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error flag bit
        constexpr uint32_t RDRF = (1U << 2);  ///< Received data full flag bit
        constexpr uint32_t TDRE = (1U << 1);  ///< Transmit data empty flag bit
        constexpr uint32_t TBI = (1U << 0);  ///< Transmit bus idle flag bit (Effective only when DMA mode is enabled)
    }

    /// I2C_RDR Register bits
    namespace i2c_rdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// I2C_TDR Register bits
    namespace i2c_tdr_bits {
        constexpr uint32_t D = (8 << 0);  ///< Data
    }

    /// I2C_BGR Register bits
    namespace i2c_bgr_bits {
        constexpr uint32_t BGR1 = (7 << 8);  ///< Baud Rate Generator Registers 1
        constexpr uint32_t BGR0 = (8 << 0);  ///< Baud Rate Generator Registers 0
    }

    /// I2C_ISMK Register bits
    namespace i2c_ismk_bits {
        constexpr uint32_t EN = (1U << 7);  ///< I2C interface operation enable bit
        constexpr uint32_t SM = (7 << 0);  ///< Slave address mask bits
    }

    /// I2C_ISBA Register bits
    namespace i2c_isba_bits {
        constexpr uint32_t SAEN = (1U << 7);  ///< Slave address enable bit
        constexpr uint32_t SA = (7 << 0);  ///< 7-bit slave address
    }

    /// I2C_FCR1 Register bits
    namespace i2c_fcr1_bits {
        constexpr uint32_t FLSTE = (1U << 4);  ///< Re-transmission data lost detect enable bit
        constexpr uint32_t FRIIE = (1U << 3);  ///< Received FIFO idle detection enable bit
        constexpr uint32_t FDRQ = (1U << 2);  ///< Transmit FIFO data request bit
        constexpr uint32_t FTIE = (1U << 1);  ///< Transmit FIFO interrupt enable bit
        constexpr uint32_t FSEL = (1U << 0);  ///< FIFO select bit
    }

    /// I2C_FCR0 Register bits
    namespace i2c_fcr0_bits {
        constexpr uint32_t FLST = (1U << 6);  ///< FIFO re-transmit data lost flag bit
        constexpr uint32_t FLD = (1U << 5);  ///< FIFO pointer reload bit
        constexpr uint32_t FSET = (1U << 4);  ///< FIFO pointer save bit
        constexpr uint32_t FCL2 = (1U << 3);  ///< FIFO2 reset bit
        constexpr uint32_t FCL1 = (1U << 2);  ///< FIFO1 reset bit
        constexpr uint32_t FE2 = (1U << 1);  ///< FIFO2 operation enable bit
        constexpr uint32_t FE1 = (1U << 0);  ///< FIFO1 operation enable bit
    }

    /// I2C_NFCR Register bits
    namespace i2c_nfcr_bits {
        constexpr uint32_t NFT = (5 << 0);  ///< Noise Filter Time Select bits
    }

    /// I2C_EIBCR Register bits
    namespace i2c_eibcr_bits {
        constexpr uint32_t SDAS = (1U << 5);  ///< SDA status bit
        constexpr uint32_t SCLS = (1U << 4);  ///< SCL status bit
        constexpr uint32_t SDAC = (1U << 3);  ///< SDA output control bit
        constexpr uint32_t SCLC = (1U << 2);  ///< SCL output control bit
        constexpr uint32_t SOCE = (1U << 1);  ///< Serial output enabled bit
        constexpr uint32_t BEC = (1U << 0);  ///< Bus error control bit
    }

}

// ============================================================================
// MFS1 Peripheral
// ============================================================================

namespace mfs1 {
    /// Base addresses
    constexpr uint32_t MFS1_BASE = 0x40038100;

    /// MFS1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS1 = reinterpret_cast<Registers*>(MFS1_BASE);

}

// ============================================================================
// MFS2 Peripheral
// ============================================================================

namespace mfs2 {
    /// Base addresses
    constexpr uint32_t MFS2_BASE = 0x40038200;

    /// MFS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS2 = reinterpret_cast<Registers*>(MFS2_BASE);

}

// ============================================================================
// MFS3 Peripheral
// ============================================================================

namespace mfs3 {
    /// Base addresses
    constexpr uint32_t MFS3_BASE = 0x40038300;

    /// MFS3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS3 = reinterpret_cast<Registers*>(MFS3_BASE);

}

// ============================================================================
// MFS4 Peripheral
// ============================================================================

namespace mfs4 {
    /// Base addresses
    constexpr uint32_t MFS4_BASE = 0x40038400;

    /// MFS4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS4 = reinterpret_cast<Registers*>(MFS4_BASE);

}

// ============================================================================
// MFS5 Peripheral
// ============================================================================

namespace mfs5 {
    /// Base addresses
    constexpr uint32_t MFS5_BASE = 0x40038500;

    /// MFS5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS5 = reinterpret_cast<Registers*>(MFS5_BASE);

}

// ============================================================================
// MFS6 Peripheral
// ============================================================================

namespace mfs6 {
    /// Base addresses
    constexpr uint32_t MFS6_BASE = 0x40038600;

    /// MFS6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS6 = reinterpret_cast<Registers*>(MFS6_BASE);

}

// ============================================================================
// MFS7 Peripheral
// ============================================================================

namespace mfs7 {
    /// Base addresses
    constexpr uint32_t MFS7_BASE = 0x40038700;

    /// MFS7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS7 = reinterpret_cast<Registers*>(MFS7_BASE);

}

// ============================================================================
// MFS8 Peripheral
// ============================================================================

namespace mfs8 {
    /// Base addresses
    constexpr uint32_t MFS8_BASE = 0x40038800;

    /// MFS8 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS8 = reinterpret_cast<Registers*>(MFS8_BASE);

}

// ============================================================================
// MFS9 Peripheral
// ============================================================================

namespace mfs9 {
    /// Base addresses
    constexpr uint32_t MFS9_BASE = 0x40038900;

    /// MFS9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS9 = reinterpret_cast<Registers*>(MFS9_BASE);

}

// ============================================================================
// MFS10 Peripheral
// ============================================================================

namespace mfs10 {
    /// Base addresses
    constexpr uint32_t MFS10_BASE = 0x40038A00;

    /// MFS10 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS10 = reinterpret_cast<Registers*>(MFS10_BASE);

}

// ============================================================================
// MFS11 Peripheral
// ============================================================================

namespace mfs11 {
    /// Base addresses
    constexpr uint32_t MFS11_BASE = 0x40038B00;

    /// MFS11 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS11 = reinterpret_cast<Registers*>(MFS11_BASE);

}

// ============================================================================
// MFS12 Peripheral
// ============================================================================

namespace mfs12 {
    /// Base addresses
    constexpr uint32_t MFS12_BASE = 0x40038C00;

    /// MFS12 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS12 = reinterpret_cast<Registers*>(MFS12_BASE);

}

// ============================================================================
// MFS13 Peripheral
// ============================================================================

namespace mfs13 {
    /// Base addresses
    constexpr uint32_t MFS13_BASE = 0x40038D00;

    /// MFS13 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS13 = reinterpret_cast<Registers*>(MFS13_BASE);

}

// ============================================================================
// MFS14 Peripheral
// ============================================================================

namespace mfs14 {
    /// Base addresses
    constexpr uint32_t MFS14_BASE = 0x40038E00;

    /// MFS14 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS14 = reinterpret_cast<Registers*>(MFS14_BASE);

}

// ============================================================================
// MFS15 Peripheral
// ============================================================================

namespace mfs15 {
    /// Base addresses
    constexpr uint32_t MFS15_BASE = 0x40038F00;

    /// MFS15 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* MFS15 = reinterpret_cast<Registers*>(MFS15_BASE);

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40039000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRCCR;  ///< Offset: 0x00 - CRC Control Register
        volatile uint32_t CRCINIT;  ///< Offset: 0x04 - Initial Value Register
        volatile uint32_t CRCIN;  ///< Offset: 0x08 - Input Data Register
        volatile uint32_t CRCR;  ///< Offset: 0x0C - CRC Register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRCCR Register bits
    namespace crccr_bits {
        constexpr uint32_t FXOR = (1U << 6);  ///< Initialization bit
        constexpr uint32_t CRCLSF = (1U << 5);  ///< Final XOR control bit
        constexpr uint32_t CRCLTE = (1U << 4);  ///< CRC result bit-order setting bit
        constexpr uint32_t LSBFST = (1U << 3);  ///< CRC result byte-order setting bit
        constexpr uint32_t LTLEND = (1U << 2);  ///< Bit-order setting bit
        constexpr uint32_t CRC32 = (1U << 1);  ///< Byte-order setting bit
        constexpr uint32_t INIT = (1U << 0);  ///< CRC mode selection bit
    }

    /// CRCINIT Register bits
    namespace crcinit_bits {
        constexpr uint32_t D = (32 << 0);  ///< Initial value
    }

    /// CRCIN Register bits
    namespace crcin_bits {
        constexpr uint32_t D = (32 << 0);  ///< Input data
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t D = (32 << 0);  ///< CRC Data
    }

}

// ============================================================================
// WC Peripheral
// ============================================================================

namespace wc {
    /// Base addresses
    constexpr uint32_t WC_BASE = 0x4003A000;

    /// WC Register structure
    struct Registers {
        volatile uint32_t WCRD;  ///< Offset: 0x00 - Watch Counter Read Register
        volatile uint32_t WCRL;  ///< Offset: 0x01 - Watch Counter Reload Register
        volatile uint32_t WCCR;  ///< Offset: 0x02 - Watch Counter Control Register
        volatile uint32_t CLK_SEL;  ///< Offset: 0x10 - Clock Selection Register
        volatile uint32_t CLK_EN;  ///< Offset: 0x14 - Division Clock Enable Register
    };

    /// Peripheral instances
    inline Registers* WC = reinterpret_cast<Registers*>(WC_BASE);

    // Bit definitions
    /// WCRD Register bits
    namespace wcrd_bits {
        constexpr uint32_t CTR = (6 << 0);  ///< Counter read bits
    }

    /// WCRL Register bits
    namespace wcrl_bits {
        constexpr uint32_t RLC = (6 << 0);  ///< Counter reload value setting bits
    }

    /// WCCR Register bits
    namespace wccr_bits {
        constexpr uint32_t WCEN = (1U << 7);  ///< Watch counter operation enable bit
        constexpr uint32_t WCOP = (1U << 6);  ///< Watch counter operating state flag
        constexpr uint32_t CS = (2 << 2);  ///< Count clock select bits
        constexpr uint32_t WCIE = (1U << 1);  ///< Interrupt request enable bit
        constexpr uint32_t WCIF = (1U << 0);  ///< Interrupt request flag bit
    }

    /// CLK_SEL Register bits
    namespace clk_sel_bits {
        constexpr uint32_t SEL_OUT = (3 << 8);  ///< Output clock selection bit
        constexpr uint32_t SEL_IN = (2 << 0);  ///< Input clock selection bit
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN_R = (1U << 1);  ///< Division clock enable read bit
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Division clock enable bit
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003B000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t WTCR10;  ///< Offset: 0x100 - Control Register 10
        volatile uint32_t WTCR11;  ///< Offset: 0x104 - Control Register 11
        volatile uint32_t WTCR12;  ///< Offset: 0x108 - Control Register 12
        volatile uint32_t WTCR13;  ///< Offset: 0x10C - Control Register 13
        volatile uint32_t WTCR20;  ///< Offset: 0x110 - Control Register 20
        volatile uint32_t WTCR21;  ///< Offset: 0x114 - Control Register 21
        volatile uint32_t WTSR;  ///< Offset: 0x11C - Second Register
        volatile uint32_t WTMIR;  ///< Offset: 0x120 - Minute Register
        volatile uint32_t WTHR;  ///< Offset: 0x124 - Hour register
        volatile uint32_t WTDR;  ///< Offset: 0x128 - Day Register
        volatile uint32_t WTDW;  ///< Offset: 0x12C - Day of the Week Register
        volatile uint32_t WTMOR;  ///< Offset: 0x130 - Month Register
        volatile uint32_t WTYR;  ///< Offset: 0x134 - Year Register
        volatile uint32_t ALMIR;  ///< Offset: 0x138 - Alarm Minute Register
        volatile uint32_t ALHR;  ///< Offset: 0x13C - Alarm Hour Register
        volatile uint32_t ALDR;  ///< Offset: 0x140 - Alarm Date Register
        volatile uint32_t ALMOR;  ///< Offset: 0x144 - Alarm Month Register
        volatile uint32_t ALYR;  ///< Offset: 0x148 - Alarm Years Register
        volatile uint32_t WTTR0;  ///< Offset: 0x14C - Timer Setting Register 0
        volatile uint32_t WTTR1;  ///< Offset: 0x150 - Timer Setting Register 1
        volatile uint32_t WTTR2;  ///< Offset: 0x154 - Timer Setting Register 2
        volatile uint32_t WTCAL0;  ///< Offset: 0x158 - Frequency Correction Value Setting Register 0
        volatile uint32_t WTCAL1;  ///< Offset: 0x15C - Frequency Correction Value Setting Register 1
        volatile uint32_t WTCALEN;  ///< Offset: 0x160 - Frequency Correction Enable Register
        volatile uint32_t WTDIV;  ///< Offset: 0x164 - Division Ratio Setting Register
        volatile uint32_t WTDIVEN;  ///< Offset: 0x168 - Divider Output Enable Register
        volatile uint32_t WTCALPRD;  ///< Offset: 0x16C - Frequency Correction Period Setting Register
        volatile uint32_t WTCOSEL;  ///< Offset: 0x170 - RTCCO Output Selection Register
        volatile uint32_t VB_CLKDIV;  ///< Offset: 0x174 - VB_CLKDIV Register
        volatile uint32_t WTOSCCNT;  ///< Offset: 0x178 - WTOSCCNT Register
        volatile uint32_t CCS;  ///< Offset: 0x17C - CCS Register
        volatile uint32_t CCB;  ///< Offset: 0x180 - CCB Register
        volatile uint32_t BOOST;  ///< Offset: 0x188 - BOOST Register
        volatile uint32_t EWKUP;  ///< Offset: 0x18C - EWKUP Register
        volatile uint32_t VDET;  ///< Offset: 0x190 - VDET Register
        volatile uint32_t HIBRST;  ///< Offset: 0x198 - HIBRST Register
        volatile uint32_t VBPFR;  ///< Offset: 0x19C - Port Function Set Register
        volatile uint32_t VBPCR;  ///< Offset: 0x1A0 - Pull-up Set Register
        volatile uint32_t VBDDR;  ///< Offset: 0x1A4 - Port I/O Direction Set Register
        volatile uint32_t VBDIR;  ///< Offset: 0x1A8 - Port Input Data Register
        volatile uint32_t VBDOR;  ///< Offset: 0x1AC - Port Output Data Register
        volatile uint32_t VBPZR;  ///< Offset: 0x1B0 - Port Pseudo-Open Drain Set Register
        volatile uint32_t BREG00;  ///< Offset: 0x200 - Backup Register
        volatile uint32_t BREG01;  ///< Offset: 0x201 - Backup Register
        volatile uint32_t BREG02;  ///< Offset: 0x202 - Backup Register
        volatile uint32_t BREG03;  ///< Offset: 0x203 - Backup Register
        volatile uint32_t BREG04;  ///< Offset: 0x204 - Backup Register
        volatile uint32_t BREG05;  ///< Offset: 0x205 - Backup Register
        volatile uint32_t BREG06;  ///< Offset: 0x206 - Backup Register
        volatile uint32_t BREG07;  ///< Offset: 0x207 - Backup Register
        volatile uint32_t BREG08;  ///< Offset: 0x208 - Backup Register
        volatile uint32_t BREG09;  ///< Offset: 0x209 - Backup Register
        volatile uint32_t BREG0A;  ///< Offset: 0x20A - Backup Register
        volatile uint32_t BREG0B;  ///< Offset: 0x20B - Backup Register
        volatile uint32_t BREG0C;  ///< Offset: 0x20C - Backup Register
        volatile uint32_t BREG0D;  ///< Offset: 0x20D - Backup Register
        volatile uint32_t BREG0E;  ///< Offset: 0x20E - Backup Register
        volatile uint32_t BREG0F;  ///< Offset: 0x20F - Backup Register
        volatile uint32_t BREG10;  ///< Offset: 0x210 - Backup Register
        volatile uint32_t BREG11;  ///< Offset: 0x211 - Backup Register
        volatile uint32_t BREG12;  ///< Offset: 0x212 - Backup Register
        volatile uint32_t BREG13;  ///< Offset: 0x213 - Backup Register
        volatile uint32_t BREG14;  ///< Offset: 0x214 - Backup Register
        volatile uint32_t BREG15;  ///< Offset: 0x215 - Backup Register
        volatile uint32_t BREG16;  ///< Offset: 0x216 - Backup Register
        volatile uint32_t BREG17;  ///< Offset: 0x217 - Backup Register
        volatile uint32_t BREG18;  ///< Offset: 0x218 - Backup Register
        volatile uint32_t BREG19;  ///< Offset: 0x219 - Backup Register
        volatile uint32_t BREG1A;  ///< Offset: 0x21A - Backup Register
        volatile uint32_t BREG1B;  ///< Offset: 0x21B - Backup Register
        volatile uint32_t BREG1C;  ///< Offset: 0x21C - Backup Register
        volatile uint32_t BREG1D;  ///< Offset: 0x21D - Backup Register
        volatile uint32_t BREG1E;  ///< Offset: 0x21E - Backup Register
        volatile uint32_t BREG1F;  ///< Offset: 0x21F - Backup Register
        volatile uint32_t BREG20;  ///< Offset: 0x220 - Backup Register
        volatile uint32_t BREG21;  ///< Offset: 0x221 - Backup Register
        volatile uint32_t BREG22;  ///< Offset: 0x222 - Backup Register
        volatile uint32_t BREG23;  ///< Offset: 0x223 - Backup Register
        volatile uint32_t BREG24;  ///< Offset: 0x224 - Backup Register
        volatile uint32_t BREG25;  ///< Offset: 0x225 - Backup Register
        volatile uint32_t BREG26;  ///< Offset: 0x226 - Backup Register
        volatile uint32_t BREG27;  ///< Offset: 0x227 - Backup Register
        volatile uint32_t BREG28;  ///< Offset: 0x228 - Backup Register
        volatile uint32_t BREG29;  ///< Offset: 0x229 - Backup Register
        volatile uint32_t BREG2A;  ///< Offset: 0x22A - Backup Register
        volatile uint32_t BREG2B;  ///< Offset: 0x22B - Backup Register
        volatile uint32_t BREG2C;  ///< Offset: 0x22C - Backup Register
        volatile uint32_t BREG2D;  ///< Offset: 0x22D - Backup Register
        volatile uint32_t BREG2E;  ///< Offset: 0x22E - Backup Register
        volatile uint32_t BREG2F;  ///< Offset: 0x22F - Backup Register
        volatile uint32_t BREG30;  ///< Offset: 0x230 - Backup Register
        volatile uint32_t BREG31;  ///< Offset: 0x231 - Backup Register
        volatile uint32_t BREG32;  ///< Offset: 0x232 - Backup Register
        volatile uint32_t BREG33;  ///< Offset: 0x233 - Backup Register
        volatile uint32_t BREG34;  ///< Offset: 0x234 - Backup Register
        volatile uint32_t BREG35;  ///< Offset: 0x235 - Backup Register
        volatile uint32_t BREG36;  ///< Offset: 0x236 - Backup Register
        volatile uint32_t BREG37;  ///< Offset: 0x237 - Backup Register
        volatile uint32_t BREG38;  ///< Offset: 0x238 - Backup Register
        volatile uint32_t BREG39;  ///< Offset: 0x239 - Backup Register
        volatile uint32_t BREG3A;  ///< Offset: 0x23A - Backup Register
        volatile uint32_t BREG3B;  ///< Offset: 0x23B - Backup Register
        volatile uint32_t BREG3C;  ///< Offset: 0x23C - Backup Register
        volatile uint32_t BREG3D;  ///< Offset: 0x23D - Backup Register
        volatile uint32_t BREG3E;  ///< Offset: 0x23E - Backup Register
        volatile uint32_t BREG3F;  ///< Offset: 0x23F - Backup Register
        volatile uint32_t BREG40;  ///< Offset: 0x240 - Backup Register
        volatile uint32_t BREG41;  ///< Offset: 0x241 - Backup Register
        volatile uint32_t BREG42;  ///< Offset: 0x242 - Backup Register
        volatile uint32_t BREG43;  ///< Offset: 0x243 - Backup Register
        volatile uint32_t BREG44;  ///< Offset: 0x244 - Backup Register
        volatile uint32_t BREG45;  ///< Offset: 0x245 - Backup Register
        volatile uint32_t BREG46;  ///< Offset: 0x246 - Backup Register
        volatile uint32_t BREG47;  ///< Offset: 0x247 - Backup Register
        volatile uint32_t BREG48;  ///< Offset: 0x248 - Backup Register
        volatile uint32_t BREG49;  ///< Offset: 0x249 - Backup Register
        volatile uint32_t BREG4A;  ///< Offset: 0x24A - Backup Register
        volatile uint32_t BREG4B;  ///< Offset: 0x24B - Backup Register
        volatile uint32_t BREG4C;  ///< Offset: 0x24C - Backup Register
        volatile uint32_t BREG4D;  ///< Offset: 0x24D - Backup Register
        volatile uint32_t BREG4E;  ///< Offset: 0x24E - Backup Register
        volatile uint32_t BREG4F;  ///< Offset: 0x24F - Backup Register
        volatile uint32_t BREG50;  ///< Offset: 0x250 - Backup Register
        volatile uint32_t BREG51;  ///< Offset: 0x251 - Backup Register
        volatile uint32_t BREG52;  ///< Offset: 0x252 - Backup Register
        volatile uint32_t BREG53;  ///< Offset: 0x253 - Backup Register
        volatile uint32_t BREG54;  ///< Offset: 0x254 - Backup Register
        volatile uint32_t BREG55;  ///< Offset: 0x255 - Backup Register
        volatile uint32_t BREG56;  ///< Offset: 0x256 - Backup Register
        volatile uint32_t BREG57;  ///< Offset: 0x257 - Backup Register
        volatile uint32_t BREG58;  ///< Offset: 0x258 - Backup Register
        volatile uint32_t BREG59;  ///< Offset: 0x259 - Backup Register
        volatile uint32_t BREG5A;  ///< Offset: 0x25A - Backup Register
        volatile uint32_t BREG5B;  ///< Offset: 0x25B - Backup Register
        volatile uint32_t BREG5C;  ///< Offset: 0x25C - Backup Register
        volatile uint32_t BREG5D;  ///< Offset: 0x25D - Backup Register
        volatile uint32_t BREG5E;  ///< Offset: 0x25E - Backup Register
        volatile uint32_t BREG5F;  ///< Offset: 0x25F - Backup Register
        volatile uint32_t BREG60;  ///< Offset: 0x260 - Backup Register
        volatile uint32_t BREG61;  ///< Offset: 0x261 - Backup Register
        volatile uint32_t BREG62;  ///< Offset: 0x262 - Backup Register
        volatile uint32_t BREG63;  ///< Offset: 0x263 - Backup Register
        volatile uint32_t BREG64;  ///< Offset: 0x264 - Backup Register
        volatile uint32_t BREG65;  ///< Offset: 0x265 - Backup Register
        volatile uint32_t BREG66;  ///< Offset: 0x266 - Backup Register
        volatile uint32_t BREG67;  ///< Offset: 0x267 - Backup Register
        volatile uint32_t BREG68;  ///< Offset: 0x268 - Backup Register
        volatile uint32_t BREG69;  ///< Offset: 0x269 - Backup Register
        volatile uint32_t BREG6A;  ///< Offset: 0x26A - Backup Register
        volatile uint32_t BREG6B;  ///< Offset: 0x26B - Backup Register
        volatile uint32_t BREG6C;  ///< Offset: 0x26C - Backup Register
        volatile uint32_t BREG6D;  ///< Offset: 0x26D - Backup Register
        volatile uint32_t BREG6E;  ///< Offset: 0x26E - Backup Register
        volatile uint32_t BREG6F;  ///< Offset: 0x26F - Backup Register
        volatile uint32_t BREG70;  ///< Offset: 0x270 - Backup Register
        volatile uint32_t BREG71;  ///< Offset: 0x271 - Backup Register
        volatile uint32_t BREG72;  ///< Offset: 0x272 - Backup Register
        volatile uint32_t BREG73;  ///< Offset: 0x273 - Backup Register
        volatile uint32_t BREG74;  ///< Offset: 0x274 - Backup Register
        volatile uint32_t BREG75;  ///< Offset: 0x275 - Backup Register
        volatile uint32_t BREG76;  ///< Offset: 0x276 - Backup Register
        volatile uint32_t BREG77;  ///< Offset: 0x277 - Backup Register
        volatile uint32_t BREG78;  ///< Offset: 0x278 - Backup Register
        volatile uint32_t BREG79;  ///< Offset: 0x279 - Backup Register
        volatile uint32_t BREG7A;  ///< Offset: 0x27A - Backup Register
        volatile uint32_t BREG7B;  ///< Offset: 0x27B - Backup Register
        volatile uint32_t BREG7C;  ///< Offset: 0x27C - Backup Register
        volatile uint32_t BREG7D;  ///< Offset: 0x27D - Backup Register
        volatile uint32_t BREG7E;  ///< Offset: 0x27E - Backup Register
        volatile uint32_t BREG7F;  ///< Offset: 0x27F - Backup Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// WTCR10 Register bits
    namespace wtcr10_bits {
        constexpr uint32_t TRANS = (1U << 7);  ///< Transfer flag bit
        constexpr uint32_t BUSY = (1U << 6);  ///< Busy bit
        constexpr uint32_t SCRST = (1U << 5);  ///< Sub second generation/1-second generation counter reset bit
        constexpr uint32_t SCST = (1U << 4);  ///< 1-second clock output stop bit
        constexpr uint32_t SRST = (1U << 3);  ///< RTC reset bit
        constexpr uint32_t RUN = (1U << 2);  ///< RTC count block operation bit
        constexpr uint32_t ST = (1U << 0);  ///< Start bit
    }

    /// WTCR11 Register bits
    namespace wtcr11_bits {
        constexpr uint32_t YEN = (1U << 4);  ///< Alarm year register enable bit
        constexpr uint32_t MOEN = (1U << 3);  ///< Alarm month register enable bit
        constexpr uint32_t DEN = (1U << 2);  ///< Alarm day register enable bit
        constexpr uint32_t HEN = (1U << 1);  ///< Alarm hour register enable bit
        constexpr uint32_t MIEN = (1U << 0);  ///< Alarm minute register enable bit
    }

    /// WTCR12 Register bits
    namespace wtcr12_bits {
        constexpr uint32_t INTCRI = (1U << 7);  ///< Year/month/date/hour/minute/second/day of the week counter value read completion interrupt flag bit
        constexpr uint32_t INTERI = (1U << 6);  ///< Time rewrite error interrupt flag bit
        constexpr uint32_t INTALI = (1U << 5);  ///< Alarm coincidence flag bit
        constexpr uint32_t INTTMI = (1U << 4);  ///< Timer underflow detection flag bit
        constexpr uint32_t INTHI = (1U << 3);  ///< Every hour flag bit
        constexpr uint32_t INTMI = (1U << 2);  ///< Every minute flag bit
        constexpr uint32_t INTSI = (1U << 1);  ///< Every second flag bit
        constexpr uint32_t INTSSI = (1U << 0);  ///< Every 0.5-second flag bit
    }

    /// WTCR13 Register bits
    namespace wtcr13_bits {
        constexpr uint32_t INTCRIE = (1U << 7);  ///< Year/month/date/hour/minute/second/day of the week counter value read completion interrupt enable bit
        constexpr uint32_t INTERIE = (1U << 6);  ///< Time rewrite error interrupt enable bit
        constexpr uint32_t INTALIE = (1U << 5);  ///< Alarm coincidence interrupt enable bit
        constexpr uint32_t INTTMIE = (1U << 4);  ///< Timer underflow interrupt enable bit
        constexpr uint32_t INTHIE = (1U << 3);  ///< Every hour interrupt enable bit
        constexpr uint32_t INTMIE = (1U << 2);  ///< Every minute interrupt enable bit
        constexpr uint32_t INTSIE = (1U << 1);  ///< Every second interrupt enable bit
        constexpr uint32_t INTSSIE = (1U << 0);  ///< Every 0.5-second interrupt enable bit
    }

    /// WTCR20 Register bits
    namespace wtcr20_bits {
        constexpr uint32_t PWRITE = (1U << 5);  ///< VBAT PORT save control bit
        constexpr uint32_t PREAD = (1U << 4);  ///< VBAT PORT recall control bit
        constexpr uint32_t BWRITE = (1U << 3);  ///< Back up register save control bit
        constexpr uint32_t BREAD = (1U << 2);  ///< Back up register recall control bit
        constexpr uint32_t CWRITE = (1U << 1);  ///< RTC setting save control bit
        constexpr uint32_t CREAD = (1U << 0);  ///< RTC setting recall control bit
    }

    /// WTCR21 Register bits
    namespace wtcr21_bits {
        constexpr uint32_t TMRUN = (1U << 2);  ///< Timer counter operation bit
        constexpr uint32_t TMEN = (1U << 1);  ///< Timer counter control bit
        constexpr uint32_t TMST = (1U << 0);  ///< Timer counter start bit
    }

    /// WTSR Register bits
    namespace wtsr_bits {
        constexpr uint32_t TS = (3 << 4);  ///< 2nd digit of the second information
        constexpr uint32_t S = (4 << 0);  ///< 1st digit of the second information
    }

    /// WTMIR Register bits
    namespace wtmir_bits {
        constexpr uint32_t TMI = (3 << 4);  ///< 2nd digit of the minute information
        constexpr uint32_t MI = (4 << 0);  ///< 1st digit of the minute information
    }

    /// WTHR Register bits
    namespace wthr_bits {
        constexpr uint32_t TH = (2 << 4);  ///< 2nd digit of the hour information
        constexpr uint32_t H = (4 << 0);  ///< 1st digit of the hour information
    }

    /// WTDR Register bits
    namespace wtdr_bits {
        constexpr uint32_t TD = (2 << 4);  ///< 2nd digit of the day information
        constexpr uint32_t D = (4 << 0);  ///< 1st digit of the day information
    }

    /// WTDW Register bits
    namespace wtdw_bits {
        constexpr uint32_t DW = (3 << 0);  ///< Day of the week information
    }

    /// WTMOR Register bits
    namespace wtmor_bits {
        constexpr uint32_t TMO0 = (1U << 4);  ///< 2nd digit of the month information
        constexpr uint32_t MO = (4 << 0);  ///< 1st digit of the month information
    }

    /// WTYR Register bits
    namespace wtyr_bits {
        constexpr uint32_t TY = (4 << 4);  ///< 2nd digit of the year information
        constexpr uint32_t Y = (4 << 0);  ///< 1st digit of the year information
    }

    /// ALMIR Register bits
    namespace almir_bits {
        constexpr uint32_t TAMI = (3 << 4);  ///< 2nd digit of the alarm-set minute information
        constexpr uint32_t AMI = (4 << 0);  ///< 1st digit of the alarm-set minute information
    }

    /// ALHR Register bits
    namespace alhr_bits {
        constexpr uint32_t TAH = (2 << 4);  ///< 2nd digit of the alarm-set hour information
        constexpr uint32_t AH = (4 << 0);  ///< 1st digit of the alarm-set hour information
    }

    /// ALDR Register bits
    namespace aldr_bits {
        constexpr uint32_t TAD = (2 << 4);  ///< 2nd digit of the alarm-set date information
        constexpr uint32_t AD = (4 << 0);  ///< 1st digit of the alarm-set date information
    }

    /// ALMOR Register bits
    namespace almor_bits {
        constexpr uint32_t TAMO0 = (1U << 4);  ///< 2nd digit of the alarm-set month information
        constexpr uint32_t AMO = (4 << 0);  ///< 1st digit of the alarm-set month information
    }

    /// ALYR Register bits
    namespace alyr_bits {
        constexpr uint32_t TAY = (4 << 4);  ///< 2nd digit of the alarm-set year information
        constexpr uint32_t AY = (4 << 0);  ///< 1st digit of the alarm-set year information
    }

    /// WTTR0 Register bits
    namespace wttr0_bits {
        constexpr uint32_t TM = (8 << 0);  ///< Timer Setting Register
    }

    /// WTTR1 Register bits
    namespace wttr1_bits {
        constexpr uint32_t TM = (8 << 0);  ///< Timer Setting Register
    }

    /// WTTR2 Register bits
    namespace wttr2_bits {
        constexpr uint32_t TM = (2 << 0);  ///< Timer Setting Register
    }

    /// WTCAL0 Register bits
    namespace wtcal0_bits {
        constexpr uint32_t WTCAL0 = (8 << 0);  ///< Frequency correction value setting bits 0
    }

    /// WTCAL1 Register bits
    namespace wtcal1_bits {
        constexpr uint32_t WTCAL1 = (2 << 0);  ///< Frequency correction value setting bits 1
    }

    /// WTCALEN Register bits
    namespace wtcalen_bits {
        constexpr uint32_t WTCALEN = (1U << 0);  ///< Frequency correction enable bit
    }

    /// WTDIV Register bits
    namespace wtdiv_bits {
        constexpr uint32_t WTDIV = (4 << 0);  ///< Division ration setting bits
    }

    /// WTDIVEN Register bits
    namespace wtdiven_bits {
        constexpr uint32_t WTDIVRDY = (1U << 1);  ///< Divider state bit
        constexpr uint32_t WTDIVEN = (1U << 0);  ///< Divider enable bit
    }

    /// WTCALPRD Register bits
    namespace wtcalprd_bits {
        constexpr uint32_t WTCALPRD = (6 << 0);  ///< Frequency correction value setting bits
    }

    /// WTCOSEL Register bits
    namespace wtcosel_bits {
        constexpr uint32_t WTCOSEL = (1U << 0);  ///< RTCCO output selection bit
    }

    /// VB_CLKDIV Register bits
    namespace vb_clkdiv_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Transfer clock set bits
    }

    /// WTOSCCNT Register bits
    namespace wtosccnt_bits {
        constexpr uint32_t SOSCNTL = (1U << 1);  ///< Cooperative operation control bit
        constexpr uint32_t SOSCEX = (1U << 0);  ///< Oscillation enable bit
    }

    /// CCS Register bits
    namespace ccs_bits {
        constexpr uint32_t CCS = (8 << 0);  ///< Oscillation sustain current set bits
    }

    /// CCB Register bits
    namespace ccb_bits {
        constexpr uint32_t CCB = (8 << 0);  ///< Oscillation boost current set bits
    }

    /// BOOST Register bits
    namespace boost_bits {
        constexpr uint32_t BOOST = (2 << 0);  ///< Oscillation boost time set bits
    }

    /// EWKUP Register bits
    namespace ewkup_bits {
        constexpr uint32_t WUP0 = (1U << 0);  ///< Wakeup request bit
    }

    /// VDET Register bits
    namespace vdet_bits {
        constexpr uint32_t PON = (1U << 7);  ///< Power-on bit
    }

    /// HIBRST Register bits
    namespace hibrst_bits {
        constexpr uint32_t HIBRST = (1U << 0);  ///< Hibernation start bit
    }

    /// VBPFR Register bits
    namespace vbpfr_bits {
        constexpr uint32_t SPSR = (2 << 4);  ///< Oscillation pin function set bits
        constexpr uint32_t VPFR3 = (1U << 3);  ///< Port function of P46/X0A pin set bit
        constexpr uint32_t VPFR2 = (1U << 2);  ///< Port function of P47/X1A pin set bit
        constexpr uint32_t VPFR1 = (1U << 1);  ///< Port function of P49/VWAKEUP pin set bit
        constexpr uint32_t VPFR0 = (1U << 0);  ///< Port function of P48/VREGCTL pin set bit
    }

    /// VBPCR Register bits
    namespace vbpcr_bits {
        constexpr uint32_t VPCR3 = (1U << 3);  ///< P46/X0A pin pull-up set bit
        constexpr uint32_t VPCR2 = (1U << 2);  ///< P47/X1A pin pull-up set bit
        constexpr uint32_t VPCR1 = (1U << 1);  ///< P49/VWAKEUP pin pull-up set bit
        constexpr uint32_t VPCR0 = (1U << 0);  ///< P48/VREGCTL pin pull-up set bit
    }

    /// VBDDR Register bits
    namespace vbddr_bits {
        constexpr uint32_t VDDR3 = (1U << 3);  ///< Port direction of P46/X0A pin set bit
        constexpr uint32_t VDDR2 = (1U << 2);  ///< Port direction of P47/X1A pin set bit
        constexpr uint32_t VDDR1 = (1U << 1);  ///< Port direction of P49/VWAKEUP pin set bit
        constexpr uint32_t VDDR0 = (1U << 0);  ///< Port direction of P48/VREGCTL pin set bit
    }

    /// VBDIR Register bits
    namespace vbdir_bits {
        constexpr uint32_t VDIR3 = (1U << 3);  ///< Port input data of P46/X0A pin bit
        constexpr uint32_t VDIR2 = (1U << 2);  ///< Port input data of P47/X1A pin bit
        constexpr uint32_t VDIR1 = (1U << 1);  ///< Port input data of P49/VWAKEUP pin bit
        constexpr uint32_t VDIR0 = (1U << 0);  ///< Port input data of P48/VREGCTL pin bit
    }

    /// VBDOR Register bits
    namespace vbdor_bits {
        constexpr uint32_t VDOR3 = (1U << 3);  ///< Port output data of P46/X0A pin bit
        constexpr uint32_t VDOR2 = (1U << 2);  ///< Port output data of P47/X1A pin bit
        constexpr uint32_t VDOR1 = (1U << 1);  ///< Port output data of P49/VWAKEUP pin bit
        constexpr uint32_t VDOR0 = (1U << 0);  ///< Port output data of P48/VREGCTL pin bit
    }

    /// VBPZR Register bits
    namespace vbpzr_bits {
        constexpr uint32_t VPZR1 = (1U << 1);  ///< P49/VWAKEUP pin pseudo-open drain set bit
        constexpr uint32_t VPZR0 = (1U << 0);  ///< P48/VREGCTL pin pseudo-open drain set bit
    }

}

// ============================================================================
// LCR Peripheral
// ============================================================================

namespace lcr {
    /// Base addresses
    constexpr uint32_t LCR_BASE = 0x4003C000;

    /// LCR Register structure
    struct Registers {
        volatile uint32_t LCR_PRSLD;  ///< Offset: 0x00 - Low-speed CR Prescaler Control Register
    };

    /// Peripheral instances
    inline Registers* LCR = reinterpret_cast<Registers*>(LCR_BASE);

    // Bit definitions
    /// LCR_PRSLD Register bits
    namespace lcr_prsld_bits {
        constexpr uint32_t LCR_PRSLD = (6 << 0);  ///< Low-speed CR Prescaler Load
    }

}

// ============================================================================
// CLK Peripheral
// ============================================================================

namespace clk {
    /// Base addresses
    constexpr uint32_t CLK_GATING_BASE = 0x4003C100;

    /// CLK Register structure
    struct Registers {
        volatile uint32_t CKEN0;  ///< Offset: 0x00 - Peripheral Function Clock Control Register 0
        volatile uint32_t MRST0;  ///< Offset: 0x04 - Peripheral Function Reset Control Register 0
        volatile uint32_t CKEN1;  ///< Offset: 0x10 - Peripheral Function Clock Control Register 1
        volatile uint32_t MRST1;  ///< Offset: 0x14 - Peripheral Function Reset Control Register 1
        volatile uint32_t CKEN2;  ///< Offset: 0x20 - Peripheral Function Clock Control Register 2
        volatile uint32_t MRST2;  ///< Offset: 0x24 - Peripheral Function Reset Control Register 2
    };

    /// Peripheral instances
    inline Registers* CLK_GATING = reinterpret_cast<Registers*>(CLK_GATING_BASE);

    // Bit definitions
    /// CKEN0 Register bits
    namespace cken0_bits {
        constexpr uint32_t GIOCK = (1U << 28);  ///< Settings for operation clock supplying and gating to GPIO function
        constexpr uint32_t EXBCK = (1U << 26);  ///< Settings for operation clock supplying and gating of external bus interface function
        constexpr uint32_t DMACK = (1U << 24);  ///< Supplying and gating settings of DMAC operation clock
        constexpr uint32_t ADCCK3 = (1U << 19);  ///< Settings for operation clock supplying and gating to A/D converter unit 3
        constexpr uint32_t ADCCK2 = (1U << 18);  ///< Settings for operation clock supplying and gating to A/D converter unit 2
        constexpr uint32_t ADCCK1 = (1U << 17);  ///< Settings for operation clock supplying and gating to A/D converter unit 1
        constexpr uint32_t ADCCK0 = (1U << 16);  ///< Settings for operation clock supplying and gating to A/D converter unit 0
        constexpr uint32_t MFSCK15 = (1U << 15);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.15
        constexpr uint32_t MFSCK14 = (1U << 14);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.14
        constexpr uint32_t MFSCK13 = (1U << 13);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.13
        constexpr uint32_t MFSCK12 = (1U << 12);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.12
        constexpr uint32_t MFSCK11 = (1U << 11);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.11
        constexpr uint32_t MFSCK10 = (1U << 10);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.10
        constexpr uint32_t MFSCK9 = (1U << 9);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.9
        constexpr uint32_t MFSCK8 = (1U << 8);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.8
        constexpr uint32_t MFSCK7 = (1U << 7);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.7
        constexpr uint32_t MFSCK6 = (1U << 6);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.6
        constexpr uint32_t MFSCK5 = (1U << 5);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.5
        constexpr uint32_t MFSCK4 = (1U << 4);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.4
        constexpr uint32_t MFSCK3 = (1U << 3);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.3
        constexpr uint32_t MFSCK2 = (1U << 2);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.2
        constexpr uint32_t MFSCK1 = (1U << 1);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.1
        constexpr uint32_t MFSCK0 = (1U << 0);  ///< Settings for operation clock supply and gating to multi-function serial interface ch.0
    }

    /// MRST0 Register bits
    namespace mrst0_bits {
        constexpr uint32_t EXBRST = (1U << 26);  ///< Reset control for external bus interface
        constexpr uint32_t DMARST = (1U << 24);  ///< Reset control of DMAC
        constexpr uint32_t ADCRST3 = (1U << 19);  ///< Reset control of A/D converter unit 3
        constexpr uint32_t ADCRST2 = (1U << 18);  ///< Reset control of A/D converter unit 2
        constexpr uint32_t ADCRST1 = (1U << 17);  ///< Reset control of A/D converter unit 1
        constexpr uint32_t ADCRST0 = (1U << 16);  ///< Reset control of A/D converter unit 0
        constexpr uint32_t MFSRST15 = (1U << 15);  ///< Control of software reset of multi-function serial interface ch.15
        constexpr uint32_t MFSRST14 = (1U << 14);  ///< Control of software reset of multi-function serial interface ch.14
        constexpr uint32_t MFSRST13 = (1U << 13);  ///< Control of software reset of multi-function serial interface ch.13
        constexpr uint32_t MFSRST12 = (1U << 12);  ///< Control of software reset of multi-function serial interface ch.12
        constexpr uint32_t MFSRST11 = (1U << 11);  ///< Control of software reset of multi-function serial interface ch.11
        constexpr uint32_t MFSRST10 = (1U << 10);  ///< Control of software reset of multi-function serial interface ch.10
        constexpr uint32_t MFSRST9 = (1U << 9);  ///< Control of software reset of multi-function serial interface ch.9
        constexpr uint32_t MFSRST8 = (1U << 8);  ///< Control of software reset of multi-function serial interface ch.8
        constexpr uint32_t MFSRST7 = (1U << 7);  ///< Control of software reset of multi-function serial interface ch.7
        constexpr uint32_t MFSRST6 = (1U << 6);  ///< Control of software reset of multi-function serial interface ch.6
        constexpr uint32_t MFSRST5 = (1U << 5);  ///< Control of software reset of multi-function serial interface ch.5
        constexpr uint32_t MFSRST4 = (1U << 4);  ///< Control of software reset of multi-function serial interface ch.4
        constexpr uint32_t MFSRST3 = (1U << 3);  ///< Control of software reset of multi-function serial interface ch.3
        constexpr uint32_t MFSRST2 = (1U << 2);  ///< Control of software reset of multi-function serial interface ch.2
        constexpr uint32_t MFSRST1 = (1U << 1);  ///< Control of software reset of multi-function serial interface ch.1
        constexpr uint32_t MFSRST0 = (1U << 0);  ///< Control of software reset of multi-function serial interface ch.0
    }

    /// CKEN1 Register bits
    namespace cken1_bits {
        constexpr uint32_t QDUCK3 = (1U << 19);  ///< Reset control of quad counter unit 3
        constexpr uint32_t QDUCK2 = (1U << 18);  ///< Reset control of quad counter unit 2
        constexpr uint32_t QDUCK1 = (1U << 17);  ///< Reset control of quad counter unit 1
        constexpr uint32_t QDUCK0 = (1U << 16);  ///< Reset control of quad counter unit 0
        constexpr uint32_t MFTCK3 = (1U << 11);  ///< Settings for operation clock supply and gating of multi-function timer 3 and PPG 24/26/28/30
        constexpr uint32_t MFTCK2 = (1U << 10);  ///< Settings for operation clock supply and gating of multi-function timer 2 and PPG 16/18/20/22
        constexpr uint32_t MFTCK1 = (1U << 9);  ///< Settings for operation clock supply and gating of multi-function timer 1 and PPG 8/10/12/14
        constexpr uint32_t MFTCK0 = (1U << 8);  ///< Settings for operation clock supply and gating of multi-function timer 0 and PPG 0/2/4/6
        constexpr uint32_t BTMCK3 = (1U << 3);  ///< Settings operation clock supply and gating to base timer 12/13/14/15
        constexpr uint32_t BTMCK2 = (1U << 2);  ///< Settings operation clock supply and gating to base timer 8/9/10/11
        constexpr uint32_t BTMCK1 = (1U << 1);  ///< Settings operation clock supply and gating to base timer 4/5/6/7
        constexpr uint32_t BTMCK0 = (1U << 0);  ///< Settings operation clock supply and gating to base timer 0/1/2/3
    }

    /// MRST1 Register bits
    namespace mrst1_bits {
        constexpr uint32_t QDURST3 = (1U << 19);  ///< Reset control of quad counter unit 3
        constexpr uint32_t QDURST2 = (1U << 18);  ///< Reset control of quad counter unit 2
        constexpr uint32_t QDURST1 = (1U << 17);  ///< Reset control of quad counter unit 1
        constexpr uint32_t QDURST0 = (1U << 16);  ///< Reset control of quad counter unit 0
        constexpr uint32_t MFTRST3 = (1U << 11);  ///< Control of multi-function timer 3 and PPG 24/26/28/30 reset control
        constexpr uint32_t MFTRST2 = (1U << 10);  ///< Control of multi-function timer 2 and PPG 16/18/20/22 reset control
        constexpr uint32_t MFTRST1 = (1U << 9);  ///< Control of multi-function timer 1 and PPG 8/10/12/14 reset control
        constexpr uint32_t MFTRST0 = (1U << 8);  ///< Control of multi-function timer 0 and PPG 0/2/4/6 reset control
        constexpr uint32_t BTMRST3 = (1U << 3);  ///< Reset control of base timer 12/13/14/15
        constexpr uint32_t BTMRST2 = (1U << 2);  ///< Reset control of base timer 8/9/10/11
        constexpr uint32_t BTMRST1 = (1U << 1);  ///< Reset control of base timer 4/5/6/7
        constexpr uint32_t BTMRST0 = (1U << 0);  ///< Reset control of base timer 0/1/2/3
    }

    /// CKEN2 Register bits
    namespace cken2_bits {
        constexpr uint32_t QSPICK = (1U << 28);  ///< 28
        constexpr uint32_t CECCK1 = (1U << 25);  ///< 25
        constexpr uint32_t CECCK0 = (1U << 24);  ///< 24
        constexpr uint32_t PCRCCK = (1U << 20);  ///< 20
        constexpr uint32_t I2SCK1 = (1U << 17);  ///< 17
        constexpr uint32_t I2SCK0 = (1U << 16);  ///< 16
        constexpr uint32_t SDCCK = (1U << 8);  ///< Settings for operation clock supply and gating to SD card interface
        constexpr uint32_t CANCK2 = (1U << 6);  ///< Settings for operation clock supply and gating to SD card interface
        constexpr uint32_t CANCK1 = (1U << 5);  ///< Settings for clock supply and gating to CAN controller ch.1
        constexpr uint32_t CANCK0 = (1U << 4);  ///< Settings for clock supply and gating to CAN controller ch.0
        constexpr uint32_t USBCK1 = (1U << 1);  ///< Settings for operation clock supply and gating of USB(function/host) ch.1
        constexpr uint32_t USBCK0 = (1U << 0);  ///< Settings for operation clock supply and gating of USB(function/host) ch.0
    }

    /// MRST2 Register bits
    namespace mrst2_bits {
        constexpr uint32_t QSPIRST = (1U << 28);  ///< 28
        constexpr uint32_t CECRST1 = (1U << 25);  ///< 25
        constexpr uint32_t CECRST0 = (1U << 24);  ///< 24
        constexpr uint32_t PCRCRST = (1U << 20);  ///< 20
        constexpr uint32_t I2SRST1 = (1U << 17);  ///< 17
        constexpr uint32_t I2SRST0 = (1U << 16);  ///< 16
        constexpr uint32_t SDCRST = (1U << 8);  ///< Reset control of SD card interface
        constexpr uint32_t CANRST2 = (1U << 6);  ///< Reset control of SD card interface
        constexpr uint32_t CANRST1 = (1U << 5);  ///< Reset control of CAN controller ch.1
        constexpr uint32_t CANRST0 = (1U << 4);  ///< Reset control of CAN controller ch.0
        constexpr uint32_t USBRST1 = (1U << 1);  ///< Reset control of USB (function/host) ch.1
        constexpr uint32_t USBRST0 = (1U << 0);  ///< Reset control of USB (function/host) ch.0
    }

}

// ============================================================================
// PLL Peripheral
// ============================================================================

namespace pll {
    /// Base addresses
    constexpr uint32_t PLL_CONTROL_BASE = 0x4003C800;

    /// PLL Register structure
    struct Registers {
        volatile uint32_t SSCTL1;  ///< Offset: 0x00 - SSCTL1
        volatile uint32_t SSCTL2;  ///< Offset: 0x04 - SSCTL2
    };

    /// Peripheral instances
    inline Registers* PLL_CONTROL = reinterpret_cast<Registers*>(PLL_CONTROL_BASE);

}

// ============================================================================
// EXBUS Peripheral
// ============================================================================

namespace exbus {
    /// Base addresses
    constexpr uint32_t EXBUS_BASE = 0x4003F000;

    /// EXBUS Register structure
    struct Registers {
        volatile uint32_t MODE0;  ///< Offset: 0x00 - Mode Register 0
        volatile uint32_t MODE1;  ///< Offset: 0x04 - Mode Register 1
        volatile uint32_t MODE2;  ///< Offset: 0x08 - Mode Register 2
        volatile uint32_t MODE3;  ///< Offset: 0x0C - Mode Register 3
        volatile uint32_t MODE4;  ///< Offset: 0x10 - Mode Register 4
        volatile uint32_t MODE5;  ///< Offset: 0x14 - Mode Register 5
        volatile uint32_t MODE6;  ///< Offset: 0x18 - Mode Register 6
        volatile uint32_t MODE7;  ///< Offset: 0x1C - Mode Register 7
        volatile uint32_t TIM0;  ///< Offset: 0x20 - Timing Register 0
        volatile uint32_t TIM1;  ///< Offset: 0x24 - Timing Register 1
        volatile uint32_t TIM2;  ///< Offset: 0x28 - Timing Register 2
        volatile uint32_t TIM3;  ///< Offset: 0x2C - Timing Register 3
        volatile uint32_t TIM4;  ///< Offset: 0x30 - Timing Register 4
        volatile uint32_t TIM5;  ///< Offset: 0x34 - Timing Register 5
        volatile uint32_t TIM6;  ///< Offset: 0x38 - Timing Register 6
        volatile uint32_t TIM7;  ///< Offset: 0x3C - Timing Register 7
        volatile uint32_t AREA0;  ///< Offset: 0x40 - Area Register 0
        volatile uint32_t AREA1;  ///< Offset: 0x44 - Area Register 1
        volatile uint32_t AREA2;  ///< Offset: 0x48 - Area Register 2
        volatile uint32_t AREA3;  ///< Offset: 0x4C - Area Register 3
        volatile uint32_t AREA4;  ///< Offset: 0x50 - Area Register 4
        volatile uint32_t AREA5;  ///< Offset: 0x54 - Area Register 5
        volatile uint32_t AREA6;  ///< Offset: 0x58 - Area Register 6
        volatile uint32_t AREA7;  ///< Offset: 0x5C - Area Register 7
        volatile uint32_t ATIM0;  ///< Offset: 0x60 - ALE Timing Register 0
        volatile uint32_t ATIM1;  ///< Offset: 0x64 - ALE Timing Register 1
        volatile uint32_t ATIM2;  ///< Offset: 0x68 - ALE Timing Register 2
        volatile uint32_t ATIM3;  ///< Offset: 0x6C - ALE Timing Register 3
        volatile uint32_t ATIM4;  ///< Offset: 0x70 - ALE Timing Register 4
        volatile uint32_t ATIM5;  ///< Offset: 0x74 - ALE Timing Register 5
        volatile uint32_t ATIM6;  ///< Offset: 0x78 - ALE Timing Register 6
        volatile uint32_t ATIM7;  ///< Offset: 0x7C - ALE Timing Register 7
        volatile uint32_t SDMODE;  ///< Offset: 0x100 - SDRAM Mode Register
        volatile uint32_t REFTIM;  ///< Offset: 0x104 - Refresh Timer Register
        volatile uint32_t PWRDWN;  ///< Offset: 0x108 - Power Down Count Register
        volatile uint32_t SDTIM;  ///< Offset: 0x10C - SDRAM Timing Register
        volatile uint32_t SDCMD;  ///< Offset: 0x110 - SDRAM Command Register
        volatile uint32_t MEMCERR;  ///< Offset: 0x200 - Memory Controller Register
        volatile uint32_t DCLKR;  ///< Offset: 0x300 - Division Clock Register
        volatile uint32_t EST;  ///< Offset: 0x304 - Error Status Register
        volatile uint32_t WEAD;  ///< Offset: 0x308 - Write Error Address Register
        volatile uint32_t ESCLR;  ///< Offset: 0x30C - Error Status Clear Register
        volatile uint32_t AMODE;  ///< Offset: 0x310 - Access Mode Register
    };

    /// Peripheral instances
    inline Registers* EXBUS = reinterpret_cast<Registers*>(EXBUS_BASE);

    // Bit definitions
    /// MODE0 Register bits
    namespace mode0_bits {
        constexpr uint32_t MOEXEUP = (1U << 13);  ///< select how to set the MOEX width
        constexpr uint32_t MPXCSOF = (1U << 12);  ///< select a CS assertion from the start of accessing to the end of address output
        constexpr uint32_t MPXDOFF = (1U << 11);  ///< select whether or not the address is output to the data lines in multiplex mode
        constexpr uint32_t ALEINV = (1U << 9);  ///< set up the polarity of the ALE signal
        constexpr uint32_t MPXMODE = (1U << 8);  ///< select operation bus mode
        constexpr uint32_t SHRTDOUT = (1U << 7);  ///< select to which idle cycle the write data output is extended
        constexpr uint32_t RDY = (1U << 6);  ///< control the external RDY function
        constexpr uint32_t PAGE = (1U << 5);  ///< NOR Flash memory page access mode
        constexpr uint32_t NAND = (1U << 4);  ///< NAND Flash memory mode
        constexpr uint32_t WEOFF = (1U << 3);  ///< disable the write enable signal (MWEX) operation
        constexpr uint32_t RBMON = (1U << 2);  ///< Read Byte Mask ON
        constexpr uint32_t WDTH = (2 << 0);  ///< specify Data Width
    }

    /// TIM0 Register bits
    namespace tim0_bits {
        constexpr uint32_t WIDLC = (4 << 28);  ///< Write Idle Cycle
        constexpr uint32_t WWEC = (4 << 24);  ///< Write Enable Cycle
        constexpr uint32_t WADC = (4 << 20);  ///< Write Address Setup cycle
        constexpr uint32_t WACC = (4 << 16);  ///< Write Access Cycle
        constexpr uint32_t RIDLC = (4 << 12);  ///< Read Idle Cycle
        constexpr uint32_t FRADC = (4 << 8);  ///< First Read Address Cycle
        constexpr uint32_t RADC = (4 << 4);  ///< Read Address Setup cycle
        constexpr uint32_t RACC = (4 << 0);  ///< Read Access Cycle
    }

    /// AREA0 Register bits
    namespace area0_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA1 Register bits
    namespace area1_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA2 Register bits
    namespace area2_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA3 Register bits
    namespace area3_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA4 Register bits
    namespace area4_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA5 Register bits
    namespace area5_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA6 Register bits
    namespace area6_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// AREA7 Register bits
    namespace area7_bits {
        constexpr uint32_t MASK = (7 << 16);  ///< address mask
        constexpr uint32_t ADDR = (8 << 0);  ///< Address
    }

    /// ATIM0 Register bits
    namespace atim0_bits {
        constexpr uint32_t ALEW = (4 << 8);  ///< Address Latch Enable Width
        constexpr uint32_t ALES = (4 << 4);  ///< Address Latch Enable Setup cycle
        constexpr uint32_t ALC = (4 << 0);  ///< Address Latch Cycle
    }

    /// SDMODE Register bits
    namespace sdmode_bits {
        constexpr uint32_t MSDCLKOFF = (1U << 16);  ///< MSDCLK OFF
        constexpr uint32_t BASEL = (4 << 12);  ///< Bank Address Select
        constexpr uint32_t RASEL = (4 << 8);  ///< Row Address Select
        constexpr uint32_t CASEL = (2 << 4);  ///< Column Address Select
        constexpr uint32_t ROFF = (1U << 2);  ///< Refresh OFF
        constexpr uint32_t PDON = (1U << 1);  ///< Power Down ON
        constexpr uint32_t SDON = (1U << 0);  ///< SDRAM ON
    }

    /// REFTIM Register bits
    namespace reftim_bits {
        constexpr uint32_t PREF = (1U << 24);  ///< Pre-Refresh
        constexpr uint32_t NREF = (8 << 16);  ///< Number of Refresh
        constexpr uint32_t REFC = (16 << 0);  ///< Refresh Count
    }

    /// PWRDWN Register bits
    namespace pwrdwn_bits {
        constexpr uint32_t PDC = (16 << 0);  ///< Power Down Count
    }

    /// SDTIM Register bits
    namespace sdtim_bits {
        constexpr uint32_t BOFF = (1U << 31);  ///< Buffer readout bit
        constexpr uint32_t TDPL = (2 << 24);  ///< Data-in to Precharge Lead Time
        constexpr uint32_t TREFC = (4 << 20);  ///< Refresh Cycle time
        constexpr uint32_t TRAS = (4 << 16);  ///< RAS active time
        constexpr uint32_t TRCD = (4 << 12);  ///< RAS-CAS Delay
        constexpr uint32_t TRP = (4 << 8);  ///< RAS Precharge time
        constexpr uint32_t TRC = (4 << 4);  ///< RAS Cycle time
        constexpr uint32_t CL = (2 << 0);  ///< CAS Latency
    }

    /// SDCMD Register bits
    namespace sdcmd_bits {
        constexpr uint32_t PEND = (1U << 31);  ///< Pend
        constexpr uint32_t SDCKE = (1U << 20);  ///< SDRAM CKE
        constexpr uint32_t SDCS = (1U << 19);  ///< SDRAM Chip Select
        constexpr uint32_t SDRAS = (1U << 18);  ///< SDRAM RAS
        constexpr uint32_t SDCAS = (1U << 17);  ///< SDRAM CAS
        constexpr uint32_t SDWE = (1U << 16);  ///< SDRAM Write Enable
        constexpr uint32_t SDAD = (16 << 0);  ///< SDRAM ADress
    }

    /// MEMCERR Register bits
    namespace memcerr_bits {
        constexpr uint32_t SDION = (1U << 3);  ///< SDRAM error Interrupt ON
        constexpr uint32_t SFION = (1U << 2);  ///< SRAM/Flash error Interrupt ON
        constexpr uint32_t SDER = (1U << 1);  ///< SDRAM Error
        constexpr uint32_t SFER = (1U << 0);  ///< SRAM/Flash Error
    }

    /// DCLKR Register bits
    namespace dclkr_bits {
        constexpr uint32_t MCLKON = (1U << 4);  ///< MCLK ON
        constexpr uint32_t MDIV = (4 << 0);  ///< MCLK Division Ratio Setup
    }

    /// EST Register bits
    namespace est_bits {
        constexpr uint32_t WERR = (1U << 0);  ///< WERR
    }

    /// WEAD Register bits
    namespace wead_bits {
        constexpr uint32_t ADDR = (32 << 0);  ///< ADDR
    }

    /// ESCLR Register bits
    namespace esclr_bits {
        constexpr uint32_t WERRCLR = (1U << 0);  ///< Write Error Clear
    }

    /// AMODE Register bits
    namespace amode_bits {
        constexpr uint32_t WAEN = (1U << 0);  ///< WAEN
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBETHERCLK_BASE = 0x40036000;
    constexpr uint32_t USB0_BASE = 0x40040000;
    constexpr uint32_t USB1_BASE = 0x40050000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t UCCR;  ///< Offset: 0x00 - USB/Ethernet-PLL Clock Control Register
        volatile uint32_t UPCR1;  ///< Offset: 0x04 - USB/Ethernet-PLL Control Register 1
        volatile uint32_t UPCR2;  ///< Offset: 0x08 - USB/Ethernet-PLL Control Register 2
        volatile uint32_t UPCR3;  ///< Offset: 0x0C - USB/Ethernet-PLL Control Register 3
        volatile uint32_t UPCR4;  ///< Offset: 0x10 - USB/Ethernet-PLL Control Register 4
        volatile uint32_t UP_STR;  ///< Offset: 0x14 - USB/Ethernet-PLL Status Register
        volatile uint32_t UPINT_ENR;  ///< Offset: 0x18 - USB/Ethernet-PLL Interrupt Source Enable Register
        volatile uint32_t UPINT_CLR;  ///< Offset: 0x1C - USB/Ethernet-PLL Interrupt Source Clear Register
        volatile uint32_t UPINT_STR;  ///< Offset: 0x20 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t UPCR5;  ///< Offset: 0x24 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t UPCR6;  ///< Offset: 0x28 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t UPCR7;  ///< Offset: 0x2C - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t USBEN0;  ///< Offset: 0x30 - ERROR!!!!!!!!!!!!!!!!!!!!
        volatile uint32_t USBEN1;  ///< Offset: 0x34 - ERROR!!!!!!!!!!!!!!!!!!!!
    };

    /// Peripheral instances
    inline Registers* USBETHERCLK = reinterpret_cast<Registers*>(USBETHERCLK_BASE);
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);
    inline Registers* USB1 = reinterpret_cast<Registers*>(USB1_BASE);

    // Bit definitions
    /// UCCR Register bits
    namespace uccr_bits {
        constexpr uint32_t ECSEL1 = (1U << 7);  ///< Ethernet clock selection bit 1
        constexpr uint32_t ECSEL0 = (1U << 6);  ///< Ethernet clock selection bit 0
        constexpr uint32_t ECEN = (1U << 4);  ///< Ethernet clock output enable bit
        constexpr uint32_t UCEN1 = (1U << 3);  ///< USB1 clock output enable bit
        constexpr uint32_t UCSEL1 = (1U << 2);  ///< USB1 clock selection bit
        constexpr uint32_t UCSEL0 = (1U << 1);  ///< USB0 clock selection bit
        constexpr uint32_t UCEN0 = (1U << 0);  ///< USB0 clock output enable bit
    }

    /// UPCR1 Register bits
    namespace upcr1_bits {
        constexpr uint32_t UPINC = (1U << 1);  ///< USB/Ethernet-PLL input clock selection bit
        constexpr uint32_t UPLLEN = (1U << 0);  ///< USB/Ethernet-PLL oscillation enable bit
    }

    /// UPCR2 Register bits
    namespace upcr2_bits {
        constexpr uint32_t UPOWT = (3 << 0);  ///< USB/Ethernet-PLL oscillation stabilization wait time setting bit
    }

    /// UPCR3 Register bits
    namespace upcr3_bits {
        constexpr uint32_t UPLLK = (5 << 0);  ///< Frequency division ratio (K) setting bit of the USB/Ethernet-PLL clock
    }

    /// UPCR4 Register bits
    namespace upcr4_bits {
        constexpr uint32_t UPLLN = (7 << 0);  ///< Frequency division ratio (N) setting bit of the USB/Ethernet-PLL clock
    }

    /// UP_STR Register bits
    namespace up_str_bits {
        constexpr uint32_t UPRDY = (1U << 0);  ///< USB/Ethernet-PLL oscillation stabilization bit
    }

    /// UPINT_ENR Register bits
    namespace upint_enr_bits {
        constexpr uint32_t UPCSE = (1U << 0);  ///< USB/Ethernet-PLL oscillation stabilization wait complete interrupt enable bit
    }

    /// UPINT_CLR Register bits
    namespace upint_clr_bits {
        constexpr uint32_t UPCSC = (1U << 0);  ///< USB/Ethernet-PLL oscillation stabilization interrupt source clear bit
    }

    /// UPINT_STR Register bits
    namespace upint_str_bits {
        constexpr uint32_t UPCSI = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// UPCR5 Register bits
    namespace upcr5_bits {
        constexpr uint32_t UPLLM = (4 << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// UPCR6 Register bits
    namespace upcr6_bits {
        constexpr uint32_t UBSR = (4 << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// UPCR7 Register bits
    namespace upcr7_bits {
        constexpr uint32_t EPLLEN = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// USBEN0 Register bits
    namespace usben0_bits {
        constexpr uint32_t USBEN0 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

    /// USBEN1 Register bits
    namespace usben1_bits {
        constexpr uint32_t USBEN1 = (1U << 0);  ///< ERROR!!!!!!!!!!!!!!!!!!!!
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x40060000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMACR;  ///< Offset: 0x00 - Entire DMAC Configuration Register
        volatile uint32_t DMACA0;  ///< Offset: 0x10 - Configuration A Register
        volatile uint32_t DMACB0;  ///< Offset: 0x14 - Configuration B Register
        volatile uint32_t DMACSA0;  ///< Offset: 0x18 - Transfer Source Address Register
        volatile uint32_t DMACDA0;  ///< Offset: 0x1C - Transfer Destination Address Register
        volatile uint32_t DMACA1;  ///< Offset: 0x20 - Configuration A Register 1
        volatile uint32_t DMACB1;  ///< Offset: 0x24 - Configuration B Register 1
        volatile uint32_t DMACSA1;  ///< Offset: 0x28 - Transfer Source Address Register 1
        volatile uint32_t DMACDA1;  ///< Offset: 0x2C - Transfer Destination Address Register 1
        volatile uint32_t DMACA2;  ///< Offset: 0x30 - Configuration A Register 2
        volatile uint32_t DMACB2;  ///< Offset: 0x34 - Configuration B Register 2
        volatile uint32_t DMACSA2;  ///< Offset: 0x38 - Transfer Source Address Register 2
        volatile uint32_t DMACDA2;  ///< Offset: 0x3C - Transfer Destination Address Register 2
        volatile uint32_t DMACA3;  ///< Offset: 0x40 - Configuration A Register 3
        volatile uint32_t DMACB3;  ///< Offset: 0x44 - Configuration B Register 3
        volatile uint32_t DMACSA3;  ///< Offset: 0x48 - Transfer Source Address Register 3
        volatile uint32_t DMACDA3;  ///< Offset: 0x4C - Transfer Destination Address Register 3
        volatile uint32_t DMACA4;  ///< Offset: 0x50 - Configuration A Register 4
        volatile uint32_t DMACB4;  ///< Offset: 0x54 - Configuration B Register 4
        volatile uint32_t DMACSA4;  ///< Offset: 0x58 - Transfer Source Address Register 4
        volatile uint32_t DMACDA4;  ///< Offset: 0x5C - Transfer Destination Address Register 4
        volatile uint32_t DMACA5;  ///< Offset: 0x60 - Configuration A Register 5
        volatile uint32_t DMACB5;  ///< Offset: 0x64 - Configuration B Register 5
        volatile uint32_t DMACSA5;  ///< Offset: 0x68 - Transfer Source Address Register 5
        volatile uint32_t DMACDA5;  ///< Offset: 0x6C - Transfer Destination Address Register 5
        volatile uint32_t DMACA6;  ///< Offset: 0x70 - Configuration A Register 6
        volatile uint32_t DMACB6;  ///< Offset: 0x74 - Configuration B Register 6
        volatile uint32_t DMACSA6;  ///< Offset: 0x78 - Transfer Source Address Register 6
        volatile uint32_t DMACDA6;  ///< Offset: 0x7C - Transfer Destination Address Register 6
        volatile uint32_t DMACA7;  ///< Offset: 0x80 - Configuration A Register 7
        volatile uint32_t DMACB7;  ///< Offset: 0x84 - Configuration B Register 7
        volatile uint32_t DMACSA7;  ///< Offset: 0x88 - Transfer Source Address Register 7
        volatile uint32_t DMACDA7;  ///< Offset: 0x8C - Transfer Destination Address Register 7
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

    // Bit definitions
    /// DMACR Register bits
    namespace dmacr_bits {
        constexpr uint32_t DE = (1U << 31);  ///< DMA Enable (all-channel operation enable bit)
        constexpr uint32_t DS = (1U << 30);  ///< DMA Stop
        constexpr uint32_t PR = (1U << 28);  ///< Priority Rotation
        constexpr uint32_t DH = (4 << 24);  ///< DMA Halt (All-channel pause bit)
    }

    /// DMACA0 Register bits
    namespace dmaca0_bits {
        constexpr uint32_t EB = (1U << 31);  ///< Enable bit (individual-channel operation enable bit)
        constexpr uint32_t PB = (1U << 30);  ///< Pause bit (individual-channel pause bit)
        constexpr uint32_t ST = (1U << 29);  ///< Software Trigger
        constexpr uint32_t IS = (6 << 23);  ///< Input Select
        constexpr uint32_t BC = (4 << 16);  ///< Block Count
        constexpr uint32_t TC = (16 << 0);  ///< Transfer Count
    }

    /// DMACB0 Register bits
    namespace dmacb0_bits {
        constexpr uint32_t MS = (2 << 28);  ///< Mode Select
        constexpr uint32_t TW = (2 << 26);  ///< Transfer Width
        constexpr uint32_t FS = (1U << 25);  ///< Fixed Source
        constexpr uint32_t FD = (1U << 24);  ///< Fixed Destination
        constexpr uint32_t RC = (1U << 23);  ///< Reload Count (BC/TC reload)
        constexpr uint32_t RS = (1U << 22);  ///< Reload Source
        constexpr uint32_t RD = (1U << 21);  ///< Reload Destination
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt (unsuccessful transfer completion interrupt enable)
        constexpr uint32_t CI = (1U << 19);  ///< Completion Interrupt (successful transfer completion interrupt enable)
        constexpr uint32_t SS = (3 << 16);  ///< Stop Status (stop status notification)
        constexpr uint32_t EM = (1U << 0);  ///< Enable bit Mask (EB bit clear mask)
    }

}

// ============================================================================
// DSTC Peripheral
// ============================================================================

namespace dstc {
    /// Base addresses
    constexpr uint32_t DSTC_BASE = 0x40061000;

    /// DSTC Register structure
    struct Registers {
        volatile uint32_t DESTP;  ///< Offset: 0x00 - Descriptor top address Register
        volatile uint32_t HWDESP;  ///< Offset: 0x04 - Hardware DES pointer Register
        volatile uint32_t CMD;  ///< Offset: 0x08 - Command Register
        volatile uint32_t CFG;  ///< Offset: 0x09 - Configuration Register
        volatile uint32_t SWTR;  ///< Offset: 0x0A - Software trigger Register
        volatile uint32_t MONERS;  ///< Offset: 0x0C - MONERS Register
        volatile uint32_t DREQENB0;  ///< Offset: 0x10 - DMA request enable Register 0
        volatile uint32_t DREQENB1;  ///< Offset: 0x14 - DMA request enable Register 1
        volatile uint32_t DREQENB2;  ///< Offset: 0x18 - DMA request enable Register 2
        volatile uint32_t DREQENB3;  ///< Offset: 0x1C - DMA request enable Register 3
        volatile uint32_t DREQENB4;  ///< Offset: 0x20 - DMA request enable Register 4
        volatile uint32_t DREQENB5;  ///< Offset: 0x24 - DMA request enable Register 5
        volatile uint32_t DREQENB6;  ///< Offset: 0x28 - DMA request enable Register 6
        volatile uint32_t DREQENB7;  ///< Offset: 0x2C - DMA request enable Register 7
        volatile uint32_t HWINT0;  ///< Offset: 0x30 - Hardware transfer interrupt Register 0
        volatile uint32_t HWINT1;  ///< Offset: 0x34 - Hardware transfer interrupt Register 1
        volatile uint32_t HWINT2;  ///< Offset: 0x38 - Hardware transfer interrupt Register 2
        volatile uint32_t HWINT3;  ///< Offset: 0x3C - Hardware transfer interrupt Register 3
        volatile uint32_t HWINT4;  ///< Offset: 0x40 - Hardware transfer interrupt Register 4
        volatile uint32_t HWINT5;  ///< Offset: 0x44 - Hardware transfer interrupt Register 5
        volatile uint32_t HWINT6;  ///< Offset: 0x48 - Hardware transfer interrupt Register 6
        volatile uint32_t HWINT7;  ///< Offset: 0x4C - Hardware transfer interrupt Register 7
        volatile uint32_t HWINTCLR0;  ///< Offset: 0x50 - Hardware transfer interrupt clear Register 0
        volatile uint32_t HWINTCLR1;  ///< Offset: 0x54 - Hardware transfer interrupt clear Register 1
        volatile uint32_t HWINTCLR2;  ///< Offset: 0x58 - Hardware transfer interrupt clear Register 2
        volatile uint32_t HWINTCLR3;  ///< Offset: 0x5C - Hardware transfer interrupt clear Register 3
        volatile uint32_t HWINTCLR4;  ///< Offset: 0x60 - Hardware transfer interrupt clear Register 4
        volatile uint32_t HWINTCLR5;  ///< Offset: 0x64 - Hardware transfer interrupt clear Register 5
        volatile uint32_t HWINTCLR6;  ///< Offset: 0x68 - Hardware transfer interrupt clear Register 6
        volatile uint32_t HWINTCLR7;  ///< Offset: 0x6C - Hardware transfer interrupt clear Register 7
        volatile uint32_t DQMSK0;  ///< Offset: 0x70 - DMA request mask Register 0
        volatile uint32_t DQMSK1;  ///< Offset: 0x74 - DMA request mask Register 1
        volatile uint32_t DQMSK2;  ///< Offset: 0x78 - DMA request mask Register 2
        volatile uint32_t DQMSK3;  ///< Offset: 0x7C - DMA request mask Register 3
        volatile uint32_t DQMSK4;  ///< Offset: 0x80 - DMA request mask Register 4
        volatile uint32_t DQMSK5;  ///< Offset: 0x84 - DMA request mask Register 5
        volatile uint32_t DQMSK6;  ///< Offset: 0x88 - DMA request mask Register 6
        volatile uint32_t DQMSK7;  ///< Offset: 0x8C - DMA request mask Register 7
        volatile uint32_t DQMSKCLR0;  ///< Offset: 0x90 - DMA request mask clear Register 0
        volatile uint32_t DQMSKCLR1;  ///< Offset: 0x94 - DMA request mask clear Register 1
        volatile uint32_t DQMSKCLR2;  ///< Offset: 0x98 - DMA request mask clear Register 2
        volatile uint32_t DQMSKCLR3;  ///< Offset: 0x9C - DMA request mask clear Register 3
        volatile uint32_t DQMSKCLR4;  ///< Offset: 0xA0 - DMA request mask clear Register 4
        volatile uint32_t DQMSKCLR5;  ///< Offset: 0xA4 - DMA request mask clear Register 5
        volatile uint32_t DQMSKCLR6;  ///< Offset: 0xA8 - DMA request mask clear Register 6
        volatile uint32_t DQMSKCLR7;  ///< Offset: 0xAC - DMA request mask clear Register 7
    };

    /// Peripheral instances
    inline Registers* DSTC = reinterpret_cast<Registers*>(DSTC_BASE);

    // Bit definitions
    /// HWDESP Register bits
    namespace hwdesp_bits {
        constexpr uint32_t HWDESP = (14 << 16);  ///< HWDESP
        constexpr uint32_t CHANNEL = (8 << 0);  ///< CHANNEL
    }

    /// CFG Register bits
    namespace cfg_bits {
        constexpr uint32_t SWPR = (3 << 4);  ///< Software transfer priority
        constexpr uint32_t ESTE = (1U << 3);  ///< Error stop enable
        constexpr uint32_t RBDIS = (1U << 2);  ///< Read skip buffer disable
        constexpr uint32_t ERINTE = (1U << 1);  ///< Error interrupt enable
        constexpr uint32_t SWINTE = (1U << 0);  ///< Software interrupt enable
    }

    /// SWTR Register bits
    namespace swtr_bits {
        constexpr uint32_t SWST = (1U << 15);  ///< Software status
        constexpr uint32_t SWREQ = (1U << 14);  ///< Software request
        constexpr uint32_t SWDESP = (14 << 0);  ///< Software DES pointer
    }

    /// MONERS Register bits
    namespace moners_bits {
        constexpr uint32_t EDESP = (14 << 16);  ///< Error DES pointer
        constexpr uint32_t ECH = (8 << 8);  ///< Error hardware channel
        constexpr uint32_t EHS = (1U << 6);  ///< Error hardware software
        constexpr uint32_t ESTOP = (1U << 4);  ///< Error stop
        constexpr uint32_t DER = (1U << 3);  ///< Double error
        constexpr uint32_t EST = (3 << 0);  ///< Error status
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CANPRES_BASE = 0x40037000;
    constexpr uint32_t CAN0_BASE = 0x40062000;
    constexpr uint32_t CAN1_BASE = 0x40063000;
    constexpr uint32_t CANFD_BASE = 0x40070000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CANPRE;  ///< Offset: 0x00 - CAN Prescaler Register
    };

    /// Peripheral instances
    inline Registers* CANPRES = reinterpret_cast<Registers*>(CANPRES_BASE);
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);
    inline Registers* CANFD = reinterpret_cast<Registers*>(CANFD_BASE);

    // Bit definitions
    /// CANPRE Register bits
    namespace canpre_bits {
        constexpr uint32_t CANPRE = (4 << 0);  ///< CAN prescaler setting bits
    }

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETHERNET_MAC0_BASE = 0x40064000;
    constexpr uint32_t ETHERNET_CONTROL_BASE = 0x40066000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - MAC Configuration Register
        volatile uint32_t MFFR;  ///< Offset: 0x04 - MAC Frame Filter Register
        volatile uint32_t MHTRH;  ///< Offset: 0x08 - MAC Hash Table Register (High)
        volatile uint32_t MHTRL;  ///< Offset: 0x0C - MAC Hash Table Register (Low)
        volatile uint32_t GAR;  ///< Offset: 0x10 - GMII/MII Address Register
        volatile uint32_t GDR;  ///< Offset: 0x14 - GMII/MII Data Register
        volatile uint32_t FCR;  ///< Offset: 0x18 - Flow Control Register
        volatile uint32_t VTR;  ///< Offset: 0x1C - VLAN TAG Register
        volatile uint32_t RWFFR;  ///< Offset: 0x28 - Remote Wake-up Frame Filter Register
        volatile uint32_t PMTR;  ///< Offset: 0x2C - PMT Register
        volatile uint32_t LPICSR;  ///< Offset: 0x30 - LPI Control and Status Register
        volatile uint32_t LPITCR;  ///< Offset: 0x34 - LPI Timers Control Register
        volatile uint32_t ISR;  ///< Offset: 0x38 - Interrupt Status Register
        volatile uint32_t IMR;  ///< Offset: 0x3C - Interrupt Mask Register
        volatile uint32_t MAR0H;  ///< Offset: 0x40 - MAC Address0 Register (High)
        volatile uint32_t MAR0L;  ///< Offset: 0x44 - MAC Address0 Register (Low)
        volatile uint32_t MAR1H;  ///< Offset: 0x48 - MAC Address1 Register -High
        volatile uint32_t MAR1L;  ///< Offset: 0x4C - MAC Address1 Register -Low
        volatile uint32_t MAR2H;  ///< Offset: 0x50 - MAC Address2 Register -High
        volatile uint32_t MAR2L;  ///< Offset: 0x54 - MAC Address2 Register -Low
        volatile uint32_t MAR3H;  ///< Offset: 0x58 - MAC Address3 Register -High
        volatile uint32_t MAR3L;  ///< Offset: 0x5C - MAC Address3 Register -Low
        volatile uint32_t MAR4H;  ///< Offset: 0x60 - MAC Address4 Register -High
        volatile uint32_t MAR4L;  ///< Offset: 0x64 - MAC Address4 Register -Low
        volatile uint32_t MAR5H;  ///< Offset: 0x68 - MAC Address5 Register -High
        volatile uint32_t MAR5L;  ///< Offset: 0x6C - MAC Address5 Register -Low
        volatile uint32_t MAR6H;  ///< Offset: 0x70 - MAC Address6 Register -High
        volatile uint32_t MAR6L;  ///< Offset: 0x74 - MAC Address6 Register -Low
        volatile uint32_t MAR7H;  ///< Offset: 0x78 - MAC Address7 Register -High
        volatile uint32_t MAR7L;  ///< Offset: 0x7C - MAC Address7 Register -Low
        volatile uint32_t MAR8H;  ///< Offset: 0x80 - MAC Address8 Register -High
        volatile uint32_t MAR8L;  ///< Offset: 0x84 - MAC Address8 Register -Low
        volatile uint32_t MAR9H;  ///< Offset: 0x88 - MAC Address9 Register -High
        volatile uint32_t MAR9L;  ///< Offset: 0x8C - MAC Address9 Register -Low
        volatile uint32_t MAR10H;  ///< Offset: 0x90 - MAC Address10 Register -High
        volatile uint32_t MAR10L;  ///< Offset: 0x94 - MAC Address10 Register -Low
        volatile uint32_t MAR11H;  ///< Offset: 0x98 - MAC Address11 Register -High
        volatile uint32_t MAR11L;  ///< Offset: 0x9C - MAC Address11 Register -Low
        volatile uint32_t MAR12H;  ///< Offset: 0xA0 - MAC Address12 Register -High
        volatile uint32_t MAR12L;  ///< Offset: 0xA4 - MAC Address12 Register -Low
        volatile uint32_t MAR13H;  ///< Offset: 0xA8 - MAC Address13 Register -High
        volatile uint32_t MAR13L;  ///< Offset: 0xAC - MAC Address13 Register -Low
        volatile uint32_t MAR14H;  ///< Offset: 0xB0 - MAC Address14 Register -High
        volatile uint32_t MAR14L;  ///< Offset: 0xB4 - MAC Address14 Register -Low
        volatile uint32_t MAR15H;  ///< Offset: 0xB8 - MAC Address15 Register -High
        volatile uint32_t MAR15L;  ///< Offset: 0xBC - MAC Address15 Register -Low
        volatile uint32_t RGSR;  ///< Offset: 0xD8 - RGMII Status Register)
        volatile uint32_t mmc_cntl;  ///< Offset: 0x100 - MMC Control Register
        volatile uint32_t mmc_intr_rx;  ///< Offset: 0x104 - Receive Interrupt Register
        volatile uint32_t mmc_intr_tx;  ///< Offset: 0x108 - MMC Transmit Interrupt Register
        volatile uint32_t mmc_intr_mask_rx;  ///< Offset: 0x10C - MMC Receive Interrupt Mask Register
        volatile uint32_t mmc_intr_mask_tx;  ///< Offset: 0x110 - MMC Transmit Interrupt Mask Register
        volatile uint32_t txoctetcount_gb;  ///< Offset: 0x114 - "Number of bytes transmitted, exclusive of preamble and...
        volatile uint32_t txframecount_gb;  ///< Offset: 0x118 - "Number of good and bad frames transmitted, exclusive of...
        volatile uint32_t txbroadcastframes_g;  ///< Offset: 0x11C - Number of good broadcast frames transmitted
        volatile uint32_t txmulticastframes_g;  ///< Offset: 0x120 - Number of good multicast frames transmitted
        volatile uint32_t tx64octets_gb;  ///< Offset: 0x124 - "Number of good and bad frames transmitted with length...
        volatile uint32_t tx65to127octets_gb;  ///< Offset: 0x128 - "Number of good and bad frames transmitted with length...
        volatile uint32_t tx128to255octets_gb;  ///< Offset: 0x12C - "Number of good and bad frames transmitted with length...
        volatile uint32_t tx256to511octets_gb;  ///< Offset: 0x130 - "Number of good and bad frames transmitted with length...
        volatile uint32_t tx512to1023octets_gb;  ///< Offset: 0x134 - "Number of good and bad frames transmitted with length...
        volatile uint32_t tx1024tomaxoctets_gb;  ///< Offset: 0x138 - "Number of good and bad frames transmitted with length...
        volatile uint32_t txunicastframes_gb;  ///< Offset: 0x13C - Number of good and bad unicast frames transmitted
        volatile uint32_t txmulticastframes_gb;  ///< Offset: 0x140 - Number of good and bad multicast frames transmitted
        volatile uint32_t txbroadcastframes_gb;  ///< Offset: 0x144 - Number of good and bad broadcast frames transmitted
        volatile uint32_t txunderflowerror;  ///< Offset: 0x148 - Number of frames aborted due to frame underflow error
        volatile uint32_t txsinglecol_g;  ///< Offset: 0x14C - Number of successfully transmitted frames after a single...
        volatile uint32_t txmulticol_g;  ///< Offset: 0x150 - Number of successfully transmitted frames after more...
        volatile uint32_t txdeferred;  ///< Offset: 0x154 - Number of successfully transmitted frames after a...
        volatile uint32_t txlatecol;  ///< Offset: 0x158 - Number of frames aborted due to late collision error.
        volatile uint32_t txexesscol;  ///< Offset: 0x15C - Number of frames aborted due to excessive (16) collision errors.
        volatile uint32_t txcarriererror;  ///< Offset: 0x160 - Number of frames aborted due to carrier sense error (no...
        volatile uint32_t txoctetcount_g;  ///< Offset: 0x164 - "Number of bytes transmitted, exclusive of preamble, in...
        volatile uint32_t txframecount_g;  ///< Offset: 0x168 - Number of good frames transmitted.
        volatile uint32_t txexecessdef_g;  ///< Offset: 0x16C - Number of frames aborted due to excessive deferral error...
        volatile uint32_t txpauseframes;  ///< Offset: 0x170 - Number of good PAUSE frames transmitted.
        volatile uint32_t txvlanframes_g;  ///< Offset: 0x174 - "Number of good VLAN frames transmitted, exclusive of...
        volatile uint32_t rxframecount_gb;  ///< Offset: 0x180 - Number of good and bad frames received.
        volatile uint32_t rxoctetcount_gb;  ///< Offset: 0x184 - "Number of bytes received, exclusive of preamble, in...
        volatile uint32_t rxoctetcount_g;  ///< Offset: 0x188 - "Number of bytes received, exclusive of preamble, only...
        volatile uint32_t rxbroadcastframes_g;  ///< Offset: 0x18C - Number of good broadcast frames received.
        volatile uint32_t rxmulticastframes_g;  ///< Offset: 0x190 - Number of good multicast frames received.
        volatile uint32_t rxcrcerror;  ///< Offset: 0x194 - Number of frames received with CRC error.
        volatile uint32_t rxallignmenterror;  ///< Offset: 0x198 - Number of frames received with alignment (dribble)...
        volatile uint32_t rxrunterror;  ///< Offset: 0x19C - Number of frames received with runt (64 bytes and CRC...
        volatile uint32_t rxjabbererror;  ///< Offset: 0x1A0 - Number of frames received with length greater than 1518...
        volatile uint32_t rxundersize_g;  ///< Offset: 0x1A4 - "Number of frames received with length less than 64...
        volatile uint32_t rxoversize_g;  ///< Offset: 0x1A8 - Number of frames received with length greater than the...
        volatile uint32_t rx64octets_gb;  ///< Offset: 0x1AC - "Number of good and bad frames received with length 64...
        volatile uint32_t rx65to127octets_gb;  ///< Offset: 0x1B0 - "Number of good and bad frames received with length...
        volatile uint32_t rx128to255octets_gb;  ///< Offset: 0x1B4 - "Number of good and bad frames received with length...
        volatile uint32_t rx256to511octets_gb;  ///< Offset: 0x1B8 - "Number of good and bad frames received with length...
        volatile uint32_t rx512to1023octets_gb;  ///< Offset: 0x1BC - "Number of good and bad frames received with length...
        volatile uint32_t rx1024tomaxoctets_gb;  ///< Offset: 0x1C0 - "Number of good and bad frames received with length...
        volatile uint32_t rxunicastframes_g;  ///< Offset: 0x1C4 - Number of good unicast frames received.
        volatile uint32_t rxlengtherror;  ///< Offset: 0x1C8 - "Number of frames received with length error (Length...
        volatile uint32_t rxoutofrangetype;  ///< Offset: 0x1CC - Number of frames received with length/type field not...
        volatile uint32_t rxpauseframes;  ///< Offset: 0x1D0 - Number of good and valid PAUSE frames received.
        volatile uint32_t rxfifooverflow;  ///< Offset: 0x1D4 - Number of missed received frames due to FIFO overflow.
        volatile uint32_t rxvlanframes_gb;  ///< Offset: 0x1D8 - Number of good and bad VLAN frames received.
        volatile uint32_t rxwatchdogerror;  ///< Offset: 0x1DC - Number of frames received with error due to watchdog...
        volatile uint32_t mmc_ipc_intr_mask_rx;  ///< Offset: 0x200 - MMC Receive Checksum Offload Interrupt Mask Register
        volatile uint32_t mmc_ipc_intr_rx;  ///< Offset: 0x208 - MMC Receive Checksum Offload Interrupt Register
        volatile uint32_t rxipv4_gd_frms;  ///< Offset: 0x210 - "Number of good IPv4 datagrams received with the TCP,...
        volatile uint32_t rxipv4_hdrerr_frms;  ///< Offset: 0x214 - "Number of IPv4 datagrams received with header errors...
        volatile uint32_t rxipv4_nopay_frms;  ///< Offset: 0x218 - "Number of IPv4 datagram frames received that did not...
        volatile uint32_t rxipv4_frag_frms;  ///< Offset: 0x21C - Number of good IPv4 datagrams with fragmentation
        volatile uint32_t rxipv4_udsbl_frms;  ///< Offset: 0x220 - Number of good IPv4 datagrams received that had a UDP...
        volatile uint32_t rxipv6_gd_frms;  ///< Offset: 0x224 - "Number of good IPv6 datagrams received with TCP, UDP,...
        volatile uint32_t rxipv6_hdrerr_frms;  ///< Offset: 0x228 - Number of IPv6 datagrams received with header errors...
        volatile uint32_t rxipv6_nopay_frms;  ///< Offset: 0x22C - "Number of IPv6 datagram frames received that did not...
        volatile uint32_t rxudp_gd_frms;  ///< Offset: 0x230 - Number of good IP datagrams with a good UDP payload....
        volatile uint32_t rxudp_err_frms;  ///< Offset: 0x234 - Number of good IP datagrams whose UDP payload has a...
        volatile uint32_t rxtcp_gd_frms;  ///< Offset: 0x238 - Number of good IP datagrams with a good TCP payload
        volatile uint32_t rxtcp_err_frms;  ///< Offset: 0x23C - Number of good IP datagrams whose TCP payload has a...
        volatile uint32_t rxicmp_gd_frms;  ///< Offset: 0x240 - Number of good IP datagrams with a good ICMP payload
        volatile uint32_t rxicmp_err_frms;  ///< Offset: 0x244 - Number of good IP datagrams whose ICMP payload has a...
        volatile uint32_t rxipv4_gd_octets;  ///< Offset: 0x250 - "Number of bytes received in good IPv4 datagrams...
        volatile uint32_t rxipv4_hdrerr_octets;  ///< Offset: 0x254 - "Number of bytes received in IPv4 datagrams with header...
        volatile uint32_t rxipv4_nopay_octets;  ///< Offset: 0x258 - "Number of bytes received in IPv4 datagrams that did not...
        volatile uint32_t rxipv4_frag_octets;  ///< Offset: 0x25C - Number of bytes received in fragmented IPv4 datagrams....
        volatile uint32_t rxipv4_udsbl_octets;  ///< Offset: 0x260 - Number of bytes received in a UDP segment that had the...
        volatile uint32_t rxipv6_gd_octets;  ///< Offset: 0x264 - "Number of bytes received in good IPv6 datagrams...
        volatile uint32_t rxipv6_hdrerr_octets;  ///< Offset: 0x268 - "Number of bytes received in IPv6 datagrams with header...
        volatile uint32_t rxipv6_nopay_octets;  ///< Offset: 0x26C - "Number of bytes received in IPv6 datagrams that did not...
        volatile uint32_t rxudp_gd_octets;  ///< Offset: 0x270 - Number of bytes received in a good UDP segment. This...
        volatile uint32_t rxudp_err_octets;  ///< Offset: 0x274 - Number of bytes received in a UDP segment that had...
        volatile uint32_t rxtcp_gd_octets;  ///< Offset: 0x278 - Number of bytes received in a good TCP segment
        volatile uint32_t rxtcp_err_octets;  ///< Offset: 0x27C - Number of bytes received in a TCP segment with checksum errors
        volatile uint32_t rxicmp_gd_octets;  ///< Offset: 0x280 - Number of bytes received in a good ICMP segment
        volatile uint32_t rxicmp_err_octets;  ///< Offset: 0x284 - Number of bytes received in an ICMP segment with checksum errors
        volatile uint32_t TSCR;  ///< Offset: 0x700 - Time Stamp Control Register
        volatile uint32_t SSIR;  ///< Offset: 0x704 - Sub-Second Increment Register
        volatile uint32_t STSR;  ///< Offset: 0x708 - System Time - Seconds Register
        volatile uint32_t STNR;  ///< Offset: 0x70C - System Time - Nanoseconds Register
        volatile uint32_t STSUR;  ///< Offset: 0x710 - System Time - Seconds Update Register
        volatile uint32_t STNUR;  ///< Offset: 0x714 - System Time - Nanoseconds Update Register
        volatile uint32_t TSAR;  ///< Offset: 0x718 - Time Stamp Addend Register
        volatile uint32_t TTSR;  ///< Offset: 0x71C - Target Time Seconds Register
        volatile uint32_t TTNR;  ///< Offset: 0x720 - Target Time Nanoseconds Register
        volatile uint32_t STHWSR;  ///< Offset: 0x724 - System Time - Higher Word Seconds Register
        volatile uint32_t TSR;  ///< Offset: 0x728 - Time Stamp Status Register
        volatile uint32_t PPSCR;  ///< Offset: 0x72C - PPS Control Register
        volatile uint32_t ATNR;  ///< Offset: 0x730 - Auxiliary Time Stamp - Nanoseconds Register
        volatile uint32_t ATSR;  ///< Offset: 0x734 - Auxiliary Time Stamp - Seconds Register
        volatile uint32_t MAR16H;  ///< Offset: 0x800 - MAC Address16 Register -High
        volatile uint32_t MAR16L;  ///< Offset: 0x804 - MAC Address16 Register -Low
        volatile uint32_t MAR17H;  ///< Offset: 0x808 - MAC Address17 Register -High
        volatile uint32_t MAR17L;  ///< Offset: 0x80C - MAC Address17 Register -Low
        volatile uint32_t MAR18H;  ///< Offset: 0x810 - MAC Address18 Register -High
        volatile uint32_t MAR18L;  ///< Offset: 0x814 - MAC Address18 Register -Low
        volatile uint32_t MAR19H;  ///< Offset: 0x818 - MAC Address19 Register -High
        volatile uint32_t MAR19L;  ///< Offset: 0x81C - MAC Address19 Register -Low
        volatile uint32_t MAR20H;  ///< Offset: 0x820 - MAC Address20 Register -High
        volatile uint32_t MAR20L;  ///< Offset: 0x824 - MAC Address20 Register -Low
        volatile uint32_t MAR21H;  ///< Offset: 0x828 - MAC Address21 Register -High
        volatile uint32_t MAR21L;  ///< Offset: 0x82C - MAC Address21 Register -Low
        volatile uint32_t MAR22H;  ///< Offset: 0x830 - MAC Address22 Register -High
        volatile uint32_t MAR22L;  ///< Offset: 0x834 - MAC Address22 Register -Low
        volatile uint32_t MAR23H;  ///< Offset: 0x838 - MAC Address23 Register -High
        volatile uint32_t MAR23L;  ///< Offset: 0x83C - MAC Address23 Register -Low
        volatile uint32_t MAR24H;  ///< Offset: 0x840 - MAC Address24 Register -High
        volatile uint32_t MAR24L;  ///< Offset: 0x844 - MAC Address24 Register -Low
        volatile uint32_t MAR25H;  ///< Offset: 0x848 - MAC Address25 Register -High
        volatile uint32_t MAR25L;  ///< Offset: 0x84C - MAC Address25 Register -Low
        volatile uint32_t MAR26H;  ///< Offset: 0x850 - MAC Address26 Register -High
        volatile uint32_t MAR26L;  ///< Offset: 0x854 - MAC Address26 Register -Low
        volatile uint32_t MAR27H;  ///< Offset: 0x858 - MAC Address27 Register -High
        volatile uint32_t MAR27L;  ///< Offset: 0x85C - MAC Address27 Register -Low
        volatile uint32_t MAR28H;  ///< Offset: 0x860 - MAC Address28 Register -High
        volatile uint32_t MAR28L;  ///< Offset: 0x864 - MAC Address28 Register -Low
        volatile uint32_t MAR29H;  ///< Offset: 0x868 - MAC Address29 Register -High
        volatile uint32_t MAR29L;  ///< Offset: 0x86C - MAC Address29 Register -Low
        volatile uint32_t MAR30H;  ///< Offset: 0x870 - MAC Address30 Register -High
        volatile uint32_t MAR30L;  ///< Offset: 0x874 - MAC Address30 Register -Low
        volatile uint32_t MAR31H;  ///< Offset: 0x878 - MAC Address31 Register -High
        volatile uint32_t MAR31L;  ///< Offset: 0x87C - MAC Address31 Register -Low
        volatile uint32_t BMR;  ///< Offset: 0x1000 - Bus Mode Register
        volatile uint32_t TPDR;  ///< Offset: 0x1004 - Transmit Poll Demand Register)
        volatile uint32_t RPDR;  ///< Offset: 0x1008 - Receive Poll Demand Register
        volatile uint32_t RDLAR;  ///< Offset: 0x100C - Receive Descriptor List Address Register)
        volatile uint32_t TDLAR;  ///< Offset: 0x1010 - Transmit Descriptor List Address Register
        volatile uint32_t SR;  ///< Offset: 0x1014 - Status Register
        volatile uint32_t OMR;  ///< Offset: 0x1018 - Operation Mode Register
        volatile uint32_t IER;  ///< Offset: 0x101C - Interrupt Enable Register
        volatile uint32_t MFBOCR;  ///< Offset: 0x1020 - Missed Frame and Buffer Overflow Counter Register
        volatile uint32_t RIWTR;  ///< Offset: 0x1024 - Receive Interrupt Watchdog Timer Register
        volatile uint32_t AHBSR;  ///< Offset: 0x102C - AHB Status Register
        volatile uint32_t CHTDR;  ///< Offset: 0x1048 - Current Host Transmit Descriptor Register
        volatile uint32_t CHRDR;  ///< Offset: 0x104C - Current Host Receive Descriptor Register
        volatile uint32_t CHTBAR;  ///< Offset: 0x1050 - Current Host Transmit Buffer Address Register
        volatile uint32_t CHRBAR;  ///< Offset: 0x1054 - Current Host Receive Buffer Address Register
    };

    /// Peripheral instances
    inline Registers* ETHERNET_MAC0 = reinterpret_cast<Registers*>(ETHERNET_MAC0_BASE);
    inline Registers* ETHERNET_CONTROL = reinterpret_cast<Registers*>(ETHERNET_CONTROL_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t CST = (1U << 25);  ///< CRC stripping for Type frames
        constexpr uint32_t TC = (1U << 24);  ///< Transmit Configuration in RGMII
        constexpr uint32_t WD = (1U << 23);  ///< Watchdog Disable
        constexpr uint32_t JD = (1U << 22);  ///< Jabber Disable
        constexpr uint32_t BE = (1U << 21);  ///< Frame Burst Enable
        constexpr uint32_t JE = (1U << 20);  ///< Jumbo Frame Enable
        constexpr uint32_t IFG = (3 << 17);  ///< Inter-Frame GAP
        constexpr uint32_t DCRS = (1U << 16);  ///< Disable Carrier Sense During Transaction
        constexpr uint32_t PS = (1U << 15);  ///< Port Select
        constexpr uint32_t FES = (1U << 14);  ///< Speed
        constexpr uint32_t DO_ = (1U << 13);  ///< Disable Receive Own (renamed from DO_)
        constexpr uint32_t LM = (1U << 12);  ///< Loop-back Mode
        constexpr uint32_t DM = (1U << 11);  ///< Duplex mode
        constexpr uint32_t IPC = (1U << 10);  ///< Checksum Offload
        constexpr uint32_t DR = (1U << 9);  ///< Disable Retry
        constexpr uint32_t LUD = (1U << 8);  ///< Link Up/Down in RGMII
        constexpr uint32_t ACS = (1U << 7);  ///< Automatic Pad/CRC Stripping
        constexpr uint32_t BL = (2 << 5);  ///< Back-off Limit
        constexpr uint32_t DC = (1U << 4);  ///< Deferral Check
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
    }

    /// MFFR Register bits
    namespace mffr_bits {
        constexpr uint32_t RA = (1U << 31);  ///< Receive All
        constexpr uint32_t HPF = (1U << 10);  ///< Hash or Perfect Filter
        constexpr uint32_t SAF = (1U << 9);  ///< Source Address Filter
        constexpr uint32_t SAIF = (1U << 8);  ///< Source Address Inverse Filter
        constexpr uint32_t PCF = (2 << 6);  ///< Pass Control Frames
        constexpr uint32_t DB = (1U << 5);  ///< Disable Broadcast Frames
        constexpr uint32_t PM = (1U << 4);  ///< Pass All Multicast
        constexpr uint32_t DAIF = (1U << 3);  ///< DA Inverse Filtering
        constexpr uint32_t HMC = (1U << 2);  ///< Hash Multicast
        constexpr uint32_t HUC = (1U << 1);  ///< Hash Unicast
        constexpr uint32_t PR = (1U << 0);  ///< Promiscuous Mode
    }

    /// MHTRH Register bits
    namespace mhtrh_bits {
        constexpr uint32_t HTH = (32 << 0);  ///< the upper 32 bits of the hash table in the HTH
    }

    /// MHTRL Register bits
    namespace mhtrl_bits {
        constexpr uint32_t HTL = (32 << 0);  ///< the lower 32 bits of the hash table in the HTL
    }

    /// GAR Register bits
    namespace gar_bits {
        constexpr uint32_t PA = (5 << 11);  ///< Physical Layer Address
        constexpr uint32_t GR = (5 << 6);  ///< GMII Register
        constexpr uint32_t CR = (4 << 2);  ///< Application Clock Range
        constexpr uint32_t GW = (1U << 1);  ///< GMII/MII Write
        constexpr uint32_t GB = (1U << 0);  ///< GMII/MII Busy
    }

    /// GDR Register bits
    namespace gdr_bits {
        constexpr uint32_t GD = (16 << 0);  ///< GMII/MII Data Register
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t PT = (16 << 16);  ///< Pause Time
        constexpr uint32_t DZPQ = (1U << 7);  ///< Disable Zero-Quanta Pause
        constexpr uint32_t PLT = (2 << 4);  ///< Pause Low Threshold
        constexpr uint32_t UP = (1U << 3);  ///< Unicast Pause Frame detect
        constexpr uint32_t RFE = (1U << 2);  ///< Receive Flow Control Enable
        constexpr uint32_t TFE = (1U << 1);  ///< Transmit Flow Control Enable
        constexpr uint32_t FCB_BPA = (1U << 0);  ///< Flow Control Busy/Backpressure Activate
    }

    /// VTR Register bits
    namespace vtr_bits {
        constexpr uint32_t ETV = (1U << 16);  ///< Enable 12-Bit VLAN Tag Comparison
        constexpr uint32_t VL = (16 << 0);  ///< VLAN Tag Identifier
    }

    /// RWFFR Register bits
    namespace rwffr_bits {
        constexpr uint32_t RWFFR = (32 << 0);  ///< Remote Wake-up Frame Filter Register
    }

    /// PMTR Register bits
    namespace pmtr_bits {
        constexpr uint32_t RWFFRPR = (1U << 31);  ///< Remote Wake-up Frame Filter Register Pointer Reset
        constexpr uint32_t GU = (1U << 9);  ///< Global Unicast
        constexpr uint32_t WPR = (1U << 6);  ///< Wake Up Frame Receive
        constexpr uint32_t MPR = (1U << 5);  ///< Magic Packet Received
        constexpr uint32_t WFE = (1U << 2);  ///< Wake-Up Frame Enable
        constexpr uint32_t MPE = (1U << 1);  ///< Magic Packet Enable
        constexpr uint32_t PD = (1U << 0);  ///< Power Down
    }

    /// LPICSR Register bits
    namespace lpicsr_bits {
        constexpr uint32_t LPITXA = (1U << 19);  ///< LPI TX Automate
        constexpr uint32_t PLSEN = (1U << 18);  ///< PHY Link Status Enable
        constexpr uint32_t PLS = (1U << 17);  ///< PHY Link Status
        constexpr uint32_t LPIEN = (1U << 16);  ///< LPI Enable
        constexpr uint32_t RLPIST = (1U << 9);  ///< Receive LPI State
        constexpr uint32_t TLPIST = (1U << 8);  ///< Transmit LPI State
        constexpr uint32_t RLPIEX = (1U << 3);  ///< Receive LPI Exit
        constexpr uint32_t RLPIEN = (1U << 2);  ///< Receive LPI Entry
        constexpr uint32_t TLPIEX = (1U << 1);  ///< Transmit LPI Exit
        constexpr uint32_t TLPIEN = (1U << 0);  ///< Transmit LPI Entry
    }

    /// LPITCR Register bits
    namespace lpitcr_bits {
        constexpr uint32_t LIT = (10 << 16);  ///< LPI LS TIMER
        constexpr uint32_t TWT = (16 << 0);  ///< LPI TW TIMER
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t LPIIS = (1U << 10);  ///< LPI Interrupt Status
        constexpr uint32_t TSIS = (1U << 9);  ///< Time Stamp Interrupt Status
        constexpr uint32_t COIS = (1U << 7);  ///< MMC Receive Checksum Offload Interrupt Status
        constexpr uint32_t TIS = (1U << 6);  ///< MMC Transmit Interrupt Status
        constexpr uint32_t RIS = (1U << 5);  ///< MMC Receive Interrupt Status
        constexpr uint32_t MIS = (1U << 4);  ///< MMC Interrupt Status
        constexpr uint32_t PIS = (1U << 3);  ///< PMT Interrupt Status
        constexpr uint32_t RGIS = (1U << 0);  ///< RGMII Interrupt Status
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t LPIIM = (1U << 10);  ///< LPI Interrupt Mask
        constexpr uint32_t TSIM = (1U << 9);  ///< Time Stamp Interrupt Mask
        constexpr uint32_t PIM = (1U << 3);  ///< PMT Interrupt Mask
        constexpr uint32_t RGIM = (1U << 0);  ///< RGMII Interrupt Mask
    }

    /// MAR0H Register bits
    namespace mar0h_bits {
        constexpr uint32_t MO = (1U << 31);  ///< Must be one
        constexpr uint32_t A0 = (16 << 0);  ///< MAC Address0
    }

    /// MAR0L Register bits
    namespace mar0l_bits {
        constexpr uint32_t A0 = (32 << 0);  ///< MAC Address0
    }

    /// MAR1H Register bits
    namespace mar1h_bits {
        constexpr uint32_t AE = (1U << 31);  ///< Address Enable
        constexpr uint32_t SA = (1U << 30);  ///< Source Address
        constexpr uint32_t MBC = (6 << 24);  ///< Mask Byte Control
        constexpr uint32_t A = (16 << 0);  ///< MAC Address
    }

    /// MAR1L Register bits
    namespace mar1l_bits {
        constexpr uint32_t A = (32 << 0);  ///< MAC Address
    }

    /// RGSR Register bits
    namespace rgsr_bits {
        constexpr uint32_t LS = (1U << 3);  ///< Link Status
        constexpr uint32_t LSP = (2 << 1);  ///< Link Speed
        constexpr uint32_t LM = (1U << 0);  ///< Link Mode
    }

    /// TSCR Register bits
    namespace tscr_bits {
        constexpr uint32_t ATSFC = (1U << 24);  ///< Auxiliary Snapshot FIFO Clear
        constexpr uint32_t TSENMF = (1U << 18);  ///< Enable MAC address for PTP frame filtering
        constexpr uint32_t TSPS = (2 << 16);  ///< SelectPTP packets for taking snapshots
        constexpr uint32_t TSMRM = (1U << 15);  ///< Enable Snapshot for Messages Relevant to Master
        constexpr uint32_t TETSEM = (1U << 14);  ///< Enable Time Stamp Snapshot for Event Messages
        constexpr uint32_t TSIP4E = (1U << 13);  ///< Enable Time Stamp Snapshot for IPv4 frames
        constexpr uint32_t TSIP6E = (1U << 12);  ///< Enable Time Stamp Snapshot for IPv6 frames
        constexpr uint32_t TETSP = (1U << 11);  ///< Enable Time Stamp Snapshot for PTP over Ethernet frames
        constexpr uint32_t TSV2E = (1U << 10);  ///< Enable PTP packet snooping for version 2 format
        constexpr uint32_t TSDB = (1U << 9);  ///< Time Stamp Digital or Binary rollover control
        constexpr uint32_t TSEA = (1U << 8);  ///< Enable Time Stamp for All Frames
        constexpr uint32_t TARU = (1U << 5);  ///< Addend Register Update
        constexpr uint32_t TITE = (1U << 4);  ///< Time Stamp Interrupt Trigger Enable
        constexpr uint32_t TSU = (1U << 3);  ///< Time Stamp Update
        constexpr uint32_t TSI = (1U << 2);  ///< Time Stamp Initialize
        constexpr uint32_t TFCU = (1U << 1);  ///< Time Stamp Fine or Coarse Update
        constexpr uint32_t TSE = (1U << 0);  ///< Time Stamp Enable
    }

    /// SSIR Register bits
    namespace ssir_bits {
        constexpr uint32_t SSINC = (8 << 0);  ///< Sub-Second Increment Value
    }

    /// STSR Register bits
    namespace stsr_bits {
        constexpr uint32_t TSS = (32 << 0);  ///< Time Stamp Second
    }

    /// STNR Register bits
    namespace stnr_bits {
        constexpr uint32_t TSSS = (31 << 0);  ///< Time Stamp Sub-Seconds
    }

    /// STSUR Register bits
    namespace stsur_bits {
        constexpr uint32_t TSS = (32 << 0);  ///< Time Stamp Second
    }

    /// STNUR Register bits
    namespace stnur_bits {
        constexpr uint32_t ADDSUB = (1U << 31);  ///< Add or Subtract Time
        constexpr uint32_t TSSS = (31 << 0);  ///< Time Stamp Sub-Seconds
    }

    /// TSAR Register bits
    namespace tsar_bits {
        constexpr uint32_t TSAR = (32 << 0);  ///< Time Stamp Addend Register
    }

    /// TTSR Register bits
    namespace ttsr_bits {
        constexpr uint32_t TSTR = (32 << 0);  ///< Target Time Stamp Seconds Register
    }

    /// TTNR Register bits
    namespace ttnr_bits {
        constexpr uint32_t TSTR = (31 << 0);  ///< Target Time Stamp Nanoseconds Register
    }

    /// STHWSR Register bits
    namespace sthwsr_bits {
        constexpr uint32_t TSHWR = (16 << 0);  ///< Time Stamp Higher Word Register
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t ATSNS = (3 << 25);  ///< Auxiliary Time Stamp Number of Snapshots
        constexpr uint32_t ATSSTM = (1U << 24);  ///< Auxiliary Time Stamp Snapshot Trigger Missed
        constexpr uint32_t TRGTER = (1U << 3);  ///< Timestamp Target Time Error
        constexpr uint32_t ATSTS = (1U << 2);  ///< Auxiliary Time Stamp Trigger Snapshot
        constexpr uint32_t TSTART = (1U << 1);  ///< Time Stamp Target Time Reached
        constexpr uint32_t TSSOVF = (1U << 0);  ///< Time Stamp Seconds Overflow
    }

    /// PPSCR Register bits
    namespace ppscr_bits {
        constexpr uint32_t PPSCTRL = (4 << 0);  ///< Controls the frequency of the PPS output
    }

    /// ATNR Register bits
    namespace atnr_bits {
        constexpr uint32_t ATN = (31 << 0);  ///< ATN
    }

    /// ATSR Register bits
    namespace atsr_bits {
        constexpr uint32_t ATS = (32 << 0);  ///< ATS
    }

    /// BMR Register bits
    namespace bmr_bits {
        constexpr uint32_t TXPR = (1U << 27);  ///< Transmit Priority
        constexpr uint32_t MB = (1U << 26);  ///< Mixed Burst
        constexpr uint32_t AAL = (1U << 25);  ///< Address-Aligned Beats
        constexpr uint32_t _8XPBL = (1U << 24);  ///< 8xPBL Mode
        constexpr uint32_t USP = (1U << 23);  ///< Use Separate PBL
        constexpr uint32_t RPBL = (6 << 17);  ///< RxDMA PBL
        constexpr uint32_t FB = (1U << 16);  ///< Fixed Burst
        constexpr uint32_t PR = (2 << 14);  ///< Rx:Tx priority ratio
        constexpr uint32_t PBL = (6 << 8);  ///< Programmable Burst Length
        constexpr uint32_t ATDS = (1U << 7);  ///< Alternate Descriptor Size
        constexpr uint32_t DSL = (5 << 2);  ///< Descriptor Skip Length
        constexpr uint32_t DA = (1U << 1);  ///< DMA Arbitration scheme
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
    }

    /// TPDR Register bits
    namespace tpdr_bits {
        constexpr uint32_t TPD = (32 << 0);  ///< Transmit Poll Demand
    }

    /// RPDR Register bits
    namespace rpdr_bits {
        constexpr uint32_t RPD = (32 << 0);  ///< Receive Poll Demand
    }

    /// RDLAR Register bits
    namespace rdlar_bits {
        constexpr uint32_t SRL = (30 << 2);  ///< Start of Receive List
    }

    /// TDLAR Register bits
    namespace tdlar_bits {
        constexpr uint32_t STL = (30 << 2);  ///< Start of Transmit List
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t GLPII = (1U << 30);  ///< GMAC LPI Interrupt
        constexpr uint32_t TTI = (1U << 29);  ///< Time-Stamp Trigger Interrupt
        constexpr uint32_t GPI = (1U << 28);  ///< GMAC PMT Interrupt
        constexpr uint32_t GMI = (1U << 27);  ///< GMAC MMC Interrupt
        constexpr uint32_t GLI = (1U << 26);  ///< GMAC Line interface Interrupt
        constexpr uint32_t EB = (3 << 23);  ///< Error Bits
        constexpr uint32_t TS = (3 << 20);  ///< Transmit Process State
        constexpr uint32_t RS = (3 << 17);  ///< Receive Process State
        constexpr uint32_t NIS = (1U << 16);  ///< Normal Interrupt Summary
        constexpr uint32_t AIS = (1U << 15);  ///< Abnormal Interrupt Summary
        constexpr uint32_t ERI = (1U << 14);  ///< Early Receive Interrupt
        constexpr uint32_t FBI = (1U << 13);  ///< Fatal Bus Error Interrupt
        constexpr uint32_t ETI = (1U << 10);  ///< Early Transmit Interrupt
        constexpr uint32_t RWT = (1U << 9);  ///< Receive Watchdog Timeout
        constexpr uint32_t RPS = (1U << 8);  ///< Receive process Stopped
        constexpr uint32_t RU = (1U << 7);  ///< Receive Buffer Unavailable
        constexpr uint32_t RI = (1U << 6);  ///< Receive Interrupt
        constexpr uint32_t UNF = (1U << 5);  ///< Transmit underflow
        constexpr uint32_t OVF = (1U << 4);  ///< Receive Overflow
        constexpr uint32_t TJT = (1U << 3);  ///< Transmit Jabber Timeout
        constexpr uint32_t TU = (1U << 2);  ///< Transmit Buffer Unavailable
        constexpr uint32_t TPS = (1U << 1);  ///< Transmit Process Stopped
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt
    }

    /// OMR Register bits
    namespace omr_bits {
        constexpr uint32_t DT = (1U << 26);  ///< Disable Dropping of TCP/IP Checksum Error Frames
        constexpr uint32_t RSF = (1U << 25);  ///< Receive Store and Forward
        constexpr uint32_t DFF = (1U << 24);  ///< Disable Flushing of Received Frames
        constexpr uint32_t TSF = (1U << 21);  ///< Transmit Store Forward
        constexpr uint32_t FTF = (1U << 20);  ///< Flush Transmit FIFO
        constexpr uint32_t TTC = (3 << 14);  ///< Transmit Threshold Control
        constexpr uint32_t ST = (1U << 13);  ///< Start/Stop Transmission Command
        constexpr uint32_t FEF = (1U << 7);  ///< Forward Error Frames
        constexpr uint32_t FUF = (1U << 6);  ///< Forward Undersized Good Frames
        constexpr uint32_t RTC = (2 << 3);  ///< Receive Threshold Control
        constexpr uint32_t OSF = (1U << 2);  ///< Operate on Second Frame
        constexpr uint32_t SR = (1U << 1);  ///< Start/Stop Receive
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t NIE = (1U << 16);  ///< Normal Interrupt Summary Enable
        constexpr uint32_t AIE = (1U << 15);  ///< Abnormal Interrupt Summary Enable
        constexpr uint32_t ERE = (1U << 14);  ///< Early Receive Interrupt Enable
        constexpr uint32_t FBE = (1U << 13);  ///< Fatal Bus Error Enable
        constexpr uint32_t ETE = (1U << 10);  ///< Early Transmit Interrupt Enable
        constexpr uint32_t RWE = (1U << 9);  ///< Receive Watchdog Timeout Enable
        constexpr uint32_t RSE = (1U << 8);  ///< Receive Process Stopped Enable
        constexpr uint32_t RUE = (1U << 7);  ///< Receive Buffer Unavailable Enable
        constexpr uint32_t RIE = (1U << 6);  ///< Receive Interrupt Enable
        constexpr uint32_t UNE = (1U << 5);  ///< Transmit underflow Enable
        constexpr uint32_t OVE = (1U << 4);  ///< Receive Overflow Enable
        constexpr uint32_t TJE = (1U << 3);  ///< Transmit Jabber Timeout
        constexpr uint32_t TUE = (1U << 2);  ///< Transmit Buffer Unavailable
        constexpr uint32_t TSE = (1U << 1);  ///< Transmit Process Stopped
        constexpr uint32_t TIE = (1U << 0);  ///< Transmit Interrupt
    }

    /// MFBOCR Register bits
    namespace mfbocr_bits {
        constexpr uint32_t ONMFF = (1U << 28);  ///< Overflow NMFF
        constexpr uint32_t NMFF = (11 << 17);  ///< Number of Missed frame by Ethernet-MAC
        constexpr uint32_t ONMFH = (1U << 16);  ///< Overflow NMFH
        constexpr uint32_t NMFH = (16 << 0);  ///< Number of Missed frame by HOST
    }

    /// RIWTR Register bits
    namespace riwtr_bits {
        constexpr uint32_t RIWT = (8 << 0);  ///< RI Watchdog Timer count
    }

    /// AHBSR Register bits
    namespace ahbsr_bits {
        constexpr uint32_t AHBS = (1U << 0);  ///< AHB Status
    }

    /// CHTDR Register bits
    namespace chtdr_bits {
        constexpr uint32_t HTDAP = (32 << 0);  ///< Host Transmit Descriptor Address Pointer
    }

    /// CHRDR Register bits
    namespace chrdr_bits {
        constexpr uint32_t HRDAP = (32 << 0);  ///< Host Receive Descriptor Address Pointer
    }

    /// CHTBAR Register bits
    namespace chtbar_bits {
        constexpr uint32_t HTBAR = (32 << 0);  ///< Host Transmit Buffer Address Register
    }

    /// CHRBAR Register bits
    namespace chrbar_bits {
        constexpr uint32_t HRBAR = (32 << 0);  ///< Host Receive Buffer Address Register
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2SPRE_BASE = 0x4003D000;
    constexpr uint32_t I2S0_BASE = 0x4006C000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t ICCR;  ///< Offset: 0x00 - I2S Clock Control Register
        volatile uint32_t IPCR1;  ///< Offset: 0x04 - I2S-PLL Control Register 1
        volatile uint32_t IPCR2;  ///< Offset: 0x08 - I2S-PLL Control Register 2
        volatile uint32_t IPCR3;  ///< Offset: 0x0C - I2S-PLL Control Register 3
        volatile uint32_t IPCR4;  ///< Offset: 0x10 - I2S-PLL Control Register 4
        volatile uint32_t IP_STR;  ///< Offset: 0x14 - I2S-PLL Status Register
        volatile uint32_t IPINT_ENR;  ///< Offset: 0x18 - I2S-PLL Interrupt Factor Enable Register
        volatile uint32_t IPINT_CLR;  ///< Offset: 0x1C - I2S-PLL Interrupt Factor Status Register
        volatile uint32_t IPINT_STR;  ///< Offset: 0x20 - I2S-PLL Interrupt Factor Clear Register
        volatile uint32_t IPCR5;  ///< Offset: 0x24 - I2S-PLL Control Register 5
    };

    /// Peripheral instances
    inline Registers* I2SPRE = reinterpret_cast<Registers*>(I2SPRE_BASE);
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// ICCR Register bits
    namespace iccr_bits {
        constexpr uint32_t ICSEL = (1U << 1);  ///< I2S clock selection bit
        constexpr uint32_t ICEN = (1U << 0);  ///< I2S clock output enable bit
    }

    /// IPCR1 Register bits
    namespace ipcr1_bits {
        constexpr uint32_t IPLLEN = (1U << 0);  ///< I2S-PLL oscillation enable bit
    }

    /// IPCR2 Register bits
    namespace ipcr2_bits {
        constexpr uint32_t IPOWT = (3 << 0);  ///< I2S-PLL oscillation stabilization wait time setting bits
    }

    /// IPCR3 Register bits
    namespace ipcr3_bits {
        constexpr uint32_t IPLLK = (5 << 0);  ///< Frequency division ratio (K) setting bits of the I2S-PLL clock
    }

    /// IPCR4 Register bits
    namespace ipcr4_bits {
        constexpr uint32_t IPLLN = (7 << 0);  ///< Frequency division ratio (N) setting bits of the I2S-PLL clock
    }

    /// IP_STR Register bits
    namespace ip_str_bits {
        constexpr uint32_t IPRDY = (1U << 0);  ///< I2S-PLL oscillation stabilization bit
    }

    /// IPINT_ENR Register bits
    namespace ipint_enr_bits {
        constexpr uint32_t IPCSE = (1U << 0);  ///< I2S-PLL oscillation stabilization wait complete interrupt enable bit
    }

    /// IPINT_CLR Register bits
    namespace ipint_clr_bits {
        constexpr uint32_t IPCSC = (1U << 0);  ///< I2S-PLL interrupt factor status bit
    }

    /// IPINT_STR Register bits
    namespace ipint_str_bits {
        constexpr uint32_t IPCSI = (1U << 0);  ///< I2S-PLL oscillation stabilization interrupt factor clear bit
    }

    /// IPCR5 Register bits
    namespace ipcr5_bits {
        constexpr uint32_t IPLLM = (7 << 0);  ///< Frequency division ratio (M) setting bits of the I2S-PLL clock
    }

}

// ============================================================================
// SDIF Peripheral
// ============================================================================

namespace sdif {
    /// Base addresses
    constexpr uint32_t SDIF_BASE = 0x4006E000;

    /// SDIF Register structure
    struct Registers {
        volatile uint32_t DUMMY;  ///< Offset: 0x00 - Dummy
    };

    /// Peripheral instances
    inline Registers* SDIF = reinterpret_cast<Registers*>(SDIF_BASE);

}

// ============================================================================
// PCRC Peripheral
// ============================================================================

namespace pcrc {
    /// Base addresses
    constexpr uint32_t PCRC_BASE = 0x40080000;

    /// PCRC Register structure
    struct Registers {
        volatile uint32_t PRGCRC_POLY;  ///< Offset: 0x00 - CRC Computing Generator Polynomial Register
        volatile uint32_t PRGCRC_SEED;  ///< Offset: 0x04 - CRC Computing Initial Value Register
        volatile uint32_t PRGCRC_FXOR;  ///< Offset: 0x08 - CRC Computing Resault XOR Value Register
        volatile uint32_t PRGCRC_CFG;  ///< Offset: 0x0C - CRC Computing Configuration Register
        volatile uint32_t PRGCRC_WR;  ///< Offset: 0x10 - CRC Computing Input Data Register
        volatile uint32_t PRGCRC_RD;  ///< Offset: 0x14 - CRC Computing Output Data Register
    };

    /// Peripheral instances
    inline Registers* PCRC = reinterpret_cast<Registers*>(PCRC_BASE);

    // Bit definitions
    /// PRGCRC_CFG Register bits
    namespace prgcrc_cfg_bits {
        constexpr uint32_t LOCK = (1U << 28);  ///< Lock
        constexpr uint32_t CDEN = (1U << 26);  ///< DMA request enable
        constexpr uint32_t CIEN = (1U << 25);  ///< Interrupt request enable
        constexpr uint32_t CIRQ = (1U << 24);  ///< Interrupt request
        constexpr uint32_t SZ = (2 << 22);  ///< Input data size
        constexpr uint32_t TEST = (6 << 16);  ///< Test
        constexpr uint32_t FI = (2 << 10);  ///< Input data format
        constexpr uint32_t FO = (2 << 8);  ///< output data format
        constexpr uint32_t CIRQCLR = (1U << 0);  ///< Interrupt request clear
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t HSSPI_BASE = 0xD0000000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t PCC0;  ///< Offset: 0x04 - Peripheral Communication Setting Register 0
        volatile uint32_t PCC1;  ///< Offset: 0x08 - Peripheral Communication Setting Registers 1
        volatile uint32_t PCC2;  ///< Offset: 0x0C - Peripheral Communication Setting Registers 2
        volatile uint32_t PCC3;  ///< Offset: 0x10 - Peripheral Communication Setting Registers 3
        volatile uint32_t TXF;  ///< Offset: 0x14 - Transmission Interrupt Factor Register
        volatile uint32_t TXE;  ///< Offset: 0x18 - Transmission Interrupt Enable Register
        volatile uint32_t TXC;  ///< Offset: 0x1C - Transmission Interrupt Clear Register
        volatile uint32_t RXF;  ///< Offset: 0x20 - Reception Interrupt Factor Register
        volatile uint32_t RXE;  ///< Offset: 0x24 - Reception Interrupt Enable Register
        volatile uint32_t RXC;  ///< Offset: 0x28 - Interrupt Clear Register
        volatile uint32_t FAULTF;  ///< Offset: 0x2C - Fault Interrupt Factor Register
        volatile uint32_t FAULTC;  ///< Offset: 0x30 - Fault Interrupt Clear Register
        volatile uint32_t DMCFG;  ///< Offset: 0x34 - Direct Mode Setting Register
        volatile uint32_t DMDMAEN;  ///< Offset: 0x35 - DMDMAEN
        volatile uint32_t DMSTART;  ///< Offset: 0x38 - Direct Mode Transfer Start Control Register
        volatile uint32_t DMSTOP;  ///< Offset: 0x39 - Direct Mode Transfer Stop Control Register
        volatile uint32_t DMPSEL;  ///< Offset: 0x3A - Direct Mode Slave Select Register
        volatile uint32_t DMTRP;  ///< Offset: 0x3B - Direct Mode Transfer Protocol Setting Register
        volatile uint32_t DMBCC;  ///< Offset: 0x3C - Direct Mode Transfer Byte Count Setting Register
        volatile uint32_t DMBCS;  ///< Offset: 0x3E - Direct Mode Transfer Remaining Count Register
        volatile uint32_t DMSTATUS;  ///< Offset: 0x40 - Direct Mode Status Register
        volatile uint32_t FIFOCFG;  ///< Offset: 0x4C - FIFO Setting Register
        volatile uint32_t TXFIFO0;  ///< Offset: 0x50 - TX-FIFO0 Register
        volatile uint32_t TXFIFO1;  ///< Offset: 0x54 - TX-FIFO1 Register
        volatile uint32_t TXFIFO2;  ///< Offset: 0x58 - TX-FIFO2 Register
        volatile uint32_t TXFIFO3;  ///< Offset: 0x5C - TX-FIFO3 Register
        volatile uint32_t TXFIFO4;  ///< Offset: 0x60 - TX-FIFO4 Register
        volatile uint32_t TXFIFO5;  ///< Offset: 0x64 - TX-FIFO5 Register
        volatile uint32_t TXFIFO6;  ///< Offset: 0x68 - TX-FIFO6 Register
        volatile uint32_t TXFIFO7;  ///< Offset: 0x6C - TX-FIFO7 Register
        volatile uint32_t TXFIFO8;  ///< Offset: 0x70 - TX-FIFO8 Register
        volatile uint32_t TXFIFO9;  ///< Offset: 0x74 - TX-FIFO9 Register
        volatile uint32_t TXFIFO10;  ///< Offset: 0x78 - TX-FIFO10 Register
        volatile uint32_t TXFIFO11;  ///< Offset: 0x7C - TX-FIFO11 Register
        volatile uint32_t TXFIFO12;  ///< Offset: 0x80 - TX-FIFO12 Register
        volatile uint32_t TXFIFO13;  ///< Offset: 0x84 - TX-FIFO13 Register
        volatile uint32_t TXFIFO14;  ///< Offset: 0x88 - TX-FIFO14 Register
        volatile uint32_t TXFIFO15;  ///< Offset: 0x8C - TX-FIFO15 Register
        volatile uint32_t RXFIFO0;  ///< Offset: 0x90 - RX-FIFO0 Register
        volatile uint32_t RXFIFO1;  ///< Offset: 0x94 - RX-FIFO1 read data
        volatile uint32_t RXFIFO2;  ///< Offset: 0x98 - RX-FIFO2 read data
        volatile uint32_t RXFIFO3;  ///< Offset: 0x9C - RX-FIFO3 read data
        volatile uint32_t RXFIFO4;  ///< Offset: 0xA0 - RX-FIFO4 read data
        volatile uint32_t RXFIFO5;  ///< Offset: 0xA4 - RX-FIFO5 read data
        volatile uint32_t RXFIFO6;  ///< Offset: 0xA8 - RX-FIFO6 read data
        volatile uint32_t RXFIFO7;  ///< Offset: 0xAC - RX-FIFO7 read data
        volatile uint32_t RXFIFO8;  ///< Offset: 0xB0 - RX-FIFO8 read data
        volatile uint32_t RXFIFO9;  ///< Offset: 0xB4 - RX-FIFO9 read data
        volatile uint32_t RXFIFO10;  ///< Offset: 0xB8 - RX-FIFO10 read data
        volatile uint32_t RXFIFO11;  ///< Offset: 0xBC - RX-FIFO11 read data
        volatile uint32_t RXFIFO12;  ///< Offset: 0xC0 - RX-FIFO12 read data
        volatile uint32_t RXFIFO13;  ///< Offset: 0xC4 - RX-FIFO13 read data
        volatile uint32_t RXFIFO14;  ///< Offset: 0xC8 - RX-FIFO14 read data
        volatile uint32_t RXFIFO15;  ///< Offset: 0xCC - RX-FIFO15 read data
        volatile uint32_t CSCFG;  ///< Offset: 0xD0 - 32
        volatile uint32_t CSITIME;  ///< Offset: 0xD4 - Command Sequencer Idle Timer Setting Register
        volatile uint32_t CSAEXT;  ///< Offset: 0xD8 - Command Sequencer Address Extension Register
        volatile uint32_t RDCSDC0;  ///< Offset: 0xDC - Read Command Sequence Data/Control Register 0
        volatile uint32_t RDCSDC1;  ///< Offset: 0xDE - Read Command Sequence Data/Control Register 1
        volatile uint32_t RDCSDC2;  ///< Offset: 0xE0 - Read Command Sequence Data/Control Register 2
        volatile uint32_t RDCSDC3;  ///< Offset: 0xE2 - Read Command Sequence Data/Control Register 3
        volatile uint32_t RDCSDC4;  ///< Offset: 0xE4 - Read Command Sequence Data/Control Register 4
        volatile uint32_t RDCSDC5;  ///< Offset: 0xE6 - Read Command Sequence Data/Control Register 5
        volatile uint32_t RDCSDC6;  ///< Offset: 0xE8 - Read Command Sequence Data/Control Register 6
        volatile uint32_t RDCSDC7;  ///< Offset: 0xEA - Read Command Sequence Data/Control Register 7
        volatile uint32_t WRCSDC0;  ///< Offset: 0xEC - Write Command Sequence Data/Control Register 0
        volatile uint32_t WRCSDC1;  ///< Offset: 0xEE - Write Command Sequence Data/Control Register 1
        volatile uint32_t WRCSDC2;  ///< Offset: 0xF0 - Write Command Sequence Data/Control Register 2
        volatile uint32_t WRCSDC3;  ///< Offset: 0xF2 - Write Command Sequence Data/Control Register 3
        volatile uint32_t WRCSDC4;  ///< Offset: 0xF4 - Write Command Sequence Data/Control Register 4
        volatile uint32_t WRCSDC5;  ///< Offset: 0xF6 - Write Command Sequence Data/Control Register 5
        volatile uint32_t WRCSDC6;  ///< Offset: 0xF8 - Write Command Sequence Data/Control Register 6
        volatile uint32_t WRCSDC7;  ///< Offset: 0xFA - Write Command Sequence Data/Control Register 7
        volatile uint32_t MID;  ///< Offset: 0xFC - Module Identification Register
        volatile uint32_t QDCLKR;  ///< Offset: 0x400 - QDCLKR
        volatile uint32_t DBCNT;  ///< Offset: 0x404 - DBCNT
    };

    /// Peripheral instances
    inline Registers* HSSPI = reinterpret_cast<Registers*>(HSSPI_BASE);

    // Bit definitions
    /// MCTRL Register bits
    namespace mctrl_bits {
        constexpr uint32_t SYNCON = (1U << 5);  ///< Synchronizer circuit operation bit
        constexpr uint32_t MES = (1U << 4);  ///< Module enable status bit
        constexpr uint32_t CSEN = (1U << 1);  ///< Command sequencer mode enable bit
        constexpr uint32_t MEN = (1U << 0);  ///< Module enable bit
    }

    /// PCC0 Register bits
    namespace pcc0_bits {
        constexpr uint32_t RDDSEL = (2 << 21);  ///< Read deselect time setting bits
        constexpr uint32_t WRDSEL = (4 << 17);  ///< Write or different command deselect time setting bits
        constexpr uint32_t SAFESYNC = (1U << 16);  ///< Safe synchronization bit
        constexpr uint32_t CDRS = (7 << 9);  ///< Clock division ratio setting bits
        constexpr uint32_t SENDIAN = (1U << 8);  ///< Endian setting bit
        constexpr uint32_t SDIR = (1U << 7);  ///< Shift direction setting bit
        constexpr uint32_t SS2CD = (2 << 5);  ///< Slave-select-to-clock-start delay time setting bit
        constexpr uint32_t SSPOL = (1U << 4);  ///< Slave select polarity setting bit
        constexpr uint32_t RTM = (1U << 3);  ///< Timing compensation setting bit
        constexpr uint32_t ACES = (1U << 2);  ///< Serial data transmission/reception timing setting bit
        constexpr uint32_t CPOL = (1U << 1);  ///< Serial clock polarity setting bit
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase setting bit
    }

    /// TXF Register bits
    namespace txf_bits {
        constexpr uint32_t TSSRS = (1U << 6);  ///< Slave select released detection bit
        constexpr uint32_t TFMTS = (1U << 5);  ///< TX-FIFO-exceeded-threshold detection bit
        constexpr uint32_t TFLETS = (1U << 4);  ///< TX-FIFO-less-than-or-equal-to-threshold detection bit
        constexpr uint32_t TFUS = (1U << 3);  ///< TX-FIFO underrun detection bit
        constexpr uint32_t TFOS = (1U << 2);  ///< TX-FIFO overrun detection bit
        constexpr uint32_t TFES = (1U << 1);  ///< TX-FIFO and shift register empty detection bit
        constexpr uint32_t TFFS = (1U << 0);  ///< TX-FIFO full detection bit
    }

    /// TXE Register bits
    namespace txe_bits {
        constexpr uint32_t TSSRE = (1U << 6);  ///< Slave select released detection interrupt enable bit
        constexpr uint32_t TFMTE = (1U << 5);  ///< TX-FIFO-exceeded-threshold detection interrupt enable bit
        constexpr uint32_t TFLETE = (1U << 4);  ///< TX-FIFO-less-than-or-equal-to-threshold detection interrupt enable bit
        constexpr uint32_t TFUE = (1U << 3);  ///< TX-FIFO underrun detection interrupt enable bit
        constexpr uint32_t TFOE = (1U << 2);  ///< TX-FIFO overrun detection interrupt enable bit
        constexpr uint32_t TFEE = (1U << 1);  ///< TX-FIFO and shift register empty detection interrupt enable bit
        constexpr uint32_t TFFE = (1U << 0);  ///< TX-FIFO full detection interrupt enable bit
    }

    /// TXC Register bits
    namespace txc_bits {
        constexpr uint32_t TSSRC = (1U << 6);  ///< Slave select released detection clear bit
        constexpr uint32_t TFMTC = (1U << 5);  ///< TX-FIFO-exceeded-threshold detection clear bit
        constexpr uint32_t TFLETC = (1U << 4);  ///< TX-FIFO-less-than-or-equal-to-threshold detection clear bit
        constexpr uint32_t TFUC = (1U << 3);  ///< TX-FIFO underrun detection clear bit
        constexpr uint32_t TFOC = (1U << 2);  ///< TX-FIFO overrun detection clear bit
        constexpr uint32_t TFEC = (1U << 1);  ///< TX-FIFO and shift register empty detection clear bit
        constexpr uint32_t TFFC = (1U << 0);  ///< TX-FIFO full detection clear bit
    }

    /// RXF Register bits
    namespace rxf_bits {
        constexpr uint32_t RSSRS = (1U << 6);  ///< Slave select released detection bit
        constexpr uint32_t RFMTS = (1U << 5);  ///< RX-FIFO-exceeded-threshold detection bit
        constexpr uint32_t RFLETS = (1U << 4);  ///< RX-FIFO-less-than-or-equal-to-threshold detection bit
        constexpr uint32_t RFUS = (1U << 3);  ///< RX-FIFO underrun detection bit
        constexpr uint32_t RFOS = (1U << 2);  ///< RX-FIFO overrun detection bit
        constexpr uint32_t RFES = (1U << 1);  ///< RX-FIFO empty detection bit
        constexpr uint32_t RFFS = (1U << 0);  ///< RX-FIFO full detection bit
    }

    /// RXE Register bits
    namespace rxe_bits {
        constexpr uint32_t RSSRE = (1U << 6);  ///< Slave select released detection interrupt enable bit
        constexpr uint32_t RFMTE = (1U << 5);  ///< RX-FIFO-exceeded-threshold detection interrupt enable bit
        constexpr uint32_t RFLETE = (1U << 4);  ///< RX-FIFO-less-than-or-equal-to-threshold detection interrupt enable bit
        constexpr uint32_t RFUE = (1U << 3);  ///< RX-FIFO underrun detection interrupt enable bit
        constexpr uint32_t RFOE = (1U << 2);  ///< RX-FIFO overrun detection interrupt enable bit
        constexpr uint32_t RFEE = (1U << 1);  ///< RX-FIFO and shift register empty-state detection interrupt enable bit
        constexpr uint32_t RFFE = (1U << 0);  ///< RX-FIFO full detection interrupt enable bit
    }

    /// RXC Register bits
    namespace rxc_bits {
        constexpr uint32_t RSSRC = (1U << 6);  ///< Slave select released detection clear bit
        constexpr uint32_t RFMTC = (1U << 5);  ///< RX-FIFO-exceeded-threshold detection clear bit
        constexpr uint32_t RFLETC = (1U << 4);  ///< RX-FIFO-less-than-or-equal-to-threshold detection clear bit
        constexpr uint32_t RFUC = (1U << 3);  ///< RX-FIFO underrun detection clear bit
        constexpr uint32_t RFOC = (1U << 2);  ///< RX-FIFO overrun detection clear bit
        constexpr uint32_t RFEC = (1U << 1);  ///< RX-FIFO and shift register empty-state detection clear bit
        constexpr uint32_t RFFC = (1U << 0);  ///< RX-FIFO full detection clear bit
    }

    /// FAULTF Register bits
    namespace faultf_bits {
        constexpr uint32_t DRCBSFS = (1U << 4);  ///< DRCBSFS
        constexpr uint32_t DWCBSFS = (1U << 3);  ///< DWCBSFS
        constexpr uint32_t PVFS = (1U << 2);  ///< Protection violation fault detection bit
        constexpr uint32_t WAFS = (1U << 1);  ///< Write access fault detection bit
        constexpr uint32_t UMAFS = (1U << 0);  ///< Unmapped memory access fault detection bit
    }

    /// FAULTC Register bits
    namespace faultc_bits {
        constexpr uint32_t DRCBSFC = (1U << 4);  ///< DRCBSFC
        constexpr uint32_t DWCBSFC = (1U << 3);  ///< DWCBSFC
        constexpr uint32_t PVFC = (1U << 2);  ///< Protection violation fault detection clear bit
        constexpr uint32_t WAFC = (1U << 1);  ///< Write access fault detection clear bit
        constexpr uint32_t UMAFC = (1U << 0);  ///< Unmapped memory access fault detection clear bit
    }

    /// DMCFG Register bits
    namespace dmcfg_bits {
        constexpr uint32_t SSDC = (1U << 1);  ///< Slave select deassertion setting bit
    }

    /// DMDMAEN Register bits
    namespace dmdmaen_bits {
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< TXDMAEN
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< RXDMAEN
    }

    /// DMSTART Register bits
    namespace dmstart_bits {
        constexpr uint32_t START = (1U << 0);  ///< Transfer start bit
    }

    /// DMSTOP Register bits
    namespace dmstop_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Transfer stop bit
    }

    /// DMPSEL Register bits
    namespace dmpsel_bits {
        constexpr uint32_t PSEL = (2 << 0);  ///< Peripheral select bits
    }

    /// DMTRP Register bits
    namespace dmtrp_bits {
        constexpr uint32_t TRP = (4 << 0);  ///< Transfer protocol setting bits
    }

    /// DMBCC Register bits
    namespace dmbcc_bits {
        constexpr uint32_t BCC = (16 << 0);  ///< Transferred byte count setting value
    }

    /// DMBCS Register bits
    namespace dmbcs_bits {
        constexpr uint32_t BCS = (16 << 0);  ///< Number of remaining bytes to transfer
    }

    /// DMSTATUS Register bits
    namespace dmstatus_bits {
        constexpr uint32_t TXFLEVEL = (5 << 16);  ///< Remaining TX-FIFO data indication bits
        constexpr uint32_t RXFLEVEL = (5 << 8);  ///< Remaining RX-FIFO data indication bits
        constexpr uint32_t TXACTIVE = (1U << 1);  ///< Transmission status bit
        constexpr uint32_t RXACTIVE = (1U << 0);  ///< Reception status bit
    }

    /// FIFOCFG Register bits
    namespace fifocfg_bits {
        constexpr uint32_t TXFLSH = (1U << 12);  ///< TX-FIFO clear bit
        constexpr uint32_t RXFLSH = (1U << 11);  ///< RX-FIFO clear bit
        constexpr uint32_t TXCTRL = (1U << 10);  ///< TX-FIFO transmission data control bit
        constexpr uint32_t FWIDTH = (2 << 8);  ///< FIFO bit width setting value
        constexpr uint32_t TXFTH = (4 << 4);  ///< TX-FIFO threshold
        constexpr uint32_t RXFTH = (4 << 0);  ///< RX-FIFO threshold
    }

    /// TXFIFO0 Register bits
    namespace txfifo0_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< TX-FIFO0 write data
    }

    /// RXFIFO0 Register bits
    namespace rxfifo0_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< RX-FIFO0 read data
    }

    /// CSCFG Register bits
    namespace cscfg_bits {
        constexpr uint32_t MSEL = (4 << 16);  ///< Memory device selection bits
        constexpr uint32_t SSEL3EN = (1U << 11);  ///< Slave select 3 enable bit
        constexpr uint32_t SSEL2EN = (1U << 10);  ///< Slave select 2 enable bit
        constexpr uint32_t SSEL1EN = (1U << 9);  ///< Slave select 1 enable bit
        constexpr uint32_t SSEL0EN = (1U << 8);  ///< Slave select 0 enable bit
        constexpr uint32_t MBM = (2 << 1);  ///< SPI data width setting bits
        constexpr uint32_t SRAM = (1U << 0);  ///< Readable/Writable or Read only selection bit
    }

    /// CSITIME Register bits
    namespace csitime_bits {
        constexpr uint32_t ITIME = (16 << 0);  ///< Idle timer setting value
    }

    /// CSAEXT Register bits
    namespace csaext_bits {
        constexpr uint32_t AEXT = (19 << 13);  ///< Address extension bits
    }

    /// RDCSDC0 Register bits
    namespace rdcsdc0_bits {
        constexpr uint32_t RDCSDATA = (8 << 8);  ///< Read command sequencer data/control setting values
        constexpr uint32_t CONT = (1U << 3);  ///< Continuous instruction setting bit
        constexpr uint32_t TRP = (2 << 1);  ///< Serial interface width control bits
        constexpr uint32_t DEC = (1U << 0);  ///< Decode control bit
    }

    /// WRCSDC0 Register bits
    namespace wrcsdc0_bits {
        constexpr uint32_t WRCSDATA = (8 << 8);  ///< Write command sequencer data/control setting values
        constexpr uint32_t CONT = (1U << 3);  ///< Continuous instruction setting bit
        constexpr uint32_t TRP = (2 << 1);  ///< Serial interface width control bits
        constexpr uint32_t DEC = (1U << 0);  ///< Decode control bit
    }

    /// MID Register bits
    namespace mid_bits {
        constexpr uint32_t MID = (32 << 0);  ///< Module identification information bits
    }

    /// QDCLKR Register bits
    namespace qdclkr_bits {
        constexpr uint32_t QHDIV = (4 << 0);  ///< QHDIV
    }

    /// DBCNT Register bits
    namespace dbcnt_bits {
        constexpr uint32_t TXDBEN = (1U << 1);  ///< TXDBEN
        constexpr uint32_t RXDBEN = (1U << 0);  ///< RXDBEN
    }

}


} // namespace alloy::generated::s6e2cc

#endif // ALLOY_GENERATED_S6E2CC_PERIPHERALS_HPP