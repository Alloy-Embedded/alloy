/// Auto-generated code for STM32F031x
/// Generated by Alloy Code Generator
/// Source: st_stm32f031.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:41
#ifndef ALLOY_GENERATED_STM32F031X_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32F031X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32f031x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x0C - Initial CRC value
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (8 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< reset bit
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t INIT = (32 << 0);  ///< Programmable initial CRC value
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOF_BASE = 0x48001400;
    constexpr uint32_t GPIOC_BASE = 0x48000800;
    constexpr uint32_t GPIOB_BASE = 0x48000400;
    constexpr uint32_t GPIOA_BASE = 0x48000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - Port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bit 15
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bit 14
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bit 13
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bit 12
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bit 11
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bit 10
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bit 9
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bit 8
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bit 7
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bit 6
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bit 5
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bit 4
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bit 3
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bit 2
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bit 1
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bit 0
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFRL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFRH15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x Reset bit y
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x Reset bit y
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x Reset bit y
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x Reset bit y
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x Reset bit y
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x Reset bit y
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x Reset bit y
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x Reset bit y
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x Reset bit y
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x Reset bit y
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x Reset bit y
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x Reset bit y
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x Reset bit y
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x Reset bit y
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x Reset bit y
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x Reset bit y
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - I2S configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - I2S prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
        constexpr uint32_t I2SE = (1U << 10);  ///< I2S Enable
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2S standard selection
        constexpr uint32_t CKPOL = (1U << 3);  ///< Steady state clock polarity
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2S Linear prescaler
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - power control register
        volatile uint32_t CSR;  ///< Offset: 0x04 - power control/status register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t FPDS = (1U << 9);  ///< Flash power down in Stop mode
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t PLS = (3 << 5);  ///< PVD level selection
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t CSBF = (1U << 3);  ///< Clear standby flag
        constexpr uint32_t CWUF = (1U << 2);  ///< Clear wakeup flag
        constexpr uint32_t PDDS = (1U << 1);  ///< Power down deepsleep
        constexpr uint32_t LPDS = (1U << 0);  ///< Low-power deep sleep
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t BRE = (1U << 9);  ///< Backup regulator enable
        constexpr uint32_t EWUP = (1U << 8);  ///< Enable WKUP pin
        constexpr uint32_t BRR = (1U << 3);  ///< Backup regulator ready
        constexpr uint32_t PVDO = (1U << 2);  ///< PVD output
        constexpr uint32_t SBF = (1U << 1);  ///< Standby flag
        constexpr uint32_t WUF = (1U << 0);  ///< Wakeup flag
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t SWRST = (1U << 13);  ///< Software reset
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD8 = (2 << 8);  ///< Slave address bit 9:8 (master mode)
        constexpr uint32_t SADD1 = (7 << 1);  ///< Slave address bit 7:1 (master mode)
        constexpr uint32_t SADD0 = (1U << 0);  ///< Slave address bit 0 (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1_0 = (1U << 0);  ///< Interface address
        constexpr uint32_t OA1_1 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA1_8 = (2 << 8);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SMCR;  ///< Offset: 0x08 - slave mode control register
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCMR2_Output;  ///< Offset: 0x1C - capture/compare mode register (output mode)
        volatile uint32_t CCMR2_Input;  ///< Offset: 0x1C - capture/compare mode register 2 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t CCR2;  ///< Offset: 0x38 - capture/compare register 2
        volatile uint32_t CCR3;  ///< Offset: 0x3C - capture/compare register 3
        volatile uint32_t CCR4;  ///< Offset: 0x40 - capture/compare register 4
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
    };

    /// Peripheral instances
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CMS = (2 << 5);  ///< Center-aligned mode selection
        constexpr uint32_t DIR = (1U << 4);  ///< Direction
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS4 = (1U << 14);  ///< Output Idle state 4
        constexpr uint32_t OIS3N = (1U << 13);  ///< Output Idle state 3
        constexpr uint32_t OIS3 = (1U << 12);  ///< Output Idle state 3
        constexpr uint32_t OIS2N = (1U << 11);  ///< Output Idle state 2
        constexpr uint32_t OIS2 = (1U << 10);  ///< Output Idle state 2
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1 selection
        constexpr uint32_t MMS = (3 << 4);  ///< Master mode selection
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// SMCR Register bits
    namespace smcr_bits {
        constexpr uint32_t ETP = (1U << 15);  ///< External trigger polarity
        constexpr uint32_t ECE = (1U << 14);  ///< External clock enable
        constexpr uint32_t ETPS = (2 << 12);  ///< External trigger prescaler
        constexpr uint32_t ETF = (4 << 8);  ///< External trigger filter
        constexpr uint32_t MSM = (1U << 7);  ///< Master/Slave mode
        constexpr uint32_t TS = (3 << 4);  ///< Trigger selection
        constexpr uint32_t SMS = (3 << 0);  ///< Slave mode selection
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t TDE = (1U << 14);  ///< Trigger DMA request enable
        constexpr uint32_t COMDE = (1U << 13);  ///< Reserved
        constexpr uint32_t CC4DE = (1U << 12);  ///< Capture/Compare 4 DMA request enable
        constexpr uint32_t CC3DE = (1U << 11);  ///< Capture/Compare 3 DMA request enable
        constexpr uint32_t CC2DE = (1U << 10);  ///< Capture/Compare 2 DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t TIE = (1U << 6);  ///< Trigger interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t CC4IE = (1U << 4);  ///< Capture/Compare 4 interrupt enable
        constexpr uint32_t CC3IE = (1U << 3);  ///< Capture/Compare 3 interrupt enable
        constexpr uint32_t CC2IE = (1U << 2);  ///< Capture/Compare 2 interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC4OF = (1U << 12);  ///< Capture/Compare 4 overcapture flag
        constexpr uint32_t CC3OF = (1U << 11);  ///< Capture/Compare 3 overcapture flag
        constexpr uint32_t CC2OF = (1U << 10);  ///< Capture/compare 2 overcapture flag
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t TIF = (1U << 6);  ///< Trigger interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC4IF = (1U << 4);  ///< Capture/Compare 4 interrupt flag
        constexpr uint32_t CC3IF = (1U << 3);  ///< Capture/Compare 3 interrupt flag
        constexpr uint32_t CC2IF = (1U << 2);  ///< Capture/Compare 2 interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t TG = (1U << 6);  ///< Trigger generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC4G = (1U << 4);  ///< Capture/compare 4 generation
        constexpr uint32_t CC3G = (1U << 3);  ///< Capture/compare 3 generation
        constexpr uint32_t CC2G = (1U << 2);  ///< Capture/compare 2 generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC2CE = (1U << 15);  ///< Output Compare 2 clear enable
        constexpr uint32_t OC2M = (3 << 12);  ///< Output Compare 2 mode
        constexpr uint32_t OC2PE = (1U << 11);  ///< Output Compare 2 preload enable
        constexpr uint32_t OC2FE = (1U << 10);  ///< Output Compare 2 fast enable
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection
        constexpr uint32_t OC1CE = (1U << 7);  ///< Output Compare 1 clear enable
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC2F = (4 << 12);  ///< Input capture 2 filter
        constexpr uint32_t IC2PCS = (2 << 10);  ///< Input capture 2 prescaler
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t IC1PCS = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR2_Output Register bits
    namespace ccmr2_output_bits {
        constexpr uint32_t OC4CE = (1U << 15);  ///< Output compare 4 clear enable
        constexpr uint32_t OC4M = (3 << 12);  ///< Output compare 4 mode
        constexpr uint32_t OC4PE = (1U << 11);  ///< Output compare 4 preload enable
        constexpr uint32_t OC4FE = (1U << 10);  ///< Output compare 4 fast enable
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection
        constexpr uint32_t OC3CE = (1U << 7);  ///< Output compare 3 clear enable
        constexpr uint32_t OC3M = (3 << 4);  ///< Output compare 3 mode
        constexpr uint32_t OC3PE = (1U << 3);  ///< Output compare 3 preload enable
        constexpr uint32_t OC3FE = (1U << 2);  ///< Output compare 3 fast enable
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/Compare 3 selection
    }

    /// CCMR2_Input Register bits
    namespace ccmr2_input_bits {
        constexpr uint32_t IC4F = (4 << 12);  ///< Input capture 4 filter
        constexpr uint32_t IC4PSC = (2 << 10);  ///< Input capture 4 prescaler
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection
        constexpr uint32_t IC3F = (4 << 4);  ///< Input capture 3 filter
        constexpr uint32_t IC3PSC = (2 << 2);  ///< Input capture 3 prescaler
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/compare 3 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC4P = (1U << 13);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC4E = (1U << 12);  ///< Capture/Compare 4 output enable
        constexpr uint32_t CC3NP = (1U << 11);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC3NE = (1U << 10);  ///< Capture/Compare 3 complementary output enable
        constexpr uint32_t CC3P = (1U << 9);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC3E = (1U << 8);  ///< Capture/Compare 3 output enable
        constexpr uint32_t CC2NP = (1U << 7);  ///< Capture/Compare 2 output Polarity
        constexpr uint32_t CC2NE = (1U << 6);  ///< Capture/Compare 2 complementary output enable
        constexpr uint32_t CC2P = (1U << 5);  ///< Capture/Compare 2 output Polarity
        constexpr uint32_t CC2E = (1U << 4);  ///< Capture/Compare 2 output enable
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/Compare 2 value
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t CCR3 = (16 << 0);  ///< Capture/Compare 3 value
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t CCR4 = (16 << 0);  ///< Capture/Compare 3 value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (16 << 0);  ///< DMA register for burst accesses
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40010400;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t IMR;  ///< Offset: 0x00 - Interrupt mask register (EXTI_IMR)
        volatile uint32_t EMR;  ///< Offset: 0x04 - Event mask register (EXTI_EMR)
        volatile uint32_t RTSR;  ///< Offset: 0x08 - Rising Trigger selection register (EXTI_RTSR)
        volatile uint32_t FTSR;  ///< Offset: 0x0C - Falling Trigger selection register (EXTI_FTSR)
        volatile uint32_t SWIER;  ///< Offset: 0x10 - Software interrupt event register (EXTI_SWIER)
        volatile uint32_t PR;  ///< Offset: 0x14 - Pending register (EXTI_PR)
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Interrupt Mask on line 0
        constexpr uint32_t MR1 = (1U << 1);  ///< Interrupt Mask on line 1
        constexpr uint32_t MR2 = (1U << 2);  ///< Interrupt Mask on line 2
        constexpr uint32_t MR3 = (1U << 3);  ///< Interrupt Mask on line 3
        constexpr uint32_t MR4 = (1U << 4);  ///< Interrupt Mask on line 4
        constexpr uint32_t MR5 = (1U << 5);  ///< Interrupt Mask on line 5
        constexpr uint32_t MR6 = (1U << 6);  ///< Interrupt Mask on line 6
        constexpr uint32_t MR7 = (1U << 7);  ///< Interrupt Mask on line 7
        constexpr uint32_t MR8 = (1U << 8);  ///< Interrupt Mask on line 8
        constexpr uint32_t MR9 = (1U << 9);  ///< Interrupt Mask on line 9
        constexpr uint32_t MR10 = (1U << 10);  ///< Interrupt Mask on line 10
        constexpr uint32_t MR11 = (1U << 11);  ///< Interrupt Mask on line 11
        constexpr uint32_t MR12 = (1U << 12);  ///< Interrupt Mask on line 12
        constexpr uint32_t MR13 = (1U << 13);  ///< Interrupt Mask on line 13
        constexpr uint32_t MR14 = (1U << 14);  ///< Interrupt Mask on line 14
        constexpr uint32_t MR15 = (1U << 15);  ///< Interrupt Mask on line 15
        constexpr uint32_t MR16 = (1U << 16);  ///< Interrupt Mask on line 16
        constexpr uint32_t MR17 = (1U << 17);  ///< Interrupt Mask on line 17
        constexpr uint32_t MR18 = (1U << 18);  ///< Interrupt Mask on line 18
        constexpr uint32_t MR19 = (1U << 19);  ///< Interrupt Mask on line 19
        constexpr uint32_t MR20 = (1U << 20);  ///< Interrupt Mask on line 20
        constexpr uint32_t MR21 = (1U << 21);  ///< Interrupt Mask on line 21
        constexpr uint32_t MR22 = (1U << 22);  ///< Interrupt Mask on line 22
        constexpr uint32_t MR23 = (1U << 23);  ///< Interrupt Mask on line 23
        constexpr uint32_t MR24 = (1U << 24);  ///< Interrupt Mask on line 24
        constexpr uint32_t MR25 = (1U << 25);  ///< Interrupt Mask on line 25
        constexpr uint32_t MR26 = (1U << 26);  ///< Interrupt Mask on line 26
        constexpr uint32_t MR27 = (1U << 27);  ///< Interrupt Mask on line 27
    }

    /// EMR Register bits
    namespace emr_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Event Mask on line 0
        constexpr uint32_t MR1 = (1U << 1);  ///< Event Mask on line 1
        constexpr uint32_t MR2 = (1U << 2);  ///< Event Mask on line 2
        constexpr uint32_t MR3 = (1U << 3);  ///< Event Mask on line 3
        constexpr uint32_t MR4 = (1U << 4);  ///< Event Mask on line 4
        constexpr uint32_t MR5 = (1U << 5);  ///< Event Mask on line 5
        constexpr uint32_t MR6 = (1U << 6);  ///< Event Mask on line 6
        constexpr uint32_t MR7 = (1U << 7);  ///< Event Mask on line 7
        constexpr uint32_t MR8 = (1U << 8);  ///< Event Mask on line 8
        constexpr uint32_t MR9 = (1U << 9);  ///< Event Mask on line 9
        constexpr uint32_t MR10 = (1U << 10);  ///< Event Mask on line 10
        constexpr uint32_t MR11 = (1U << 11);  ///< Event Mask on line 11
        constexpr uint32_t MR12 = (1U << 12);  ///< Event Mask on line 12
        constexpr uint32_t MR13 = (1U << 13);  ///< Event Mask on line 13
        constexpr uint32_t MR14 = (1U << 14);  ///< Event Mask on line 14
        constexpr uint32_t MR15 = (1U << 15);  ///< Event Mask on line 15
        constexpr uint32_t MR16 = (1U << 16);  ///< Event Mask on line 16
        constexpr uint32_t MR17 = (1U << 17);  ///< Event Mask on line 17
        constexpr uint32_t MR18 = (1U << 18);  ///< Event Mask on line 18
        constexpr uint32_t MR19 = (1U << 19);  ///< Event Mask on line 19
        constexpr uint32_t MR20 = (1U << 20);  ///< Event Mask on line 20
        constexpr uint32_t MR21 = (1U << 21);  ///< Event Mask on line 21
        constexpr uint32_t MR22 = (1U << 22);  ///< Event Mask on line 22
        constexpr uint32_t MR23 = (1U << 23);  ///< Event Mask on line 23
        constexpr uint32_t MR24 = (1U << 24);  ///< Event Mask on line 24
        constexpr uint32_t MR25 = (1U << 25);  ///< Event Mask on line 25
        constexpr uint32_t MR26 = (1U << 26);  ///< Event Mask on line 26
        constexpr uint32_t MR27 = (1U << 27);  ///< Event Mask on line 27
    }

    /// RTSR Register bits
    namespace rtsr_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration of line 0
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration of line 1
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration of line 2
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration of line 3
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration of line 4
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration of line 5
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration of line 6
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration of line 7
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration of line 8
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration of line 9
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration of line 10
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration of line 11
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration of line 12
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration of line 13
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration of line 14
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration of line 15
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration of line 16
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration of line 17
        constexpr uint32_t TR19 = (1U << 19);  ///< Rising trigger event configuration of line 19
    }

    /// FTSR Register bits
    namespace ftsr_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Falling trigger event configuration of line 0
        constexpr uint32_t TR1 = (1U << 1);  ///< Falling trigger event configuration of line 1
        constexpr uint32_t TR2 = (1U << 2);  ///< Falling trigger event configuration of line 2
        constexpr uint32_t TR3 = (1U << 3);  ///< Falling trigger event configuration of line 3
        constexpr uint32_t TR4 = (1U << 4);  ///< Falling trigger event configuration of line 4
        constexpr uint32_t TR5 = (1U << 5);  ///< Falling trigger event configuration of line 5
        constexpr uint32_t TR6 = (1U << 6);  ///< Falling trigger event configuration of line 6
        constexpr uint32_t TR7 = (1U << 7);  ///< Falling trigger event configuration of line 7
        constexpr uint32_t TR8 = (1U << 8);  ///< Falling trigger event configuration of line 8
        constexpr uint32_t TR9 = (1U << 9);  ///< Falling trigger event configuration of line 9
        constexpr uint32_t TR10 = (1U << 10);  ///< Falling trigger event configuration of line 10
        constexpr uint32_t TR11 = (1U << 11);  ///< Falling trigger event configuration of line 11
        constexpr uint32_t TR12 = (1U << 12);  ///< Falling trigger event configuration of line 12
        constexpr uint32_t TR13 = (1U << 13);  ///< Falling trigger event configuration of line 13
        constexpr uint32_t TR14 = (1U << 14);  ///< Falling trigger event configuration of line 14
        constexpr uint32_t TR15 = (1U << 15);  ///< Falling trigger event configuration of line 15
        constexpr uint32_t TR16 = (1U << 16);  ///< Falling trigger event configuration of line 16
        constexpr uint32_t TR17 = (1U << 17);  ///< Falling trigger event configuration of line 17
        constexpr uint32_t TR19 = (1U << 19);  ///< Falling trigger event configuration of line 19
    }

    /// SWIER Register bits
    namespace swier_bits {
        constexpr uint32_t SWIER0 = (1U << 0);  ///< Software Interrupt on line 0
        constexpr uint32_t SWIER1 = (1U << 1);  ///< Software Interrupt on line 1
        constexpr uint32_t SWIER2 = (1U << 2);  ///< Software Interrupt on line 2
        constexpr uint32_t SWIER3 = (1U << 3);  ///< Software Interrupt on line 3
        constexpr uint32_t SWIER4 = (1U << 4);  ///< Software Interrupt on line 4
        constexpr uint32_t SWIER5 = (1U << 5);  ///< Software Interrupt on line 5
        constexpr uint32_t SWIER6 = (1U << 6);  ///< Software Interrupt on line 6
        constexpr uint32_t SWIER7 = (1U << 7);  ///< Software Interrupt on line 7
        constexpr uint32_t SWIER8 = (1U << 8);  ///< Software Interrupt on line 8
        constexpr uint32_t SWIER9 = (1U << 9);  ///< Software Interrupt on line 9
        constexpr uint32_t SWIER10 = (1U << 10);  ///< Software Interrupt on line 10
        constexpr uint32_t SWIER11 = (1U << 11);  ///< Software Interrupt on line 11
        constexpr uint32_t SWIER12 = (1U << 12);  ///< Software Interrupt on line 12
        constexpr uint32_t SWIER13 = (1U << 13);  ///< Software Interrupt on line 13
        constexpr uint32_t SWIER14 = (1U << 14);  ///< Software Interrupt on line 14
        constexpr uint32_t SWIER15 = (1U << 15);  ///< Software Interrupt on line 15
        constexpr uint32_t SWIER16 = (1U << 16);  ///< Software Interrupt on line 16
        constexpr uint32_t SWIER17 = (1U << 17);  ///< Software Interrupt on line 17
        constexpr uint32_t SWIER19 = (1U << 19);  ///< Software Interrupt on line 19
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR0 = (1U << 0);  ///< Pending bit 0
        constexpr uint32_t PR1 = (1U << 1);  ///< Pending bit 1
        constexpr uint32_t PR2 = (1U << 2);  ///< Pending bit 2
        constexpr uint32_t PR3 = (1U << 3);  ///< Pending bit 3
        constexpr uint32_t PR4 = (1U << 4);  ///< Pending bit 4
        constexpr uint32_t PR5 = (1U << 5);  ///< Pending bit 5
        constexpr uint32_t PR6 = (1U << 6);  ///< Pending bit 6
        constexpr uint32_t PR7 = (1U << 7);  ///< Pending bit 7
        constexpr uint32_t PR8 = (1U << 8);  ///< Pending bit 8
        constexpr uint32_t PR9 = (1U << 9);  ///< Pending bit 9
        constexpr uint32_t PR10 = (1U << 10);  ///< Pending bit 10
        constexpr uint32_t PR11 = (1U << 11);  ///< Pending bit 11
        constexpr uint32_t PR12 = (1U << 12);  ///< Pending bit 12
        constexpr uint32_t PR13 = (1U << 13);  ///< Pending bit 13
        constexpr uint32_t PR14 = (1U << 14);  ///< Pending bit 14
        constexpr uint32_t PR15 = (1U << 15);  ///< Pending bit 15
        constexpr uint32_t PR16 = (1U << 16);  ///< Pending bit 16
        constexpr uint32_t PR17 = (1U << 17);  ///< Pending bit 17
        constexpr uint32_t PR19 = (1U << 19);  ///< Pending bit 19
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER;  ///< Offset: 0x00 - Interrupt Set Enable Register
        volatile uint32_t ICER;  ///< Offset: 0x80 - Interrupt Clear Enable Register
        volatile uint32_t ISPR;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ICPR;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register 1
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register 2
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register 3
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register 4
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register 5
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register 6
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register 7
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// ISER Register bits
    namespace iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER Register bits
    namespace icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR Register bits
    namespace ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR Register bits
    namespace icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t PRI_00 = (2 << 6);  ///< PRI_00
        constexpr uint32_t PRI_01 = (2 << 14);  ///< PRI_01
        constexpr uint32_t PRI_02 = (2 << 22);  ///< PRI_02
        constexpr uint32_t PRI_03 = (2 << 30);  ///< PRI_03
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t PRI_40 = (2 << 6);  ///< PRI_40
        constexpr uint32_t PRI_41 = (2 << 14);  ///< PRI_41
        constexpr uint32_t PRI_42 = (2 << 22);  ///< PRI_42
        constexpr uint32_t PRI_43 = (2 << 30);  ///< PRI_43
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t PRI_80 = (2 << 6);  ///< PRI_80
        constexpr uint32_t PRI_81 = (2 << 14);  ///< PRI_81
        constexpr uint32_t PRI_82 = (2 << 22);  ///< PRI_82
        constexpr uint32_t PRI_83 = (2 << 30);  ///< PRI_83
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t PRI_120 = (2 << 6);  ///< PRI_120
        constexpr uint32_t PRI_121 = (2 << 14);  ///< PRI_121
        constexpr uint32_t PRI_122 = (2 << 22);  ///< PRI_122
        constexpr uint32_t PRI_123 = (2 << 30);  ///< PRI_123
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t PRI_160 = (2 << 6);  ///< PRI_160
        constexpr uint32_t PRI_161 = (2 << 14);  ///< PRI_161
        constexpr uint32_t PRI_162 = (2 << 22);  ///< PRI_162
        constexpr uint32_t PRI_163 = (2 << 30);  ///< PRI_163
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t PRI_200 = (2 << 6);  ///< PRI_200
        constexpr uint32_t PRI_201 = (2 << 14);  ///< PRI_201
        constexpr uint32_t PRI_202 = (2 << 22);  ///< PRI_202
        constexpr uint32_t PRI_203 = (2 << 30);  ///< PRI_203
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t PRI_240 = (2 << 6);  ///< PRI_240
        constexpr uint32_t PRI_241 = (2 << 14);  ///< PRI_241
        constexpr uint32_t PRI_242 = (2 << 22);  ///< PRI_242
        constexpr uint32_t PRI_243 = (2 << 30);  ///< PRI_243
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t PRI_280 = (2 << 6);  ///< PRI_280
        constexpr uint32_t PRI_281 = (2 << 14);  ///< PRI_281
        constexpr uint32_t PRI_282 = (2 << 22);  ///< PRI_282
        constexpr uint32_t PRI_283 = (2 << 30);  ///< PRI_283
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40020000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - DMA interrupt status register (DMA_ISR)
        volatile uint32_t IFCR;  ///< Offset: 0x04 - DMA interrupt flag clear register (DMA_IFCR)
        volatile uint32_t CCR1;  ///< Offset: 0x08 - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - DMA channel 1 number of data register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - DMA channel 1 peripheral address register
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - DMA channel 1 memory address register
        volatile uint32_t CCR2;  ///< Offset: 0x1C - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - DMA channel 2 number of data register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - DMA channel 2 peripheral address register
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - DMA channel 2 memory address register
        volatile uint32_t CCR3;  ///< Offset: 0x30 - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - DMA channel 3 number of data register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - DMA channel 3 peripheral address register
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - DMA channel 3 memory address register
        volatile uint32_t CCR4;  ///< Offset: 0x44 - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - DMA channel 4 number of data register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - DMA channel 4 peripheral address register
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - DMA channel 4 memory address register
        volatile uint32_t CCR5;  ///< Offset: 0x58 - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - DMA channel 5 number of data register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - DMA channel 5 peripheral address register
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - DMA channel 5 memory address register
        volatile uint32_t CCR6;  ///< Offset: 0x6C - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR6;  ///< Offset: 0x70 - DMA channel 6 number of data register
        volatile uint32_t CPAR6;  ///< Offset: 0x74 - DMA channel 6 peripheral address register
        volatile uint32_t CMAR6;  ///< Offset: 0x78 - DMA channel 6 memory address register
        volatile uint32_t CCR7;  ///< Offset: 0x80 - DMA channel configuration register (DMA_CCR)
        volatile uint32_t CNDTR7;  ///< Offset: 0x84 - DMA channel 7 number of data register
        volatile uint32_t CPAR7;  ///< Offset: 0x88 - DMA channel 7 peripheral address register
        volatile uint32_t CMAR7;  ///< Offset: 0x8C - DMA channel 7 memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t GIF1 = (1U << 0);  ///< Channel 1 Global interrupt flag
        constexpr uint32_t TCIF1 = (1U << 1);  ///< Channel 1 Transfer Complete flag
        constexpr uint32_t HTIF1 = (1U << 2);  ///< Channel 1 Half Transfer Complete flag
        constexpr uint32_t TEIF1 = (1U << 3);  ///< Channel 1 Transfer Error flag
        constexpr uint32_t GIF2 = (1U << 4);  ///< Channel 2 Global interrupt flag
        constexpr uint32_t TCIF2 = (1U << 5);  ///< Channel 2 Transfer Complete flag
        constexpr uint32_t HTIF2 = (1U << 6);  ///< Channel 2 Half Transfer Complete flag
        constexpr uint32_t TEIF2 = (1U << 7);  ///< Channel 2 Transfer Error flag
        constexpr uint32_t GIF3 = (1U << 8);  ///< Channel 3 Global interrupt flag
        constexpr uint32_t TCIF3 = (1U << 9);  ///< Channel 3 Transfer Complete flag
        constexpr uint32_t HTIF3 = (1U << 10);  ///< Channel 3 Half Transfer Complete flag
        constexpr uint32_t TEIF3 = (1U << 11);  ///< Channel 3 Transfer Error flag
        constexpr uint32_t GIF4 = (1U << 12);  ///< Channel 4 Global interrupt flag
        constexpr uint32_t TCIF4 = (1U << 13);  ///< Channel 4 Transfer Complete flag
        constexpr uint32_t HTIF4 = (1U << 14);  ///< Channel 4 Half Transfer Complete flag
        constexpr uint32_t TEIF4 = (1U << 15);  ///< Channel 4 Transfer Error flag
        constexpr uint32_t GIF5 = (1U << 16);  ///< Channel 5 Global interrupt flag
        constexpr uint32_t TCIF5 = (1U << 17);  ///< Channel 5 Transfer Complete flag
        constexpr uint32_t HTIF5 = (1U << 18);  ///< Channel 5 Half Transfer Complete flag
        constexpr uint32_t TEIF5 = (1U << 19);  ///< Channel 5 Transfer Error flag
        constexpr uint32_t GIF6 = (1U << 20);  ///< Channel 6 Global interrupt flag
        constexpr uint32_t TCIF6 = (1U << 21);  ///< Channel 6 Transfer Complete flag
        constexpr uint32_t HTIF6 = (1U << 22);  ///< Channel 6 Half Transfer Complete flag
        constexpr uint32_t TEIF6 = (1U << 23);  ///< Channel 6 Transfer Error flag
        constexpr uint32_t GIF7 = (1U << 24);  ///< Channel 7 Global interrupt flag
        constexpr uint32_t TCIF7 = (1U << 25);  ///< Channel 7 Transfer Complete flag
        constexpr uint32_t HTIF7 = (1U << 26);  ///< Channel 7 Half Transfer Complete flag
        constexpr uint32_t TEIF7 = (1U << 27);  ///< Channel 7 Transfer Error flag
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CGIF1 = (1U << 0);  ///< Channel 1 Global interrupt clear
        constexpr uint32_t CGIF2 = (1U << 4);  ///< Channel 2 Global interrupt clear
        constexpr uint32_t CGIF3 = (1U << 8);  ///< Channel 3 Global interrupt clear
        constexpr uint32_t CGIF4 = (1U << 12);  ///< Channel 4 Global interrupt clear
        constexpr uint32_t CGIF5 = (1U << 16);  ///< Channel 5 Global interrupt clear
        constexpr uint32_t CGIF6 = (1U << 20);  ///< Channel 6 Global interrupt clear
        constexpr uint32_t CGIF7 = (1U << 24);  ///< Channel 7 Global interrupt clear
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< Channel 1 Transfer Complete clear
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< Channel 2 Transfer Complete clear
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< Channel 3 Transfer Complete clear
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< Channel 4 Transfer Complete clear
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< Channel 5 Transfer Complete clear
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< Channel 6 Transfer Complete clear
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< Channel 7 Transfer Complete clear
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< Channel 1 Half Transfer clear
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< Channel 2 Half Transfer clear
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< Channel 3 Half Transfer clear
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< Channel 4 Half Transfer clear
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< Channel 5 Half Transfer clear
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< Channel 6 Half Transfer clear
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< Channel 7 Half Transfer clear
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< Channel 1 Transfer Error clear
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< Channel 2 Transfer Error clear
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< Channel 3 Transfer Error clear
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< Channel 4 Transfer Error clear
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< Channel 5 Transfer Error clear
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< Channel 6 Transfer Error clear
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< Channel 7 Transfer Error clear
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR6 Register bits
    namespace ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR6 Register bits
    namespace cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR6 Register bits
    namespace cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR6 Register bits
    namespace cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR7 Register bits
    namespace ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half Transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel Priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR7 Register bits
    namespace cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR7 Register bits
    namespace cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR7 Register bits
    namespace cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - Clock configuration register (RCC_CFGR)
        volatile uint32_t CIR;  ///< Offset: 0x08 - Clock interrupt register (RCC_CIR)
        volatile uint32_t APB2RSTR;  ///< Offset: 0x0C - APB2 peripheral reset register (RCC_APB2RSTR)
        volatile uint32_t APB1RSTR;  ///< Offset: 0x10 - APB1 peripheral reset register (RCC_APB1RSTR)
        volatile uint32_t AHBENR;  ///< Offset: 0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)
        volatile uint32_t APB2ENR;  ///< Offset: 0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)
        volatile uint32_t APB1ENR;  ///< Offset: 0x1C - APB1 peripheral clock enable register (RCC_APB1ENR)
        volatile uint32_t BDCR;  ///< Offset: 0x20 - Backup domain control register (RCC_BDCR)
        volatile uint32_t CSR;  ///< Offset: 0x24 - Control/status register (RCC_CSR)
        volatile uint32_t AHBRSTR;  ///< Offset: 0x28 - AHB peripheral reset register
        volatile uint32_t CFGR2;  ///< Offset: 0x2C - Clock configuration register 2
        volatile uint32_t CFGR3;  ///< Offset: 0x30 - Clock configuration register 3
        volatile uint32_t CR2;  ///< Offset: 0x34 - Clock control register 2
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t HSION = (1U << 0);  ///< Internal High Speed clock enable
        constexpr uint32_t HSIRDY = (1U << 1);  ///< Internal High Speed clock ready flag
        constexpr uint32_t HSITRIM = (5 << 3);  ///< Internal High Speed clock trimming
        constexpr uint32_t HSICAL = (8 << 8);  ///< Internal High Speed clock Calibration
        constexpr uint32_t HSEON = (1U << 16);  ///< External High Speed clock enable
        constexpr uint32_t HSERDY = (1U << 17);  ///< External High Speed clock ready flag
        constexpr uint32_t HSEBYP = (1U << 18);  ///< External High Speed clock Bypass
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock Security System enable
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SW = (2 << 0);  ///< System clock Switch
        constexpr uint32_t SWS = (2 << 2);  ///< System Clock Switch Status
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler
        constexpr uint32_t PPRE = (3 << 8);  ///< APB Low speed prescaler (APB1)
        constexpr uint32_t ADCPRE = (2 << 14);  ///< ADC prescaler
        constexpr uint32_t PLLSRC = (1U << 16);  ///< PLL entry clock source
        constexpr uint32_t PLLXTPRE = (1U << 17);  ///< HSE divider for PLL entry
        constexpr uint32_t PLLMUL = (4 << 18);  ///< PLL Multiplication Factor
        constexpr uint32_t MCO = (3 << 24);  ///< Microcontroller clock output
    }

    /// CIR Register bits
    namespace cir_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI Ready Interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE Ready Interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 2);  ///< HSI Ready Interrupt flag
        constexpr uint32_t HSERDYF = (1U << 3);  ///< HSE Ready Interrupt flag
        constexpr uint32_t PLLRDYF = (1U << 4);  ///< PLL Ready Interrupt flag
        constexpr uint32_t HSI14RDYF = (1U << 5);  ///< HSI14 ready interrupt flag
        constexpr uint32_t CSSF = (1U << 7);  ///< Clock Security System Interrupt flag
        constexpr uint32_t LSIRDYIE = (1U << 8);  ///< LSI Ready Interrupt Enable
        constexpr uint32_t LSERDYIE = (1U << 9);  ///< LSE Ready Interrupt Enable
        constexpr uint32_t HSIRDYIE = (1U << 10);  ///< HSI Ready Interrupt Enable
        constexpr uint32_t HSERDYIE = (1U << 11);  ///< HSE Ready Interrupt Enable
        constexpr uint32_t PLLRDYIE = (1U << 12);  ///< PLL Ready Interrupt Enable
        constexpr uint32_t HSI14RDYE = (1U << 13);  ///< HSI14 ready interrupt enable
        constexpr uint32_t LSIRDYC = (1U << 16);  ///< LSI Ready Interrupt Clear
        constexpr uint32_t LSERDYC = (1U << 17);  ///< LSE Ready Interrupt Clear
        constexpr uint32_t HSIRDYC = (1U << 18);  ///< HSI Ready Interrupt Clear
        constexpr uint32_t HSERDYC = (1U << 19);  ///< HSE Ready Interrupt Clear
        constexpr uint32_t PLLRDYC = (1U << 20);  ///< PLL Ready Interrupt Clear
        constexpr uint32_t HSI14RDYC = (1U << 21);  ///< HSI 14 MHz Ready Interrupt Clear
        constexpr uint32_t CSSC = (1U << 23);  ///< Clock security system interrupt clear
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG and COMP reset
        constexpr uint32_t ADCRST = (1U << 9);  ///< ADC interface reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI 1 reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset
        constexpr uint32_t DBGMCURST = (1U << 22);  ///< Debug MCU reset
    }

    /// APB1RSTR Register bits
    namespace apb1rstr_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< Timer 2 reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< Timer 3 reset
        constexpr uint32_t TIM14RST = (1U << 8);  ///< Timer 14 reset
        constexpr uint32_t WWDGRST = (1U << 11);  ///< Window watchdog reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t CECRST = (1U << 30);  ///< HDMI CEC reset
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA1 clock enable
        constexpr uint32_t SRAMEN = (1U << 2);  ///< SRAM interface clock enable
        constexpr uint32_t FLITFEN = (1U << 4);  ///< FLITF clock enable
        constexpr uint32_t CRCEN = (1U << 6);  ///< CRC clock enable
        constexpr uint32_t IOPAEN = (1U << 17);  ///< I/O port A clock enable
        constexpr uint32_t IOPBEN = (1U << 18);  ///< I/O port B clock enable
        constexpr uint32_t IOPCEN = (1U << 19);  ///< I/O port C clock enable
        constexpr uint32_t IOPFEN = (1U << 22);  ///< I/O port F clock enable
        constexpr uint32_t TSCEN = (1U << 24);  ///< Touch sensing controller clock enable
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG clock enable
        constexpr uint32_t ADCEN = (1U << 9);  ///< ADC 1 interface clock enable
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 Timer clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI 1 clock enable
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 timer clock enable
        constexpr uint32_t DBGMCUEN = (1U << 22);  ///< MCU debug module clock enable
    }

    /// APB1ENR Register bits
    namespace apb1enr_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< Timer 2 clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< Timer 3 clock enable
        constexpr uint32_t TIM14EN = (1U << 8);  ///< Timer 14 clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C 1 clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t CECEN = (1U << 30);  ///< HDMI CEC interface clock enable
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< External Low Speed oscillator enable
        constexpr uint32_t LSERDY = (1U << 1);  ///< External Low Speed oscillator ready
        constexpr uint32_t LSEBYP = (1U << 2);  ///< External Low Speed oscillator bypass
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< Internal low speed oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< Internal low speed oscillator ready
        constexpr uint32_t RMVF = (1U << 24);  ///< Remove reset flag
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< PIN reset flag
        constexpr uint32_t PORRSTF = (1U << 27);  ///< POR/PDR reset flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent watchdog reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t IOPARST = (1U << 17);  ///< I/O port A reset
        constexpr uint32_t IOPBRST = (1U << 18);  ///< I/O port B reset
        constexpr uint32_t IOPCRST = (1U << 19);  ///< I/O port C reset
        constexpr uint32_t IOPFRST = (1U << 22);  ///< I/O port F reset
        constexpr uint32_t TSCRST = (1U << 24);  ///< Touch sensing controller reset
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t PREDIV = (4 << 0);  ///< PREDIV division factor
    }

    /// CFGR3 Register bits
    namespace cfgr3_bits {
        constexpr uint32_t USART1SW = (2 << 0);  ///< USART1 clock source selection
        constexpr uint32_t I2C1SW = (1U << 4);  ///< I2C1 clock source selection
        constexpr uint32_t CECSW = (1U << 6);  ///< HDMI CEC clock source selection
        constexpr uint32_t ADCSW = (1U << 8);  ///< ADC clock source selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t HSI14ON = (1U << 0);  ///< HSI14 clock enable
        constexpr uint32_t HSI14RDY = (1U << 1);  ///< HR14 clock ready flag
        constexpr uint32_t HSI14DIS = (1U << 2);  ///< HSI14 clock request from ADC disable
        constexpr uint32_t HSI14TRIM = (5 << 3);  ///< HSI14 clock trimming
        constexpr uint32_t HSI14CAL = (8 << 8);  ///< HSI14 clock calibration
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - configuration register 1
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
        volatile uint32_t CFGR2;  ///< Offset: 0x18 - configuration register 2
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t I2C_PB9_FM = (1U << 19);  ///< Fast Mode Plus (FM+) driving capability activation bits.
        constexpr uint32_t I2C_PB8_FM = (1U << 18);  ///< Fast Mode Plus (FM+) driving capability activation bits.
        constexpr uint32_t I2C_PB7_FM = (1U << 17);  ///< Fast Mode Plus (FM+) driving capability activation bits.
        constexpr uint32_t I2C_PB6_FM = (1U << 16);  ///< Fast Mode Plus (FM+) driving capability activation bits.
        constexpr uint32_t TIM17_DMA_RMP = (1U << 12);  ///< TIM17 DMA request remapping bit
        constexpr uint32_t TIM16_DMA_RMP = (1U << 11);  ///< TIM16 DMA request remapping bit
        constexpr uint32_t USART1_RX_DMA_RMP = (1U << 10);  ///< USART1_RX DMA request remapping bit
        constexpr uint32_t USART1_TX_DMA_RMP = (1U << 9);  ///< USART1_TX DMA remapping bit
        constexpr uint32_t ADC_DMA_RMP = (1U << 8);  ///< ADC DMA remapping bit
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI 3 configuration bits
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI 2 configuration bits
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI 1 configuration bits
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI 0 configuration bits
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI 7 configuration bits
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI 6 configuration bits
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI 5 configuration bits
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI 4 configuration bits
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI 11 configuration bits
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI 10 configuration bits
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI 9 configuration bits
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI 8 configuration bits
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI 15 configuration bits
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI 14 configuration bits
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI 13 configuration bits
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI 12 configuration bits
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t SRAM_PEF = (1U << 8);  ///< SRAM parity flag
        constexpr uint32_t PVD_LOCK = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t SRAM_PARITY_LOCK = (1U << 1);  ///< SRAM parity lock bit
        constexpr uint32_t LOCUP_LOCK = (1U << 0);  ///< Cortex-M0 LOCKUP bit enable bit
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - interrupt and status register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t CFGR1;  ///< Offset: 0x0C - configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - configuration register 2
        volatile uint32_t SMPR;  ///< Offset: 0x14 - sampling time register
        volatile uint32_t TR;  ///< Offset: 0x20 - watchdog threshold register
        volatile uint32_t CHSELR;  ///< Offset: 0x28 - channel selection register
        volatile uint32_t DR;  ///< Offset: 0x40 - data register
        volatile uint32_t CCR;  ///< Offset: 0x308 - common configuration register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t AWD = (1U << 7);  ///< Analog watchdog flag
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun
        constexpr uint32_t EOS = (1U << 3);  ///< End of sequence flag
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t AWDIE = (1U << 7);  ///< Analog watchdog interrupt enable
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of conversion sequence interrupt enable
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of conversion interrupt enable
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop conversion command
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start conversion command
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable command
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t AWDCH = (5 << 26);  ///< Analog watchdog channel selection
        constexpr uint32_t AWDEN = (1U << 23);  ///< Analog watchdog enable
        constexpr uint32_t AWDSGL = (1U << 22);  ///< Enable the watchdog on a single channel or on all channels
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode
        constexpr uint32_t AUTDLY = (1U << 14);  ///< Auto-delayed conversion mode
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun management mode
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection
        constexpr uint32_t EXTSEL = (3 << 6);  ///< External trigger selection
        constexpr uint32_t ALIGN = (1U << 5);  ///< Data alignment
        constexpr uint32_t RES = (2 << 3);  ///< Data resolution
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction
        constexpr uint32_t DMACFG = (1U << 1);  ///< Direct memery access configuration
        constexpr uint32_t DMAEN = (1U << 0);  ///< Direct memory access enable
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t JITOFF_D4 = (1U << 31);  ///< JITOFF_D4
        constexpr uint32_t JITOFF_D2 = (1U << 30);  ///< JITOFF_D2
    }

    /// SMPR Register bits
    namespace smpr_bits {
        constexpr uint32_t SMPR = (3 << 0);  ///< Sampling time selection
    }

    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t HT = (12 << 16);  ///< Analog watchdog higher threshold
        constexpr uint32_t LT = (12 << 0);  ///< Analog watchdog lower threshold
    }

    /// CHSELR Register bits
    namespace chselr_bits {
        constexpr uint32_t CHSEL18 = (1U << 18);  ///< Channel-x selection
        constexpr uint32_t CHSEL17 = (1U << 17);  ///< Channel-x selection
        constexpr uint32_t CHSEL16 = (1U << 16);  ///< Channel-x selection
        constexpr uint32_t CHSEL15 = (1U << 15);  ///< Channel-x selection
        constexpr uint32_t CHSEL14 = (1U << 14);  ///< Channel-x selection
        constexpr uint32_t CHSEL13 = (1U << 13);  ///< Channel-x selection
        constexpr uint32_t CHSEL12 = (1U << 12);  ///< Channel-x selection
        constexpr uint32_t CHSEL11 = (1U << 11);  ///< Channel-x selection
        constexpr uint32_t CHSEL10 = (1U << 10);  ///< Channel-x selection
        constexpr uint32_t CHSEL9 = (1U << 9);  ///< Channel-x selection
        constexpr uint32_t CHSEL8 = (1U << 8);  ///< Channel-x selection
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel-x selection
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel-x selection
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel-x selection
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel-x selection
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel-x selection
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel-x selection
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel-x selection
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel-x selection
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Converted data
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t VBATEN = (1U << 24);  ///< VBAT enable
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable
        constexpr uint32_t VREFEN = (1U << 22);  ///< Temperature sensor and VREFINT enable
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable
        constexpr uint32_t ABRMOD = (2 << 21);  ///< Auto baud rate mode
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< IrDA low-power
        constexpr uint32_t IREN = (1U << 1);  ///< IrDA mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t DIV_Mantissa = (12 << 4);  ///< mantissa of USARTDIV
        constexpr uint32_t DIV_Fraction = (4 << 0);  ///< fraction of USARTDIV
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag
        constexpr uint32_t WUF = (1U << 20);  ///< Wakeup from Stop mode flag
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wakeup from Mute mode
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag
        constexpr uint32_t CMF = (1U << 17);  ///< character match flag
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag
        constexpr uint32_t ABRF = (1U << 15);  ///< Auto baud rate flag
        constexpr uint32_t ABRE = (1U << 14);  ///< Auto baud rate error
        constexpr uint32_t EOBF = (1U << 12);  ///< End of block flag
        constexpr uint32_t RTOF = (1U << 11);  ///< Receiver timeout
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag
        constexpr uint32_t LBDF = (1U << 8);  ///< LIN break detection flag
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error
        constexpr uint32_t NF = (1U << 2);  ///< Noise detected flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing error
        constexpr uint32_t PE = (1U << 0);  ///< Parity error
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of timeout clear flag
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t ISR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t ALRMAR;  ///< Offset: 0x1C - alarm A register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t SSR;  ///< Offset: 0x28 - sub second register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - timestamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - timestamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - time-stamp sub second register
        volatile uint32_t CALR;  ///< Offset: 0x3C - calibration register
        volatile uint32_t TAFCR;  ///< Offset: 0x40 - tamper and alternate function configuration register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t BKP0R;  ///< Offset: 0x50 - backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x54 - backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x58 - backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x5C - backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x60 - backup register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 60 Hz)
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change)
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change)
        constexpr uint32_t BKP = (1U << 18);  ///< Backup
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t ALRAF = (1U << 8);  ///< Alarm A flag
        constexpr uint32_t TSF = (1U << 11);  ///< Time-stamp flag
        constexpr uint32_t TSOVF = (1U << 12);  ///< Time-stamp overflow flag
        constexpr uint32_t TAMP1F = (1U << 13);  ///< RTC_TAMP1 detection flag
        constexpr uint32_t TAMP2F = (1U << 14);  ///< RTC_TAMP2 detection flag
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format.
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format.
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Reserved
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Reserved
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// TAFCR Register bits
    namespace tafcr_bits {
        constexpr uint32_t PC15MODE = (1U << 23);  ///< PC15 mode
        constexpr uint32_t PC15VALUE = (1U << 22);  ///< PC15 value
        constexpr uint32_t PC14MODE = (1U << 21);  ///< PC14 mode
        constexpr uint32_t PC14VALUE = (1U << 20);  ///< PC14 value
        constexpr uint32_t PC13MODE = (1U << 19);  ///< PC13 mode
        constexpr uint32_t PC13VALUE = (1U << 18);  ///< RTC_ALARM output type/PC13 value
        constexpr uint32_t TAMP_PUDIS = (1U << 15);  ///< RTC_TAMPx pull-up disable
        constexpr uint32_t TAMP_PRCH = (2 << 13);  ///< RTC_TAMPx precharge duration
        constexpr uint32_t TAMPFLT = (2 << 11);  ///< RTC_TAMPx filter count
        constexpr uint32_t TAMPFREQ = (3 << 8);  ///< Tamper sampling frequency
        constexpr uint32_t TAMPTS = (1U << 7);  ///< Activate timestamp on tamper detection event
        constexpr uint32_t TAMP2_TRG = (1U << 4);  ///< Active level for RTC_TAMP2 input
        constexpr uint32_t TAMP2E = (1U << 3);  ///< RTC_TAMP2 input detection enable
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP1TRG = (1U << 1);  ///< Active level for RTC_TAMP1 input
        constexpr uint32_t TAMP1E = (1U << 0);  ///< RTC_TAMP1 input detection enable
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x40024000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t ICR;  ///< Offset: 0x08 - interrupt clear register
        volatile uint32_t ISR;  ///< Offset: 0x0C - interrupt status register
        volatile uint32_t IOHCR;  ///< Offset: 0x10 - I/O hysteresis control register
        volatile uint32_t IOASCR;  ///< Offset: 0x18 - I/O analog switch control register
        volatile uint32_t IOSCR;  ///< Offset: 0x20 - I/O sampling control register
        volatile uint32_t IOCCR;  ///< Offset: 0x28 - I/O channel control register
        volatile uint32_t IOGCSR;  ///< Offset: 0x30 - I/O group control status register
        volatile uint32_t IOG1CR;  ///< Offset: 0x34 - I/O group x counter register
        volatile uint32_t IOG2CR;  ///< Offset: 0x38 - I/O group x counter register
        volatile uint32_t IOG3CR;  ///< Offset: 0x3C - I/O group x counter register
        volatile uint32_t IOG4CR;  ///< Offset: 0x40 - I/O group x counter register
        volatile uint32_t IOG5CR;  ///< Offset: 0x44 - I/O group x counter register
        volatile uint32_t IOG6CR;  ///< Offset: 0x48 - I/O group x counter register
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CTPH = (4 << 28);  ///< Charge transfer pulse high
        constexpr uint32_t CTPL = (4 << 24);  ///< Charge transfer pulse low
        constexpr uint32_t SSD = (7 << 17);  ///< Spread spectrum deviation
        constexpr uint32_t SSE = (1U << 16);  ///< Spread spectrum enable
        constexpr uint32_t SSPSC = (1U << 15);  ///< Spread spectrum prescaler
        constexpr uint32_t PGPSC = (3 << 12);  ///< pulse generator prescaler
        constexpr uint32_t MCV = (3 << 5);  ///< Max count value
        constexpr uint32_t IODEF = (1U << 4);  ///< I/O Default mode
        constexpr uint32_t SYNCPOL = (1U << 3);  ///< Synchronization pin polarity
        constexpr uint32_t AM = (1U << 2);  ///< Acquisition mode
        constexpr uint32_t START = (1U << 1);  ///< Start a new acquisition
        constexpr uint32_t TSCE = (1U << 0);  ///< Touch sensing controller enable
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t MCEIE = (1U << 1);  ///< Max count error interrupt enable
        constexpr uint32_t EOAIE = (1U << 0);  ///< End of acquisition interrupt enable
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t MCEIC = (1U << 1);  ///< Max count error interrupt clear
        constexpr uint32_t EOAIC = (1U << 0);  ///< End of acquisition interrupt clear
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t MCEF = (1U << 1);  ///< Max count error flag
        constexpr uint32_t EOAF = (1U << 0);  ///< End of acquisition flag
    }

    /// IOHCR Register bits
    namespace iohcr_bits {
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4 Schmitt trigger hysteresis mode
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3 Schmitt trigger hysteresis mode
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2 Schmitt trigger hysteresis mode
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1 Schmitt trigger hysteresis mode
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4 Schmitt trigger hysteresis mode
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3 Schmitt trigger hysteresis mode
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2 Schmitt trigger hysteresis mode
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1 Schmitt trigger hysteresis mode
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4 Schmitt trigger hysteresis mode
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3 Schmitt trigger hysteresis mode
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2 Schmitt trigger hysteresis mode
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1 Schmitt trigger hysteresis mode
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4 Schmitt trigger hysteresis mode
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3 Schmitt trigger hysteresis mode
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2 Schmitt trigger hysteresis mode
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1 Schmitt trigger hysteresis mode
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4 Schmitt trigger hysteresis mode
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3 Schmitt trigger hysteresis mode
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2 Schmitt trigger hysteresis mode
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1 Schmitt trigger hysteresis mode
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4 Schmitt trigger hysteresis mode
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3 Schmitt trigger hysteresis mode
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2 Schmitt trigger hysteresis mode
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1 Schmitt trigger hysteresis mode
    }

    /// IOASCR Register bits
    namespace ioascr_bits {
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4 analog switch enable
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3 analog switch enable
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2 analog switch enable
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1 analog switch enable
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4 analog switch enable
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3 analog switch enable
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2 analog switch enable
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1 analog switch enable
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4 analog switch enable
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3 analog switch enable
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2 analog switch enable
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1 analog switch enable
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4 analog switch enable
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3 analog switch enable
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2 analog switch enable
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1 analog switch enable
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4 analog switch enable
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3 analog switch enable
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2 analog switch enable
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1 analog switch enable
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4 analog switch enable
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3 analog switch enable
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2 analog switch enable
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1 analog switch enable
    }

    /// IOSCR Register bits
    namespace ioscr_bits {
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4 sampling mode
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3 sampling mode
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2 sampling mode
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1 sampling mode
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4 sampling mode
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3 sampling mode
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2 sampling mode
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1 sampling mode
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4 sampling mode
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3 sampling mode
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2 sampling mode
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1 sampling mode
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4 sampling mode
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3 sampling mode
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2 sampling mode
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1 sampling mode
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4 sampling mode
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3 sampling mode
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2 sampling mode
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1 sampling mode
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4 sampling mode
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3 sampling mode
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2 sampling mode
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1 sampling mode
    }

    /// IOCCR Register bits
    namespace ioccr_bits {
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4 channel mode
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3 channel mode
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2 channel mode
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1 channel mode
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4 channel mode
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3 channel mode
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2 channel mode
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1 channel mode
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4 channel mode
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3 channel mode
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2 channel mode
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1 channel mode
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4 channel mode
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3 channel mode
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2 channel mode
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1 channel mode
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4 channel mode
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3 channel mode
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2 channel mode
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1 channel mode
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4 channel mode
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3 channel mode
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2 channel mode
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1 channel mode
    }

    /// IOGCSR Register bits
    namespace iogcsr_bits {
        constexpr uint32_t G8S = (1U << 23);  ///< Analog I/O group x status
        constexpr uint32_t G7S = (1U << 22);  ///< Analog I/O group x status
        constexpr uint32_t G6S = (1U << 21);  ///< Analog I/O group x status
        constexpr uint32_t G5S = (1U << 20);  ///< Analog I/O group x status
        constexpr uint32_t G4S = (1U << 19);  ///< Analog I/O group x status
        constexpr uint32_t G3S = (1U << 18);  ///< Analog I/O group x status
        constexpr uint32_t G2S = (1U << 17);  ///< Analog I/O group x status
        constexpr uint32_t G1S = (1U << 16);  ///< Analog I/O group x status
        constexpr uint32_t G8E = (1U << 7);  ///< Analog I/O group x enable
        constexpr uint32_t G7E = (1U << 6);  ///< Analog I/O group x enable
        constexpr uint32_t G6E = (1U << 5);  ///< Analog I/O group x enable
        constexpr uint32_t G5E = (1U << 4);  ///< Analog I/O group x enable
        constexpr uint32_t G4E = (1U << 3);  ///< Analog I/O group x enable
        constexpr uint32_t G3E = (1U << 2);  ///< Analog I/O group x enable
        constexpr uint32_t G2E = (1U << 1);  ///< Analog I/O group x enable
        constexpr uint32_t G1E = (1U << 0);  ///< Analog I/O group x enable
    }

    /// IOG1CR Register bits
    namespace iog1cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG2CR Register bits
    namespace iog2cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG3CR Register bits
    namespace iog3cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG4CR Register bits
    namespace iog4cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG5CR Register bits
    namespace iog5cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG6CR Register bits
    namespace iog6cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

}

// ============================================================================
// CEC Peripheral
// ============================================================================

namespace cec {
    /// Base addresses
    constexpr uint32_t CEC_BASE = 0x40007800;

    /// CEC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - configuration register
        volatile uint32_t TXDR;  ///< Offset: 0x08 - Tx data register
        volatile uint32_t RXDR;  ///< Offset: 0x0C - Rx Data Register
        volatile uint32_t ISR;  ///< Offset: 0x10 - Interrupt and Status Register
        volatile uint32_t IER;  ///< Offset: 0x14 - interrupt enable register
    };

    /// Peripheral instances
    inline Registers* CEC = reinterpret_cast<Registers*>(CEC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TXEOM = (1U << 2);  ///< Tx End Of Message
        constexpr uint32_t TXSOM = (1U << 1);  ///< Tx start of message
        constexpr uint32_t CECEN = (1U << 0);  ///< CEC Enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t LBPEGEN = (1U << 11);  ///< Generate Error-Bit on Long Bit Period Error
        constexpr uint32_t BREGEN = (1U << 10);  ///< Generate error-bit on bit rising error
        constexpr uint32_t BRESTP = (1U << 9);  ///< Rx-stop on bit rising error
        constexpr uint32_t RXTOL = (1U << 8);  ///< Rx-Tolerance
        constexpr uint32_t SFT = (3 << 5);  ///< Signal Free Time
        constexpr uint32_t LSTN = (1U << 4);  ///< Listen mode
        constexpr uint32_t OAR = (4 << 0);  ///< Own Address
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< Tx Data register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDR = (8 << 0);  ///< CEC Rx Data Register
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXACKE = (1U << 12);  ///< Tx-Missing acknowledge error
        constexpr uint32_t TXERR = (1U << 11);  ///< Tx-Error
        constexpr uint32_t TXUDR = (1U << 10);  ///< Tx-Buffer Underrun
        constexpr uint32_t TXEND = (1U << 9);  ///< End of Transmission
        constexpr uint32_t TXBR = (1U << 8);  ///< Tx-Byte Request
        constexpr uint32_t ARBLST = (1U << 7);  ///< Arbitration Lost
        constexpr uint32_t RXACKE = (1U << 6);  ///< Rx-Missing Acknowledge
        constexpr uint32_t LBPE = (1U << 5);  ///< Rx-Long Bit Period Error
        constexpr uint32_t SBPE = (1U << 4);  ///< Rx-Short Bit period error
        constexpr uint32_t BRE = (1U << 3);  ///< Rx-Bit rising error
        constexpr uint32_t RXOVR = (1U << 2);  ///< Rx-Overrun
        constexpr uint32_t RXEND = (1U << 1);  ///< End Of Reception
        constexpr uint32_t RXBR = (1U << 0);  ///< Rx-Byte Received
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TXACKIE = (1U << 12);  ///< Tx-Missing Acknowledge Error Interrupt Enable
        constexpr uint32_t TXERRIE = (1U << 11);  ///< Tx-Error Interrupt Enable
        constexpr uint32_t TXUDRIE = (1U << 10);  ///< Tx-Underrun interrupt enable
        constexpr uint32_t TXENDIE = (1U << 9);  ///< Tx-End of message interrupt enable
        constexpr uint32_t TXBRIE = (1U << 8);  ///< Tx-Byte Request Interrupt Enable
        constexpr uint32_t ARBLSTIE = (1U << 7);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t RXACKIE = (1U << 6);  ///< Rx-Missing Acknowledge Error Interrupt Enable
        constexpr uint32_t LBPEIE = (1U << 5);  ///< Long Bit Period Error Interrupt Enable
        constexpr uint32_t SBPEIE = (1U << 4);  ///< Short Bit Period Error Interrupt Enable
        constexpr uint32_t BREIE = (1U << 3);  ///< Bit Rising Error Interrupt Enable
        constexpr uint32_t RXOVRIE = (1U << 2);  ///< Rx-Buffer Overrun Interrupt Enable
        constexpr uint32_t RXENDIE = (1U << 1);  ///< End Of Reception Interrupt Enable
        constexpr uint32_t RXBRIE = (1U << 0);  ///< Rx-Byte Received Interrupt Enable
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t Flash_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Flash access control register
        volatile uint32_t KEYR;  ///< Offset: 0x04 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x08 - Flash option key register
        volatile uint32_t SR;  ///< Offset: 0x0C - Flash status register
        volatile uint32_t CR;  ///< Offset: 0x10 - Flash control register
        volatile uint32_t AR;  ///< Offset: 0x14 - Flash address register
        volatile uint32_t OBR;  ///< Offset: 0x1C - Option byte register
        volatile uint32_t WRPR;  ///< Offset: 0x20 - Write protection register
    };

    /// Peripheral instances
    inline Registers* Flash = reinterpret_cast<Registers*>(Flash_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< LATENCY
        constexpr uint32_t PRFTBE = (1U << 4);  ///< PRFTBE
        constexpr uint32_t PRFTBS = (1U << 5);  ///< PRFTBS
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t FKEYR = (32 << 0);  ///< Flash Key
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 5);  ///< End of operation
        constexpr uint32_t WRPRT = (1U << 4);  ///< Write protection error
        constexpr uint32_t PGERR = (1U << 2);  ///< Programming error
        constexpr uint32_t BSY = (1U << 0);  ///< Busy
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t FORCE_OPTLOAD = (1U << 13);  ///< Force option byte loading
        constexpr uint32_t EOPIE = (1U << 12);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 10);  ///< Error interrupt enable
        constexpr uint32_t OPTWRE = (1U << 9);  ///< Option bytes write enable
        constexpr uint32_t LOCK = (1U << 7);  ///< Lock
        constexpr uint32_t STRT = (1U << 6);  ///< Start
        constexpr uint32_t OPTER = (1U << 5);  ///< Option byte erase
        constexpr uint32_t OPTPG = (1U << 4);  ///< Option byte programming
        constexpr uint32_t MER = (1U << 2);  ///< Mass erase
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t PG = (1U << 0);  ///< Programming
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t FAR = (32 << 0);  ///< Flash address
    }

    /// OBR Register bits
    namespace obr_bits {
        constexpr uint32_t Data1 = (8 << 24);  ///< Data1
        constexpr uint32_t Data0 = (8 << 16);  ///< Data0
        constexpr uint32_t VDDA_MONITOR = (1U << 13);  ///< VDDA_MONITOR
        constexpr uint32_t BOOT1 = (1U << 12);  ///< BOOT1
        constexpr uint32_t nRST_STDBY = (1U << 10);  ///< nRST_STDBY
        constexpr uint32_t nRST_STOP = (1U << 9);  ///< nRST_STOP
        constexpr uint32_t WDG_SW = (1U << 8);  ///< WDG_SW
        constexpr uint32_t LEVEL2_PROT = (1U << 2);  ///< Level 2 protection status
        constexpr uint32_t LEVEL1_PROT = (1U << 1);  ///< Level 1 protection status
        constexpr uint32_t OPTERR = (1U << 0);  ///< Option byte error
    }

    /// WRPR Register bits
    namespace wrpr_bits {
        constexpr uint32_t WRP = (16 << 0);  ///< Write protect
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0x40015800;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - MCU Device ID Code Register
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU Configuration Register
        volatile uint32_t APBLFZ;  ///< Offset: 0x08 - APB Low Freeze Register
        volatile uint32_t APBHFZ;  ///< Offset: 0x0C - APB High Freeze Register
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device Identifier
        constexpr uint32_t DIV_ID = (4 << 12);  ///< Division Identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision Identifier
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop Mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby Mode
    }

    /// APBLFZ Register bits
    namespace apblfz_bits {
        constexpr uint32_t DBG_TIMER2_STOP = (1U << 0);  ///< Debug Timer 2 stopped when Core is halted
        constexpr uint32_t DBG_TIMER3_STOP = (1U << 1);  ///< Debug Timer 3 stopped when Core is halted
        constexpr uint32_t DBG_TIMER6_STOP = (1U << 4);  ///< Debug Timer 6 stopped when Core is halted
        constexpr uint32_t DBG_TIMER14_STOP = (1U << 8);  ///< Debug Timer 14 stopped when Core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< Debug RTC stopped when Core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Debug Window Wachdog stopped when Core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Debug Independent Wachdog stopped when Core is halted
        constexpr uint32_t I2C1_SMBUS_TIMEOUT = (1U << 21);  ///< SMBUS timeout mode stopped when Core is halted
    }

    /// APBHFZ Register bits
    namespace apbhfz_bits {
        constexpr uint32_t DBG_TIMER1_STOP = (1U << 11);  ///< Debug Timer 1 stopped when Core is halted
        constexpr uint32_t DBG_TIMER15_STO = (1U << 16);  ///< Debug Timer 15 stopped when Core is halted
        constexpr uint32_t DBG_TIMER16_STO = (1U << 17);  ///< Debug Timer 16 stopped when Core is halted
        constexpr uint32_t DBG_TIMER17_STO = (1U << 18);  ///< Debug Timer 17 stopped when Core is halted
    }

}


} // namespace alloy::generated::stm32f031x

#endif // ALLOY_GENERATED_STM32F031X_PERIPHERALS_HPP