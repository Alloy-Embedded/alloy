/// Auto-generated code for STM32F410
/// Generated by Alloy Code Generator
/// Source: st_stm32f410.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:30:09
#ifndef ALLOY_GENERATED_STM32F410_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32F410_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32f410 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_Common_BASE = 0x40012300;
    constexpr uint32_t ADC1_BASE = 0x40012000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - ADC Common status register
        volatile uint32_t CCR;  ///< Offset: 0x04 - ADC common control register
    };

    /// Peripheral instances
    inline Registers* ADC_Common = reinterpret_cast<Registers*>(ADC_Common_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t OVR3 = (1U << 21);  ///< Overrun flag of ADC3
        constexpr uint32_t STRT3 = (1U << 20);  ///< Regular channel Start flag of ADC 3
        constexpr uint32_t JSTRT3 = (1U << 19);  ///< Injected channel Start flag of ADC 3
        constexpr uint32_t JEOC3 = (1U << 18);  ///< Injected channel end of conversion of ADC 3
        constexpr uint32_t EOC3 = (1U << 17);  ///< End of conversion of ADC 3
        constexpr uint32_t AWD3 = (1U << 16);  ///< Analog watchdog flag of ADC 3
        constexpr uint32_t OVR2 = (1U << 13);  ///< Overrun flag of ADC 2
        constexpr uint32_t STRT2 = (1U << 12);  ///< Regular channel Start flag of ADC 2
        constexpr uint32_t JSTRT2 = (1U << 11);  ///< Injected channel Start flag of ADC 2
        constexpr uint32_t JEOC2 = (1U << 10);  ///< Injected channel end of conversion of ADC 2
        constexpr uint32_t EOC2 = (1U << 9);  ///< End of conversion of ADC 2
        constexpr uint32_t AWD2 = (1U << 8);  ///< Analog watchdog flag of ADC 2
        constexpr uint32_t OVR1 = (1U << 5);  ///< Overrun flag of ADC 1
        constexpr uint32_t STRT1 = (1U << 4);  ///< Regular channel Start flag of ADC 1
        constexpr uint32_t JSTRT1 = (1U << 3);  ///< Injected channel Start flag of ADC 1
        constexpr uint32_t JEOC1 = (1U << 2);  ///< Injected channel end of conversion of ADC 1
        constexpr uint32_t EOC1 = (1U << 1);  ///< End of conversion of ADC 1
        constexpr uint32_t AWD1 = (1U << 0);  ///< Analog watchdog flag of ADC 1
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t TSVREFE = (1U << 23);  ///< Temperature sensor and VREFINT enable
        constexpr uint32_t VBATE = (1U << 22);  ///< VBAT enable
        constexpr uint32_t ADCPRE = (2 << 16);  ///< ADC prescaler
        constexpr uint32_t DMA = (2 << 14);  ///< Direct memory access mode for multi ADC mode
        constexpr uint32_t DDS = (1U << 13);  ///< DMA disable selection for multi-ADC mode
        constexpr uint32_t DELAY = (4 << 8);  ///< Delay between 2 sampling phases
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent Data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data Register
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (8 << 0);  ///< Independent Data register
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CR = (1U << 0);  ///< Control regidter
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0xE0042000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGMCU_IDCODE;  ///< Offset: 0x00 - IDCODE
        volatile uint32_t DBGMCU_CR;  ///< Offset: 0x04 - Control Register
        volatile uint32_t DBGMCU_APB1_FZ;  ///< Offset: 0x08 - Debug MCU APB1 Freeze registe
        volatile uint32_t DBGMCU_APB2_FZ;  ///< Offset: 0x0C - Debug MCU APB2 Freeze registe
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGMCU_IDCODE Register bits
    namespace dbgmcu_idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< DEV_ID
        constexpr uint32_t REV_ID = (16 << 16);  ///< REV_ID
    }

    /// DBGMCU_CR Register bits
    namespace dbgmcu_cr_bits {
        constexpr uint32_t DBG_SLEEP = (1U << 0);  ///< DBG_SLEEP
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< DBG_STOP
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< DBG_STANDBY
        constexpr uint32_t TRACE_IOEN = (1U << 5);  ///< TRACE_IOEN
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< TRACE_MODE
    }

    /// DBGMCU_APB1_FZ Register bits
    namespace dbgmcu_apb1_fz_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< DBG_TIM2_STOP
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< DBG_TIM3 _STOP
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< DBG_TIM4_STOP
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< DBG_TIM5_STOP
        constexpr uint32_t DBG_RTC_Stop = (1U << 10);  ///< RTC stopped when Core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< DBG_WWDG_STOP
        constexpr uint32_t DBG_IWDEG_STOP = (1U << 12);  ///< DBG_IWDEG_STOP
        constexpr uint32_t DBG_I2C1_SMBUS_TIMEOUT = (1U << 21);  ///< DBG_J2C1_SMBUS_TIMEOUT
        constexpr uint32_t DBG_I2C2_SMBUS_TIMEOUT = (1U << 22);  ///< DBG_J2C2_SMBUS_TIMEOUT
        constexpr uint32_t DBG_I2C3SMBUS_TIMEOUT = (1U << 23);  ///< DBG_J2C3SMBUS_TIMEOUT
    }

    /// DBGMCU_APB2_FZ Register bits
    namespace dbgmcu_apb2_fz_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 0);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM9_STOP = (1U << 16);  ///< TIM9 counter stopped when core is halted
        constexpr uint32_t DBG_TIM10_STOP = (1U << 17);  ///< TIM10 counter stopped when core is halted
        constexpr uint32_t DBG_TIM11_STOP = (1U << 18);  ///< TIM11 counter stopped when core is halted
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40013C00;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t IMR;  ///< Offset: 0x00 - Interrupt mask register (EXTI_IMR)
        volatile uint32_t EMR;  ///< Offset: 0x04 - Event mask register (EXTI_EMR)
        volatile uint32_t RTSR;  ///< Offset: 0x08 - Rising Trigger selection register (EXTI_RTSR)
        volatile uint32_t FTSR;  ///< Offset: 0x0C - Falling Trigger selection register (EXTI_FTSR)
        volatile uint32_t SWIER;  ///< Offset: 0x10 - Software interrupt event register (EXTI_SWIER)
        volatile uint32_t PR;  ///< Offset: 0x14 - Pending register (EXTI_PR)
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Interrupt Mask on line 0
        constexpr uint32_t MR1 = (1U << 1);  ///< Interrupt Mask on line 1
        constexpr uint32_t MR2 = (1U << 2);  ///< Interrupt Mask on line 2
        constexpr uint32_t MR3 = (1U << 3);  ///< Interrupt Mask on line 3
        constexpr uint32_t MR4 = (1U << 4);  ///< Interrupt Mask on line 4
        constexpr uint32_t MR5 = (1U << 5);  ///< Interrupt Mask on line 5
        constexpr uint32_t MR6 = (1U << 6);  ///< Interrupt Mask on line 6
        constexpr uint32_t MR7 = (1U << 7);  ///< Interrupt Mask on line 7
        constexpr uint32_t MR8 = (1U << 8);  ///< Interrupt Mask on line 8
        constexpr uint32_t MR9 = (1U << 9);  ///< Interrupt Mask on line 9
        constexpr uint32_t MR10 = (1U << 10);  ///< Interrupt Mask on line 10
        constexpr uint32_t MR11 = (1U << 11);  ///< Interrupt Mask on line 11
        constexpr uint32_t MR12 = (1U << 12);  ///< Interrupt Mask on line 12
        constexpr uint32_t MR13 = (1U << 13);  ///< Interrupt Mask on line 13
        constexpr uint32_t MR14 = (1U << 14);  ///< Interrupt Mask on line 14
        constexpr uint32_t MR15 = (1U << 15);  ///< Interrupt Mask on line 15
        constexpr uint32_t MR16 = (1U << 16);  ///< Interrupt Mask on line 16
        constexpr uint32_t MR17 = (1U << 17);  ///< Interrupt Mask on line 17
        constexpr uint32_t MR18 = (1U << 18);  ///< Interrupt Mask on line 18
        constexpr uint32_t MR19 = (1U << 19);  ///< Interrupt Mask on line 19
        constexpr uint32_t MR20 = (1U << 20);  ///< Interrupt Mask on line 20
        constexpr uint32_t MR21 = (1U << 21);  ///< Interrupt Mask on line 21
        constexpr uint32_t MR22 = (1U << 22);  ///< Interrupt Mask on line 22
    }

    /// EMR Register bits
    namespace emr_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Event Mask on line 0
        constexpr uint32_t MR1 = (1U << 1);  ///< Event Mask on line 1
        constexpr uint32_t MR2 = (1U << 2);  ///< Event Mask on line 2
        constexpr uint32_t MR3 = (1U << 3);  ///< Event Mask on line 3
        constexpr uint32_t MR4 = (1U << 4);  ///< Event Mask on line 4
        constexpr uint32_t MR5 = (1U << 5);  ///< Event Mask on line 5
        constexpr uint32_t MR6 = (1U << 6);  ///< Event Mask on line 6
        constexpr uint32_t MR7 = (1U << 7);  ///< Event Mask on line 7
        constexpr uint32_t MR8 = (1U << 8);  ///< Event Mask on line 8
        constexpr uint32_t MR9 = (1U << 9);  ///< Event Mask on line 9
        constexpr uint32_t MR10 = (1U << 10);  ///< Event Mask on line 10
        constexpr uint32_t MR11 = (1U << 11);  ///< Event Mask on line 11
        constexpr uint32_t MR12 = (1U << 12);  ///< Event Mask on line 12
        constexpr uint32_t MR13 = (1U << 13);  ///< Event Mask on line 13
        constexpr uint32_t MR14 = (1U << 14);  ///< Event Mask on line 14
        constexpr uint32_t MR15 = (1U << 15);  ///< Event Mask on line 15
        constexpr uint32_t MR16 = (1U << 16);  ///< Event Mask on line 16
        constexpr uint32_t MR17 = (1U << 17);  ///< Event Mask on line 17
        constexpr uint32_t MR18 = (1U << 18);  ///< Event Mask on line 18
        constexpr uint32_t MR19 = (1U << 19);  ///< Event Mask on line 19
        constexpr uint32_t MR20 = (1U << 20);  ///< Event Mask on line 20
        constexpr uint32_t MR21 = (1U << 21);  ///< Event Mask on line 21
        constexpr uint32_t MR22 = (1U << 22);  ///< Event Mask on line 22
    }

    /// RTSR Register bits
    namespace rtsr_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration of line 0
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration of line 1
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration of line 2
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration of line 3
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration of line 4
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration of line 5
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration of line 6
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration of line 7
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration of line 8
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration of line 9
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration of line 10
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration of line 11
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration of line 12
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration of line 13
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration of line 14
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration of line 15
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration of line 16
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration of line 17
        constexpr uint32_t TR18 = (1U << 18);  ///< Rising trigger event configuration of line 18
        constexpr uint32_t TR19 = (1U << 19);  ///< Rising trigger event configuration of line 19
        constexpr uint32_t TR20 = (1U << 20);  ///< Rising trigger event configuration of line 20
        constexpr uint32_t TR21 = (1U << 21);  ///< Rising trigger event configuration of line 21
        constexpr uint32_t TR22 = (1U << 22);  ///< Rising trigger event configuration of line 22
    }

    /// FTSR Register bits
    namespace ftsr_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Falling trigger event configuration of line 0
        constexpr uint32_t TR1 = (1U << 1);  ///< Falling trigger event configuration of line 1
        constexpr uint32_t TR2 = (1U << 2);  ///< Falling trigger event configuration of line 2
        constexpr uint32_t TR3 = (1U << 3);  ///< Falling trigger event configuration of line 3
        constexpr uint32_t TR4 = (1U << 4);  ///< Falling trigger event configuration of line 4
        constexpr uint32_t TR5 = (1U << 5);  ///< Falling trigger event configuration of line 5
        constexpr uint32_t TR6 = (1U << 6);  ///< Falling trigger event configuration of line 6
        constexpr uint32_t TR7 = (1U << 7);  ///< Falling trigger event configuration of line 7
        constexpr uint32_t TR8 = (1U << 8);  ///< Falling trigger event configuration of line 8
        constexpr uint32_t TR9 = (1U << 9);  ///< Falling trigger event configuration of line 9
        constexpr uint32_t TR10 = (1U << 10);  ///< Falling trigger event configuration of line 10
        constexpr uint32_t TR11 = (1U << 11);  ///< Falling trigger event configuration of line 11
        constexpr uint32_t TR12 = (1U << 12);  ///< Falling trigger event configuration of line 12
        constexpr uint32_t TR13 = (1U << 13);  ///< Falling trigger event configuration of line 13
        constexpr uint32_t TR14 = (1U << 14);  ///< Falling trigger event configuration of line 14
        constexpr uint32_t TR15 = (1U << 15);  ///< Falling trigger event configuration of line 15
        constexpr uint32_t TR16 = (1U << 16);  ///< Falling trigger event configuration of line 16
        constexpr uint32_t TR17 = (1U << 17);  ///< Falling trigger event configuration of line 17
        constexpr uint32_t TR18 = (1U << 18);  ///< Falling trigger event configuration of line 18
        constexpr uint32_t TR19 = (1U << 19);  ///< Falling trigger event configuration of line 19
        constexpr uint32_t TR20 = (1U << 20);  ///< Falling trigger event configuration of line 20
        constexpr uint32_t TR21 = (1U << 21);  ///< Falling trigger event configuration of line 21
        constexpr uint32_t TR22 = (1U << 22);  ///< Falling trigger event configuration of line 22
    }

    /// SWIER Register bits
    namespace swier_bits {
        constexpr uint32_t SWIER0 = (1U << 0);  ///< Software Interrupt on line 0
        constexpr uint32_t SWIER1 = (1U << 1);  ///< Software Interrupt on line 1
        constexpr uint32_t SWIER2 = (1U << 2);  ///< Software Interrupt on line 2
        constexpr uint32_t SWIER3 = (1U << 3);  ///< Software Interrupt on line 3
        constexpr uint32_t SWIER4 = (1U << 4);  ///< Software Interrupt on line 4
        constexpr uint32_t SWIER5 = (1U << 5);  ///< Software Interrupt on line 5
        constexpr uint32_t SWIER6 = (1U << 6);  ///< Software Interrupt on line 6
        constexpr uint32_t SWIER7 = (1U << 7);  ///< Software Interrupt on line 7
        constexpr uint32_t SWIER8 = (1U << 8);  ///< Software Interrupt on line 8
        constexpr uint32_t SWIER9 = (1U << 9);  ///< Software Interrupt on line 9
        constexpr uint32_t SWIER10 = (1U << 10);  ///< Software Interrupt on line 10
        constexpr uint32_t SWIER11 = (1U << 11);  ///< Software Interrupt on line 11
        constexpr uint32_t SWIER12 = (1U << 12);  ///< Software Interrupt on line 12
        constexpr uint32_t SWIER13 = (1U << 13);  ///< Software Interrupt on line 13
        constexpr uint32_t SWIER14 = (1U << 14);  ///< Software Interrupt on line 14
        constexpr uint32_t SWIER15 = (1U << 15);  ///< Software Interrupt on line 15
        constexpr uint32_t SWIER16 = (1U << 16);  ///< Software Interrupt on line 16
        constexpr uint32_t SWIER17 = (1U << 17);  ///< Software Interrupt on line 17
        constexpr uint32_t SWIER18 = (1U << 18);  ///< Software Interrupt on line 18
        constexpr uint32_t SWIER19 = (1U << 19);  ///< Software Interrupt on line 19
        constexpr uint32_t SWIER20 = (1U << 20);  ///< Software Interrupt on line 20
        constexpr uint32_t SWIER21 = (1U << 21);  ///< Software Interrupt on line 21
        constexpr uint32_t SWIER22 = (1U << 22);  ///< Software Interrupt on line 22
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR0 = (1U << 0);  ///< Pending bit 0
        constexpr uint32_t PR1 = (1U << 1);  ///< Pending bit 1
        constexpr uint32_t PR2 = (1U << 2);  ///< Pending bit 2
        constexpr uint32_t PR3 = (1U << 3);  ///< Pending bit 3
        constexpr uint32_t PR4 = (1U << 4);  ///< Pending bit 4
        constexpr uint32_t PR5 = (1U << 5);  ///< Pending bit 5
        constexpr uint32_t PR6 = (1U << 6);  ///< Pending bit 6
        constexpr uint32_t PR7 = (1U << 7);  ///< Pending bit 7
        constexpr uint32_t PR8 = (1U << 8);  ///< Pending bit 8
        constexpr uint32_t PR9 = (1U << 9);  ///< Pending bit 9
        constexpr uint32_t PR10 = (1U << 10);  ///< Pending bit 10
        constexpr uint32_t PR11 = (1U << 11);  ///< Pending bit 11
        constexpr uint32_t PR12 = (1U << 12);  ///< Pending bit 12
        constexpr uint32_t PR13 = (1U << 13);  ///< Pending bit 13
        constexpr uint32_t PR14 = (1U << 14);  ///< Pending bit 14
        constexpr uint32_t PR15 = (1U << 15);  ///< Pending bit 15
        constexpr uint32_t PR16 = (1U << 16);  ///< Pending bit 16
        constexpr uint32_t PR17 = (1U << 17);  ///< Pending bit 17
        constexpr uint32_t PR18 = (1U << 18);  ///< Pending bit 18
        constexpr uint32_t PR19 = (1U << 19);  ///< Pending bit 19
        constexpr uint32_t PR20 = (1U << 20);  ///< Pending bit 20
        constexpr uint32_t PR21 = (1U << 21);  ///< Pending bit 21
        constexpr uint32_t PR22 = (1U << 22);  ///< Pending bit 22
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40023C00;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Flash access control register
        volatile uint32_t KEYR;  ///< Offset: 0x04 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x08 - Flash option key register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control register
        volatile uint32_t OPTCR;  ///< Offset: 0x14 - Flash option control register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t DCEN = (1U << 10);  ///< Data cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t DCRST = (1U << 12);  ///< Data cache reset
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< FPEC key
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEY = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protection error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t PGPERR = (1U << 6);  ///< Programming parallelism error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t BSY = (1U << 16);  ///< Busy
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t SER = (1U << 1);  ///< Sector Erase
        constexpr uint32_t MER = (1U << 2);  ///< Mass Erase
        constexpr uint32_t SNB = (4 << 3);  ///< Sector number
        constexpr uint32_t PSIZE = (2 << 8);  ///< Program size
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock
    }

    /// OPTCR Register bits
    namespace optcr_bits {
        constexpr uint32_t OPTLOCK = (1U << 0);  ///< Option lock
        constexpr uint32_t OPTSTRT = (1U << 1);  ///< Option start
        constexpr uint32_t BOR_LEV = (2 << 2);  ///< BOR reset Level
        constexpr uint32_t WDG_SW = (1U << 5);  ///< WDG_SW User option bytes
        constexpr uint32_t nRST_STOP = (1U << 6);  ///< nRST_STOP User option bytes
        constexpr uint32_t nRST_STDBY = (1U << 7);  ///< nRST_STDBY User option bytes
        constexpr uint32_t RDP = (8 << 8);  ///< Read protect
        constexpr uint32_t nWRP = (5 << 16);  ///< Not write protect
        constexpr uint32_t SPRMOD = (1U << 31);  ///< SPRMOD
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - power control register
        volatile uint32_t CSR;  ///< Offset: 0x04 - power control/status register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t VOS = (2 << 14);  ///< Regulator voltage scaling output selection
        constexpr uint32_t ADCDC1 = (1U << 13);  ///< ADCDC1
        constexpr uint32_t FPDS = (1U << 9);  ///< Flash power down in Stop mode
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t PLS = (3 << 5);  ///< PVD level selection
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t CSBF = (1U << 3);  ///< Clear standby flag
        constexpr uint32_t CWUF = (1U << 2);  ///< Clear wakeup flag
        constexpr uint32_t PDDS = (1U << 1);  ///< Power down deepsleep
        constexpr uint32_t LPDS = (1U << 0);  ///< Low-power deep sleep
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t WUF = (1U << 0);  ///< Wakeup flag
        constexpr uint32_t SBF = (1U << 1);  ///< Standby flag
        constexpr uint32_t PVDO = (1U << 2);  ///< PVD output
        constexpr uint32_t BRR = (1U << 3);  ///< Backup regulator ready
        constexpr uint32_t EWUP3 = (1U << 6);  ///< Enable WKUP3 pin
        constexpr uint32_t EWUP2 = (1U << 7);  ///< Enable WKUP2 pin
        constexpr uint32_t EWUP1 = (1U << 8);  ///< Enable WKUP1 pin
        constexpr uint32_t BRE = (1U << 9);  ///< Backup regulator enable
        constexpr uint32_t VOSRDY = (1U << 14);  ///< Regulator voltage scaling output selection ready bit
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40023800;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - clock control register
        volatile uint32_t PLLCFGR;  ///< Offset: 0x04 - PLL configuration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - clock configuration register
        volatile uint32_t CIR;  ///< Offset: 0x0C - clock interrupt register
        volatile uint32_t AHB1RSTR;  ///< Offset: 0x10 - AHB1 peripheral reset register
        volatile uint32_t APB1RSTR;  ///< Offset: 0x20 - APB1 peripheral reset register
        volatile uint32_t APB2RSTR;  ///< Offset: 0x24 - APB2 peripheral reset register
        volatile uint32_t AHB1ENR;  ///< Offset: 0x30 - AHB1 peripheral clock register
        volatile uint32_t APB1ENR;  ///< Offset: 0x40 - APB1 peripheral clock enable register
        volatile uint32_t APB2ENR;  ///< Offset: 0x44 - APB2 peripheral clock enable register
        volatile uint32_t AHB1LPENR;  ///< Offset: 0x50 - AHB1 peripheral clock enable in low power mode register
        volatile uint32_t APB1LPENR;  ///< Offset: 0x60 - APB1 peripheral clock enable in low power mode register
        volatile uint32_t APB2LPENR;  ///< Offset: 0x64 - APB2 peripheral clock enabled in low power mode register
        volatile uint32_t BDCR;  ///< Offset: 0x70 - Backup domain control register
        volatile uint32_t CSR;  ///< Offset: 0x74 - clock control & status register
        volatile uint32_t SSCGR;  ///< Offset: 0x80 - spread spectrum clock generation register
        volatile uint32_t DCKCFGR;  ///< Offset: 0x8C - DCKCFGR register
        volatile uint32_t DCKCFGR2;  ///< Offset: 0x94 - DCKCFGR2 register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PLLRDY = (1U << 25);  ///< Main PLL (PLL) clock ready flag
        constexpr uint32_t PLLON = (1U << 24);  ///< Main PLL (PLL) enable
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE clock bypass
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSICAL = (8 << 8);  ///< Internal high-speed clock calibration
        constexpr uint32_t HSITRIM = (5 << 3);  ///< Internal high-speed clock trimming
        constexpr uint32_t HSIRDY = (1U << 1);  ///< Internal high-speed clock ready flag
        constexpr uint32_t HSION = (1U << 0);  ///< Internal high-speed clock enable
    }

    /// PLLCFGR Register bits
    namespace pllcfgr_bits {
        constexpr uint32_t PLLM0 = (1U << 0);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM1 = (1U << 1);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM2 = (1U << 2);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM3 = (1U << 3);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM4 = (1U << 4);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM5 = (1U << 5);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLN0 = (1U << 6);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN1 = (1U << 7);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN2 = (1U << 8);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN3 = (1U << 9);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN4 = (1U << 10);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN5 = (1U << 11);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN6 = (1U << 12);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN7 = (1U << 13);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN8 = (1U << 14);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLP0 = (1U << 16);  ///< Main PLL (PLL) division factor for main system clock
        constexpr uint32_t PLLP1 = (1U << 17);  ///< Main PLL (PLL) division factor for main system clock
        constexpr uint32_t PLLSRC = (1U << 22);  ///< Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
        constexpr uint32_t PLLQ0 = (1U << 24);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLQ1 = (1U << 25);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLQ2 = (1U << 26);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLQ3 = (1U << 27);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLR1 = (1U << 28);  ///< PLLR1
        constexpr uint32_t PLLR2 = (1U << 29);  ///< PLLR2
        constexpr uint32_t PLLR3 = (1U << 30);  ///< PLLR3
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SW0 = (1U << 0);  ///< System clock switch
        constexpr uint32_t SW1 = (1U << 1);  ///< System clock switch
        constexpr uint32_t SWS0 = (1U << 2);  ///< System clock switch status
        constexpr uint32_t SWS1 = (1U << 3);  ///< System clock switch status
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler
        constexpr uint32_t MCO1EN = (1U << 8);  ///< MCO output enable
        constexpr uint32_t MCO2EN = (1U << 9);  ///< MCO output enable
        constexpr uint32_t PPRE1 = (3 << 10);  ///< APB Low speed prescaler (APB1)
        constexpr uint32_t PPRE2 = (3 << 13);  ///< APB high-speed prescaler (APB2)
        constexpr uint32_t RTCPRE = (5 << 16);  ///< HSE division factor for RTC clock
        constexpr uint32_t MCO1 = (2 << 21);  ///< Microcontroller clock output 1
        constexpr uint32_t MCO1PRE = (3 << 24);  ///< MCO1 prescaler
        constexpr uint32_t MCO2PRE = (3 << 27);  ///< MCO2 prescaler
        constexpr uint32_t MCO2 = (2 << 30);  ///< Microcontroller clock output 2
    }

    /// CIR Register bits
    namespace cir_bits {
        constexpr uint32_t CSSC = (1U << 23);  ///< Clock security system interrupt clear
        constexpr uint32_t PLLI2SRDYC = (1U << 21);  ///< PLLI2S ready interrupt clear
        constexpr uint32_t PLLRDYC = (1U << 20);  ///< Main PLL(PLL) ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 19);  ///< HSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 18);  ///< HSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 17);  ///< LSE ready interrupt clear
        constexpr uint32_t LSIRDYC = (1U << 16);  ///< LSI ready interrupt clear
        constexpr uint32_t PLLRDYIE = (1U << 12);  ///< Main PLL (PLL) ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 11);  ///< HSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 10);  ///< HSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 9);  ///< LSE ready interrupt enable
        constexpr uint32_t LSIRDYIE = (1U << 8);  ///< LSI ready interrupt enable
        constexpr uint32_t CSSF = (1U << 7);  ///< Clock security system interrupt flag
        constexpr uint32_t PLLRDYF = (1U << 4);  ///< Main PLL (PLL) ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 3);  ///< HSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 2);  ///< HSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
    }

    /// AHB1RSTR Register bits
    namespace ahb1rstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< IO port A reset
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< IO port B reset
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< IO port C reset
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< IO port H reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
        constexpr uint32_t DMA1RST = (1U << 21);  ///< DMA2 reset
        constexpr uint32_t DMA2RST = (1U << 22);  ///< DMA2 reset
        constexpr uint32_t RNGRST = (1U << 31);  ///< RNGRST
    }

    /// APB1RSTR Register bits
    namespace apb1rstr_bits {
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 reset
        constexpr uint32_t LPTIM1RST = (1U << 9);  ///< LPTIM1 reset
        constexpr uint32_t WWDGRST = (1U << 11);  ///< Window watchdog reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI 2 reset
        constexpr uint32_t UART2RST = (1U << 17);  ///< USART 2 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C 1 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C 2 reset
        constexpr uint32_t I2C4RST = (1U << 24);  ///< I2C4 reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t DACRST = (1U << 29);  ///< DAC reset
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t TIM11RST = (1U << 18);  ///< TIM11 reset
        constexpr uint32_t TIM9RST = (1U << 16);  ///< TIM9 reset
        constexpr uint32_t SYSCFGRST = (1U << 14);  ///< System configuration controller reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI 1 reset
        constexpr uint32_t ADCRST = (1U << 8);  ///< ADC interface reset (common to all ADCs)
        constexpr uint32_t USART6RST = (1U << 5);  ///< USART6 reset
        constexpr uint32_t USART1RST = (1U << 4);  ///< USART1 reset
        constexpr uint32_t TIM1RST = (1U << 0);  ///< TIM1 reset
    }

    /// AHB1ENR Register bits
    namespace ahb1enr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< IO port A clock enable
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< IO port B clock enable
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< IO port C clock enable
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< IO port H clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
        constexpr uint32_t DMA1EN = (1U << 21);  ///< DMA1 clock enable
        constexpr uint32_t DMA2EN = (1U << 22);  ///< DMA2 clock enable
        constexpr uint32_t RNGEN = (1U << 31);  ///< RNG clock enable
    }

    /// APB1ENR Register bits
    namespace apb1enr_bits {
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 clock enable
        constexpr uint32_t LPTIM1EN = (1U << 9);  ///< LPTIM1 clock enable
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART 2 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t I2C4EN = (1U << 24);  ///< I2C4 clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t DACEN = (1U << 29);  ///< DAC interface clock enable
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 0);  ///< TIM1 clock enable
        constexpr uint32_t USART1EN = (1U << 4);  ///< USART1 clock enable
        constexpr uint32_t USART6EN = (1U << 5);  ///< USART6 clock enable
        constexpr uint32_t ADC1EN = (1U << 8);  ///< ADC1 clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t SYSCFGEN = (1U << 14);  ///< System configuration controller clock enable
        constexpr uint32_t EXTITEN = (1U << 15);  ///< EXTI ans external IT clock enable
        constexpr uint32_t TIM9EN = (1U << 16);  ///< TIM9 clock enable
        constexpr uint32_t TIM11EN = (1U << 18);  ///< TIM11 clock enable
        constexpr uint32_t SPI5EN = (1U << 20);  ///< SPI5 clock enable
    }

    /// AHB1LPENR Register bits
    namespace ahb1lpenr_bits {
        constexpr uint32_t GPIOALPEN = (1U << 0);  ///< IO port A clock enable during sleep mode
        constexpr uint32_t GPIOBLPEN = (1U << 1);  ///< IO port B clock enable during Sleep mode
        constexpr uint32_t GPIOCLPEN = (1U << 2);  ///< IO port C clock enable during Sleep mode
        constexpr uint32_t GPIOHLPEN = (1U << 7);  ///< IO port H clock enable during Sleep mode
        constexpr uint32_t CRCLPEN = (1U << 12);  ///< CRC clock enable during Sleep mode
        constexpr uint32_t FLITFLPEN = (1U << 15);  ///< Flash interface clock enable during Sleep mode
        constexpr uint32_t SRAM1LPEN = (1U << 16);  ///< SRAM 1interface clock enable during Sleep mode
        constexpr uint32_t DMA1LPEN = (1U << 21);  ///< DMA1 clock enable during Sleep mode
        constexpr uint32_t DMA2LPEN = (1U << 22);  ///< DMA2 clock enable during Sleep mode
        constexpr uint32_t RNGLPEN = (1U << 31);  ///< RNG clock enable during sleep mode
    }

    /// APB1LPENR Register bits
    namespace apb1lpenr_bits {
        constexpr uint32_t TIM5LPEN = (1U << 3);  ///< TIM5 clock enable during Sleep mode
        constexpr uint32_t TIM6LPEN = (1U << 4);  ///< TIM6 clock enable during Sleep mode
        constexpr uint32_t LPTIM1LPEN = (1U << 9);  ///< LPTIM1 clock enable during sleep mode
        constexpr uint32_t RTCAPBLPEN = (1U << 10);  ///< RTC APB clock enable during sleep mode
        constexpr uint32_t WWDGLPEN = (1U << 11);  ///< Window watchdog clock enable during Sleep mode
        constexpr uint32_t SPI2LPEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode
        constexpr uint32_t USART2LPEN = (1U << 17);  ///< USART2 clock enable during Sleep mode
        constexpr uint32_t I2C1LPEN = (1U << 21);  ///< I2C1 clock enable during Sleep mode
        constexpr uint32_t I2C2LPEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode
        constexpr uint32_t I2C4LPEN = (1U << 24);  ///< I2C4 clock enable during Sleep mode
        constexpr uint32_t PWRLPEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
        constexpr uint32_t DACLPEN = (1U << 29);  ///< DAC interface clock enable during sleep mode
    }

    /// APB2LPENR Register bits
    namespace apb2lpenr_bits {
        constexpr uint32_t TIM1LPEN = (1U << 0);  ///< TIM1 clock enable during Sleep mode
        constexpr uint32_t USART1LPEN = (1U << 4);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t USART6LPEN = (1U << 5);  ///< USART6 clock enable during Sleep mode
        constexpr uint32_t ADC1LPEN = (1U << 8);  ///< ADC1 clock enable during Sleep mode
        constexpr uint32_t SDIOLPEN = (1U << 11);  ///< SDIO clock enable during Sleep mode
        constexpr uint32_t SPI1LPEN = (1U << 12);  ///< SPI 1 clock enable during Sleep mode
        constexpr uint32_t SYSCFGLPEN = (1U << 14);  ///< System configuration controller clock enable during Sleep mode
        constexpr uint32_t EXTITLPEN = (1U << 15);  ///< EXTI and External IT clock enable during sleep mode
        constexpr uint32_t TIM9LPEN = (1U << 16);  ///< TIM9 clock enable during sleep mode
        constexpr uint32_t TIM11LPEN = (1U << 18);  ///< TIM11 clock enable during Sleep mode
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t RTCSEL1 = (1U << 9);  ///< RTC clock source selection
        constexpr uint32_t RTCSEL0 = (1U << 8);  ///< RTC clock source selection
        constexpr uint32_t LSEBYP = (1U << 2);  ///< External low-speed oscillator bypass
        constexpr uint32_t LSERDY = (1U << 1);  ///< External low-speed oscillator ready
        constexpr uint32_t LSEON = (1U << 0);  ///< External low-speed oscillator enable
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t WDGRSTF = (1U << 29);  ///< Independent watchdog reset flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t PORRSTF = (1U << 27);  ///< POR/PDR reset flag
        constexpr uint32_t PADRSTF = (1U << 26);  ///< PIN reset flag
        constexpr uint32_t BORRSTF = (1U << 25);  ///< BOR reset flag
        constexpr uint32_t RMVF = (1U << 24);  ///< Remove reset flag
        constexpr uint32_t LSIRDY = (1U << 1);  ///< Internal low-speed oscillator ready
        constexpr uint32_t LSION = (1U << 0);  ///< Internal low-speed oscillator enable
    }

    /// SSCGR Register bits
    namespace sscgr_bits {
        constexpr uint32_t SSCGEN = (1U << 31);  ///< Spread spectrum modulation enable
        constexpr uint32_t SPREADSEL = (1U << 30);  ///< Spread Select
        constexpr uint32_t INCSTEP = (15 << 13);  ///< Incrementation step
        constexpr uint32_t MODPER = (13 << 0);  ///< Modulation period
    }

    /// DCKCFGR Register bits
    namespace dckcfgr_bits {
        constexpr uint32_t TIMPRE = (1U << 24);  ///< TIMPRE
        constexpr uint32_t I2SSRC = (2 << 25);  ///< I2SSRC
    }

    /// DCKCFGR2 Register bits
    namespace dckcfgr2_bits {
        constexpr uint32_t I2C4SEL = (2 << 22);  ///< I2C4SEL
        constexpr uint32_t LPTIM1SEL = (2 << 30);  ///< LPTIM1SEL
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t ISR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CALIBR;  ///< Offset: 0x18 - calibration register
        volatile uint32_t ALRMAR;  ///< Offset: 0x1C - alarm A register
        volatile uint32_t ALRMBR;  ///< Offset: 0x20 - alarm B register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t SSR;  ///< Offset: 0x28 - sub second register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t CALR;  ///< Offset: 0x3C - calibration register
        volatile uint32_t TAFCR;  ///< Offset: 0x40 - tamper and alternate function configuration register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x48 - alarm B sub second register
        volatile uint32_t BKP0R;  ///< Offset: 0x50 - backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x54 - backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x58 - backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x5C - backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x60 - backup register
        volatile uint32_t BKP5R;  ///< Offset: 0x64 - backup register
        volatile uint32_t BKP6R;  ///< Offset: 0x68 - backup register
        volatile uint32_t BKP7R;  ///< Offset: 0x6C - backup register
        volatile uint32_t BKP8R;  ///< Offset: 0x70 - backup register
        volatile uint32_t BKP9R;  ///< Offset: 0x74 - backup register
        volatile uint32_t BKP10R;  ///< Offset: 0x78 - backup register
        volatile uint32_t BKP11R;  ///< Offset: 0x7C - backup register
        volatile uint32_t BKP12R;  ///< Offset: 0x80 - backup register
        volatile uint32_t BKP13R;  ///< Offset: 0x84 - backup register
        volatile uint32_t BKP14R;  ///< Offset: 0x88 - backup register
        volatile uint32_t BKP15R;  ///< Offset: 0x8C - backup register
        volatile uint32_t BKP16R;  ///< Offset: 0x90 - backup register
        volatile uint32_t BKP17R;  ///< Offset: 0x94 - backup register
        volatile uint32_t BKP18R;  ///< Offset: 0x98 - backup register
        volatile uint32_t BKP19R;  ///< Offset: 0x9C - backup register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration Output selection
        constexpr uint32_t BKP = (1U << 18);  ///< Backup
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change)
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change)
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t TSE = (1U << 11);  ///< Time stamp enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t DCE = (1U << 7);  ///< Coarse digital calibration enable
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers
        constexpr uint32_t REFCKON = (1U << 4);  ///< Reference clock detection enable (50 or 60 Hz)
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge
        constexpr uint32_t WCKSEL = (3 << 0);  ///< Wakeup clock selection
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t ALRAF = (1U << 8);  ///< Alarm A flag
        constexpr uint32_t ALRBF = (1U << 9);  ///< Alarm B flag
        constexpr uint32_t WUTF = (1U << 10);  ///< Wakeup timer flag
        constexpr uint32_t TSF = (1U << 11);  ///< Time-stamp flag
        constexpr uint32_t TSOVF = (1U << 12);  ///< Time-stamp overflow flag
        constexpr uint32_t TAMP1F = (1U << 13);  ///< Tamper detection flag
        constexpr uint32_t TAMP2F = (1U << 14);  ///< TAMPER2 detection flag
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// CALIBR Register bits
    namespace calibr_bits {
        constexpr uint32_t DCS = (1U << 7);  ///< Digital calibration sign
        constexpr uint32_t DC = (5 << 0);  ///< Digital calibration
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// TAFCR Register bits
    namespace tafcr_bits {
        constexpr uint32_t ALARMOUTTYPE = (1U << 18);  ///< AFO_ALARM output type
        constexpr uint32_t TSINSEL = (1U << 17);  ///< TIMESTAMP mapping
        constexpr uint32_t TAMP1INSEL = (1U << 16);  ///< TAMPER1 mapping
        constexpr uint32_t TAMPPUDIS = (1U << 15);  ///< TAMPER pull-up disable
        constexpr uint32_t TAMPPRCH = (2 << 13);  ///< Tamper precharge duration
        constexpr uint32_t TAMPFLT = (2 << 11);  ///< Tamper filter count
        constexpr uint32_t TAMPFREQ = (3 << 8);  ///< Tamper sampling frequency
        constexpr uint32_t TAMPTS = (1U << 7);  ///< Activate timestamp on tamper detection event
        constexpr uint32_t TAMP2TRG = (1U << 4);  ///< Active level for tamper 2
        constexpr uint32_t TAMP2E = (1U << 3);  ///< Tamper 2 detection enable
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP1TRG = (1U << 1);  ///< Active level for tamper 1
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper 1 detection enable
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP5R Register bits
    namespace bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP6R Register bits
    namespace bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP7R Register bits
    namespace bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP8R Register bits
    namespace bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP9R Register bits
    namespace bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP10R Register bits
    namespace bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP11R Register bits
    namespace bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP12R Register bits
    namespace bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP13R Register bits
    namespace bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP14R Register bits
    namespace bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP15R Register bits
    namespace bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP16R Register bits
    namespace bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP17R Register bits
    namespace bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP18R Register bits
    namespace bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP19R Register bits
    namespace bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40013800;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t MEMRM;  ///< Offset: 0x00 - memory remap register
        volatile uint32_t PMC;  ///< Offset: 0x04 - peripheral mode configuration register
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
        volatile uint32_t CMPCR;  ///< Offset: 0x20 - Compensation cell control register
        volatile uint32_t CFGR;  ///< Offset: 0x2C - Configuration register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// MEMRM Register bits
    namespace memrm_bits {
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< MEM_MODE
    }

    /// PMC Register bits
    namespace pmc_bits {
        constexpr uint32_t ADC1DC2 = (1U << 16);  ///< ADC1DC2
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI x configuration (x = 0 to 3)
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI x configuration (x = 4 to 7)
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI10
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI x configuration (x = 8 to 11)
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI x configuration (x = 12 to 15)
    }

    /// CMPCR Register bits
    namespace cmpcr_bits {
        constexpr uint32_t READY = (1U << 8);  ///< READY
        constexpr uint32_t CMP_PD = (1U << 0);  ///< Compensation cell power-down
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t FMPI2C1_SCL = (1U << 0);  ///< FMPI2C1_SCL
        constexpr uint32_t FMPI2C1_SDA = (1U << 1);  ///< FMPI2C1_SDA
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM1_BASE = 0x40010000;
    constexpr uint32_t TIM8_BASE = 0x40010400;
    constexpr uint32_t TIM11_BASE = 0x40014800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t TIM9_BASE = 0x40014000;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t LPTIM1_BASE = 0x40002400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SMCR;  ///< Offset: 0x08 - slave mode control register
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register 1 (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCMR2_Output;  ///< Offset: 0x1C - capture/compare mode register 2 (output mode)
        volatile uint32_t CCMR2_Input;  ///< Offset: 0x1C - capture/compare mode register 2 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t CCR2;  ///< Offset: 0x38 - capture/compare register 2
        volatile uint32_t CCR3;  ///< Offset: 0x3C - capture/compare register 3
        volatile uint32_t CCR4;  ///< Offset: 0x40 - capture/compare register 4
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
    };

    /// Peripheral instances
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* TIM11 = reinterpret_cast<Registers*>(TIM11_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* TIM9 = reinterpret_cast<Registers*>(TIM9_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CMS = (2 << 5);  ///< Center-aligned mode selection
        constexpr uint32_t DIR = (1U << 4);  ///< Direction
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS4 = (1U << 14);  ///< Output Idle state 4
        constexpr uint32_t OIS3N = (1U << 13);  ///< Output Idle state 3
        constexpr uint32_t OIS3 = (1U << 12);  ///< Output Idle state 3
        constexpr uint32_t OIS2N = (1U << 11);  ///< Output Idle state 2
        constexpr uint32_t OIS2 = (1U << 10);  ///< Output Idle state 2
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1 selection
        constexpr uint32_t MMS = (3 << 4);  ///< Master mode selection
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// SMCR Register bits
    namespace smcr_bits {
        constexpr uint32_t ETP = (1U << 15);  ///< External trigger polarity
        constexpr uint32_t ECE = (1U << 14);  ///< External clock enable
        constexpr uint32_t ETPS = (2 << 12);  ///< External trigger prescaler
        constexpr uint32_t ETF = (4 << 8);  ///< External trigger filter
        constexpr uint32_t MSM = (1U << 7);  ///< Master/Slave mode
        constexpr uint32_t TS = (3 << 4);  ///< Trigger selection
        constexpr uint32_t SMS = (3 << 0);  ///< Slave mode selection
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t TDE = (1U << 14);  ///< Trigger DMA request enable
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t CC4DE = (1U << 12);  ///< Capture/Compare 4 DMA request enable
        constexpr uint32_t CC3DE = (1U << 11);  ///< Capture/Compare 3 DMA request enable
        constexpr uint32_t CC2DE = (1U << 10);  ///< Capture/Compare 2 DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t TIE = (1U << 6);  ///< Trigger interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t CC4IE = (1U << 4);  ///< Capture/Compare 4 interrupt enable
        constexpr uint32_t CC3IE = (1U << 3);  ///< Capture/Compare 3 interrupt enable
        constexpr uint32_t CC2IE = (1U << 2);  ///< Capture/Compare 2 interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC4OF = (1U << 12);  ///< Capture/Compare 4 overcapture flag
        constexpr uint32_t CC3OF = (1U << 11);  ///< Capture/Compare 3 overcapture flag
        constexpr uint32_t CC2OF = (1U << 10);  ///< Capture/compare 2 overcapture flag
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t TIF = (1U << 6);  ///< Trigger interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC4IF = (1U << 4);  ///< Capture/Compare 4 interrupt flag
        constexpr uint32_t CC3IF = (1U << 3);  ///< Capture/Compare 3 interrupt flag
        constexpr uint32_t CC2IF = (1U << 2);  ///< Capture/Compare 2 interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t TG = (1U << 6);  ///< Trigger generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC4G = (1U << 4);  ///< Capture/compare 4 generation
        constexpr uint32_t CC3G = (1U << 3);  ///< Capture/compare 3 generation
        constexpr uint32_t CC2G = (1U << 2);  ///< Capture/compare 2 generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC2CE = (1U << 15);  ///< Output Compare 2 clear enable
        constexpr uint32_t OC2M = (3 << 12);  ///< Output Compare 2 mode
        constexpr uint32_t OC2PE = (1U << 11);  ///< Output Compare 2 preload enable
        constexpr uint32_t OC2FE = (1U << 10);  ///< Output Compare 2 fast enable
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection
        constexpr uint32_t OC1CE = (1U << 7);  ///< Output Compare 1 clear enable
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC2F = (4 << 12);  ///< Input capture 2 filter
        constexpr uint32_t IC2PCS = (2 << 10);  ///< Input capture 2 prescaler
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t ICPCS = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR2_Output Register bits
    namespace ccmr2_output_bits {
        constexpr uint32_t OC4CE = (1U << 15);  ///< Output compare 4 clear enable
        constexpr uint32_t OC4M = (3 << 12);  ///< Output compare 4 mode
        constexpr uint32_t OC4PE = (1U << 11);  ///< Output compare 4 preload enable
        constexpr uint32_t OC4FE = (1U << 10);  ///< Output compare 4 fast enable
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection
        constexpr uint32_t OC3CE = (1U << 7);  ///< Output compare 3 clear enable
        constexpr uint32_t OC3M = (3 << 4);  ///< Output compare 3 mode
        constexpr uint32_t OC3PE = (1U << 3);  ///< Output compare 3 preload enable
        constexpr uint32_t OC3FE = (1U << 2);  ///< Output compare 3 fast enable
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/Compare 3 selection
    }

    /// CCMR2_Input Register bits
    namespace ccmr2_input_bits {
        constexpr uint32_t IC4F = (4 << 12);  ///< Input capture 4 filter
        constexpr uint32_t IC4PSC = (2 << 10);  ///< Input capture 4 prescaler
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection
        constexpr uint32_t IC3F = (4 << 4);  ///< Input capture 3 filter
        constexpr uint32_t IC3PSC = (2 << 2);  ///< Input capture 3 prescaler
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/compare 3 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC4P = (1U << 13);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC4E = (1U << 12);  ///< Capture/Compare 4 output enable
        constexpr uint32_t CC3NP = (1U << 11);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC3NE = (1U << 10);  ///< Capture/Compare 3 complementary output enable
        constexpr uint32_t CC3P = (1U << 9);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC3E = (1U << 8);  ///< Capture/Compare 3 output enable
        constexpr uint32_t CC2NP = (1U << 7);  ///< Capture/Compare 2 output Polarity
        constexpr uint32_t CC2NE = (1U << 6);  ///< Capture/Compare 2 complementary output enable
        constexpr uint32_t CC2P = (1U << 5);  ///< Capture/Compare 2 output Polarity
        constexpr uint32_t CC2E = (1U << 4);  ///< Capture/Compare 2 output enable
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/Compare 2 value
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t CCR3 = (16 << 0);  ///< Capture/Compare value
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t CCR4 = (16 << 0);  ///< Capture/Compare value
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (16 << 0);  ///< DMA register for burst accesses
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40011000;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART6_BASE = 0x40011400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Status register
        volatile uint32_t DR;  ///< Offset: 0x04 - Data register
        volatile uint32_t BRR;  ///< Offset: 0x08 - Baud rate register
        volatile uint32_t CR1;  ///< Offset: 0x0C - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x10 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x14 - Control register 3
        volatile uint32_t GTPR;  ///< Offset: 0x18 - Guard time and prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART6 = reinterpret_cast<Registers*>(USART6_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CTS = (1U << 9);  ///< CTS flag
        constexpr uint32_t LBD = (1U << 8);  ///< LIN break detection flag
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE line detected
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error
        constexpr uint32_t NF = (1U << 2);  ///< Noise detected flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing error
        constexpr uint32_t PE = (1U << 0);  ///< Parity error
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (9 << 0);  ///< Data value
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t DIV_Mantissa = (12 << 4);  ///< mantissa of USARTDIV
        constexpr uint32_t DIV_Fraction = (4 << 0);  ///< fraction of USARTDIV
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t UE = (1U << 13);  ///< USART enable
        constexpr uint32_t M = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< TXE interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver wakeup
        constexpr uint32_t SBK = (1U << 0);  ///< Send break
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< lin break detection length
        constexpr uint32_t ADD = (4 << 0);  ///< Address of the USART node
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< IrDA low-power
        constexpr uint32_t IREN = (1U << 1);  ///< IrDA mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA2_BASE = 0x40026400;
    constexpr uint32_t DMA1_BASE = 0x40026000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t LISR;  ///< Offset: 0x00 - low interrupt status register
        volatile uint32_t HISR;  ///< Offset: 0x04 - high interrupt status register
        volatile uint32_t LIFCR;  ///< Offset: 0x08 - low interrupt flag clear register
        volatile uint32_t HIFCR;  ///< Offset: 0x0C - high interrupt flag clear register
        volatile uint32_t S0CR;  ///< Offset: 0x10 - stream x configuration register
        volatile uint32_t S0NDTR;  ///< Offset: 0x14 - stream x number of data register
        volatile uint32_t S0PAR;  ///< Offset: 0x18 - stream x peripheral address register
        volatile uint32_t S0M0AR;  ///< Offset: 0x1C - stream x memory 0 address register
        volatile uint32_t S0M1AR;  ///< Offset: 0x20 - stream x memory 1 address register
        volatile uint32_t S0FCR;  ///< Offset: 0x24 - stream x FIFO control register
        volatile uint32_t S1CR;  ///< Offset: 0x28 - stream x configuration register
        volatile uint32_t S1NDTR;  ///< Offset: 0x2C - stream x number of data register
        volatile uint32_t S1PAR;  ///< Offset: 0x30 - stream x peripheral address register
        volatile uint32_t S1M0AR;  ///< Offset: 0x34 - stream x memory 0 address register
        volatile uint32_t S1M1AR;  ///< Offset: 0x38 - stream x memory 1 address register
        volatile uint32_t S1FCR;  ///< Offset: 0x3C - stream x FIFO control register
        volatile uint32_t S2CR;  ///< Offset: 0x40 - stream x configuration register
        volatile uint32_t S2NDTR;  ///< Offset: 0x44 - stream x number of data register
        volatile uint32_t S2PAR;  ///< Offset: 0x48 - stream x peripheral address register
        volatile uint32_t S2M0AR;  ///< Offset: 0x4C - stream x memory 0 address register
        volatile uint32_t S2M1AR;  ///< Offset: 0x50 - stream x memory 1 address register
        volatile uint32_t S2FCR;  ///< Offset: 0x54 - stream x FIFO control register
        volatile uint32_t S3CR;  ///< Offset: 0x58 - stream x configuration register
        volatile uint32_t S3NDTR;  ///< Offset: 0x5C - stream x number of data register
        volatile uint32_t S3PAR;  ///< Offset: 0x60 - stream x peripheral address register
        volatile uint32_t S3M0AR;  ///< Offset: 0x64 - stream x memory 0 address register
        volatile uint32_t S3M1AR;  ///< Offset: 0x68 - stream x memory 1 address register
        volatile uint32_t S3FCR;  ///< Offset: 0x6C - stream x FIFO control register
        volatile uint32_t S4CR;  ///< Offset: 0x70 - stream x configuration register
        volatile uint32_t S4NDTR;  ///< Offset: 0x74 - stream x number of data register
        volatile uint32_t S4PAR;  ///< Offset: 0x78 - stream x peripheral address register
        volatile uint32_t S4M0AR;  ///< Offset: 0x7C - stream x memory 0 address register
        volatile uint32_t S4M1AR;  ///< Offset: 0x80 - stream x memory 1 address register
        volatile uint32_t S4FCR;  ///< Offset: 0x84 - stream x FIFO control register
        volatile uint32_t S5CR;  ///< Offset: 0x88 - stream x configuration register
        volatile uint32_t S5NDTR;  ///< Offset: 0x8C - stream x number of data register
        volatile uint32_t S5PAR;  ///< Offset: 0x90 - stream x peripheral address register
        volatile uint32_t S5M0AR;  ///< Offset: 0x94 - stream x memory 0 address register
        volatile uint32_t S5M1AR;  ///< Offset: 0x98 - stream x memory 1 address register
        volatile uint32_t S5FCR;  ///< Offset: 0x9C - stream x FIFO control register
        volatile uint32_t S6CR;  ///< Offset: 0xA0 - stream x configuration register
        volatile uint32_t S6NDTR;  ///< Offset: 0xA4 - stream x number of data register
        volatile uint32_t S6PAR;  ///< Offset: 0xA8 - stream x peripheral address register
        volatile uint32_t S6M0AR;  ///< Offset: 0xAC - stream x memory 0 address register
        volatile uint32_t S6M1AR;  ///< Offset: 0xB0 - stream x memory 1 address register
        volatile uint32_t S6FCR;  ///< Offset: 0xB4 - stream x FIFO control register
        volatile uint32_t S7CR;  ///< Offset: 0xB8 - stream x configuration register
        volatile uint32_t S7NDTR;  ///< Offset: 0xBC - stream x number of data register
        volatile uint32_t S7PAR;  ///< Offset: 0xC0 - stream x peripheral address register
        volatile uint32_t S7M0AR;  ///< Offset: 0xC4 - stream x memory 0 address register
        volatile uint32_t S7M1AR;  ///< Offset: 0xC8 - stream x memory 1 address register
        volatile uint32_t S7FCR;  ///< Offset: 0xCC - stream x FIFO control register
    };

    /// Peripheral instances
    inline Registers* DMA2 = reinterpret_cast<Registers*>(DMA2_BASE);
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);

    // Bit definitions
    /// LISR Register bits
    namespace lisr_bits {
        constexpr uint32_t TCIF3 = (1U << 27);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF3 = (1U << 26);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF3 = (1U << 25);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF3 = (1U << 24);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF3 = (1U << 22);  ///< Stream x FIFO error interrupt flag (x=3..0)
        constexpr uint32_t TCIF2 = (1U << 21);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF2 = (1U << 20);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF2 = (1U << 19);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF2 = (1U << 18);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF2 = (1U << 16);  ///< Stream x FIFO error interrupt flag (x=3..0)
        constexpr uint32_t TCIF1 = (1U << 11);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF1 = (1U << 10);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF1 = (1U << 9);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF1 = (1U << 8);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF1 = (1U << 6);  ///< Stream x FIFO error interrupt flag (x=3..0)
        constexpr uint32_t TCIF0 = (1U << 5);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF0 = (1U << 4);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF0 = (1U << 3);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF0 = (1U << 2);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF0 = (1U << 0);  ///< Stream x FIFO error interrupt flag (x=3..0)
    }

    /// HISR Register bits
    namespace hisr_bits {
        constexpr uint32_t TCIF7 = (1U << 27);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF7 = (1U << 26);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF7 = (1U << 25);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF7 = (1U << 24);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF7 = (1U << 22);  ///< Stream x FIFO error interrupt flag (x=7..4)
        constexpr uint32_t TCIF6 = (1U << 21);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF6 = (1U << 20);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF6 = (1U << 19);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF6 = (1U << 18);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF6 = (1U << 16);  ///< Stream x FIFO error interrupt flag (x=7..4)
        constexpr uint32_t TCIF5 = (1U << 11);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF5 = (1U << 10);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF5 = (1U << 9);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF5 = (1U << 8);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF5 = (1U << 6);  ///< Stream x FIFO error interrupt flag (x=7..4)
        constexpr uint32_t TCIF4 = (1U << 5);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF4 = (1U << 4);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF4 = (1U << 3);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF4 = (1U << 2);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF4 = (1U << 0);  ///< Stream x FIFO error interrupt flag (x=7..4)
    }

    /// LIFCR Register bits
    namespace lifcr_bits {
        constexpr uint32_t CTCIF3 = (1U << 27);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF3 = (1U << 26);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF3 = (1U << 25);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF3 = (1U << 24);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF3 = (1U << 22);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
        constexpr uint32_t CTCIF2 = (1U << 21);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF2 = (1U << 20);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF2 = (1U << 19);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF2 = (1U << 18);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF2 = (1U << 16);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
        constexpr uint32_t CTCIF1 = (1U << 11);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF1 = (1U << 10);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF1 = (1U << 9);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF1 = (1U << 8);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF1 = (1U << 6);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
        constexpr uint32_t CTCIF0 = (1U << 5);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF0 = (1U << 4);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF0 = (1U << 3);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF0 = (1U << 2);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF0 = (1U << 0);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
    }

    /// HIFCR Register bits
    namespace hifcr_bits {
        constexpr uint32_t CTCIF7 = (1U << 27);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF7 = (1U << 25);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF7 = (1U << 24);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF7 = (1U << 22);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF6 = (1U << 20);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF6 = (1U << 19);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF6 = (1U << 18);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF6 = (1U << 16);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
        constexpr uint32_t CTCIF5 = (1U << 11);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF5 = (1U << 10);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF5 = (1U << 9);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF5 = (1U << 8);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF5 = (1U << 6);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
        constexpr uint32_t CTCIF4 = (1U << 5);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF4 = (1U << 4);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF4 = (1U << 3);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF4 = (1U << 2);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF4 = (1U << 0);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
    }

    /// S0CR Register bits
    namespace s0cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S0NDTR Register bits
    namespace s0ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S0PAR Register bits
    namespace s0par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S0M0AR Register bits
    namespace s0m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S0M1AR Register bits
    namespace s0m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S0FCR Register bits
    namespace s0fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S1CR Register bits
    namespace s1cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S1NDTR Register bits
    namespace s1ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S1PAR Register bits
    namespace s1par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S1M0AR Register bits
    namespace s1m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S1M1AR Register bits
    namespace s1m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S1FCR Register bits
    namespace s1fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S2CR Register bits
    namespace s2cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S2NDTR Register bits
    namespace s2ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S2PAR Register bits
    namespace s2par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S2M0AR Register bits
    namespace s2m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S2M1AR Register bits
    namespace s2m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S2FCR Register bits
    namespace s2fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S3CR Register bits
    namespace s3cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S3NDTR Register bits
    namespace s3ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S3PAR Register bits
    namespace s3par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S3M0AR Register bits
    namespace s3m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S3M1AR Register bits
    namespace s3m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S3FCR Register bits
    namespace s3fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S4CR Register bits
    namespace s4cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S4NDTR Register bits
    namespace s4ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S4PAR Register bits
    namespace s4par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S4M0AR Register bits
    namespace s4m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S4M1AR Register bits
    namespace s4m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S4FCR Register bits
    namespace s4fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S5CR Register bits
    namespace s5cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S5NDTR Register bits
    namespace s5ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S5PAR Register bits
    namespace s5par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S5M0AR Register bits
    namespace s5m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S5M1AR Register bits
    namespace s5m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S5FCR Register bits
    namespace s5fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S6CR Register bits
    namespace s6cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S6NDTR Register bits
    namespace s6ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S6PAR Register bits
    namespace s6par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S6M0AR Register bits
    namespace s6m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S6M1AR Register bits
    namespace s6m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S6FCR Register bits
    namespace s6fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S7CR Register bits
    namespace s7cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S7NDTR Register bits
    namespace s7ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S7PAR Register bits
    namespace s7par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S7M0AR Register bits
    namespace s7m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S7M1AR Register bits
    namespace s7m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S7FCR Register bits
    namespace s7fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOH_BASE = 0x40021C00;
    constexpr uint32_t GPIOC_BASE = 0x40020800;
    constexpr uint32_t GPIOB_BASE = 0x40020400;
    constexpr uint32_t GPIOA_BASE = 0x40020000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
    };

    /// Peripheral instances
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFRL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFRH15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C4_BASE = 0x40006000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t DR;  ///< Offset: 0x10 - Data register
        volatile uint32_t SR1;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t SR2;  ///< Offset: 0x18 - Status register 2
        volatile uint32_t CCR;  ///< Offset: 0x1C - Clock control register
        volatile uint32_t TRISE;  ///< Offset: 0x20 - TRISE register
    };

    /// Peripheral instances
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t SWRST = (1U << 15);  ///< Software reset
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t PEC = (1U << 12);  ///< Packet error checking
        constexpr uint32_t POS = (1U << 11);  ///< Acknowledge/PEC Position (for data reception)
        constexpr uint32_t ACK = (1U << 10);  ///< Acknowledge enable
        constexpr uint32_t STOP = (1U << 9);  ///< Stop generation
        constexpr uint32_t START = (1U << 8);  ///< Start generation
        constexpr uint32_t NOSTRETCH = (1U << 7);  ///< Clock stretching disable (Slave mode)
        constexpr uint32_t ENGC = (1U << 6);  ///< General call enable
        constexpr uint32_t ENPEC = (1U << 5);  ///< PEC enable
        constexpr uint32_t ENARP = (1U << 4);  ///< ARP enable
        constexpr uint32_t SMBTYPE = (1U << 3);  ///< SMBus type
        constexpr uint32_t SMBUS = (1U << 1);  ///< SMBus mode
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LAST = (1U << 12);  ///< DMA last transfer
        constexpr uint32_t DMAEN = (1U << 11);  ///< DMA requests enable
        constexpr uint32_t ITBUFEN = (1U << 10);  ///< Buffer interrupt enable
        constexpr uint32_t ITEVTEN = (1U << 9);  ///< Event interrupt enable
        constexpr uint32_t ITERREN = (1U << 8);  ///< Error interrupt enable
        constexpr uint32_t FREQ = (6 << 0);  ///< Peripheral clock frequency
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t ADDMODE = (1U << 15);  ///< Addressing mode (slave mode)
        constexpr uint32_t ADD10 = (2 << 8);  ///< Interface address
        constexpr uint32_t ADD7 = (7 << 1);  ///< Interface address
        constexpr uint32_t ADD0 = (1U << 0);  ///< Interface address
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t ADD2 = (7 << 1);  ///< Interface address
        constexpr uint32_t ENDUAL = (1U << 0);  ///< Dual addressing mode enable
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (8 << 0);  ///< 8-bit data register
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t SMBALERT = (1U << 15);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 14);  ///< Timeout or Tlow error
        constexpr uint32_t PECERR = (1U << 12);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 11);  ///< Overrun/Underrun
        constexpr uint32_t AF = (1U << 10);  ///< Acknowledge failure
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost (master mode)
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TxE = (1U << 7);  ///< Data register empty (transmitters)
        constexpr uint32_t RxNE = (1U << 6);  ///< Data register not empty (receivers)
        constexpr uint32_t STOPF = (1U << 4);  ///< Stop detection (slave mode)
        constexpr uint32_t ADD10 = (1U << 3);  ///< 10-bit header sent (Master mode)
        constexpr uint32_t BTF = (1U << 2);  ///< Byte transfer finished
        constexpr uint32_t ADDR = (1U << 1);  ///< Address sent (master mode)/matched (slave mode)
        constexpr uint32_t SB = (1U << 0);  ///< Start bit (Master mode)
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PEC = (8 << 8);  ///< acket error checking register
        constexpr uint32_t DUALF = (1U << 7);  ///< Dual flag (Slave mode)
        constexpr uint32_t SMBHOST = (1U << 6);  ///< SMBus host header (Slave mode)
        constexpr uint32_t SMBDEFAULT = (1U << 5);  ///< SMBus device default address (Slave mode)
        constexpr uint32_t GENCALL = (1U << 4);  ///< General call address (Slave mode)
        constexpr uint32_t TRA = (1U << 2);  ///< Transmitter/receiver
        constexpr uint32_t BUSY = (1U << 1);  ///< Bus busy
        constexpr uint32_t MSL = (1U << 0);  ///< Master/slave
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t F_S = (1U << 15);  ///< I2C master mode selection
        constexpr uint32_t DUTY = (1U << 14);  ///< Fast mode duty cycle
        constexpr uint32_t CCR = (12 << 0);  ///< Clock control register in Fast/Standard mode (Master mode)
    }

    /// TRISE Register bits
    namespace trise_bits {
        constexpr uint32_t TRISE = (6 << 0);  ///< Maximum rise time in Fast/Standard mode (Master mode)
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SPI5_BASE = 0x40015000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - I2S configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - I2S prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI5 = reinterpret_cast<Registers*>(SPI5_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
        constexpr uint32_t I2SE = (1U << 10);  ///< I2S Enable
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2S standard selection
        constexpr uint32_t CKPOL = (1U << 3);  ///< Steady state clock polarity
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2S Linear prescaler
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;
    constexpr uint32_t NVIC_STIR_BASE = 0xE000EF00;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER0;  ///< Offset: 0x00 - Interrupt Set-Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x04 - Interrupt Set-Enable Register
        volatile uint32_t ISER2;  ///< Offset: 0x08 - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x80 - Interrupt Clear-Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x84 - Interrupt Clear-Enable Register
        volatile uint32_t ICER2;  ///< Offset: 0x88 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x104 - Interrupt Set-Pending Register
        volatile uint32_t ISPR2;  ///< Offset: 0x108 - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x184 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR2;  ///< Offset: 0x188 - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x200 - Interrupt Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x204 - Interrupt Active Bit Register
        volatile uint32_t IABR2;  ///< Offset: 0x208 - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x320 - Interrupt Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x324 - Interrupt Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x328 - Interrupt Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x32C - Interrupt Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x330 - Interrupt Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x334 - Interrupt Priority Register
        volatile uint32_t IPR14;  ///< Offset: 0x338 - Interrupt Priority Register
        volatile uint32_t IPR15;  ///< Offset: 0x33C - Interrupt Priority Register
        volatile uint32_t IPR16;  ///< Offset: 0x340 - Interrupt Priority Register
        volatile uint32_t IPR17;  ///< Offset: 0x344 - Interrupt Priority Register
        volatile uint32_t IPR18;  ///< Offset: 0x348 - Interrupt Priority Register
        volatile uint32_t IPR19;  ///< Offset: 0x34C - Interrupt Priority Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);
    inline Registers* NVIC_STIR = reinterpret_cast<Registers*>(NVIC_STIR_BASE);

    // Bit definitions
    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER2 Register bits
    namespace iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER2 Register bits
    namespace icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR2 Register bits
    namespace ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR2 Register bits
    namespace icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR2 Register bits
    namespace iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR14 Register bits
    namespace ipr14_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR15 Register bits
    namespace ipr15_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR16 Register bits
    namespace ipr16_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR17 Register bits
    namespace ipr17_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR18 Register bits
    namespace ipr18_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR19 Register bits
    namespace ipr19_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40080000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DR;  ///< Offset: 0x08 - data register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t RNGEN = (1U << 2);  ///< Random number generator enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SWTRIGR;  ///< Offset: 0x04 - software trigger register
        volatile uint32_t DHR12R1;  ///< Offset: 0x08 - channel1 12-bit right-aligned data holding register
        volatile uint32_t DHR12L1;  ///< Offset: 0x0C - channel1 12-bit left aligned data holding register
        volatile uint32_t DHR8R1;  ///< Offset: 0x10 - channel1 8-bit right aligned data holding register
        volatile uint32_t DHR12R2;  ///< Offset: 0x14 - channel2 12-bit right aligned data holding register
        volatile uint32_t DHR12L2;  ///< Offset: 0x18 - channel2 12-bit left aligned data holding register
        volatile uint32_t DHR8R2;  ///< Offset: 0x1C - channel2 8-bit right-aligned data holding register
        volatile uint32_t DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DOR1;  ///< Offset: 0x2C - channel1 data output register
        volatile uint32_t DOR2;  ///< Offset: 0x30 - channel2 data output register
        volatile uint32_t SR;  ///< Offset: 0x34 - status register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable
        constexpr uint32_t TSEL2 = (3 << 19);  ///< DAC channel2 trigger selection
        constexpr uint32_t TEN2 = (1U << 18);  ///< DAC channel2 trigger enable
        constexpr uint32_t BOFF2 = (1U << 17);  ///< DAC channel2 output buffer disable
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable
        constexpr uint32_t TSEL1 = (3 << 3);  ///< DAC channel1 trigger selection
        constexpr uint32_t TEN1 = (1U << 2);  ///< DAC channel1 trigger enable
        constexpr uint32_t BOFF1 = (1U << 1);  ///< DAC channel1 output buffer disable
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable
    }

    /// SWTRIGR Register bits
    namespace swtrigr_bits {
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger
    }

    /// DHR12R1 Register bits
    namespace dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
    }

    /// DHR12L1 Register bits
    namespace dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
    }

    /// DHR8R1 Register bits
    namespace dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DHR12R2 Register bits
    namespace dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DHR12L2 Register bits
    namespace dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data
    }

    /// DHR8R2 Register bits
    namespace dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DHR12RD Register bits
    namespace dhr12rd_bits {
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
    }

    /// DHR12LD Register bits
    namespace dhr12ld_bits {
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
    }

    /// DHR8RD Register bits
    namespace dhr8rd_bits {
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DOR1 Register bits
    namespace dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output
    }

    /// DOR2 Register bits
    namespace dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_BASE = 0xE000EF34;
    constexpr uint32_t FPU_CPACR_BASE = 0xE000ED88;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t FPCCR;  ///< Offset: 0x00 - Floating-point context control register
        volatile uint32_t FPCAR;  ///< Offset: 0x04 - Floating-point context address register
        volatile uint32_t FPSCR;  ///< Offset: 0x08 - Floating-point status control register
    };

    /// Peripheral instances
    inline Registers* FPU = reinterpret_cast<Registers*>(FPU_BASE);
    inline Registers* FPU_CPACR = reinterpret_cast<Registers*>(FPU_CPACR_BASE);

    // Bit definitions
    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t LSPACT = (1U << 0);  ///< LSPACT
        constexpr uint32_t USER = (1U << 1);  ///< USER
        constexpr uint32_t THREAD = (1U << 3);  ///< THREAD
        constexpr uint32_t HFRDY = (1U << 4);  ///< HFRDY
        constexpr uint32_t MMRDY = (1U << 5);  ///< MMRDY
        constexpr uint32_t BFRDY = (1U << 6);  ///< BFRDY
        constexpr uint32_t MONRDY = (1U << 8);  ///< MONRDY
        constexpr uint32_t LSPEN = (1U << 30);  ///< LSPEN
        constexpr uint32_t ASPEN = (1U << 31);  ///< ASPEN
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 3);  ///< Location of unpopulated floating-point
    }

    /// FPSCR Register bits
    namespace fpscr_bits {
        constexpr uint32_t IOC = (1U << 0);  ///< Invalid operation cumulative exception bit
        constexpr uint32_t DZC = (1U << 1);  ///< Division by zero cumulative exception bit.
        constexpr uint32_t OFC = (1U << 2);  ///< Overflow cumulative exception bit
        constexpr uint32_t UFC = (1U << 3);  ///< Underflow cumulative exception bit
        constexpr uint32_t IXC = (1U << 4);  ///< Inexact cumulative exception bit
        constexpr uint32_t IDC = (1U << 7);  ///< Input denormal cumulative exception bit.
        constexpr uint32_t RMode = (2 << 22);  ///< Rounding Mode control field
        constexpr uint32_t FZ = (1U << 24);  ///< Flush-to-zero mode control bit:
        constexpr uint32_t DN = (1U << 25);  ///< Default NaN mode control bit
        constexpr uint32_t AHP = (1U << 26);  ///< Alternative half-precision control bit
        constexpr uint32_t V = (1U << 28);  ///< Overflow condition code flag
        constexpr uint32_t C = (1U << 29);  ///< Carry condition code flag
        constexpr uint32_t Z = (1U << 30);  ///< Zero condition code flag
        constexpr uint32_t N = (1U << 31);  ///< Negative condition code flag
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000ED90;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t MPU_TYPER;  ///< Offset: 0x00 - MPU type register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0x04 - MPU control register
        volatile uint32_t MPU_RNR;  ///< Offset: 0x08 - MPU region number register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0x0C - MPU region base address register
        volatile uint32_t MPU_RASR;  ///< Offset: 0x10 - MPU region attribute and size register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// MPU_TYPER Register bits
    namespace mpu_typer_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate flag
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables the MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enables the operation of MPU during hard fault
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enable priviliged software access to default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< MPU region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< Size of the MPU protection region
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< memory attribute
        constexpr uint32_t C = (1U << 17);  ///< memory attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable memory attribute
        constexpr uint32_t TEX = (3 << 19);  ///< memory attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

}

// ============================================================================
// STK Peripheral
// ============================================================================

namespace stk {
    /// Base addresses
    constexpr uint32_t STK_BASE = 0xE000E010;

    /// STK Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - SysTick control and status register
        volatile uint32_t LOAD;  ///< Offset: 0x04 - SysTick reload value register
        volatile uint32_t VAL;  ///< Offset: 0x08 - SysTick current value register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick calibration value register
    };

    /// Peripheral instances
    inline Registers* STK = reinterpret_cast<Registers*>(STK_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick exception request enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source selection
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< COUNTFLAG
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< RELOAD value
    }

    /// VAL Register bits
    namespace val_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Calibration value
        constexpr uint32_t SKEW = (1U << 30);  ///< SKEW flag: Indicates whether the TENMS value is exact
        constexpr uint32_t NOREF = (1U << 31);  ///< NOREF flag. Reads as zero
    }

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED00;
    constexpr uint32_t SCB_ACTRL_BASE = 0xE000E008;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - CPUID base register
        volatile uint32_t ICSR;  ///< Offset: 0x04 - Interrupt control and state register
        volatile uint32_t VTOR;  ///< Offset: 0x08 - Vector table offset register
        volatile uint32_t AIRCR;  ///< Offset: 0x0C - Application interrupt and reset control register
        volatile uint32_t SCR;  ///< Offset: 0x10 - System control register
        volatile uint32_t CCR;  ///< Offset: 0x14 - Configuration and control register
        volatile uint32_t SHPR1;  ///< Offset: 0x18 - System handler priority registers
        volatile uint32_t SHPR2;  ///< Offset: 0x1C - System handler priority registers
        volatile uint32_t SHPR3;  ///< Offset: 0x20 - System handler priority registers
        volatile uint32_t SHCRS;  ///< Offset: 0x24 - System handler control and state register
        volatile uint32_t CFSR_UFSR_BFSR_MMFSR;  ///< Offset: 0x28 - Configurable fault status register
        volatile uint32_t HFSR;  ///< Offset: 0x2C - Hard fault status register
        volatile uint32_t MMFAR;  ///< Offset: 0x34 - Memory management fault address register
        volatile uint32_t BFAR;  ///< Offset: 0x38 - Bus fault address register
        volatile uint32_t AFSR;  ///< Offset: 0x3C - Auxiliary fault status register
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);
    inline Registers* SCB_ACTRL = reinterpret_cast<Registers*>(SCB_ACTRL_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Constant = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active vector
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to base level
        constexpr uint32_t VECTPENDING = (7 << 12);  ///< Pending vector
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit.
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (21 << 9);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< VECTRESET
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< SYSRESETREQ
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< PRIGROUP
        constexpr uint32_t ENDIANESS = (1U << 15);  ///< ENDIANESS
        constexpr uint32_t VECTKEYSTAT = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< SLEEPONEXIT
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< SLEEPDEEP
        constexpr uint32_t SEVEONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Configures how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< USERSETMPEND
        constexpr uint32_t UNALIGN__TRP = (1U << 3);  ///< UNALIGN_ TRP
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< DIV_0_TRP
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< BFHFNMIGN
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

    /// SHCRS Register bits
    namespace shcrs_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< Memory management fault exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< Bus fault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< Usage fault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVC call active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< Usage fault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< Memory management fault exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< Bus fault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVC call pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< Memory management fault enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< Bus fault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< Usage fault enable bit
    }

    /// CFSR_UFSR_BFSR_MMFSR Register bits
    namespace cfsr_ufsr_bfsr_mmfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 1);  ///< Instruction access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< Memory manager fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< Memory manager fault on stacking for exception entry.
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MLSPERR
        constexpr uint32_t MMARVALID = (1U << 7);  ///< Memory Management Fault Address Register (MMAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< Bus fault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< Bus fault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< Bus fault on floating-point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< Bus Fault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction usage fault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state usage fault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load usage fault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor usage fault.
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access usage fault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero usage fault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< Vector table hard fault
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced hard fault
        constexpr uint32_t DEBUG_VT = (1U << 31);  ///< Reserved for Debug use
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t MMFAR = (32 << 0);  ///< Memory management fault address
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t BFAR = (32 << 0);  ///< Bus fault address
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t IMPDEF = (32 << 0);  ///< Implementation defined
    }

}


} // namespace alloy::generated::stm32f410

#endif // ALLOY_GENERATED_STM32F410_PERIPHERALS_HPP