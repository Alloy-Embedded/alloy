/// Auto-generated code for STM32F446
/// Generated by Alloy Code Generator
/// Source: st_stm32f446.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:38
#ifndef ALLOY_GENERATED_STM32F446_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32F446_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32f446 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_dcmi = true;
    constexpr uint32_t num_dcmi_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 8;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 5;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 4;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 14;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_otg = true;
    constexpr uint32_t num_otg_instances = 6;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 3;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 2;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai2 = true;
    constexpr uint32_t num_sai2_instances = 1;
    constexpr bool has_spdif = true;
    constexpr uint32_t num_spdif_instances = 1;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 1;
    constexpr bool has_hdmi = true;
    constexpr uint32_t num_hdmi_instances = 1;
    constexpr bool has_fpu = true;
    constexpr uint32_t num_fpu_instances = 2;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_stk = true;
    constexpr uint32_t num_stk_instances = 1;
    constexpr bool has_scb = true;
    constexpr uint32_t num_scb_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct dcmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 14;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otg_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spdif_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hdmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpu_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct stk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 8;
    constexpr uint32_t max_gpio_pins = 128;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart6 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
}

// ============================================================================
// DCMI Peripheral
// ============================================================================

namespace dcmi {
    /// Base addresses
    constexpr uint32_t DCMI_BASE = 0x50050000;

    /// DCMI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register 1
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - interrupt clear register
        volatile uint32_t ESCR;  ///< Offset: 0x18 - embedded synchronization code register
        volatile uint32_t ESUR;  ///< Offset: 0x1C - embedded synchronization unmask register
        volatile uint32_t CWSTRT;  ///< Offset: 0x20 - crop window start
        volatile uint32_t CWSIZE;  ///< Offset: 0x24 - crop window size
        volatile uint32_t DR;  ///< Offset: 0x28 - data register
    };

    /// Peripheral instances
    inline Registers* DCMI = reinterpret_cast<Registers*>(DCMI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CAPTURE = (1U << 0);  ///< Capture enable
        constexpr uint32_t CM = (1U << 1);  ///< Capture mode
        constexpr uint32_t CROP = (1U << 2);  ///< Crop feature
        constexpr uint32_t JPEG = (1U << 3);  ///< JPEG format
        constexpr uint32_t ESS = (1U << 4);  ///< Embedded synchronization select
        constexpr uint32_t PCKPOL = (1U << 5);  ///< Pixel clock polarity
        constexpr uint32_t HSPOL = (1U << 6);  ///< Horizontal synchronization polarity
        constexpr uint32_t VSPOL = (1U << 7);  ///< Vertical synchronization polarity
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< DCMI enable
        constexpr uint32_t BSM = (2 << 16);  ///< Byte Select mode
        constexpr uint32_t OEBS = (1U << 18);  ///< Odd/Even Byte Select
        constexpr uint32_t LSM = (1U << 19);  ///< Line Select mode
        constexpr uint32_t OELS = (1U << 20);  ///< Odd/Even Line Select
        constexpr uint32_t FCRC = (2 << 8);  ///< Frame capture rate control
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t FNE = (1U << 2);  ///< FIFO not empty
        constexpr uint32_t VSYNC = (1U << 1);  ///< VSYNC
        constexpr uint32_t HSYNC = (1U << 0);  ///< HSYNC
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t LINE_RIS = (1U << 4);  ///< Line raw interrupt status
        constexpr uint32_t VSYNC_RIS = (1U << 3);  ///< VSYNC raw interrupt status
        constexpr uint32_t ERR_RIS = (1U << 2);  ///< Synchronization error raw interrupt status
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< Overrun raw interrupt status
        constexpr uint32_t FRAME_RIS = (1U << 0);  ///< Capture complete raw interrupt status
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t LINE_IE = (1U << 4);  ///< Line interrupt enable
        constexpr uint32_t VSYNC_IE = (1U << 3);  ///< VSYNC interrupt enable
        constexpr uint32_t ERR_IE = (1U << 2);  ///< Synchronization error interrupt enable
        constexpr uint32_t OVR_IE = (1U << 1);  ///< Overrun interrupt enable
        constexpr uint32_t FRAME_IE = (1U << 0);  ///< Capture complete interrupt enable
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t LINE_MIS = (1U << 4);  ///< Line masked interrupt status
        constexpr uint32_t VSYNC_MIS = (1U << 3);  ///< VSYNC masked interrupt status
        constexpr uint32_t ERR_MIS = (1U << 2);  ///< Synchronization error masked interrupt status
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< Overrun masked interrupt status
        constexpr uint32_t FRAME_MIS = (1U << 0);  ///< Capture complete masked interrupt status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t LINE_ISC = (1U << 4);  ///< line interrupt status clear
        constexpr uint32_t VSYNC_ISC = (1U << 3);  ///< Vertical synch interrupt status clear
        constexpr uint32_t ERR_ISC = (1U << 2);  ///< Synchronization error interrupt status clear
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< Overrun interrupt status clear
        constexpr uint32_t FRAME_ISC = (1U << 0);  ///< Capture complete interrupt status clear
    }

    /// ESCR Register bits
    namespace escr_bits {
        constexpr uint32_t FEC = (8 << 24);  ///< Frame end delimiter code
        constexpr uint32_t LEC = (8 << 16);  ///< Line end delimiter code
        constexpr uint32_t LSC = (8 << 8);  ///< Line start delimiter code
        constexpr uint32_t FSC = (8 << 0);  ///< Frame start delimiter code
    }

    /// ESUR Register bits
    namespace esur_bits {
        constexpr uint32_t FEU = (8 << 24);  ///< Frame end delimiter unmask
        constexpr uint32_t LEU = (8 << 16);  ///< Line end delimiter unmask
        constexpr uint32_t LSU = (8 << 8);  ///< Line start delimiter unmask
        constexpr uint32_t FSU = (8 << 0);  ///< Frame start delimiter unmask
    }

    /// CWSTRT Register bits
    namespace cwstrt_bits {
        constexpr uint32_t VST = (13 << 16);  ///< Vertical start line count
        constexpr uint32_t HOFFCNT = (14 << 0);  ///< Horizontal offset count
    }

    /// CWSIZE Register bits
    namespace cwsize_bits {
        constexpr uint32_t VLINE = (14 << 16);  ///< Vertical line count
        constexpr uint32_t CAPCNT = (14 << 0);  ///< Capture count
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t Byte3 = (8 << 24);  ///< Data byte 3
        constexpr uint32_t Byte2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t Byte1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t Byte0 = (8 << 0);  ///< Data byte 0
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0xA0000000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x00 - SRAM/NOR-Flash chip-select control register 1
        volatile uint32_t BTR1;  ///< Offset: 0x04 - SRAM/NOR-Flash chip-select timing register 1
        volatile uint32_t BCR2;  ///< Offset: 0x08 - SRAM/NOR-Flash chip-select control register 2
        volatile uint32_t BTR2;  ///< Offset: 0x0C - SRAM/NOR-Flash chip-select timing register 2
        volatile uint32_t BCR3;  ///< Offset: 0x10 - SRAM/NOR-Flash chip-select control register 3
        volatile uint32_t BTR3;  ///< Offset: 0x14 - SRAM/NOR-Flash chip-select timing register 3
        volatile uint32_t BCR4;  ///< Offset: 0x18 - SRAM/NOR-Flash chip-select control register 4
        volatile uint32_t BTR4;  ///< Offset: 0x1C - SRAM/NOR-Flash chip-select timing register 4
        volatile uint32_t PCR2;  ///< Offset: 0x60 - PC Card/NAND Flash control register 2
        volatile uint32_t SR2;  ///< Offset: 0x64 - FIFO status and interrupt register 2
        volatile uint32_t PMEM2;  ///< Offset: 0x68 - Common memory space timing register 2
        volatile uint32_t PATT2;  ///< Offset: 0x6C - Attribute memory space timing register 2
        volatile uint32_t ECCR2;  ///< Offset: 0x74 - ECC result register 2
        volatile uint32_t PCR3;  ///< Offset: 0x80 - PC Card/NAND Flash control register 3
        volatile uint32_t SR3;  ///< Offset: 0x84 - FIFO status and interrupt register 3
        volatile uint32_t PMEM3;  ///< Offset: 0x88 - Common memory space timing register 3
        volatile uint32_t PATT3;  ///< Offset: 0x8C - Attribute memory space timing register 3
        volatile uint32_t ECCR3;  ///< Offset: 0x94 - ECC result register 3
        volatile uint32_t PCR4;  ///< Offset: 0xA0 - PC Card/NAND Flash control register 4
        volatile uint32_t SR4;  ///< Offset: 0xA4 - FIFO status and interrupt register 4
        volatile uint32_t PMEM4;  ///< Offset: 0xA8 - Common memory space timing register 4
        volatile uint32_t PATT4;  ///< Offset: 0xAC - Attribute memory space timing register 4
        volatile uint32_t PIO4;  ///< Offset: 0xB0 - I/O space timing register 4
        volatile uint32_t BWTR1;  ///< Offset: 0x104 - SRAM/NOR-Flash write timing registers 1
        volatile uint32_t BWTR2;  ///< Offset: 0x10C - SRAM/NOR-Flash write timing registers 2
        volatile uint32_t BWTR3;  ///< Offset: 0x114 - SRAM/NOR-Flash write timing registers 3
        volatile uint32_t BWTR4;  ///< Offset: 0x11C - SRAM/NOR-Flash write timing registers 4
        volatile uint32_t SDCR1;  ///< Offset: 0x140 - SDRAM Control Register 1
        volatile uint32_t SDCR2;  ///< Offset: 0x144 - SDRAM Control Register 2
        volatile uint32_t SDTR1;  ///< Offset: 0x148 - SDRAM Timing register 1
        volatile uint32_t SDTR2;  ///< Offset: 0x14C - SDRAM Timing register 2
        volatile uint32_t SDCMR;  ///< Offset: 0x150 - SDRAM Command Mode register
        volatile uint32_t SDRTR;  ///< Offset: 0x154 - SDRAM Refresh Timer register
        volatile uint32_t SDSR;  ///< Offset: 0x158 - SDRAM Status register
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t CCLKEN = (1U << 20);  ///< CCLKEN
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< CBURSTRW
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< ASYNCWAIT
        constexpr uint32_t EXTMOD = (1U << 14);  ///< EXTMOD
        constexpr uint32_t WAITEN = (1U << 13);  ///< WAITEN
        constexpr uint32_t WREN = (1U << 12);  ///< WREN
        constexpr uint32_t WAITCFG = (1U << 11);  ///< WAITCFG
        constexpr uint32_t WAITPOL = (1U << 9);  ///< WAITPOL
        constexpr uint32_t BURSTEN = (1U << 8);  ///< BURSTEN
        constexpr uint32_t FACCEN = (1U << 6);  ///< FACCEN
        constexpr uint32_t MWID = (2 << 4);  ///< MWID
        constexpr uint32_t MTYP = (2 << 2);  ///< MTYP
        constexpr uint32_t MUXEN = (1U << 1);  ///< MUXEN
        constexpr uint32_t MBKEN = (1U << 0);  ///< MBKEN
    }

    /// BTR1 Register bits
    namespace btr1_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t BUSTURN = (4 << 16);  ///< BUSTURN
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< CBURSTRW
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< ASYNCWAIT
        constexpr uint32_t EXTMOD = (1U << 14);  ///< EXTMOD
        constexpr uint32_t WAITEN = (1U << 13);  ///< WAITEN
        constexpr uint32_t WREN = (1U << 12);  ///< WREN
        constexpr uint32_t WAITCFG = (1U << 11);  ///< WAITCFG
        constexpr uint32_t WRAPMOD = (1U << 10);  ///< WRAPMOD
        constexpr uint32_t WAITPOL = (1U << 9);  ///< WAITPOL
        constexpr uint32_t BURSTEN = (1U << 8);  ///< BURSTEN
        constexpr uint32_t FACCEN = (1U << 6);  ///< FACCEN
        constexpr uint32_t MWID = (2 << 4);  ///< MWID
        constexpr uint32_t MTYP = (2 << 2);  ///< MTYP
        constexpr uint32_t MUXEN = (1U << 1);  ///< MUXEN
        constexpr uint32_t MBKEN = (1U << 0);  ///< MBKEN
    }

    /// BTR2 Register bits
    namespace btr2_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t BUSTURN = (4 << 16);  ///< BUSTURN
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// BCR3 Register bits
    namespace bcr3_bits {
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< CBURSTRW
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< ASYNCWAIT
        constexpr uint32_t EXTMOD = (1U << 14);  ///< EXTMOD
        constexpr uint32_t WAITEN = (1U << 13);  ///< WAITEN
        constexpr uint32_t WREN = (1U << 12);  ///< WREN
        constexpr uint32_t WAITCFG = (1U << 11);  ///< WAITCFG
        constexpr uint32_t WRAPMOD = (1U << 10);  ///< WRAPMOD
        constexpr uint32_t WAITPOL = (1U << 9);  ///< WAITPOL
        constexpr uint32_t BURSTEN = (1U << 8);  ///< BURSTEN
        constexpr uint32_t FACCEN = (1U << 6);  ///< FACCEN
        constexpr uint32_t MWID = (2 << 4);  ///< MWID
        constexpr uint32_t MTYP = (2 << 2);  ///< MTYP
        constexpr uint32_t MUXEN = (1U << 1);  ///< MUXEN
        constexpr uint32_t MBKEN = (1U << 0);  ///< MBKEN
    }

    /// BTR3 Register bits
    namespace btr3_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t BUSTURN = (4 << 16);  ///< BUSTURN
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// BCR4 Register bits
    namespace bcr4_bits {
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< CBURSTRW
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< ASYNCWAIT
        constexpr uint32_t EXTMOD = (1U << 14);  ///< EXTMOD
        constexpr uint32_t WAITEN = (1U << 13);  ///< WAITEN
        constexpr uint32_t WREN = (1U << 12);  ///< WREN
        constexpr uint32_t WAITCFG = (1U << 11);  ///< WAITCFG
        constexpr uint32_t WRAPMOD = (1U << 10);  ///< WRAPMOD
        constexpr uint32_t WAITPOL = (1U << 9);  ///< WAITPOL
        constexpr uint32_t BURSTEN = (1U << 8);  ///< BURSTEN
        constexpr uint32_t FACCEN = (1U << 6);  ///< FACCEN
        constexpr uint32_t MWID = (2 << 4);  ///< MWID
        constexpr uint32_t MTYP = (2 << 2);  ///< MTYP
        constexpr uint32_t MUXEN = (1U << 1);  ///< MUXEN
        constexpr uint32_t MBKEN = (1U << 0);  ///< MBKEN
    }

    /// BTR4 Register bits
    namespace btr4_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t BUSTURN = (4 << 16);  ///< BUSTURN
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECCPS
        constexpr uint32_t TAR = (4 << 13);  ///< TAR
        constexpr uint32_t TCLR = (4 << 9);  ///< TCLR
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECCEN
        constexpr uint32_t PWID = (2 << 4);  ///< PWID
        constexpr uint32_t PTYP = (1U << 3);  ///< PTYP
        constexpr uint32_t PBKEN = (1U << 2);  ///< PBKEN
        constexpr uint32_t PWAITEN = (1U << 1);  ///< PWAITEN
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t FEMPT = (1U << 6);  ///< FEMPT
        constexpr uint32_t IFEN = (1U << 5);  ///< IFEN
        constexpr uint32_t ILEN = (1U << 4);  ///< ILEN
        constexpr uint32_t IREN = (1U << 3);  ///< IREN
        constexpr uint32_t IFS = (1U << 2);  ///< IFS
        constexpr uint32_t ILS = (1U << 1);  ///< ILS
        constexpr uint32_t IRS = (1U << 0);  ///< IRS
    }

    /// PMEM2 Register bits
    namespace pmem2_bits {
        constexpr uint32_t MEMHIZx = (8 << 24);  ///< MEMHIZx
        constexpr uint32_t MEMHOLDx = (8 << 16);  ///< MEMHOLDx
        constexpr uint32_t MEMWAITx = (8 << 8);  ///< MEMWAITx
        constexpr uint32_t MEMSETx = (8 << 0);  ///< MEMSETx
    }

    /// PATT2 Register bits
    namespace patt2_bits {
        constexpr uint32_t ATTHIZx = (8 << 24);  ///< ATTHIZx
        constexpr uint32_t ATTHOLDx = (8 << 16);  ///< ATTHOLDx
        constexpr uint32_t ATTWAITx = (8 << 8);  ///< ATTWAITx
        constexpr uint32_t ATTSETx = (8 << 0);  ///< ATTSETx
    }

    /// ECCR2 Register bits
    namespace eccr2_bits {
        constexpr uint32_t ECCx = (32 << 0);  ///< ECCx
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECCPS
        constexpr uint32_t TAR = (4 << 13);  ///< TAR
        constexpr uint32_t TCLR = (4 << 9);  ///< TCLR
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECCEN
        constexpr uint32_t PWID = (2 << 4);  ///< PWID
        constexpr uint32_t PTYP = (1U << 3);  ///< PTYP
        constexpr uint32_t PBKEN = (1U << 2);  ///< PBKEN
        constexpr uint32_t PWAITEN = (1U << 1);  ///< PWAITEN
    }

    /// SR3 Register bits
    namespace sr3_bits {
        constexpr uint32_t FEMPT = (1U << 6);  ///< FEMPT
        constexpr uint32_t IFEN = (1U << 5);  ///< IFEN
        constexpr uint32_t ILEN = (1U << 4);  ///< ILEN
        constexpr uint32_t IREN = (1U << 3);  ///< IREN
        constexpr uint32_t IFS = (1U << 2);  ///< IFS
        constexpr uint32_t ILS = (1U << 1);  ///< ILS
        constexpr uint32_t IRS = (1U << 0);  ///< IRS
    }

    /// PMEM3 Register bits
    namespace pmem3_bits {
        constexpr uint32_t MEMHIZx = (8 << 24);  ///< MEMHIZx
        constexpr uint32_t MEMHOLDx = (8 << 16);  ///< MEMHOLDx
        constexpr uint32_t MEMWAITx = (8 << 8);  ///< MEMWAITx
        constexpr uint32_t MEMSETx = (8 << 0);  ///< MEMSETx
    }

    /// PATT3 Register bits
    namespace patt3_bits {
        constexpr uint32_t ATTHIZx = (8 << 24);  ///< ATTHIZx
        constexpr uint32_t ATTHOLDx = (8 << 16);  ///< ATTHOLDx
        constexpr uint32_t ATTWAITx = (8 << 8);  ///< ATTWAITx
        constexpr uint32_t ATTSETx = (8 << 0);  ///< ATTSETx
    }

    /// ECCR3 Register bits
    namespace eccr3_bits {
        constexpr uint32_t ECCx = (32 << 0);  ///< ECCx
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECCPS
        constexpr uint32_t TAR = (4 << 13);  ///< TAR
        constexpr uint32_t TCLR = (4 << 9);  ///< TCLR
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECCEN
        constexpr uint32_t PWID = (2 << 4);  ///< PWID
        constexpr uint32_t PTYP = (1U << 3);  ///< PTYP
        constexpr uint32_t PBKEN = (1U << 2);  ///< PBKEN
        constexpr uint32_t PWAITEN = (1U << 1);  ///< PWAITEN
    }

    /// SR4 Register bits
    namespace sr4_bits {
        constexpr uint32_t FEMPT = (1U << 6);  ///< FEMPT
        constexpr uint32_t IFEN = (1U << 5);  ///< IFEN
        constexpr uint32_t ILEN = (1U << 4);  ///< ILEN
        constexpr uint32_t IREN = (1U << 3);  ///< IREN
        constexpr uint32_t IFS = (1U << 2);  ///< IFS
        constexpr uint32_t ILS = (1U << 1);  ///< ILS
        constexpr uint32_t IRS = (1U << 0);  ///< IRS
    }

    /// PMEM4 Register bits
    namespace pmem4_bits {
        constexpr uint32_t MEMHIZx = (8 << 24);  ///< MEMHIZx
        constexpr uint32_t MEMHOLDx = (8 << 16);  ///< MEMHOLDx
        constexpr uint32_t MEMWAITx = (8 << 8);  ///< MEMWAITx
        constexpr uint32_t MEMSETx = (8 << 0);  ///< MEMSETx
    }

    /// PATT4 Register bits
    namespace patt4_bits {
        constexpr uint32_t ATTHIZx = (8 << 24);  ///< ATTHIZx
        constexpr uint32_t ATTHOLDx = (8 << 16);  ///< ATTHOLDx
        constexpr uint32_t ATTWAITx = (8 << 8);  ///< ATTWAITx
        constexpr uint32_t ATTSETx = (8 << 0);  ///< ATTSETx
    }

    /// PIO4 Register bits
    namespace pio4_bits {
        constexpr uint32_t IOHIZx = (8 << 24);  ///< IOHIZx
        constexpr uint32_t IOHOLDx = (8 << 16);  ///< IOHOLDx
        constexpr uint32_t IOWAITx = (8 << 8);  ///< IOWAITx
        constexpr uint32_t IOSETx = (8 << 0);  ///< IOSETx
    }

    /// BWTR1 Register bits
    namespace bwtr1_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// BWTR2 Register bits
    namespace bwtr2_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// BWTR3 Register bits
    namespace bwtr3_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// BWTR4 Register bits
    namespace bwtr4_bits {
        constexpr uint32_t ACCMOD = (2 << 28);  ///< ACCMOD
        constexpr uint32_t DATLAT = (4 << 24);  ///< DATLAT
        constexpr uint32_t CLKDIV = (4 << 20);  ///< CLKDIV
        constexpr uint32_t DATAST = (8 << 8);  ///< DATAST
        constexpr uint32_t ADDHLD = (4 << 4);  ///< ADDHLD
        constexpr uint32_t ADDSET = (4 << 0);  ///< ADDSET
    }

    /// SDCR1 Register bits
    namespace sdcr1_bits {
        constexpr uint32_t NC = (2 << 0);  ///< Number of column address bits
        constexpr uint32_t NR = (2 << 2);  ///< Number of row address bits
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t NB = (1U << 6);  ///< Number of internal banks
        constexpr uint32_t CAS = (2 << 7);  ///< CAS latency
        constexpr uint32_t WP = (1U << 9);  ///< Write protection
        constexpr uint32_t SDCLK = (2 << 10);  ///< SDRAM clock configuration
        constexpr uint32_t RBURST = (1U << 12);  ///< Burst read
        constexpr uint32_t RPIPE = (2 << 13);  ///< Read pipe
    }

    /// SDCR2 Register bits
    namespace sdcr2_bits {
        constexpr uint32_t NC = (2 << 0);  ///< Number of column address bits
        constexpr uint32_t NR = (2 << 2);  ///< Number of row address bits
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t NB = (1U << 6);  ///< Number of internal banks
        constexpr uint32_t CAS = (2 << 7);  ///< CAS latency
        constexpr uint32_t WP = (1U << 9);  ///< Write protection
        constexpr uint32_t SDCLK = (2 << 10);  ///< SDRAM clock configuration
        constexpr uint32_t RBURST = (1U << 12);  ///< Burst read
        constexpr uint32_t RPIPE = (2 << 13);  ///< Read pipe
    }

    /// SDTR1 Register bits
    namespace sdtr1_bits {
        constexpr uint32_t TMRD = (4 << 0);  ///< Load Mode Register to Active
        constexpr uint32_t TXSR = (4 << 4);  ///< Exit self-refresh delay
        constexpr uint32_t TRAS = (4 << 8);  ///< Self refresh time
        constexpr uint32_t TRC = (4 << 12);  ///< Row cycle delay
        constexpr uint32_t TWR = (4 << 16);  ///< Recovery delay
        constexpr uint32_t TRP = (4 << 20);  ///< Row precharge delay
        constexpr uint32_t TRCD = (4 << 24);  ///< Row to column delay
    }

    /// SDTR2 Register bits
    namespace sdtr2_bits {
        constexpr uint32_t TMRD = (4 << 0);  ///< Load Mode Register to Active
        constexpr uint32_t TXSR = (4 << 4);  ///< Exit self-refresh delay
        constexpr uint32_t TRAS = (4 << 8);  ///< Self refresh time
        constexpr uint32_t TRC = (4 << 12);  ///< Row cycle delay
        constexpr uint32_t TWR = (4 << 16);  ///< Recovery delay
        constexpr uint32_t TRP = (4 << 20);  ///< Row precharge delay
        constexpr uint32_t TRCD = (4 << 24);  ///< Row to column delay
    }

    /// SDCMR Register bits
    namespace sdcmr_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< Command mode
        constexpr uint32_t CTB2 = (1U << 3);  ///< Command target bank 2
        constexpr uint32_t CTB1 = (1U << 4);  ///< Command target bank 1
        constexpr uint32_t NRFS = (4 << 5);  ///< Number of Auto-refresh
        constexpr uint32_t MRD = (13 << 9);  ///< Mode Register definition
    }

    /// SDRTR Register bits
    namespace sdrtr_bits {
        constexpr uint32_t CRE = (1U << 0);  ///< Clear Refresh error flag
        constexpr uint32_t COUNT = (13 << 1);  ///< Refresh Timer Count
        constexpr uint32_t REIE = (1U << 14);  ///< RES Interrupt Enable
    }

    /// SDSR Register bits
    namespace sdsr_bits {
        constexpr uint32_t RE = (1U << 0);  ///< Refresh error flag
        constexpr uint32_t MODES1 = (2 << 1);  ///< Status Mode for Bank 1
        constexpr uint32_t MODES2 = (2 << 3);  ///< Status Mode for Bank 2
        constexpr uint32_t BUSY = (1U << 5);  ///< Busy status
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0xE0042000;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t DBGMCU_IDCODE;  ///< Offset: 0x00 - IDCODE
        volatile uint32_t DBGMCU_CR;  ///< Offset: 0x04 - Control Register
        volatile uint32_t DBGMCU_APB1_FZ;  ///< Offset: 0x08 - Debug MCU APB1 Freeze registe
        volatile uint32_t DBGMCU_APB2_FZ;  ///< Offset: 0x0C - Debug MCU APB2 Freeze registe
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// DBGMCU_IDCODE Register bits
    namespace dbgmcu_idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< DEV_ID
        constexpr uint32_t REV_ID = (16 << 16);  ///< REV_ID
    }

    /// DBGMCU_CR Register bits
    namespace dbgmcu_cr_bits {
        constexpr uint32_t DBG_SLEEP = (1U << 0);  ///< DBG_SLEEP
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< DBG_STOP
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< DBG_STANDBY
        constexpr uint32_t TRACE_IOEN = (1U << 5);  ///< TRACE_IOEN
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< TRACE_MODE
    }

    /// DBGMCU_APB1_FZ Register bits
    namespace dbgmcu_apb1_fz_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< DBG_TIM2_STOP
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< DBG_TIM3 _STOP
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< DBG_TIM4_STOP
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< DBG_TIM5_STOP
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< DBG_TIM6_STOP
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< DBG_TIM7_STOP
        constexpr uint32_t DBG_TIM12_STOP = (1U << 6);  ///< DBG_TIM12_STOP
        constexpr uint32_t DBG_TIM13_STOP = (1U << 7);  ///< DBG_TIM13_STOP
        constexpr uint32_t DBG_TIM14_STOP = (1U << 8);  ///< DBG_TIM14_STOP
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< RTC stopped when Core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< DBG_WWDG_STOP
        constexpr uint32_t DBG_IWDEG_STOP = (1U << 12);  ///< DBG_IWDEG_STOP
        constexpr uint32_t DBG_J2C1_SMBUS_TIMEOUT = (1U << 21);  ///< DBG_J2C1_SMBUS_TIMEOUT
        constexpr uint32_t DBG_J2C2_SMBUS_TIMEOUT = (1U << 22);  ///< DBG_J2C2_SMBUS_TIMEOUT
        constexpr uint32_t DBG_J2C3SMBUS_TIMEOUT = (1U << 23);  ///< DBG_J2C3SMBUS_TIMEOUT
        constexpr uint32_t DBG_I2CFMP_SMBUS_TIMEOUT = (1U << 24);  ///< SMBUS timeout mode stopped when Core is halted
        constexpr uint32_t DBG_CAN1_STOP = (1U << 25);  ///< DBG_CAN1_STOP
        constexpr uint32_t DBG_CAN2_STOP = (1U << 26);  ///< DBG_CAN2_STOP
    }

    /// DBGMCU_APB2_FZ Register bits
    namespace dbgmcu_apb2_fz_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 0);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM8_STOP = (1U << 1);  ///< TIM8 counter stopped when core is halted
        constexpr uint32_t DBG_TIM9_STOP = (1U << 16);  ///< TIM9 counter stopped when core is halted
        constexpr uint32_t DBG_TIM10_STOP = (1U << 17);  ///< TIM10 counter stopped when core is halted
        constexpr uint32_t DBG_TIM11_STOP = (1U << 18);  ///< TIM11 counter stopped when core is halted
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA2_BASE = 0x40026400;
    constexpr uint32_t DMA1_BASE = 0x40026000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t LISR;  ///< Offset: 0x00 - low interrupt status register
        volatile uint32_t HISR;  ///< Offset: 0x04 - high interrupt status register
        volatile uint32_t LIFCR;  ///< Offset: 0x08 - low interrupt flag clear register
        volatile uint32_t HIFCR;  ///< Offset: 0x0C - high interrupt flag clear register
        volatile uint32_t S0CR;  ///< Offset: 0x10 - stream x configuration register
        volatile uint32_t S0NDTR;  ///< Offset: 0x14 - stream x number of data register
        volatile uint32_t S0PAR;  ///< Offset: 0x18 - stream x peripheral address register
        volatile uint32_t S0M0AR;  ///< Offset: 0x1C - stream x memory 0 address register
        volatile uint32_t S0M1AR;  ///< Offset: 0x20 - stream x memory 1 address register
        volatile uint32_t S0FCR;  ///< Offset: 0x24 - stream x FIFO control register
        volatile uint32_t S1CR;  ///< Offset: 0x28 - stream x configuration register
        volatile uint32_t S1NDTR;  ///< Offset: 0x2C - stream x number of data register
        volatile uint32_t S1PAR;  ///< Offset: 0x30 - stream x peripheral address register
        volatile uint32_t S1M0AR;  ///< Offset: 0x34 - stream x memory 0 address register
        volatile uint32_t S1M1AR;  ///< Offset: 0x38 - stream x memory 1 address register
        volatile uint32_t S1FCR;  ///< Offset: 0x3C - stream x FIFO control register
        volatile uint32_t S2CR;  ///< Offset: 0x40 - stream x configuration register
        volatile uint32_t S2NDTR;  ///< Offset: 0x44 - stream x number of data register
        volatile uint32_t S2PAR;  ///< Offset: 0x48 - stream x peripheral address register
        volatile uint32_t S2M0AR;  ///< Offset: 0x4C - stream x memory 0 address register
        volatile uint32_t S2M1AR;  ///< Offset: 0x50 - stream x memory 1 address register
        volatile uint32_t S2FCR;  ///< Offset: 0x54 - stream x FIFO control register
        volatile uint32_t S3CR;  ///< Offset: 0x58 - stream x configuration register
        volatile uint32_t S3NDTR;  ///< Offset: 0x5C - stream x number of data register
        volatile uint32_t S3PAR;  ///< Offset: 0x60 - stream x peripheral address register
        volatile uint32_t S3M0AR;  ///< Offset: 0x64 - stream x memory 0 address register
        volatile uint32_t S3M1AR;  ///< Offset: 0x68 - stream x memory 1 address register
        volatile uint32_t S3FCR;  ///< Offset: 0x6C - stream x FIFO control register
        volatile uint32_t S4CR;  ///< Offset: 0x70 - stream x configuration register
        volatile uint32_t S4NDTR;  ///< Offset: 0x74 - stream x number of data register
        volatile uint32_t S4PAR;  ///< Offset: 0x78 - stream x peripheral address register
        volatile uint32_t S4M0AR;  ///< Offset: 0x7C - stream x memory 0 address register
        volatile uint32_t S4M1AR;  ///< Offset: 0x80 - stream x memory 1 address register
        volatile uint32_t S4FCR;  ///< Offset: 0x84 - stream x FIFO control register
        volatile uint32_t S5CR;  ///< Offset: 0x88 - stream x configuration register
        volatile uint32_t S5NDTR;  ///< Offset: 0x8C - stream x number of data register
        volatile uint32_t S5PAR;  ///< Offset: 0x90 - stream x peripheral address register
        volatile uint32_t S5M0AR;  ///< Offset: 0x94 - stream x memory 0 address register
        volatile uint32_t S5M1AR;  ///< Offset: 0x98 - stream x memory 1 address register
        volatile uint32_t S5FCR;  ///< Offset: 0x9C - stream x FIFO control register
        volatile uint32_t S6CR;  ///< Offset: 0xA0 - stream x configuration register
        volatile uint32_t S6NDTR;  ///< Offset: 0xA4 - stream x number of data register
        volatile uint32_t S6PAR;  ///< Offset: 0xA8 - stream x peripheral address register
        volatile uint32_t S6M0AR;  ///< Offset: 0xAC - stream x memory 0 address register
        volatile uint32_t S6M1AR;  ///< Offset: 0xB0 - stream x memory 1 address register
        volatile uint32_t S6FCR;  ///< Offset: 0xB4 - stream x FIFO control register
        volatile uint32_t S7CR;  ///< Offset: 0xB8 - stream x configuration register
        volatile uint32_t S7NDTR;  ///< Offset: 0xBC - stream x number of data register
        volatile uint32_t S7PAR;  ///< Offset: 0xC0 - stream x peripheral address register
        volatile uint32_t S7M0AR;  ///< Offset: 0xC4 - stream x memory 0 address register
        volatile uint32_t S7M1AR;  ///< Offset: 0xC8 - stream x memory 1 address register
        volatile uint32_t S7FCR;  ///< Offset: 0xCC - stream x FIFO control register
    };

    /// Peripheral instances
    inline Registers* DMA2 = reinterpret_cast<Registers*>(DMA2_BASE);
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);

    // Bit definitions
    /// LISR Register bits
    namespace lisr_bits {
        constexpr uint32_t TCIF3 = (1U << 27);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF3 = (1U << 26);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF3 = (1U << 25);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF3 = (1U << 24);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF3 = (1U << 22);  ///< Stream x FIFO error interrupt flag (x=3..0)
        constexpr uint32_t TCIF2 = (1U << 21);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF2 = (1U << 20);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF2 = (1U << 19);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF2 = (1U << 18);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF2 = (1U << 16);  ///< Stream x FIFO error interrupt flag (x=3..0)
        constexpr uint32_t TCIF1 = (1U << 11);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF1 = (1U << 10);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF1 = (1U << 9);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF1 = (1U << 8);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF1 = (1U << 6);  ///< Stream x FIFO error interrupt flag (x=3..0)
        constexpr uint32_t TCIF0 = (1U << 5);  ///< Stream x transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t HTIF0 = (1U << 4);  ///< Stream x half transfer interrupt flag (x=3..0)
        constexpr uint32_t TEIF0 = (1U << 3);  ///< Stream x transfer error interrupt flag (x=3..0)
        constexpr uint32_t DMEIF0 = (1U << 2);  ///< Stream x direct mode error interrupt flag (x=3..0)
        constexpr uint32_t FEIF0 = (1U << 0);  ///< Stream x FIFO error interrupt flag (x=3..0)
    }

    /// HISR Register bits
    namespace hisr_bits {
        constexpr uint32_t TCIF7 = (1U << 27);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF7 = (1U << 26);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF7 = (1U << 25);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF7 = (1U << 24);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF7 = (1U << 22);  ///< Stream x FIFO error interrupt flag (x=7..4)
        constexpr uint32_t TCIF6 = (1U << 21);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF6 = (1U << 20);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF6 = (1U << 19);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF6 = (1U << 18);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF6 = (1U << 16);  ///< Stream x FIFO error interrupt flag (x=7..4)
        constexpr uint32_t TCIF5 = (1U << 11);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF5 = (1U << 10);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF5 = (1U << 9);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF5 = (1U << 8);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF5 = (1U << 6);  ///< Stream x FIFO error interrupt flag (x=7..4)
        constexpr uint32_t TCIF4 = (1U << 5);  ///< Stream x transfer complete interrupt flag (x=7..4)
        constexpr uint32_t HTIF4 = (1U << 4);  ///< Stream x half transfer interrupt flag (x=7..4)
        constexpr uint32_t TEIF4 = (1U << 3);  ///< Stream x transfer error interrupt flag (x=7..4)
        constexpr uint32_t DMEIF4 = (1U << 2);  ///< Stream x direct mode error interrupt flag (x=7..4)
        constexpr uint32_t FEIF4 = (1U << 0);  ///< Stream x FIFO error interrupt flag (x=7..4)
    }

    /// LIFCR Register bits
    namespace lifcr_bits {
        constexpr uint32_t CTCIF3 = (1U << 27);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF3 = (1U << 26);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF3 = (1U << 25);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF3 = (1U << 24);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF3 = (1U << 22);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
        constexpr uint32_t CTCIF2 = (1U << 21);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF2 = (1U << 20);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF2 = (1U << 19);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF2 = (1U << 18);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF2 = (1U << 16);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
        constexpr uint32_t CTCIF1 = (1U << 11);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF1 = (1U << 10);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF1 = (1U << 9);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF1 = (1U << 8);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF1 = (1U << 6);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
        constexpr uint32_t CTCIF0 = (1U << 5);  ///< Stream x clear transfer complete interrupt flag (x = 3..0)
        constexpr uint32_t CHTIF0 = (1U << 4);  ///< Stream x clear half transfer interrupt flag (x = 3..0)
        constexpr uint32_t CTEIF0 = (1U << 3);  ///< Stream x clear transfer error interrupt flag (x = 3..0)
        constexpr uint32_t CDMEIF0 = (1U << 2);  ///< Stream x clear direct mode error interrupt flag (x = 3..0)
        constexpr uint32_t CFEIF0 = (1U << 0);  ///< Stream x clear FIFO error interrupt flag (x = 3..0)
    }

    /// HIFCR Register bits
    namespace hifcr_bits {
        constexpr uint32_t CTCIF7 = (1U << 27);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF7 = (1U << 25);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF7 = (1U << 24);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF7 = (1U << 22);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF6 = (1U << 20);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF6 = (1U << 19);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF6 = (1U << 18);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF6 = (1U << 16);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
        constexpr uint32_t CTCIF5 = (1U << 11);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF5 = (1U << 10);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF5 = (1U << 9);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF5 = (1U << 8);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF5 = (1U << 6);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
        constexpr uint32_t CTCIF4 = (1U << 5);  ///< Stream x clear transfer complete interrupt flag (x = 7..4)
        constexpr uint32_t CHTIF4 = (1U << 4);  ///< Stream x clear half transfer interrupt flag (x = 7..4)
        constexpr uint32_t CTEIF4 = (1U << 3);  ///< Stream x clear transfer error interrupt flag (x = 7..4)
        constexpr uint32_t CDMEIF4 = (1U << 2);  ///< Stream x clear direct mode error interrupt flag (x = 7..4)
        constexpr uint32_t CFEIF4 = (1U << 0);  ///< Stream x clear FIFO error interrupt flag (x = 7..4)
    }

    /// S0CR Register bits
    namespace s0cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S0NDTR Register bits
    namespace s0ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S0PAR Register bits
    namespace s0par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S0M0AR Register bits
    namespace s0m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S0M1AR Register bits
    namespace s0m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S0FCR Register bits
    namespace s0fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S1CR Register bits
    namespace s1cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S1NDTR Register bits
    namespace s1ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S1PAR Register bits
    namespace s1par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S1M0AR Register bits
    namespace s1m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S1M1AR Register bits
    namespace s1m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S1FCR Register bits
    namespace s1fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S2CR Register bits
    namespace s2cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S2NDTR Register bits
    namespace s2ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S2PAR Register bits
    namespace s2par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S2M0AR Register bits
    namespace s2m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S2M1AR Register bits
    namespace s2m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S2FCR Register bits
    namespace s2fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S3CR Register bits
    namespace s3cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S3NDTR Register bits
    namespace s3ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S3PAR Register bits
    namespace s3par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S3M0AR Register bits
    namespace s3m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S3M1AR Register bits
    namespace s3m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S3FCR Register bits
    namespace s3fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S4CR Register bits
    namespace s4cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S4NDTR Register bits
    namespace s4ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S4PAR Register bits
    namespace s4par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S4M0AR Register bits
    namespace s4m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S4M1AR Register bits
    namespace s4m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S4FCR Register bits
    namespace s4fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S5CR Register bits
    namespace s5cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S5NDTR Register bits
    namespace s5ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S5PAR Register bits
    namespace s5par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S5M0AR Register bits
    namespace s5m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S5M1AR Register bits
    namespace s5m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S5FCR Register bits
    namespace s5fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S6CR Register bits
    namespace s6cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S6NDTR Register bits
    namespace s6ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S6PAR Register bits
    namespace s6par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S6M0AR Register bits
    namespace s6m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S6M1AR Register bits
    namespace s6m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S6FCR Register bits
    namespace s6fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

    /// S7CR Register bits
    namespace s7cr_bits {
        constexpr uint32_t CHSEL = (3 << 25);  ///< Channel selection
        constexpr uint32_t MBURST = (2 << 23);  ///< Memory burst transfer configuration
        constexpr uint32_t PBURST = (2 << 21);  ///< Peripheral burst transfer configuration
        constexpr uint32_t ACK = (1U << 20);  ///< ACK
        constexpr uint32_t CT = (1U << 19);  ///< Current target (only in double buffer mode)
        constexpr uint32_t DBM = (1U << 18);  ///< Double buffer mode
        constexpr uint32_t PL = (2 << 16);  ///< Priority level
        constexpr uint32_t PINCOS = (1U << 15);  ///< Peripheral increment offset size
        constexpr uint32_t MSIZE = (2 << 13);  ///< Memory data size
        constexpr uint32_t PSIZE = (2 << 11);  ///< Peripheral data size
        constexpr uint32_t MINC = (1U << 10);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 9);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 8);  ///< Circular mode
        constexpr uint32_t DIR = (2 << 6);  ///< Data transfer direction
        constexpr uint32_t PFCTRL = (1U << 5);  ///< Peripheral flow controller
        constexpr uint32_t TCIE = (1U << 4);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 3);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 2);  ///< Transfer error interrupt enable
        constexpr uint32_t DMEIE = (1U << 1);  ///< Direct mode error interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Stream enable / flag stream ready when read low
    }

    /// S7NDTR Register bits
    namespace s7ndtr_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// S7PAR Register bits
    namespace s7par_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// S7M0AR Register bits
    namespace s7m0ar_bits {
        constexpr uint32_t M0A = (32 << 0);  ///< Memory 0 address
    }

    /// S7M1AR Register bits
    namespace s7m1ar_bits {
        constexpr uint32_t M1A = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// S7FCR Register bits
    namespace s7fcr_bits {
        constexpr uint32_t FEIE = (1U << 7);  ///< FIFO error interrupt enable
        constexpr uint32_t FS = (3 << 3);  ///< FIFO status
        constexpr uint32_t DMDIS = (1U << 2);  ///< Direct mode disable
        constexpr uint32_t FTH = (2 << 0);  ///< FIFO threshold selection
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40023800;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - clock control register
        volatile uint32_t PLLCFGR;  ///< Offset: 0x04 - PLL configuration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - clock configuration register
        volatile uint32_t CIR;  ///< Offset: 0x0C - clock interrupt register
        volatile uint32_t AHB1RSTR;  ///< Offset: 0x10 - AHB1 peripheral reset register
        volatile uint32_t AHB2RSTR;  ///< Offset: 0x14 - AHB2 peripheral reset register
        volatile uint32_t AHB3RSTR;  ///< Offset: 0x18 - AHB3 peripheral reset register
        volatile uint32_t APB1RSTR;  ///< Offset: 0x20 - APB1 peripheral reset register
        volatile uint32_t APB2RSTR;  ///< Offset: 0x24 - APB2 peripheral reset register
        volatile uint32_t AHB1ENR;  ///< Offset: 0x30 - AHB1 peripheral clock register
        volatile uint32_t AHB2ENR;  ///< Offset: 0x34 - AHB2 peripheral clock enable register
        volatile uint32_t AHB3ENR;  ///< Offset: 0x38 - AHB3 peripheral clock enable register
        volatile uint32_t APB1ENR;  ///< Offset: 0x40 - APB1 peripheral clock enable register
        volatile uint32_t APB2ENR;  ///< Offset: 0x44 - APB2 peripheral clock enable register
        volatile uint32_t AHB1LPENR;  ///< Offset: 0x50 - AHB1 peripheral clock enable in low power mode register
        volatile uint32_t AHB2LPENR;  ///< Offset: 0x54 - AHB2 peripheral clock enable in low power mode register
        volatile uint32_t AHB3LPENR;  ///< Offset: 0x58 - AHB3 peripheral clock enable in low power mode register
        volatile uint32_t APB1LPENR;  ///< Offset: 0x60 - APB1 peripheral clock enable in low power mode register
        volatile uint32_t APB2LPENR;  ///< Offset: 0x64 - APB2 peripheral clock enabled in low power mode register
        volatile uint32_t BDCR;  ///< Offset: 0x70 - Backup domain control register
        volatile uint32_t CSR;  ///< Offset: 0x74 - clock control & status register
        volatile uint32_t SSCGR;  ///< Offset: 0x80 - spread spectrum clock generation register
        volatile uint32_t PLLI2SCFGR;  ///< Offset: 0x84 - PLLI2S configuration register
        volatile uint32_t PLLSAICFGR;  ///< Offset: 0x88 - PLL configuration register
        volatile uint32_t DCKCFGR;  ///< Offset: 0x8C - Dedicated Clock Configuration Register
        volatile uint32_t CKGATENR;  ///< Offset: 0x90 - clocks gated enable register
        volatile uint32_t DCKCFGR2;  ///< Offset: 0x94 - dedicated clocks configuration register 2
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PLLI2SRDY = (1U << 27);  ///< PLLI2S clock ready flag
        constexpr uint32_t PLLI2SON = (1U << 26);  ///< PLLI2S enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< Main PLL (PLL) clock ready flag
        constexpr uint32_t PLLON = (1U << 24);  ///< Main PLL (PLL) enable
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE clock bypass
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSICAL = (8 << 8);  ///< Internal high-speed clock calibration
        constexpr uint32_t HSITRIM = (5 << 3);  ///< Internal high-speed clock trimming
        constexpr uint32_t HSIRDY = (1U << 1);  ///< Internal high-speed clock ready flag
        constexpr uint32_t HSION = (1U << 0);  ///< Internal high-speed clock enable
    }

    /// PLLCFGR Register bits
    namespace pllcfgr_bits {
        constexpr uint32_t PLLQ3 = (1U << 27);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLQ2 = (1U << 26);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLQ1 = (1U << 25);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLQ0 = (1U << 24);  ///< Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        constexpr uint32_t PLLSRC = (1U << 22);  ///< Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
        constexpr uint32_t PLLP1 = (1U << 17);  ///< Main PLL (PLL) division factor for main system clock
        constexpr uint32_t PLLP0 = (1U << 16);  ///< Main PLL (PLL) division factor for main system clock
        constexpr uint32_t PLLN8 = (1U << 14);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN7 = (1U << 13);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN6 = (1U << 12);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN5 = (1U << 11);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN4 = (1U << 10);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN3 = (1U << 9);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN2 = (1U << 8);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN1 = (1U << 7);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLN0 = (1U << 6);  ///< Main PLL (PLL) multiplication factor for VCO
        constexpr uint32_t PLLM5 = (1U << 5);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM4 = (1U << 4);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM3 = (1U << 3);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM2 = (1U << 2);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM1 = (1U << 1);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLM0 = (1U << 0);  ///< Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCO2 = (2 << 30);  ///< Microcontroller clock output 2
        constexpr uint32_t MCO2PRE = (3 << 27);  ///< MCO2 prescaler
        constexpr uint32_t MCO1PRE = (3 << 24);  ///< MCO1 prescaler
        constexpr uint32_t I2SSRC = (1U << 23);  ///< I2S clock selection
        constexpr uint32_t MCO1 = (2 << 21);  ///< Microcontroller clock output 1
        constexpr uint32_t RTCPRE = (5 << 16);  ///< HSE division factor for RTC clock
        constexpr uint32_t PPRE2 = (3 << 13);  ///< APB high-speed prescaler (APB2)
        constexpr uint32_t PPRE1 = (3 << 10);  ///< APB Low speed prescaler (APB1)
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler
        constexpr uint32_t SWS1 = (1U << 3);  ///< System clock switch status
        constexpr uint32_t SWS0 = (1U << 2);  ///< System clock switch status
        constexpr uint32_t SW1 = (1U << 1);  ///< System clock switch
        constexpr uint32_t SW0 = (1U << 0);  ///< System clock switch
    }

    /// CIR Register bits
    namespace cir_bits {
        constexpr uint32_t CSSC = (1U << 23);  ///< Clock security system interrupt clear
        constexpr uint32_t PLLSAIRDYC = (1U << 22);  ///< PLLSAI Ready Interrupt Clear
        constexpr uint32_t PLLI2SRDYC = (1U << 21);  ///< PLLI2S ready interrupt clear
        constexpr uint32_t PLLRDYC = (1U << 20);  ///< Main PLL(PLL) ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 19);  ///< HSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 18);  ///< HSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 17);  ///< LSE ready interrupt clear
        constexpr uint32_t LSIRDYC = (1U << 16);  ///< LSI ready interrupt clear
        constexpr uint32_t PLLSAIRDYIE = (1U << 14);  ///< PLLSAI Ready Interrupt Enable
        constexpr uint32_t PLLI2SRDYIE = (1U << 13);  ///< PLLI2S ready interrupt enable
        constexpr uint32_t PLLRDYIE = (1U << 12);  ///< Main PLL (PLL) ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 11);  ///< HSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 10);  ///< HSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 9);  ///< LSE ready interrupt enable
        constexpr uint32_t LSIRDYIE = (1U << 8);  ///< LSI ready interrupt enable
        constexpr uint32_t CSSF = (1U << 7);  ///< Clock security system interrupt flag
        constexpr uint32_t PLLSAIRDYF = (1U << 6);  ///< PLLSAI ready interrupt flag
        constexpr uint32_t PLLI2SRDYF = (1U << 5);  ///< PLLI2S ready interrupt flag
        constexpr uint32_t PLLRDYF = (1U << 4);  ///< Main PLL (PLL) ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 3);  ///< HSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 2);  ///< HSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
    }

    /// AHB1RSTR Register bits
    namespace ahb1rstr_bits {
        constexpr uint32_t OTGHSRST = (1U << 29);  ///< USB OTG HS module reset
        constexpr uint32_t DMA2RST = (1U << 22);  ///< DMA2 reset
        constexpr uint32_t DMA1RST = (1U << 21);  ///< DMA2 reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< IO port H reset
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< IO port G reset
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< IO port F reset
        constexpr uint32_t GPIOERST = (1U << 4);  ///< IO port E reset
        constexpr uint32_t GPIODRST = (1U << 3);  ///< IO port D reset
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< IO port C reset
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< IO port B reset
        constexpr uint32_t GPIOARST = (1U << 0);  ///< IO port A reset
    }

    /// AHB2RSTR Register bits
    namespace ahb2rstr_bits {
        constexpr uint32_t OTGFSRST = (1U << 7);  ///< USB OTG FS module reset
        constexpr uint32_t DCMIRST = (1U << 0);  ///< Camera interface reset
    }

    /// AHB3RSTR Register bits
    namespace ahb3rstr_bits {
        constexpr uint32_t FMCRST = (1U << 0);  ///< Flexible memory controller module reset
        constexpr uint32_t QSPIRST = (1U << 1);  ///< QUADSPI module reset
    }

    /// APB1RSTR Register bits
    namespace apb1rstr_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 reset
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM4 reset
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 reset
        constexpr uint32_t TIM12RST = (1U << 6);  ///< TIM12 reset
        constexpr uint32_t TIM13RST = (1U << 7);  ///< TIM13 reset
        constexpr uint32_t TIM14RST = (1U << 8);  ///< TIM14 reset
        constexpr uint32_t WWDGRST = (1U << 11);  ///< Window watchdog reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI 2 reset
        constexpr uint32_t SPI3RST = (1U << 15);  ///< SPI 3 reset
        constexpr uint32_t SPDIFRST = (1U << 16);  ///< SPDIF-IN reset
        constexpr uint32_t UART2RST = (1U << 17);  ///< USART 2 reset
        constexpr uint32_t UART3RST = (1U << 18);  ///< USART 3 reset
        constexpr uint32_t UART4RST = (1U << 19);  ///< USART 4 reset
        constexpr uint32_t UART5RST = (1U << 20);  ///< USART 5 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C 1 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C 2 reset
        constexpr uint32_t I2C3RST = (1U << 23);  ///< I2C3 reset
        constexpr uint32_t I2CFMP1RST = (1U << 24);  ///< I2CFMP1 reset
        constexpr uint32_t CAN1RST = (1U << 25);  ///< CAN1 reset
        constexpr uint32_t CAN2RST = (1U << 26);  ///< CAN2 reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t DACRST = (1U << 29);  ///< DAC reset
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t TIM1RST = (1U << 0);  ///< TIM1 reset
        constexpr uint32_t TIM8RST = (1U << 1);  ///< TIM8 reset
        constexpr uint32_t USART1RST = (1U << 4);  ///< USART1 reset
        constexpr uint32_t USART6RST = (1U << 5);  ///< USART6 reset
        constexpr uint32_t ADCRST = (1U << 8);  ///< ADC interface reset (common to all ADCs)
        constexpr uint32_t SDIORST = (1U << 11);  ///< SDIO reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI 1 reset
        constexpr uint32_t SPI4RST = (1U << 13);  ///< SPI4 reset
        constexpr uint32_t SYSCFGRST = (1U << 14);  ///< System configuration controller reset
        constexpr uint32_t TIM9RST = (1U << 16);  ///< TIM9 reset
        constexpr uint32_t TIM10RST = (1U << 17);  ///< TIM10 reset
        constexpr uint32_t TIM11RST = (1U << 18);  ///< TIM11 reset
        constexpr uint32_t SAI1RST = (1U << 22);  ///< SAI1 reset
        constexpr uint32_t SAI2RST = (1U << 23);  ///< SAI2 reset
    }

    /// AHB1ENR Register bits
    namespace ahb1enr_bits {
        constexpr uint32_t OTGHSULPIEN = (1U << 30);  ///< USB OTG HSULPI clock enable
        constexpr uint32_t OTGHSEN = (1U << 29);  ///< USB OTG HS clock enable
        constexpr uint32_t DMA2EN = (1U << 22);  ///< DMA2 clock enable
        constexpr uint32_t DMA1EN = (1U << 21);  ///< DMA1 clock enable
        constexpr uint32_t BKPSRAMEN = (1U << 18);  ///< Backup SRAM interface clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< IO port H clock enable
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< IO port G clock enable
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< IO port F clock enable
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< IO port E clock enable
        constexpr uint32_t GPIODEN = (1U << 3);  ///< IO port D clock enable
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< IO port C clock enable
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< IO port B clock enable
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< IO port A clock enable
    }

    /// AHB2ENR Register bits
    namespace ahb2enr_bits {
        constexpr uint32_t OTGFSEN = (1U << 7);  ///< USB OTG FS clock enable
        constexpr uint32_t DCMIEN = (1U << 0);  ///< Camera interface enable
    }

    /// AHB3ENR Register bits
    namespace ahb3enr_bits {
        constexpr uint32_t FMCEN = (1U << 0);  ///< Flexible memory controller module clock enable
        constexpr uint32_t QSPIEN = (1U << 1);  ///< QUADSPI memory controller module clock enable
    }

    /// APB1ENR Register bits
    namespace apb1enr_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 clock enable
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 clock enable
        constexpr uint32_t TIM12EN = (1U << 6);  ///< TIM12 clock enable
        constexpr uint32_t TIM13EN = (1U << 7);  ///< TIM13 clock enable
        constexpr uint32_t TIM14EN = (1U << 8);  ///< TIM14 clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t SPI3EN = (1U << 15);  ///< SPI3 clock enable
        constexpr uint32_t SPDIFEN = (1U << 16);  ///< SPDIF-IN clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART 2 clock enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 clock enable
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 clock enable
        constexpr uint32_t I2CFMP1EN = (1U << 24);  ///< I2CFMP1 clock enable
        constexpr uint32_t CAN1EN = (1U << 25);  ///< CAN 1 clock enable
        constexpr uint32_t CAN2EN = (1U << 26);  ///< CAN 2 clock enable
        constexpr uint32_t CEC = (1U << 27);  ///< CEC interface clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t DACEN = (1U << 29);  ///< DAC interface clock enable
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 0);  ///< TIM1 clock enable
        constexpr uint32_t TIM8EN = (1U << 1);  ///< TIM8 clock enable
        constexpr uint32_t USART1EN = (1U << 4);  ///< USART1 clock enable
        constexpr uint32_t USART6EN = (1U << 5);  ///< USART6 clock enable
        constexpr uint32_t ADC1EN = (1U << 8);  ///< ADC1 clock enable
        constexpr uint32_t ADC2EN = (1U << 9);  ///< ADC2 clock enable
        constexpr uint32_t ADC3EN = (1U << 10);  ///< ADC3 clock enable
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SDIO clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t SPI4ENR = (1U << 13);  ///< SPI4 clock enable
        constexpr uint32_t SYSCFGEN = (1U << 14);  ///< System configuration controller clock enable
        constexpr uint32_t TIM9EN = (1U << 16);  ///< TIM9 clock enable
        constexpr uint32_t TIM10EN = (1U << 17);  ///< TIM10 clock enable
        constexpr uint32_t TIM11EN = (1U << 18);  ///< TIM11 clock enable
        constexpr uint32_t SAI1EN = (1U << 22);  ///< SAI1 clock enable
        constexpr uint32_t SAI2EN = (1U << 23);  ///< SAI2 clock enable
    }

    /// AHB1LPENR Register bits
    namespace ahb1lpenr_bits {
        constexpr uint32_t GPIOALPEN = (1U << 0);  ///< IO port A clock enable during sleep mode
        constexpr uint32_t GPIOBLPEN = (1U << 1);  ///< IO port B clock enable during Sleep mode
        constexpr uint32_t GPIOCLPEN = (1U << 2);  ///< IO port C clock enable during Sleep mode
        constexpr uint32_t GPIODLPEN = (1U << 3);  ///< IO port D clock enable during Sleep mode
        constexpr uint32_t GPIOELPEN = (1U << 4);  ///< IO port E clock enable during Sleep mode
        constexpr uint32_t GPIOFLPEN = (1U << 5);  ///< IO port F clock enable during Sleep mode
        constexpr uint32_t GPIOGLPEN = (1U << 6);  ///< IO port G clock enable during Sleep mode
        constexpr uint32_t GPIOHLPEN = (1U << 7);  ///< IO port H clock enable during Sleep mode
        constexpr uint32_t CRCLPEN = (1U << 12);  ///< CRC clock enable during Sleep mode
        constexpr uint32_t FLITFLPEN = (1U << 15);  ///< Flash interface clock enable during Sleep mode
        constexpr uint32_t SRAM1LPEN = (1U << 16);  ///< SRAM 1interface clock enable during Sleep mode
        constexpr uint32_t SRAM2LPEN = (1U << 17);  ///< SRAM 2 interface clock enable during Sleep mode
        constexpr uint32_t BKPSRAMLPEN = (1U << 18);  ///< Backup SRAM interface clock enable during Sleep mode
        constexpr uint32_t DMA1LPEN = (1U << 21);  ///< DMA1 clock enable during Sleep mode
        constexpr uint32_t DMA2LPEN = (1U << 22);  ///< DMA2 clock enable during Sleep mode
        constexpr uint32_t OTGHSLPEN = (1U << 29);  ///< USB OTG HS clock enable during Sleep mode
        constexpr uint32_t OTGHSULPILPEN = (1U << 30);  ///< USB OTG HS ULPI clock enable during Sleep mode
    }

    /// AHB2LPENR Register bits
    namespace ahb2lpenr_bits {
        constexpr uint32_t OTGFSLPEN = (1U << 7);  ///< USB OTG FS clock enable during Sleep mode
        constexpr uint32_t DCMILPEN = (1U << 0);  ///< Camera interface enable during Sleep mode
    }

    /// AHB3LPENR Register bits
    namespace ahb3lpenr_bits {
        constexpr uint32_t FMCLPEN = (1U << 0);  ///< Flexible memory controller module clock enable during Sleep mode
        constexpr uint32_t QSPILPEN = (1U << 1);  ///< QUADSPI memory controller module clock enable during Sleep mode
    }

    /// APB1LPENR Register bits
    namespace apb1lpenr_bits {
        constexpr uint32_t TIM2LPEN = (1U << 0);  ///< TIM2 clock enable during Sleep mode
        constexpr uint32_t TIM3LPEN = (1U << 1);  ///< TIM3 clock enable during Sleep mode
        constexpr uint32_t TIM4LPEN = (1U << 2);  ///< TIM4 clock enable during Sleep mode
        constexpr uint32_t TIM5LPEN = (1U << 3);  ///< TIM5 clock enable during Sleep mode
        constexpr uint32_t TIM6LPEN = (1U << 4);  ///< TIM6 clock enable during Sleep mode
        constexpr uint32_t TIM7LPEN = (1U << 5);  ///< TIM7 clock enable during Sleep mode
        constexpr uint32_t TIM12LPEN = (1U << 6);  ///< TIM12 clock enable during Sleep mode
        constexpr uint32_t TIM13LPEN = (1U << 7);  ///< TIM13 clock enable during Sleep mode
        constexpr uint32_t TIM14LPEN = (1U << 8);  ///< TIM14 clock enable during Sleep mode
        constexpr uint32_t WWDGLPEN = (1U << 11);  ///< Window watchdog clock enable during Sleep mode
        constexpr uint32_t SPI2LPEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode
        constexpr uint32_t SPI3LPEN = (1U << 15);  ///< SPI3 clock enable during Sleep mode
        constexpr uint32_t SPDIFLPEN = (1U << 16);  ///< SPDIF clock enable during Sleep mode
        constexpr uint32_t USART2LPEN = (1U << 17);  ///< USART2 clock enable during Sleep mode
        constexpr uint32_t USART3LPEN = (1U << 18);  ///< USART3 clock enable during Sleep mode
        constexpr uint32_t UART4LPEN = (1U << 19);  ///< UART4 clock enable during Sleep mode
        constexpr uint32_t UART5LPEN = (1U << 20);  ///< UART5 clock enable during Sleep mode
        constexpr uint32_t I2C1LPEN = (1U << 21);  ///< I2C1 clock enable during Sleep mode
        constexpr uint32_t I2C2LPEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode
        constexpr uint32_t I2C3LPEN = (1U << 23);  ///< I2C3 clock enable during Sleep mode
        constexpr uint32_t I2CFMP1LPEN = (1U << 24);  ///< I2CFMP1 clock enable during Sleep mode
        constexpr uint32_t CAN1LPEN = (1U << 25);  ///< CAN 1 clock enable during Sleep mode
        constexpr uint32_t CAN2LPEN = (1U << 26);  ///< CAN 2 clock enable during Sleep mode
        constexpr uint32_t CECLPEN = (1U << 27);  ///< CEC clock enable during Sleep mode
        constexpr uint32_t PWRLPEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
        constexpr uint32_t DACLPEN = (1U << 29);  ///< DAC interface clock enable during Sleep mode
    }

    /// APB2LPENR Register bits
    namespace apb2lpenr_bits {
        constexpr uint32_t TIM1LPEN = (1U << 0);  ///< TIM1 clock enable during Sleep mode
        constexpr uint32_t TIM8LPEN = (1U << 1);  ///< TIM8 clock enable during Sleep mode
        constexpr uint32_t USART1LPEN = (1U << 4);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t USART6LPEN = (1U << 5);  ///< USART6 clock enable during Sleep mode
        constexpr uint32_t ADC1LPEN = (1U << 8);  ///< ADC1 clock enable during Sleep mode
        constexpr uint32_t ADC2LPEN = (1U << 9);  ///< ADC2 clock enable during Sleep mode
        constexpr uint32_t ADC3LPEN = (1U << 10);  ///< ADC 3 clock enable during Sleep mode
        constexpr uint32_t SDIOLPEN = (1U << 11);  ///< SDIO clock enable during Sleep mode
        constexpr uint32_t SPI1LPEN = (1U << 12);  ///< SPI 1 clock enable during Sleep mode
        constexpr uint32_t SPI4LPEN = (1U << 13);  ///< SPI 4 clock enable during Sleep mode
        constexpr uint32_t SYSCFGLPEN = (1U << 14);  ///< System configuration controller clock enable during Sleep mode
        constexpr uint32_t TIM9LPEN = (1U << 16);  ///< TIM9 clock enable during sleep mode
        constexpr uint32_t TIM10LPEN = (1U << 17);  ///< TIM10 clock enable during Sleep mode
        constexpr uint32_t TIM11LPEN = (1U << 18);  ///< TIM11 clock enable during Sleep mode
        constexpr uint32_t SAI1LPEN = (1U << 22);  ///< SAI1 clock enable
        constexpr uint32_t SAI2LPEN = (1U << 23);  ///< SAI2 clock enable
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t LSEMOD = (1U << 3);  ///< External low-speed oscillator mode
        constexpr uint32_t LSEBYP = (1U << 2);  ///< External low-speed oscillator bypass
        constexpr uint32_t LSERDY = (1U << 1);  ///< External low-speed oscillator ready
        constexpr uint32_t LSEON = (1U << 0);  ///< External low-speed oscillator enable
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t WDGRSTF = (1U << 29);  ///< Independent watchdog reset flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t PORRSTF = (1U << 27);  ///< POR/PDR reset flag
        constexpr uint32_t PADRSTF = (1U << 26);  ///< PIN reset flag
        constexpr uint32_t BORRSTF = (1U << 25);  ///< BOR reset flag
        constexpr uint32_t RMVF = (1U << 24);  ///< Remove reset flag
        constexpr uint32_t LSIRDY = (1U << 1);  ///< Internal low-speed oscillator ready
        constexpr uint32_t LSION = (1U << 0);  ///< Internal low-speed oscillator enable
    }

    /// SSCGR Register bits
    namespace sscgr_bits {
        constexpr uint32_t SSCGEN = (1U << 31);  ///< Spread spectrum modulation enable
        constexpr uint32_t SPREADSEL = (1U << 30);  ///< Spread Select
        constexpr uint32_t INCSTEP = (15 << 13);  ///< Incrementation step
        constexpr uint32_t MODPER = (13 << 0);  ///< Modulation period
    }

    /// PLLI2SCFGR Register bits
    namespace plli2scfgr_bits {
        constexpr uint32_t PLLI2SM = (6 << 0);  ///< Division factor for audio PLL (PLLI2S) input clock
        constexpr uint32_t PLLI2SN = (9 << 6);  ///< PLLI2S multiplication factor for VCO
        constexpr uint32_t PLLI2SP = (2 << 16);  ///< PLLI2S division factor for SPDIF-IN clock
        constexpr uint32_t PLLI2SQ = (4 << 24);  ///< PLLI2S division factor for SAI1 clock
        constexpr uint32_t PLLI2SR = (3 << 28);  ///< PLLI2S division factor for I2S clocks
    }

    /// PLLSAICFGR Register bits
    namespace pllsaicfgr_bits {
        constexpr uint32_t PLLSAIM = (6 << 0);  ///< Division factor for audio PLLSAI input clock
        constexpr uint32_t PLLSAIN = (9 << 6);  ///< PLLSAI division factor for VCO
        constexpr uint32_t PLLSAIP = (2 << 16);  ///< PLLSAI division factor for 48 MHz clock
        constexpr uint32_t PLLSAIQ = (4 << 24);  ///< PLLSAI division factor for SAIs clock
    }

    /// DCKCFGR Register bits
    namespace dckcfgr_bits {
        constexpr uint32_t PLLI2SDIVQ = (5 << 0);  ///< PLLI2S division factor for SAIs clock
        constexpr uint32_t PLLSAIDIVQ = (5 << 8);  ///< PLLSAI division factor for SAIs clock
        constexpr uint32_t SAI1SRC = (2 << 20);  ///< SAI1 clock source selection
        constexpr uint32_t SAI2SRC = (2 << 22);  ///< SAI2 clock source selection
        constexpr uint32_t TIMPRE = (1U << 24);  ///< Timers clocks prescalers selection
        constexpr uint32_t I2S1SRC = (2 << 25);  ///< I2S APB1 clock source selection
        constexpr uint32_t I2S2SRC = (2 << 27);  ///< I2S APB2 clock source selection
    }

    /// CKGATENR Register bits
    namespace ckgatenr_bits {
        constexpr uint32_t AHB2APB1_CKEN = (1U << 0);  ///< AHB to APB1 Bridge clock enable
        constexpr uint32_t AHB2APB2_CKEN = (1U << 1);  ///< AHB to APB2 Bridge clock enable
        constexpr uint32_t CM4DBG_CKEN = (1U << 2);  ///< Cortex M4 ETM clock enable
        constexpr uint32_t SPARE_CKEN = (1U << 3);  ///< Spare clock enable
        constexpr uint32_t SRAM_CKEN = (1U << 4);  ///< SRQAM controller clock enable
        constexpr uint32_t FLITF_CKEN = (1U << 5);  ///< Flash Interface clock enable
        constexpr uint32_t RCC_CKEN = (1U << 6);  ///< RCC clock enable
    }

    /// DCKCFGR2 Register bits
    namespace dckcfgr2_bits {
        constexpr uint32_t FMPI2C1SEL = (2 << 22);  ///< I2C4 kernel clock source selection
        constexpr uint32_t CECSEL = (1U << 26);  ///< HDMI CEC clock source selection
        constexpr uint32_t CK48MSEL = (1U << 27);  ///< SDIO/USBFS/HS clock selection
        constexpr uint32_t SDIOSEL = (1U << 28);  ///< SDIO clock selection
        constexpr uint32_t SPDIFSEL = (1U << 29);  ///< SPDIF clock selection
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOH_BASE = 0x40021C00;
    constexpr uint32_t GPIOG_BASE = 0x40021800;
    constexpr uint32_t GPIOF_BASE = 0x40021400;
    constexpr uint32_t GPIOE_BASE = 0x40021000;
    constexpr uint32_t GPIOD_BASE = 0x40020C00;
    constexpr uint32_t GPIOC_BASE = 0x40020800;
    constexpr uint32_t GPIOB_BASE = 0x40020400;
    constexpr uint32_t GPIOA_BASE = 0x40020000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
    };

    /// Peripheral instances
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFRL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFRH15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40013800;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t MEMRM;  ///< Offset: 0x00 - memory remap register
        volatile uint32_t PMC;  ///< Offset: 0x04 - peripheral mode configuration register
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
        volatile uint32_t CMPCR;  ///< Offset: 0x20 - Compensation cell control register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// MEMRM Register bits
    namespace memrm_bits {
        constexpr uint32_t MEM_MODE = (3 << 0);  ///< Memory mapping selection
        constexpr uint32_t FB_MODE = (1U << 8);  ///< Flash bank mode selection
        constexpr uint32_t SWP_FMC = (2 << 10);  ///< FMC memory mapping swap
    }

    /// PMC Register bits
    namespace pmc_bits {
        constexpr uint32_t MII_RMII_SEL = (1U << 23);  ///< Ethernet PHY interface selection
        constexpr uint32_t ADC1DC2 = (1U << 16);  ///< ADC1DC2
        constexpr uint32_t ADC2DC2 = (1U << 17);  ///< ADC2DC2
        constexpr uint32_t ADC3DC2 = (1U << 18);  ///< ADC3DC2
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI x configuration (x = 0 to 3)
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI x configuration (x = 4 to 7)
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI10
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI x configuration (x = 8 to 11)
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI x configuration (x = 12 to 15)
    }

    /// CMPCR Register bits
    namespace cmpcr_bits {
        constexpr uint32_t READY = (1U << 8);  ///< READY
        constexpr uint32_t CMP_PD = (1U << 0);  ///< Compensation cell power-down
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SPI3_BASE = 0x40003C00;
    constexpr uint32_t SPI4_BASE = 0x40013400;
    constexpr uint32_t QUADSPI_BASE = 0xA0001000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - I2S configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - I2S prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SPI4 = reinterpret_cast<Registers*>(SPI4_BASE);
    inline Registers* QUADSPI = reinterpret_cast<Registers*>(QUADSPI_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
        constexpr uint32_t I2SE = (1U << 10);  ///< I2S Enable
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2S standard selection
        constexpr uint32_t CKPOL = (1U << 3);  ///< Steady state clock polarity
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2S Linear prescaler
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x40012000;
    constexpr uint32_t ADC2_BASE = 0x40012100;
    constexpr uint32_t ADC3_BASE = 0x40012200;
    constexpr uint32_t C_ADC_BASE = 0x40012300;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - status register
        volatile uint32_t CR1;  ///< Offset: 0x04 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x08 - control register 2
        volatile uint32_t SMPR1;  ///< Offset: 0x0C - sample time register 1
        volatile uint32_t SMPR2;  ///< Offset: 0x10 - sample time register 2
        volatile uint32_t JOFR1;  ///< Offset: 0x14 - injected channel data offset register x
        volatile uint32_t JOFR2;  ///< Offset: 0x18 - injected channel data offset register x
        volatile uint32_t JOFR3;  ///< Offset: 0x1C - injected channel data offset register x
        volatile uint32_t JOFR4;  ///< Offset: 0x20 - injected channel data offset register x
        volatile uint32_t HTR;  ///< Offset: 0x24 - watchdog higher threshold register
        volatile uint32_t LTR;  ///< Offset: 0x28 - watchdog lower threshold register
        volatile uint32_t SQR1;  ///< Offset: 0x2C - regular sequence register 1
        volatile uint32_t SQR2;  ///< Offset: 0x30 - regular sequence register 2
        volatile uint32_t SQR3;  ///< Offset: 0x34 - regular sequence register 3
        volatile uint32_t JSQR;  ///< Offset: 0x38 - injected sequence register
        volatile uint32_t JDR1;  ///< Offset: 0x3C - injected data register x
        volatile uint32_t JDR2;  ///< Offset: 0x40 - injected data register x
        volatile uint32_t JDR3;  ///< Offset: 0x44 - injected data register x
        volatile uint32_t JDR4;  ///< Offset: 0x48 - injected data register x
        volatile uint32_t DR;  ///< Offset: 0x4C - regular data register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC3 = reinterpret_cast<Registers*>(ADC3_BASE);
    inline Registers* C_ADC = reinterpret_cast<Registers*>(C_ADC_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t OVR = (1U << 5);  ///< Overrun
        constexpr uint32_t STRT = (1U << 4);  ///< Regular channel start flag
        constexpr uint32_t JSTRT = (1U << 3);  ///< Injected channel start flag
        constexpr uint32_t JEOC = (1U << 2);  ///< Injected channel end of conversion
        constexpr uint32_t EOC = (1U << 1);  ///< Regular channel end of conversion
        constexpr uint32_t AWD = (1U << 0);  ///< Analog watchdog flag
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t OVRIE = (1U << 26);  ///< Overrun interrupt enable
        constexpr uint32_t RES = (2 << 24);  ///< Resolution
        constexpr uint32_t AWDEN = (1U << 23);  ///< Analog watchdog enable on regular channels
        constexpr uint32_t JAWDEN = (1U << 22);  ///< Analog watchdog enable on injected channels
        constexpr uint32_t DISCNUM = (3 << 13);  ///< Discontinuous mode channel count
        constexpr uint32_t JDISCEN = (1U << 12);  ///< Discontinuous mode on injected channels
        constexpr uint32_t DISCEN = (1U << 11);  ///< Discontinuous mode on regular channels
        constexpr uint32_t JAUTO = (1U << 10);  ///< Automatic injected group conversion
        constexpr uint32_t AWDSGL = (1U << 9);  ///< Enable the watchdog on a single channel in scan mode
        constexpr uint32_t SCAN = (1U << 8);  ///< Scan mode
        constexpr uint32_t JEOCIE = (1U << 7);  ///< Interrupt enable for injected channels
        constexpr uint32_t AWDIE = (1U << 6);  ///< Analog watchdog interrupt enable
        constexpr uint32_t EOCIE = (1U << 5);  ///< Interrupt enable for EOC
        constexpr uint32_t AWDCH = (5 << 0);  ///< Analog watchdog channel select bits
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t SWSTART = (1U << 30);  ///< Start conversion of regular channels
        constexpr uint32_t EXTEN = (2 << 28);  ///< External trigger enable for regular channels
        constexpr uint32_t EXTSEL = (4 << 24);  ///< External event select for regular group
        constexpr uint32_t JSWSTART = (1U << 22);  ///< Start conversion of injected channels
        constexpr uint32_t JEXTEN = (2 << 20);  ///< External trigger enable for injected channels
        constexpr uint32_t JEXTSEL = (4 << 16);  ///< External event select for injected group
        constexpr uint32_t ALIGN = (1U << 11);  ///< Data alignment
        constexpr uint32_t EOCS = (1U << 10);  ///< End of conversion selection
        constexpr uint32_t DDS = (1U << 9);  ///< DMA disable selection (for single ADC mode)
        constexpr uint32_t DMA = (1U << 8);  ///< Direct memory access mode (for single ADC mode)
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous conversion
        constexpr uint32_t ADON = (1U << 0);  ///< A/D Converter ON / OFF
    }

    /// SMPR1 Register bits
    namespace smpr1_bits {
        constexpr uint32_t SMPx_x = (32 << 0);  ///< Sample time bits
    }

    /// SMPR2 Register bits
    namespace smpr2_bits {
        constexpr uint32_t SMPx_x = (32 << 0);  ///< Sample time bits
    }

    /// JOFR1 Register bits
    namespace jofr1_bits {
        constexpr uint32_t JOFFSET1 = (12 << 0);  ///< Data offset for injected channel x
    }

    /// JOFR2 Register bits
    namespace jofr2_bits {
        constexpr uint32_t JOFFSET2 = (12 << 0);  ///< Data offset for injected channel x
    }

    /// JOFR3 Register bits
    namespace jofr3_bits {
        constexpr uint32_t JOFFSET3 = (12 << 0);  ///< Data offset for injected channel x
    }

    /// JOFR4 Register bits
    namespace jofr4_bits {
        constexpr uint32_t JOFFSET4 = (12 << 0);  ///< Data offset for injected channel x
    }

    /// HTR Register bits
    namespace htr_bits {
        constexpr uint32_t HT = (12 << 0);  ///< Analog watchdog higher threshold
    }

    /// LTR Register bits
    namespace ltr_bits {
        constexpr uint32_t LT = (12 << 0);  ///< Analog watchdog lower threshold
    }

    /// SQR1 Register bits
    namespace sqr1_bits {
        constexpr uint32_t L = (4 << 20);  ///< Regular channel sequence length
        constexpr uint32_t SQ16 = (5 << 15);  ///< 16th conversion in regular sequence
        constexpr uint32_t SQ15 = (5 << 10);  ///< 15th conversion in regular sequence
        constexpr uint32_t SQ14 = (5 << 5);  ///< 14th conversion in regular sequence
        constexpr uint32_t SQ13 = (5 << 0);  ///< 13th conversion in regular sequence
    }

    /// SQR2 Register bits
    namespace sqr2_bits {
        constexpr uint32_t SQ12 = (5 << 25);  ///< 12th conversion in regular sequence
        constexpr uint32_t SQ11 = (5 << 20);  ///< 11th conversion in regular sequence
        constexpr uint32_t SQ10 = (5 << 15);  ///< 10th conversion in regular sequence
        constexpr uint32_t SQ9 = (5 << 10);  ///< 9th conversion in regular sequence
        constexpr uint32_t SQ8 = (5 << 5);  ///< 8th conversion in regular sequence
        constexpr uint32_t SQ7 = (5 << 0);  ///< 7th conversion in regular sequence
    }

    /// SQR3 Register bits
    namespace sqr3_bits {
        constexpr uint32_t SQ6 = (5 << 25);  ///< 6th conversion in regular sequence
        constexpr uint32_t SQ5 = (5 << 20);  ///< 5th conversion in regular sequence
        constexpr uint32_t SQ4 = (5 << 15);  ///< 4th conversion in regular sequence
        constexpr uint32_t SQ3 = (5 << 10);  ///< 3rd conversion in regular sequence
        constexpr uint32_t SQ2 = (5 << 5);  ///< 2nd conversion in regular sequence
        constexpr uint32_t SQ1 = (5 << 0);  ///< 1st conversion in regular sequence
    }

    /// JSQR Register bits
    namespace jsqr_bits {
        constexpr uint32_t JL = (2 << 20);  ///< Injected sequence length
        constexpr uint32_t JSQ4 = (5 << 15);  ///< 4th conversion in injected sequence
        constexpr uint32_t JSQ3 = (5 << 10);  ///< 3rd conversion in injected sequence
        constexpr uint32_t JSQ2 = (5 << 5);  ///< 2nd conversion in injected sequence
        constexpr uint32_t JSQ1 = (5 << 0);  ///< 1st conversion in injected sequence
    }

    /// JDR1 Register bits
    namespace jdr1_bits {
        constexpr uint32_t JDATA = (16 << 0);  ///< Injected data
    }

    /// JDR2 Register bits
    namespace jdr2_bits {
        constexpr uint32_t JDATA = (16 << 0);  ///< Injected data
    }

    /// JDR3 Register bits
    namespace jdr3_bits {
        constexpr uint32_t JDATA = (16 << 0);  ///< Injected data
    }

    /// JDR4 Register bits
    namespace jdr4_bits {
        constexpr uint32_t JDATA = (16 << 0);  ///< Injected data
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Regular data
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART6_BASE = 0x40011400;
    constexpr uint32_t USART1_BASE = 0x40011000;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Status register
        volatile uint32_t DR;  ///< Offset: 0x04 - Data register
        volatile uint32_t BRR;  ///< Offset: 0x08 - Baud rate register
        volatile uint32_t CR1;  ///< Offset: 0x0C - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x10 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x14 - Control register 3
        volatile uint32_t GTPR;  ///< Offset: 0x18 - Guard time and prescaler register
    };

    /// Peripheral instances
    inline Registers* USART6 = reinterpret_cast<Registers*>(USART6_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CTS = (1U << 9);  ///< CTS flag
        constexpr uint32_t LBD = (1U << 8);  ///< LIN break detection flag
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE line detected
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error
        constexpr uint32_t NF = (1U << 2);  ///< Noise detected flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing error
        constexpr uint32_t PE = (1U << 0);  ///< Parity error
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (9 << 0);  ///< Data value
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t DIV_Mantissa = (12 << 4);  ///< mantissa of USARTDIV
        constexpr uint32_t DIV_Fraction = (4 << 0);  ///< fraction of USARTDIV
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t UE = (1U << 13);  ///< USART enable
        constexpr uint32_t M = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< TXE interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver wakeup
        constexpr uint32_t SBK = (1U << 0);  ///< Send break
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< lin break detection length
        constexpr uint32_t ADD = (4 << 0);  ///< Address of the USART node
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< IrDA low-power
        constexpr uint32_t IREN = (1U << 1);  ///< IrDA mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SWTRIGR;  ///< Offset: 0x04 - software trigger register
        volatile uint32_t DHR12R1;  ///< Offset: 0x08 - channel1 12-bit right-aligned data holding register
        volatile uint32_t DHR12L1;  ///< Offset: 0x0C - channel1 12-bit left aligned data holding register
        volatile uint32_t DHR8R1;  ///< Offset: 0x10 - channel1 8-bit right aligned data holding register
        volatile uint32_t DHR12R2;  ///< Offset: 0x14 - channel2 12-bit right aligned data holding register
        volatile uint32_t DHR12L2;  ///< Offset: 0x18 - channel2 12-bit left aligned data holding register
        volatile uint32_t DHR8R2;  ///< Offset: 0x1C - channel2 8-bit right-aligned data holding register
        volatile uint32_t DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DOR1;  ///< Offset: 0x2C - channel1 data output register
        volatile uint32_t DOR2;  ///< Offset: 0x30 - channel2 data output register
        volatile uint32_t SR;  ///< Offset: 0x34 - status register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable
        constexpr uint32_t TSEL2 = (3 << 19);  ///< DAC channel2 trigger selection
        constexpr uint32_t TEN2 = (1U << 18);  ///< DAC channel2 trigger enable
        constexpr uint32_t BOFF2 = (1U << 17);  ///< DAC channel2 output buffer disable
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable
        constexpr uint32_t TSEL1 = (3 << 3);  ///< DAC channel1 trigger selection
        constexpr uint32_t TEN1 = (1U << 2);  ///< DAC channel1 trigger enable
        constexpr uint32_t BOFF1 = (1U << 1);  ///< DAC channel1 output buffer disable
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable
    }

    /// SWTRIGR Register bits
    namespace swtrigr_bits {
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger
    }

    /// DHR12R1 Register bits
    namespace dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
    }

    /// DHR12L1 Register bits
    namespace dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
    }

    /// DHR8R1 Register bits
    namespace dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DHR12R2 Register bits
    namespace dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DHR12L2 Register bits
    namespace dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data
    }

    /// DHR8R2 Register bits
    namespace dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DHR12RD Register bits
    namespace dhr12rd_bits {
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
    }

    /// DHR12LD Register bits
    namespace dhr12ld_bits {
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
    }

    /// DHR8RD Register bits
    namespace dhr8rd_bits {
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DOR1 Register bits
    namespace dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output
    }

    /// DOR2 Register bits
    namespace dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C3_BASE = 0x40005C00;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C1_BASE = 0x40005400;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t DR;  ///< Offset: 0x10 - Data register
        volatile uint32_t SR1;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t SR2;  ///< Offset: 0x18 - Status register 2
        volatile uint32_t CCR;  ///< Offset: 0x1C - Clock control register
        volatile uint32_t TRISE;  ///< Offset: 0x20 - TRISE register
        volatile uint32_t FLTR;  ///< Offset: 0x24 - I2C FLTR register
    };

    /// Peripheral instances
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t SWRST = (1U << 15);  ///< Software reset
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t PEC = (1U << 12);  ///< Packet error checking
        constexpr uint32_t POS = (1U << 11);  ///< Acknowledge/PEC Position (for data reception)
        constexpr uint32_t ACK = (1U << 10);  ///< Acknowledge enable
        constexpr uint32_t STOP = (1U << 9);  ///< Stop generation
        constexpr uint32_t START = (1U << 8);  ///< Start generation
        constexpr uint32_t NOSTRETCH = (1U << 7);  ///< Clock stretching disable (Slave mode)
        constexpr uint32_t ENGC = (1U << 6);  ///< General call enable
        constexpr uint32_t ENPEC = (1U << 5);  ///< PEC enable
        constexpr uint32_t ENARP = (1U << 4);  ///< ARP enable
        constexpr uint32_t SMBTYPE = (1U << 3);  ///< SMBus type
        constexpr uint32_t SMBUS = (1U << 1);  ///< SMBus mode
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LAST = (1U << 12);  ///< DMA last transfer
        constexpr uint32_t DMAEN = (1U << 11);  ///< DMA requests enable
        constexpr uint32_t ITBUFEN = (1U << 10);  ///< Buffer interrupt enable
        constexpr uint32_t ITEVTEN = (1U << 9);  ///< Event interrupt enable
        constexpr uint32_t ITERREN = (1U << 8);  ///< Error interrupt enable
        constexpr uint32_t FREQ = (6 << 0);  ///< Peripheral clock frequency
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t ADDMODE = (1U << 15);  ///< Addressing mode (slave mode)
        constexpr uint32_t ADD10 = (2 << 8);  ///< Interface address
        constexpr uint32_t ADD7 = (7 << 1);  ///< Interface address
        constexpr uint32_t ADD0 = (1U << 0);  ///< Interface address
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t ADD2 = (7 << 1);  ///< Interface address
        constexpr uint32_t ENDUAL = (1U << 0);  ///< Dual addressing mode enable
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (8 << 0);  ///< 8-bit data register
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t SMBALERT = (1U << 15);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 14);  ///< Timeout or Tlow error
        constexpr uint32_t PECERR = (1U << 12);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 11);  ///< Overrun/Underrun
        constexpr uint32_t AF = (1U << 10);  ///< Acknowledge failure
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost (master mode)
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TxE = (1U << 7);  ///< Data register empty (transmitters)
        constexpr uint32_t RxNE = (1U << 6);  ///< Data register not empty (receivers)
        constexpr uint32_t STOPF = (1U << 4);  ///< Stop detection (slave mode)
        constexpr uint32_t ADD10 = (1U << 3);  ///< 10-bit header sent (Master mode)
        constexpr uint32_t BTF = (1U << 2);  ///< Byte transfer finished
        constexpr uint32_t ADDR = (1U << 1);  ///< Address sent (master mode)/matched (slave mode)
        constexpr uint32_t SB = (1U << 0);  ///< Start bit (Master mode)
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PEC = (8 << 8);  ///< acket error checking register
        constexpr uint32_t DUALF = (1U << 7);  ///< Dual flag (Slave mode)
        constexpr uint32_t SMBHOST = (1U << 6);  ///< SMBus host header (Slave mode)
        constexpr uint32_t SMBDEFAULT = (1U << 5);  ///< SMBus device default address (Slave mode)
        constexpr uint32_t GENCALL = (1U << 4);  ///< General call address (Slave mode)
        constexpr uint32_t TRA = (1U << 2);  ///< Transmitter/receiver
        constexpr uint32_t BUSY = (1U << 1);  ///< Bus busy
        constexpr uint32_t MSL = (1U << 0);  ///< Master/slave
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t F_S = (1U << 15);  ///< I2C master mode selection
        constexpr uint32_t DUTY = (1U << 14);  ///< Fast mode duty cycle
        constexpr uint32_t CCR = (12 << 0);  ///< Clock control register in Fast/Standard mode (Master mode)
    }

    /// TRISE Register bits
    namespace trise_bits {
        constexpr uint32_t TRISE = (6 << 0);  ///< Maximum rise time in Fast/Standard mode (Master mode)
    }

    /// FLTR Register bits
    namespace fltr_bits {
        constexpr uint32_t DNF = (4 << 0);  ///< Digital noise filter
        constexpr uint32_t ANOFF = (1U << 4);  ///< Analog noise filter OFF
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0000h)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t ISR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CALIBR;  ///< Offset: 0x18 - calibration register
        volatile uint32_t ALRMAR;  ///< Offset: 0x1C - alarm A register
        volatile uint32_t ALRMBR;  ///< Offset: 0x20 - alarm B register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t SSR;  ///< Offset: 0x28 - sub second register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t CALR;  ///< Offset: 0x3C - calibration register
        volatile uint32_t TAFCR;  ///< Offset: 0x40 - tamper and alternate function configuration register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x48 - alarm B sub second register
        volatile uint32_t BKP0R;  ///< Offset: 0x50 - backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x54 - backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x58 - backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x5C - backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x60 - backup register
        volatile uint32_t BKP5R;  ///< Offset: 0x64 - backup register
        volatile uint32_t BKP6R;  ///< Offset: 0x68 - backup register
        volatile uint32_t BKP7R;  ///< Offset: 0x6C - backup register
        volatile uint32_t BKP8R;  ///< Offset: 0x70 - backup register
        volatile uint32_t BKP9R;  ///< Offset: 0x74 - backup register
        volatile uint32_t BKP10R;  ///< Offset: 0x78 - backup register
        volatile uint32_t BKP11R;  ///< Offset: 0x7C - backup register
        volatile uint32_t BKP12R;  ///< Offset: 0x80 - backup register
        volatile uint32_t BKP13R;  ///< Offset: 0x84 - backup register
        volatile uint32_t BKP14R;  ///< Offset: 0x88 - backup register
        volatile uint32_t BKP15R;  ///< Offset: 0x8C - backup register
        volatile uint32_t BKP16R;  ///< Offset: 0x90 - backup register
        volatile uint32_t BKP17R;  ///< Offset: 0x94 - backup register
        volatile uint32_t BKP18R;  ///< Offset: 0x98 - backup register
        volatile uint32_t BKP19R;  ///< Offset: 0x9C - backup register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity
        constexpr uint32_t BKP = (1U << 18);  ///< Backup
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change)
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change)
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t TSE = (1U << 11);  ///< Time stamp enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t DCE = (1U << 7);  ///< Coarse digital calibration enable
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t REFCKON = (1U << 4);  ///< Reference clock detection enable (50 or 60 Hz)
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge
        constexpr uint32_t WCKSEL = (3 << 0);  ///< Wakeup clock selection
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t ALRAF = (1U << 8);  ///< Alarm A flag
        constexpr uint32_t ALRBF = (1U << 9);  ///< Alarm B flag
        constexpr uint32_t WUTF = (1U << 10);  ///< Wakeup timer flag
        constexpr uint32_t TSF = (1U << 11);  ///< Time-stamp flag
        constexpr uint32_t TSOVF = (1U << 12);  ///< Time-stamp overflow flag
        constexpr uint32_t TAMP1F = (1U << 13);  ///< Tamper detection flag
        constexpr uint32_t TAMP2F = (1U << 14);  ///< TAMPER2 detection flag
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// CALIBR Register bits
    namespace calibr_bits {
        constexpr uint32_t DCS = (1U << 7);  ///< Digital calibration sign
        constexpr uint32_t DC = (5 << 0);  ///< Digital calibration
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t ALARMOUTTYPE = (1U << 18);  ///< AFO_ALARM output type
        constexpr uint32_t TSINSEL = (1U << 17);  ///< TIMESTAMP mapping
        constexpr uint32_t TAMP1INSEL = (1U << 16);  ///< TAMPER1 mapping
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP1TRG = (1U << 1);  ///< Active level for tamper 1
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper 1 detection enable
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// TAFCR Register bits
    namespace tafcr_bits {
        constexpr uint32_t ALARMOUTTYPE = (1U << 18);  ///< AFO_ALARM output type
        constexpr uint32_t TSINSEL = (1U << 17);  ///< TIMESTAMP mapping
        constexpr uint32_t TAMP1INSEL = (1U << 16);  ///< TAMPER1 mapping
        constexpr uint32_t TAMPPUDIS = (1U << 15);  ///< TAMPER pull-up disable
        constexpr uint32_t TAMPPRCH = (2 << 13);  ///< Tamper precharge duration
        constexpr uint32_t TAMPFLT = (2 << 11);  ///< Tamper filter count
        constexpr uint32_t TAMPFREQ = (3 << 8);  ///< Tamper sampling frequency
        constexpr uint32_t TAMPTS = (1U << 7);  ///< Activate timestamp on tamper detection event
        constexpr uint32_t TAMP2TRG = (1U << 4);  ///< Active level for tamper 2
        constexpr uint32_t TAMP2E = (1U << 3);  ///< Tamper 2 detection enable
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP1TRG = (1U << 1);  ///< Active level for tamper 1
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper 1 detection enable
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP5R Register bits
    namespace bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP6R Register bits
    namespace bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP7R Register bits
    namespace bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP8R Register bits
    namespace bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP9R Register bits
    namespace bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP10R Register bits
    namespace bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP11R Register bits
    namespace bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP12R Register bits
    namespace bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP13R Register bits
    namespace bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP14R Register bits
    namespace bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP15R Register bits
    namespace bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP16R Register bits
    namespace bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP17R Register bits
    namespace bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP18R Register bits
    namespace bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP19R Register bits
    namespace bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM1_BASE = 0x40010000;
    constexpr uint32_t TIM8_BASE = 0x40010400;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t TIM9_BASE = 0x40014000;
    constexpr uint32_t TIM12_BASE = 0x40001800;
    constexpr uint32_t TIM10_BASE = 0x40014400;
    constexpr uint32_t TIM13_BASE = 0x40001C00;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM11_BASE = 0x40014800;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SMCR;  ///< Offset: 0x08 - slave mode control register
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register 1 (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCMR2_Output;  ///< Offset: 0x1C - capture/compare mode register 2 (output mode)
        volatile uint32_t CCMR2_Input;  ///< Offset: 0x1C - capture/compare mode register 2 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t CCR2;  ///< Offset: 0x38 - capture/compare register 2
        volatile uint32_t CCR3;  ///< Offset: 0x3C - capture/compare register 3
        volatile uint32_t CCR4;  ///< Offset: 0x40 - capture/compare register 4
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
    };

    /// Peripheral instances
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* TIM9 = reinterpret_cast<Registers*>(TIM9_BASE);
    inline Registers* TIM12 = reinterpret_cast<Registers*>(TIM12_BASE);
    inline Registers* TIM10 = reinterpret_cast<Registers*>(TIM10_BASE);
    inline Registers* TIM13 = reinterpret_cast<Registers*>(TIM13_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM11 = reinterpret_cast<Registers*>(TIM11_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CMS = (2 << 5);  ///< Center-aligned mode selection
        constexpr uint32_t DIR = (1U << 4);  ///< Direction
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS4 = (1U << 14);  ///< Output Idle state 4
        constexpr uint32_t OIS3N = (1U << 13);  ///< Output Idle state 3
        constexpr uint32_t OIS3 = (1U << 12);  ///< Output Idle state 3
        constexpr uint32_t OIS2N = (1U << 11);  ///< Output Idle state 2
        constexpr uint32_t OIS2 = (1U << 10);  ///< Output Idle state 2
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1 selection
        constexpr uint32_t MMS = (3 << 4);  ///< Master mode selection
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// SMCR Register bits
    namespace smcr_bits {
        constexpr uint32_t ETP = (1U << 15);  ///< External trigger polarity
        constexpr uint32_t ECE = (1U << 14);  ///< External clock enable
        constexpr uint32_t ETPS = (2 << 12);  ///< External trigger prescaler
        constexpr uint32_t ETF = (4 << 8);  ///< External trigger filter
        constexpr uint32_t MSM = (1U << 7);  ///< Master/Slave mode
        constexpr uint32_t TS = (3 << 4);  ///< Trigger selection
        constexpr uint32_t SMS = (3 << 0);  ///< Slave mode selection
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t TDE = (1U << 14);  ///< Trigger DMA request enable
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t CC4DE = (1U << 12);  ///< Capture/Compare 4 DMA request enable
        constexpr uint32_t CC3DE = (1U << 11);  ///< Capture/Compare 3 DMA request enable
        constexpr uint32_t CC2DE = (1U << 10);  ///< Capture/Compare 2 DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t TIE = (1U << 6);  ///< Trigger interrupt enable
        constexpr uint32_t CC4IE = (1U << 4);  ///< Capture/Compare 4 interrupt enable
        constexpr uint32_t CC3IE = (1U << 3);  ///< Capture/Compare 3 interrupt enable
        constexpr uint32_t CC2IE = (1U << 2);  ///< Capture/Compare 2 interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC4OF = (1U << 12);  ///< Capture/Compare 4 overcapture flag
        constexpr uint32_t CC3OF = (1U << 11);  ///< Capture/Compare 3 overcapture flag
        constexpr uint32_t CC2OF = (1U << 10);  ///< Capture/compare 2 overcapture flag
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t TIF = (1U << 6);  ///< Trigger interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC4IF = (1U << 4);  ///< Capture/Compare 4 interrupt flag
        constexpr uint32_t CC3IF = (1U << 3);  ///< Capture/Compare 3 interrupt flag
        constexpr uint32_t CC2IF = (1U << 2);  ///< Capture/Compare 2 interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t TG = (1U << 6);  ///< Trigger generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC4G = (1U << 4);  ///< Capture/compare 4 generation
        constexpr uint32_t CC3G = (1U << 3);  ///< Capture/compare 3 generation
        constexpr uint32_t CC2G = (1U << 2);  ///< Capture/compare 2 generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC2CE = (1U << 15);  ///< Output Compare 2 clear enable
        constexpr uint32_t OC2M = (3 << 12);  ///< Output Compare 2 mode
        constexpr uint32_t OC2PE = (1U << 11);  ///< Output Compare 2 preload enable
        constexpr uint32_t OC2FE = (1U << 10);  ///< Output Compare 2 fast enable
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection
        constexpr uint32_t OC1CE = (1U << 7);  ///< Output Compare 1 clear enable
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC2F = (4 << 12);  ///< Input capture 2 filter
        constexpr uint32_t IC2PCS = (2 << 10);  ///< Input capture 2 prescaler
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t ICPCS = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR2_Output Register bits
    namespace ccmr2_output_bits {
        constexpr uint32_t OC4CE = (1U << 15);  ///< Output compare 4 clear enable
        constexpr uint32_t OC4M = (3 << 12);  ///< Output compare 4 mode
        constexpr uint32_t OC4PE = (1U << 11);  ///< Output compare 4 preload enable
        constexpr uint32_t OC4FE = (1U << 10);  ///< Output compare 4 fast enable
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection
        constexpr uint32_t OC3CE = (1U << 7);  ///< Output compare 3 clear enable
        constexpr uint32_t OC3M = (3 << 4);  ///< Output compare 3 mode
        constexpr uint32_t OC3PE = (1U << 3);  ///< Output compare 3 preload enable
        constexpr uint32_t OC3FE = (1U << 2);  ///< Output compare 3 fast enable
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/Compare 3 selection
    }

    /// CCMR2_Input Register bits
    namespace ccmr2_input_bits {
        constexpr uint32_t IC4F = (4 << 12);  ///< Input capture 4 filter
        constexpr uint32_t IC4PSC = (2 << 10);  ///< Input capture 4 prescaler
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection
        constexpr uint32_t IC3F = (4 << 4);  ///< Input capture 3 filter
        constexpr uint32_t IC3PSC = (2 << 2);  ///< Input capture 3 prescaler
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/compare 3 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC4P = (1U << 13);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC4E = (1U << 12);  ///< Capture/Compare 4 output enable
        constexpr uint32_t CC3NP = (1U << 11);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC3NE = (1U << 10);  ///< Capture/Compare 3 complementary output enable
        constexpr uint32_t CC3P = (1U << 9);  ///< Capture/Compare 3 output Polarity
        constexpr uint32_t CC3E = (1U << 8);  ///< Capture/Compare 3 output enable
        constexpr uint32_t CC2NP = (1U << 7);  ///< Capture/Compare 2 output Polarity
        constexpr uint32_t CC2NE = (1U << 6);  ///< Capture/Compare 2 complementary output enable
        constexpr uint32_t CC2P = (1U << 5);  ///< Capture/Compare 2 output Polarity
        constexpr uint32_t CC2E = (1U << 4);  ///< Capture/Compare 2 output enable
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/Compare 2 value
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t CCR3 = (16 << 0);  ///< Capture/Compare value
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t CCR4 = (16 << 0);  ///< Capture/Compare value
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (16 << 0);  ///< DMA register for burst accesses
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent Data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data Register
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (8 << 0);  ///< Independent Data register
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CR = (1U << 0);  ///< Control regidter
    }

}

// ============================================================================
// OTG Peripheral
// ============================================================================

namespace otg {
    /// Base addresses
    constexpr uint32_t OTG_FS_GLOBAL_BASE = 0x50000000;
    constexpr uint32_t OTG_FS_HOST_BASE = 0x50000400;
    constexpr uint32_t OTG_FS_DEVICE_BASE = 0x50000800;
    constexpr uint32_t OTG_HS_GLOBAL_BASE = 0x40040000;
    constexpr uint32_t OTG_HS_HOST_BASE = 0x40040400;
    constexpr uint32_t OTG_HS_DEVICE_BASE = 0x40040800;

    /// OTG Register structure
    struct Registers {
        volatile uint32_t FS_GOTGCTL;  ///< Offset: 0x00 - OTG_FS control and status register (OTG_FS_GOTGCTL)
        volatile uint32_t FS_GOTGINT;  ///< Offset: 0x04 - OTG_FS interrupt register (OTG_FS_GOTGINT)
        volatile uint32_t FS_GAHBCFG;  ///< Offset: 0x08 - OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
        volatile uint32_t FS_GUSBCFG;  ///< Offset: 0x0C - OTG_FS USB configuration register (OTG_FS_GUSBCFG)
        volatile uint32_t FS_GRSTCTL;  ///< Offset: 0x10 - OTG_FS reset register (OTG_FS_GRSTCTL)
        volatile uint32_t FS_GINTSTS;  ///< Offset: 0x14 - OTG_FS core interrupt register (OTG_FS_GINTSTS)
        volatile uint32_t FS_GINTMSK;  ///< Offset: 0x18 - OTG_FS interrupt mask register (OTG_FS_GINTMSK)
        volatile uint32_t FS_GRXSTSR_Device;  ///< Offset: 0x1C - OTG_FS Receive status debug read(Device mode)
        volatile uint32_t FS_GRXSTSR_Host;  ///< Offset: 0x1C - OTG_FS Receive status debug read(Host mode)
        volatile uint32_t FS_GRXFSIZ;  ///< Offset: 0x24 - OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
        volatile uint32_t FS_GNPTXFSIZ_Device;  ///< Offset: 0x28 - OTG_FS non-periodic transmit FIFO size register (Device mode)
        volatile uint32_t FS_GNPTXFSIZ_Host;  ///< Offset: 0x28 - OTG_FS non-periodic transmit FIFO size register (Host mode)
        volatile uint32_t FS_GNPTXSTS;  ///< Offset: 0x2C - OTG_FS non-periodic transmit FIFO/queue status register...
        volatile uint32_t FS_GCCFG;  ///< Offset: 0x38 - OTG_FS general core configuration register (OTG_FS_GCCFG)
        volatile uint32_t FS_CID;  ///< Offset: 0x3C - core ID register
        volatile uint32_t FS_HPTXFSIZ;  ///< Offset: 0x100 - OTG_FS Host periodic transmit FIFO size register...
        volatile uint32_t FS_DIEPTXF1;  ///< Offset: 0x104 - OTG_FS device IN endpoint transmit FIFO size register...
        volatile uint32_t FS_DIEPTXF2;  ///< Offset: 0x108 - OTG_FS device IN endpoint transmit FIFO size register...
        volatile uint32_t FS_DIEPTXF3;  ///< Offset: 0x10C - OTG_FS device IN endpoint transmit FIFO size register...
    };

    /// Peripheral instances
    inline Registers* OTG_FS_GLOBAL = reinterpret_cast<Registers*>(OTG_FS_GLOBAL_BASE);
    inline Registers* OTG_FS_HOST = reinterpret_cast<Registers*>(OTG_FS_HOST_BASE);
    inline Registers* OTG_FS_DEVICE = reinterpret_cast<Registers*>(OTG_FS_DEVICE_BASE);
    inline Registers* OTG_HS_GLOBAL = reinterpret_cast<Registers*>(OTG_HS_GLOBAL_BASE);
    inline Registers* OTG_HS_HOST = reinterpret_cast<Registers*>(OTG_HS_HOST_BASE);
    inline Registers* OTG_HS_DEVICE = reinterpret_cast<Registers*>(OTG_HS_DEVICE_BASE);

    // Bit definitions
    /// FS_GOTGCTL Register bits
    namespace fs_gotgctl_bits {
        constexpr uint32_t SRQSCS = (1U << 0);  ///< Session request success
        constexpr uint32_t SRQ = (1U << 1);  ///< Session request
        constexpr uint32_t HNGSCS = (1U << 8);  ///< Host negotiation success
        constexpr uint32_t HNPRQ = (1U << 9);  ///< HNP request
        constexpr uint32_t HSHNPEN = (1U << 10);  ///< Host set HNP enable
        constexpr uint32_t DHNPEN = (1U << 11);  ///< Device HNP enabled
        constexpr uint32_t CIDSTS = (1U << 16);  ///< Connector ID status
        constexpr uint32_t DBCT = (1U << 17);  ///< Long/short debounce time
        constexpr uint32_t ASVLD = (1U << 18);  ///< A-session valid
        constexpr uint32_t BSVLD = (1U << 19);  ///< B-session valid
    }

    /// FS_GOTGINT Register bits
    namespace fs_gotgint_bits {
        constexpr uint32_t SEDET = (1U << 2);  ///< Session end detected
        constexpr uint32_t SRSSCHG = (1U << 8);  ///< Session request success status change
        constexpr uint32_t HNSSCHG = (1U << 9);  ///< Host negotiation success status change
        constexpr uint32_t HNGDET = (1U << 17);  ///< Host negotiation detected
        constexpr uint32_t ADTOCHG = (1U << 18);  ///< A-device timeout change
        constexpr uint32_t DBCDNE = (1U << 19);  ///< Debounce done
    }

    /// FS_GAHBCFG Register bits
    namespace fs_gahbcfg_bits {
        constexpr uint32_t GINT = (1U << 0);  ///< Global interrupt mask
        constexpr uint32_t TXFELVL = (1U << 7);  ///< TxFIFO empty level
        constexpr uint32_t PTXFELVL = (1U << 8);  ///< Periodic TxFIFO empty level
    }

    /// FS_GUSBCFG Register bits
    namespace fs_gusbcfg_bits {
        constexpr uint32_t TOCAL = (3 << 0);  ///< FS timeout calibration
        constexpr uint32_t PHYSEL = (1U << 6);  ///< Full Speed serial transceiver select
        constexpr uint32_t SRPCAP = (1U << 8);  ///< SRP-capable
        constexpr uint32_t HNPCAP = (1U << 9);  ///< HNP-capable
        constexpr uint32_t TRDT = (4 << 10);  ///< USB turnaround time
        constexpr uint32_t FHMOD = (1U << 29);  ///< Force host mode
        constexpr uint32_t FDMOD = (1U << 30);  ///< Force device mode
        constexpr uint32_t CTXPKT = (1U << 31);  ///< Corrupt Tx packet
    }

    /// FS_GRSTCTL Register bits
    namespace fs_grstctl_bits {
        constexpr uint32_t CSRST = (1U << 0);  ///< Core soft reset
        constexpr uint32_t HSRST = (1U << 1);  ///< HCLK soft reset
        constexpr uint32_t FCRST = (1U << 2);  ///< Host frame counter reset
        constexpr uint32_t RXFFLSH = (1U << 4);  ///< RxFIFO flush
        constexpr uint32_t TXFFLSH = (1U << 5);  ///< TxFIFO flush
        constexpr uint32_t TXFNUM = (5 << 6);  ///< TxFIFO number
        constexpr uint32_t AHBIDL = (1U << 31);  ///< AHB master idle
    }

    /// FS_GINTSTS Register bits
    namespace fs_gintsts_bits {
        constexpr uint32_t CMOD = (1U << 0);  ///< Current mode of operation
        constexpr uint32_t MMIS = (1U << 1);  ///< Mode mismatch interrupt
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTG interrupt
        constexpr uint32_t SOF = (1U << 3);  ///< Start of frame
        constexpr uint32_t RXFLVL = (1U << 4);  ///< RxFIFO non-empty
        constexpr uint32_t NPTXFE = (1U << 5);  ///< Non-periodic TxFIFO empty
        constexpr uint32_t GINAKEFF = (1U << 6);  ///< Global IN non-periodic NAK effective
        constexpr uint32_t GOUTNAKEFF = (1U << 7);  ///< Global OUT NAK effective
        constexpr uint32_t ESUSP = (1U << 10);  ///< Early suspend
        constexpr uint32_t USBSUSP = (1U << 11);  ///< USB suspend
        constexpr uint32_t USBRST = (1U << 12);  ///< USB reset
        constexpr uint32_t ENUMDNE = (1U << 13);  ///< Enumeration done
        constexpr uint32_t ISOODRP = (1U << 14);  ///< Isochronous OUT packet dropped interrupt
        constexpr uint32_t EOPF = (1U << 15);  ///< End of periodic frame interrupt
        constexpr uint32_t IEPINT = (1U << 18);  ///< IN endpoint interrupt
        constexpr uint32_t OEPINT = (1U << 19);  ///< OUT endpoint interrupt
        constexpr uint32_t IISOIXFR = (1U << 20);  ///< Incomplete isochronous IN transfer
        constexpr uint32_t IPXFR_INCOMPISOOUT = (1U << 21);  ///< Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
        constexpr uint32_t HPRTINT = (1U << 24);  ///< Host port interrupt
        constexpr uint32_t HCINT = (1U << 25);  ///< Host channels interrupt
        constexpr uint32_t PTXFE = (1U << 26);  ///< Periodic TxFIFO empty
        constexpr uint32_t CIDSCHG = (1U << 28);  ///< Connector ID status change
        constexpr uint32_t DISCINT = (1U << 29);  ///< Disconnect detected interrupt
        constexpr uint32_t SRQINT = (1U << 30);  ///< Session request/new session detected interrupt
        constexpr uint32_t WKUPINT = (1U << 31);  ///< Resume/remote wakeup detected interrupt
    }

    /// FS_GINTMSK Register bits
    namespace fs_gintmsk_bits {
        constexpr uint32_t MMISM = (1U << 1);  ///< Mode mismatch interrupt mask
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTG interrupt mask
        constexpr uint32_t SOFM = (1U << 3);  ///< Start of frame mask
        constexpr uint32_t RXFLVLM = (1U << 4);  ///< Receive FIFO non-empty mask
        constexpr uint32_t NPTXFEM = (1U << 5);  ///< Non-periodic TxFIFO empty mask
        constexpr uint32_t GINAKEFFM = (1U << 6);  ///< Global non-periodic IN NAK effective mask
        constexpr uint32_t GONAKEFFM = (1U << 7);  ///< Global OUT NAK effective mask
        constexpr uint32_t ESUSPM = (1U << 10);  ///< Early suspend mask
        constexpr uint32_t USBSUSPM = (1U << 11);  ///< USB suspend mask
        constexpr uint32_t USBRST = (1U << 12);  ///< USB reset mask
        constexpr uint32_t ENUMDNEM = (1U << 13);  ///< Enumeration done mask
        constexpr uint32_t ISOODRPM = (1U << 14);  ///< Isochronous OUT packet dropped interrupt mask
        constexpr uint32_t EOPFM = (1U << 15);  ///< End of periodic frame interrupt mask
        constexpr uint32_t EPMISM = (1U << 17);  ///< Endpoint mismatch interrupt mask
        constexpr uint32_t IEPINT = (1U << 18);  ///< IN endpoints interrupt mask
        constexpr uint32_t OEPINT = (1U << 19);  ///< OUT endpoints interrupt mask
        constexpr uint32_t IISOIXFRM = (1U << 20);  ///< Incomplete isochronous IN transfer mask
        constexpr uint32_t IPXFRM_IISOOXFRM = (1U << 21);  ///< Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
        constexpr uint32_t PRTIM = (1U << 24);  ///< Host port interrupt mask
        constexpr uint32_t HCIM = (1U << 25);  ///< Host channels interrupt mask
        constexpr uint32_t PTXFEM = (1U << 26);  ///< Periodic TxFIFO empty mask
        constexpr uint32_t CIDSCHGM = (1U << 28);  ///< Connector ID status change mask
        constexpr uint32_t DISCINT = (1U << 29);  ///< Disconnect detected interrupt mask
        constexpr uint32_t SRQIM = (1U << 30);  ///< Session request/new session detected interrupt mask
        constexpr uint32_t WUIM = (1U << 31);  ///< Resume/remote wakeup detected interrupt mask
    }

    /// FS_GRXSTSR_Device Register bits
    namespace fs_grxstsr_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint number
        constexpr uint32_t BCNT = (11 << 4);  ///< Byte count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< Packet status
        constexpr uint32_t FRMNUM = (4 << 21);  ///< Frame number
    }

    /// FS_GRXSTSR_Host Register bits
    namespace fs_grxstsr_host_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint number
        constexpr uint32_t BCNT = (11 << 4);  ///< Byte count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< Packet status
        constexpr uint32_t FRMNUM = (4 << 21);  ///< Frame number
    }

    /// FS_GRXFSIZ Register bits
    namespace fs_grxfsiz_bits {
        constexpr uint32_t RXFD = (16 << 0);  ///< RxFIFO depth
    }

    /// FS_GNPTXFSIZ_Device Register bits
    namespace fs_gnptxfsiz_device_bits {
        constexpr uint32_t TX0FSA = (16 << 0);  ///< Endpoint 0 transmit RAM start address
        constexpr uint32_t TX0FD = (16 << 16);  ///< Endpoint 0 TxFIFO depth
    }

    /// FS_GNPTXFSIZ_Host Register bits
    namespace fs_gnptxfsiz_host_bits {
        constexpr uint32_t NPTXFSA = (16 << 0);  ///< Non-periodic transmit RAM start address
        constexpr uint32_t NPTXFD = (16 << 16);  ///< Non-periodic TxFIFO depth
    }

    /// FS_GNPTXSTS Register bits
    namespace fs_gnptxsts_bits {
        constexpr uint32_t NPTXFSAV = (16 << 0);  ///< Non-periodic TxFIFO space available
        constexpr uint32_t NPTQXSAV = (8 << 16);  ///< Non-periodic transmit request queue space available
        constexpr uint32_t NPTXQTOP = (7 << 24);  ///< Top of the non-periodic transmit request queue
    }

    /// FS_GCCFG Register bits
    namespace fs_gccfg_bits {
        constexpr uint32_t PWRDWN = (1U << 16);  ///< Power down
        constexpr uint32_t VBUSASEN = (1U << 18);  ///< Enable the VBUS sensing device
        constexpr uint32_t VBUSBSEN = (1U << 19);  ///< Enable the VBUS sensing device
        constexpr uint32_t SOFOUTEN = (1U << 20);  ///< SOF output enable
    }

    /// FS_CID Register bits
    namespace fs_cid_bits {
        constexpr uint32_t PRODUCT_ID = (32 << 0);  ///< Product ID field
    }

    /// FS_HPTXFSIZ Register bits
    namespace fs_hptxfsiz_bits {
        constexpr uint32_t PTXSA = (16 << 0);  ///< Host periodic TxFIFO start address
        constexpr uint32_t PTXFSIZ = (16 << 16);  ///< Host periodic TxFIFO depth
    }

    /// FS_DIEPTXF1 Register bits
    namespace fs_dieptxf1_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFO2 transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// FS_DIEPTXF2 Register bits
    namespace fs_dieptxf2_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFO3 transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// FS_DIEPTXF3 Register bits
    namespace fs_dieptxf3_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFO4 transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t OTG_FS_PWRCLK_BASE = 0x50000E00;
    constexpr uint32_t OTG_HS_PWRCLK_BASE = 0x40040E00;
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t FS_PCGCCTL;  ///< Offset: 0x00 - OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)
    };

    /// Peripheral instances
    inline Registers* OTG_FS_PWRCLK = reinterpret_cast<Registers*>(OTG_FS_PWRCLK_BASE);
    inline Registers* OTG_HS_PWRCLK = reinterpret_cast<Registers*>(OTG_HS_PWRCLK_BASE);
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// FS_PCGCCTL Register bits
    namespace fs_pcgcctl_bits {
        constexpr uint32_t STPPCLK = (1U << 0);  ///< Stop PHY clock
        constexpr uint32_t GATEHCLK = (1U << 1);  ///< Gate HCLK
        constexpr uint32_t PHYSUSP = (1U << 4);  ///< PHY Suspended
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN1_BASE = 0x40006400;
    constexpr uint32_t CAN2_BASE = 0x40006800;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - master control register
        volatile uint32_t MSR;  ///< Offset: 0x04 - master status register
        volatile uint32_t TSR;  ///< Offset: 0x08 - transmit status register
        volatile uint32_t RF0R;  ///< Offset: 0x0C - receive FIFO 0 register
        volatile uint32_t RF1R;  ///< Offset: 0x10 - receive FIFO 1 register
        volatile uint32_t IER;  ///< Offset: 0x14 - interrupt enable register
        volatile uint32_t ESR;  ///< Offset: 0x18 - interrupt enable register
        volatile uint32_t BTR;  ///< Offset: 0x1C - bit timing register
        volatile uint32_t TI0R;  ///< Offset: 0x180 - TX mailbox identifier register
        volatile uint32_t TDT0R;  ///< Offset: 0x184 - mailbox data length control and time stamp register
        volatile uint32_t TDL0R;  ///< Offset: 0x188 - mailbox data low register
        volatile uint32_t TDH0R;  ///< Offset: 0x18C - mailbox data high register
        volatile uint32_t TI1R;  ///< Offset: 0x190 - mailbox identifier register
        volatile uint32_t TDT1R;  ///< Offset: 0x194 - mailbox data length control and time stamp register
        volatile uint32_t TDL1R;  ///< Offset: 0x198 - mailbox data low register
        volatile uint32_t TDH1R;  ///< Offset: 0x19C - mailbox data high register
        volatile uint32_t TI2R;  ///< Offset: 0x1A0 - mailbox identifier register
        volatile uint32_t TDT2R;  ///< Offset: 0x1A4 - mailbox data length control and time stamp register
        volatile uint32_t TDL2R;  ///< Offset: 0x1A8 - mailbox data low register
        volatile uint32_t TDH2R;  ///< Offset: 0x1AC - mailbox data high register
        volatile uint32_t RI0R;  ///< Offset: 0x1B0 - receive FIFO mailbox identifier register
        volatile uint32_t RDT0R;  ///< Offset: 0x1B4 - mailbox data high register
        volatile uint32_t RDL0R;  ///< Offset: 0x1B8 - mailbox data high register
        volatile uint32_t RDH0R;  ///< Offset: 0x1BC - receive FIFO mailbox data high register
        volatile uint32_t RI1R;  ///< Offset: 0x1C0 - mailbox data high register
        volatile uint32_t RDT1R;  ///< Offset: 0x1C4 - mailbox data high register
        volatile uint32_t RDL1R;  ///< Offset: 0x1C8 - mailbox data high register
        volatile uint32_t RDH1R;  ///< Offset: 0x1CC - mailbox data high register
        volatile uint32_t FMR;  ///< Offset: 0x200 - filter master register
        volatile uint32_t FM1R;  ///< Offset: 0x204 - filter mode register
        volatile uint32_t FS1R;  ///< Offset: 0x20C - filter scale register
        volatile uint32_t FFA1R;  ///< Offset: 0x214 - filter FIFO assignment register
        volatile uint32_t FA1R;  ///< Offset: 0x21C - filter activation register
        volatile uint32_t F0R1;  ///< Offset: 0x240 - Filter bank 0 register 1
        volatile uint32_t F0R2;  ///< Offset: 0x244 - Filter bank 0 register 2
        volatile uint32_t F1R1;  ///< Offset: 0x248 - Filter bank 1 register 1
        volatile uint32_t F1R2;  ///< Offset: 0x24C - Filter bank 1 register 2
        volatile uint32_t F2R1;  ///< Offset: 0x250 - Filter bank 2 register 1
        volatile uint32_t F2R2;  ///< Offset: 0x254 - Filter bank 2 register 2
        volatile uint32_t F3R1;  ///< Offset: 0x258 - Filter bank 3 register 1
        volatile uint32_t F3R2;  ///< Offset: 0x25C - Filter bank 3 register 2
        volatile uint32_t F4R1;  ///< Offset: 0x260 - Filter bank 4 register 1
        volatile uint32_t F4R2;  ///< Offset: 0x264 - Filter bank 4 register 2
        volatile uint32_t F5R1;  ///< Offset: 0x268 - Filter bank 5 register 1
        volatile uint32_t F5R2;  ///< Offset: 0x26C - Filter bank 5 register 2
        volatile uint32_t F6R1;  ///< Offset: 0x270 - Filter bank 6 register 1
        volatile uint32_t F6R2;  ///< Offset: 0x274 - Filter bank 6 register 2
        volatile uint32_t F7R1;  ///< Offset: 0x278 - Filter bank 7 register 1
        volatile uint32_t F7R2;  ///< Offset: 0x27C - Filter bank 7 register 2
        volatile uint32_t F8R1;  ///< Offset: 0x280 - Filter bank 8 register 1
        volatile uint32_t F8R2;  ///< Offset: 0x284 - Filter bank 8 register 2
        volatile uint32_t F9R1;  ///< Offset: 0x288 - Filter bank 9 register 1
        volatile uint32_t F9R2;  ///< Offset: 0x28C - Filter bank 9 register 2
        volatile uint32_t F10R1;  ///< Offset: 0x290 - Filter bank 10 register 1
        volatile uint32_t F10R2;  ///< Offset: 0x294 - Filter bank 10 register 2
        volatile uint32_t F11R1;  ///< Offset: 0x298 - Filter bank 11 register 1
        volatile uint32_t F11R2;  ///< Offset: 0x29C - Filter bank 11 register 2
        volatile uint32_t F12R1;  ///< Offset: 0x2A0 - Filter bank 4 register 1
        volatile uint32_t F12R2;  ///< Offset: 0x2A4 - Filter bank 12 register 2
        volatile uint32_t F13R1;  ///< Offset: 0x2A8 - Filter bank 13 register 1
        volatile uint32_t F13R2;  ///< Offset: 0x2AC - Filter bank 13 register 2
        volatile uint32_t F14R1;  ///< Offset: 0x2B0 - Filter bank 14 register 1
        volatile uint32_t F14R2;  ///< Offset: 0x2B4 - Filter bank 14 register 2
        volatile uint32_t F15R1;  ///< Offset: 0x2B8 - Filter bank 15 register 1
        volatile uint32_t F15R2;  ///< Offset: 0x2BC - Filter bank 15 register 2
        volatile uint32_t F16R1;  ///< Offset: 0x2C0 - Filter bank 16 register 1
        volatile uint32_t F16R2;  ///< Offset: 0x2C4 - Filter bank 16 register 2
        volatile uint32_t F17R1;  ///< Offset: 0x2C8 - Filter bank 17 register 1
        volatile uint32_t F17R2;  ///< Offset: 0x2CC - Filter bank 17 register 2
        volatile uint32_t F18R1;  ///< Offset: 0x2D0 - Filter bank 18 register 1
        volatile uint32_t F18R2;  ///< Offset: 0x2D4 - Filter bank 18 register 2
        volatile uint32_t F19R1;  ///< Offset: 0x2D8 - Filter bank 19 register 1
        volatile uint32_t F19R2;  ///< Offset: 0x2DC - Filter bank 19 register 2
        volatile uint32_t F20R1;  ///< Offset: 0x2E0 - Filter bank 20 register 1
        volatile uint32_t F20R2;  ///< Offset: 0x2E4 - Filter bank 20 register 2
        volatile uint32_t F21R1;  ///< Offset: 0x2E8 - Filter bank 21 register 1
        volatile uint32_t F21R2;  ///< Offset: 0x2EC - Filter bank 21 register 2
        volatile uint32_t F22R1;  ///< Offset: 0x2F0 - Filter bank 22 register 1
        volatile uint32_t F22R2;  ///< Offset: 0x2F4 - Filter bank 22 register 2
        volatile uint32_t F23R1;  ///< Offset: 0x2F8 - Filter bank 23 register 1
        volatile uint32_t F23R2;  ///< Offset: 0x2FC - Filter bank 23 register 2
        volatile uint32_t F24R1;  ///< Offset: 0x300 - Filter bank 24 register 1
        volatile uint32_t F24R2;  ///< Offset: 0x304 - Filter bank 24 register 2
        volatile uint32_t F25R1;  ///< Offset: 0x308 - Filter bank 25 register 1
        volatile uint32_t F25R2;  ///< Offset: 0x30C - Filter bank 25 register 2
        volatile uint32_t F26R1;  ///< Offset: 0x310 - Filter bank 26 register 1
        volatile uint32_t F26R2;  ///< Offset: 0x314 - Filter bank 26 register 2
        volatile uint32_t F27R1;  ///< Offset: 0x318 - Filter bank 27 register 1
        volatile uint32_t F27R2;  ///< Offset: 0x31C - Filter bank 27 register 2
    };

    /// Peripheral instances
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);
    inline Registers* CAN2 = reinterpret_cast<Registers*>(CAN2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t DBF = (1U << 16);  ///< DBF
        constexpr uint32_t RESET = (1U << 15);  ///< RESET
        constexpr uint32_t TTCM = (1U << 7);  ///< TTCM
        constexpr uint32_t ABOM = (1U << 6);  ///< ABOM
        constexpr uint32_t AWUM = (1U << 5);  ///< AWUM
        constexpr uint32_t NART = (1U << 4);  ///< NART
        constexpr uint32_t RFLM = (1U << 3);  ///< RFLM
        constexpr uint32_t TXFP = (1U << 2);  ///< TXFP
        constexpr uint32_t SLEEP = (1U << 1);  ///< SLEEP
        constexpr uint32_t INRQ = (1U << 0);  ///< INRQ
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t RX = (1U << 11);  ///< RX
        constexpr uint32_t SAMP = (1U << 10);  ///< SAMP
        constexpr uint32_t RXM = (1U << 9);  ///< RXM
        constexpr uint32_t TXM = (1U << 8);  ///< TXM
        constexpr uint32_t SLAKI = (1U << 4);  ///< SLAKI
        constexpr uint32_t WKUI = (1U << 3);  ///< WKUI
        constexpr uint32_t ERRI = (1U << 2);  ///< ERRI
        constexpr uint32_t SLAK = (1U << 1);  ///< SLAK
        constexpr uint32_t INAK = (1U << 0);  ///< INAK
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t LOW2 = (1U << 31);  ///< Lowest priority flag for mailbox 2
        constexpr uint32_t LOW1 = (1U << 30);  ///< Lowest priority flag for mailbox 1
        constexpr uint32_t LOW0 = (1U << 29);  ///< Lowest priority flag for mailbox 0
        constexpr uint32_t TME2 = (1U << 28);  ///< Lowest priority flag for mailbox 2
        constexpr uint32_t TME1 = (1U << 27);  ///< Lowest priority flag for mailbox 1
        constexpr uint32_t TME0 = (1U << 26);  ///< Lowest priority flag for mailbox 0
        constexpr uint32_t CODE = (2 << 24);  ///< CODE
        constexpr uint32_t ABRQ2 = (1U << 23);  ///< ABRQ2
        constexpr uint32_t TERR2 = (1U << 19);  ///< TERR2
        constexpr uint32_t ALST2 = (1U << 18);  ///< ALST2
        constexpr uint32_t TXOK2 = (1U << 17);  ///< TXOK2
        constexpr uint32_t RQCP2 = (1U << 16);  ///< RQCP2
        constexpr uint32_t ABRQ1 = (1U << 15);  ///< ABRQ1
        constexpr uint32_t TERR1 = (1U << 11);  ///< TERR1
        constexpr uint32_t ALST1 = (1U << 10);  ///< ALST1
        constexpr uint32_t TXOK1 = (1U << 9);  ///< TXOK1
        constexpr uint32_t RQCP1 = (1U << 8);  ///< RQCP1
        constexpr uint32_t ABRQ0 = (1U << 7);  ///< ABRQ0
        constexpr uint32_t TERR0 = (1U << 3);  ///< TERR0
        constexpr uint32_t ALST0 = (1U << 2);  ///< ALST0
        constexpr uint32_t TXOK0 = (1U << 1);  ///< TXOK0
        constexpr uint32_t RQCP0 = (1U << 0);  ///< RQCP0
    }

    /// RF0R Register bits
    namespace rf0r_bits {
        constexpr uint32_t RFOM0 = (1U << 5);  ///< RFOM0
        constexpr uint32_t FOVR0 = (1U << 4);  ///< FOVR0
        constexpr uint32_t FULL0 = (1U << 3);  ///< FULL0
        constexpr uint32_t FMP0 = (2 << 0);  ///< FMP0
    }

    /// RF1R Register bits
    namespace rf1r_bits {
        constexpr uint32_t RFOM1 = (1U << 5);  ///< RFOM1
        constexpr uint32_t FOVR1 = (1U << 4);  ///< FOVR1
        constexpr uint32_t FULL1 = (1U << 3);  ///< FULL1
        constexpr uint32_t FMP1 = (2 << 0);  ///< FMP1
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t SLKIE = (1U << 17);  ///< SLKIE
        constexpr uint32_t WKUIE = (1U << 16);  ///< WKUIE
        constexpr uint32_t ERRIE = (1U << 15);  ///< ERRIE
        constexpr uint32_t LECIE = (1U << 11);  ///< LECIE
        constexpr uint32_t BOFIE = (1U << 10);  ///< BOFIE
        constexpr uint32_t EPVIE = (1U << 9);  ///< EPVIE
        constexpr uint32_t EWGIE = (1U << 8);  ///< EWGIE
        constexpr uint32_t FOVIE1 = (1U << 6);  ///< FOVIE1
        constexpr uint32_t FFIE1 = (1U << 5);  ///< FFIE1
        constexpr uint32_t FMPIE1 = (1U << 4);  ///< FMPIE1
        constexpr uint32_t FOVIE0 = (1U << 3);  ///< FOVIE0
        constexpr uint32_t FFIE0 = (1U << 2);  ///< FFIE0
        constexpr uint32_t FMPIE0 = (1U << 1);  ///< FMPIE0
        constexpr uint32_t TMEIE = (1U << 0);  ///< TMEIE
    }

    /// ESR Register bits
    namespace esr_bits {
        constexpr uint32_t REC = (8 << 24);  ///< REC
        constexpr uint32_t TEC = (8 << 16);  ///< TEC
        constexpr uint32_t LEC = (3 << 4);  ///< LEC
        constexpr uint32_t BOFF = (1U << 2);  ///< BOFF
        constexpr uint32_t EPVF = (1U << 1);  ///< EPVF
        constexpr uint32_t EWGF = (1U << 0);  ///< EWGF
    }

    /// BTR Register bits
    namespace btr_bits {
        constexpr uint32_t SILM = (1U << 31);  ///< SILM
        constexpr uint32_t LBKM = (1U << 30);  ///< LBKM
        constexpr uint32_t SJW = (2 << 24);  ///< SJW
        constexpr uint32_t TS2 = (3 << 20);  ///< TS2
        constexpr uint32_t TS1 = (4 << 16);  ///< TS1
        constexpr uint32_t BRP = (10 << 0);  ///< BRP
    }

    /// TI0R Register bits
    namespace ti0r_bits {
        constexpr uint32_t STID = (11 << 21);  ///< STID
        constexpr uint32_t EXID = (18 << 3);  ///< EXID
        constexpr uint32_t IDE = (1U << 2);  ///< IDE
        constexpr uint32_t RTR = (1U << 1);  ///< RTR
        constexpr uint32_t TXRQ = (1U << 0);  ///< TXRQ
    }

    /// TDT0R Register bits
    namespace tdt0r_bits {
        constexpr uint32_t TIME = (16 << 16);  ///< TIME
        constexpr uint32_t TGT = (1U << 8);  ///< TGT
        constexpr uint32_t DLC = (4 << 0);  ///< DLC
    }

    /// TDL0R Register bits
    namespace tdl0r_bits {
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// TDH0R Register bits
    namespace tdh0r_bits {
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4
    }

    /// TI1R Register bits
    namespace ti1r_bits {
        constexpr uint32_t STID = (11 << 21);  ///< STID
        constexpr uint32_t EXID = (18 << 3);  ///< EXID
        constexpr uint32_t IDE = (1U << 2);  ///< IDE
        constexpr uint32_t RTR = (1U << 1);  ///< RTR
        constexpr uint32_t TXRQ = (1U << 0);  ///< TXRQ
    }

    /// TDT1R Register bits
    namespace tdt1r_bits {
        constexpr uint32_t TIME = (16 << 16);  ///< TIME
        constexpr uint32_t TGT = (1U << 8);  ///< TGT
        constexpr uint32_t DLC = (4 << 0);  ///< DLC
    }

    /// TDL1R Register bits
    namespace tdl1r_bits {
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// TDH1R Register bits
    namespace tdh1r_bits {
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4
    }

    /// TI2R Register bits
    namespace ti2r_bits {
        constexpr uint32_t STID = (11 << 21);  ///< STID
        constexpr uint32_t EXID = (18 << 3);  ///< EXID
        constexpr uint32_t IDE = (1U << 2);  ///< IDE
        constexpr uint32_t RTR = (1U << 1);  ///< RTR
        constexpr uint32_t TXRQ = (1U << 0);  ///< TXRQ
    }

    /// TDT2R Register bits
    namespace tdt2r_bits {
        constexpr uint32_t TIME = (16 << 16);  ///< TIME
        constexpr uint32_t TGT = (1U << 8);  ///< TGT
        constexpr uint32_t DLC = (4 << 0);  ///< DLC
    }

    /// TDL2R Register bits
    namespace tdl2r_bits {
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// TDH2R Register bits
    namespace tdh2r_bits {
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4
    }

    /// RI0R Register bits
    namespace ri0r_bits {
        constexpr uint32_t STID = (11 << 21);  ///< STID
        constexpr uint32_t EXID = (18 << 3);  ///< EXID
        constexpr uint32_t IDE = (1U << 2);  ///< IDE
        constexpr uint32_t RTR = (1U << 1);  ///< RTR
    }

    /// RDT0R Register bits
    namespace rdt0r_bits {
        constexpr uint32_t TIME = (16 << 16);  ///< TIME
        constexpr uint32_t FMI = (8 << 8);  ///< FMI
        constexpr uint32_t DLC = (4 << 0);  ///< DLC
    }

    /// RDL0R Register bits
    namespace rdl0r_bits {
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// RDH0R Register bits
    namespace rdh0r_bits {
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4
    }

    /// RI1R Register bits
    namespace ri1r_bits {
        constexpr uint32_t STID = (11 << 21);  ///< STID
        constexpr uint32_t EXID = (18 << 3);  ///< EXID
        constexpr uint32_t IDE = (1U << 2);  ///< IDE
        constexpr uint32_t RTR = (1U << 1);  ///< RTR
    }

    /// RDT1R Register bits
    namespace rdt1r_bits {
        constexpr uint32_t TIME = (16 << 16);  ///< TIME
        constexpr uint32_t FMI = (8 << 8);  ///< FMI
        constexpr uint32_t DLC = (4 << 0);  ///< DLC
    }

    /// RDL1R Register bits
    namespace rdl1r_bits {
        constexpr uint32_t DATA3 = (8 << 24);  ///< DATA3
        constexpr uint32_t DATA2 = (8 << 16);  ///< DATA2
        constexpr uint32_t DATA1 = (8 << 8);  ///< DATA1
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// RDH1R Register bits
    namespace rdh1r_bits {
        constexpr uint32_t DATA7 = (8 << 24);  ///< DATA7
        constexpr uint32_t DATA6 = (8 << 16);  ///< DATA6
        constexpr uint32_t DATA5 = (8 << 8);  ///< DATA5
        constexpr uint32_t DATA4 = (8 << 0);  ///< DATA4
    }

    /// FMR Register bits
    namespace fmr_bits {
        constexpr uint32_t CAN2SB = (6 << 8);  ///< CAN2SB
        constexpr uint32_t FINIT = (1U << 0);  ///< FINIT
    }

    /// FM1R Register bits
    namespace fm1r_bits {
        constexpr uint32_t FBM0 = (1U << 0);  ///< Filter mode
        constexpr uint32_t FBM1 = (1U << 1);  ///< Filter mode
        constexpr uint32_t FBM2 = (1U << 2);  ///< Filter mode
        constexpr uint32_t FBM3 = (1U << 3);  ///< Filter mode
        constexpr uint32_t FBM4 = (1U << 4);  ///< Filter mode
        constexpr uint32_t FBM5 = (1U << 5);  ///< Filter mode
        constexpr uint32_t FBM6 = (1U << 6);  ///< Filter mode
        constexpr uint32_t FBM7 = (1U << 7);  ///< Filter mode
        constexpr uint32_t FBM8 = (1U << 8);  ///< Filter mode
        constexpr uint32_t FBM9 = (1U << 9);  ///< Filter mode
        constexpr uint32_t FBM10 = (1U << 10);  ///< Filter mode
        constexpr uint32_t FBM11 = (1U << 11);  ///< Filter mode
        constexpr uint32_t FBM12 = (1U << 12);  ///< Filter mode
        constexpr uint32_t FBM13 = (1U << 13);  ///< Filter mode
        constexpr uint32_t FBM14 = (1U << 14);  ///< Filter mode
        constexpr uint32_t FBM15 = (1U << 15);  ///< Filter mode
        constexpr uint32_t FBM16 = (1U << 16);  ///< Filter mode
        constexpr uint32_t FBM17 = (1U << 17);  ///< Filter mode
        constexpr uint32_t FBM18 = (1U << 18);  ///< Filter mode
        constexpr uint32_t FBM19 = (1U << 19);  ///< Filter mode
        constexpr uint32_t FBM20 = (1U << 20);  ///< Filter mode
        constexpr uint32_t FBM21 = (1U << 21);  ///< Filter mode
        constexpr uint32_t FBM22 = (1U << 22);  ///< Filter mode
        constexpr uint32_t FBM23 = (1U << 23);  ///< Filter mode
        constexpr uint32_t FBM24 = (1U << 24);  ///< Filter mode
        constexpr uint32_t FBM25 = (1U << 25);  ///< Filter mode
        constexpr uint32_t FBM26 = (1U << 26);  ///< Filter mode
        constexpr uint32_t FBM27 = (1U << 27);  ///< Filter mode
    }

    /// FS1R Register bits
    namespace fs1r_bits {
        constexpr uint32_t FSC0 = (1U << 0);  ///< Filter scale configuration
        constexpr uint32_t FSC1 = (1U << 1);  ///< Filter scale configuration
        constexpr uint32_t FSC2 = (1U << 2);  ///< Filter scale configuration
        constexpr uint32_t FSC3 = (1U << 3);  ///< Filter scale configuration
        constexpr uint32_t FSC4 = (1U << 4);  ///< Filter scale configuration
        constexpr uint32_t FSC5 = (1U << 5);  ///< Filter scale configuration
        constexpr uint32_t FSC6 = (1U << 6);  ///< Filter scale configuration
        constexpr uint32_t FSC7 = (1U << 7);  ///< Filter scale configuration
        constexpr uint32_t FSC8 = (1U << 8);  ///< Filter scale configuration
        constexpr uint32_t FSC9 = (1U << 9);  ///< Filter scale configuration
        constexpr uint32_t FSC10 = (1U << 10);  ///< Filter scale configuration
        constexpr uint32_t FSC11 = (1U << 11);  ///< Filter scale configuration
        constexpr uint32_t FSC12 = (1U << 12);  ///< Filter scale configuration
        constexpr uint32_t FSC13 = (1U << 13);  ///< Filter scale configuration
        constexpr uint32_t FSC14 = (1U << 14);  ///< Filter scale configuration
        constexpr uint32_t FSC15 = (1U << 15);  ///< Filter scale configuration
        constexpr uint32_t FSC16 = (1U << 16);  ///< Filter scale configuration
        constexpr uint32_t FSC17 = (1U << 17);  ///< Filter scale configuration
        constexpr uint32_t FSC18 = (1U << 18);  ///< Filter scale configuration
        constexpr uint32_t FSC19 = (1U << 19);  ///< Filter scale configuration
        constexpr uint32_t FSC20 = (1U << 20);  ///< Filter scale configuration
        constexpr uint32_t FSC21 = (1U << 21);  ///< Filter scale configuration
        constexpr uint32_t FSC22 = (1U << 22);  ///< Filter scale configuration
        constexpr uint32_t FSC23 = (1U << 23);  ///< Filter scale configuration
        constexpr uint32_t FSC24 = (1U << 24);  ///< Filter scale configuration
        constexpr uint32_t FSC25 = (1U << 25);  ///< Filter scale configuration
        constexpr uint32_t FSC26 = (1U << 26);  ///< Filter scale configuration
        constexpr uint32_t FSC27 = (1U << 27);  ///< Filter scale configuration
    }

    /// FFA1R Register bits
    namespace ffa1r_bits {
        constexpr uint32_t FFA0 = (1U << 0);  ///< Filter FIFO assignment for filter 0
        constexpr uint32_t FFA1 = (1U << 1);  ///< Filter FIFO assignment for filter 1
        constexpr uint32_t FFA2 = (1U << 2);  ///< Filter FIFO assignment for filter 2
        constexpr uint32_t FFA3 = (1U << 3);  ///< Filter FIFO assignment for filter 3
        constexpr uint32_t FFA4 = (1U << 4);  ///< Filter FIFO assignment for filter 4
        constexpr uint32_t FFA5 = (1U << 5);  ///< Filter FIFO assignment for filter 5
        constexpr uint32_t FFA6 = (1U << 6);  ///< Filter FIFO assignment for filter 6
        constexpr uint32_t FFA7 = (1U << 7);  ///< Filter FIFO assignment for filter 7
        constexpr uint32_t FFA8 = (1U << 8);  ///< Filter FIFO assignment for filter 8
        constexpr uint32_t FFA9 = (1U << 9);  ///< Filter FIFO assignment for filter 9
        constexpr uint32_t FFA10 = (1U << 10);  ///< Filter FIFO assignment for filter 10
        constexpr uint32_t FFA11 = (1U << 11);  ///< Filter FIFO assignment for filter 11
        constexpr uint32_t FFA12 = (1U << 12);  ///< Filter FIFO assignment for filter 12
        constexpr uint32_t FFA13 = (1U << 13);  ///< Filter FIFO assignment for filter 13
        constexpr uint32_t FFA14 = (1U << 14);  ///< Filter FIFO assignment for filter 14
        constexpr uint32_t FFA15 = (1U << 15);  ///< Filter FIFO assignment for filter 15
        constexpr uint32_t FFA16 = (1U << 16);  ///< Filter FIFO assignment for filter 16
        constexpr uint32_t FFA17 = (1U << 17);  ///< Filter FIFO assignment for filter 17
        constexpr uint32_t FFA18 = (1U << 18);  ///< Filter FIFO assignment for filter 18
        constexpr uint32_t FFA19 = (1U << 19);  ///< Filter FIFO assignment for filter 19
        constexpr uint32_t FFA20 = (1U << 20);  ///< Filter FIFO assignment for filter 20
        constexpr uint32_t FFA21 = (1U << 21);  ///< Filter FIFO assignment for filter 21
        constexpr uint32_t FFA22 = (1U << 22);  ///< Filter FIFO assignment for filter 22
        constexpr uint32_t FFA23 = (1U << 23);  ///< Filter FIFO assignment for filter 23
        constexpr uint32_t FFA24 = (1U << 24);  ///< Filter FIFO assignment for filter 24
        constexpr uint32_t FFA25 = (1U << 25);  ///< Filter FIFO assignment for filter 25
        constexpr uint32_t FFA26 = (1U << 26);  ///< Filter FIFO assignment for filter 26
        constexpr uint32_t FFA27 = (1U << 27);  ///< Filter FIFO assignment for filter 27
    }

    /// FA1R Register bits
    namespace fa1r_bits {
        constexpr uint32_t FACT0 = (1U << 0);  ///< Filter active
        constexpr uint32_t FACT1 = (1U << 1);  ///< Filter active
        constexpr uint32_t FACT2 = (1U << 2);  ///< Filter active
        constexpr uint32_t FACT3 = (1U << 3);  ///< Filter active
        constexpr uint32_t FACT4 = (1U << 4);  ///< Filter active
        constexpr uint32_t FACT5 = (1U << 5);  ///< Filter active
        constexpr uint32_t FACT6 = (1U << 6);  ///< Filter active
        constexpr uint32_t FACT7 = (1U << 7);  ///< Filter active
        constexpr uint32_t FACT8 = (1U << 8);  ///< Filter active
        constexpr uint32_t FACT9 = (1U << 9);  ///< Filter active
        constexpr uint32_t FACT10 = (1U << 10);  ///< Filter active
        constexpr uint32_t FACT11 = (1U << 11);  ///< Filter active
        constexpr uint32_t FACT12 = (1U << 12);  ///< Filter active
        constexpr uint32_t FACT13 = (1U << 13);  ///< Filter active
        constexpr uint32_t FACT14 = (1U << 14);  ///< Filter active
        constexpr uint32_t FACT15 = (1U << 15);  ///< Filter active
        constexpr uint32_t FACT16 = (1U << 16);  ///< Filter active
        constexpr uint32_t FACT17 = (1U << 17);  ///< Filter active
        constexpr uint32_t FACT18 = (1U << 18);  ///< Filter active
        constexpr uint32_t FACT19 = (1U << 19);  ///< Filter active
        constexpr uint32_t FACT20 = (1U << 20);  ///< Filter active
        constexpr uint32_t FACT21 = (1U << 21);  ///< Filter active
        constexpr uint32_t FACT22 = (1U << 22);  ///< Filter active
        constexpr uint32_t FACT23 = (1U << 23);  ///< Filter active
        constexpr uint32_t FACT24 = (1U << 24);  ///< Filter active
        constexpr uint32_t FACT25 = (1U << 25);  ///< Filter active
        constexpr uint32_t FACT26 = (1U << 26);  ///< Filter active
        constexpr uint32_t FACT27 = (1U << 27);  ///< Filter active
    }

    /// F0R1 Register bits
    namespace f0r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F0R2 Register bits
    namespace f0r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F1R1 Register bits
    namespace f1r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F1R2 Register bits
    namespace f1r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F2R1 Register bits
    namespace f2r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F2R2 Register bits
    namespace f2r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F3R1 Register bits
    namespace f3r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F3R2 Register bits
    namespace f3r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F4R1 Register bits
    namespace f4r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F4R2 Register bits
    namespace f4r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F5R1 Register bits
    namespace f5r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F5R2 Register bits
    namespace f5r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F6R1 Register bits
    namespace f6r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F6R2 Register bits
    namespace f6r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F7R1 Register bits
    namespace f7r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F7R2 Register bits
    namespace f7r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F8R1 Register bits
    namespace f8r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F8R2 Register bits
    namespace f8r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F9R1 Register bits
    namespace f9r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F9R2 Register bits
    namespace f9r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F10R1 Register bits
    namespace f10r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F10R2 Register bits
    namespace f10r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F11R1 Register bits
    namespace f11r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F11R2 Register bits
    namespace f11r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F12R1 Register bits
    namespace f12r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F12R2 Register bits
    namespace f12r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F13R1 Register bits
    namespace f13r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F13R2 Register bits
    namespace f13r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F14R1 Register bits
    namespace f14r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F14R2 Register bits
    namespace f14r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F15R1 Register bits
    namespace f15r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F15R2 Register bits
    namespace f15r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F16R1 Register bits
    namespace f16r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F16R2 Register bits
    namespace f16r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F17R1 Register bits
    namespace f17r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F17R2 Register bits
    namespace f17r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F18R1 Register bits
    namespace f18r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F18R2 Register bits
    namespace f18r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F19R1 Register bits
    namespace f19r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F19R2 Register bits
    namespace f19r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F20R1 Register bits
    namespace f20r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F20R2 Register bits
    namespace f20r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F21R1 Register bits
    namespace f21r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F21R2 Register bits
    namespace f21r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F22R1 Register bits
    namespace f22r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F22R2 Register bits
    namespace f22r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F23R1 Register bits
    namespace f23r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F23R2 Register bits
    namespace f23r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F24R1 Register bits
    namespace f24r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F24R2 Register bits
    namespace f24r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F25R1 Register bits
    namespace f25r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F25R2 Register bits
    namespace f25r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F26R1 Register bits
    namespace f26r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F26R2 Register bits
    namespace f26r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F27R1 Register bits
    namespace f27r1_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

    /// F27R2 Register bits
    namespace f27r2_bits {
        constexpr uint32_t FB0 = (1U << 0);  ///< Filter bits
        constexpr uint32_t FB1 = (1U << 1);  ///< Filter bits
        constexpr uint32_t FB2 = (1U << 2);  ///< Filter bits
        constexpr uint32_t FB3 = (1U << 3);  ///< Filter bits
        constexpr uint32_t FB4 = (1U << 4);  ///< Filter bits
        constexpr uint32_t FB5 = (1U << 5);  ///< Filter bits
        constexpr uint32_t FB6 = (1U << 6);  ///< Filter bits
        constexpr uint32_t FB7 = (1U << 7);  ///< Filter bits
        constexpr uint32_t FB8 = (1U << 8);  ///< Filter bits
        constexpr uint32_t FB9 = (1U << 9);  ///< Filter bits
        constexpr uint32_t FB10 = (1U << 10);  ///< Filter bits
        constexpr uint32_t FB11 = (1U << 11);  ///< Filter bits
        constexpr uint32_t FB12 = (1U << 12);  ///< Filter bits
        constexpr uint32_t FB13 = (1U << 13);  ///< Filter bits
        constexpr uint32_t FB14 = (1U << 14);  ///< Filter bits
        constexpr uint32_t FB15 = (1U << 15);  ///< Filter bits
        constexpr uint32_t FB16 = (1U << 16);  ///< Filter bits
        constexpr uint32_t FB17 = (1U << 17);  ///< Filter bits
        constexpr uint32_t FB18 = (1U << 18);  ///< Filter bits
        constexpr uint32_t FB19 = (1U << 19);  ///< Filter bits
        constexpr uint32_t FB20 = (1U << 20);  ///< Filter bits
        constexpr uint32_t FB21 = (1U << 21);  ///< Filter bits
        constexpr uint32_t FB22 = (1U << 22);  ///< Filter bits
        constexpr uint32_t FB23 = (1U << 23);  ///< Filter bits
        constexpr uint32_t FB24 = (1U << 24);  ///< Filter bits
        constexpr uint32_t FB25 = (1U << 25);  ///< Filter bits
        constexpr uint32_t FB26 = (1U << 26);  ///< Filter bits
        constexpr uint32_t FB27 = (1U << 27);  ///< Filter bits
        constexpr uint32_t FB28 = (1U << 28);  ///< Filter bits
        constexpr uint32_t FB29 = (1U << 29);  ///< Filter bits
        constexpr uint32_t FB30 = (1U << 30);  ///< Filter bits
        constexpr uint32_t FB31 = (1U << 31);  ///< Filter bits
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;
    constexpr uint32_t NVIC_STIR_BASE = 0xE000EF00;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER0;  ///< Offset: 0x00 - Interrupt Set-Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x04 - Interrupt Set-Enable Register
        volatile uint32_t ISER2;  ///< Offset: 0x08 - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x80 - Interrupt Clear-Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x84 - Interrupt Clear-Enable Register
        volatile uint32_t ICER2;  ///< Offset: 0x88 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x104 - Interrupt Set-Pending Register
        volatile uint32_t ISPR2;  ///< Offset: 0x108 - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x184 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR2;  ///< Offset: 0x188 - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x200 - Interrupt Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x204 - Interrupt Active Bit Register
        volatile uint32_t IABR2;  ///< Offset: 0x208 - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x320 - Interrupt Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x324 - Interrupt Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x328 - Interrupt Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x32C - Interrupt Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x330 - Interrupt Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x334 - Interrupt Priority Register
        volatile uint32_t IPR14;  ///< Offset: 0x338 - Interrupt Priority Register
        volatile uint32_t IPR15;  ///< Offset: 0x33C - Interrupt Priority Register
        volatile uint32_t IPR16;  ///< Offset: 0x340 - Interrupt Priority Register
        volatile uint32_t IPR17;  ///< Offset: 0x344 - Interrupt Priority Register
        volatile uint32_t IPR18;  ///< Offset: 0x348 - Interrupt Priority Register
        volatile uint32_t IPR19;  ///< Offset: 0x34C - Interrupt Priority Register
        volatile uint32_t IPR20;  ///< Offset: 0x350 - Interrupt Priority Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);
    inline Registers* NVIC_STIR = reinterpret_cast<Registers*>(NVIC_STIR_BASE);

    // Bit definitions
    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER2 Register bits
    namespace iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER2 Register bits
    namespace icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR2 Register bits
    namespace ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR2 Register bits
    namespace icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR2 Register bits
    namespace iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR14 Register bits
    namespace ipr14_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR15 Register bits
    namespace ipr15_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR16 Register bits
    namespace ipr16_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR17 Register bits
    namespace ipr17_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR18 Register bits
    namespace ipr18_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR19 Register bits
    namespace ipr19_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR20 Register bits
    namespace ipr20_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40023C00;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Flash access control register
        volatile uint32_t KEYR;  ///< Offset: 0x04 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x08 - Flash option key register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control register
        volatile uint32_t OPTCR;  ///< Offset: 0x14 - Flash option control register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t DCEN = (1U << 10);  ///< Data cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t DCRST = (1U << 12);  ///< Data cache reset
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< FPEC key
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEY = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protection error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t PGPERR = (1U << 6);  ///< Programming parallelism error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t RDERR = (1U << 8);  ///< Read Protection Error
        constexpr uint32_t BSY = (1U << 16);  ///< Busy
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t SER = (1U << 1);  ///< Sector Erase
        constexpr uint32_t MER = (1U << 2);  ///< Mass Erase of sectors 0 to 11
        constexpr uint32_t SNB = (4 << 3);  ///< Sector number
        constexpr uint32_t PSIZE = (2 << 8);  ///< Program size
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock
    }

    /// OPTCR Register bits
    namespace optcr_bits {
        constexpr uint32_t OPTLOCK = (1U << 0);  ///< Option lock
        constexpr uint32_t OPTSTRT = (1U << 1);  ///< Option start
        constexpr uint32_t BOR_LEV = (2 << 2);  ///< BOR reset Level
        constexpr uint32_t WDG_SW = (1U << 5);  ///< WDG_SW User option bytes
        constexpr uint32_t nRST_STOP = (1U << 6);  ///< nRST_STOP User option bytes
        constexpr uint32_t nRST_STDBY = (1U << 7);  ///< nRST_STDBY User option bytes
        constexpr uint32_t RDP = (8 << 8);  ///< Read protect
        constexpr uint32_t nWRP = (8 << 16);  ///< Not write protect
        constexpr uint32_t SPRMOD = (1U << 31);  ///< Selection of Protection Mode of nWPRi bits
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40013C00;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t IMR;  ///< Offset: 0x00 - Interrupt mask register (EXTI_IMR)
        volatile uint32_t EMR;  ///< Offset: 0x04 - Event mask register (EXTI_EMR)
        volatile uint32_t RTSR;  ///< Offset: 0x08 - Rising Trigger selection register (EXTI_RTSR)
        volatile uint32_t FTSR;  ///< Offset: 0x0C - Falling Trigger selection register (EXTI_FTSR)
        volatile uint32_t SWIER;  ///< Offset: 0x10 - Software interrupt event register (EXTI_SWIER)
        volatile uint32_t PR;  ///< Offset: 0x14 - Pending register (EXTI_PR)
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Interrupt Mask on line 0
        constexpr uint32_t MR1 = (1U << 1);  ///< Interrupt Mask on line 1
        constexpr uint32_t MR2 = (1U << 2);  ///< Interrupt Mask on line 2
        constexpr uint32_t MR3 = (1U << 3);  ///< Interrupt Mask on line 3
        constexpr uint32_t MR4 = (1U << 4);  ///< Interrupt Mask on line 4
        constexpr uint32_t MR5 = (1U << 5);  ///< Interrupt Mask on line 5
        constexpr uint32_t MR6 = (1U << 6);  ///< Interrupt Mask on line 6
        constexpr uint32_t MR7 = (1U << 7);  ///< Interrupt Mask on line 7
        constexpr uint32_t MR8 = (1U << 8);  ///< Interrupt Mask on line 8
        constexpr uint32_t MR9 = (1U << 9);  ///< Interrupt Mask on line 9
        constexpr uint32_t MR10 = (1U << 10);  ///< Interrupt Mask on line 10
        constexpr uint32_t MR11 = (1U << 11);  ///< Interrupt Mask on line 11
        constexpr uint32_t MR12 = (1U << 12);  ///< Interrupt Mask on line 12
        constexpr uint32_t MR13 = (1U << 13);  ///< Interrupt Mask on line 13
        constexpr uint32_t MR14 = (1U << 14);  ///< Interrupt Mask on line 14
        constexpr uint32_t MR15 = (1U << 15);  ///< Interrupt Mask on line 15
        constexpr uint32_t MR16 = (1U << 16);  ///< Interrupt Mask on line 16
        constexpr uint32_t MR17 = (1U << 17);  ///< Interrupt Mask on line 17
        constexpr uint32_t MR18 = (1U << 18);  ///< Interrupt Mask on line 18
        constexpr uint32_t MR19 = (1U << 19);  ///< Interrupt Mask on line 19
        constexpr uint32_t MR20 = (1U << 20);  ///< Interrupt Mask on line 20
        constexpr uint32_t MR21 = (1U << 21);  ///< Interrupt Mask on line 21
        constexpr uint32_t MR22 = (1U << 22);  ///< Interrupt Mask on line 22
    }

    /// EMR Register bits
    namespace emr_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Event Mask on line 0
        constexpr uint32_t MR1 = (1U << 1);  ///< Event Mask on line 1
        constexpr uint32_t MR2 = (1U << 2);  ///< Event Mask on line 2
        constexpr uint32_t MR3 = (1U << 3);  ///< Event Mask on line 3
        constexpr uint32_t MR4 = (1U << 4);  ///< Event Mask on line 4
        constexpr uint32_t MR5 = (1U << 5);  ///< Event Mask on line 5
        constexpr uint32_t MR6 = (1U << 6);  ///< Event Mask on line 6
        constexpr uint32_t MR7 = (1U << 7);  ///< Event Mask on line 7
        constexpr uint32_t MR8 = (1U << 8);  ///< Event Mask on line 8
        constexpr uint32_t MR9 = (1U << 9);  ///< Event Mask on line 9
        constexpr uint32_t MR10 = (1U << 10);  ///< Event Mask on line 10
        constexpr uint32_t MR11 = (1U << 11);  ///< Event Mask on line 11
        constexpr uint32_t MR12 = (1U << 12);  ///< Event Mask on line 12
        constexpr uint32_t MR13 = (1U << 13);  ///< Event Mask on line 13
        constexpr uint32_t MR14 = (1U << 14);  ///< Event Mask on line 14
        constexpr uint32_t MR15 = (1U << 15);  ///< Event Mask on line 15
        constexpr uint32_t MR16 = (1U << 16);  ///< Event Mask on line 16
        constexpr uint32_t MR17 = (1U << 17);  ///< Event Mask on line 17
        constexpr uint32_t MR18 = (1U << 18);  ///< Event Mask on line 18
        constexpr uint32_t MR19 = (1U << 19);  ///< Event Mask on line 19
        constexpr uint32_t MR20 = (1U << 20);  ///< Event Mask on line 20
        constexpr uint32_t MR21 = (1U << 21);  ///< Event Mask on line 21
        constexpr uint32_t MR22 = (1U << 22);  ///< Event Mask on line 22
    }

    /// RTSR Register bits
    namespace rtsr_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration of line 0
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration of line 1
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration of line 2
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration of line 3
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration of line 4
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration of line 5
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration of line 6
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration of line 7
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration of line 8
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration of line 9
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration of line 10
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration of line 11
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration of line 12
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration of line 13
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration of line 14
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration of line 15
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration of line 16
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration of line 17
        constexpr uint32_t TR18 = (1U << 18);  ///< Rising trigger event configuration of line 18
        constexpr uint32_t TR19 = (1U << 19);  ///< Rising trigger event configuration of line 19
        constexpr uint32_t TR20 = (1U << 20);  ///< Rising trigger event configuration of line 20
        constexpr uint32_t TR21 = (1U << 21);  ///< Rising trigger event configuration of line 21
        constexpr uint32_t TR22 = (1U << 22);  ///< Rising trigger event configuration of line 22
    }

    /// FTSR Register bits
    namespace ftsr_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Falling trigger event configuration of line 0
        constexpr uint32_t TR1 = (1U << 1);  ///< Falling trigger event configuration of line 1
        constexpr uint32_t TR2 = (1U << 2);  ///< Falling trigger event configuration of line 2
        constexpr uint32_t TR3 = (1U << 3);  ///< Falling trigger event configuration of line 3
        constexpr uint32_t TR4 = (1U << 4);  ///< Falling trigger event configuration of line 4
        constexpr uint32_t TR5 = (1U << 5);  ///< Falling trigger event configuration of line 5
        constexpr uint32_t TR6 = (1U << 6);  ///< Falling trigger event configuration of line 6
        constexpr uint32_t TR7 = (1U << 7);  ///< Falling trigger event configuration of line 7
        constexpr uint32_t TR8 = (1U << 8);  ///< Falling trigger event configuration of line 8
        constexpr uint32_t TR9 = (1U << 9);  ///< Falling trigger event configuration of line 9
        constexpr uint32_t TR10 = (1U << 10);  ///< Falling trigger event configuration of line 10
        constexpr uint32_t TR11 = (1U << 11);  ///< Falling trigger event configuration of line 11
        constexpr uint32_t TR12 = (1U << 12);  ///< Falling trigger event configuration of line 12
        constexpr uint32_t TR13 = (1U << 13);  ///< Falling trigger event configuration of line 13
        constexpr uint32_t TR14 = (1U << 14);  ///< Falling trigger event configuration of line 14
        constexpr uint32_t TR15 = (1U << 15);  ///< Falling trigger event configuration of line 15
        constexpr uint32_t TR16 = (1U << 16);  ///< Falling trigger event configuration of line 16
        constexpr uint32_t TR17 = (1U << 17);  ///< Falling trigger event configuration of line 17
        constexpr uint32_t TR18 = (1U << 18);  ///< Falling trigger event configuration of line 18
        constexpr uint32_t TR19 = (1U << 19);  ///< Falling trigger event configuration of line 19
        constexpr uint32_t TR20 = (1U << 20);  ///< Falling trigger event configuration of line 20
        constexpr uint32_t TR21 = (1U << 21);  ///< Falling trigger event configuration of line 21
        constexpr uint32_t TR22 = (1U << 22);  ///< Falling trigger event configuration of line 22
    }

    /// SWIER Register bits
    namespace swier_bits {
        constexpr uint32_t SWIER0 = (1U << 0);  ///< Software Interrupt on line 0
        constexpr uint32_t SWIER1 = (1U << 1);  ///< Software Interrupt on line 1
        constexpr uint32_t SWIER2 = (1U << 2);  ///< Software Interrupt on line 2
        constexpr uint32_t SWIER3 = (1U << 3);  ///< Software Interrupt on line 3
        constexpr uint32_t SWIER4 = (1U << 4);  ///< Software Interrupt on line 4
        constexpr uint32_t SWIER5 = (1U << 5);  ///< Software Interrupt on line 5
        constexpr uint32_t SWIER6 = (1U << 6);  ///< Software Interrupt on line 6
        constexpr uint32_t SWIER7 = (1U << 7);  ///< Software Interrupt on line 7
        constexpr uint32_t SWIER8 = (1U << 8);  ///< Software Interrupt on line 8
        constexpr uint32_t SWIER9 = (1U << 9);  ///< Software Interrupt on line 9
        constexpr uint32_t SWIER10 = (1U << 10);  ///< Software Interrupt on line 10
        constexpr uint32_t SWIER11 = (1U << 11);  ///< Software Interrupt on line 11
        constexpr uint32_t SWIER12 = (1U << 12);  ///< Software Interrupt on line 12
        constexpr uint32_t SWIER13 = (1U << 13);  ///< Software Interrupt on line 13
        constexpr uint32_t SWIER14 = (1U << 14);  ///< Software Interrupt on line 14
        constexpr uint32_t SWIER15 = (1U << 15);  ///< Software Interrupt on line 15
        constexpr uint32_t SWIER16 = (1U << 16);  ///< Software Interrupt on line 16
        constexpr uint32_t SWIER17 = (1U << 17);  ///< Software Interrupt on line 17
        constexpr uint32_t SWIER18 = (1U << 18);  ///< Software Interrupt on line 18
        constexpr uint32_t SWIER19 = (1U << 19);  ///< Software Interrupt on line 19
        constexpr uint32_t SWIER20 = (1U << 20);  ///< Software Interrupt on line 20
        constexpr uint32_t SWIER21 = (1U << 21);  ///< Software Interrupt on line 21
        constexpr uint32_t SWIER22 = (1U << 22);  ///< Software Interrupt on line 22
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR0 = (1U << 0);  ///< Pending bit 0
        constexpr uint32_t PR1 = (1U << 1);  ///< Pending bit 1
        constexpr uint32_t PR2 = (1U << 2);  ///< Pending bit 2
        constexpr uint32_t PR3 = (1U << 3);  ///< Pending bit 3
        constexpr uint32_t PR4 = (1U << 4);  ///< Pending bit 4
        constexpr uint32_t PR5 = (1U << 5);  ///< Pending bit 5
        constexpr uint32_t PR6 = (1U << 6);  ///< Pending bit 6
        constexpr uint32_t PR7 = (1U << 7);  ///< Pending bit 7
        constexpr uint32_t PR8 = (1U << 8);  ///< Pending bit 8
        constexpr uint32_t PR9 = (1U << 9);  ///< Pending bit 9
        constexpr uint32_t PR10 = (1U << 10);  ///< Pending bit 10
        constexpr uint32_t PR11 = (1U << 11);  ///< Pending bit 11
        constexpr uint32_t PR12 = (1U << 12);  ///< Pending bit 12
        constexpr uint32_t PR13 = (1U << 13);  ///< Pending bit 13
        constexpr uint32_t PR14 = (1U << 14);  ///< Pending bit 14
        constexpr uint32_t PR15 = (1U << 15);  ///< Pending bit 15
        constexpr uint32_t PR16 = (1U << 16);  ///< Pending bit 16
        constexpr uint32_t PR17 = (1U << 17);  ///< Pending bit 17
        constexpr uint32_t PR18 = (1U << 18);  ///< Pending bit 18
        constexpr uint32_t PR19 = (1U << 19);  ///< Pending bit 19
        constexpr uint32_t PR20 = (1U << 20);  ///< Pending bit 20
        constexpr uint32_t PR21 = (1U << 21);  ///< Pending bit 21
        constexpr uint32_t PR22 = (1U << 22);  ///< Pending bit 22
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40015800;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x24 - BConfiguration register 1
        volatile uint32_t BCR2;  ///< Offset: 0x28 - BConfiguration register 2
        volatile uint32_t BFRCR;  ///< Offset: 0x2C - BFRCR
        volatile uint32_t BSLOTR;  ///< Offset: 0x30 - BSlot register
        volatile uint32_t BIM;  ///< Offset: 0x34 - BInterrupt mask register2
        volatile uint32_t BSR;  ///< Offset: 0x38 - BStatus register
        volatile uint32_t BCLRFR;  ///< Offset: 0x3C - BClear flag register
        volatile uint32_t BDR;  ///< Offset: 0x40 - BData register
        volatile uint32_t ACR1;  ///< Offset: 0x04 - AConfiguration register 1
        volatile uint32_t ACR2;  ///< Offset: 0x08 - AConfiguration register 2
        volatile uint32_t AFRCR;  ///< Offset: 0x0C - AFRCR
        volatile uint32_t ASLOTR;  ///< Offset: 0x10 - ASlot register
        volatile uint32_t AIM;  ///< Offset: 0x14 - AInterrupt mask register2
        volatile uint32_t ASR;  ///< Offset: 0x18 - AStatus register
        volatile uint32_t ACLRFR;  ///< Offset: 0x1C - AClear flag register
        volatile uint32_t ADR;  ///< Offset: 0x20 - AData register
        volatile uint32_t GCR;  ///< Offset: 0x00 - Global configuration register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MCJDIV = (4 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIBEN = (1U << 16);  ///< Audio block B enable
        constexpr uint32_t OutDri = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUS = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// BFRCR Register bits
    namespace bfrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// BSLOTR Register bits
    namespace bslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// BIM Register bits
    namespace bim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// BCLRFR Register bits
    namespace bclrfr_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// BDR Register bits
    namespace bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// ACR1 Register bits
    namespace acr1_bits {
        constexpr uint32_t MCJDIV = (4 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OutDri = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// ACR2 Register bits
    namespace acr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUS = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// AFRCR Register bits
    namespace afrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// ASLOTR Register bits
    namespace aslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// AIM Register bits
    namespace aim_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// ASR Register bits
    namespace asr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only.
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// ACLRFR Register bits
    namespace aclrfr_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag.
        constexpr uint32_t CNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// ADR Register bits
    namespace adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t SYNCIN = (2 << 0);  ///< Synchronization inputs
        constexpr uint32_t SYNCOUT = (2 << 4);  ///< Synchronization outputs
    }

}

// ============================================================================
// SAI2 Peripheral
// ============================================================================

namespace sai2 {
    /// Base addresses
    constexpr uint32_t SAI2_BASE = 0x40015C00;

    /// SAI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI2 = reinterpret_cast<Registers*>(SAI2_BASE);

}

// ============================================================================
// SPDIF Peripheral
// ============================================================================

namespace spdif {
    /// Base addresses
    constexpr uint32_t SPDIF_RX_BASE = 0x40004000;

    /// SPDIF Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control register
        volatile uint32_t IMR;  ///< Offset: 0x04 - Interrupt mask register
        volatile uint32_t SR;  ///< Offset: 0x08 - Status register
        volatile uint32_t IFCR;  ///< Offset: 0x0C - Interrupt Flag Clear register
        volatile uint32_t DR;  ///< Offset: 0x10 - Data input register
        volatile uint32_t CSR;  ///< Offset: 0x14 - Channel Status register
        volatile uint32_t DIR;  ///< Offset: 0x18 - Debug Information register
    };

    /// Peripheral instances
    inline Registers* SPDIF_RX = reinterpret_cast<Registers*>(SPDIF_RX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SPDIFEN = (2 << 0);  ///< Peripheral Block Enable
        constexpr uint32_t RXDMAEN = (1U << 2);  ///< Receiver DMA ENable for data flow
        constexpr uint32_t RXSTEO = (1U << 3);  ///< STerEO Mode
        constexpr uint32_t DRFMT = (2 << 4);  ///< RX Data format
        constexpr uint32_t PMSK = (1U << 6);  ///< Mask Parity error bit
        constexpr uint32_t VMSK = (1U << 7);  ///< Mask of Validity bit
        constexpr uint32_t CUMSK = (1U << 8);  ///< Mask of channel status and user bits
        constexpr uint32_t PTMSK = (1U << 9);  ///< Mask of Preamble Type bits
        constexpr uint32_t CBDMAEN = (1U << 10);  ///< Control Buffer DMA ENable for control flow
        constexpr uint32_t CHSEL = (1U << 11);  ///< Channel Selection
        constexpr uint32_t NBTR = (2 << 12);  ///< Maximum allowed re-tries during synchronization phase
        constexpr uint32_t WFA = (1U << 14);  ///< Wait For Activity
        constexpr uint32_t INSEL = (3 << 16);  ///< input selection
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t RXNEIE = (1U << 0);  ///< RXNE interrupt enable
        constexpr uint32_t CSRNEIE = (1U << 1);  ///< Control Buffer Ready Interrupt Enable
        constexpr uint32_t PERRIE = (1U << 2);  ///< Parity error interrupt enable
        constexpr uint32_t OVRIE = (1U << 3);  ///< Overrun error Interrupt Enable
        constexpr uint32_t SBLKIE = (1U << 4);  ///< Synchronization Block Detected Interrupt Enable
        constexpr uint32_t SYNCDIE = (1U << 5);  ///< Synchronization Done
        constexpr uint32_t IFEIE = (1U << 6);  ///< Serial Interface Error Interrupt Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Read data register not empty
        constexpr uint32_t CSRNE = (1U << 1);  ///< Control Buffer register is not empty
        constexpr uint32_t PERR = (1U << 2);  ///< Parity error
        constexpr uint32_t OVR = (1U << 3);  ///< Overrun error
        constexpr uint32_t SBD = (1U << 4);  ///< Synchronization Block Detected
        constexpr uint32_t SYNCD = (1U << 5);  ///< Synchronization Done
        constexpr uint32_t FERR = (1U << 6);  ///< Framing error
        constexpr uint32_t SERR = (1U << 7);  ///< Synchronization error
        constexpr uint32_t TERR = (1U << 8);  ///< Time-out error
        constexpr uint32_t WIDTH5 = (15 << 16);  ///< Duration of 5 symbols counted with SPDIF_CLK
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t PERRCF = (1U << 2);  ///< Clears the Parity error flag
        constexpr uint32_t OVRCF = (1U << 3);  ///< Clears the Overrun error flag
        constexpr uint32_t SBDCF = (1U << 4);  ///< Clears the Synchronization Block Detected flag
        constexpr uint32_t SYNCDCF = (1U << 5);  ///< Clears the Synchronization Done flag
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (24 << 0);  ///< Parity Error bit
        constexpr uint32_t PE = (1U << 24);  ///< Parity Error bit
        constexpr uint32_t V = (1U << 25);  ///< Validity bit
        constexpr uint32_t U = (1U << 26);  ///< User bit
        constexpr uint32_t C = (1U << 27);  ///< Channel Status bit
        constexpr uint32_t PT = (2 << 28);  ///< Preamble Type
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t USR = (16 << 0);  ///< User data information
        constexpr uint32_t CS = (8 << 16);  ///< Channel A status information
        constexpr uint32_t SOB = (1U << 24);  ///< Start Of Block
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t THI = (13 << 0);  ///< Threshold HIGH
        constexpr uint32_t TLO = (13 << 16);  ///< Threshold LOW
    }

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_BASE = 0x40012C00;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t SDMMC_POWER;  ///< Offset: 0x00 - SDMMC power control register
        volatile uint32_t SDMMC_CLKCR;  ///< Offset: 0x04 - The SDMMC_CLKCR register controls the SDMMC_CK output...
        volatile uint32_t SDMMC_ARGR;  ///< Offset: 0x08 - The SDMMC_ARGR register contains a 32-bit command...
        volatile uint32_t SDMMC_CMDR;  ///< Offset: 0x0C - The SDMMC_CMDR register contains the command index and...
        volatile uint32_t SDMMC_RESP1R;  ///< Offset: 0x10 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_RESP2R;  ///< Offset: 0x14 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_RESP3R;  ///< Offset: 0x18 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_RESP4R;  ///< Offset: 0x1C - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_DTIMER;  ///< Offset: 0x24 - The SDMMC_DTIMER register contains the data timeout...
        volatile uint32_t SDMMC_DLENR;  ///< Offset: 0x28 - The SDMMC_DLENR register contains the number of data...
        volatile uint32_t SDMMC_DCTRL;  ///< Offset: 0x2C - The SDMMC_DCTRL register control the data path state...
        volatile uint32_t SDMMC_DCNTR;  ///< Offset: 0x30 - The SDMMC_DCNTR register loads the value from the data...
        volatile uint32_t SDMMC_STAR;  ///< Offset: 0x34 - The SDMMC_STAR register is a read-only register. It...
        volatile uint32_t SDMMC_ICR;  ///< Offset: 0x38 - The SDMMC_ICR register is a write-only register. Writing...
        volatile uint32_t SDMMC_MASKR;  ///< Offset: 0x3C - The interrupt mask register determines which status...
        volatile uint32_t SDMMC_ACKTIMER;  ///< Offset: 0x40 - The SDMMC_ACKTIMER register contains the acknowledgment...
        volatile uint32_t SDMMC_IDMACTRLR;  ///< Offset: 0x50 - The receive and transmit FIFOs can be read or written as...
        volatile uint32_t SDMMC_IDMABSIZER;  ///< Offset: 0x54 - The SDMMC_IDMABSIZER register contains the buffers size...
        volatile uint32_t SDMMC_IDMABASE0R;  ///< Offset: 0x58 - The SDMMC_IDMABASE0R register contains the memory buffer...
        volatile uint32_t SDMMC_IDMABASE1R;  ///< Offset: 0x5C - The SDMMC_IDMABASE1R register contains the double buffer...
        volatile uint32_t SDMMC_RESPCMDR;  ///< Offset: 0x60 - The SDMMC_RESPCMDR register contains the command index...
        volatile uint32_t SDMMC_FIFOR;  ///< Offset: 0x80 - The receive and transmit FIFOs can be only read or...
        volatile uint32_t SDMMC_VER;  ///< Offset: 0x3F4 - SDMMC IP version register
        volatile uint32_t SDMMC_ID;  ///< Offset: 0x3F8 - SDMMC IP identification register
    };

    /// Peripheral instances
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);

    // Bit definitions
    /// SDMMC_POWER Register bits
    namespace sdmmc_power_bits {
        constexpr uint32_t PWRCTRL = (2 << 0);  ///< SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
        constexpr uint32_t VSWITCH = (1U << 2);  ///< Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
        constexpr uint32_t VSWITCHEN = (1U << 3);  ///< Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
        constexpr uint32_t DIRPOL = (1U << 4);  ///< Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    }

    /// SDMMC_CLKCR Register bits
    namespace sdmmc_clkcr_bits {
        constexpr uint32_t CLKDIV = (10 << 0);  ///< Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
        constexpr uint32_t PWRSAV = (1U << 12);  ///< Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
        constexpr uint32_t WIDBUS = (2 << 14);  ///< Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        constexpr uint32_t NEGEDGE = (1U << 16);  ///< SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
        constexpr uint32_t HWFC_EN = (1U << 17);  ///< Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
        constexpr uint32_t DDR = (1U << 18);  ///< Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
        constexpr uint32_t BUSSPEED = (1U << 19);  ///< Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        constexpr uint32_t SELCLKRX = (2 << 20);  ///< Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    }

    /// SDMMC_ARGR Register bits
    namespace sdmmc_argr_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
    }

    /// SDMMC_CMDR Register bits
    namespace sdmmc_cmdr_bits {
        constexpr uint32_t CMDINDEX = (6 << 0);  ///< Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
        constexpr uint32_t CMDTRANS = (1U << 6);  ///< The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
        constexpr uint32_t CMDSTOP = (1U << 7);  ///< The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
        constexpr uint32_t WAITRESP = (2 << 8);  ///< Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
        constexpr uint32_t WAITINT = (1U << 10);  ///< CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
        constexpr uint32_t WAITPEND = (1U << 11);  ///< CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
        constexpr uint32_t CPSMEN = (1U << 12);  ///< Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
        constexpr uint32_t DTHOLD = (1U << 13);  ///< Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
        constexpr uint32_t BOOTMODE = (1U << 14);  ///< Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
        constexpr uint32_t BOOTEN = (1U << 15);  ///< Enable boot mode procedure.
        constexpr uint32_t CMDSUSPEND = (1U << 16);  ///< The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    }

    /// SDMMC_RESP1R Register bits
    namespace sdmmc_resp1r_bits {
        constexpr uint32_t CARDSTATUS1 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_RESP2R Register bits
    namespace sdmmc_resp2r_bits {
        constexpr uint32_t CARDSTATUS2 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_RESP3R Register bits
    namespace sdmmc_resp3r_bits {
        constexpr uint32_t CARDSTATUS3 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_RESP4R Register bits
    namespace sdmmc_resp4r_bits {
        constexpr uint32_t CARDSTATUS4 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_DTIMER Register bits
    namespace sdmmc_dtimer_bits {
        constexpr uint32_t DATATIME = (32 << 0);  ///< Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
    }

    /// SDMMC_DLENR Register bits
    namespace sdmmc_dlenr_bits {
        constexpr uint32_t DATALENGTH = (25 << 0);  ///< Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
    }

    /// SDMMC_DCTRL Register bits
    namespace sdmmc_dctrl_bits {
        constexpr uint32_t DTEN = (1U << 0);  ///< Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
        constexpr uint32_t DTDIR = (1U << 1);  ///< Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t DTMODE = (2 << 2);  ///< Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t DBLOCKSIZE = (4 << 4);  ///< Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
        constexpr uint32_t RWSTART = (1U << 8);  ///< Read wait start. If this bit is set, read wait operation starts.
        constexpr uint32_t RWSTOP = (1U << 9);  ///< Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
        constexpr uint32_t RWMOD = (1U << 10);  ///< Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
        constexpr uint32_t BOOTACKEN = (1U << 12);  ///< Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t FIFORST = (1U << 13);  ///< FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    }

    /// SDMMC_DCNTR Register bits
    namespace sdmmc_dcntr_bits {
        constexpr uint32_t DATACOUNT = (27 << 0);  ///< Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
    }

    /// SDMMC_STAR Register bits
    namespace sdmmc_star_bits {
        constexpr uint32_t CCRCFAIL = (1U << 0);  ///< Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DCRCFAIL = (1U << 1);  ///< Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CTIMEOUT = (1U << 2);  ///< Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
        constexpr uint32_t DTIMEOUT = (1U << 3);  ///< Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t TXUNDERR = (1U << 4);  ///< Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t RXOVERR = (1U << 5);  ///< Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CMDREND = (1U << 6);  ///< Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CMDSENT = (1U << 7);  ///< Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DATAEND = (1U << 8);  ///< Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DHOLD = (1U << 9);  ///< Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DBCKEND = (1U << 10);  ///< Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DABORT = (1U << 11);  ///< Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DPSMACT = (1U << 12);  ///< Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
        constexpr uint32_t CPSMACT = (1U << 13);  ///< Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
        constexpr uint32_t TXFIFOHE = (1U << 14);  ///< Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
        constexpr uint32_t RXFIFOHF = (1U << 15);  ///< Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
        constexpr uint32_t TXFIFOF = (1U << 16);  ///< Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
        constexpr uint32_t RXFIFOF = (1U << 17);  ///< Receive FIFO full This bit is cleared when one FIFO location becomes empty.
        constexpr uint32_t TXFIFOE = (1U << 18);  ///< Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
        constexpr uint32_t RXFIFOE = (1U << 19);  ///< Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
        constexpr uint32_t BUSYD0 = (1U << 20);  ///< Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
        constexpr uint32_t BUSYD0END = (1U << 21);  ///< end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t SDIOIT = (1U << 22);  ///< SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t ACKFAIL = (1U << 23);  ///< Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t ACKTIMEOUT = (1U << 24);  ///< Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t VSWEND = (1U << 25);  ///< Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CKSTOP = (1U << 26);  ///< SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t IDMATE = (1U << 27);  ///< IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t IDMABTC = (1U << 28);  ///< IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    }

    /// SDMMC_ICR Register bits
    namespace sdmmc_icr_bits {
        constexpr uint32_t CCRCFAILC = (1U << 0);  ///< CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
        constexpr uint32_t DCRCFAILC = (1U << 1);  ///< DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
        constexpr uint32_t CTIMEOUTC = (1U << 2);  ///< CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
        constexpr uint32_t DTIMEOUTC = (1U << 3);  ///< DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
        constexpr uint32_t TXUNDERRC = (1U << 4);  ///< TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
        constexpr uint32_t RXOVERRC = (1U << 5);  ///< RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
        constexpr uint32_t CMDRENDC = (1U << 6);  ///< CMDREND flag clear bit Set by software to clear the CMDREND flag.
        constexpr uint32_t CMDSENTC = (1U << 7);  ///< CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
        constexpr uint32_t DATAENDC = (1U << 8);  ///< DATAEND flag clear bit Set by software to clear the DATAEND flag.
        constexpr uint32_t DHOLDC = (1U << 9);  ///< DHOLD flag clear bit Set by software to clear the DHOLD flag.
        constexpr uint32_t DBCKENDC = (1U << 10);  ///< DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
        constexpr uint32_t DABORTC = (1U << 11);  ///< DABORT flag clear bit Set by software to clear the DABORT flag.
        constexpr uint32_t BUSYD0ENDC = (1U << 21);  ///< BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
        constexpr uint32_t SDIOITC = (1U << 22);  ///< SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
        constexpr uint32_t ACKFAILC = (1U << 23);  ///< ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
        constexpr uint32_t ACKTIMEOUTC = (1U << 24);  ///< ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
        constexpr uint32_t VSWENDC = (1U << 25);  ///< VSWEND flag clear bit Set by software to clear the VSWEND flag.
        constexpr uint32_t CKSTOPC = (1U << 26);  ///< CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
        constexpr uint32_t IDMATEC = (1U << 27);  ///< IDMA transfer error clear bit Set by software to clear the IDMATE flag.
        constexpr uint32_t IDMABTCC = (1U << 28);  ///< IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    }

    /// SDMMC_MASKR Register bits
    namespace sdmmc_maskr_bits {
        constexpr uint32_t CCRCFAILIE = (1U << 0);  ///< Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
        constexpr uint32_t DCRCFAILIE = (1U << 1);  ///< Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
        constexpr uint32_t CTIMEOUTIE = (1U << 2);  ///< Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
        constexpr uint32_t DTIMEOUTIE = (1U << 3);  ///< Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
        constexpr uint32_t TXUNDERRIE = (1U << 4);  ///< Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
        constexpr uint32_t RXOVERRIE = (1U << 5);  ///< Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
        constexpr uint32_t CMDRENDIE = (1U << 6);  ///< Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
        constexpr uint32_t CMDSENTIE = (1U << 7);  ///< Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
        constexpr uint32_t DATAENDIE = (1U << 8);  ///< Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
        constexpr uint32_t DHOLDIE = (1U << 9);  ///< Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
        constexpr uint32_t DBCKENDIE = (1U << 10);  ///< Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
        constexpr uint32_t DABORTIE = (1U << 11);  ///< Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
        constexpr uint32_t TXFIFOHEIE = (1U << 14);  ///< Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
        constexpr uint32_t RXFIFOHFIE = (1U << 15);  ///< Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
        constexpr uint32_t RXFIFOFIE = (1U << 17);  ///< Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
        constexpr uint32_t TXFIFOEIE = (1U << 18);  ///< Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
        constexpr uint32_t BUSYD0ENDIE = (1U << 21);  ///< BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
        constexpr uint32_t SDIOITIE = (1U << 22);  ///< SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
        constexpr uint32_t ACKFAILIE = (1U << 23);  ///< Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
        constexpr uint32_t ACKTIMEOUTIE = (1U << 24);  ///< Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
        constexpr uint32_t VSWENDIE = (1U << 25);  ///< Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
        constexpr uint32_t CKSTOPIE = (1U << 26);  ///< Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
        constexpr uint32_t IDMABTCIE = (1U << 28);  ///< IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    }

    /// SDMMC_ACKTIMER Register bits
    namespace sdmmc_acktimer_bits {
        constexpr uint32_t ACKTIME = (25 << 0);  ///< Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
    }

    /// SDMMC_IDMACTRLR Register bits
    namespace sdmmc_idmactrlr_bits {
        constexpr uint32_t IDMAEN = (1U << 0);  ///< IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABMODE = (1U << 1);  ///< Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABACT = (1U << 2);  ///< Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    }

    /// SDMMC_IDMABSIZER Register bits
    namespace sdmmc_idmabsizer_bits {
        constexpr uint32_t IDMABNDT = (8 << 5);  ///< Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    }

    /// SDMMC_IDMABASE0R Register bits
    namespace sdmmc_idmabase0r_bits {
        constexpr uint32_t IDMABASE0 = (32 << 0);  ///< Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
    }

    /// SDMMC_IDMABASE1R Register bits
    namespace sdmmc_idmabase1r_bits {
        constexpr uint32_t IDMABASE1 = (32 << 0);  ///< Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
    }

    /// SDMMC_RESPCMDR Register bits
    namespace sdmmc_respcmdr_bits {
        constexpr uint32_t RESPCMD = (6 << 0);  ///< Response command index Read-only bit field. Contains the command index of the last command response received.
    }

    /// SDMMC_FIFOR Register bits
    namespace sdmmc_fifor_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
    }

    /// SDMMC_VER Register bits
    namespace sdmmc_ver_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< IP minor revision number.
        constexpr uint32_t MAJREV = (4 << 4);  ///< IP major revision number.
    }

    /// SDMMC_ID Register bits
    namespace sdmmc_id_bits {
        constexpr uint32_t IP_ID = (32 << 0);  ///< SDMMC IP identification.
    }

}

// ============================================================================
// HDMI Peripheral
// ============================================================================

namespace hdmi {
    /// Base addresses
    constexpr uint32_t HDMI_CEC_BASE = 0x40006C00;

    /// HDMI Register structure
    struct Registers {
        volatile uint32_t CEC_CR;  ///< Offset: 0x00 - CEC control register
        volatile uint32_t CEC_CFGR;  ///< Offset: 0x04 - CEC configuration register
        volatile uint32_t CEC_TXDR;  ///< Offset: 0x08 - CEC Tx data register
        volatile uint32_t CEC_RXDR;  ///< Offset: 0x0C - CEC Rx Data Register
        volatile uint32_t CEC_ISR;  ///< Offset: 0x10 - CEC Interrupt and Status Register
        volatile uint32_t CEC_IER;  ///< Offset: 0x14 - CEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* HDMI_CEC = reinterpret_cast<Registers*>(HDMI_CEC_BASE);

    // Bit definitions
    /// CEC_CR Register bits
    namespace cec_cr_bits {
        constexpr uint32_t TXEOM = (1U << 2);  ///< Tx End Of Message
        constexpr uint32_t TXSOM = (1U << 1);  ///< Tx Start Of Message
        constexpr uint32_t CECEN = (1U << 0);  ///< CEC Enable
    }

    /// CEC_CFGR Register bits
    namespace cec_cfgr_bits {
        constexpr uint32_t LSTN = (1U << 31);  ///< Listen mode
        constexpr uint32_t OAR = (15 << 16);  ///< Own addresses configuration
        constexpr uint32_t SFTOP = (1U << 8);  ///< SFT Option Bit
        constexpr uint32_t BRDNOGEN = (1U << 7);  ///< Avoid Error-Bit Generation in Broadcast
        constexpr uint32_t LBPEGEN = (1U << 6);  ///< Generate Error-Bit on Long Bit Period Error
        constexpr uint32_t BREGEN = (1U << 5);  ///< Generate Error-Bit on Bit Rising Error
        constexpr uint32_t BRESTP = (1U << 4);  ///< Rx-Stop on Bit Rising Error
        constexpr uint32_t RXTOL = (1U << 3);  ///< Rx-Tolerance
        constexpr uint32_t SFT = (3 << 0);  ///< Signal Free Time
    }

    /// CEC_TXDR Register bits
    namespace cec_txdr_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< Tx Data register
    }

    /// CEC_RXDR Register bits
    namespace cec_rxdr_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< Rx Data register
    }

    /// CEC_ISR Register bits
    namespace cec_isr_bits {
        constexpr uint32_t TXACKE = (1U << 12);  ///< Tx-Missing Acknowledge Error
        constexpr uint32_t TXERR = (1U << 11);  ///< Tx-Error
        constexpr uint32_t TXUDR = (1U << 10);  ///< Tx-Buffer Underrun
        constexpr uint32_t TXEND = (1U << 9);  ///< End of Transmission
        constexpr uint32_t TXBR = (1U << 8);  ///< Tx-Byte Request
        constexpr uint32_t ARBLST = (1U << 7);  ///< Arbitration Lost
        constexpr uint32_t RXACKE = (1U << 6);  ///< Rx-Missing Acknowledge
        constexpr uint32_t LBPE = (1U << 5);  ///< Rx-Long Bit Period Error
        constexpr uint32_t SBPE = (1U << 4);  ///< Rx-Short Bit Period Error
        constexpr uint32_t BRE = (1U << 3);  ///< Rx-Bit Rising Error
        constexpr uint32_t RXOVR = (1U << 2);  ///< Rx-Overrun
        constexpr uint32_t RXEND = (1U << 1);  ///< End Of Reception
        constexpr uint32_t RXBR = (1U << 0);  ///< Rx-Byte Received
    }

    /// CEC_IER Register bits
    namespace cec_ier_bits {
        constexpr uint32_t TXACKIE = (1U << 12);  ///< Tx-Missing Acknowledge Error Interrupt Enable
        constexpr uint32_t TXERRIE = (1U << 11);  ///< Tx-Error Interrupt Enable
        constexpr uint32_t TXUDRIE = (1U << 10);  ///< Tx-Underrun Interrupt Enable
        constexpr uint32_t TXENDIE = (1U << 9);  ///< Tx-End Of Message Interrupt Enable
        constexpr uint32_t TXBRIE = (1U << 8);  ///< Tx-Byte Request Interrupt Enable
        constexpr uint32_t ARBLSTIE = (1U << 7);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t RXACKIE = (1U << 6);  ///< Rx-Missing Acknowledge Error Interrupt Enable
        constexpr uint32_t LBPEIE = (1U << 5);  ///< Long Bit Period Error Interrupt Enable
        constexpr uint32_t SBPEIE = (1U << 4);  ///< Short Bit Period Error Interrupt Enable
        constexpr uint32_t BREIE = (1U << 3);  ///< Bit Rising Error Interrupt Enable
        constexpr uint32_t RXOVRIE = (1U << 2);  ///< Rx-Buffer Overrun Interrupt Enable
        constexpr uint32_t RXENDIE = (1U << 1);  ///< End Of Reception Interrupt Enable
        constexpr uint32_t RXBRIE = (1U << 0);  ///< Rx-Byte Received Interrupt Enable
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_BASE = 0xE000EF34;
    constexpr uint32_t FPU_CPACR_BASE = 0xE000ED88;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t FPCCR;  ///< Offset: 0x00 - Floating-point context control register
        volatile uint32_t FPCAR;  ///< Offset: 0x04 - Floating-point context address register
        volatile uint32_t FPSCR;  ///< Offset: 0x08 - Floating-point status control register
    };

    /// Peripheral instances
    inline Registers* FPU = reinterpret_cast<Registers*>(FPU_BASE);
    inline Registers* FPU_CPACR = reinterpret_cast<Registers*>(FPU_CPACR_BASE);

    // Bit definitions
    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t LSPACT = (1U << 0);  ///< LSPACT
        constexpr uint32_t USER = (1U << 1);  ///< USER
        constexpr uint32_t THREAD = (1U << 3);  ///< THREAD
        constexpr uint32_t HFRDY = (1U << 4);  ///< HFRDY
        constexpr uint32_t MMRDY = (1U << 5);  ///< MMRDY
        constexpr uint32_t BFRDY = (1U << 6);  ///< BFRDY
        constexpr uint32_t MONRDY = (1U << 8);  ///< MONRDY
        constexpr uint32_t LSPEN = (1U << 30);  ///< LSPEN
        constexpr uint32_t ASPEN = (1U << 31);  ///< ASPEN
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 3);  ///< Location of unpopulated floating-point
    }

    /// FPSCR Register bits
    namespace fpscr_bits {
        constexpr uint32_t IOC = (1U << 0);  ///< Invalid operation cumulative exception bit
        constexpr uint32_t DZC = (1U << 1);  ///< Division by zero cumulative exception bit.
        constexpr uint32_t OFC = (1U << 2);  ///< Overflow cumulative exception bit
        constexpr uint32_t UFC = (1U << 3);  ///< Underflow cumulative exception bit
        constexpr uint32_t IXC = (1U << 4);  ///< Inexact cumulative exception bit
        constexpr uint32_t IDC = (1U << 7);  ///< Input denormal cumulative exception bit.
        constexpr uint32_t RMode = (2 << 22);  ///< Rounding Mode control field
        constexpr uint32_t FZ = (1U << 24);  ///< Flush-to-zero mode control bit:
        constexpr uint32_t DN = (1U << 25);  ///< Default NaN mode control bit
        constexpr uint32_t AHP = (1U << 26);  ///< Alternative half-precision control bit
        constexpr uint32_t V = (1U << 28);  ///< Overflow condition code flag
        constexpr uint32_t C = (1U << 29);  ///< Carry condition code flag
        constexpr uint32_t Z = (1U << 30);  ///< Zero condition code flag
        constexpr uint32_t N = (1U << 31);  ///< Negative condition code flag
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000ED90;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t MPU_TYPER;  ///< Offset: 0x00 - MPU type register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0x04 - MPU control register
        volatile uint32_t MPU_RNR;  ///< Offset: 0x08 - MPU region number register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0x0C - MPU region base address register
        volatile uint32_t MPU_RASR;  ///< Offset: 0x10 - MPU region attribute and size register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// MPU_TYPER Register bits
    namespace mpu_typer_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate flag
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables the MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enables the operation of MPU during hard fault
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enable priviliged software access to default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< MPU region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< Size of the MPU protection region
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< memory attribute
        constexpr uint32_t C = (1U << 17);  ///< memory attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable memory attribute
        constexpr uint32_t TEX = (3 << 19);  ///< memory attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

}

// ============================================================================
// STK Peripheral
// ============================================================================

namespace stk {
    /// Base addresses
    constexpr uint32_t STK_BASE = 0xE000E010;

    /// STK Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - SysTick control and status register
        volatile uint32_t LOAD;  ///< Offset: 0x04 - SysTick reload value register
        volatile uint32_t VAL;  ///< Offset: 0x08 - SysTick current value register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick calibration value register
    };

    /// Peripheral instances
    inline Registers* STK = reinterpret_cast<Registers*>(STK_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick exception request enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source selection
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< COUNTFLAG
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< RELOAD value
    }

    /// VAL Register bits
    namespace val_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Calibration value
        constexpr uint32_t SKEW = (1U << 30);  ///< SKEW flag: Indicates whether the TENMS value is exact
        constexpr uint32_t NOREF = (1U << 31);  ///< NOREF flag. Reads as zero
    }

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED00;
    constexpr uint32_t SCB_ACTRL_BASE = 0xE000E008;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - CPUID base register
        volatile uint32_t ICSR;  ///< Offset: 0x04 - Interrupt control and state register
        volatile uint32_t VTOR;  ///< Offset: 0x08 - Vector table offset register
        volatile uint32_t AIRCR;  ///< Offset: 0x0C - Application interrupt and reset control register
        volatile uint32_t SCR;  ///< Offset: 0x10 - System control register
        volatile uint32_t CCR;  ///< Offset: 0x14 - Configuration and control register
        volatile uint32_t SHPR1;  ///< Offset: 0x18 - System handler priority registers
        volatile uint32_t SHPR2;  ///< Offset: 0x1C - System handler priority registers
        volatile uint32_t SHPR3;  ///< Offset: 0x20 - System handler priority registers
        volatile uint32_t SHCRS;  ///< Offset: 0x24 - System handler control and state register
        volatile uint32_t CFSR_UFSR_BFSR_MMFSR;  ///< Offset: 0x28 - Configurable fault status register
        volatile uint32_t HFSR;  ///< Offset: 0x2C - Hard fault status register
        volatile uint32_t MMFAR;  ///< Offset: 0x34 - Memory management fault address register
        volatile uint32_t BFAR;  ///< Offset: 0x38 - Bus fault address register
        volatile uint32_t AFSR;  ///< Offset: 0x3C - Auxiliary fault status register
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);
    inline Registers* SCB_ACTRL = reinterpret_cast<Registers*>(SCB_ACTRL_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Constant = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active vector
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to base level
        constexpr uint32_t VECTPENDING = (7 << 12);  ///< Pending vector
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit.
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (21 << 9);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< VECTRESET
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< SYSRESETREQ
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< PRIGROUP
        constexpr uint32_t ENDIANESS = (1U << 15);  ///< ENDIANESS
        constexpr uint32_t VECTKEYSTAT = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< SLEEPONEXIT
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< SLEEPDEEP
        constexpr uint32_t SEVEONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Configures how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< USERSETMPEND
        constexpr uint32_t UNALIGN__TRP = (1U << 3);  ///< UNALIGN_ TRP
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< DIV_0_TRP
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< BFHFNMIGN
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

    /// SHCRS Register bits
    namespace shcrs_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< Memory management fault exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< Bus fault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< Usage fault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVC call active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< Usage fault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< Memory management fault exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< Bus fault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVC call pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< Memory management fault enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< Bus fault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< Usage fault enable bit
    }

    /// CFSR_UFSR_BFSR_MMFSR Register bits
    namespace cfsr_ufsr_bfsr_mmfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 1);  ///< Instruction access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< Memory manager fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< Memory manager fault on stacking for exception entry.
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MLSPERR
        constexpr uint32_t MMARVALID = (1U << 7);  ///< Memory Management Fault Address Register (MMAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< Bus fault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< Bus fault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< Bus fault on floating-point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< Bus Fault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction usage fault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state usage fault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load usage fault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor usage fault.
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access usage fault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero usage fault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< Vector table hard fault
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced hard fault
        constexpr uint32_t DEBUG_VT = (1U << 31);  ///< Reserved for Debug use
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t MMFAR = (32 << 0);  ///< Memory management fault address
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t BFAR = (32 << 0);  ///< Bus fault address
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t IMPDEF = (32 << 0);  ///< Implementation defined
    }

}


} // namespace alloy::generated::stm32f446

#endif // ALLOY_GENERATED_STM32F446_PERIPHERALS_HPP