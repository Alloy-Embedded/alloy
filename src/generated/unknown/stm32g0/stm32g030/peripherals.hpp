/// Auto-generated code for STM32G030
/// Generated by Alloy Code Generator
/// Source: st_stm32g030.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:40
#ifndef ALLOY_GENERATED_STM32G030_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32G030_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32g030 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 6;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR;  ///< Offset: 0x14 - ADC sampling time register
        volatile uint32_t ADC_AWD1TR;  ///< Offset: 0x20 - ADC watchdog threshold register
        volatile uint32_t ADC_AWD2TR;  ///< Offset: 0x24 - ADC watchdog threshold register
        volatile uint32_t ADC_CHSELR_0;  ///< Offset: 0x28 - ADC channel selection register [alternate]
        volatile uint32_t ADC_CHSELR_1;  ///< Offset: 0x28 - channel selection register CHSELRMOD = 1 in ADC_CFGR1
        volatile uint32_t ADC_AWD3TR;  ///< Offset: 0x2C - ADC watchdog threshold register
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC Analog Watchdog 2 Configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC Analog Watchdog 3 Configuration register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xB4 - ADC Calibration factor
        volatile uint32_t ADC_CCR;  ///< Offset: 0x308 - ADC common configuration register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready This bit is set by hardware after the ADC has been enabled (ADEN=1) and when the ADC reaches a state where it is ready to accept conversion requests. It is cleared by software writing 1 to it.
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1â.
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
        constexpr uint32_t EOS = (1U << 3);  ///< End of sequence flag This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
        constexpr uint32_t AWD1 = (1U << 7);  ///< Analog watchdog 1 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
        constexpr uint32_t AWD2 = (1U << 8);  ///< Analog watchdog 2 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
        constexpr uint32_t AWD3 = (1U << 9);  ///< Analog watchdog 3 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
        constexpr uint32_t CCRDY = (1U << 13);  ///< Channel Configuration Ready flag This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it. Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable This bit is set and cleared by software to enable/disable the ADC Ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of conversion interrupt enable This bit is set and cleared by software to enable/disable the end of conversion interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of conversion sequence interrupt enable This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable This bit is set and cleared by software to enable/disable the overrun interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1IE = (1U << 7);  ///< Analog watchdog 1 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD2IE = (1U << 8);  ///< Analog watchdog 2 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD3IE = (1U << 9);  ///< Analog watchdog 3 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable This bit is set and cleared by software to enable/disable the end of calibration interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CCRDYIE = (1U << 13);  ///< Channel Configuration Ready Interrupt enable This bit is set and cleared by software to enable/disable the channel configuration ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable command This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set. It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command. Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0, ADSTP=0, ADSTART=0, ADDIS=0 and ADEN=0)
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state). It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time). Note: Setting ADDIS to '1â is only effective when ADEN=1 and ADSTART=0 (which ensures that no conversion is ongoing)
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start conversion command This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration). It is cleared by hardware: In single conversion mode (CONT=0, DISCEN=0), when software trigger is selected (EXTEN=00): at the assertion of the end of Conversion Sequence (EOS) flag. In discontinuous conversion mode(CONT=0, DISCEN=1), when the software trigger is selected (EXTEN=00): at the assertion of the end of Conversion (EOC) flag. In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware. Note: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled and there is no pending request to disable the ADC). After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop conversion command This bit is set by software to stop and discard an ongoing conversion (ADSTP Command). It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command. Note: Setting ADSTP to '1â is only effective when ADSTART=1 and ADDIS=0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC Voltage Regulator Enable This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP. It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0. Note: The software is allowed to program this bit field only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration This bit is set by software to start the calibration of the ADC. It is cleared by hardware after calibration is complete. Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0). The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN=1 and ADSTART=0 (ADC enabled and no conversion is ongoing).
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< Direct memory access enable This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to . Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t DMACFG = (1U << 1);  ///< Direct memory access configuration This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN=1. For more details, refer to page351 Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t RES = (2 << 3);  ///< Data resolution These bits are written by software to select the resolution of the conversion. Note: The software is allowed to write these bits only when ADEN=0.
        constexpr uint32_t ALIGN = (1U << 5);  ///< Data alignment This bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page349 Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EXTSEL = (3 << 6);  ///< External trigger selection These bits select the external event used to trigger the start of conversion (refer to External triggers for details): Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection These bits are set and cleared by software to select the external trigger polarity and enable the trigger. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun management mode This bit is set and cleared by software and configure the way data overruns are managed. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t WAIT = (1U << 14);  ///< Wait conversion mode This bit is set and cleared by software to enable/disable wait conversion mode.. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode This bit is set and cleared by software to enable/disable auto-off mode.. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode This bit is set and cleared by software to enable/disable discontinuous mode. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CHSELRMOD = (1U << 21);  ///< Mode selection of the ADC_CHSELR register This bit is set and cleared by software to control the ADC_CHSELR feature: Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< Enable the watchdog on a single channel or on all channels This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1EN = (1U << 23);  ///< Analog watchdog enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1CH = (5 << 26);  ///< Analog watchdog channel selection These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. ..... Others: Reserved Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t OVSE = (1U << 0);  ///< Oversampler Enable This bit is set and cleared by software. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OVSR = (3 << 2);  ///< Oversampling ratio This bit filed defines the number of oversampling ratio. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OVSS = (4 << 5);  ///< Oversampling shift This bit is set and cleared by software. Others: Reserved Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TOVS = (1U << 9);  ///< Triggered Oversampling This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t LFTRIG = (1U << 29);  ///< Low frequency trigger mode enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode These bits are set and cleared by software to define how the analog ADC is clocked: In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
    }

    /// ADC_SMPR Register bits
    namespace adc_smpr_bits {
        constexpr uint32_t SMP1 = (3 << 0);  ///< Sampling time selection 1 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP2 = (3 << 4);  ///< Sampling time selection 2 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL0 = (1U << 8);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL1 = (1U << 9);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL2 = (1U << 10);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL3 = (1U << 11);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL4 = (1U << 12);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL5 = (1U << 13);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL6 = (1U << 14);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL7 = (1U << 15);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL8 = (1U << 16);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL9 = (1U << 17);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL10 = (1U << 18);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL11 = (1U << 19);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL12 = (1U << 20);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL13 = (1U << 21);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL14 = (1U << 22);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL15 = (1U << 23);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL16 = (1U << 24);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL17 = (1U << 25);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL18 = (1U << 26);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD1TR Register bits
    namespace adc_awd1tr_bits {
        constexpr uint32_t LT1 = (12 << 0);  ///< Analog watchdog 1 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
        constexpr uint32_t HT1 = (12 << 16);  ///< Analog watchdog 1 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
    }

    /// ADC_AWD2TR Register bits
    namespace adc_awd2tr_bits {
        constexpr uint32_t LT2 = (12 << 0);  ///< Analog watchdog 2 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
        constexpr uint32_t HT2 = (12 << 16);  ///< Analog watchdog 2 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
    }

    /// ADC_CHSELR_0 Register bits
    namespace adc_chselr_0_bits {
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL8 = (1U << 8);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL9 = (1U << 9);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL10 = (1U << 10);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL11 = (1U << 11);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL12 = (1U << 12);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL13 = (1U << 13);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL14 = (1U << 14);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL15 = (1U << 15);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL16 = (1U << 16);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL17 = (1U << 17);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL18 = (1U << 18);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    }

    /// ADC_CHSELR_1 Register bits
    namespace adc_chselr_1_bits {
        constexpr uint32_t SQ1 = (4 << 0);  ///< 1st conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ2 = (4 << 4);  ///< 2nd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ3 = (4 << 8);  ///< 3rd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ4 = (4 << 12);  ///< 4th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ5 = (4 << 16);  ///< 5th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ6 = (4 << 20);  ///< 6th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ7 = (4 << 24);  ///< 7th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ8 = (4 << 28);  ///< 8th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. ... Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3TR Register bits
    namespace adc_awd3tr_bits {
        constexpr uint32_t LT3 = (12 << 0);  ///< Analog watchdog 3lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
        constexpr uint32_t HT3 = (12 << 16);  ///< Analog watchdog 3 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Converted data These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page349. Just after a calibration is complete, DATA[6:0] contains the calibration factor.
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH0 = (1U << 0);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH1 = (1U << 1);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH2 = (1U << 2);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH3 = (1U << 3);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH4 = (1U << 4);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH5 = (1U << 5);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH6 = (1U << 6);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH7 = (1U << 7);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH8 = (1U << 8);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH9 = (1U << 9);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH10 = (1U << 10);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH11 = (1U << 11);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH12 = (1U << 12);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH13 = (1U << 13);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH14 = (1U << 14);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH15 = (1U << 15);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH16 = (1U << 16);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH17 = (1U << 17);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH18 = (1U << 18);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH0 = (1U << 0);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH1 = (1U << 1);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH2 = (1U << 2);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH3 = (1U << 3);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH4 = (1U << 4);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH5 = (1U << 5);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH6 = (1U << 6);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH7 = (1U << 7);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH8 = (1U << 8);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH9 = (1U << 9);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH10 = (1U << 10);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH11 = (1U << 11);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH12 = (1U << 12);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH13 = (1U << 13);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH14 = (1U << 14);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH15 = (1U << 15);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH16 = (1U << 16);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH17 = (1U << 17);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH18 = (1U << 18);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< Calibration factor These bits are written by hardware or by software. Once a calibration is complete,they are updated by hardware with the calibration factors. Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched. Just after a calibration is complete, DATA[6:0] contains the calibration factor. Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.
    }

    /// ADC_CCR Register bits
    namespace adc_ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable This bit is set and cleared by software to enable/disable the VREFINT. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable This bit is set and cleared by software to enable/disable the temperature sensor. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t VBATEN = (1U << 24);  ///< VBAT enable This bit is set and cleared by software to enable/disable the VBAT channel. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t KEYR;  ///< Offset: 0x08 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x0C - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t CR;  ///< Offset: 0x14 - Flash control register
        volatile uint32_t ECCR;  ///< Offset: 0x18 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x20 - Flash option register
        volatile uint32_t WRP1AR;  ///< Offset: 0x2C - Flash WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x30 - Flash WRP area B address register
        volatile uint32_t WRP2AR;  ///< Offset: 0x4C - FLASH WRP2 area A address register
        volatile uint32_t WRP2BR;  ///< Offset: 0x50 - FLASH WRP2 area B address register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t EMPTY = (1U << 16);  ///< Flash User area empty
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< KEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t MISERR = (1U << 8);  ///< Fast programming data miss error
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option and Engineering bits loading validity error
        constexpr uint32_t BSY1 = (1U << 16);  ///< BSY1
        constexpr uint32_t BSY2 = (1U << 17);  ///< BSY2
        constexpr uint32_t CFGBSY = (1U << 18);  ///< Programming or erase configuration busy.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Mass erase
        constexpr uint32_t PNB = (10 << 3);  ///< Page number
        constexpr uint32_t BKER = (1U << 13);  ///< BKER
        constexpr uint32_t MER2 = (1U << 15);  ///< MER2
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (14 << 0);  ///< ECC fail address
        constexpr uint32_t SYSF_ECC = (1U << 20);  ///< ECC fail for Corrected ECC Error or Double ECC Error in info block
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t nRST_STOP = (1U << 13);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 14);  ///< nRST_STDBY
        constexpr uint32_t IDWG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t nSWAP_BANK = (1U << 20);  ///< nSWAP_BANK
        constexpr uint32_t DUAL_BANK = (1U << 21);  ///< DUAL_BANK
        constexpr uint32_t RAM_PARITY_CHECK = (1U << 22);  ///< SRAM parity check control
        constexpr uint32_t nBOOT_SEL = (1U << 24);  ///< nBOOT_SEL
        constexpr uint32_t nBOOT1 = (1U << 25);  ///< Boot configuration
        constexpr uint32_t nBOOT0 = (1U << 26);  ///< nBOOT0 option bit
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (7 << 0);  ///< WRP area A start offset
        constexpr uint32_t WRP1A_END = (7 << 16);  ///< WRP area A end offset
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (7 << 0);  ///< WRP area B start offset
        constexpr uint32_t WRP1B_END = (7 << 16);  ///< WRP area B end offset
    }

    /// WRP2AR Register bits
    namespace wrp2ar_bits {
        constexpr uint32_t WRP2A_STRT = (7 << 0);  ///< WRP2A_STRT
        constexpr uint32_t WRP2A_END = (7 << 16);  ///< WRP2A_END
    }

    /// WRP2BR Register bits
    namespace wrp2br_bits {
        constexpr uint32_t WRP2B_STRT = (7 << 0);  ///< WRP2B_STRT
        constexpr uint32_t WRP2B_END = (7 << 16);  ///< WRP2B_END
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t PLLSYSCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t IOPRSTR;  ///< Offset: 0x24 - I/O port reset register
        volatile uint32_t AHBRSTR;  ///< Offset: 0x28 - AHB peripheral reset register
        volatile uint32_t APBRSTR1;  ///< Offset: 0x2C - APB peripheral reset register 1
        volatile uint32_t APBRSTR2;  ///< Offset: 0x30 - APB peripheral reset register 2
        volatile uint32_t IOPENR;  ///< Offset: 0x34 - GPIO clock enable register
        volatile uint32_t AHBENR;  ///< Offset: 0x38 - AHB peripheral clock enable register
        volatile uint32_t APBENR1;  ///< Offset: 0x3C - APB peripheral clock enable register 1
        volatile uint32_t APBENR2;  ///< Offset: 0x40 - APB peripheral clock enable register 2
        volatile uint32_t IOPSMENR;  ///< Offset: 0x44 - GPIO in Sleep mode clock enable register
        volatile uint32_t AHBSMENR;  ///< Offset: 0x48 - AHB peripheral clock enable in Sleep mode register
        volatile uint32_t APBSMENR1;  ///< Offset: 0x4C - APB peripheral clock enable in Sleep mode register 1
        volatile uint32_t APBSMENR2;  ///< Offset: 0x50 - APB peripheral clock enable in Sleep mode register 2
        volatile uint32_t CCIPR;  ///< Offset: 0x54 - Peripherals independent clock configuration register
        volatile uint32_t CCIPR2;  ///< Offset: 0x58 - Peripherals independent clock configuration register 2
        volatile uint32_t BDCR;  ///< Offset: 0x5C - RTC domain control register
        volatile uint32_t CSR;  ///< Offset: 0x60 - Control/status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 always enable for peripheral kernels
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag
        constexpr uint32_t HSIDIV = (3 << 11);  ///< HSI16 clock division factor
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t HSICAL = (8 << 0);  ///< HSI16 clock calibration
        constexpr uint32_t HSITRIM = (7 << 8);  ///< HSI16 clock trimming
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (4 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (4 << 24);  ///< Microcontroller clock output
        constexpr uint32_t MCO2PRE = (4 << 20);  ///< MCO2PRE
        constexpr uint32_t MCO2SEL = (4 << 16);  ///< MCO2SEL
        constexpr uint32_t PPRE = (3 << 12);  ///< APB prescaler
        constexpr uint32_t HPRE = (4 << 8);  ///< AHB prescaler
        constexpr uint32_t SWS = (3 << 3);  ///< System clock switch status
        constexpr uint32_t SW = (3 << 0);  ///< System clock switch
    }

    /// PLLSYSCFGR Register bits
    namespace pllsyscfgr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< PLL input clock source
        constexpr uint32_t PLLM = (3 << 4);  ///< Division factor M of the PLL input clock divider
        constexpr uint32_t PLLN = (8 << 8);  ///< PLL frequency multiplication factor N
        constexpr uint32_t PLLPEN = (1U << 16);  ///< PLLPCLK clock output enable
        constexpr uint32_t PLLP = (5 << 17);  ///< PLL VCO division factor P for PLLPCLK clock output
        constexpr uint32_t PLLQEN = (1U << 24);  ///< PLLQCLK clock output enable
        constexpr uint32_t PLLQ = (3 << 25);  ///< PLL VCO division factor Q for PLLQCLK clock output
        constexpr uint32_t PLLREN = (1U << 28);  ///< PLLRCLK clock output enable
        constexpr uint32_t PLLR = (3 << 29);  ///< PLL VCO division factor R for PLLRCLK clock output
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable
        constexpr uint32_t PLLSYSRDYIE = (1U << 5);  ///< PLL ready interrupt enable
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag
        constexpr uint32_t PLLSYSRDYF = (1U << 5);  ///< PLL ready interrupt flag
        constexpr uint32_t CSSF = (1U << 8);  ///< Clock security system interrupt flag
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE Clock security system interrupt flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear
        constexpr uint32_t PLLSYSRDYC = (1U << 5);  ///< PLL ready interrupt clear
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear
    }

    /// IOPRSTR Register bits
    namespace ioprstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< GPIOARST
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< GPIOBRST
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< GPIOCRST
        constexpr uint32_t GPIODRST = (1U << 3);  ///< GPIODRST
        constexpr uint32_t GPIOERST = (1U << 4);  ///< GPIOERST
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< GPIOFRST
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t DMA1RST = (1U << 0);  ///< DMA1 reset
        constexpr uint32_t DMA2RST = (1U << 1);  ///< DMA1 reset
        constexpr uint32_t FLASHRST = (1U << 8);  ///< FLITF reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
    }

    /// APBRSTR1 Register bits
    namespace apbrstr1_bits {
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM4 timer reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 timer reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 timer reset
        constexpr uint32_t USART5RST = (1U << 8);  ///< USART5RST
        constexpr uint32_t USART6RST = (1U << 9);  ///< USART6RST
        constexpr uint32_t USBRST = (1U << 13);  ///< USBRST
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset
        constexpr uint32_t SPI3RST = (1U << 15);  ///< SPI3 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset
        constexpr uint32_t USART4RST = (1U << 19);  ///< USART4 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset
        constexpr uint32_t I2C3RST = (1U << 23);  ///< I2C3RST reset
        constexpr uint32_t DBGRST = (1U << 27);  ///< Debug support reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
    }

    /// APBRSTR2 Register bits
    namespace apbrstr2_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG, COMP and VREFBUF reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t TIM14RST = (1U << 15);  ///< TIM14 timer reset
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 timer reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset
        constexpr uint32_t ADCRST = (1U << 20);  ///< ADC reset
    }

    /// IOPENR Register bits
    namespace iopenr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode
        constexpr uint32_t GPIODEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< I/O port E clock enable during Sleep mode
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 clock enable
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 clock enable
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
    }

    /// APBENR1 Register bits
    namespace apbenr1_bits {
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 timer clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 timer clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 timer clock enable
        constexpr uint32_t USART5EN = (1U << 8);  ///< USART5EN
        constexpr uint32_t USART6EN = (1U << 9);  ///< USART6EN
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable
        constexpr uint32_t USBEN = (1U << 13);  ///< USBEN
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t SPI3EN = (1U << 15);  ///< SPI3 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable
        constexpr uint32_t USART4EN = (1U << 19);  ///< USART4 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 clock enable
        constexpr uint32_t DBGEN = (1U << 27);  ///< Debug support clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
    }

    /// APBENR2 Register bits
    namespace apbenr2_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable
        constexpr uint32_t TIM14EN = (1U << 15);  ///< TIM14 timer clock enable
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 timer clock enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM16 timer clock enable
        constexpr uint32_t ADCEN = (1U << 20);  ///< ADC clock enable
    }

    /// IOPSMENR Register bits
    namespace iopsmenr_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< I/O port E clock enable during Sleep mode
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode
    }

    /// AHBSMENR Register bits
    namespace ahbsmenr_bits {
        constexpr uint32_t DMA1SMEN = (1U << 0);  ///< DMA1 clock enable during Sleep mode
        constexpr uint32_t DMA2SMEN = (1U << 1);  ///< DMA2 clock enable during Sleep mode
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clock enable during Sleep mode
        constexpr uint32_t SRAMSMEN = (1U << 9);  ///< SRAM clock enable during Sleep mode
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clock enable during Sleep mode
    }

    /// APBSMENR1 Register bits
    namespace apbsmenr1_bits {
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clock enable during Sleep mode
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 timer clock enable during Sleep mode
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 timer clock enable during Sleep mode
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 timer clock enable during Sleep mode
        constexpr uint32_t USART5SMEN = (1U << 8);  ///< USART5 clock enable
        constexpr uint32_t USART6SMEN = (1U << 9);  ///< USART6 clock enable
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep mode
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< WWDG clock enable during Sleep mode
        constexpr uint32_t USBSMEN = (1U << 13);  ///< USB clock enable during Sleep mode
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode
        constexpr uint32_t SPI3SMEN = (1U << 15);  ///< SPI3 clock enable during Sleep mode
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep mode
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep mode
        constexpr uint32_t USART4SMEN = (1U << 19);  ///< USART4 clock enable during Sleep mode
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep mode
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode
        constexpr uint32_t I2C3SMEN = (1U << 23);  ///< I2C3 clock enable during Sleep mode
        constexpr uint32_t DBGSMEN = (1U << 27);  ///< Debug support clock enable during Sleep mode
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
    }

    /// APBSMENR2 Register bits
    namespace apbsmenr2_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable during Sleep mode
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clock enable during Sleep mode
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep mode
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t TIM14SMEN = (1U << 15);  ///< TIM14 timer clock enable during Sleep mode
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 timer clock enable during Sleep mode
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t ADCSMEN = (1U << 20);  ///< ADC clock enable during Sleep mode
    }

    /// CCIPR Register bits
    namespace ccipr_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 clock source selection
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 clock source selection
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection
        constexpr uint32_t I2S2SEL = (2 << 14);  ///< I2S1 clock source selection
        constexpr uint32_t TIM1SEL = (1U << 22);  ///< TIM1 clock source selection
        constexpr uint32_t TIM15SEL = (1U << 24);  ///< TIM15 clock source selection
        constexpr uint32_t ADCSEL = (2 << 30);  ///< ADCs clock source selection
    }

    /// CCIPR2 Register bits
    namespace ccipr2_bits {
        constexpr uint32_t I2S1SEL = (2 << 0);  ///< 2S1SEL
        constexpr uint32_t I2S2SEL = (2 << 2);  ///< I2S2SEL
        constexpr uint32_t USBSEL = (2 << 12);  ///< USBSEL
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure Detection
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t BDRST = (1U << 16);  ///< RTC domain software reset
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flags
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag
        constexpr uint32_t PWRRSTF = (1U << 27);  ///< BOR or POR/PDR flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PUCRE;  ///< Offset: 0x40 - Power Port E pull-UP control register
        volatile uint32_t PDCRE;  ///< Offset: 0x44 - Power Port E pull-down control register
        volatile uint32_t PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t FPD_LPSLP = (1U << 5);  ///< Flash memory powered down during Low-power sleep mode
        constexpr uint32_t FPD_LPRUN = (1U << 4);  ///< Flash memory powered down during Low-power run mode
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< Flash memory powered down during Stop mode
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t USV = (1U << 10);  ///< USV
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2
        constexpr uint32_t EWUP3 = (1U << 2);  ///< Enable Wakeup pin WKUP3
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable WKUP5 wakeup pin
        constexpr uint32_t EWUP6 = (1U << 5);  ///< Enable WKUP6 wakeup pin
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wakeup line
    }

    /// CR4 Register bits
    namespace cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity
        constexpr uint32_t WP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity
        constexpr uint32_t WP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity
        constexpr uint32_t WP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity
        constexpr uint32_t WP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity
        constexpr uint32_t WP6 = (1U << 5);  ///< WKUP6 wakeup pin polarity
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT battery charging resistor selection
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag
        constexpr uint32_t WUFI = (1U << 15);  ///< Wakeup flag internal
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started
        constexpr uint32_t FLASH_RDY = (1U << 7);  ///< Flash ready flag
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Clear wakeup flag 6
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Clear wakeup flag 3
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1
    }

    /// PUCRA Register bits
    namespace pucra_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..15)
    }

    /// PDCRA Register bits
    namespace pdcra_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..15)
    }

    /// PUCRB Register bits
    namespace pucrb_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15)
    }

    /// PDCRB Register bits
    namespace pdcrb_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..15)
    }

    /// PUCRC Register bits
    namespace pucrc_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y (y=0..15)
    }

    /// PDCRC Register bits
    namespace pdcrc_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15)
    }

    /// PUCRD Register bits
    namespace pucrd_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15)
    }

    /// PDCRD Register bits
    namespace pdcrd_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15)
    }

    /// PUCRE Register bits
    namespace pucre_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port E pull-up bit y (y=0..15)
    }

    /// PDCRE Register bits
    namespace pdcre_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port E pull-down bit y (y=0..15)
    }

    /// PUCRF Register bits
    namespace pucrf_bits {
        constexpr uint32_t PU13 = (1U << 13);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15)
    }

    /// PDCRF Register bits
    namespace pdcrf_bits {
        constexpr uint32_t PD13 = (1U << 13);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15)
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40020000;
    constexpr uint32_t DMAMUX_BASE = 0x40020800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMA_ISR;  ///< Offset: 0x00 - DMA interrupt status register
        volatile uint32_t DMA_IFCR;  ///< Offset: 0x04 - DMA interrupt flag clear register
        volatile uint32_t DMA_CCR1;  ///< Offset: 0x08 - DMA channel 1 configuration register
        volatile uint32_t DMA_CNDTR1;  ///< Offset: 0x0C - DMA channel x number of data register
        volatile uint32_t DMA_CPAR1;  ///< Offset: 0x10 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR1;  ///< Offset: 0x14 - DMA channel x memory address register
        volatile uint32_t DMA_CCR2;  ///< Offset: 0x1C - DMA channel 2 configuration register
        volatile uint32_t DMA_CNDTR2;  ///< Offset: 0x20 - DMA channel x number of data register
        volatile uint32_t DMA_CPAR2;  ///< Offset: 0x24 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR2;  ///< Offset: 0x28 - DMA channel x memory address register
        volatile uint32_t DMA_CCR3;  ///< Offset: 0x30 - DMA channel 3 configuration register
        volatile uint32_t DMA_CNDTR3;  ///< Offset: 0x34 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR3;  ///< Offset: 0x38 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR3;  ///< Offset: 0x3C - DMA channel x memory address register
        volatile uint32_t DMA_CCR4;  ///< Offset: 0x44 - DMA channel 4 configuration register
        volatile uint32_t DMA_CNDTR4;  ///< Offset: 0x48 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR4;  ///< Offset: 0x4C - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR4;  ///< Offset: 0x50 - DMA channel x memory address register
        volatile uint32_t DMA_CCR5;  ///< Offset: 0x58 - DMA channel 5 configuration register
        volatile uint32_t DMA_CNDTR5;  ///< Offset: 0x5C - DMA channel x configuration register
        volatile uint32_t DMA_CPAR5;  ///< Offset: 0x60 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR5;  ///< Offset: 0x64 - DMA channel x memory address register
        volatile uint32_t DMA_CCR6;  ///< Offset: 0x6C - DMA channel 6 configuration register
        volatile uint32_t DMA_CNDTR6;  ///< Offset: 0x70 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR6;  ///< Offset: 0x74 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR6;  ///< Offset: 0x78 - DMA channel x memory address register
        volatile uint32_t DMA_CCR7;  ///< Offset: 0x80 - DMA channel 7 configuration register
        volatile uint32_t DMA_CNDTR7;  ///< Offset: 0x84 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR7;  ///< Offset: 0x88 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR7;  ///< Offset: 0x8C - DMA channel x memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// DMA_ISR Register bits
    namespace dma_isr_bits {
        constexpr uint32_t GIF1 = (1U << 0);  ///< global interrupt flag for channel 1
        constexpr uint32_t TCIF1 = (1U << 1);  ///< transfer complete (TC) flag for channel 1
        constexpr uint32_t HTIF1 = (1U << 2);  ///< half transfer (HT) flag for channel 1
        constexpr uint32_t TEIF1 = (1U << 3);  ///< transfer error (TE) flag for channel 1
        constexpr uint32_t GIF2 = (1U << 4);  ///< global interrupt flag for channel 2
        constexpr uint32_t TCIF2 = (1U << 5);  ///< transfer complete (TC) flag for channel 2
        constexpr uint32_t HTIF2 = (1U << 6);  ///< half transfer (HT) flag for channel 2
        constexpr uint32_t TEIF2 = (1U << 7);  ///< transfer error (TE) flag for channel 2
        constexpr uint32_t GIF3 = (1U << 8);  ///< global interrupt flag for channel 3
        constexpr uint32_t TCIF3 = (1U << 9);  ///< transfer complete (TC) flag for channel 3
        constexpr uint32_t HTIF3 = (1U << 10);  ///< half transfer (HT) flag for channel 3
        constexpr uint32_t TEIF3 = (1U << 11);  ///< transfer error (TE) flag for channel 3
        constexpr uint32_t GIF4 = (1U << 12);  ///< global interrupt flag for channel 4
        constexpr uint32_t TCIF4 = (1U << 13);  ///< transfer complete (TC) flag for channel 4
        constexpr uint32_t HTIF4 = (1U << 14);  ///< half transfer (HT) flag for channel 4
        constexpr uint32_t TEIF4 = (1U << 15);  ///< transfer error (TE) flag for channel 4
        constexpr uint32_t GIF5 = (1U << 16);  ///< global interrupt flag for channel 5
        constexpr uint32_t TCIF5 = (1U << 17);  ///< transfer complete (TC) flag for channel 5
        constexpr uint32_t HTIF5 = (1U << 18);  ///< half transfer (HT) flag for channel 5
        constexpr uint32_t TEIF5 = (1U << 19);  ///< transfer error (TE) flag for channel 5
        constexpr uint32_t GIF6 = (1U << 20);  ///< global interrupt flag for channel 6
        constexpr uint32_t TCIF6 = (1U << 21);  ///< transfer complete (TC) flag for channel 6
        constexpr uint32_t HTIF6 = (1U << 22);  ///< half transfer (HT) flag for channel 6
        constexpr uint32_t TEIF6 = (1U << 23);  ///< transfer error (TE) flag for channel 6
        constexpr uint32_t GIF7 = (1U << 24);  ///< global interrupt flag for channel 7
        constexpr uint32_t TCIF7 = (1U << 25);  ///< transfer complete (TC) flag for channel 7
        constexpr uint32_t HTIF7 = (1U << 26);  ///< half transfer (HT) flag for channel 7
        constexpr uint32_t TEIF7 = (1U << 27);  ///< transfer error (TE) flag for channel 7
    }

    /// DMA_IFCR Register bits
    namespace dma_ifcr_bits {
        constexpr uint32_t CGIF1 = (1U << 0);  ///< global interrupt flag clear for channel 1
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< transfer complete flag clear for channel 1
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< half transfer flag clear for channel 1
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< transfer error flag clear for channel 1
        constexpr uint32_t CGIF2 = (1U << 4);  ///< global interrupt flag clear for channel 2
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< transfer complete flag clear for channel 2
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< half transfer flag clear for channel 2
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< transfer error flag clear for channel 2
        constexpr uint32_t CGIF3 = (1U << 8);  ///< global interrupt flag clear for channel 3
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< transfer complete flag clear for channel 3
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< half transfer flag clear for channel 3
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< transfer error flag clear for channel 3
        constexpr uint32_t CGIF4 = (1U << 12);  ///< global interrupt flag clear for channel 4
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< transfer complete flag clear for channel 4
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< half transfer flag clear for channel 4
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< transfer error flag clear for channel 4
        constexpr uint32_t CGIF5 = (1U << 16);  ///< global interrupt flag clear for channel 5
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< transfer complete flag clear for channel 5
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< half transfer flag clear for channel 5
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< transfer error flag clear for channel 5
        constexpr uint32_t CGIF6 = (1U << 20);  ///< global interrupt flag clear for channel 6
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< transfer complete flag clear for channel 6
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< half transfer flag clear for channel 6
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< transfer error flag clear for channel 6
        constexpr uint32_t CGIF7 = (1U << 24);  ///< global interrupt flag clear for channel 7
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< transfer complete flag clear for channel 7
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< half transfer flag clear for channel 7
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< transfer error flag clear for channel 7
    }

    /// DMA_CCR1 Register bits
    namespace dma_ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR1 Register bits
    namespace dma_cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR1 Register bits
    namespace dma_cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR1 Register bits
    namespace dma_cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR2 Register bits
    namespace dma_ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR2 Register bits
    namespace dma_cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR2 Register bits
    namespace dma_cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR2 Register bits
    namespace dma_cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR3 Register bits
    namespace dma_ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR3 Register bits
    namespace dma_cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR3 Register bits
    namespace dma_cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR3 Register bits
    namespace dma_cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR4 Register bits
    namespace dma_ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR4 Register bits
    namespace dma_cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR4 Register bits
    namespace dma_cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR4 Register bits
    namespace dma_cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR5 Register bits
    namespace dma_ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR5 Register bits
    namespace dma_cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR5 Register bits
    namespace dma_cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR5 Register bits
    namespace dma_cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR6 Register bits
    namespace dma_ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR6 Register bits
    namespace dma_cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR6 Register bits
    namespace dma_cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR6 Register bits
    namespace dma_cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR7 Register bits
    namespace dma_ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR7 Register bits
    namespace dma_cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR7 Register bits
    namespace dma_cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR7 Register bits
    namespace dma_cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOF_BASE = 0x50001400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port Reset bit
        constexpr uint32_t BR1 = (1U << 1);  ///< Port Reset bit
        constexpr uint32_t BR2 = (1U << 2);  ///< Port Reset bit
        constexpr uint32_t BR3 = (1U << 3);  ///< Port Reset bit
        constexpr uint32_t BR4 = (1U << 4);  ///< Port Reset bit
        constexpr uint32_t BR5 = (1U << 5);  ///< Port Reset bit
        constexpr uint32_t BR6 = (1U << 6);  ///< Port Reset bit
        constexpr uint32_t BR7 = (1U << 7);  ///< Port Reset bit
        constexpr uint32_t BR8 = (1U << 8);  ///< Port Reset bit
        constexpr uint32_t BR9 = (1U << 9);  ///< Port Reset bit
        constexpr uint32_t BR10 = (1U << 10);  ///< Port Reset bit
        constexpr uint32_t BR11 = (1U << 11);  ///< Port Reset bit
        constexpr uint32_t BR12 = (1U << 12);  ///< Port Reset bit
        constexpr uint32_t BR13 = (1U << 13);  ///< Port Reset bit
        constexpr uint32_t BR14 = (1U << 14);  ///< Port Reset bit
        constexpr uint32_t BR15 = (1U << 15);  ///< Port Reset bit
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 32-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40021800;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t IMR1;  ///< Offset: 0x80 - EXTI CPU wakeup with interrupt mask register
        volatile uint32_t EMR1;  ///< Offset: 0x84 - EXTI CPU wakeup with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event line
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable line
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software rising edge event trigger on line
    }

    /// RPR1 Register bits
    namespace rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF1 = (1U << 1);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF2 = (1U << 2);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF3 = (1U << 3);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF4 = (1U << 4);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge Pending bit
        constexpr uint32_t RPIF6 = (1U << 6);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF7 = (1U << 7);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF8 = (1U << 8);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF9 = (1U << 9);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF10 = (1U << 10);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF11 = (1U << 11);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF12 = (1U << 12);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF13 = (1U << 13);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF14 = (1U << 14);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF15 = (1U << 15);  ///< Rising edge event pending for configurable line
    }

    /// FPR1 Register bits
    namespace fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF1 = (1U << 1);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF2 = (1U << 2);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF3 = (1U << 3);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF4 = (1U << 4);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF5 = (1U << 5);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF6 = (1U << 6);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF7 = (1U << 7);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF8 = (1U << 8);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF9 = (1U << 9);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF10 = (1U << 10);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF11 = (1U << 11);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF12 = (1U << 12);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF13 = (1U << 13);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF14 = (1U << 14);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF15 = (1U << 15);  ///< Falling edge event pending for configurable line
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM26 = (1U << 26);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM31 = (1U << 31);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR1 Register bits
    namespace emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM26 = (1U << 26);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM31 = (1U << 31);  ///< CPU wakeup with event mask on event input
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
        volatile uint32_t AF1;  ///< Offset: 0x60 - TIM17 option register 1
        volatile uint32_t TISEL;  ///< Offset: 0x68 - input selection register
    };

    /// Peripheral instances
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t UIFREMAP = (1U << 11);  ///< UIF status bit remapping
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC1M_2 = (1U << 16);  ///< Output Compare 1 mode
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t IC1PSC = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
        constexpr uint32_t UIFCPY = (1U << 31);  ///< UIF Copy
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t BKF = (4 << 16);  ///< Break filter
        constexpr uint32_t BKDSRM = (1U << 26);  ///< Break Disarm
        constexpr uint32_t BKBID = (1U << 28);  ///< Break Bidirectional
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (16 << 0);  ///< DMA register for burst accesses
    }

    /// AF1 Register bits
    namespace af1_bits {
        constexpr uint32_t BKINE = (1U << 0);  ///< BRK BKIN input enable
        constexpr uint32_t BKCMP1E = (1U << 1);  ///< BRK COMP1 enable
        constexpr uint32_t BKCMP2E = (1U << 2);  ///< BRK COMP2 enable
        constexpr uint32_t BKDFBK1E = (1U << 8);  ///< BRK DFSDM_BREAK1 enable
        constexpr uint32_t BKINP = (1U << 9);  ///< BRK BKIN input polarity
        constexpr uint32_t BKCMP1P = (1U << 10);  ///< BRK COMP1 input polarity
        constexpr uint32_t BKCMP2P = (1U << 11);  ///< BRK COMP2 input polarit
    }

    /// TISEL Register bits
    namespace tisel_bits {
        constexpr uint32_t TI1SEL = (4 << 0);  ///< selects input
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - Prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4_7 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0_3 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable
        constexpr uint32_t ABRMOD = (2 << 21);  ///< Auto baud rate mode
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t TAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
        constexpr uint32_t DIS_NSS = (1U << 3);  ///< When the DSI_NSS bit is set, the NSS pin input will be ignored
        constexpr uint32_t SLVEN = (1U << 0);  ///< Synchronous Slave mode enable
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration
        constexpr uint32_t TCBGTIE = (1U << 24);  ///< Tr Complete before guard time, interrupt enable
        constexpr uint32_t TXFTIE = (1U << 23);  ///< threshold interrupt enable
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< Ir low-power
        constexpr uint32_t IREN = (1U << 1);  ///< Ir mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR_4_15 = (12 << 4);  ///< BRR_4_15
        constexpr uint32_t BRR_0_3 = (4 << 0);  ///< BRR_0_3
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO Full
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO Empty
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t ABRF = (1U << 15);  ///< ABRF
        constexpr uint32_t ABRE = (1U << 14);  ///< ABRE
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag
        constexpr uint32_t EOBF = (1U << 12);  ///< EOBF
        constexpr uint32_t RTOF = (1U << 11);  ///< RTOF
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t LBDF = (1U << 8);  ///< LBDF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NF = (1U << 2);  ///< NF
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t UDRCF = (1U << 13);  ///< SPI slave underrun clear flag
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of block clear flag
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag
        constexpr uint32_t TCBGTCF = (1U << 7);  ///< Transmission complete before Guard time clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t TXFECF = (1U << 5);  ///< TXFIFO empty clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CKPOL = (1U << 3);  ///< Inactive state clock polarity
        constexpr uint32_t I2SSTD = (2 << 4);  ///< standard selection
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t SE2 = (1U << 10);  ///< I2S enable
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t I2SDIV = (8 << 0);  ///< linear prescaler
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - SYSCFG configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x18 - SYSCFG configuration register 1
        volatile uint32_t ITLINE0;  ///< Offset: 0x80 - interrupt line 0 status register
        volatile uint32_t ITLINE2;  ///< Offset: 0x88 - interrupt line 2 status register
        volatile uint32_t ITLINE3;  ///< Offset: 0x8C - interrupt line 3 status register
        volatile uint32_t ITLINE4;  ///< Offset: 0x90 - interrupt line 4 status register
        volatile uint32_t ITLINE5;  ///< Offset: 0x94 - interrupt line 5 status register
        volatile uint32_t ITLINE6;  ///< Offset: 0x98 - interrupt line 6 status register
        volatile uint32_t ITLINE7;  ///< Offset: 0x9C - interrupt line 7 status register
        volatile uint32_t ITLINE8;  ///< Offset: 0xA0 - interrupt line 8 status register
        volatile uint32_t ITLINE9;  ///< Offset: 0xA4 - interrupt line 9 status register
        volatile uint32_t ITLINE10;  ///< Offset: 0xA8 - interrupt line 10 status register
        volatile uint32_t ITLINE11;  ///< Offset: 0xAC - interrupt line 11 status register
        volatile uint32_t ITLINE12;  ///< Offset: 0xB0 - interrupt line 12 status register
        volatile uint32_t ITLINE13;  ///< Offset: 0xB4 - interrupt line 13 status register
        volatile uint32_t ITLINE14;  ///< Offset: 0xB8 - interrupt line 14 status register
        volatile uint32_t ITLINE16;  ///< Offset: 0xC0 - interrupt line 16 status register
        volatile uint32_t ITLINE17;  ///< Offset: 0xC4 - interrupt line 17 status register
        volatile uint32_t ITLINE18;  ///< Offset: 0xC8 - interrupt line 18 status register
        volatile uint32_t ITLINE19;  ///< Offset: 0xCC - interrupt line 19 status register
        volatile uint32_t ITLINE20;  ///< Offset: 0xD0 - interrupt line 20 status register
        volatile uint32_t ITLINE21;  ///< Offset: 0xD4 - interrupt line 21 status register
        volatile uint32_t ITLINE22;  ///< Offset: 0xD8 - interrupt line 22 status register
        volatile uint32_t ITLINE23;  ///< Offset: 0xDC - interrupt line 23 status register
        volatile uint32_t ITLINE24;  ///< Offset: 0xE0 - interrupt line 24 status register
        volatile uint32_t ITLINE25;  ///< Offset: 0xE4 - interrupt line 25 status register
        volatile uint32_t ITLINE26;  ///< Offset: 0xE8 - interrupt line 26 status register
        volatile uint32_t ITLINE27;  ///< Offset: 0xEC - interrupt line 27 status register
        volatile uint32_t ITLINE28;  ///< Offset: 0xF0 - interrupt line 28 status register
        volatile uint32_t ITLINE29;  ///< Offset: 0xF4 - interrupt line 29 status register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t I2C3_FMP = (1U << 24);  ///< I2C3_FMP
        constexpr uint32_t I2C_PA10_FMP = (1U << 23);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t I2C_PA9_FMP = (1U << 22);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t I2C2_FMP = (1U << 21);  ///< FM+ driving capability activation for I2C2
        constexpr uint32_t I2C1_FMP = (1U << 20);  ///< FM+ driving capability activation for I2C1
        constexpr uint32_t I2C_PB9_FMP = (4 << 19);  ///< I2C_PB9_FMP
        constexpr uint32_t I2C_PB8_FMP = (4 << 18);  ///< I2C_PB8_FMP
        constexpr uint32_t I2C_PB7_FMP = (4 << 17);  ///< I2C_PB7_FMP
        constexpr uint32_t I2C_PBx_FMP = (4 << 16);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t UCPD2_STROBE = (1U << 10);  ///< Strobe signal bit for UCPD2
        constexpr uint32_t UCPD1_STROBE = (1U << 9);  ///< Strobe signal bit for UCPD1
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
        constexpr uint32_t IR_MOD = (2 << 6);  ///< IR Modulation Envelope signal selection.
        constexpr uint32_t IR_POL = (1U << 5);  ///< IR output polarity selection
        constexpr uint32_t PA12_RMP = (1U << 4);  ///< PA11 and PA12 remapping bit.
        constexpr uint32_t PA11_RMP = (1U << 3);  ///< PA11_RMP
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t LOCKUP_LOCK = (1U << 0);  ///< Cortex-M0+ LOCKUP bit enable bit
        constexpr uint32_t SRAM_PARITY_LOCK = (1U << 1);  ///< SRAM parity lock bit
        constexpr uint32_t ECC_LOCK = (1U << 3);  ///< ECC error lock bit
        constexpr uint32_t SRAM_PEF = (1U << 8);  ///< SRAM parity error flag
    }

    /// ITLINE0 Register bits
    namespace itline0_bits {
        constexpr uint32_t WWDG = (1U << 0);  ///< Window watchdog interrupt pending flag
    }

    /// ITLINE2 Register bits
    namespace itline2_bits {
        constexpr uint32_t TAMP = (1U << 0);  ///< TAMP
        constexpr uint32_t RTC = (1U << 1);  ///< RTC
    }

    /// ITLINE3 Register bits
    namespace itline3_bits {
        constexpr uint32_t FLASH_ITF = (1U << 0);  ///< FLASH_ITF
        constexpr uint32_t FLASH_ECC = (1U << 1);  ///< FLASH_ECC
    }

    /// ITLINE4 Register bits
    namespace itline4_bits {
        constexpr uint32_t RCC = (1U << 0);  ///< RCC
    }

    /// ITLINE5 Register bits
    namespace itline5_bits {
        constexpr uint32_t EXTI0 = (1U << 0);  ///< EXTI0
        constexpr uint32_t EXTI1 = (1U << 1);  ///< EXTI1
    }

    /// ITLINE6 Register bits
    namespace itline6_bits {
        constexpr uint32_t EXTI2 = (1U << 0);  ///< EXTI2
        constexpr uint32_t EXTI3 = (1U << 1);  ///< EXTI3
    }

    /// ITLINE7 Register bits
    namespace itline7_bits {
        constexpr uint32_t EXTI4 = (1U << 0);  ///< EXTI4
        constexpr uint32_t EXTI5 = (1U << 1);  ///< EXTI5
        constexpr uint32_t EXTI6 = (1U << 2);  ///< EXTI6
        constexpr uint32_t EXTI7 = (1U << 3);  ///< EXTI7
        constexpr uint32_t EXTI8 = (1U << 4);  ///< EXTI8
        constexpr uint32_t EXTI9 = (1U << 5);  ///< EXTI9
        constexpr uint32_t EXTI10 = (1U << 6);  ///< EXTI10
        constexpr uint32_t EXTI11 = (1U << 7);  ///< EXTI11
        constexpr uint32_t EXTI12 = (1U << 8);  ///< EXTI12
        constexpr uint32_t EXTI13 = (1U << 9);  ///< EXTI13
        constexpr uint32_t EXTI14 = (1U << 10);  ///< EXTI14
        constexpr uint32_t EXTI15 = (1U << 11);  ///< EXTI15
    }

    /// ITLINE8 Register bits
    namespace itline8_bits {
        constexpr uint32_t USB = (1U << 2);  ///< USB
    }

    /// ITLINE9 Register bits
    namespace itline9_bits {
        constexpr uint32_t DMA1_CH1 = (1U << 0);  ///< DMA1_CH1
    }

    /// ITLINE10 Register bits
    namespace itline10_bits {
        constexpr uint32_t DMA1_CH2 = (1U << 0);  ///< DMA1_CH1
        constexpr uint32_t DMA1_CH3 = (1U << 1);  ///< DMA1_CH3
    }

    /// ITLINE11 Register bits
    namespace itline11_bits {
        constexpr uint32_t DMAMUX = (1U << 0);  ///< DMAMUX
        constexpr uint32_t DMA1_CH4 = (1U << 1);  ///< DMA1_CH4
        constexpr uint32_t DMA1_CH5 = (1U << 2);  ///< DMA1_CH5
        constexpr uint32_t DMA1_CH6 = (1U << 3);  ///< DMA1_CH6
        constexpr uint32_t DMA1_CH7 = (1U << 4);  ///< DMA1_CH7
        constexpr uint32_t DMA2_CH1 = (1U << 5);  ///< DMA2_CH1
        constexpr uint32_t DMA2_CH2 = (1U << 6);  ///< DMA2_CH2
        constexpr uint32_t DMA2_CH3 = (1U << 7);  ///< DMA2_CH3
        constexpr uint32_t DMA2_CH4 = (1U << 8);  ///< DMA2_CH4
        constexpr uint32_t DMA2_CH5 = (1U << 9);  ///< DMA2_CH5
    }

    /// ITLINE12 Register bits
    namespace itline12_bits {
        constexpr uint32_t ADC = (1U << 0);  ///< ADC
    }

    /// ITLINE13 Register bits
    namespace itline13_bits {
        constexpr uint32_t TIM1_CCU = (1U << 0);  ///< TIM1_CCU
        constexpr uint32_t TIM1_TRG = (1U << 1);  ///< TIM1_TRG
        constexpr uint32_t TIM1_UPD = (1U << 2);  ///< TIM1_UPD
        constexpr uint32_t TIM1_BRK = (1U << 3);  ///< TIM1_BRK
    }

    /// ITLINE14 Register bits
    namespace itline14_bits {
        constexpr uint32_t TIM1_CC = (1U << 0);  ///< TIM1_CC
    }

    /// ITLINE16 Register bits
    namespace itline16_bits {
        constexpr uint32_t TIM3 = (1U << 0);  ///< TIM3
        constexpr uint32_t TIM4 = (1U << 1);  ///< TIM4
    }

    /// ITLINE17 Register bits
    namespace itline17_bits {
        constexpr uint32_t TIM6 = (1U << 0);  ///< TIM6
    }

    /// ITLINE18 Register bits
    namespace itline18_bits {
        constexpr uint32_t TIM7 = (1U << 0);  ///< TIM7
    }

    /// ITLINE19 Register bits
    namespace itline19_bits {
        constexpr uint32_t TIM14 = (1U << 0);  ///< TIM14
    }

    /// ITLINE20 Register bits
    namespace itline20_bits {
        constexpr uint32_t TIM15 = (1U << 0);  ///< TIM15
    }

    /// ITLINE21 Register bits
    namespace itline21_bits {
        constexpr uint32_t TIM16 = (1U << 0);  ///< TIM16
    }

    /// ITLINE22 Register bits
    namespace itline22_bits {
        constexpr uint32_t TIM17 = (1U << 0);  ///< TIM17
    }

    /// ITLINE23 Register bits
    namespace itline23_bits {
        constexpr uint32_t I2C1 = (1U << 0);  ///< I2C1
    }

    /// ITLINE24 Register bits
    namespace itline24_bits {
        constexpr uint32_t I2C2 = (1U << 0);  ///< I2C2
        constexpr uint32_t I2C3 = (1U << 1);  ///< I2C3
    }

    /// ITLINE25 Register bits
    namespace itline25_bits {
        constexpr uint32_t SPI1 = (1U << 0);  ///< SPI1
    }

    /// ITLINE26 Register bits
    namespace itline26_bits {
        constexpr uint32_t SPI2 = (1U << 0);  ///< SPI2
        constexpr uint32_t SPI3 = (1U << 14);  ///< SPI3
    }

    /// ITLINE27 Register bits
    namespace itline27_bits {
        constexpr uint32_t USART1 = (1U << 0);  ///< USART1
    }

    /// ITLINE28 Register bits
    namespace itline28_bits {
        constexpr uint32_t USART2 = (1U << 0);  ///< USART2
    }

    /// ITLINE29 Register bits
    namespace itline29_bits {
        constexpr uint32_t USART3 = (1U << 0);  ///< USART3
        constexpr uint32_t USART4 = (1U << 1);  ///< USART4
        constexpr uint32_t USART5 = (1U << 3);  ///< USART5
        constexpr uint32_t USART6 = (1U << 4);  ///< USART6
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x4000B000;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t TAMP_CR1;  ///< Offset: 0x00 - TAMP control register 1
        volatile uint32_t TAMP_CR2;  ///< Offset: 0x04 - TAMP control register 2
        volatile uint32_t TAMP_FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t TAMP_IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t TAMP_SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t TAMP_MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t TAMP_SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t TAMP_BKP0R;  ///< Offset: 0x100 - TAMP backup 0 register
        volatile uint32_t TAMP_BKP1R;  ///< Offset: 0x104 - TAMP backup 1 register
        volatile uint32_t TAMP_BKP2R;  ///< Offset: 0x108 - TAMP backup 2 register
        volatile uint32_t TAMP_BKP3R;  ///< Offset: 0x10C - TAMP backup 3 register
        volatile uint32_t TAMP_BKP4R;  ///< Offset: 0x110 - TAMP backup 4 register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// TAMP_CR1 Register bits
    namespace tamp_cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper detection on TAMP_IN1 enable
        constexpr uint32_t TAMP2E = (1U << 1);  ///< Tamper detection on TAMP_IN2 enable
        constexpr uint32_t TAMP3E = (1U << 2);  ///< Tamper detection on TAMP_IN3 enable
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< Internal tamper 3 enable: LSE monitoring
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< Internal tamper 4 enable: HSE monitoring
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< Internal tamper 5 enable: RTC calendar overflow
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< Internal tamper 6 enable: ST manufacturer readout
    }

    /// TAMP_CR2 Register bits
    namespace tamp_cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< Tamper 1 no erase
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< Tamper 2 no erase
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< Tamper 3 no erase
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< Tamper 1 mask The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< Tamper 2 mask The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< Tamper 3 mask The tamper 3 interrupt must not be enabled when TAMP3MSK is set.
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< Active level for tamper 1 input (active mode disabled) If TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< Active level for tamper 2 input (active mode disabled) If TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< Active level for tamper 3 input (active mode disabled) If TAMPFLT = 00 Tamper 3 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 3 input falling edge and low level triggers a tamper detection event.
    }

    /// TAMP_FLTCR Register bits
    namespace tamp_fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< Tamper sampling frequency Determines the frequency at which each of the TAMP_INx inputs are sampled.
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMP_INx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMP_INx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMP_INx pull-up disable This bit determines if each of the TAMPx pins are precharged before each sample.
    }

    /// TAMP_IER Register bits
    namespace tamp_ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< Tamper 2 interrupt enable
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< Tamper 3 interrupt enable
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< Internal tamper 3 interrupt enable: LSE monitoring
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< Internal tamper 4 interrupt enable: HSE monitoring
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< Internal tamper 5 interrupt enable: RTC calendar overflow
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< Internal tamper 6 interrupt enable: ST manufacturer readout
    }

    /// TAMP_SR Register bits
    namespace tamp_sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP3 input.
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< LSE monitoring tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< HSE monitoring tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 4.
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< RTC calendar overflow tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ST manufacturer readout tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
    }

    /// TAMP_MISR Register bits
    namespace tamp_misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1 interrupt masked flag This flag is set by hardware when the tamper 1 interrupt is raised.
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2 interrupt masked flag This flag is set by hardware when the tamper 2 interrupt is raised.
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3 interrupt masked flag This flag is set by hardware when the tamper 3 interrupt is raised.
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< LSE monitoring tamper interrupt masked flag This flag is set by hardware when the internal tamper 3 interrupt is raised.
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< HSE monitoring tamper interrupt masked flag This flag is set by hardware when the internal tamper 4 interrupt is raised.
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< RTC calendar overflow tamper interrupt masked flag This flag is set by hardware when the internal tamper 5 interrupt is raised.
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ST manufacturer readout tamper interrupt masked flag This flag is set by hardware when the internal tamper 6 interrupt is raised.
    }

    /// TAMP_SCR Register bits
    namespace tamp_scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< Clear TAMP1 detection flag Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< Clear TAMP2 detection flag Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< Clear TAMP3 detection flag Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< Clear ITAMP3 detection flag Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< Clear ITAMP4 detection flag Writing 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< Clear ITAMP5 detection flag Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< Clear ITAMP6 detection flag Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
    }

    /// TAMP_BKP0R Register bits
    namespace tamp_bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP1R Register bits
    namespace tamp_bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP2R Register bits
    namespace tamp_bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP3R Register bits
    namespace tamp_bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP4R Register bits
    namespace tamp_bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1_0 = (1U << 0);  ///< Interface address
        constexpr uint32_t OA1_7_1 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA1_8_9 = (2 << 8);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_TR;  ///< Offset: 0x00 - RTC time register
        volatile uint32_t RTC_DR;  ///< Offset: 0x04 - RTC date register
        volatile uint32_t RTC_SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t RTC_ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t RTC_PRER;  ///< Offset: 0x10 - RTC prescaler register
        volatile uint32_t RTC_WUTR;  ///< Offset: 0x14 - RTC wakeup timer register
        volatile uint32_t RTC_CR;  ///< Offset: 0x18 - control register
        volatile uint32_t RTC_WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t RTC_CALR;  ///< Offset: 0x28 - RTC calibration register
        volatile uint32_t RTC_SHIFTR;  ///< Offset: 0x2C - RTC shift control register
        volatile uint32_t RTC_TSTR;  ///< Offset: 0x30 - RTC timestamp time register
        volatile uint32_t RTC_TSDR;  ///< Offset: 0x34 - RTC timestamp date register
        volatile uint32_t RTC_TSSSR;  ///< Offset: 0x38 - RTC timestamp sub second register
        volatile uint32_t RTC_ALRMAR;  ///< Offset: 0x40 - RTC alarm A register
        volatile uint32_t RTC_ALRMASSR;  ///< Offset: 0x44 - RTC alarm A sub second register
        volatile uint32_t RTC_ALRMBR;  ///< Offset: 0x48 - RTC alarm B register
        volatile uint32_t RTC_ALRMBSSR;  ///< Offset: 0x4C - RTC alarm B sub second register
        volatile uint32_t RTC_SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t RTC_MISR;  ///< Offset: 0x54 - RTC masked interrupt status register
        volatile uint32_t RTC_SCR;  ///< Offset: 0x5C - RTC status clear register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// RTC_TR Register bits
    namespace rtc_tr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_DR Register bits
    namespace rtc_dr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units ...
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
    }

    /// RTC_SSR Register bits
    namespace rtc_ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    }

    /// RTC_ICSR Register bits
    namespace rtc_icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag This bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag This bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to .
    }

    /// RTC_PRER Register bits
    namespace rtc_prer_bits {
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    }

    /// RTC_WUTR Register bits
    namespace rtc_wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register. When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.
    }

    /// RTC_CR Register bits
    namespace rtc_cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< ck_wut wakeup clock selection 10x: ck_spre (usually 1Hz) clock is selected 11x: ck_spre (usually 1Hz) clock is selected and 216is added to the WUT counter value
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Timestamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers Note: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable Note: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again.
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Timestamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
        constexpr uint32_t BKP = (1U << 18);  ///< Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection When COE = 1, this bit selects which signal is output on CALIB. These frequencies are valid for RTCCLK at 32.768kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity This bit is used to configure the polarity of TAMPALRM output.
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection These bits are used to select the flag to be routed to TAMPALRM output.
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable This bit enables the CALIB output
        constexpr uint32_t ITSE = (1U << 24);  ///< timestamp on internal event enable
        constexpr uint32_t TAMPTS = (1U << 25);  ///< Activate timestamp on tamper detection event TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid servicing 2 interrupts.
        constexpr uint32_t TAMPOE = (1U << 26);  ///< Tamper detection output enable on TAMPALRM
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM pull-up enable
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM output type
        constexpr uint32_t OUT2EN = (1U << 31);  ///< RTC_OUT2 output enable Setting this bit allows to remap the RTC outputs on RTC_OUT2 as follows: OUT2EN = 0: RTC output 2 disable If OSEL â  00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1 OUT2EN = 1: RTC output 2 enable If (OSEL â  00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2 If (OSELâ  00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.
    }

    /// RTC_WPR Register bits
    namespace rtc_wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to for a description of how to unlock RTC register write protection.
    }

    /// RTC_CALR Register bits
    namespace rtc_calr_bits {
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768Hz). This decreases the frequency of the calendar with a resolution of 0.9537ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1. Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 Ã CALP) - CALM. Refer to .
    }

    /// RTC_SHIFTR Register bits
    namespace rtc_shiftr_bits {
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    }

    /// RTC_TSTR Register bits
    namespace rtc_tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_TSDR Register bits
    namespace rtc_tsdr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
    }

    /// RTC_TSSSR Register bits
    namespace rtc_tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    }

    /// RTC_ALRMAR Register bits
    namespace rtc_alrmar_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
    }

    /// RTC_ALRMASSR Register bits
    namespace rtc_alrmassr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit 2:	SS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared. 3:	SS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared. ... 12:	SS[14:12] are don't care in alarm A comparison. SS[11:0] are compared. 13:	SS[14:13] are don't care in alarm A comparison. SS[12:0] are compared. 14:	SS[14] is don't care in alarm A comparison. SS[13:0] are compared. 15:	All 15 SS bits are compared and must match to activate alarm. The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. Note: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_ALRMBR Register bits
    namespace rtc_alrmbr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
    }

    /// RTC_ALRMBSSR Register bits
    namespace rtc_alrmbssr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_SR Register bits
    namespace rtc_sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
        constexpr uint32_t ALRBF = (1U << 1);  ///< Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
        constexpr uint32_t WUTF = (1U << 2);  ///< Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSF = (1U << 3);  ///< Timestamp flag This flag is set by hardware when a timestamp event occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVF = (1U << 4);  ///< Timestamp overflow flag This flag is set by hardware when a timestamp event occurs while TSF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSF = (1U << 5);  ///< Internal timestamp flag This flag is set by hardware when a timestamp on the internal event occurs.
    }

    /// RTC_MISR Register bits
    namespace rtc_misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< Alarm A masked flag This flag is set by hardware when the alarm A interrupt occurs.
        constexpr uint32_t ALRBMF = (1U << 1);  ///< Alarm B masked flag This flag is set by hardware when the alarm B interrupt occurs.
        constexpr uint32_t WUTMF = (1U << 2);  ///< Wakeup timer masked flag This flag is set by hardware when the wakeup timer interrupt occurs. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSMF = (1U << 3);  ///< Timestamp masked flag This flag is set by hardware when a timestamp interrupt occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVMF = (1U << 4);  ///< Timestamp overflow masked flag This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSMF = (1U << 5);  ///< Internal timestamp masked flag This flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
    }

    /// RTC_SCR Register bits
    namespace rtc_scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< Clear alarm A flag Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.
        constexpr uint32_t CALRBF = (1U << 1);  ///< Clear alarm B flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
        constexpr uint32_t CWUTF = (1U << 2);  ///< Clear wakeup timer flag Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
        constexpr uint32_t CTSF = (1U << 3);  ///< Clear timestamp flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
        constexpr uint32_t CTSOVF = (1U << 4);  ///< Clear timestamp overflow flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t CITSF = (1U << 5);  ///< Clear internal timestamp flag Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x40010030;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
        constexpr uint32_t VRS = (3 << 4);  ///< Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x40015800;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - DBGMCU_IDCODE
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU configuration register
        volatile uint32_t APB_FZ1;  ///< Offset: 0x08 - Debug MCU APB1 freeze register1
        volatile uint32_t APB_FZ2;  ///< Offset: 0x0C - Debug MCU APB1 freeze register 2
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision identifie
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby mode
    }

    /// APB_FZ1 Register bits
    namespace apb_fz1_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 counter stopped when core is halted
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 counter stopped when core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< RTC counter stopped when core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Window watchdog counter stopped when core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Independent watchdog counter stopped when core is halted
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout counter stopped when core is halted
    }

    /// APB_FZ2 Register bits
    namespace apb_fz2_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM14_STOP = (1U << 15);  ///< DBG_TIM14_STOP
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< DBG_TIM16_STOP
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

}


} // namespace alloy::generated::stm32g030

#endif // ALLOY_GENERATED_STM32G030_PERIPHERALS_HPP