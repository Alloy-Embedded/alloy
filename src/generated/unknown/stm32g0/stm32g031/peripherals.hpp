/// Auto-generated code for STM32G031
/// Generated by Alloy Code Generator
/// Source: st_stm32g031.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:31
#ifndef ALLOY_GENERATED_STM32G031_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32G031_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32g031 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 8;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 2;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_lpuart = true;
}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t KEYR;  ///< Offset: 0x08 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x0C - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t CR;  ///< Offset: 0x14 - Flash control register
        volatile uint32_t ECCR;  ///< Offset: 0x18 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x20 - Flash option register
        volatile uint32_t PCROP1ASR;  ///< Offset: 0x24 - Flash PCROP zone A Start address register
        volatile uint32_t PCROP1AER;  ///< Offset: 0x28 - Flash PCROP zone A End address register
        volatile uint32_t WRP1AR;  ///< Offset: 0x2C - Flash WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x30 - Flash WRP area B address register
        volatile uint32_t PCROP1BSR;  ///< Offset: 0x34 - Flash PCROP zone B Start address register
        volatile uint32_t PCROP1BER;  ///< Offset: 0x38 - Flash PCROP zone B End address register
        volatile uint32_t SECR;  ///< Offset: 0x80 - Flash Security register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t EMPTY = (1U << 16);  ///< Flash User area empty
        constexpr uint32_t DBG_SWEN = (1U << 18);  ///< Debug access software enable
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< KEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t MISERR = (1U << 8);  ///< Fast programming data miss error
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error
        constexpr uint32_t RDERR = (1U << 14);  ///< PCROP read error
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option and Engineering bits loading validity error
        constexpr uint32_t BSY = (1U << 16);  ///< Busy
        constexpr uint32_t CFGBSY = (1U << 18);  ///< Programming or erase configuration busy.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t MER = (1U << 2);  ///< Mass erase
        constexpr uint32_t PNB = (6 << 3);  ///< Page number
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t RDERRIE = (1U << 26);  ///< PCROP read error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t SEC_PROT = (1U << 28);  ///< Securable memory area protection enable
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (14 << 0);  ///< ECC fail address
        constexpr uint32_t SYSF_ECC = (1U << 20);  ///< ECC fail for Corrected ECC Error or Double ECC Error in info block
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t BOREN = (1U << 8);  ///< BOR reset Level
        constexpr uint32_t BORF_LEV = (2 << 9);  ///< These bits contain the VDD supply level threshold that activates the reset
        constexpr uint32_t BORR_LEV = (2 << 11);  ///< These bits contain the VDD supply level threshold that releases the reset.
        constexpr uint32_t nRST_STOP = (1U << 13);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 14);  ///< nRST_STDBY
        constexpr uint32_t nRSTS_HDW = (1U << 15);  ///< nRSTS_HDW
        constexpr uint32_t IDWG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t RAM_PARITY_CHECK = (1U << 22);  ///< SRAM parity check control
        constexpr uint32_t nBOOT_SEL = (1U << 24);  ///< nBOOT_SEL
        constexpr uint32_t nBOOT1 = (1U << 25);  ///< Boot configuration
        constexpr uint32_t nBOOT0 = (1U << 26);  ///< nBOOT0 option bit
        constexpr uint32_t NRST_MODE = (2 << 27);  ///< NRST_MODE
        constexpr uint32_t IRHEN = (1U << 29);  ///< Internal reset holder enable bit
    }

    /// PCROP1ASR Register bits
    namespace pcrop1asr_bits {
        constexpr uint32_t PCROP1A_STRT = (8 << 0);  ///< PCROP1A area start offset
    }

    /// PCROP1AER Register bits
    namespace pcrop1aer_bits {
        constexpr uint32_t PCROP1A_END = (8 << 0);  ///< PCROP1A area end offset
        constexpr uint32_t PCROP_RDP = (1U << 31);  ///< PCROP area preserved when RDP level decreased
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (6 << 0);  ///< WRP area A start offset
        constexpr uint32_t WRP1A_END = (6 << 16);  ///< WRP area A end offset
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (6 << 0);  ///< WRP area B start offset
        constexpr uint32_t WRP1B_END = (6 << 16);  ///< WRP area B end offset
    }

    /// PCROP1BSR Register bits
    namespace pcrop1bsr_bits {
        constexpr uint32_t PCROP1B_STRT = (8 << 0);  ///< PCROP1B area start offset
    }

    /// PCROP1BER Register bits
    namespace pcrop1ber_bits {
        constexpr uint32_t PCROP1B_END = (8 << 0);  ///< PCROP1B area end offset
    }

    /// SECR Register bits
    namespace secr_bits {
        constexpr uint32_t SEC_SIZE = (7 << 0);  ///< Securable memory area size
        constexpr uint32_t BOOT_LOCK = (1U << 16);  ///< used to force boot from user area
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t PLLSYSCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t AHBRSTR;  ///< Offset: 0x28 - AHB peripheral reset register
        volatile uint32_t IOPRSTR;  ///< Offset: 0x24 - GPIO reset register
        volatile uint32_t APBRSTR1;  ///< Offset: 0x2C - APB peripheral reset register 1
        volatile uint32_t APBRSTR2;  ///< Offset: 0x30 - APB peripheral reset register 2
        volatile uint32_t IOPENR;  ///< Offset: 0x34 - GPIO clock enable register
        volatile uint32_t AHBENR;  ///< Offset: 0x38 - AHB peripheral clock enable register
        volatile uint32_t APBENR1;  ///< Offset: 0x3C - APB peripheral clock enable register 1
        volatile uint32_t APBENR2;  ///< Offset: 0x40 - APB peripheral clock enable register 2
        volatile uint32_t IOPSMENR;  ///< Offset: 0x44 - GPIO in Sleep mode clock enable register
        volatile uint32_t AHBSMENR;  ///< Offset: 0x48 - AHB peripheral clock enable in Sleep mode register
        volatile uint32_t APBSMENR1;  ///< Offset: 0x4C - APB peripheral clock enable in Sleep mode register 1
        volatile uint32_t APBSMENR2;  ///< Offset: 0x50 - APB peripheral clock enable in Sleep mode register 2
        volatile uint32_t CCIPR;  ///< Offset: 0x54 - Peripherals independent clock configuration register
        volatile uint32_t BDCR;  ///< Offset: 0x5C - RTC domain control register
        volatile uint32_t CSR;  ///< Offset: 0x60 - Control/status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 always enable for peripheral kernels
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag
        constexpr uint32_t HSIDIV = (3 << 11);  ///< HSI16 clock division factor
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t HSICAL = (8 << 0);  ///< HSI16 clock calibration
        constexpr uint32_t HSITRIM = (7 << 8);  ///< HSI16 clock trimming
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (3 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (3 << 24);  ///< Microcontroller clock output
        constexpr uint32_t PPRE = (3 << 12);  ///< APB prescaler
        constexpr uint32_t HPRE = (4 << 8);  ///< AHB prescaler
        constexpr uint32_t SWS = (3 << 3);  ///< System clock switch status
        constexpr uint32_t SW = (3 << 0);  ///< System clock switch
    }

    /// PLLSYSCFGR Register bits
    namespace pllsyscfgr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< PLL input clock source
        constexpr uint32_t PLLM = (3 << 4);  ///< Division factor M of the PLL input clock divider
        constexpr uint32_t PLLN = (7 << 8);  ///< PLL frequency multiplication factor N
        constexpr uint32_t PLLPEN = (1U << 16);  ///< PLLPCLK clock output enable
        constexpr uint32_t PLLP = (5 << 17);  ///< PLL VCO division factor P for PLLPCLK clock output
        constexpr uint32_t PLLQEN = (1U << 24);  ///< PLLQCLK clock output enable
        constexpr uint32_t PLLQ = (3 << 25);  ///< PLL VCO division factor Q for PLLQCLK clock output
        constexpr uint32_t PLLREN = (1U << 28);  ///< PLLRCLK clock output enable
        constexpr uint32_t PLLR = (3 << 29);  ///< PLL VCO division factor R for PLLRCLK clock output
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable
        constexpr uint32_t PLLSYSRDYIE = (1U << 5);  ///< PLL ready interrupt enable
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag
        constexpr uint32_t PLLSYSRDYF = (1U << 5);  ///< PLL ready interrupt flag
        constexpr uint32_t CSSF = (1U << 8);  ///< Clock security system interrupt flag
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE Clock security system interrupt flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear
        constexpr uint32_t PLLSYSRDYC = (1U << 5);  ///< PLL ready interrupt clear
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t DMARST = (1U << 0);  ///< DMA1 reset
        constexpr uint32_t FLASHRST = (1U << 8);  ///< FLITF reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
    }

    /// IOPRSTR Register bits
    namespace ioprstr_bits {
        constexpr uint32_t IOPARST = (1U << 0);  ///< I/O port A reset
        constexpr uint32_t IOPBRST = (1U << 1);  ///< I/O port B reset
        constexpr uint32_t IOPCRST = (1U << 2);  ///< I/O port C reset
        constexpr uint32_t IOPDRST = (1U << 3);  ///< I/O port D reset
        constexpr uint32_t IOPFRST = (1U << 5);  ///< I/O port F reset
    }

    /// APBRSTR1 Register bits
    namespace apbrstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 timer reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset
        constexpr uint32_t LPUART1RST = (1U << 20);  ///< LPUART1 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset
        constexpr uint32_t DBGRST = (1U << 27);  ///< Debug support reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t LPTIM2RST = (1U << 30);  ///< Low Power Timer 2 reset
        constexpr uint32_t LPTIM1RST = (1U << 31);  ///< Low Power Timer 1 reset
    }

    /// APBRSTR2 Register bits
    namespace apbrstr2_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG, COMP and VREFBUF reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t TIM14RST = (1U << 15);  ///< TIM14 timer reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset
        constexpr uint32_t ADCRST = (1U << 20);  ///< ADC reset
    }

    /// IOPENR Register bits
    namespace iopenr_bits {
        constexpr uint32_t IOPAEN = (1U << 0);  ///< I/O port A clock enable
        constexpr uint32_t IOPBEN = (1U << 1);  ///< I/O port B clock enable
        constexpr uint32_t IOPCEN = (1U << 2);  ///< I/O port C clock enable
        constexpr uint32_t IOPDEN = (1U << 3);  ///< I/O port D clock enable
        constexpr uint32_t IOPFEN = (1U << 5);  ///< I/O port F clock enable
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA clock enable
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
    }

    /// APBENR1 Register bits
    namespace apbenr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 timer clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable
        constexpr uint32_t LPUART1EN = (1U << 20);  ///< LPUART1 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t DBGEN = (1U << 27);  ///< Debug support clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t LPTIM2EN = (1U << 30);  ///< LPTIM2 clock enable
        constexpr uint32_t LPTIM1EN = (1U << 31);  ///< LPTIM1 clock enable
    }

    /// APBENR2 Register bits
    namespace apbenr2_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable
        constexpr uint32_t TIM14EN = (1U << 15);  ///< TIM14 timer clock enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM16 timer clock enable
        constexpr uint32_t ADCEN = (1U << 20);  ///< ADC clock enable
    }

    /// IOPSMENR Register bits
    namespace iopsmenr_bits {
        constexpr uint32_t IOPASMEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode
        constexpr uint32_t IOPBSMEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode
        constexpr uint32_t IOPCSMEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode
        constexpr uint32_t IOPDSMEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode
        constexpr uint32_t IOPFSMEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode
    }

    /// AHBSMENR Register bits
    namespace ahbsmenr_bits {
        constexpr uint32_t DMASMEN = (1U << 0);  ///< DMA clock enable during Sleep mode
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clock enable during Sleep mode
        constexpr uint32_t SRAMSMEN = (1U << 9);  ///< SRAM clock enable during Sleep mode
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clock enable during Sleep mode
    }

    /// APBSMENR1 Register bits
    namespace apbsmenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 timer clock enable during Sleep mode
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clock enable during Sleep mode
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep mode
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< WWDG clock enable during Sleep mode
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep mode
        constexpr uint32_t LPUART1SMEN = (1U << 20);  ///< LPUART1 clock enable during Sleep mode
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep mode
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode
        constexpr uint32_t DBGSMEN = (1U << 27);  ///< Debug support clock enable during Sleep mode
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
        constexpr uint32_t LPTIM2SMEN = (1U << 30);  ///< Low Power Timer 2 clock enable during Sleep mode
        constexpr uint32_t LPTIM1SMEN = (1U << 31);  ///< Low Power Timer 1 clock enable during Sleep mode
    }

    /// APBSMENR2 Register bits
    namespace apbsmenr2_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable during Sleep mode
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clock enable during Sleep mode
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep mode
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t TIM14SMEN = (1U << 15);  ///< TIM14 timer clock enable during Sleep mode
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t ADCSMEN = (1U << 20);  ///< ADC clock enable during Sleep mode
    }

    /// CCIPR Register bits
    namespace ccipr_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection
        constexpr uint32_t LPUART1SEL = (2 << 10);  ///< LPUART1 clock source selection
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection
        constexpr uint32_t I2S2SEL = (2 << 14);  ///< I2S1 clock source selection
        constexpr uint32_t LPTIM1SEL = (2 << 18);  ///< LPTIM1 clock source selection
        constexpr uint32_t LPTIM2SEL = (2 << 20);  ///< LPTIM2 clock source selection
        constexpr uint32_t TIM1SEL = (1U << 22);  ///< TIM1 clock source selection
        constexpr uint32_t RNGSEL = (2 << 26);  ///< RNG clock source selection
        constexpr uint32_t RNGDIV = (2 << 28);  ///< Division factor of RNG clock divider
        constexpr uint32_t ADCSEL = (2 << 30);  ///< ADCs clock source selection
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure Detection
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t BDRST = (1U << 16);  ///< RTC domain software reset
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flags
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag
        constexpr uint32_t PWRRSTF = (1U << 27);  ///< BOR or POR/PDR flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t FPD_LPSLP = (1U << 5);  ///< Flash memory powered down during Low-power sleep mode
        constexpr uint32_t FPD_LPRUN = (1U << 4);  ///< Flash memory powered down during Low-power run mode
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< Flash memory powered down during Stop mode
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PVDE = (1U << 0);  ///< Power voltage detector enable
        constexpr uint32_t PVDFT = (3 << 1);  ///< Power voltage detector falling threshold selection
        constexpr uint32_t PVDRT = (3 << 4);  ///< Power voltage detector rising threshold selection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable WKUP5 wakeup pin
        constexpr uint32_t EWUP6 = (1U << 5);  ///< Enable WKUP6 wakeup pin
        constexpr uint32_t RRS = (1U << 8);  ///< SRAM retention in Standby mode
        constexpr uint32_t ULPEN = (1U << 9);  ///< Enable the periodical sampling mode for PDR detection
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wakeup line
    }

    /// CR4 Register bits
    namespace cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity
        constexpr uint32_t WP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity
        constexpr uint32_t WP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity
        constexpr uint32_t WP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity
        constexpr uint32_t WP6 = (1U << 5);  ///< WKUP6 wakeup pin polarity
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT battery charging resistor selection
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag
        constexpr uint32_t WUFI = (1U << 15);  ///< Wakeup flag internal
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PVDO = (1U << 11);  ///< Power voltage detector output
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started
        constexpr uint32_t FLASH_RDY = (1U << 7);  ///< Flash ready flag
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Clear wakeup flag 6
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1
    }

    /// PUCRA Register bits
    namespace pucra_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..15)
    }

    /// PDCRA Register bits
    namespace pdcra_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..15)
    }

    /// PUCRB Register bits
    namespace pucrb_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15)
    }

    /// PDCRB Register bits
    namespace pdcrb_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..15)
    }

    /// PUCRC Register bits
    namespace pucrc_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15)
    }

    /// PDCRC Register bits
    namespace pdcrc_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15)
    }

    /// PUCRD Register bits
    namespace pucrd_bits {
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15)
    }

    /// PDCRD Register bits
    namespace pdcrd_bits {
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15)
    }

    /// PUCRF Register bits
    namespace pucrf_bits {
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15)
    }

    /// PDCRF Register bits
    namespace pdcrf_bits {
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15)
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40020000;
    constexpr uint32_t DMAMUX_BASE = 0x40020800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - low interrupt status register
        volatile uint32_t IFCR;  ///< Offset: 0x04 - high interrupt status register
        volatile uint32_t CCR1;  ///< Offset: 0x08 - DMA channel x configuration register
        volatile uint32_t CCR2;  ///< Offset: 0x1C - DMA channel x configuration register
        volatile uint32_t CCR3;  ///< Offset: 0x30 - DMA channel x configuration register
        volatile uint32_t CCR4;  ///< Offset: 0x44 - DMA channel x configuration register
        volatile uint32_t CCR5;  ///< Offset: 0x58 - DMA channel x configuration register
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - DMA channel x number of data register
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - DMA channel x number of data register
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - DMA channel x configuration register
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - DMA channel x configuration register
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - DMA channel x configuration register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - DMA channel x peripheral address register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - DMA channel x peripheral address register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - DMA channel x peripheral address register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - DMA channel x peripheral address register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - DMA channel x peripheral address register
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - DMA channel x memory address register
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - DMA channel x memory address register
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - DMA channel x memory address register
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - DMA channel x memory address register
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - DMA channel x memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t GIF0 = (1U << 0);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF1 = (1U << 1);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF2 = (1U << 2);  ///< Channel half transfer flag
        constexpr uint32_t TEIF3 = (1U << 3);  ///< Channel transfer error flag
        constexpr uint32_t GIF4 = (1U << 4);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF5 = (1U << 5);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF6 = (1U << 6);  ///< Channel half transfer flag
        constexpr uint32_t TEIF7 = (1U << 7);  ///< Channel transfer error flag
        constexpr uint32_t GIF8 = (1U << 8);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF9 = (1U << 9);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF10 = (1U << 10);  ///< Channel half transfer flag
        constexpr uint32_t TEIF11 = (1U << 11);  ///< Channel transfer error flag
        constexpr uint32_t GIF12 = (1U << 12);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF13 = (1U << 13);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF14 = (1U << 14);  ///< Channel half transfer flag
        constexpr uint32_t TEIF15 = (1U << 15);  ///< Channel transfer error flag
        constexpr uint32_t GIF16 = (1U << 16);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF17 = (1U << 17);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF18 = (1U << 18);  ///< Channel half transfer flag
        constexpr uint32_t TEIF19 = (1U << 19);  ///< Channel transfer error flag
        constexpr uint32_t GIF20 = (1U << 20);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF21 = (1U << 21);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF22 = (1U << 22);  ///< Channel half transfer flag
        constexpr uint32_t TEIF23 = (1U << 23);  ///< Channel transfer error flag
        constexpr uint32_t GIF24 = (1U << 24);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF25 = (1U << 25);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF26 = (1U << 26);  ///< Channel half transfer flag
        constexpr uint32_t TEIF27 = (1U << 27);  ///< Channel transfer error flag
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CGIF0 = (1U << 0);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF2 = (1U << 2);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF3 = (1U << 3);  ///< Channel transfer error flag
        constexpr uint32_t CGIF4 = (1U << 4);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF5 = (1U << 5);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF6 = (1U << 6);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF7 = (1U << 7);  ///< Channel transfer error flag
        constexpr uint32_t CGIF8 = (1U << 8);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF9 = (1U << 9);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF10 = (1U << 10);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF11 = (1U << 11);  ///< Channel transfer error flag
        constexpr uint32_t CGIF12 = (1U << 12);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF13 = (1U << 13);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF14 = (1U << 14);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF15 = (1U << 15);  ///< Channel transfer error flag
        constexpr uint32_t CGIF16 = (1U << 16);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF17 = (1U << 17);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF18 = (1U << 18);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF19 = (1U << 19);  ///< Channel transfer error flag
        constexpr uint32_t CGIF20 = (1U << 20);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF21 = (1U << 21);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF22 = (1U << 22);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF23 = (1U << 23);  ///< Channel transfer error flag
        constexpr uint32_t CGIF24 = (1U << 24);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF25 = (1U << 25);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF26 = (1U << 26);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF27 = (1U << 27);  ///< Channel transfer error flag
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOF_BASE = 0x50001400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port Reset bit
        constexpr uint32_t BR1 = (1U << 1);  ///< Port Reset bit
        constexpr uint32_t BR2 = (1U << 2);  ///< Port Reset bit
        constexpr uint32_t BR3 = (1U << 3);  ///< Port Reset bit
        constexpr uint32_t BR4 = (1U << 4);  ///< Port Reset bit
        constexpr uint32_t BR5 = (1U << 5);  ///< Port Reset bit
        constexpr uint32_t BR6 = (1U << 6);  ///< Port Reset bit
        constexpr uint32_t BR7 = (1U << 7);  ///< Port Reset bit
        constexpr uint32_t BR8 = (1U << 8);  ///< Port Reset bit
        constexpr uint32_t BR9 = (1U << 9);  ///< Port Reset bit
        constexpr uint32_t BR10 = (1U << 10);  ///< Port Reset bit
        constexpr uint32_t BR11 = (1U << 11);  ///< Port Reset bit
        constexpr uint32_t BR12 = (1U << 12);  ///< Port Reset bit
        constexpr uint32_t BR13 = (1U << 13);  ///< Port Reset bit
        constexpr uint32_t BR14 = (1U << 14);  ///< Port Reset bit
        constexpr uint32_t BR15 = (1U << 15);  ///< Port Reset bit
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 32-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40021800;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t IMR1;  ///< Offset: 0x80 - EXTI CPU wakeup with interrupt mask register
        volatile uint32_t EMR1;  ///< Offset: 0x84 - EXTI CPU wakeup with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWIER0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// RPR1 Register bits
    namespace rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF1 = (1U << 1);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF2 = (1U << 2);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF3 = (1U << 3);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF4 = (1U << 4);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge Pending bit
        constexpr uint32_t RPIF6 = (1U << 6);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF7 = (1U << 7);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF8 = (1U << 8);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF9 = (1U << 9);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF10 = (1U << 10);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF11 = (1U << 11);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF12 = (1U << 12);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF13 = (1U << 13);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF14 = (1U << 14);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF15 = (1U << 15);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF16 = (1U << 16);  ///< configurable event inputs x rising edge Pending bit.
    }

    /// FPR1 Register bits
    namespace fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< configurable event inputs x falling edge pending bit.
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM26 = (1U << 26);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM28 = (1U << 28);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM29 = (1U << 29);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM30 = (1U << 30);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM31 = (1U << 31);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR1 Register bits
    namespace emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM26 = (1U << 26);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM28 = (1U << 28);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM29 = (1U << 29);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM30 = (1U << 30);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM31 = (1U << 31);  ///< CPU wakeup with event mask on event input
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t LPTIM1_BASE = 0x40007C00;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
        volatile uint32_t AF1;  ///< Offset: 0x60 - TIM17 option register 1
        volatile uint32_t TISEL;  ///< Offset: 0x68 - input selection register
    };

    /// Peripheral instances
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t UIFREMAP = (1U << 11);  ///< UIF status bit remapping
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC1M_2 = (1U << 16);  ///< Output Compare 1 mode
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t IC1PSC = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
        constexpr uint32_t UIFCPY = (1U << 31);  ///< UIF Copy
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t BKF = (4 << 16);  ///< Break filter
        constexpr uint32_t BKDSRM = (1U << 26);  ///< Break Disarm
        constexpr uint32_t BKBID = (1U << 28);  ///< Break Bidirectional
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (16 << 0);  ///< DMA register for burst accesses
    }

    /// AF1 Register bits
    namespace af1_bits {
        constexpr uint32_t BKINE = (1U << 0);  ///< BRK BKIN input enable
        constexpr uint32_t BKCMP1E = (1U << 1);  ///< BRK COMP1 enable
        constexpr uint32_t BKCMP2E = (1U << 2);  ///< BRK COMP2 enable
        constexpr uint32_t BKDFBK1E = (1U << 8);  ///< BRK DFSDM_BREAK1 enable
        constexpr uint32_t BKINP = (1U << 9);  ///< BRK BKIN input polarity
        constexpr uint32_t BKCMP1P = (1U << 10);  ///< BRK COMP1 input polarity
        constexpr uint32_t BKCMP2P = (1U << 11);  ///< BRK COMP2 input polarit
    }

    /// TISEL Register bits
    namespace tisel_bits {
        constexpr uint32_t TI1SEL = (4 << 0);  ///< selects input
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t LPUART_BASE = 0x40008000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - Prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* LPUART = reinterpret_cast<Registers*>(LPUART_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4_7 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0_3 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable
        constexpr uint32_t ABRMOD = (2 << 21);  ///< Auto baud rate mode
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t TAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
        constexpr uint32_t DIS_NSS = (1U << 3);  ///< When the DSI_NSS bit is set, the NSS pin input will be ignored
        constexpr uint32_t SLVEN = (1U << 0);  ///< Synchronous Slave mode enable
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration
        constexpr uint32_t TCBGTIE = (1U << 24);  ///< Tr Complete before guard time, interrupt enable
        constexpr uint32_t TXFTIE = (1U << 23);  ///< threshold interrupt enable
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< Ir low-power
        constexpr uint32_t IREN = (1U << 1);  ///< Ir mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR_4_15 = (12 << 4);  ///< BRR_4_15
        constexpr uint32_t BRR_0_3 = (4 << 0);  ///< BRR_0_3
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO Full
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO Empty
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t ABRF = (1U << 15);  ///< ABRF
        constexpr uint32_t ABRE = (1U << 14);  ///< ABRE
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag
        constexpr uint32_t EOBF = (1U << 12);  ///< EOBF
        constexpr uint32_t RTOF = (1U << 11);  ///< RTOF
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t LBDF = (1U << 8);  ///< LBDF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NF = (1U << 2);  ///< NF
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t UDRCF = (1U << 13);  ///< SPI slave underrun clear flag
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of block clear flag
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag
        constexpr uint32_t TCBGTCF = (1U << 7);  ///< Transmission complete before Guard time clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t TXFECF = (1U << 5);  ///< TXFIFO empty clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CKPOL = (1U << 3);  ///< Inactive state clock polarity
        constexpr uint32_t I2SSTD = (2 << 4);  ///< standard selection
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t SE2 = (1U << 10);  ///< I2S enable
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t I2SDIV = (8 << 0);  ///< linear prescaler
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t CFGR1;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t SMPR;  ///< Offset: 0x14 - ADC sampling time register
        volatile uint32_t AWD1TR;  ///< Offset: 0x20 - watchdog threshold register
        volatile uint32_t AWD2TR;  ///< Offset: 0x24 - watchdog threshold register
        volatile uint32_t CHSELR;  ///< Offset: 0x28 - channel selection register
        volatile uint32_t CHSELR_1;  ///< Offset: 0x28 - channel selection register CHSELRMOD = 1 in ADC_CFGR1
        volatile uint32_t AWD3TR;  ///< Offset: 0x2C - watchdog threshold register
        volatile uint32_t DR;  ///< Offset: 0x40 - ADC group regular conversion data register
        volatile uint32_t AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t AWD3CR;  ///< Offset: 0xA4 - ADC analog watchdog 3 configuration register
        volatile uint32_t CALFACT;  ///< Offset: 0xB4 - ADC calibration factors register
        volatile uint32_t CCR;  ///< Offset: 0x308 - ADC common control register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t CCRDY = (1U << 13);  ///< Channel Configuration Ready flag
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag
        constexpr uint32_t AWD3 = (1U << 9);  ///< ADC analog watchdog 3 flag
        constexpr uint32_t AWD2 = (1U << 8);  ///< ADC analog watchdog 2 flag
        constexpr uint32_t AWD1 = (1U << 7);  ///< ADC analog watchdog 1 flag
        constexpr uint32_t OVR = (1U << 4);  ///< ADC group regular overrun flag
        constexpr uint32_t EOS = (1U << 3);  ///< ADC group regular end of sequence conversions flag
        constexpr uint32_t EOC = (1U << 2);  ///< ADC group regular end of unitary conversion flag
        constexpr uint32_t EOSMP = (1U << 1);  ///< ADC group regular end of sampling flag
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t CCRDYIE = (1U << 13);  ///< Channel Configuration Ready Interrupt enable
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable
        constexpr uint32_t AWD3IE = (1U << 9);  ///< ADC analog watchdog 3 interrupt
        constexpr uint32_t AWD2IE = (1U << 8);  ///< ADC analog watchdog 2 interrupt
        constexpr uint32_t AWD1IE = (1U << 7);  ///< ADC analog watchdog 1 interrupt
        constexpr uint32_t OVRIE = (1U << 4);  ///< ADC group regular overrun interrupt
        constexpr uint32_t EOSIE = (1U << 3);  ///< ADC group regular end of sequence conversions interrupt
        constexpr uint32_t EOCIE = (1U << 2);  ///< ADC group regular end of unitary conversion interrupt
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< ADC group regular end of sampling interrupt
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC voltage regulator enable
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC group regular conversion stop
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC group regular conversion start
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t AWDCH1CH = (5 << 26);  ///< ADC analog watchdog 1 monitored channel selection
        constexpr uint32_t AWD1EN = (1U << 23);  ///< ADC analog watchdog 1 enable on scope ADC group regular
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< ADC analog watchdog 1 monitoring a single channel or all channels
        constexpr uint32_t CHSELRMOD = (1U << 21);  ///< Mode selection of the ADC_CHSELR register
        constexpr uint32_t DISCEN = (1U << 16);  ///< ADC group regular sequencer discontinuous mode
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode
        constexpr uint32_t WAIT = (1U << 14);  ///< Wait conversion mode
        constexpr uint32_t CONT = (1U << 13);  ///< ADC group regular continuous conversion mode
        constexpr uint32_t OVRMOD = (1U << 12);  ///< ADC group regular overrun configuration
        constexpr uint32_t EXTEN = (2 << 10);  ///< ADC group regular external trigger polarity
        constexpr uint32_t EXTSEL = (3 << 6);  ///< ADC group regular external trigger source
        constexpr uint32_t ALIGN = (1U << 5);  ///< ADC data alignement
        constexpr uint32_t RES = (2 << 3);  ///< ADC data resolution
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction
        constexpr uint32_t DMACFG = (1U << 1);  ///< ADC DMA transfer configuration
        constexpr uint32_t DMAEN = (1U << 0);  ///< ADC DMA transfer enable
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode
        constexpr uint32_t LFTRIG = (1U << 29);  ///< Low frequency trigger mode enable
        constexpr uint32_t TOVS = (1U << 9);  ///< ADC oversampling discontinuous mode (triggered mode) for ADC group regular
        constexpr uint32_t OVSS = (4 << 5);  ///< ADC oversampling shift
        constexpr uint32_t OVSR = (3 << 2);  ///< ADC oversampling ratio
        constexpr uint32_t OVSE = (1U << 0);  ///< ADC oversampler enable on scope ADC group regular
    }

    /// SMPR Register bits
    namespace smpr_bits {
        constexpr uint32_t SMP1 = (3 << 0);  ///< Sampling time selection
        constexpr uint32_t SMP2 = (3 << 4);  ///< Sampling time selection
        constexpr uint32_t SMPSEL = (19 << 8);  ///< Channel sampling time selection
    }

    /// AWD1TR Register bits
    namespace awd1tr_bits {
        constexpr uint32_t HT1 = (12 << 16);  ///< ADC analog watchdog 1 threshold high
        constexpr uint32_t LT1 = (12 << 0);  ///< ADC analog watchdog 1 threshold low
    }

    /// AWD2TR Register bits
    namespace awd2tr_bits {
        constexpr uint32_t HT2 = (12 << 16);  ///< ADC analog watchdog 2 threshold high
        constexpr uint32_t LT2 = (12 << 0);  ///< ADC analog watchdog 2 threshold low
    }

    /// CHSELR Register bits
    namespace chselr_bits {
        constexpr uint32_t CHSEL = (19 << 0);  ///< Channel-x selection
    }

    /// CHSELR_1 Register bits
    namespace chselr_1_bits {
        constexpr uint32_t SQ1 = (4 << 0);  ///< conversion of the sequence
        constexpr uint32_t SQ2 = (4 << 4);  ///< conversion of the sequence
        constexpr uint32_t SQ3 = (4 << 8);  ///< conversion of the sequence
        constexpr uint32_t SQ4 = (4 << 12);  ///< conversion of the sequence
        constexpr uint32_t SQ5 = (4 << 16);  ///< conversion of the sequence
        constexpr uint32_t SQ6 = (4 << 20);  ///< conversion of the sequence
        constexpr uint32_t SQ7 = (4 << 24);  ///< conversion of the sequence
        constexpr uint32_t SQ8 = (4 << 28);  ///< conversion of the sequence
    }

    /// AWD3TR Register bits
    namespace awd3tr_bits {
        constexpr uint32_t HT3 = (12 << 16);  ///< ADC analog watchdog 3 threshold high
        constexpr uint32_t LT3 = (12 << 0);  ///< ADC analog watchdog 3 threshold high
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t regularDATA = (16 << 0);  ///< ADC group regular conversion data
    }

    /// AWD2CR Register bits
    namespace awd2cr_bits {
        constexpr uint32_t AWD2CH = (19 << 0);  ///< ADC analog watchdog 2 monitored channel selection
    }

    /// AWD3CR Register bits
    namespace awd3cr_bits {
        constexpr uint32_t AWD3CH = (19 << 0);  ///< ADC analog watchdog 3 monitored channel selection
    }

    /// CALFACT Register bits
    namespace calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< ADC calibration factor in single-ended mode
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable
        constexpr uint32_t VBATEN = (1U << 24);  ///< VBAT enable
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;
    constexpr uint32_t SYSCFG_ITLINE_BASE = 0x40010080;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - SYSCFG configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x18 - SYSCFG configuration register 1
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);
    inline Registers* SYSCFG_ITLINE = reinterpret_cast<Registers*>(SYSCFG_ITLINE_BASE);

    // Bit definitions
    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t I2C_PAx_FMP = (2 << 22);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t I2C2_FMP = (1U << 21);  ///< FM+ driving capability activation for I2C2
        constexpr uint32_t I2C1_FMP = (1U << 20);  ///< FM+ driving capability activation for I2C1
        constexpr uint32_t I2C_PBx_FMP = (4 << 16);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
        constexpr uint32_t IR_MOD = (2 << 6);  ///< IR Modulation Envelope signal selection.
        constexpr uint32_t IR_POL = (1U << 5);  ///< IR output polarity selection
        constexpr uint32_t PA11_PA12_RMP = (1U << 4);  ///< PA11 and PA12 remapping bit.
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t LOCKUP_LOCK = (1U << 0);  ///< Cortex-M0+ LOCKUP bit enable bit
        constexpr uint32_t SRAM_PARITY_LOCK = (1U << 1);  ///< SRAM parity lock bit
        constexpr uint32_t PVD_LOCK = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t ECC_LOCK = (1U << 3);  ///< ECC error lock bit
        constexpr uint32_t SRAM_PEF = (1U << 8);  ///< SRAM parity error flag
        constexpr uint32_t PA1_CDEN = (1U << 16);  ///< PA1_CDEN
        constexpr uint32_t PA3_CDEN = (1U << 17);  ///< PA3_CDEN
        constexpr uint32_t PA5_CDEN = (1U << 18);  ///< PA5_CDEN
        constexpr uint32_t PA6_CDEN = (1U << 19);  ///< PA6_CDEN
        constexpr uint32_t PA13_CDEN = (1U << 20);  ///< PA13_CDEN
        constexpr uint32_t PB0_CDEN = (1U << 21);  ///< PB0_CDEN
        constexpr uint32_t PB1_CDEN = (1U << 22);  ///< PB1_CDEN
        constexpr uint32_t PB2_CDEN = (1U << 23);  ///< PB2_CDEN
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x4000B000;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t BKP0R;  ///< Offset: 0x100 - TAMP backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x104 - TAMP backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x108 - TAMP backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x10C - TAMP backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x110 - TAMP backup register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< TAMP1E
        constexpr uint32_t TAMP2E = (1U << 1);  ///< TAMP2E
        constexpr uint32_t ITAMP1E = (1U << 16);  ///< ITAMP1E
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< ITAMP3E
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< ITAMP4E
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< ITAMP5E
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< ITAMP6E
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< TAMP1NOER
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< TAMP2NOER
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< TAMP1MSK
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< TAMP2MSK
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< TAMP1TRG
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< TAMP2TRG
    }

    /// FLTCR Register bits
    namespace fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< TAMPFREQ
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMPFLT
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMPPRCH
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMPPUDIS
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< TAMP1IE
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< TAMP2IE
        constexpr uint32_t ITAMP1IE = (1U << 16);  ///< ITAMP1IE
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< ITAMP3IE
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< ITAMP4IE
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< ITAMP5IE
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< ITAMP6IE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1F
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2F
        constexpr uint32_t ITAMP1F = (1U << 16);  ///< ITAMP1F
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< ITAMP3F
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< ITAMP4F
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< ITAMP5F
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ITAMP6F
        constexpr uint32_t ITAMP7F = (1U << 22);  ///< ITAMP7F
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF:
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< ITAMP4MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< CTAMP1F
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< CTAMP2F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< CITAMP3F
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< CITAMP4F
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< CITAMP5F
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< CITAMP6F
        constexpr uint32_t CITAMP7F = (1U << 22);  ///< CITAMP7F
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1_0 = (1U << 0);  ///< Interface address
        constexpr uint32_t OA1_7_1 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA1_8_9 = (2 << 8);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - status clear register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< WUCKSEL
        constexpr uint32_t TSEDGE = (1U << 3);  ///< TSEDGE
        constexpr uint32_t REFCKON = (1U << 4);  ///< REFCKON
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< BYPSHAD
        constexpr uint32_t FMT = (1U << 6);  ///< FMT
        constexpr uint32_t ALRAE = (1U << 8);  ///< ALRAE
        constexpr uint32_t ALRBE = (1U << 9);  ///< ALRBE
        constexpr uint32_t WUTE = (1U << 10);  ///< WUTE
        constexpr uint32_t TSE = (1U << 11);  ///< TSE
        constexpr uint32_t ALRAIE = (1U << 12);  ///< ALRAIE
        constexpr uint32_t ALRBIE = (1U << 13);  ///< ALRBIE
        constexpr uint32_t WUTIE = (1U << 14);  ///< WUTIE
        constexpr uint32_t TSIE = (1U << 15);  ///< TSIE
        constexpr uint32_t ADD1H = (1U << 16);  ///< ADD1H
        constexpr uint32_t SUB1H = (1U << 17);  ///< SUB1H
        constexpr uint32_t BKP = (1U << 18);  ///< BKP
        constexpr uint32_t COSEL = (1U << 19);  ///< COSEL
        constexpr uint32_t POL = (1U << 20);  ///< POL
        constexpr uint32_t OSEL = (2 << 21);  ///< OSEL
        constexpr uint32_t COE = (1U << 23);  ///< COE
        constexpr uint32_t ITSE = (1U << 24);  ///< ITSE
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x40010030;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
        constexpr uint32_t VRS = (3 << 4);  ///< Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x40015800;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - DBGMCU_IDCODE
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU configuration register
        volatile uint32_t APB_FZ1;  ///< Offset: 0x08 - Debug MCU APB1 freeze register1
        volatile uint32_t APB_FZ2;  ///< Offset: 0x0C - Debug MCU APB1 freeze register 2
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision identifie
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby mode
    }

    /// APB_FZ1 Register bits
    namespace apb_fz1_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 counter stopped when core is halted
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 counter stopped when core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< RTC counter stopped when core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Window watchdog counter stopped when core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Independent watchdog counter stopped when core is halted
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout counter stopped when core is halted
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 30);  ///< LPTIM2 counter stopped when core is halted
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 31);  ///< LPTIM1 counter stopped when core is halted
    }

    /// APB_FZ2 Register bits
    namespace apb_fz2_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM14_STOP = (1U << 15);  ///< DBG_TIM14_STOP
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< DBG_TIM16_STOP
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

}


} // namespace alloy::generated::stm32g031

#endif // ALLOY_GENERATED_STM32G031_PERIPHERALS_HPP