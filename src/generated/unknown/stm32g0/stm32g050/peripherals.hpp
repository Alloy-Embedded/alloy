/// Auto-generated code for STM32G050
/// Generated by Alloy Code Generator
/// Source: st_stm32g050.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:23
#ifndef ALLOY_GENERATED_STM32G050_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32G050_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32g050 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 6;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 8;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 6;
    constexpr uint32_t max_gpio_pins = 96;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR;  ///< Offset: 0x14 - ADC sampling time register
        volatile uint32_t ADC_AWD1TR;  ///< Offset: 0x20 - ADC watchdog threshold register
        volatile uint32_t ADC_AWD2TR;  ///< Offset: 0x24 - ADC watchdog threshold register
        volatile uint32_t ADC_CHSELR_0;  ///< Offset: 0x28 - ADC channel selection register [alternate]
        volatile uint32_t ADC_CHSELR_1;  ///< Offset: 0x28 - channel selection register CHSELRMOD = 1 in ADC_CFGR1
        volatile uint32_t ADC_AWD3TR;  ///< Offset: 0x2C - ADC watchdog threshold register
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC Analog Watchdog 2 Configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC Analog Watchdog 3 Configuration register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xB4 - ADC Calibration factor
        volatile uint32_t ADC_CCR;  ///< Offset: 0x308 - ADC common configuration register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready This bit is set by hardware after the ADC has been enabled (ADEN=1) and when the ADC reaches a state where it is ready to accept conversion requests. It is cleared by software writing 1 to it.
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1â.
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
        constexpr uint32_t EOS = (1U << 3);  ///< End of sequence flag This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
        constexpr uint32_t AWD1 = (1U << 7);  ///< Analog watchdog 1 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
        constexpr uint32_t AWD2 = (1U << 8);  ///< Analog watchdog 2 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
        constexpr uint32_t AWD3 = (1U << 9);  ///< Analog watchdog 3 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
        constexpr uint32_t CCRDY = (1U << 13);  ///< Channel Configuration Ready flag This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it. Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable This bit is set and cleared by software to enable/disable the ADC Ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of conversion interrupt enable This bit is set and cleared by software to enable/disable the end of conversion interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of conversion sequence interrupt enable This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable This bit is set and cleared by software to enable/disable the overrun interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1IE = (1U << 7);  ///< Analog watchdog 1 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD2IE = (1U << 8);  ///< Analog watchdog 2 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD3IE = (1U << 9);  ///< Analog watchdog 3 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable This bit is set and cleared by software to enable/disable the end of calibration interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CCRDYIE = (1U << 13);  ///< Channel Configuration Ready Interrupt enable This bit is set and cleared by software to enable/disable the channel configuration ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable command This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set. It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command. Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0, ADSTP=0, ADSTART=0, ADDIS=0 and ADEN=0)
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state). It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time). Note: Setting ADDIS to '1â is only effective when ADEN=1 and ADSTART=0 (which ensures that no conversion is ongoing)
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start conversion command This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration). It is cleared by hardware: In single conversion mode (CONT=0, DISCEN=0), when software trigger is selected (EXTEN=00): at the assertion of the end of Conversion Sequence (EOS) flag. In discontinuous conversion mode(CONT=0, DISCEN=1), when the software trigger is selected (EXTEN=00): at the assertion of the end of Conversion (EOC) flag. In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware. Note: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled and there is no pending request to disable the ADC). After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop conversion command This bit is set by software to stop and discard an ongoing conversion (ADSTP Command). It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command. Note: Setting ADSTP to '1â is only effective when ADSTART=1 and ADDIS=0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC Voltage Regulator Enable This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP. It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0. Note: The software is allowed to program this bit field only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration This bit is set by software to start the calibration of the ADC. It is cleared by hardware after calibration is complete. Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0). The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN=1 and ADSTART=0 (ADC enabled and no conversion is ongoing).
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< Direct memory access enable This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to . Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t DMACFG = (1U << 1);  ///< Direct memory access configuration This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN=1. For more details, refer to page351 Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t RES = (2 << 3);  ///< Data resolution These bits are written by software to select the resolution of the conversion. Note: The software is allowed to write these bits only when ADEN=0.
        constexpr uint32_t ALIGN = (1U << 5);  ///< Data alignment This bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page349 Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EXTSEL = (3 << 6);  ///< External trigger selection These bits select the external event used to trigger the start of conversion (refer to External triggers for details): Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection These bits are set and cleared by software to select the external trigger polarity and enable the trigger. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun management mode This bit is set and cleared by software and configure the way data overruns are managed. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t WAIT = (1U << 14);  ///< Wait conversion mode This bit is set and cleared by software to enable/disable wait conversion mode.. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode This bit is set and cleared by software to enable/disable auto-off mode.. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode This bit is set and cleared by software to enable/disable discontinuous mode. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CHSELRMOD = (1U << 21);  ///< Mode selection of the ADC_CHSELR register This bit is set and cleared by software to control the ADC_CHSELR feature: Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< Enable the watchdog on a single channel or on all channels This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1EN = (1U << 23);  ///< Analog watchdog enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1CH = (5 << 26);  ///< Analog watchdog channel selection These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. ..... Others: Reserved Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t OVSE = (1U << 0);  ///< Oversampler Enable This bit is set and cleared by software. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OVSR = (3 << 2);  ///< Oversampling ratio This bit filed defines the number of oversampling ratio. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OVSS = (4 << 5);  ///< Oversampling shift This bit is set and cleared by software. Others: Reserved Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TOVS = (1U << 9);  ///< Triggered Oversampling This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t LFTRIG = (1U << 29);  ///< Low frequency trigger mode enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode These bits are set and cleared by software to define how the analog ADC is clocked: In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
    }

    /// ADC_SMPR Register bits
    namespace adc_smpr_bits {
        constexpr uint32_t SMP1 = (3 << 0);  ///< Sampling time selection 1 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP2 = (3 << 4);  ///< Sampling time selection 2 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL0 = (1U << 8);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL1 = (1U << 9);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL2 = (1U << 10);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL3 = (1U << 11);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL4 = (1U << 12);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL5 = (1U << 13);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL6 = (1U << 14);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL7 = (1U << 15);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL8 = (1U << 16);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL9 = (1U << 17);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL10 = (1U << 18);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL11 = (1U << 19);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL12 = (1U << 20);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL13 = (1U << 21);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL14 = (1U << 22);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL15 = (1U << 23);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL16 = (1U << 24);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL17 = (1U << 25);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL18 = (1U << 26);  ///< Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD1TR Register bits
    namespace adc_awd1tr_bits {
        constexpr uint32_t LT1 = (12 << 0);  ///< Analog watchdog 1 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
        constexpr uint32_t HT1 = (12 << 16);  ///< Analog watchdog 1 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
    }

    /// ADC_AWD2TR Register bits
    namespace adc_awd2tr_bits {
        constexpr uint32_t LT2 = (12 << 0);  ///< Analog watchdog 2 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
        constexpr uint32_t HT2 = (12 << 16);  ///< Analog watchdog 2 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
    }

    /// ADC_CHSELR_0 Register bits
    namespace adc_chselr_0_bits {
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL8 = (1U << 8);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL9 = (1U << 9);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL10 = (1U << 10);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL11 = (1U << 11);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL12 = (1U << 12);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL13 = (1U << 13);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL14 = (1U << 14);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL15 = (1U << 15);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL16 = (1U << 16);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL17 = (1U << 17);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL18 = (1U << 18);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to for ADC inputs connected to external channels and internal sources. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    }

    /// ADC_CHSELR_1 Register bits
    namespace adc_chselr_1_bits {
        constexpr uint32_t SQ1 = (4 << 0);  ///< 1st conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ2 = (4 << 4);  ///< 2nd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ3 = (4 << 8);  ///< 3rd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ4 = (4 << 12);  ///< 4th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ5 = (4 << 16);  ///< 5th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ6 = (4 << 20);  ///< 6th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ7 = (4 << 24);  ///< 7th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ8 = (4 << 28);  ///< 8th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. ... Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3TR Register bits
    namespace adc_awd3tr_bits {
        constexpr uint32_t LT3 = (12 << 0);  ///< Analog watchdog 3lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
        constexpr uint32_t HT3 = (12 << 16);  ///< Analog watchdog 3 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on page355.
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Converted data These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page349. Just after a calibration is complete, DATA[6:0] contains the calibration factor.
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH0 = (1U << 0);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH1 = (1U << 1);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH2 = (1U << 2);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH3 = (1U << 3);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH4 = (1U << 4);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH5 = (1U << 5);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH6 = (1U << 6);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH7 = (1U << 7);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH8 = (1U << 8);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH9 = (1U << 9);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH10 = (1U << 10);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH11 = (1U << 11);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH12 = (1U << 12);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH13 = (1U << 13);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH14 = (1U << 14);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH15 = (1U << 15);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH16 = (1U << 16);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH17 = (1U << 17);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH18 = (1U << 18);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH0 = (1U << 0);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH1 = (1U << 1);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH2 = (1U << 2);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH3 = (1U << 3);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH4 = (1U << 4);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH5 = (1U << 5);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH6 = (1U << 6);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH7 = (1U << 7);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH8 = (1U << 8);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH9 = (1U << 9);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH10 = (1U << 10);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH11 = (1U << 11);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH12 = (1U << 12);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH13 = (1U << 13);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH14 = (1U << 14);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH15 = (1U << 15);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH16 = (1U << 16);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH17 = (1U << 17);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH18 = (1U << 18);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< Calibration factor These bits are written by hardware or by software. Once a calibration is complete,they are updated by hardware with the calibration factors. Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched. Just after a calibration is complete, DATA[6:0] contains the calibration factor. Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.
    }

    /// ADC_CCR Register bits
    namespace adc_ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable This bit is set and cleared by software to enable/disable the VREFINT. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable This bit is set and cleared by software to enable/disable the temperature sensor. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t VBATEN = (1U << 24);  ///< VBAT enable This bit is set and cleared by software to enable/disable the VBAT channel. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRC_DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t CRC_IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CRC_CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t CRC_INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t CRC_POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRC_DR Register bits
    namespace crc_dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// CRC_IDR Register bits
    namespace crc_idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 32-bit data register bits
    }

    /// CRC_CR Register bits
    namespace crc_cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data This bit controls the reversal of the bit order of the output data.
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data These bits control the reversal of the bit order of the input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size These bits control the size of the polynomial.
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// CRC_INIT Register bits
    namespace crc_init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// CRC_POL Register bits
    namespace crc_pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x40015800;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - MCU Device ID Code Register
        volatile uint32_t DBG_CR;  ///< Offset: 0x04 - DBG configuration register
        volatile uint32_t DBG_APB_FZ1;  ///< Offset: 0x08 - DBG APB freeze register 1
        volatile uint32_t DBG_APB_FZ2;  ///< Offset: 0x0C - DBG APB freeze register 2
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device Identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision Identifier
    }

    /// DBG_CR Register bits
    namespace dbg_cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode Debug options in Stop mode. Upon Stop mode exit, the software must re-establish the desired clock configuration.
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby and Shutdown modes Debug options in Standby or Shutdown mode.
    }

    /// DBG_APB_FZ1 Register bits
    namespace dbg_apb_fz1_bits {
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< Clocking of TIM3 counter when the core is halted This bit enables/disables the clock to the counter of TIM3 when the core is halted:
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< Clocking of TIM6 counter when the core is halted This bit enables/disables the clock to the counter of TIM6 when the core is halted:
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< Clocking of TIM7 counter when the core is halted. This bit enables/disables the clock to the counter of ITIM7 when the core is halted:
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< Clocking of RTC counter when the core is halted This bit enables/disables the clock to the counter of RTC when the core is halted:
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Clocking of WWDG counter when the core is halted This bit enables/disables the clock to the counter of WWDG when the core is halted:
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Clocking of IWDG counter when the core is halted This bit enables/disables the clock to the counter of IWDG when the core is halted:
        constexpr uint32_t DBG_I2C1_SMBUS_TIMEOUT = (1U << 21);  ///< SMBUS timeout when core is halted
        constexpr uint32_t DBG_I2C2_SMBUS_TIMEOUT = (1U << 22);  ///< SMBUS timeout when core is halted
    }

    /// DBG_APB_FZ2 Register bits
    namespace dbg_apb_fz2_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< Clocking of TIM1 counter when the core is halted This bit enables/disables the clock to the counter of TIM1 when the core is halted:
        constexpr uint32_t DBG_TIM14_STOP = (1U << 15);  ///< Clocking of TIM14 counter when the core is halted This bit enables/disables the clock to the counter of TIM14 when the core is halted:
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< Clocking of TIM15 counter when the core is halted This bit enables/disables the clock to the counter of TIM15 when the core is halted: Only available on STM32G071xx and STM32G081xx, reserved on STM32G031xx and STM32G041xx.
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< Clocking of TIM16 counter when the core is halted This bit enables/disables the clock to the counter of TIM16 when the core is halted:
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< Clocking of TIM17 counter when the core is halted This bit enables/disables the clock to the counter of TIM17 when the core is halted:
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40020000;
    constexpr uint32_t DMAMUX_BASE = 0x40020800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMA_ISR;  ///< Offset: 0x00 - DMA interrupt status register
        volatile uint32_t DMA_IFCR;  ///< Offset: 0x04 - DMA interrupt flag clear register
        volatile uint32_t DMA_CCR1;  ///< Offset: 0x08 - DMA channel 1 configuration register
        volatile uint32_t DMA_CNDTR1;  ///< Offset: 0x0C - DMA channel x number of data register
        volatile uint32_t DMA_CPAR1;  ///< Offset: 0x10 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR1;  ///< Offset: 0x14 - DMA channel x memory address register
        volatile uint32_t DMA_CCR2;  ///< Offset: 0x1C - DMA channel 2 configuration register
        volatile uint32_t DMA_CNDTR2;  ///< Offset: 0x20 - DMA channel x number of data register
        volatile uint32_t DMA_CPAR2;  ///< Offset: 0x24 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR2;  ///< Offset: 0x28 - DMA channel x memory address register
        volatile uint32_t DMA_CCR3;  ///< Offset: 0x30 - DMA channel 3 configuration register
        volatile uint32_t DMA_CNDTR3;  ///< Offset: 0x34 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR3;  ///< Offset: 0x38 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR3;  ///< Offset: 0x3C - DMA channel x memory address register
        volatile uint32_t DMA_CCR4;  ///< Offset: 0x44 - DMA channel 4 configuration register
        volatile uint32_t DMA_CNDTR4;  ///< Offset: 0x48 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR4;  ///< Offset: 0x4C - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR4;  ///< Offset: 0x50 - DMA channel x memory address register
        volatile uint32_t DMA_CCR5;  ///< Offset: 0x58 - DMA channel 5 configuration register
        volatile uint32_t DMA_CNDTR5;  ///< Offset: 0x5C - DMA channel x configuration register
        volatile uint32_t DMA_CPAR5;  ///< Offset: 0x60 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR5;  ///< Offset: 0x64 - DMA channel x memory address register
        volatile uint32_t DMA_CCR6;  ///< Offset: 0x6C - DMA channel 6 configuration register
        volatile uint32_t DMA_CNDTR6;  ///< Offset: 0x70 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR6;  ///< Offset: 0x74 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR6;  ///< Offset: 0x78 - DMA channel x memory address register
        volatile uint32_t DMA_CCR7;  ///< Offset: 0x80 - DMA channel 7 configuration register
        volatile uint32_t DMA_CNDTR7;  ///< Offset: 0x84 - DMA channel x configuration register
        volatile uint32_t DMA_CPAR7;  ///< Offset: 0x88 - DMA channel x peripheral address register
        volatile uint32_t DMA_CMAR7;  ///< Offset: 0x8C - DMA channel x memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// DMA_ISR Register bits
    namespace dma_isr_bits {
        constexpr uint32_t GIF1 = (1U << 0);  ///< global interrupt flag for channel 1
        constexpr uint32_t TCIF1 = (1U << 1);  ///< transfer complete (TC) flag for channel 1
        constexpr uint32_t HTIF1 = (1U << 2);  ///< half transfer (HT) flag for channel 1
        constexpr uint32_t TEIF1 = (1U << 3);  ///< transfer error (TE) flag for channel 1
        constexpr uint32_t GIF2 = (1U << 4);  ///< global interrupt flag for channel 2
        constexpr uint32_t TCIF2 = (1U << 5);  ///< transfer complete (TC) flag for channel 2
        constexpr uint32_t HTIF2 = (1U << 6);  ///< half transfer (HT) flag for channel 2
        constexpr uint32_t TEIF2 = (1U << 7);  ///< transfer error (TE) flag for channel 2
        constexpr uint32_t GIF3 = (1U << 8);  ///< global interrupt flag for channel 3
        constexpr uint32_t TCIF3 = (1U << 9);  ///< transfer complete (TC) flag for channel 3
        constexpr uint32_t HTIF3 = (1U << 10);  ///< half transfer (HT) flag for channel 3
        constexpr uint32_t TEIF3 = (1U << 11);  ///< transfer error (TE) flag for channel 3
        constexpr uint32_t GIF4 = (1U << 12);  ///< global interrupt flag for channel 4
        constexpr uint32_t TCIF4 = (1U << 13);  ///< transfer complete (TC) flag for channel 4
        constexpr uint32_t HTIF4 = (1U << 14);  ///< half transfer (HT) flag for channel 4
        constexpr uint32_t TEIF4 = (1U << 15);  ///< transfer error (TE) flag for channel 4
        constexpr uint32_t GIF5 = (1U << 16);  ///< global interrupt flag for channel 5
        constexpr uint32_t TCIF5 = (1U << 17);  ///< transfer complete (TC) flag for channel 5
        constexpr uint32_t HTIF5 = (1U << 18);  ///< half transfer (HT) flag for channel 5
        constexpr uint32_t TEIF5 = (1U << 19);  ///< transfer error (TE) flag for channel 5
        constexpr uint32_t GIF6 = (1U << 20);  ///< global interrupt flag for channel 6
        constexpr uint32_t TCIF6 = (1U << 21);  ///< transfer complete (TC) flag for channel 6
        constexpr uint32_t HTIF6 = (1U << 22);  ///< half transfer (HT) flag for channel 6
        constexpr uint32_t TEIF6 = (1U << 23);  ///< transfer error (TE) flag for channel 6
        constexpr uint32_t GIF7 = (1U << 24);  ///< global interrupt flag for channel 7
        constexpr uint32_t TCIF7 = (1U << 25);  ///< transfer complete (TC) flag for channel 7
        constexpr uint32_t HTIF7 = (1U << 26);  ///< half transfer (HT) flag for channel 7
        constexpr uint32_t TEIF7 = (1U << 27);  ///< transfer error (TE) flag for channel 7
    }

    /// DMA_IFCR Register bits
    namespace dma_ifcr_bits {
        constexpr uint32_t CGIF1 = (1U << 0);  ///< global interrupt flag clear for channel 1
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< transfer complete flag clear for channel 1
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< half transfer flag clear for channel 1
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< transfer error flag clear for channel 1
        constexpr uint32_t CGIF2 = (1U << 4);  ///< global interrupt flag clear for channel 2
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< transfer complete flag clear for channel 2
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< half transfer flag clear for channel 2
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< transfer error flag clear for channel 2
        constexpr uint32_t CGIF3 = (1U << 8);  ///< global interrupt flag clear for channel 3
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< transfer complete flag clear for channel 3
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< half transfer flag clear for channel 3
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< transfer error flag clear for channel 3
        constexpr uint32_t CGIF4 = (1U << 12);  ///< global interrupt flag clear for channel 4
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< transfer complete flag clear for channel 4
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< half transfer flag clear for channel 4
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< transfer error flag clear for channel 4
        constexpr uint32_t CGIF5 = (1U << 16);  ///< global interrupt flag clear for channel 5
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< transfer complete flag clear for channel 5
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< half transfer flag clear for channel 5
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< transfer error flag clear for channel 5
        constexpr uint32_t CGIF6 = (1U << 20);  ///< global interrupt flag clear for channel 6
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< transfer complete flag clear for channel 6
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< half transfer flag clear for channel 6
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< transfer error flag clear for channel 6
        constexpr uint32_t CGIF7 = (1U << 24);  ///< global interrupt flag clear for channel 7
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< transfer complete flag clear for channel 7
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< half transfer flag clear for channel 7
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< transfer error flag clear for channel 7
    }

    /// DMA_CCR1 Register bits
    namespace dma_ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR1 Register bits
    namespace dma_cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR1 Register bits
    namespace dma_cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR1 Register bits
    namespace dma_cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR2 Register bits
    namespace dma_ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR2 Register bits
    namespace dma_cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR2 Register bits
    namespace dma_cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR2 Register bits
    namespace dma_cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR3 Register bits
    namespace dma_ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR3 Register bits
    namespace dma_cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR3 Register bits
    namespace dma_cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR3 Register bits
    namespace dma_cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR4 Register bits
    namespace dma_ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR4 Register bits
    namespace dma_cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR4 Register bits
    namespace dma_cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR4 Register bits
    namespace dma_cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR5 Register bits
    namespace dma_ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR5 Register bits
    namespace dma_cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR5 Register bits
    namespace dma_cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR5 Register bits
    namespace dma_cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR6 Register bits
    namespace dma_ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR6 Register bits
    namespace dma_cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR6 Register bits
    namespace dma_cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR6 Register bits
    namespace dma_cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CCR7 Register bits
    namespace dma_ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CNDTR7 Register bits
    namespace dma_cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216-1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN=1).
    }

    /// DMA_CPAR7 Register bits
    namespace dma_cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

    /// DMA_CMAR7 Register bits
    namespace dma_cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN=1).
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40021800;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t IMR1;  ///< Offset: 0x80 - EXTI CPU wakeup with interrupt mask register
        volatile uint32_t EMR1;  ///< Offset: 0x84 - EXTI CPU wakeup with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event line
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event line
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable line
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable line
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software rising edge event trigger on line
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software rising edge event trigger on line
    }

    /// RPR1 Register bits
    namespace rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF1 = (1U << 1);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF2 = (1U << 2);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF3 = (1U << 3);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF4 = (1U << 4);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge Pending bit
        constexpr uint32_t RPIF6 = (1U << 6);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF7 = (1U << 7);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF8 = (1U << 8);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF9 = (1U << 9);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF10 = (1U << 10);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF11 = (1U << 11);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF12 = (1U << 12);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF13 = (1U << 13);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF14 = (1U << 14);  ///< Rising edge event pending for configurable line
        constexpr uint32_t RPIF15 = (1U << 15);  ///< Rising edge event pending for configurable line
    }

    /// FPR1 Register bits
    namespace fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF1 = (1U << 1);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF2 = (1U << 2);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF3 = (1U << 3);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF4 = (1U << 4);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF5 = (1U << 5);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF6 = (1U << 6);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF7 = (1U << 7);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF8 = (1U << 8);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF9 = (1U << 9);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF10 = (1U << 10);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF11 = (1U << 11);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF12 = (1U << 12);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF13 = (1U << 13);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF14 = (1U << 14);  ///< Falling edge event pending for configurable line
        constexpr uint32_t FPIF15 = (1U << 15);  ///< Falling edge event pending for configurable line
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM26 = (1U << 26);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM31 = (1U << 31);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR1 Register bits
    namespace emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM26 = (1U << 26);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM31 = (1U << 31);  ///< CPU wakeup with event mask on event input
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t KEYR;  ///< Offset: 0x08 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x0C - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t CR;  ///< Offset: 0x14 - Flash control register
        volatile uint32_t ECCR;  ///< Offset: 0x18 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x20 - Flash option register
        volatile uint32_t WRP1AR;  ///< Offset: 0x2C - Flash WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x30 - Flash WRP area B address register
        volatile uint32_t WRP2AR;  ///< Offset: 0x4C - FLASH WRP2 area A address register
        volatile uint32_t WRP2BR;  ///< Offset: 0x50 - FLASH WRP2 area B address register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t EMPTY = (1U << 16);  ///< Flash User area empty
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< KEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t MISERR = (1U << 8);  ///< Fast programming data miss error
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option and Engineering bits loading validity error
        constexpr uint32_t BSY1 = (1U << 16);  ///< BSY1
        constexpr uint32_t BSY2 = (1U << 17);  ///< BSY2
        constexpr uint32_t CFGBSY = (1U << 18);  ///< Programming or erase configuration busy.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Mass erase
        constexpr uint32_t PNB = (10 << 3);  ///< Page number
        constexpr uint32_t BKER = (1U << 13);  ///< BKER
        constexpr uint32_t MER2 = (1U << 15);  ///< MER2
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (14 << 0);  ///< ECC fail address
        constexpr uint32_t SYSF_ECC = (1U << 20);  ///< ECC fail for Corrected ECC Error or Double ECC Error in info block
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t nRST_STOP = (1U << 13);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 14);  ///< nRST_STDBY
        constexpr uint32_t IDWG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t nSWAP_BANK = (1U << 20);  ///< nSWAP_BANK
        constexpr uint32_t DUAL_BANK = (1U << 21);  ///< DUAL_BANK
        constexpr uint32_t RAM_PARITY_CHECK = (1U << 22);  ///< SRAM parity check control
        constexpr uint32_t nBOOT_SEL = (1U << 24);  ///< nBOOT_SEL
        constexpr uint32_t nBOOT1 = (1U << 25);  ///< Boot configuration
        constexpr uint32_t nBOOT0 = (1U << 26);  ///< nBOOT0 option bit
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (7 << 0);  ///< WRP area A start offset
        constexpr uint32_t WRP1A_END = (7 << 16);  ///< WRP area A end offset
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (7 << 0);  ///< WRP area B start offset
        constexpr uint32_t WRP1B_END = (7 << 16);  ///< WRP area B end offset
    }

    /// WRP2AR Register bits
    namespace wrp2ar_bits {
        constexpr uint32_t WRP2A_STRT = (7 << 0);  ///< WRP2A_STRT
        constexpr uint32_t WRP2A_END = (7 << 16);  ///< WRP2A_END
    }

    /// WRP2BR Register bits
    namespace wrp2br_bits {
        constexpr uint32_t WRP2B_STRT = (7 << 0);  ///< WRP2B_STRT
        constexpr uint32_t WRP2B_END = (7 << 16);  ///< WRP2B_END
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOE_BASE = 0x50001000;
    constexpr uint32_t GPIOF_BASE = 0x50001400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port Reset bit
        constexpr uint32_t BR1 = (1U << 1);  ///< Port Reset bit
        constexpr uint32_t BR2 = (1U << 2);  ///< Port Reset bit
        constexpr uint32_t BR3 = (1U << 3);  ///< Port Reset bit
        constexpr uint32_t BR4 = (1U << 4);  ///< Port Reset bit
        constexpr uint32_t BR5 = (1U << 5);  ///< Port Reset bit
        constexpr uint32_t BR6 = (1U << 6);  ///< Port Reset bit
        constexpr uint32_t BR7 = (1U << 7);  ///< Port Reset bit
        constexpr uint32_t BR8 = (1U << 8);  ///< Port Reset bit
        constexpr uint32_t BR9 = (1U << 9);  ///< Port Reset bit
        constexpr uint32_t BR10 = (1U << 10);  ///< Port Reset bit
        constexpr uint32_t BR11 = (1U << 11);  ///< Port Reset bit
        constexpr uint32_t BR12 = (1U << 12);  ///< Port Reset bit
        constexpr uint32_t BR13 = (1U << 13);  ///< Port Reset bit
        constexpr uint32_t BR14 = (1U << 14);  ///< Port Reset bit
        constexpr uint32_t BR15 = (1U << 15);  ///< Port Reset bit
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2C_CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t I2C_CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t I2C_OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t I2C_OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t I2C_TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t I2C_TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t I2C_ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t I2C_ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t I2C_PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t I2C_RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t I2C_TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// I2C_CR1 Register bits
    namespace i2c_cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match Interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received Interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< Stop detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable Note: Any of these events generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control This bit is used to enable hardware byte control in slave mode.
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to . Note: WUPEN can be set only when DNF = '0000â
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    }

    /// I2C_CR2 Register bits
    namespace i2c_cr2_bits {
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] should be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t START = (1U << 13);  ///< Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1â to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit generates a START condition once the bus is free. Note: Writing '0â to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In Master Mode: Note: Writing '0â to this bit has no effect.
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing '0â to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes The number of bytes to be transmitted/received is programmed there. This field is donât care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode This bit is set and cleared by software.
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing '0â to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    }

    /// I2C_OAR1 Register bits
    namespace i2c_oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN=0.
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// I2C_OAR2 Register bits
    namespace i2c_oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN=0.
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// I2C_TIMINGR Register bits
    namespace i2c_timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// I2C_TIMEOUTR Register bits
    namespace i2c_timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// I2C_ISR Register bits
    namespace i2c_isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// I2C_ICR Register bits
    namespace i2c_icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// I2C_PECR Register bits
    namespace i2c_pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// I2C_RXDR Register bits
    namespace i2c_rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// I2C_TXDR Register bits
    namespace i2c_txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t IWDG_KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t IWDG_PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t IWDG_RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t IWDG_SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t IWDG_WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// IWDG_KR Register bits
    namespace iwdg_kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// IWDG_PR Register bits
    namespace iwdg_pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider These bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.
    }

    /// IWDG_RLR Register bits
    namespace iwdg_rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// IWDG_SR Register bits
    namespace iwdg_sr_bits {
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Prescaler value can be updated only when PVU bit is reset.
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Reload value can be updated only when RVU bit is reset.
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Window value can be updated only when WVU bit is reset.
    }

    /// IWDG_WINR Register bits
    namespace iwdg_winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PUCRE;  ///< Offset: 0x40 - Power Port E pull-UP control register
        volatile uint32_t PDCRE;  ///< Offset: 0x44 - Power Port E pull-down control register
        volatile uint32_t PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t FPD_LPSLP = (1U << 5);  ///< Flash memory powered down during Low-power sleep mode
        constexpr uint32_t FPD_LPRUN = (1U << 4);  ///< Flash memory powered down during Low-power run mode
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< Flash memory powered down during Stop mode
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t USV = (1U << 10);  ///< USV
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2
        constexpr uint32_t EWUP3 = (1U << 2);  ///< Enable Wakeup pin WKUP3
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable WKUP5 wakeup pin
        constexpr uint32_t EWUP6 = (1U << 5);  ///< Enable WKUP6 wakeup pin
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wakeup line
    }

    /// CR4 Register bits
    namespace cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity
        constexpr uint32_t WP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity
        constexpr uint32_t WP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity
        constexpr uint32_t WP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity
        constexpr uint32_t WP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity
        constexpr uint32_t WP6 = (1U << 5);  ///< WKUP6 wakeup pin polarity
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT battery charging resistor selection
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag
        constexpr uint32_t WUFI = (1U << 15);  ///< Wakeup flag internal
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started
        constexpr uint32_t FLASH_RDY = (1U << 7);  ///< Flash ready flag
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Clear wakeup flag 6
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Clear wakeup flag 3
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1
    }

    /// PUCRA Register bits
    namespace pucra_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..15)
    }

    /// PDCRA Register bits
    namespace pdcra_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..15)
    }

    /// PUCRB Register bits
    namespace pucrb_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15)
    }

    /// PDCRB Register bits
    namespace pdcrb_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..15)
    }

    /// PUCRC Register bits
    namespace pucrc_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y (y=0..15)
    }

    /// PDCRC Register bits
    namespace pdcrc_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15)
    }

    /// PUCRD Register bits
    namespace pucrd_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15)
    }

    /// PDCRD Register bits
    namespace pdcrd_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15)
    }

    /// PUCRE Register bits
    namespace pucre_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port E pull-up bit y (y=0..15)
    }

    /// PDCRE Register bits
    namespace pdcre_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port E pull-down bit y (y=0..15)
    }

    /// PUCRF Register bits
    namespace pucrf_bits {
        constexpr uint32_t PU13 = (1U << 13);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15)
    }

    /// PDCRF Register bits
    namespace pdcrf_bits {
        constexpr uint32_t PD13 = (1U << 13);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15)
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t PLLSYSCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t IOPRSTR;  ///< Offset: 0x24 - I/O port reset register
        volatile uint32_t AHBRSTR;  ///< Offset: 0x28 - AHB peripheral reset register
        volatile uint32_t APBRSTR1;  ///< Offset: 0x2C - APB peripheral reset register 1
        volatile uint32_t APBRSTR2;  ///< Offset: 0x30 - APB peripheral reset register 2
        volatile uint32_t IOPENR;  ///< Offset: 0x34 - GPIO clock enable register
        volatile uint32_t AHBENR;  ///< Offset: 0x38 - AHB peripheral clock enable register
        volatile uint32_t APBENR1;  ///< Offset: 0x3C - APB peripheral clock enable register 1
        volatile uint32_t APBENR2;  ///< Offset: 0x40 - APB peripheral clock enable register 2
        volatile uint32_t IOPSMENR;  ///< Offset: 0x44 - GPIO in Sleep mode clock enable register
        volatile uint32_t AHBSMENR;  ///< Offset: 0x48 - AHB peripheral clock enable in Sleep mode register
        volatile uint32_t APBSMENR1;  ///< Offset: 0x4C - APB peripheral clock enable in Sleep mode register 1
        volatile uint32_t APBSMENR2;  ///< Offset: 0x50 - APB peripheral clock enable in Sleep mode register 2
        volatile uint32_t CCIPR;  ///< Offset: 0x54 - Peripherals independent clock configuration register
        volatile uint32_t CCIPR2;  ///< Offset: 0x58 - Peripherals independent clock configuration register 2
        volatile uint32_t BDCR;  ///< Offset: 0x5C - RTC domain control register
        volatile uint32_t CSR;  ///< Offset: 0x60 - Control/status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 always enable for peripheral kernels
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag
        constexpr uint32_t HSIDIV = (3 << 11);  ///< HSI16 clock division factor
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t HSICAL = (8 << 0);  ///< HSI16 clock calibration
        constexpr uint32_t HSITRIM = (7 << 8);  ///< HSI16 clock trimming
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (4 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (4 << 24);  ///< Microcontroller clock output
        constexpr uint32_t MCO2PRE = (4 << 20);  ///< MCO2PRE
        constexpr uint32_t MCO2SEL = (4 << 16);  ///< MCO2SEL
        constexpr uint32_t PPRE = (3 << 12);  ///< APB prescaler
        constexpr uint32_t HPRE = (4 << 8);  ///< AHB prescaler
        constexpr uint32_t SWS = (3 << 3);  ///< System clock switch status
        constexpr uint32_t SW = (3 << 0);  ///< System clock switch
    }

    /// PLLSYSCFGR Register bits
    namespace pllsyscfgr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< PLL input clock source
        constexpr uint32_t PLLM = (3 << 4);  ///< Division factor M of the PLL input clock divider
        constexpr uint32_t PLLN = (8 << 8);  ///< PLL frequency multiplication factor N
        constexpr uint32_t PLLPEN = (1U << 16);  ///< PLLPCLK clock output enable
        constexpr uint32_t PLLP = (5 << 17);  ///< PLL VCO division factor P for PLLPCLK clock output
        constexpr uint32_t PLLQEN = (1U << 24);  ///< PLLQCLK clock output enable
        constexpr uint32_t PLLQ = (3 << 25);  ///< PLL VCO division factor Q for PLLQCLK clock output
        constexpr uint32_t PLLREN = (1U << 28);  ///< PLLRCLK clock output enable
        constexpr uint32_t PLLR = (3 << 29);  ///< PLL VCO division factor R for PLLRCLK clock output
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable
        constexpr uint32_t PLLSYSRDYIE = (1U << 5);  ///< PLL ready interrupt enable
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag
        constexpr uint32_t PLLSYSRDYF = (1U << 5);  ///< PLL ready interrupt flag
        constexpr uint32_t CSSF = (1U << 8);  ///< Clock security system interrupt flag
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE Clock security system interrupt flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear
        constexpr uint32_t PLLSYSRDYC = (1U << 5);  ///< PLL ready interrupt clear
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear
    }

    /// IOPRSTR Register bits
    namespace ioprstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< GPIOARST
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< GPIOBRST
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< GPIOCRST
        constexpr uint32_t GPIODRST = (1U << 3);  ///< GPIODRST
        constexpr uint32_t GPIOERST = (1U << 4);  ///< GPIOERST
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< GPIOFRST
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t DMA1RST = (1U << 0);  ///< DMA1 reset
        constexpr uint32_t DMA2RST = (1U << 1);  ///< DMA1 reset
        constexpr uint32_t FLASHRST = (1U << 8);  ///< FLITF reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
    }

    /// APBRSTR1 Register bits
    namespace apbrstr1_bits {
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM4 timer reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 timer reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 timer reset
        constexpr uint32_t USART5RST = (1U << 8);  ///< USART5RST
        constexpr uint32_t USART6RST = (1U << 9);  ///< USART6RST
        constexpr uint32_t USBRST = (1U << 13);  ///< USBRST
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset
        constexpr uint32_t SPI3RST = (1U << 15);  ///< SPI3 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset
        constexpr uint32_t USART4RST = (1U << 19);  ///< USART4 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset
        constexpr uint32_t I2C3RST = (1U << 23);  ///< I2C3RST reset
        constexpr uint32_t DBGRST = (1U << 27);  ///< Debug support reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
    }

    /// APBRSTR2 Register bits
    namespace apbrstr2_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG, COMP and VREFBUF reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t TIM14RST = (1U << 15);  ///< TIM14 timer reset
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 timer reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset
        constexpr uint32_t ADCRST = (1U << 20);  ///< ADC reset
    }

    /// IOPENR Register bits
    namespace iopenr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode
        constexpr uint32_t GPIODEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< I/O port E clock enable during Sleep mode
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 clock enable
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 clock enable
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
    }

    /// APBENR1 Register bits
    namespace apbenr1_bits {
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 timer clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 timer clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 timer clock enable
        constexpr uint32_t USART5EN = (1U << 8);  ///< USART5EN
        constexpr uint32_t USART6EN = (1U << 9);  ///< USART6EN
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable
        constexpr uint32_t USBEN = (1U << 13);  ///< USBEN
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t SPI3EN = (1U << 15);  ///< SPI3 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable
        constexpr uint32_t USART4EN = (1U << 19);  ///< USART4 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 clock enable
        constexpr uint32_t DBGEN = (1U << 27);  ///< Debug support clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
    }

    /// APBENR2 Register bits
    namespace apbenr2_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable
        constexpr uint32_t TIM14EN = (1U << 15);  ///< TIM14 timer clock enable
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 timer clock enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM16 timer clock enable
        constexpr uint32_t ADCEN = (1U << 20);  ///< ADC clock enable
    }

    /// IOPSMENR Register bits
    namespace iopsmenr_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< I/O port E clock enable during Sleep mode
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode
    }

    /// AHBSMENR Register bits
    namespace ahbsmenr_bits {
        constexpr uint32_t DMA1SMEN = (1U << 0);  ///< DMA1 clock enable during Sleep mode
        constexpr uint32_t DMA2SMEN = (1U << 1);  ///< DMA2 clock enable during Sleep mode
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clock enable during Sleep mode
        constexpr uint32_t SRAMSMEN = (1U << 9);  ///< SRAM clock enable during Sleep mode
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clock enable during Sleep mode
    }

    /// APBSMENR1 Register bits
    namespace apbsmenr1_bits {
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clock enable during Sleep mode
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 timer clock enable during Sleep mode
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 timer clock enable during Sleep mode
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 timer clock enable during Sleep mode
        constexpr uint32_t USART5SMEN = (1U << 8);  ///< USART5 clock enable
        constexpr uint32_t USART6SMEN = (1U << 9);  ///< USART6 clock enable
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep mode
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< WWDG clock enable during Sleep mode
        constexpr uint32_t USBSMEN = (1U << 13);  ///< USB clock enable during Sleep mode
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode
        constexpr uint32_t SPI3SMEN = (1U << 15);  ///< SPI3 clock enable during Sleep mode
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep mode
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep mode
        constexpr uint32_t USART4SMEN = (1U << 19);  ///< USART4 clock enable during Sleep mode
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep mode
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode
        constexpr uint32_t I2C3SMEN = (1U << 23);  ///< I2C3 clock enable during Sleep mode
        constexpr uint32_t DBGSMEN = (1U << 27);  ///< Debug support clock enable during Sleep mode
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
    }

    /// APBSMENR2 Register bits
    namespace apbsmenr2_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable during Sleep mode
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clock enable during Sleep mode
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep mode
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t TIM14SMEN = (1U << 15);  ///< TIM14 timer clock enable during Sleep mode
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 timer clock enable during Sleep mode
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t ADCSMEN = (1U << 20);  ///< ADC clock enable during Sleep mode
    }

    /// CCIPR Register bits
    namespace ccipr_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 clock source selection
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 clock source selection
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection
        constexpr uint32_t I2S2SEL = (2 << 14);  ///< I2S1 clock source selection
        constexpr uint32_t TIM1SEL = (1U << 22);  ///< TIM1 clock source selection
        constexpr uint32_t TIM15SEL = (1U << 24);  ///< TIM15 clock source selection
        constexpr uint32_t ADCSEL = (2 << 30);  ///< ADCs clock source selection
    }

    /// CCIPR2 Register bits
    namespace ccipr2_bits {
        constexpr uint32_t I2S1SEL = (2 << 0);  ///< 2S1SEL
        constexpr uint32_t I2S2SEL = (2 << 2);  ///< I2S2SEL
        constexpr uint32_t USBSEL = (2 << 12);  ///< USBSEL
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure Detection
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t BDRST = (1U << 16);  ///< RTC domain software reset
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flags
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag
        constexpr uint32_t PWRRSTF = (1U << 27);  ///< BOR or POR/PDR flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_TR;  ///< Offset: 0x00 - RTC time register
        volatile uint32_t RTC_DR;  ///< Offset: 0x04 - RTC date register
        volatile uint32_t RTC_SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t RTC_ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t RTC_PRER;  ///< Offset: 0x10 - RTC prescaler register
        volatile uint32_t RTC_WUTR;  ///< Offset: 0x14 - RTC wakeup timer register
        volatile uint32_t RTC_CR;  ///< Offset: 0x18 - control register
        volatile uint32_t RTC_WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t RTC_CALR;  ///< Offset: 0x28 - RTC calibration register
        volatile uint32_t RTC_SHIFTR;  ///< Offset: 0x2C - RTC shift control register
        volatile uint32_t RTC_TSTR;  ///< Offset: 0x30 - RTC timestamp time register
        volatile uint32_t RTC_TSDR;  ///< Offset: 0x34 - RTC timestamp date register
        volatile uint32_t RTC_TSSSR;  ///< Offset: 0x38 - RTC timestamp sub second register
        volatile uint32_t RTC_ALRMAR;  ///< Offset: 0x40 - RTC alarm A register
        volatile uint32_t RTC_ALRMASSR;  ///< Offset: 0x44 - RTC alarm A sub second register
        volatile uint32_t RTC_ALRMBR;  ///< Offset: 0x48 - RTC alarm B register
        volatile uint32_t RTC_ALRMBSSR;  ///< Offset: 0x4C - RTC alarm B sub second register
        volatile uint32_t RTC_SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t RTC_MISR;  ///< Offset: 0x54 - RTC masked interrupt status register
        volatile uint32_t RTC_SCR;  ///< Offset: 0x5C - RTC status clear register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// RTC_TR Register bits
    namespace rtc_tr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_DR Register bits
    namespace rtc_dr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units ...
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
    }

    /// RTC_SSR Register bits
    namespace rtc_ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    }

    /// RTC_ICSR Register bits
    namespace rtc_icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag This bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag This bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to .
    }

    /// RTC_PRER Register bits
    namespace rtc_prer_bits {
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    }

    /// RTC_WUTR Register bits
    namespace rtc_wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register. When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.
    }

    /// RTC_CR Register bits
    namespace rtc_cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< ck_wut wakeup clock selection 10x: ck_spre (usually 1Hz) clock is selected 11x: ck_spre (usually 1Hz) clock is selected and 216is added to the WUT counter value
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Timestamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers Note: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable Note: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again.
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Timestamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
        constexpr uint32_t BKP = (1U << 18);  ///< Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection When COE = 1, this bit selects which signal is output on CALIB. These frequencies are valid for RTCCLK at 32.768kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity This bit is used to configure the polarity of TAMPALRM output.
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection These bits are used to select the flag to be routed to TAMPALRM output.
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable This bit enables the CALIB output
        constexpr uint32_t ITSE = (1U << 24);  ///< timestamp on internal event enable
        constexpr uint32_t TAMPTS = (1U << 25);  ///< Activate timestamp on tamper detection event TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid servicing 2 interrupts.
        constexpr uint32_t TAMPOE = (1U << 26);  ///< Tamper detection output enable on TAMPALRM
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM pull-up enable
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM output type
        constexpr uint32_t OUT2EN = (1U << 31);  ///< RTC_OUT2 output enable Setting this bit allows to remap the RTC outputs on RTC_OUT2 as follows: OUT2EN = 0: RTC output 2 disable If OSEL â  00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1 OUT2EN = 1: RTC output 2 enable If (OSEL â  00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2 If (OSELâ  00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.
    }

    /// RTC_WPR Register bits
    namespace rtc_wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to for a description of how to unlock RTC register write protection.
    }

    /// RTC_CALR Register bits
    namespace rtc_calr_bits {
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768Hz). This decreases the frequency of the calendar with a resolution of 0.9537ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1. Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 Ã CALP) - CALM. Refer to .
    }

    /// RTC_SHIFTR Register bits
    namespace rtc_shiftr_bits {
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    }

    /// RTC_TSTR Register bits
    namespace rtc_tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_TSDR Register bits
    namespace rtc_tsdr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
    }

    /// RTC_TSSSR Register bits
    namespace rtc_tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    }

    /// RTC_ALRMAR Register bits
    namespace rtc_alrmar_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
    }

    /// RTC_ALRMASSR Register bits
    namespace rtc_alrmassr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit 2:	SS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared. 3:	SS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared. ... 12:	SS[14:12] are don't care in alarm A comparison. SS[11:0] are compared. 13:	SS[14:13] are don't care in alarm A comparison. SS[12:0] are compared. 14:	SS[14] is don't care in alarm A comparison. SS[13:0] are compared. 15:	All 15 SS bits are compared and must match to activate alarm. The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. Note: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_ALRMBR Register bits
    namespace rtc_alrmbr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
    }

    /// RTC_ALRMBSSR Register bits
    namespace rtc_alrmbssr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_SR Register bits
    namespace rtc_sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
        constexpr uint32_t ALRBF = (1U << 1);  ///< Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
        constexpr uint32_t WUTF = (1U << 2);  ///< Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSF = (1U << 3);  ///< Timestamp flag This flag is set by hardware when a timestamp event occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVF = (1U << 4);  ///< Timestamp overflow flag This flag is set by hardware when a timestamp event occurs while TSF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSF = (1U << 5);  ///< Internal timestamp flag This flag is set by hardware when a timestamp on the internal event occurs.
    }

    /// RTC_MISR Register bits
    namespace rtc_misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< Alarm A masked flag This flag is set by hardware when the alarm A interrupt occurs.
        constexpr uint32_t ALRBMF = (1U << 1);  ///< Alarm B masked flag This flag is set by hardware when the alarm B interrupt occurs.
        constexpr uint32_t WUTMF = (1U << 2);  ///< Wakeup timer masked flag This flag is set by hardware when the wakeup timer interrupt occurs. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSMF = (1U << 3);  ///< Timestamp masked flag This flag is set by hardware when a timestamp interrupt occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVMF = (1U << 4);  ///< Timestamp overflow masked flag This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSMF = (1U << 5);  ///< Internal timestamp masked flag This flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
    }

    /// RTC_SCR Register bits
    namespace rtc_scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< Clear alarm A flag Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.
        constexpr uint32_t CALRBF = (1U << 1);  ///< Clear alarm B flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
        constexpr uint32_t CWUTF = (1U << 2);  ///< Clear wakeup timer flag Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
        constexpr uint32_t CTSF = (1U << 3);  ///< Clear timestamp flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
        constexpr uint32_t CTSOVF = (1U << 4);  ///< Clear timestamp overflow flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t CITSF = (1U << 5);  ///< Clear internal timestamp flag Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CR1;  ///< Offset: 0x00 - Clock phase Note: This bit should not be changed when...
        volatile uint32_t SPI_CR2;  ///< Offset: 0x04 - Rx buffer DMA enable When this bit is set, a DMA request...
        volatile uint32_t SPI_SR;  ///< Offset: 0x08 - Receive buffer not empty
        volatile uint32_t SPI_DR;  ///< Offset: 0x0C - Data register Data received or to be transmitted The...
        volatile uint32_t SPI_CRCPR;  ///< Offset: 0x10 - CRC polynomial register This register contains the...
        volatile uint32_t SPI_RXCRCR;  ///< Offset: 0x14 - Rx CRC register When CRC calculation is enabled, the...
        volatile uint32_t SPI_TXCRCR;  ///< Offset: 0x18 - Tx CRC register When CRC calculation is enabled, the...
        volatile uint32_t SPI_I2SCFGR;  ///< Offset: 0x1C - Channel length (number of bits per audio channel) The...
        volatile uint32_t SPI_I2SPR;  ///< Offset: 0x20 - I2S linear prescaler I2SDIV [7:0] = 0 or I2SDIV [7:0] =...
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// SPI_CR1 Register bits
    namespace spi_cr1_bits {
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase Note: This bit should not be changed when communication is ongoing. This bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode.
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity Note: This bit should not be changed when communication is ongoing. This bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode.
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection Note: This bit should not be changed when communication is ongoing. This bit is not used in I2S mode.
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control Note: These bits should not be changed when communication is ongoing. These bits are not used in I2S mode.
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable Note: When disabling the SPI, follow the procedure described in SPI on page1020. This bit is not used in I2S mode.
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format Note: 1. This bit should not be changed when communication is ongoing. 2. This bit is not used in I2S mode and SPI TI mode.
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored. Note: This bit is not used in I2S mode and SPI TI mode.
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit. Note: This bit is not used in I2S mode and SPI TI mode.
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only mode enabled. This bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted. Note: This bit is not used in I2S mode.
        constexpr uint32_t CRCL = (1U << 11);  ///< CRC length This bit is set and cleared by software to select the CRC length. Note: This bit should be written only when SPI is disabled (SPE = '0â) for correct operation. This bit is not used in I2S mode.
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< Transmit CRC next Note: This bit has to be written as soon as the last data is written in the SPIx_DR register. This bit is not used in I2S mode.
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable Note: This bit should be written only when SPI is disabled (SPE = '0â) for correct operation. This bit is not used in I2S mode.
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode This bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode. Note: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used. This bit is not used in I2S mode.
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable. This bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active. Note: This bit is not used in I2S mode.
    }

    /// SPI_CR2 Register bits
    namespace spi_cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable When this bit is set, a DMA request is generated whenever the RXNE flag is set.
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable When this bit is set, a DMA request is generated whenever the TXE flag is set.
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable Note: This bit is not used in I2S mode and SPI TI mode.
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management This bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer. It has no meaning if CPHA = â1â, or FRF = â1â. Note: 1. This bit must be written only when the SPI is disabled (SPE=0). 2. This bit is not used in I2S mode and SPI TI mode.
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format 1 SPI TI mode Note: This bit must be written only when the SPI is disabled (SPE=0). This bit is not used in I2S mode.
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I2S mode).
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size These bits configure the data length for SPI transfers. If software attempts to write one of the âNot usedâ values, they are forced to the value â0111â (8-bit) Note: These bits are not used in I2S mode.
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold This bit is used to set the threshold of the RXFIFO that triggers an RXNE event Note: This bit is not used in I2S mode.
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception This bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPIx_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPIx_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPIx_CR1 register). Note: Refer to if the CRCEN bit is set. This bit is not used in IÂ²S mode.
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission This bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPIx_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPIx_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPIx_CR1 register). Note: Refer to if the CRCEN bit is set. This bit is not used in IÂ²S mode.
    }

    /// SPI_SR Register bits
    namespace spi_sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side Note: This bit is not used in SPI mode. It has no significance in PCM mode.
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag This flag is set by hardware and reset by a software sequence. Refer to page1056 for the software sequence. Note: This bit is not used in SPI mode.
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag Note: This flag is set by hardware and cleared by software writing 0. This bit is not used in I2S mode.
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault This flag is set by hardware and reset by a software sequence. Refer to (MODF) on page1030 for the software sequence. Note: This bit is not used in I2S mode.
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag This flag is set by hardware and reset by a software sequence. Refer to page1056 for the software sequence.
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag This flag is set and cleared by hardware. Note: The BSY flag must be used with caution: refer to and .
        constexpr uint32_t FRE = (1U << 8);  ///< Frame format error This flag is used for SPI in TI slave mode and I2S slave mode. Refer to error flags and . This flag is set by hardware and reset when SPIx_SR is read by software.
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level These bits are set and cleared by hardware. Note: These bits are not used in IÂ²S mode and in SPI receive-only mode while CRC calculation is enabled.
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level These bits are set and cleared by hardware. Note: This bit is not used in I2S mode.
    }

    /// SPI_DR Register bits
    namespace spi_dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register Data received or to be transmitted The data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See ). Note: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used.
    }

    /// SPI_CRCPR Register bits
    namespace spi_crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register This register contains the polynomial for the CRC calculation. The CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.
    }

    /// SPI_RXCRCR Register bits
    namespace spi_rxcrcr_bits {
        constexpr uint32_t RXCRC = (16 << 0);  ///< Rx CRC register When CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPIx_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPIx_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPIx_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPIx_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY Flag is set could return an incorrect value. These bits are not used in I2S mode.
    }

    /// SPI_TXCRCR Register bits
    namespace spi_txcrcr_bits {
        constexpr uint32_t TXCRC = (16 << 0);  ///< Tx CRC register When CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPIx_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPIx_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPIx_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPIx_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY flag is set could return an incorrect value. These bits are not used in I2S mode.
    }

    /// SPI_I2SCFGR Register bits
    namespace spi_i2scfgr_bits {
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel) The bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in. Note: For correct operation, this bit should be configured when the I2S is disabled. It is not used in SPI mode.
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred Note: For correct operation, these bits should be configured when the I2S is disabled. They are not used in SPI mode.
        constexpr uint32_t CKPOL = (1U << 3);  ///< Inactive state clock polarity Note: For correct operation, this bit should be configured when the I2S is disabled. It is not used in SPI mode. The bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS signals.
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2S standard selection For more details on I2S standards, refer to Note: For correct operation, these bits should be configured when the I2S is disabled. They are not used in SPI mode.
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization Note: This bit has a meaning only if I2SSTD = 11 (PCM standard is used). It is not used in SPI mode.
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode Note: These bits should be configured when the I2S is disabled. They are not used in SPI mode.
        constexpr uint32_t I2SE = (1U << 10);  ///< I2S enable Note: This bit is not used in SPI mode.
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection Note: This bit should be configured when the SPI is disabled.
        constexpr uint32_t ASTRTEN = (1U << 12);  ///< Asynchronous start enable. When the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal. When the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and the appropriate level is detected on the WS signal. Note: The appropriate transition is a falling edge on WS signal when I2S Philips Standard is used, or a rising edge for other standards. The appropriate level is a low level on WS signal when I2S Philips Standard is used, or a high level for other standards. Please refer to for additional information.
    }

    /// SPI_I2SPR Register bits
    namespace spi_i2spr_bits {
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2S linear prescaler I2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values. Refer to . Note: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode. They are not used in SPI mode.
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler Refer to . Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode. It is not used in SPI mode.
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode. It is not used in SPI mode.
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - SYSCFG configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x18 - SYSCFG configuration register 1
        volatile uint32_t ITLINE0;  ///< Offset: 0x80 - interrupt line 0 status register
        volatile uint32_t ITLINE2;  ///< Offset: 0x88 - interrupt line 2 status register
        volatile uint32_t ITLINE3;  ///< Offset: 0x8C - interrupt line 3 status register
        volatile uint32_t ITLINE4;  ///< Offset: 0x90 - interrupt line 4 status register
        volatile uint32_t ITLINE5;  ///< Offset: 0x94 - interrupt line 5 status register
        volatile uint32_t ITLINE6;  ///< Offset: 0x98 - interrupt line 6 status register
        volatile uint32_t ITLINE7;  ///< Offset: 0x9C - interrupt line 7 status register
        volatile uint32_t ITLINE8;  ///< Offset: 0xA0 - interrupt line 8 status register
        volatile uint32_t ITLINE9;  ///< Offset: 0xA4 - interrupt line 9 status register
        volatile uint32_t ITLINE10;  ///< Offset: 0xA8 - interrupt line 10 status register
        volatile uint32_t ITLINE11;  ///< Offset: 0xAC - interrupt line 11 status register
        volatile uint32_t ITLINE12;  ///< Offset: 0xB0 - interrupt line 12 status register
        volatile uint32_t ITLINE13;  ///< Offset: 0xB4 - interrupt line 13 status register
        volatile uint32_t ITLINE14;  ///< Offset: 0xB8 - interrupt line 14 status register
        volatile uint32_t ITLINE16;  ///< Offset: 0xC0 - interrupt line 16 status register
        volatile uint32_t ITLINE17;  ///< Offset: 0xC4 - interrupt line 17 status register
        volatile uint32_t ITLINE18;  ///< Offset: 0xC8 - interrupt line 18 status register
        volatile uint32_t ITLINE19;  ///< Offset: 0xCC - interrupt line 19 status register
        volatile uint32_t ITLINE20;  ///< Offset: 0xD0 - interrupt line 20 status register
        volatile uint32_t ITLINE21;  ///< Offset: 0xD4 - interrupt line 21 status register
        volatile uint32_t ITLINE22;  ///< Offset: 0xD8 - interrupt line 22 status register
        volatile uint32_t ITLINE23;  ///< Offset: 0xDC - interrupt line 23 status register
        volatile uint32_t ITLINE24;  ///< Offset: 0xE0 - interrupt line 24 status register
        volatile uint32_t ITLINE25;  ///< Offset: 0xE4 - interrupt line 25 status register
        volatile uint32_t ITLINE26;  ///< Offset: 0xE8 - interrupt line 26 status register
        volatile uint32_t ITLINE27;  ///< Offset: 0xEC - interrupt line 27 status register
        volatile uint32_t ITLINE28;  ///< Offset: 0xF0 - interrupt line 28 status register
        volatile uint32_t ITLINE29;  ///< Offset: 0xF4 - interrupt line 29 status register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t I2C3_FMP = (1U << 24);  ///< I2C3_FMP
        constexpr uint32_t I2C_PA10_FMP = (1U << 23);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t I2C_PA9_FMP = (1U << 22);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t I2C2_FMP = (1U << 21);  ///< FM+ driving capability activation for I2C2
        constexpr uint32_t I2C1_FMP = (1U << 20);  ///< FM+ driving capability activation for I2C1
        constexpr uint32_t I2C_PB9_FMP = (4 << 19);  ///< I2C_PB9_FMP
        constexpr uint32_t I2C_PB8_FMP = (4 << 18);  ///< I2C_PB8_FMP
        constexpr uint32_t I2C_PB7_FMP = (4 << 17);  ///< I2C_PB7_FMP
        constexpr uint32_t I2C_PBx_FMP = (4 << 16);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t UCPD2_STROBE = (1U << 10);  ///< Strobe signal bit for UCPD2
        constexpr uint32_t UCPD1_STROBE = (1U << 9);  ///< Strobe signal bit for UCPD1
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
        constexpr uint32_t IR_MOD = (2 << 6);  ///< IR Modulation Envelope signal selection.
        constexpr uint32_t IR_POL = (1U << 5);  ///< IR output polarity selection
        constexpr uint32_t PA12_RMP = (1U << 4);  ///< PA11 and PA12 remapping bit.
        constexpr uint32_t PA11_RMP = (1U << 3);  ///< PA11_RMP
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t LOCKUP_LOCK = (1U << 0);  ///< Cortex-M0+ LOCKUP bit enable bit
        constexpr uint32_t SRAM_PARITY_LOCK = (1U << 1);  ///< SRAM parity lock bit
        constexpr uint32_t ECC_LOCK = (1U << 3);  ///< ECC error lock bit
        constexpr uint32_t SRAM_PEF = (1U << 8);  ///< SRAM parity error flag
    }

    /// ITLINE0 Register bits
    namespace itline0_bits {
        constexpr uint32_t WWDG = (1U << 0);  ///< Window watchdog interrupt pending flag
    }

    /// ITLINE2 Register bits
    namespace itline2_bits {
        constexpr uint32_t TAMP = (1U << 0);  ///< TAMP
        constexpr uint32_t RTC = (1U << 1);  ///< RTC
    }

    /// ITLINE3 Register bits
    namespace itline3_bits {
        constexpr uint32_t FLASH_ITF = (1U << 0);  ///< FLASH_ITF
        constexpr uint32_t FLASH_ECC = (1U << 1);  ///< FLASH_ECC
    }

    /// ITLINE4 Register bits
    namespace itline4_bits {
        constexpr uint32_t RCC = (1U << 0);  ///< RCC
    }

    /// ITLINE5 Register bits
    namespace itline5_bits {
        constexpr uint32_t EXTI0 = (1U << 0);  ///< EXTI0
        constexpr uint32_t EXTI1 = (1U << 1);  ///< EXTI1
    }

    /// ITLINE6 Register bits
    namespace itline6_bits {
        constexpr uint32_t EXTI2 = (1U << 0);  ///< EXTI2
        constexpr uint32_t EXTI3 = (1U << 1);  ///< EXTI3
    }

    /// ITLINE7 Register bits
    namespace itline7_bits {
        constexpr uint32_t EXTI4 = (1U << 0);  ///< EXTI4
        constexpr uint32_t EXTI5 = (1U << 1);  ///< EXTI5
        constexpr uint32_t EXTI6 = (1U << 2);  ///< EXTI6
        constexpr uint32_t EXTI7 = (1U << 3);  ///< EXTI7
        constexpr uint32_t EXTI8 = (1U << 4);  ///< EXTI8
        constexpr uint32_t EXTI9 = (1U << 5);  ///< EXTI9
        constexpr uint32_t EXTI10 = (1U << 6);  ///< EXTI10
        constexpr uint32_t EXTI11 = (1U << 7);  ///< EXTI11
        constexpr uint32_t EXTI12 = (1U << 8);  ///< EXTI12
        constexpr uint32_t EXTI13 = (1U << 9);  ///< EXTI13
        constexpr uint32_t EXTI14 = (1U << 10);  ///< EXTI14
        constexpr uint32_t EXTI15 = (1U << 11);  ///< EXTI15
    }

    /// ITLINE8 Register bits
    namespace itline8_bits {
        constexpr uint32_t USB = (1U << 2);  ///< USB
    }

    /// ITLINE9 Register bits
    namespace itline9_bits {
        constexpr uint32_t DMA1_CH1 = (1U << 0);  ///< DMA1_CH1
    }

    /// ITLINE10 Register bits
    namespace itline10_bits {
        constexpr uint32_t DMA1_CH2 = (1U << 0);  ///< DMA1_CH1
        constexpr uint32_t DMA1_CH3 = (1U << 1);  ///< DMA1_CH3
    }

    /// ITLINE11 Register bits
    namespace itline11_bits {
        constexpr uint32_t DMAMUX = (1U << 0);  ///< DMAMUX
        constexpr uint32_t DMA1_CH4 = (1U << 1);  ///< DMA1_CH4
        constexpr uint32_t DMA1_CH5 = (1U << 2);  ///< DMA1_CH5
        constexpr uint32_t DMA1_CH6 = (1U << 3);  ///< DMA1_CH6
        constexpr uint32_t DMA1_CH7 = (1U << 4);  ///< DMA1_CH7
        constexpr uint32_t DMA2_CH1 = (1U << 5);  ///< DMA2_CH1
        constexpr uint32_t DMA2_CH2 = (1U << 6);  ///< DMA2_CH2
        constexpr uint32_t DMA2_CH3 = (1U << 7);  ///< DMA2_CH3
        constexpr uint32_t DMA2_CH4 = (1U << 8);  ///< DMA2_CH4
        constexpr uint32_t DMA2_CH5 = (1U << 9);  ///< DMA2_CH5
    }

    /// ITLINE12 Register bits
    namespace itline12_bits {
        constexpr uint32_t ADC = (1U << 0);  ///< ADC
    }

    /// ITLINE13 Register bits
    namespace itline13_bits {
        constexpr uint32_t TIM1_CCU = (1U << 0);  ///< TIM1_CCU
        constexpr uint32_t TIM1_TRG = (1U << 1);  ///< TIM1_TRG
        constexpr uint32_t TIM1_UPD = (1U << 2);  ///< TIM1_UPD
        constexpr uint32_t TIM1_BRK = (1U << 3);  ///< TIM1_BRK
    }

    /// ITLINE14 Register bits
    namespace itline14_bits {
        constexpr uint32_t TIM1_CC = (1U << 0);  ///< TIM1_CC
    }

    /// ITLINE16 Register bits
    namespace itline16_bits {
        constexpr uint32_t TIM3 = (1U << 0);  ///< TIM3
        constexpr uint32_t TIM4 = (1U << 1);  ///< TIM4
    }

    /// ITLINE17 Register bits
    namespace itline17_bits {
        constexpr uint32_t TIM6 = (1U << 0);  ///< TIM6
    }

    /// ITLINE18 Register bits
    namespace itline18_bits {
        constexpr uint32_t TIM7 = (1U << 0);  ///< TIM7
    }

    /// ITLINE19 Register bits
    namespace itline19_bits {
        constexpr uint32_t TIM14 = (1U << 0);  ///< TIM14
    }

    /// ITLINE20 Register bits
    namespace itline20_bits {
        constexpr uint32_t TIM15 = (1U << 0);  ///< TIM15
    }

    /// ITLINE21 Register bits
    namespace itline21_bits {
        constexpr uint32_t TIM16 = (1U << 0);  ///< TIM16
    }

    /// ITLINE22 Register bits
    namespace itline22_bits {
        constexpr uint32_t TIM17 = (1U << 0);  ///< TIM17
    }

    /// ITLINE23 Register bits
    namespace itline23_bits {
        constexpr uint32_t I2C1 = (1U << 0);  ///< I2C1
    }

    /// ITLINE24 Register bits
    namespace itline24_bits {
        constexpr uint32_t I2C2 = (1U << 0);  ///< I2C2
        constexpr uint32_t I2C3 = (1U << 1);  ///< I2C3
    }

    /// ITLINE25 Register bits
    namespace itline25_bits {
        constexpr uint32_t SPI1 = (1U << 0);  ///< SPI1
    }

    /// ITLINE26 Register bits
    namespace itline26_bits {
        constexpr uint32_t SPI2 = (1U << 0);  ///< SPI2
        constexpr uint32_t SPI3 = (1U << 14);  ///< SPI3
    }

    /// ITLINE27 Register bits
    namespace itline27_bits {
        constexpr uint32_t USART1 = (1U << 0);  ///< USART1
    }

    /// ITLINE28 Register bits
    namespace itline28_bits {
        constexpr uint32_t USART2 = (1U << 0);  ///< USART2
    }

    /// ITLINE29 Register bits
    namespace itline29_bits {
        constexpr uint32_t USART3 = (1U << 0);  ///< USART3
        constexpr uint32_t USART4 = (1U << 1);  ///< USART4
        constexpr uint32_t USART5 = (1U << 3);  ///< USART5
        constexpr uint32_t USART6 = (1U << 4);  ///< USART6
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x4000B000;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t TAMP_CR1;  ///< Offset: 0x00 - TAMP control register 1
        volatile uint32_t TAMP_CR2;  ///< Offset: 0x04 - TAMP control register 2
        volatile uint32_t TAMP_FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t TAMP_IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t TAMP_SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t TAMP_MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t TAMP_SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t TAMP_BKP0R;  ///< Offset: 0x100 - TAMP backup 0 register
        volatile uint32_t TAMP_BKP1R;  ///< Offset: 0x104 - TAMP backup 1 register
        volatile uint32_t TAMP_BKP2R;  ///< Offset: 0x108 - TAMP backup 2 register
        volatile uint32_t TAMP_BKP3R;  ///< Offset: 0x10C - TAMP backup 3 register
        volatile uint32_t TAMP_BKP4R;  ///< Offset: 0x110 - TAMP backup 4 register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// TAMP_CR1 Register bits
    namespace tamp_cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper detection on TAMP_IN1 enable
        constexpr uint32_t TAMP2E = (1U << 1);  ///< Tamper detection on TAMP_IN2 enable
        constexpr uint32_t TAMP3E = (1U << 2);  ///< Tamper detection on TAMP_IN3 enable
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< Internal tamper 3 enable: LSE monitoring
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< Internal tamper 4 enable: HSE monitoring
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< Internal tamper 5 enable: RTC calendar overflow
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< Internal tamper 6 enable: ST manufacturer readout
    }

    /// TAMP_CR2 Register bits
    namespace tamp_cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< Tamper 1 no erase
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< Tamper 2 no erase
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< Tamper 3 no erase
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< Tamper 1 mask The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< Tamper 2 mask The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< Tamper 3 mask The tamper 3 interrupt must not be enabled when TAMP3MSK is set.
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< Active level for tamper 1 input (active mode disabled) If TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< Active level for tamper 2 input (active mode disabled) If TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< Active level for tamper 3 input (active mode disabled) If TAMPFLT = 00 Tamper 3 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 3 input falling edge and low level triggers a tamper detection event.
    }

    /// TAMP_FLTCR Register bits
    namespace tamp_fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< Tamper sampling frequency Determines the frequency at which each of the TAMP_INx inputs are sampled.
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMP_INx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMP_INx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMP_INx pull-up disable This bit determines if each of the TAMPx pins are precharged before each sample.
    }

    /// TAMP_IER Register bits
    namespace tamp_ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< Tamper 2 interrupt enable
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< Tamper 3 interrupt enable
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< Internal tamper 3 interrupt enable: LSE monitoring
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< Internal tamper 4 interrupt enable: HSE monitoring
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< Internal tamper 5 interrupt enable: RTC calendar overflow
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< Internal tamper 6 interrupt enable: ST manufacturer readout
    }

    /// TAMP_SR Register bits
    namespace tamp_sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP3 input.
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< LSE monitoring tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< HSE monitoring tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 4.
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< RTC calendar overflow tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ST manufacturer readout tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
    }

    /// TAMP_MISR Register bits
    namespace tamp_misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1 interrupt masked flag This flag is set by hardware when the tamper 1 interrupt is raised.
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2 interrupt masked flag This flag is set by hardware when the tamper 2 interrupt is raised.
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3 interrupt masked flag This flag is set by hardware when the tamper 3 interrupt is raised.
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< LSE monitoring tamper interrupt masked flag This flag is set by hardware when the internal tamper 3 interrupt is raised.
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< HSE monitoring tamper interrupt masked flag This flag is set by hardware when the internal tamper 4 interrupt is raised.
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< RTC calendar overflow tamper interrupt masked flag This flag is set by hardware when the internal tamper 5 interrupt is raised.
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ST manufacturer readout tamper interrupt masked flag This flag is set by hardware when the internal tamper 6 interrupt is raised.
    }

    /// TAMP_SCR Register bits
    namespace tamp_scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< Clear TAMP1 detection flag Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< Clear TAMP2 detection flag Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< Clear TAMP3 detection flag Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< Clear ITAMP3 detection flag Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< Clear ITAMP4 detection flag Writing 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< Clear ITAMP5 detection flag Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< Clear ITAMP6 detection flag Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
    }

    /// TAMP_BKP0R Register bits
    namespace tamp_bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP1R Register bits
    namespace tamp_bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP2R Register bits
    namespace tamp_bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP3R Register bits
    namespace tamp_bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP4R Register bits
    namespace tamp_bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIM1_CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t TIM1_CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t TIM1_SMCR;  ///< Offset: 0x08 - slave mode control register
        volatile uint32_t TIM1_DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t TIM1_SR;  ///< Offset: 0x10 - status register
        volatile uint32_t TIM1_EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register 1 (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (output mode)
        volatile uint32_t CCMR2_Output;  ///< Offset: 0x1C - capture/compare mode register 2 (output mode)
        volatile uint32_t CCMR2_Input;  ///< Offset: 0x1C - capture/compare mode register 2 (output mode)
        volatile uint32_t TIM1_CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t TIM1_CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t TIM1_PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t TIM1_ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t TIM1_RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t TIM1_CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t TIM1_CCR2;  ///< Offset: 0x38 - capture/compare register 2
        volatile uint32_t TIM1_CCR3;  ///< Offset: 0x3C - capture/compare register 3
        volatile uint32_t TIM1_CCR4;  ///< Offset: 0x40 - capture/compare register 4
        volatile uint32_t TIM1_BDTR;  ///< Offset: 0x44 - break and dead-time register
        volatile uint32_t TIM1_DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t TIM1_DMAR;  ///< Offset: 0x4C - DMA address for full transfer
        volatile uint32_t CCMR3_Output;  ///< Offset: 0x54 - capture/compare mode register 2 (output mode)
        volatile uint32_t TIM1_CCR5;  ///< Offset: 0x58 - capture/compare register 4
        volatile uint32_t TIM1_CCR6;  ///< Offset: 0x5C - capture/compare register 6
        volatile uint32_t TIM1_AF1;  ///< Offset: 0x60 - TIM1 alternate function option register 1
        volatile uint32_t TIM1_AF2;  ///< Offset: 0x64 - TIM1 alternate function option register 2
        volatile uint32_t TIM1_TISEL;  ///< Offset: 0x68 - TIM1 timer input selection register
    };

    /// Peripheral instances
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);

    // Bit definitions
    /// TIM1_CR1 Register bits
    namespace tim1_cr1_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.
        constexpr uint32_t URS = (1U << 2);  ///< Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller
        constexpr uint32_t OPM = (1U << 3);  ///< One pulse mode
        constexpr uint32_t DIR = (1U << 4);  ///< Direction Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.
        constexpr uint32_t CMS = (2 << 5);  ///< Center-aligned mode selection Note: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (ETR, TIx): Note: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT.
        constexpr uint32_t UIFREMAP = (1U << 11);  ///< UIF status bit remapping
    }

    /// TIM1_CR2 Register bits
    namespace tim1_cr2_bits {
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control Note: This bit acts only on channels that have a complementary output.
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection Note: This bit acts only on channels that have a complementary output.
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t MMS = (3 << 4);  ///< Master mode selection These bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1 selection
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t OIS2 = (1U << 10);  ///< Output Idle state 2 (OC2 output) Refer to OIS1 bit
        constexpr uint32_t OIS2N = (1U << 11);  ///< Output Idle state 2 (OC2N output) Refer to OIS1N bit
        constexpr uint32_t OIS3 = (1U << 12);  ///< Output Idle state 3 (OC3 output) Refer to OIS1 bit
        constexpr uint32_t OIS3N = (1U << 13);  ///< Output Idle state 3 (OC3N output) Refer to OIS1N bit
        constexpr uint32_t OIS4 = (1U << 14);  ///< Output Idle state 4 (OC4 output) Refer to OIS1 bit
        constexpr uint32_t OIS5 = (1U << 16);  ///< Output Idle state 5 (OC5 output) Refer to OIS1 bit
        constexpr uint32_t OIS6 = (1U << 18);  ///< Output Idle state 6 (OC6 output) Refer to OIS1 bit
        constexpr uint32_t MMS2 = (4 << 20);  ///< Master mode selection 2 These bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows: Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
    }

    /// TIM1_SMCR Register bits
    namespace tim1_smcr_bits {
        constexpr uint32_t SMS1 = (3 << 0);  ///< Slave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.
        constexpr uint32_t OCCS = (1U << 3);  ///< OCREF clear selection This bit is used to select the OCREF clear source.
        constexpr uint32_t TS1 = (3 << 4);  ///< Trigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.
        constexpr uint32_t MSM = (1U << 7);  ///< Master/slave mode
        constexpr uint32_t ETF = (4 << 8);  ///< External trigger filter This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
        constexpr uint32_t ETPS = (2 << 12);  ///< External trigger prescaler External trigger signal ETRP frequency must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
        constexpr uint32_t ECE = (1U << 14);  ///< External clock enable This bit enables External clock mode 2. Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111). If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.
        constexpr uint32_t ETP = (1U << 15);  ///< External trigger polarity This bit selects whether ETR or ETR is used for trigger operations
        constexpr uint32_t SMS2 = (1U << 16);  ///< Slave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.
        constexpr uint32_t TS2 = (2 << 20);  ///< Trigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.
    }

    /// TIM1_DIER Register bits
    namespace tim1_dier_bits {
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t CC2IE = (1U << 2);  ///< Capture/Compare 2 interrupt enable
        constexpr uint32_t CC3IE = (1U << 3);  ///< Capture/Compare 3 interrupt enable
        constexpr uint32_t CC4IE = (1U << 4);  ///< Capture/Compare 4 interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t TIE = (1U << 6);  ///< Trigger interrupt enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t CC2DE = (1U << 10);  ///< Capture/Compare 2 DMA request enable
        constexpr uint32_t CC3DE = (1U << 11);  ///< Capture/Compare 3 DMA request enable
        constexpr uint32_t CC4DE = (1U << 12);  ///< Capture/Compare 4 DMA request enable
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t TDE = (1U << 14);  ///< Trigger DMA request enable
    }

    /// TIM1_SR Register bits
    namespace tim1_sr_bits {
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by a trigger event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register.
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
        constexpr uint32_t CC2IF = (1U << 2);  ///< Capture/Compare 2 interrupt flag Refer to CC1IF description
        constexpr uint32_t CC3IF = (1U << 3);  ///< Capture/Compare 3 interrupt flag Refer to CC1IF description
        constexpr uint32_t CC4IF = (1U << 4);  ///< Capture/Compare 4 interrupt flag Refer to CC1IF description
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.
        constexpr uint32_t TIF = (1U << 6);  ///< Trigger interrupt flag This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
        constexpr uint32_t B2IF = (1U << 8);  ///< Break 2 interrupt flag This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0â.
        constexpr uint32_t CC2OF = (1U << 10);  ///< Capture/Compare 2 overcapture flag Refer to CC1OF description
        constexpr uint32_t CC3OF = (1U << 11);  ///< Capture/Compare 3 overcapture flag Refer to CC1OF description
        constexpr uint32_t CC4OF = (1U << 12);  ///< Capture/Compare 4 overcapture flag Refer to CC1OF description
        constexpr uint32_t SBIF = (1U << 13);  ///< System Break interrupt flag This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active. This flag must be reset to re-start PWM operation.
        constexpr uint32_t CC5IF = (1U << 16);  ///< Compare 5 interrupt flag Refer to CC1IF description (Note: Channel 5 can only be configured as output)
        constexpr uint32_t CC6IF = (1U << 17);  ///< Compare 6 interrupt flag Refer to CC1IF description (Note: Channel 6 can only be configured as output)
    }

    /// TIM1_EGR Register bits
    namespace tim1_egr_bits {
        constexpr uint32_t UG = (1U << 0);  ///< Update generation This bit can be set by software, it is automatically cleared by hardware.
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
        constexpr uint32_t CC2G = (1U << 2);  ///< Capture/Compare 2 generation Refer to CC1G description
        constexpr uint32_t CC3G = (1U << 3);  ///< Capture/Compare 3 generation Refer to CC1G description
        constexpr uint32_t CC4G = (1U << 4);  ///< Capture/Compare 4 generation Refer to CC1G description
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware Note: This bit acts only on channels having a complementary output.
        constexpr uint32_t TG = (1U << 6);  ///< Trigger generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
        constexpr uint32_t BG = (1U << 7);  ///< Break generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
        constexpr uint32_t B2G = (1U << 8);  ///< Break 2 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = '0â in TIMx_CCER).
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
        constexpr uint32_t OC1M1 = (3 << 4);  ///< Output Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from âfrozenâ mode to âPWMâ mode. Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated. Note: The OC1M[3] bit is not contiguous, located in bit 16.
        constexpr uint32_t OC1CE = (1U << 7);  ///< Output Compare 1 clear enable
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = '0â in TIMx_CCER).
        constexpr uint32_t OC2FE = (1U << 10);  ///< Output Compare 2 fast enable Refer to OC1FE description.
        constexpr uint32_t OC2PE = (1U << 11);  ///< Output Compare 2 preload enable Refer to OC1PE description.
        constexpr uint32_t OC2M1 = (3 << 12);  ///< Output Compare 2 mode Refer to OC1M[3:0] description.
        constexpr uint32_t OC2CE = (1U << 15);  ///< Output Compare 2 clear enable Refer to OC1CE description.
        constexpr uint32_t OC1M2 = (1U << 16);  ///< Output Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from âfrozenâ mode to âPWMâ mode. Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated. Note: The OC1M[3] bit is not contiguous, located in bit 16.
        constexpr uint32_t OC2M2 = (1U << 24);  ///< Output Compare 2 mode Refer to OC1M[3:0] description.
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = '0â in TIMx_CCER).
        constexpr uint32_t IC1PSC = (2 << 2);  ///< Input capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=â0â (TIMx_CCER register).
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
        constexpr uint32_t CC2S = (2 << 8);  ///< Capture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = '0â in TIMx_CCER).
        constexpr uint32_t IC2PSC = (2 << 10);  ///< Input capture 2 prescaler Refer to IC1PSC[1:0] description.
        constexpr uint32_t IC2F = (4 << 12);  ///< Input capture 2 filter Refer to IC1F[3:0] description.
    }

    /// CCMR2_Output Register bits
    namespace ccmr2_output_bits {
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/Compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = '0â in TIMx_CCER).
        constexpr uint32_t OC3FE = (1U << 2);  ///< Output compare 3 fast enable Refer to OC1FE description.
        constexpr uint32_t OC3PE = (1U << 3);  ///< Output compare 3 preload enable Refer to OC1PE description.
        constexpr uint32_t OC3M1 = (3 << 4);  ///< Output compare 3 mode Refer to OC1M[3:0] description.
        constexpr uint32_t OC3CE = (1U << 7);  ///< Output compare 3 clear enable Refer to OC1CE description.
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = '0â in TIMx_CCER).
        constexpr uint32_t OC4FE = (1U << 10);  ///< Output compare 4 fast enable Refer to OC1FE description.
        constexpr uint32_t OC4PE = (1U << 11);  ///< Output compare 4 preload enable Refer to OC1PE description.
        constexpr uint32_t OC4M1 = (3 << 12);  ///< Output compare 4 mode Refer to OC3M[3:0] description.
        constexpr uint32_t OC4CE = (1U << 15);  ///< Output compare 4 clear enable Refer to OC1CE description.
        constexpr uint32_t OC3M2 = (1U << 16);  ///< Output compare 3 mode Refer to OC1M[3:0] description.
        constexpr uint32_t OC4M2 = (1U << 24);  ///< Output compare 4 mode Refer to OC3M[3:0] description.
    }

    /// CCMR2_Input Register bits
    namespace ccmr2_input_bits {
        constexpr uint32_t CC3S = (2 << 0);  ///< Capture/compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = '0â in TIMx_CCER).
        constexpr uint32_t IC3PSC = (2 << 2);  ///< Input capture 3 prescaler Refer to IC1PSC[1:0] description.
        constexpr uint32_t IC3F = (4 << 4);  ///< Input capture 3 filter Refer to IC1F[3:0] description.
        constexpr uint32_t CC4S = (2 << 8);  ///< Capture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = '0â in TIMx_CCER).
        constexpr uint32_t IC4PSC = (2 << 10);  ///< Input capture 4 prescaler Refer to IC1PSC[1:0] description.
        constexpr uint32_t IC4F = (4 << 12);  ///< Input capture 4 filter Refer to IC1F[3:0] description.
    }

    /// TIM1_CCER Register bits
    namespace tim1_ccer_bits {
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details. Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0:	The configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (channel configured as output). On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        constexpr uint32_t CC2E = (1U << 4);  ///< Capture/Compare 2 output enable Refer to CC1E description
        constexpr uint32_t CC2P = (1U << 5);  ///< Capture/Compare 2 output polarity Refer to CC1P description
        constexpr uint32_t CC2NE = (1U << 6);  ///< Capture/Compare 2 complementary output enable Refer to CC1NE description
        constexpr uint32_t CC2NP = (1U << 7);  ///< Capture/Compare 2 complementary output polarity Refer to CC1NP description
        constexpr uint32_t CC3E = (1U << 8);  ///< Capture/Compare 3 output enable Refer to CC1E description
        constexpr uint32_t CC3P = (1U << 9);  ///< Capture/Compare 3 output polarity Refer to CC1P description
        constexpr uint32_t CC3NE = (1U << 10);  ///< Capture/Compare 3 complementary output enable Refer to CC1NE description
        constexpr uint32_t CC3NP = (1U << 11);  ///< Capture/Compare 3 complementary output polarity Refer to CC1NP description
        constexpr uint32_t CC4E = (1U << 12);  ///< Capture/Compare 4 output enable Refer to CC1E description
        constexpr uint32_t CC4P = (1U << 13);  ///< Capture/Compare 4 output polarity Refer to CC1P description
        constexpr uint32_t CC4NP = (1U << 15);  ///< Capture/Compare 4 complementary output polarity Refer to CC1NP description
        constexpr uint32_t CC5E = (1U << 16);  ///< Capture/Compare 5 output enable Refer to CC1E description
        constexpr uint32_t CC5P = (1U << 17);  ///< Capture/Compare 5 output polarity Refer to CC1P description
        constexpr uint32_t CC6E = (1U << 20);  ///< Capture/Compare 6 output enable Refer to CC1E description
        constexpr uint32_t CC6P = (1U << 21);  ///< Capture/Compare 6 output polarity Refer to CC1P description
    }

    /// TIM1_CNT Register bits
    namespace tim1_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value
        constexpr uint32_t UIFCPY = (1U << 31);  ///< UIF copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.
    }

    /// TIM1_PSC Register bits
    namespace tim1_psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value The counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1). PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in âreset modeâ).
    }

    /// TIM1_ARR Register bits
    namespace tim1_arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value ARR is the value to be loaded in the actual auto-reload register. Refer to the for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null.
    }

    /// TIM1_RCR Register bits
    namespace tim1_rcr_bits {
        constexpr uint32_t REP = (16 << 0);  ///< Repetition counter value
    }

    /// TIM1_CCR1 Register bits
    namespace tim1_ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// TIM1_CCR2 Register bits
    namespace tim1_ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/Compare 2 value
    }

    /// TIM1_CCR3 Register bits
    namespace tim1_ccr3_bits {
        constexpr uint32_t CCR3 = (16 << 0);  ///< Capture/Compare value
    }

    /// TIM1_CCR4 Register bits
    namespace tim1_ccr4_bits {
        constexpr uint32_t CCR4 = (16 << 0);  ///< Capture/Compare value
    }

    /// TIM1_BDTR Register bits
    namespace tim1_bdtr_bits {
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tDTG with tDTG=tDTS. DTG[7:5]=10x => DT=(64+DTG[5:0])xtDTG with tDTG=2xtDTS. DTG[7:5]=110 => DT=(32+DTG[4:0])xtDTG with tDTG=8xtDTS. DTG[7:5]=111 => DT=(32+DTG[4:0])xtDTG with tDTG=16xtDTS. Example if tDTS=125Â ns (8Â MHz), dead-time possible values are: 0 to 15875Â ns by 125Â ns steps, 16Â Î¼s to 31750Â nsÂ  by 250Â ns steps, 32Â Î¼s to 63Â Î¼s by 1Â Î¼s steps, 64Â Î¼s to 126Â Î¼s by 2Â Î¼s steps Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs. See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable This bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per ). Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit. See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).
        constexpr uint32_t BKF = (4 << 16);  ///< Break filter This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t BK2F = (4 << 20);  ///< Break 2 filter This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t BK2E = (1U << 24);  ///< Break 2 enable Note: The BRK2 must only be used with OSSR = OSSI = 1. Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        constexpr uint32_t BK2P = (1U << 25);  ///< Break 2 polarity Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        constexpr uint32_t BKDSRM = (1U << 26);  ///< Break Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        constexpr uint32_t BK2DSRM = (1U << 27);  ///< Break2 Disarm Refer to BKDSRM description
        constexpr uint32_t BKBID = (1U << 28);  ///< Break Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        constexpr uint32_t BK2BID = (1U << 29);  ///< Break2 bidirectional Refer to BKBID description
    }

    /// TIM1_DCR Register bits
    namespace tim1_dcr_bits {
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ...
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below). ... Example: Let us consider the following transfer: DBL = 7 bytes & DBA = TIMx_CR1. If DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation: (TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA According to the configuration of the DMA Data Size, several cases may occur: If the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers. If the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.
    }

    /// TIM1_DMAR Register bits
    namespace tim1_dmar_bits {
        constexpr uint32_t DMAB = (32 << 0);  ///< DMA register for burst accesses 	A read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4 	where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).
    }

    /// CCMR3_Output Register bits
    namespace ccmr3_output_bits {
        constexpr uint32_t OC6M_bit3 = (1U << 24);  ///< Output Compare 6 mode bit 3
        constexpr uint32_t OC5M_bit3 = (1U << 16);  ///< Output Compare 5 mode bit 3
        constexpr uint32_t OC6CE = (1U << 15);  ///< Output compare 6 clear enable
        constexpr uint32_t OC6M = (3 << 12);  ///< Output compare 6 mode
        constexpr uint32_t OC6PE = (1U << 11);  ///< Output compare 6 preload enable
        constexpr uint32_t OC6FE = (1U << 10);  ///< Output compare 6 fast enable
        constexpr uint32_t OC5CE = (1U << 7);  ///< Output compare 5 clear enable
        constexpr uint32_t OC5M = (3 << 4);  ///< Output compare 5 mode
        constexpr uint32_t OC5PE = (1U << 3);  ///< Output compare 5 preload enable
        constexpr uint32_t OC5FE = (1U << 2);  ///< Output compare 5 fast enable
    }

    /// TIM1_CCR5 Register bits
    namespace tim1_ccr5_bits {
        constexpr uint32_t CCR5 = (16 << 0);  ///< Capture/Compare 5 value CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output.
        constexpr uint32_t GC5C1 = (1U << 29);  ///< Group Channel 5 and Channel 1 Distortion on Channel 1 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1). Note: it is also possible to apply this distortion on combined PWM signals.
        constexpr uint32_t GC5C2 = (1U << 30);  ///< Group Channel 5 and Channel 2 Distortion on Channel 2 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1). Note: it is also possible to apply this distortion on combined PWM signals.
        constexpr uint32_t GC5C3 = (1U << 31);  ///< Group Channel 5 and Channel 3 Distortion on Channel 3 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2). Note: it is also possible to apply this distortion on combined PWM signals.
    }

    /// TIM1_CCR6 Register bits
    namespace tim1_ccr6_bits {
        constexpr uint32_t CCR6 = (16 << 0);  ///< Capture/Compare value
    }

    /// TIM1_AF1 Register bits
    namespace tim1_af1_bits {
        constexpr uint32_t BKINE = (1U << 0);  ///< BRK BKIN input enable This bit enables the BKIN alternate function input for the timerâs BRK input. BKIN input is 'ORedâ with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t BKINP = (1U << 9);  ///< BRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t ETRSEL = (4 << 14);  ///< ETR source selection These bits select the ETR input source. Others: Reserved Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    }

    /// TIM1_AF2 Register bits
    namespace tim1_af2_bits {
        constexpr uint32_t BK2INE = (1U << 0);  ///< BRK2 BKIN input enable This bit enables the BKIN2 alternate function input for the timerâs BRK2 input. BKIN2 input is 'ORedâ with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        constexpr uint32_t BK2INP = (1U << 9);  ///< BRK2 BKIN2 input polarity This bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    }

    /// TIM1_TISEL Register bits
    namespace tim1_tisel_bits {
        constexpr uint32_t TI1SEL = (4 << 0);  ///< selects TI1[0] to TI1[15] input Others: Reserved
        constexpr uint32_t TI2SEL = (4 << 8);  ///< selects TI2[0] to TI2[15] input Others: Reserved
        constexpr uint32_t TI3SEL = (4 << 16);  ///< selects TI3[0] to TI3[15] input Others: Reserved
        constexpr uint32_t TI4SEL = (4 << 24);  ///< selects TI4[0] to TI4[15] input Others: Reserved
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1_FIFO_ENABLED;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR1_FIFO_DISABLED;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR_FIFO_ENABLED;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ISR_FIFO_DISABLED;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - Prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);

    // Bit definitions
    /// CR1_FIFO_ENABLED Register bits
    namespace cr1_fifo_enabled_bits {
        constexpr uint32_t UE = (1U << 0);  ///< USART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable This bit enables the receiver. It is set and cleared by software.
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0â followed by '1â) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1â. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFIFO not empty interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if MÂ =Â 1; 8th bit if MÂ =Â 0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t M0 = (1U << 12);  ///< Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable This bit is set and cleared by software.
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t M1 = (1U << 28);  ///< Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00â: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01â: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10â: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable This bit is set and cleared by software.
    }

    /// CR1_FIFO_DISABLED Register bits
    namespace cr1_fifo_disabled_bits {
        constexpr uint32_t UE = (1U << 0);  ///< USART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable This bit enables the receiver. It is set and cleared by software.
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0â followed by '1â) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1â. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXNEIE = (1U << 5);  ///< Receive data register not empty This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXEIE = (1U << 7);  ///< Transmit data register empty This bit is set and cleared by software.
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if MÂ =Â 1; 8th bit if MÂ =Â 0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t M0 = (1U << 12);  ///< Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable This bit is set and cleared by software.
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t M1 = (1U << 28);  ///< Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00â: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01â: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10â: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t SLVEN = (1U << 0);  ///< Synchronous Slave mode enable When the SLVEN bit is set, the synchronous slave mode is enabled. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t DIS_NSS = (1U << 3);  ///< When the DIS_NSS bit is set, the NSS pin input is ignored. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the USART is disabled (UEÂ =Â 0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length This bit is for selection between 11 bit or 10 bit break detection. This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable Break interrupt mask (break detection using break delimiter). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in synchronous mode. The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register. This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase This bit is used to select the phase of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see and ) This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity This bit enables the user to select the polarity of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable This bit enables the user to enable the SCLK pin. This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to . In Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected: UE = 0 SCEN = 1 GTPR configuration CLKEN= 1 UE = 1
        constexpr uint32_t STOP = (2 << 12);  ///< stop bits These bits are used for programming the stop bits. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable This bit is set and cleared by software. The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable This bit is set and cleared by software. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t ABRMOD = (2 << 21);  ///< Auto baud rate mode These bits are set and cleared by software. This bitfield can only be written when ABREN = 0 or the USART is disabled (UEÂ =Â 0). Note: If DATAINVÂ =Â 1 and/or MSBFIRSTÂ =Â 1 the patterns must be the same on the line, for example 0xAA for MSBFIRST) If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable This bit is set and cleared by software. When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register). Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the USART node ADD[7:4]: These bits give the address of the USART node or a character code to be recognized. They are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or low-power mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match. These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UEÂ =Â 0). ADD[3:0]: These bits give the address of the USART node or a character code to be recognized. They are used for wakeup with address mark detection, in multiprocessor communication during Mute mode or low-power mode. These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UEÂ =Â 0).
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FEÂ =Â 1 or OREÂ =Â 1 or NEÂ =Â 1 or UDR = 1 in the USART_ISR register).
        constexpr uint32_t IREN = (1U << 1);  ///< IrDA mode enable This bit is set and cleared by software. This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t IRLP = (1U << 2);  ///< IrDA low-power This bit is used for selecting between normal and low-power IrDA modes This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable This bit is used for enabling Smartcard mode. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver This bit is set/reset by software
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter This bit is set/reset by software
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable This bit can only be written when the USART is disabled (UEÂ =Â 0) Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled. This bit can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used. This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: This control bit enables checking the communication flow w/o reading the data
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error This bit can only be written when the USART is disabled (UE=0). Note: The reception errors are: parity error, framing error or noise error.
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count This bitfield specifies the number of retries for transmission and reception in Smartcard mode. In transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set). In reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set). This bitfield must be programmed only when the USART is disabled (UEÂ =Â 0). When the USART is enabled (UEÂ =Â 1), this bitfield may only be written to 0x0, in order to stop retransmission. Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag). This bitfield can only be written when the USART is disabled (UEÂ =Â 0). If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to pageÂ 835.
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to pageÂ 835.
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFIFO threshold interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TCBGTIE = (1U << 24);  ///< Transmission Complete before guard time, interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration Remaining combinations: Reserved
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration Remaining combinations: Reserved
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (16 << 0);  ///< USART baud rate
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value In IrDA low-power and normal IrDA mode: PSC[7:0] = IrDA Normal and Low-Power baud rate PSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is divided by the value given in the register (8 significant bits): In Smartcard mode: PSC[4:0]Â =Â Prescaler value PSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency: ... 0010Â 0000: Divides the source clock by 32 (IrDA mode) ... 1111Â 1111: Divides the source clock by 255 (IrDA mode) This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: Bits [7:5] must be kept cleared if Smartcard mode is used. This bitfield is reserved and forced by hardware to '0â when the Smartcard and IrDA modes are not supported. Refer to .
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value This bitfield is used to program the Guard time value in terms of number of baud clock periods. This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request Writing 1 to this bit resets the ABRF flag in the USART_ISR and requests an automatic baud rate measurement on the next received data frame. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE. This enables to discard the received data without reading them, and avoid an overrun condition.
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request When FIFO mode is disabled, writing '1â to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes. Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
    }

    /// ISR_FIFO_ENABLED Register bits
    namespace isr_fifo_enabled_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.
        constexpr uint32_t FE = (1U << 1);  ///< Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIEÂ =Â 1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.
        constexpr uint32_t NE = (1U << 2);  ///< Noise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on pageÂ 861). This error is associated with the character in the USART_RDR.
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXFNEIEÂ =Â 1 or EIE = 1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIEÂ =Â 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MMEÂ =Â 1), IDLE is set if the USART is not mute (RWUÂ =Â 0), whatever the Mute mode selected by the WAKE bit. If RWUÂ =Â 1, IDLE is not set.
        constexpr uint32_t RXFNE = (1U << 5);  ///< RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXFNEIEÂ =Â 1 in the USART_CR1 register.
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set. An interrupt is generated if TCIEÂ =Â 1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.
        constexpr uint32_t TXFNF = (1U << 7);  ///< TXFIFO not full TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register. Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). This bit is used during single buffer transmission.
        constexpr uint32_t LBDF = (1U << 8);  ///< LIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIEÂ =Â 1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t RTOF = (1U << 11);  ///< Receiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIEÂ =Â 1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
        constexpr uint32_t EOBF = (1U << 12);  ///< End of block flag This bit is set by hardware when a complete block has been received (for example TÂ =Â 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIEÂ =Â 1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t ABRE = (1U << 14);  ///< Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t ABRF = (1U << 15);  ///< Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABREÂ =Â 1) (ABRE, RXFNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        constexpr uint32_t CMF = (1U << 17);  ///< Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIEÂ =Â 1in the USART_CR1 register.
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t WUF = (1U << 20);  ///< Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIEÂ =Â 1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TEÂ =Â 0, followed by TEÂ =Â 1 in the USART_CR1 register, in order to respect the TEÂ =Â 0 minimum period.
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO empty This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register. An interrupt is generated if the TXFEIE bit Â =Â 1 (bit 30) in the USART_CR1 register.
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO full This bit is set by hardware when the number of received data corresponds to RXFIFOÂ sizeÂ +Â 1 (RXFIFO full + 1 data in the USART_RDR register. An interrupt is generated if the RXFFIE bit Â =Â 1 in the USART_CR1 register.
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIEÂ =Â 1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1â. Refer to on pageÂ 835.
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit Â =Â 1 (bit 27) in the USART_CR3 register. Note: When the RXFTCFG threshold is configured to '101â, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit Â =Â 1 (bit 31) in the USART_CR3 register.
    }

    /// ISR_FIFO_DISABLED Register bits
    namespace isr_fifo_disabled_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register.
        constexpr uint32_t FE = (1U << 1);  ///< Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIEÂ =Â 1 in the USART_CR1 register.
        constexpr uint32_t NE = (1U << 2);  ///< Noise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on pageÂ 861).
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXNEÂ =Â 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXNEIEÂ =Â 1 or EIE Â =Â  1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIEÂ =Â 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MMEÂ =Â 1), IDLE is set if the USART is not mute (RWUÂ =Â 0), whatever the Mute mode selected by the WAKE bit. If RWUÂ =Â 1, IDLE is not set.
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXNEIEÂ =Â 1 in the USART_CR1 register.
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXE is set. An interrupt is generated if TCIEÂ =Â 1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard TÂ =Â 0 mode, in case of transmission failure). An interrupt is generated if the TXEIE bit Â =Â 1 in the USART_CR1 register.
        constexpr uint32_t LBDF = (1U << 8);  ///< LIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIEÂ =Â 1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t RTOF = (1U << 11);  ///< Receiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIEÂ =Â 1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
        constexpr uint32_t EOBF = (1U << 12);  ///< End of block flag This bit is set by hardware when a complete block has been received (for example TÂ =Â 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIEÂ =Â 1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t ABRE = (1U << 14);  ///< Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t ABRF = (1U << 15);  ///< Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABREÂ =Â 1) (ABRE, RXNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        constexpr uint32_t CMF = (1U << 17);  ///< Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIEÂ =Â 1in the USART_CR1 register.
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t WUF = (1U << 20);  ///< Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIEÂ =Â 1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TEÂ =Â 0, followed by TEÂ =Â 1 in the USART_CR1 register, in order to respect the TEÂ =Â 0 minimum period.
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIEÂ =Â 1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1â. Refer to on pageÂ 835.
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag Writing 1 to this bit clears the PE flag in the USART_ISR register.
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag Writing 1 to this bit clears the FE flag in the USART_ISR register.
        constexpr uint32_t NECF = (1U << 2);  ///< Noise detected clear flag Writing 1 to this bit clears the NE flag in the USART_ISR register.
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag Writing 1 to this bit clears the ORE flag in the USART_ISR register.
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the USART_ISR register.
        constexpr uint32_t TXFECF = (1U << 5);  ///< TXFIFO empty clear flag Writing 1 to this bit clears the TXFE flag in the USART_ISR register.
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag Writing 1 to this bit clears the TC flag in the USART_ISR register.
        constexpr uint32_t TCBGTCF = (1U << 7);  ///< Transmission complete before Guard time clear flag Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag Writing 1 to this bit clears the LBDF flag in the USART_ISR register. Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag Writing 1 to this bit clears the CTSIF flag in the USART_ISR register. Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag Writing 1 to this bit clears the RTOF flag in the USART_ISR register. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to pageÂ 835.
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of block clear flag Writing 1 to this bit clears the EOBF flag in the USART_ISR register. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t UDRCF = (1U << 13);  ///< SPI slave underrun clear flag Writing 1 to this bit clears the UDRF flag in the USART_ISR register. Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag Writing 1 to this bit clears the CMF flag in the USART_ISR register.
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to pageÂ 835.
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler The USART input clock can be divided by a prescaler factor: Remaining combinations: Reserved Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.
    }

}


} // namespace alloy::generated::stm32g050

#endif // ALLOY_GENERATED_STM32G050_PERIPHERALS_HPP