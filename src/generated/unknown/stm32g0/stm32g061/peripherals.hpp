/// Auto-generated code for STM32G061
/// Generated by Alloy Code Generator
/// Source: st_stm32g061.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:29
#ifndef ALLOY_GENERATED_STM32G061_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32G061_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32g061 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 6;
    constexpr bool has_hdmi = true;
    constexpr uint32_t num_hdmi_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 11;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct hdmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 11;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 6;
    constexpr uint32_t max_gpio_pins = 96;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x40026000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t AES_CR;  ///< Offset: 0x00 - AES control register
        volatile uint32_t AES_SR;  ///< Offset: 0x04 - AES control register
        volatile uint32_t AES_DINR;  ///< Offset: 0x08 - AES data input register
        volatile uint32_t AES_DOUTR;  ///< Offset: 0x0C - AES data output register
        volatile uint32_t AES_KEYR0;  ///< Offset: 0x10 - AES key register 0
        volatile uint32_t AES_KEYR1;  ///< Offset: 0x14 - AES key register 1
        volatile uint32_t AES_KEYR2;  ///< Offset: 0x18 - AES key register 2
        volatile uint32_t AES_KEYR3;  ///< Offset: 0x1C - AES key register 3
        volatile uint32_t AES_IVR0;  ///< Offset: 0x20 - AES initialization vector register 0
        volatile uint32_t AES_IVR1;  ///< Offset: 0x24 - AES initialization vector register 1
        volatile uint32_t AES_IVR2;  ///< Offset: 0x28 - AES initialization vector register 2
        volatile uint32_t AES_IVR3;  ///< Offset: 0x2C - AES initialization vector register 3
        volatile uint32_t AES_KEYR4;  ///< Offset: 0x30 - AES key register 4
        volatile uint32_t AES_KEYR5;  ///< Offset: 0x34 - AES key register 5
        volatile uint32_t AES_KEYR6;  ///< Offset: 0x38 - AES key register 6
        volatile uint32_t AES_KEYR7;  ///< Offset: 0x3C - AES key register 7
        volatile uint32_t AES_SUSP0R;  ///< Offset: 0x40 - AES suspend registers
        volatile uint32_t AES_SUSP1R;  ///< Offset: 0x44 - AES suspend registers
        volatile uint32_t AES_SUSP2R;  ///< Offset: 0x48 - AES suspend registers
        volatile uint32_t AES_SUSP3R;  ///< Offset: 0x4C - AES suspend registers
        volatile uint32_t AES_SUSP4R;  ///< Offset: 0x50 - AES suspend registers
        volatile uint32_t AES_SUSP5R;  ///< Offset: 0x54 - AES suspend registers
        volatile uint32_t AES_SUSP6R;  ///< Offset: 0x58 - AES suspend registers
        volatile uint32_t AES_SUSP7R;  ///< Offset: 0x5C - AES suspend registers
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);

    // Bit definitions
    /// AES_CR Register bits
    namespace aes_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< AES enable This bit enables/disables the AES peripheral: At any moment, clearing then setting the bit re-initializes the AES peripheral. This bit is automatically cleared by hardware upon the completion of the key preparation (Mode 2) and upon the completion of GCM/GMAC/CCM initial phase.
        constexpr uint32_t DATATYPE = (2 << 1);  ///< Data type selection This bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping: For more details, refer to . Attempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access.
        constexpr uint32_t MODE = (2 << 3);  ///< AES operating mode This bitfield selects the AES operating mode: Attempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. Any attempt to selecting Mode 4 while either ECB or CBC chaining mode is not selected, defaults to effective selection of Mode 3. It is not possible to select a Mode 3 following a Mode 4.
        constexpr uint32_t CHMOD1 = (2 << 5);  ///< Chaining mode selection, bit [2] Refer to the bits [5:6] of the register for the description of the CHMOD[2:0] bitfield CHMOD[1:0]: Chaining mode selection, bits [1:0] This bitfield, together with the bit CHMOD[2] forming CHMOD[2:0], selects the AES chaining mode: others: Reserved Attempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access.
        constexpr uint32_t CCFC = (1U << 7);  ///< Computation complete flag clear Upon written to 1, this bit clears the computation complete flag (CCF) in the AES_SR register: Reading the flag always returns zero.
        constexpr uint32_t ERRC = (1U << 8);  ///< Error flag clear Upon written to 1, this bit clears the RDERR and WRERR error flags in the AES_SR register: Reading the flag always returns zero.
        constexpr uint32_t CCFIE = (1U << 9);  ///< CCF interrupt enable This bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set:
        constexpr uint32_t ERRIE = (1U << 10);  ///< Error interrupt enable This bit enables or disables (masks) the AES interrupt generation when RDERR and/or WRERR is set:
        constexpr uint32_t DMAINEN = (1U << 11);  ///< DMA input enable This bit enables/disables data transferring with DMA, in the input phase: When the bit is set, DMA requests are automatically generated by AES during the input data phase. This feature is only effective when Mode 1 or Mode 3 is selected through the MODE[1:0] bitfield. It is not effective for Mode 2 (key derivation). Usage of DMA with Mode 4 (single decryption) is not recommended.
        constexpr uint32_t DMAOUTEN = (1U << 12);  ///< DMA output enable This bit enables/disables data transferring with DMA, in the output phase: When the bit is set, DMA requests are automatically generated by AES during the output data phase. This feature is only effective when Mode 1 or Mode 3 is selected through the MODE[1:0] bitfield. It is not effective for Mode 2 (key derivation). Usage of DMA with Mode 4 (single decryption) is not recommended.
        constexpr uint32_t GCMPH = (2 << 13);  ///< GCM or CCM phase selection This bitfield selects the phase of GCM, GMAC or CCM algorithm: The bitfield has no effect if other than GCM, GMAC or CCM algorithms are selected (through the ALGOMODE bitfield).
        constexpr uint32_t CHMOD2 = (1U << 16);  ///< Chaining mode selection, bit [2] Refer to the bits [5:6] of the register for the description of the CHMOD[2:0] bitfield CHMOD[1:0]: Chaining mode selection, bits [1:0] This bitfield, together with the bit CHMOD[2] forming CHMOD[2:0], selects the AES chaining mode: others: Reserved Attempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access.
        constexpr uint32_t KEYSIZE = (1U << 18);  ///< Key size selection This bitfield defines the length of the key used in the AES cryptographic core, in bits: Attempts to write the bit are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access.
        constexpr uint32_t NPBLB = (4 << 20);  ///< Number of padding bytes in last block The bitfield sets the number of padding bytes in last block of payload: ...
    }

    /// AES_SR Register bits
    namespace aes_sr_bits {
        constexpr uint32_t CCF = (1U << 0);  ///< Computation completed flag This flag indicates whether the computation is completed: The flag is set by hardware upon the completion of the computation. It is cleared by software, upon setting the CCFC bit of the AES_CR register. Upon the flag setting, an interrupt is generated if enabled through the CCFIE bit of the AES_CR register. The flag is significant only when the DMAOUTEN bit is 0. It may stay high when DMA_EN is 1.
        constexpr uint32_t RDERR = (1U << 1);  ///< Read error flag This flag indicates the detection of an unexpected read operation from the AES_DOUTR register (during computation or data input phase): The flag is set by hardware. It is cleared by software upon setting the ERRC bit of the AES_CR register. Upon the flag setting, an interrupt is generated if enabled through the ERRIE bit of the AES_CR register. The flag setting has no impact on the AES operation. Unexpected read returns zero.
        constexpr uint32_t WRERR = (1U << 2);  ///< Write error This flag indicates the detection of an unexpected write operation to the AES_DINR register (during computation or data output phase): The flag is set by hardware. It is cleared by software upon setting the ERRC bit of the AES_CR register. Upon the flag setting, an interrupt is generated if enabled through the ERRIE bit of the AES_CR register. The flag setting has no impact on the AES operation. Unexpected write is ignored.
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy This flag indicates whether AES is idle or busy during GCM payload encryption phase: When the flag indicates “idle”, the current GCM encryption processing may be suspended to process a higher-priority message. In other chaining modes, or in GCM phases other than payload encryption, the flag must be ignored for the suspend process.
    }

    /// AES_DINR Register bits
    namespace aes_dinr_bits {
        constexpr uint32_t DIN = (32 << 0);  ///< Input data word A four-fold sequential write to this bitfield during the input phase results in writing a complete 128-bit block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 128-bit input buffer. The data signification of the input data block depends on the AES operating mode: - Mode 1 (encryption): plaintext - Mode 2 (key derivation): the bitfield is not used (AES_KEYRx registers used for input) - Mode 3 (decryption) and Mode 4 (key derivation then single decryption): ciphertext The data swap operation is described in page 499.
    }

    /// AES_DOUTR Register bits
    namespace aes_doutr_bits {
        constexpr uint32_t DOUT = (32 << 0);  ///< Output data word This read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon the computation completion (CCF set), virtually reads a complete 128-bit block of output data from the AES peripheral. Before reaching the output buffer, the data produced by the AES core are handled by the data swap block according to the DATATYPE[1:0] bitfield. Data weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0]. The data signification of the output data block depends on the AES operating mode: - Mode 1 (encryption): ciphertext - Mode 2 (key derivation): the bitfield is not used (AES_KEYRx registers used for output) - Mode 3 (decryption) and Mode 4 (key derivation then single decryption): plaintext The data swap operation is described in page 499.
    }

    /// AES_KEYR0 Register bits
    namespace aes_keyr0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [31:0] This bitfield contains the bits [31:0] of the AES encryption or decryption key, depending on the operating mode: - In Mode 1 (encryption), Mode 2 (key derivation) and Mode 4 (key derivation then single decryption): the value to write into the bitfield is the encryption key. - In Mode 3 (decryption): the value to write into the bitfield is the encryption key to be derived before being used for decryption. After writing the encryption key into the bitfield, its reading before enabling AES returns the same value. Its reading after enabling AES and after the CCF flag is set returns the decryption key derived from the encryption key. Note: In mode 4 (key derivation then single decryption) the bitfield always contains the encryption key. The AES_KEYRx registers may be written only when KEYSIZE value is correct and when the AES peripheral is disabled (EN bit of the AES_CR register cleared). Note that, if, the key is directly loaded to AES_KEYRx registers (hence writes to key register is ignored and KEIF is set). Refer to for more details.
    }

    /// AES_KEYR1 Register bits
    namespace aes_keyr1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [63:32] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_KEYR2 Register bits
    namespace aes_keyr2_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [95:64] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_KEYR3 Register bits
    namespace aes_keyr3_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [127:96] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_IVR0 Register bits
    namespace aes_ivr0_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [31:0] Refer to for description of the IVI[127:0] bitfield. The initialization vector is only used in chaining modes other than ECB. The AES_IVRx registers may be written only when the AES peripheral is disabled
    }

    /// AES_IVR1 Register bits
    namespace aes_ivr1_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [63:32] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.
    }

    /// AES_IVR2 Register bits
    namespace aes_ivr2_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [95:64] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.
    }

    /// AES_IVR3 Register bits
    namespace aes_ivr3_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [127:96] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.
    }

    /// AES_KEYR4 Register bits
    namespace aes_keyr4_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [159:128] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_KEYR5 Register bits
    namespace aes_keyr5_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [191:160] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_KEYR6 Register bits
    namespace aes_keyr6_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [223:192] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_KEYR7 Register bits
    namespace aes_keyr7_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [255:224] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
    }

    /// AES_SUSP0R Register bits
    namespace aes_susp0r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP1R Register bits
    namespace aes_susp1r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP2R Register bits
    namespace aes_susp2r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP3R Register bits
    namespace aes_susp3r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP4R Register bits
    namespace aes_susp4r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP5R Register bits
    namespace aes_susp5r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP6R Register bits
    namespace aes_susp6r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

    /// AES_SUSP7R Register bits
    namespace aes_susp7r_bits {
        constexpr uint32_t SUSP = (32 << 0);  ///< AES suspend Upon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR;  ///< Offset: 0x14 - ADC sampling time register
        volatile uint32_t ADC_AWD1TR;  ///< Offset: 0x20 - ADC watchdog threshold register
        volatile uint32_t ADC_AWD2TR;  ///< Offset: 0x24 - ADC watchdog threshold register
        volatile uint32_t ADC_CHSELRMOD0;  ///< Offset: 0x28 - ADC channel selection register
        volatile uint32_t ADC_CHSELRMOD1;  ///< Offset: 0x28 - ADC channel selection register
        volatile uint32_t ADC_AWD3TR;  ///< Offset: 0x2C - ADC watchdog threshold register
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC Analog Watchdog 2 Configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC Analog Watchdog 3 Configuration register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xB4 - ADC Calibration factor
        volatile uint32_t ADC_CCR;  ///< Offset: 0x308 - ADC common configuration register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready 	This bit is set by hardware after the ADC has been enabled (ADENÂ =Â 1) and when the ADC reaches a state where it is ready to accept conversion requests. 	It is cleared by software writing 1 to it.
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag 	This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1â.
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag 	This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
        constexpr uint32_t EOS = (1U << 3);  ///< End of sequence flag 	This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun 	This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
        constexpr uint32_t AWD1 = (1U << 7);  ///< Analog watchdog 1 flag 	This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
        constexpr uint32_t AWD2 = (1U << 8);  ///< Analog watchdog 2 flag 	This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
        constexpr uint32_t AWD3 = (1U << 9);  ///< Analog watchdog 3 flag 	This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag 	This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
        constexpr uint32_t CCRDY = (1U << 13);  ///< Channel Configuration Ready flag 	This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it. 	Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable 	This bit is set and cleared by software to enable/disable the ADC Ready interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable 	This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of conversion interrupt enable 	This bit is set and cleared by software to enable/disable the end of conversion interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of conversion sequence interrupt enable 	This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable 	This bit is set and cleared by software to enable/disable the overrun interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1IE = (1U << 7);  ///< Analog watchdog 1 interrupt enable 	This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 	Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD2IE = (1U << 8);  ///< Analog watchdog 2 interrupt enable 	This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 	Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD3IE = (1U << 9);  ///< Analog watchdog 3 interrupt enable 	This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 	Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable 	This bit is set and cleared by software to enable/disable the end of calibration interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CCRDYIE = (1U << 13);  ///< Channel Configuration Ready Interrupt enable 	This bit is set and cleared by software to enable/disable the channel configuration ready interrupt. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable command 	This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set. 	It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command. 	Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCALÂ =Â 0, ADSTPÂ =Â 0, ADSTARTÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0)
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command 	This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state). 	It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time). 	Note: Setting ADDIS to '1â is only effective when ADENÂ =Â 1 and ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing)
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start conversion command 	This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration). 	It is cleared by hardware: 	In single conversion mode (CONTÂ =Â 0, DISCENÂ =Â 0), when software trigger is selected (EXTENÂ =Â 00): at the assertion of the end of Conversion Sequence (EOS) flag. 	In discontinuous conversion mode(CONTÂ =Â 0, DISCENÂ =Â 1), when the software trigger is selected (EXTENÂ =Â 00): at the assertion of the end of Conversion (EOC) flag. 	In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware. 	Note: The software is allowed to set ADSTART only when ADENÂ =Â 1 and ADDISÂ =Â 0 (ADC is enabled and there is no pending request to disable the ADC). 	After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop conversion command 	This bit is set by software to stop and discard an ongoing conversion (ADSTP Command). 	It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command. 	Note: Setting ADSTP to '1â is only effective when ADSTARTÂ =Â 1 and ADDISÂ =Â 0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC Voltage Regulator Enable 	This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP. 	It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0. 	Note: The software is allowed to program this bit field only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0).
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration 	This bit is set by software to start the calibration of the ADC. 	It is cleared by hardware after calibration is complete. 	Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0). 	The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADENÂ =Â 1 and ADSTARTÂ =Â 0 (ADC enabled and no conversion is ongoing).
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< Direct memory access enable 	This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to . 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t DMACFG = (1U << 1);  ///< Direct memory access configuration 	This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAENÂ =Â 1. 	For more details, refer to pageÂ 391 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction 	This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t RES = (2 << 3);  ///< Data resolution 	These bits are written by software to select the resolution of the conversion. 	Note: The software is allowed to write these bits only when ADENÂ =Â 0.
        constexpr uint32_t ALIGN = (1U << 5);  ///< Data alignment 	This bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on pageÂ 389 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EXTSEL = (3 << 6);  ///< External trigger selection 	These bits select the external event used to trigger the start of conversion (refer to External triggers for details): 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection 	These bits are set and cleared by software to select the external trigger polarity and enable the trigger. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun management mode 	This bit is set and cleared by software and configure the way data overruns are managed. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode 	This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared. 	Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCENÂ =Â 1 and CONTÂ =Â 1. 	The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t WAIT = (1U << 14);  ///< Wait conversion mode 	This bit is set and cleared by software to enable/disable wait conversion mode.. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode 	This bit is set and cleared by software to enable/disable auto-off mode.. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode 	This bit is set and cleared by software to enable/disable discontinuous mode. 	Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCENÂ =Â 1 and CONTÂ =Â 1. 	The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CHSELRMOD = (1U << 21);  ///< Mode selection of the ADC_CHSELR register 	This bit is set and cleared by software to control the ADC_CHSELR feature: 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< Enable the watchdog on a single channel or on all channels 	This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1EN = (1U << 23);  ///< Analog watchdog enable 	This bit is set and cleared by software. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1CH = (5 << 26);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. 	..... 	Others: Reserved 	Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register. 	The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t OVSE = (1U << 0);  ///< Oversampler Enable 	This bit is set and cleared by software. 	Note: Software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OVSR = (3 << 2);  ///< Oversampling ratio 	This bit filed defines the number of oversampling ratio. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OVSS = (4 << 5);  ///< Oversampling shift 	This bit is set and cleared by software. 	Others: Reserved 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TOVS = (1U << 9);  ///< Triggered Oversampling 	This bit is set and cleared by software. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t LFTRIG = (1U << 29);  ///< Low frequency trigger mode enable 	This bit is set and cleared by software. 	Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode 	These bits are set and cleared by software to define how the analog ADC is clocked: 	In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. 	Note: The software is allowed to write these bits only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0).
    }

    /// ADC_SMPR Register bits
    namespace adc_smpr_bits {
        constexpr uint32_t SMP1 = (3 << 0);  ///< Sampling time selection 1 	These bits are written by software to select the sampling time that applies to all channels. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP2 = (3 << 4);  ///< Sampling time selection 2 	These bits are written by software to select the sampling time that applies to all channels. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL0 = (1U << 8);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL1 = (1U << 9);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL2 = (1U << 10);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL3 = (1U << 11);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL4 = (1U << 12);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL5 = (1U << 13);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL6 = (1U << 14);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL7 = (1U << 15);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL8 = (1U << 16);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL9 = (1U << 17);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL10 = (1U << 18);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL11 = (1U << 19);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL12 = (1U << 20);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL13 = (1U << 21);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL14 = (1U << 22);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL15 = (1U << 23);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL16 = (1U << 24);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL17 = (1U << 25);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL18 = (1U << 26);  ///< Channel-x sampling time selection 	These bits are written by software to define which sampling time is used. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD1TR Register bits
    namespace adc_awd1tr_bits {
        constexpr uint32_t LT1 = (12 << 0);  ///< Analog watchdog 1 lower threshold 	These bits are written by software to define the lower threshold for the analog watchdog. 	Refer to ADC_AWDxTR) on pageÂ 395.
        constexpr uint32_t HT1 = (12 << 16);  ///< Analog watchdog 1 higher threshold 	These bits are written by software to define the higher threshold for the analog watchdog. 	Refer to ADC_AWDxTR) on pageÂ 395.
    }

    /// ADC_AWD2TR Register bits
    namespace adc_awd2tr_bits {
        constexpr uint32_t LT2 = (12 << 0);  ///< Analog watchdog 2 lower threshold 	These bits are written by software to define the lower threshold for the analog watchdog. 	Refer to ADC_AWDxTR) on pageÂ 395.
        constexpr uint32_t HT2 = (12 << 16);  ///< Analog watchdog 2 higher threshold 	These bits are written by software to define the higher threshold for the analog watchdog. 	Refer to ADC_AWDxTR) on pageÂ 395.
    }

    /// ADC_CHSELRMOD0 Register bits
    namespace adc_chselrmod0_bits {
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL8 = (1U << 8);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL9 = (1U << 9);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL10 = (1U << 10);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL11 = (1U << 11);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL12 = (1U << 12);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL13 = (1U << 13);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL14 = (1U << 14);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL15 = (1U << 15);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL16 = (1U << 16);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL17 = (1U << 17);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL18 = (1U << 18);  ///< Channel-x selection 	These bits are written by software and define which channels are part of the sequence of channels to be converted. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). 	If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    }

    /// ADC_CHSELRMOD1 Register bits
    namespace adc_chselrmod1_bits {
        constexpr uint32_t SQ1 = (4 << 0);  ///< 1st conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ2 = (4 << 4);  ///< 2nd conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ3 = (4 << 8);  ///< 3rd conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ4 = (4 << 12);  ///< 4th conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ5 = (4 << 16);  ///< 5th conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ6 = (4 << 20);  ///< 6th conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ7 = (4 << 24);  ///< 7th conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	Refer to SQ8[3:0] for a definition of channel selection. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ8 = (4 << 28);  ///< 8th conversion of the sequence 	These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence. 	When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. 	... 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3TR Register bits
    namespace adc_awd3tr_bits {
        constexpr uint32_t LT3 = (12 << 0);  ///< Analog watchdog 3lower threshold 	These bits are written by software to define the lower threshold for the analog watchdog. 	Refer to ADC_AWDxTR) on pageÂ 395.
        constexpr uint32_t HT3 = (12 << 16);  ///< Analog watchdog 3 higher threshold 	These bits are written by software to define the higher threshold for the analog watchdog. 	Refer to ADC_AWDxTR) on pageÂ 395.
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Converted data 	These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on pageÂ 389. 	Just after a calibration is complete, DATA[6:0] contains the calibration factor.
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH0 = (1U << 0);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH1 = (1U << 1);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH2 = (1U << 2);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH3 = (1U << 3);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH4 = (1U << 4);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH5 = (1U << 5);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH6 = (1U << 6);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH7 = (1U << 7);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH8 = (1U << 8);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH9 = (1U << 9);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH10 = (1U << 10);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH11 = (1U << 11);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH12 = (1U << 12);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH13 = (1U << 13);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH14 = (1U << 14);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH15 = (1U << 15);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH16 = (1U << 16);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH17 = (1U << 17);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH18 = (1U << 18);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). 	Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH0 = (1U << 0);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH1 = (1U << 1);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH2 = (1U << 2);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH3 = (1U << 3);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH4 = (1U << 4);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH5 = (1U << 5);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH6 = (1U << 6);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH7 = (1U << 7);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH8 = (1U << 8);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH9 = (1U << 9);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH10 = (1U << 10);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH11 = (1U << 11);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH12 = (1U << 12);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH13 = (1U << 13);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH14 = (1U << 14);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH15 = (1U << 15);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH16 = (1U << 16);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH17 = (1U << 17);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH18 = (1U << 18);  ///< Analog watchdog channel selection 	These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). 	Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< Calibration factor 	These bits are written by hardware or by software. 	Once a calibration is complete,Â they are updated by hardware with the calibration factors. 	Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched. 	Just after a calibration is complete, DATA[6:0] contains the calibration factor. 	Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.
    }

    /// ADC_CCR Register bits
    namespace adc_ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0).
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable 	This bit is set and cleared by software to enable/disable the VREFINT. 	Note: Software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable 	This bit is set and cleared by software to enable/disable the temperature sensor. 	Note: Software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t VBATEN = (1U << 24);  ///< VBAT enable 	This bit is set and cleared by software to enable/disable the VBAT channel. 	Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing)
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRC_DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t CRC_IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CRC_CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t CRC_INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t CRC_POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRC_DR Register bits
    namespace crc_dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// CRC_IDR Register bits
    namespace crc_idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 32-bit data register bits
    }

    /// CRC_CR Register bits
    namespace crc_cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data This bit controls the reversal of the bit order of the output data.
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data These bits control the reversal of the bit order of the input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size These bits control the size of the polynomial.
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// CRC_INIT Register bits
    namespace crc_init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// CRC_POL Register bits
    namespace crc_pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC Sample and Hold sample time register 2
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable This bit is set and cleared by software to enable/disable DAC channel1 trigger. Note: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle.
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1 ... Refer to the trigger selection tables in for details on trigger configuration and mapping. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. 1x: Triangle wave generation enabled Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. ≥ 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC channel1 calibration enable This bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2. Note: These bits are available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable This bit is set and cleared by software to enable/disable DAC channel2 trigger Note: When software trigger is selected, the transfer from the DAC_DHR2 register to the DAC_DOR2 register takes only one dac_pclk clock cycle. These bits are available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t TSEL2 = (4 << 18);  ///< DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 ... Refer to the trigger selection tables in for details on trigger configuration and mapping. Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled). These bits are available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled) These bits are available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. ≥ 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 Note: These bits are available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable This bit is set and cleared by software. Note: This bit is available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software. Note: This bit is available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC channel2 calibration enable This bit is set and cleared by software to enable/disable DAC channel2 calibration, it can be written only if EN2 bit is set to 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored. Note: This bit is available only on dual-channel DACs. Refer to implementation.
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. This bit is available only on dual-channel DACs. Refer to implementation.
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software. They specify 12-bit data for DAC channel1.
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software. They specify 12-bit data for DAC channel1.
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software. They specify 8-bit data for DAC channel1.
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data These bits are written by software. They specify 12-bit data for DAC channel2.
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC channel1 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC channel1 busy writing sample time flag This bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization).
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1). Note: This bit is available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC channel2 calibration offset status This bit is set and cleared by hardware Note: This bit is available only on dual-channel DACs. Refer to implementation.
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC channel2 busy writing sample time flag This bit is systematically set just after Sample and hold mode enable. It is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). Note: This bit is available only on dual-channel DACs. Refer to implementation.
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC channel1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC channel2 offset trimming value These bits are available only on dual-channel DACs. Refer to implementation.
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC channel1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel1 mode: DAC channel1 in Normal mode DAC channel1 in sample & hold mode Note: This register can be modified only when EN1=0.
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC channel2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel2 mode: DAC channel2 in Normal mode DAC channel2 in Sample and hold mode Note: This register can be modified only when EN2=0. Refer to for the availability of DAC channel2.
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC channel1 sample time (only valid in Sample and hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST1=1, the write operation is ignored.
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC channel2 sample time (only valid in Sample and hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWST2 of DAC_SR register is low, if BWST2=1, the write operation is ignored.
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC channel1 hold time (only valid in Sample and hold mode) Hold time= (THOLD[9:0]) x LSI clock period Note: This register can be modified only when EN1=0.
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC channel2 hold time (only valid in Sample and hold mode). Hold time= (THOLD[9:0]) x LSI clock period Note: This register can be modified only when EN2=0. These bits are available only on dual-channel DACs. Refer to implementation.
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC channel1 refresh time (only valid in Sample and hold mode) Refresh time= (TREFRESH[7:0]) x LSI clock period Note: This register can be modified only when EN1=0.
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC channel2 refresh time (only valid in Sample and hold mode) Refresh time= (TREFRESH[7:0]) x LSI clock period Note: This register can be modified only when EN2=0. These bits are available only on dual-channel DACs. Refer to implementation.
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x40015800;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - MCU Device ID Code Register
        volatile uint32_t DBG_CR;  ///< Offset: 0x04 - DBG configuration register
        volatile uint32_t DBG_APB_FZ1;  ///< Offset: 0x08 - DBG APB freeze register 1
        volatile uint32_t DBG_APB_FZ2;  ///< Offset: 0x0C - DBG APB freeze register 2
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device Identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision Identifier
    }

    /// DBG_CR Register bits
    namespace dbg_cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode Debug options in Stop mode. Upon Stop mode exit, the software must re-establish the desired clock configuration.
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby and Shutdown modes Debug options in Standby or Shutdown mode.
    }

    /// DBG_APB_FZ1 Register bits
    namespace dbg_apb_fz1_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< Clocking of TIM2 counter when the core is halted This bit enables/disables the clock to the counter of TIM2 when the core is halted:
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< Clocking of TIM3 counter when the core is halted This bit enables/disables the clock to the counter of TIM3 when the core is halted:
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< Clocking of TIM6 counter when the core is halted This bit enables/disables the clock to the counter of TIM6 when the core is halted:
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< Clocking of TIM7 counter when the core is halted. This bit enables/disables the clock to the counter of ITIM7 when the core is halted:
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< Clocking of RTC counter when the core is halted This bit enables/disables the clock to the counter of RTC when the core is halted:
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Clocking of WWDG counter when the core is halted This bit enables/disables the clock to the counter of WWDG when the core is halted:
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Clocking of IWDG counter when the core is halted This bit enables/disables the clock to the counter of IWDG when the core is halted:
        constexpr uint32_t DBG_I2C1_SMBUS_TIMEOUT = (1U << 21);  ///< SMBUS timeout when core is halted
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 30);  ///< Clocking of LPTIMER2 counter when the core is halted This bit enables/disables the clock to the counter of LPTIMER2 when the core is halted:
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 31);  ///< Clocking of LPTIMER1 counter when the core is halted This bit enables/disables the clock to the counter of LPTIMER1 when the core is halted:
    }

    /// DBG_APB_FZ2 Register bits
    namespace dbg_apb_fz2_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< Clocking of TIM1 counter when the core is halted This bit enables/disables the clock to the counter of TIM1 when the core is halted:
        constexpr uint32_t DBG_TIM14_STOP = (1U << 15);  ///< Clocking of TIM14 counter when the core is halted This bit enables/disables the clock to the counter of TIM14 when the core is halted:
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< Clocking of TIM15 counter when the core is halted This bit enables/disables the clock to the counter of TIM15 when the core is halted: Only available on STM32G071xx and STM32G081xx, reserved on STM32G031xx and STM32G041xx.
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< Clocking of TIM16 counter when the core is halted This bit enables/disables the clock to the counter of TIM16 when the core is halted:
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< Clocking of TIM17 counter when the core is halted This bit enables/disables the clock to the counter of TIM17 when the core is halted:
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40020000;
    constexpr uint32_t DMAMUX_BASE = 0x40020800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMA_ISR;  ///< Offset: 0x00 - DMA interrupt status register
        volatile uint32_t DMA_IFCR;  ///< Offset: 0x04 - DMA interrupt flag clear register
        volatile uint32_t DMA_CCR1;  ///< Offset: 0x08 - DMA channel 1 configuration register
        volatile uint32_t DMA_CNDTR1;  ///< Offset: 0x0C - DMA channel 1 number of data to transfer register
        volatile uint32_t DMA_CPAR1;  ///< Offset: 0x10 - DMA channel 1 peripheral address register
        volatile uint32_t DMA_CMAR1;  ///< Offset: 0x14 - DMA channel 1 memory address register
        volatile uint32_t DMA_CCR2;  ///< Offset: 0x1C - DMA channel 2 configuration register
        volatile uint32_t DMA_CNDTR2;  ///< Offset: 0x20 - DMA channel 2 number of data to transfer register
        volatile uint32_t DMA_CPAR2;  ///< Offset: 0x24 - DMA channel 2 peripheral address register
        volatile uint32_t DMA_CMAR2;  ///< Offset: 0x28 - DMA channel 2 memory address register
        volatile uint32_t DMA_CCR3;  ///< Offset: 0x30 - DMA channel 3 configuration register
        volatile uint32_t DMA_CNDTR3;  ///< Offset: 0x34 - DMA channel 3 number of data to transfer register
        volatile uint32_t DMA_CPAR3;  ///< Offset: 0x38 - DMA channel 3 peripheral address register
        volatile uint32_t DMA_CMAR3;  ///< Offset: 0x3C - DMA channel 3 memory address register
        volatile uint32_t DMA_CCR4;  ///< Offset: 0x44 - DMA channel 4 configuration register
        volatile uint32_t DMA_CNDTR4;  ///< Offset: 0x48 - DMA channel 4 number of data to transfer register
        volatile uint32_t DMA_CPAR4;  ///< Offset: 0x4C - DMA channel 4 peripheral address register
        volatile uint32_t DMA_CMAR4;  ///< Offset: 0x50 - DMA channel 4 memory address register
        volatile uint32_t DMA_CCR5;  ///< Offset: 0x58 - DMA channel 5 configuration register
        volatile uint32_t DMA_CNDTR5;  ///< Offset: 0x5C - DMA channel 5 number of data to transfer register
        volatile uint32_t DMA_CPAR5;  ///< Offset: 0x60 - DMA channel 5 peripheral address register
        volatile uint32_t DMA_CMAR5;  ///< Offset: 0x64 - DMA channel 5 memory address register
        volatile uint32_t DMA_CCR6;  ///< Offset: 0x6C - DMA channel 6 configuration register
        volatile uint32_t DMA_CNDTR6;  ///< Offset: 0x70 - DMA channel 6 number of data to transfer register
        volatile uint32_t DMA_CPAR6;  ///< Offset: 0x74 - DMA channel 6 peripheral address register
        volatile uint32_t DMA_CMAR6;  ///< Offset: 0x78 - DMA channel 6 memory address register
        volatile uint32_t DMA_CCR7;  ///< Offset: 0x80 - DMA channel 7 configuration register
        volatile uint32_t DMA_CNDTR7;  ///< Offset: 0x84 - DMA channel 7 number of data to transfer register
        volatile uint32_t DMA_CPAR7;  ///< Offset: 0x88 - DMA channel 7 peripheral address register
        volatile uint32_t DMA_CMAR7;  ///< Offset: 0x8C - DMA channel 7 memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// DMA_ISR Register bits
    namespace dma_isr_bits {
        constexpr uint32_t GIF1 = (1U << 0);  ///< global interrupt flag for channel 1
        constexpr uint32_t TCIF1 = (1U << 1);  ///< transfer complete (TC) flag for channel 1
        constexpr uint32_t HTIF1 = (1U << 2);  ///< half transfer (HT) flag for channel 1
        constexpr uint32_t TEIF1 = (1U << 3);  ///< transfer error (TE) flag for channel 1
        constexpr uint32_t GIF2 = (1U << 4);  ///< global interrupt flag for channel 2
        constexpr uint32_t TCIF2 = (1U << 5);  ///< transfer complete (TC) flag for channel 2
        constexpr uint32_t HTIF2 = (1U << 6);  ///< half transfer (HT) flag for channel 2
        constexpr uint32_t TEIF2 = (1U << 7);  ///< transfer error (TE) flag for channel 2
        constexpr uint32_t GIF3 = (1U << 8);  ///< global interrupt flag for channel 3
        constexpr uint32_t TCIF3 = (1U << 9);  ///< transfer complete (TC) flag for channel 3
        constexpr uint32_t HTIF3 = (1U << 10);  ///< half transfer (HT) flag for channel 3
        constexpr uint32_t TEIF3 = (1U << 11);  ///< transfer error (TE) flag for channel 3
        constexpr uint32_t GIF4 = (1U << 12);  ///< global interrupt flag for channel 4
        constexpr uint32_t TCIF4 = (1U << 13);  ///< transfer complete (TC) flag for channel 4
        constexpr uint32_t HTIF4 = (1U << 14);  ///< half transfer (HT) flag for channel 4
        constexpr uint32_t TEIF4 = (1U << 15);  ///< transfer error (TE) flag for channel 4
        constexpr uint32_t GIF5 = (1U << 16);  ///< global interrupt flag for channel 5
        constexpr uint32_t TCIF5 = (1U << 17);  ///< transfer complete (TC) flag for channel 5
        constexpr uint32_t HTIF5 = (1U << 18);  ///< half transfer (HT) flag for channel 5
        constexpr uint32_t TEIF5 = (1U << 19);  ///< transfer error (TE) flag for channel 5
        constexpr uint32_t GIF6 = (1U << 20);  ///< global interrupt flag for channel 6
        constexpr uint32_t TCIF6 = (1U << 21);  ///< transfer complete (TC) flag for channel 6
        constexpr uint32_t HTIF6 = (1U << 22);  ///< half transfer (HT) flag for channel 6
        constexpr uint32_t TEIF6 = (1U << 23);  ///< transfer error (TE) flag for channel 6
        constexpr uint32_t GIF7 = (1U << 24);  ///< global interrupt flag for channel 7
        constexpr uint32_t TCIF7 = (1U << 25);  ///< transfer complete (TC) flag for channel 7
        constexpr uint32_t HTIF7 = (1U << 26);  ///< half transfer (HT) flag for channel 7
        constexpr uint32_t TEIF7 = (1U << 27);  ///< transfer error (TE) flag for channel 7
    }

    /// DMA_IFCR Register bits
    namespace dma_ifcr_bits {
        constexpr uint32_t CGIF1 = (1U << 0);  ///< global interrupt flag clear for channel 1
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< transfer complete flag clear for channel 1
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< half transfer flag clear for channel 1
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< transfer error flag clear for channel 1
        constexpr uint32_t CGIF2 = (1U << 4);  ///< global interrupt flag clear for channel 2
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< transfer complete flag clear for channel 2
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< half transfer flag clear for channel 2
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< transfer error flag clear for channel 2
        constexpr uint32_t CGIF3 = (1U << 8);  ///< global interrupt flag clear for channel 3
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< transfer complete flag clear for channel 3
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< half transfer flag clear for channel 3
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< transfer error flag clear for channel 3
        constexpr uint32_t CGIF4 = (1U << 12);  ///< global interrupt flag clear for channel 4
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< transfer complete flag clear for channel 4
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< half transfer flag clear for channel 4
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< transfer error flag clear for channel 4
        constexpr uint32_t CGIF5 = (1U << 16);  ///< global interrupt flag clear for channel 5
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< transfer complete flag clear for channel 5
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< half transfer flag clear for channel 5
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< transfer error flag clear for channel 5
        constexpr uint32_t CGIF6 = (1U << 20);  ///< global interrupt flag clear for channel 6
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< transfer complete flag clear for channel 6
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< half transfer flag clear for channel 6
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< transfer error flag clear for channel 6
        constexpr uint32_t CGIF7 = (1U << 24);  ///< global interrupt flag clear for channel 7
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< transfer complete flag clear for channel 7
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< half transfer flag clear for channel 7
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< transfer error flag clear for channel 7
    }

    /// DMA_CCR1 Register bits
    namespace dma_ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR1 Register bits
    namespace dma_cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR1 Register bits
    namespace dma_cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR1 Register bits
    namespace dma_cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CCR2 Register bits
    namespace dma_ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR2 Register bits
    namespace dma_cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR2 Register bits
    namespace dma_cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR2 Register bits
    namespace dma_cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CCR3 Register bits
    namespace dma_ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR3 Register bits
    namespace dma_cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR3 Register bits
    namespace dma_cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR3 Register bits
    namespace dma_cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CCR4 Register bits
    namespace dma_ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR4 Register bits
    namespace dma_cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR4 Register bits
    namespace dma_cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR4 Register bits
    namespace dma_cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CCR5 Register bits
    namespace dma_ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR5 Register bits
    namespace dma_cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR5 Register bits
    namespace dma_cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR5 Register bits
    namespace dma_cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CCR6 Register bits
    namespace dma_ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR6 Register bits
    namespace dma_cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR6 Register bits
    namespace dma_cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR6 Register bits
    namespace dma_cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CCR7 Register bits
    namespace dma_ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t HTIE = (1U << 2);  ///< half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t TEIE = (1U << 3);  ///< transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t DIR = (1U << 4);  ///< data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t CIRC = (1U << 5);  ///< circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PINC = (1U << 6);  ///< peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MINC = (1U << 7);  ///< memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PSIZE = (2 << 8);  ///< peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MSIZE = (2 << 10);  ///< memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t PL = (2 << 12);  ///< priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CNDTR7 Register bits
    namespace dma_cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CPAR7 Register bits
    namespace dma_cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

    /// DMA_CMAR7 Register bits
    namespace dma_cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t KEYR;  ///< Offset: 0x08 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x0C - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t CR;  ///< Offset: 0x14 - Flash control register
        volatile uint32_t ECCR;  ///< Offset: 0x18 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x20 - Flash option register
        volatile uint32_t PCROP1ASR;  ///< Offset: 0x24 - Flash PCROP zone A Start address register
        volatile uint32_t PCROP1AER;  ///< Offset: 0x28 - Flash PCROP zone A End address register
        volatile uint32_t WRP1AR;  ///< Offset: 0x2C - Flash WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x30 - Flash WRP area B address register
        volatile uint32_t PCROP1BSR;  ///< Offset: 0x34 - Flash PCROP zone B Start address register
        volatile uint32_t PCROP1BER;  ///< Offset: 0x38 - Flash PCROP area B End address register
        volatile uint32_t PCROP2ASR;  ///< Offset: 0x44 - Flash PCROP2 area A start address register
        volatile uint32_t PCROP2AER;  ///< Offset: 0x48 - Flash PCROP2 area A end address register
        volatile uint32_t WRP2AR;  ///< Offset: 0x4C - Flash WRP2 area A address register
        volatile uint32_t WRP2BR;  ///< Offset: 0x50 - Flash WRP2 area B address register
        volatile uint32_t PCROP2BSR;  ///< Offset: 0x54 - FLASH PCROP2 area B start address register
        volatile uint32_t PCROP2BER;  ///< Offset: 0x58 - FLASH PCROP2 area B end address register
        volatile uint32_t SECR;  ///< Offset: 0x80 - Flash Security register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t EMPTY = (1U << 16);  ///< Flash User area empty
        constexpr uint32_t DBG_SWEN = (1U << 18);  ///< Debug access software enable
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< KEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t MISERR = (1U << 8);  ///< Fast programming data miss error
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error
        constexpr uint32_t RDERR = (1U << 14);  ///< PCROP read error
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option and Engineering bits loading validity error
        constexpr uint32_t BSY = (1U << 16);  ///< Busy
        constexpr uint32_t CFGBSY = (1U << 18);  ///< Programming or erase configuration busy.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t MER = (1U << 2);  ///< Mass erase
        constexpr uint32_t PNB = (6 << 3);  ///< Page number
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t RDERRIE = (1U << 26);  ///< PCROP read error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t SEC_PROT = (1U << 28);  ///< Securable memory area protection enable
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (14 << 0);  ///< ECC fail address
        constexpr uint32_t SYSF_ECC = (1U << 20);  ///< ECC fail for Corrected ECC Error or Double ECC Error in info block
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t BOREN = (1U << 8);  ///< BOR reset Level
        constexpr uint32_t BORF_LEV = (2 << 9);  ///< These bits contain the VDD supply level threshold that activates the reset
        constexpr uint32_t BORR_LEV = (2 << 11);  ///< These bits contain the VDD supply level threshold that releases the reset.
        constexpr uint32_t nRST_STOP = (1U << 13);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 14);  ///< nRST_STDBY
        constexpr uint32_t nRSTS_HDW = (1U << 15);  ///< nRSTS_HDW
        constexpr uint32_t IDWG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t RAM_PARITY_CHECK = (1U << 22);  ///< SRAM parity check control
        constexpr uint32_t nBOOT_SEL = (1U << 24);  ///< nBOOT_SEL
        constexpr uint32_t nBOOT1 = (1U << 25);  ///< Boot configuration
        constexpr uint32_t nBOOT0 = (1U << 26);  ///< nBOOT0 option bit
        constexpr uint32_t NRST_MODE = (2 << 27);  ///< NRST_MODE
        constexpr uint32_t IRHEN = (1U << 29);  ///< Internal reset holder enable bit
    }

    /// PCROP1ASR Register bits
    namespace pcrop1asr_bits {
        constexpr uint32_t PCROP1A_STRT = (8 << 0);  ///< PCROP1A area start offset
    }

    /// PCROP1AER Register bits
    namespace pcrop1aer_bits {
        constexpr uint32_t PCROP1A_END = (8 << 0);  ///< PCROP1A area end offset
        constexpr uint32_t PCROP_RDP = (1U << 31);  ///< PCROP area preserved when RDP level decreased
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (6 << 0);  ///< WRP area A start offset
        constexpr uint32_t WRP1A_END = (6 << 16);  ///< WRP area A end offset
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (6 << 0);  ///< WRP area B start offset
        constexpr uint32_t WRP1B_END = (6 << 16);  ///< WRP area B end offset
    }

    /// PCROP1BSR Register bits
    namespace pcrop1bsr_bits {
        constexpr uint32_t PCROP1B_STRT = (8 << 0);  ///< PCROP1B area start offset
    }

    /// PCROP1BER Register bits
    namespace pcrop1ber_bits {
        constexpr uint32_t PCROP1B_END = (9 << 0);  ///< PCROP1B area end offset
    }

    /// PCROP2ASR Register bits
    namespace pcrop2asr_bits {
        constexpr uint32_t PCROP2A_STRT = (9 << 0);  ///< PCROP2A area start offset, bank2
    }

    /// PCROP2AER Register bits
    namespace pcrop2aer_bits {
        constexpr uint32_t PCROP2A_END = (9 << 0);  ///< PCROP2A area end offset, bank2
    }

    /// WRP2AR Register bits
    namespace wrp2ar_bits {
        constexpr uint32_t WRP2A_STRT = (7 << 0);  ///< WRP area A start offset, Bank 2
        constexpr uint32_t WRP2A_END = (7 << 16);  ///< WRP area A end offset, Bank 2
    }

    /// WRP2BR Register bits
    namespace wrp2br_bits {
        constexpr uint32_t WRP2B_STRT = (7 << 0);  ///< WRP area B start offset, Bank 2
        constexpr uint32_t WRP2B_END = (7 << 16);  ///< WRP area B end offset, Bank 2
    }

    /// PCROP2BSR Register bits
    namespace pcrop2bsr_bits {
        constexpr uint32_t PCROP2B_STRT = (9 << 0);  ///< PCROP2B area start offset, Bank 2
    }

    /// PCROP2BER Register bits
    namespace pcrop2ber_bits {
        constexpr uint32_t PCROP2B_END = (9 << 0);  ///< PCROP2B area end offset, Bank 2
    }

    /// SECR Register bits
    namespace secr_bits {
        constexpr uint32_t SEC_SIZE = (8 << 0);  ///< Securable memory area size
        constexpr uint32_t BOOT_LOCK = (1U << 16);  ///< used to force boot from user area
        constexpr uint32_t SEC_SIZE2 = (8 << 20);  ///< Securable memory area size
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOE_BASE = 0x50001000;
    constexpr uint32_t GPIOF_BASE = 0x50001400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port Reset bit
        constexpr uint32_t BR1 = (1U << 1);  ///< Port Reset bit
        constexpr uint32_t BR2 = (1U << 2);  ///< Port Reset bit
        constexpr uint32_t BR3 = (1U << 3);  ///< Port Reset bit
        constexpr uint32_t BR4 = (1U << 4);  ///< Port Reset bit
        constexpr uint32_t BR5 = (1U << 5);  ///< Port Reset bit
        constexpr uint32_t BR6 = (1U << 6);  ///< Port Reset bit
        constexpr uint32_t BR7 = (1U << 7);  ///< Port Reset bit
        constexpr uint32_t BR8 = (1U << 8);  ///< Port Reset bit
        constexpr uint32_t BR9 = (1U << 9);  ///< Port Reset bit
        constexpr uint32_t BR10 = (1U << 10);  ///< Port Reset bit
        constexpr uint32_t BR11 = (1U << 11);  ///< Port Reset bit
        constexpr uint32_t BR12 = (1U << 12);  ///< Port Reset bit
        constexpr uint32_t BR13 = (1U << 13);  ///< Port Reset bit
        constexpr uint32_t BR14 = (1U << 14);  ///< Port Reset bit
        constexpr uint32_t BR15 = (1U << 15);  ///< Port Reset bit
    }

}

// ============================================================================
// HDMI Peripheral
// ============================================================================

namespace hdmi {
    /// Base addresses
    constexpr uint32_t HDMI_CEC_BASE = 0x40007800;

    /// HDMI Register structure
    struct Registers {
        volatile uint32_t CEC_CR;  ///< Offset: 0x00 - CEC control register
        volatile uint32_t CEC_CFGR;  ///< Offset: 0x04 - This register is used to configure the HDMI-CEC...
        volatile uint32_t CEC_TXDR;  ///< Offset: 0x08 - CEC Tx data register
        volatile uint32_t CEC_RXDR;  ///< Offset: 0x0C - CEC Rx Data Register
        volatile uint32_t CEC_ISR;  ///< Offset: 0x10 - CEC Interrupt and Status Register
        volatile uint32_t CEC_IER;  ///< Offset: 0x14 - CEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* HDMI_CEC = reinterpret_cast<Registers*>(HDMI_CEC_BASE);

    // Bit definitions
    /// CEC_CR Register bits
    namespace cec_cr_bits {
        constexpr uint32_t CECEN = (1U << 0);  ///< CEC enable The CECEN bit is set and cleared by software. CECEN = 1 starts message reception and enables the TXSOM control. CECEN = 0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
        constexpr uint32_t TXSOM = (1U << 1);  ///< Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission starts after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND = 1), in case of transmission underrun (TXUDR = 1), negative acknowledge (TXACKE = 1), and transmission error (TXERR = 1). It is also cleared by CECEN = 0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST = 1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN = 1. TXSOM must be set when transmission data is available into TXDR. HEADER first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR that is used only for reception.
        constexpr uint32_t TXEOM = (1U << 2);  ///< Tx end of message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN = 1. TXEOM must be set before writing transmission data to TXDR. If TXEOM is set when TXSOM = 0, transmitted message consists of 1 byte (HEADER) only (PING message).
    }

    /// CEC_CFGR Register bits
    namespace cec_cfgr_bits {
        constexpr uint32_t SFT = (3 << 0);  ///< Signal free time SFT bits are set by software. In the SFT = 0x0 configuration, the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. 0x0 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST = 1, TXERR = 1, TXUDR = 1 or TXACKE = 1) 4 data-bit periods if CEC is the new bus initiator 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM = 1)
        constexpr uint32_t RXTOL = (1U << 3);  ///< Rx-tolerance The RXTOL bit is set and cleared by software. Start-bit, +/- 200 µs rise, +/- 200 µs fall Data-bit: +/- 200 µs rise. +/- 350 µs fall Start-bit: +/- 400 µs rise, +/- 400 µs fall Data-bit: +/-300 µs rise, +/- 500 µs fall
        constexpr uint32_t BRESTP = (1U << 4);  ///< Rx-stop on bit rising error The BRESTP bit is set and cleared by software.
        constexpr uint32_t BREGEN = (1U << 5);  ///< Generate error-bit on bit rising error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN = 0, an error-bit is generated upon BRE detection with BRESTP = 1 in broadcast even if BREGEN = 0.
        constexpr uint32_t LBPEGEN = (1U << 6);  ///< Generate error-bit on long bit period error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN = 0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN = 0.
        constexpr uint32_t BRDNOGEN = (1U << 7);  ///< Avoid error-bit generation in broadcast The BRDNOGEN bit is set and cleared by software. error-bit on the CEC line. LBPE detection with LBPEGEN = 0 on a broadcast message generates an error-bit on the CEC line.
        constexpr uint32_t SFTOP = (1U << 8);  ///< SFT option bit The SFTOPT bit is set and cleared by software.
        constexpr uint32_t OAR = (15 << 16);  ///< Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN = 1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
        constexpr uint32_t LSTN = (1U << 31);  ///< Listen mode LSTN bit is set and cleared by software.
    }

    /// CEC_TXDR Register bits
    namespace cec_txdr_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
    }

    /// CEC_RXDR Register bits
    namespace cec_rxdr_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
    }

    /// CEC_ISR Register bits
    namespace cec_isr_bits {
        constexpr uint32_t RXBR = (1U << 0);  ///< Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
        constexpr uint32_t RXEND = (1U << 1);  ///< End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
        constexpr uint32_t RXOVR = (1U << 2);  ///< Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
        constexpr uint32_t BRE = (1U << 3);  ///< Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
        constexpr uint32_t SBPE = (1U << 4);  ///< Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
        constexpr uint32_t LBPE = (1U << 5);  ///< Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
        constexpr uint32_t RXACKE = (1U << 6);  ///< Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
        constexpr uint32_t ARBLST = (1U << 7);  ///< Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
        constexpr uint32_t TXBR = (1U << 8);  ///< Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
        constexpr uint32_t TXEND = (1U << 9);  ///< End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
        constexpr uint32_t TXUDR = (1U << 10);  ///< Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
        constexpr uint32_t TXERR = (1U << 11);  ///< Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
        constexpr uint32_t TXACKE = (1U << 12);  ///< Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
    }

    /// CEC_IER Register bits
    namespace cec_ier_bits {
        constexpr uint32_t RXBRIE = (1U << 0);  ///< Rx-byte received interrupt enable The RXBRIE bit is set and cleared by software.
        constexpr uint32_t RXENDIE = (1U << 1);  ///< End of reception interrupt enable The RXENDIE bit is set and cleared by software.
        constexpr uint32_t RXOVRIE = (1U << 2);  ///< Rx-buffer overrun interrupt enable The RXOVRIE bit is set and cleared by software.
        constexpr uint32_t BREIE = (1U << 3);  ///< Bit rising error interrupt enable The BREIE bit is set and cleared by software.
        constexpr uint32_t SBPEIE = (1U << 4);  ///< Short bit period error interrupt enable The SBPEIE bit is set and cleared by software.
        constexpr uint32_t LBPEIE = (1U << 5);  ///< Long bit period error interrupt enable The LBPEIE bit is set and cleared by software.
        constexpr uint32_t RXACKIE = (1U << 6);  ///< Rx-missing acknowledge error interrupt enable The RXACKIE bit is set and cleared by software.
        constexpr uint32_t ARBLSTIE = (1U << 7);  ///< Arbitration lost interrupt enable The ARBLSTIE bit is set and cleared by software.
        constexpr uint32_t TXBRIE = (1U << 8);  ///< Tx-byte request interrupt enable The TXBRIE bit is set and cleared by software.
        constexpr uint32_t TXENDIE = (1U << 9);  ///< Tx-end of message interrupt enable The TXENDIE bit is set and cleared by software.
        constexpr uint32_t TXUDRIE = (1U << 10);  ///< Tx-underrun interrupt enable The TXUDRIE bit is set and cleared by software.
        constexpr uint32_t TXERRIE = (1U << 11);  ///< Tx-error interrupt enable The TXERRIE bit is set and cleared by software.
        constexpr uint32_t TXACKIE = (1U << 12);  ///< Tx-missing acknowledge error interrupt enable The TXACKEIE bit is set and cleared by software.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2C_CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t I2C_CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t I2C_OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t I2C_OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t I2C_TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t I2C_TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t I2C_ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t I2C_ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t I2C_PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t I2C_RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t I2C_TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// I2C_CR1 Register bits
    namespace i2c_cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match Interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received Interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< Stop detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable Note: Any of these events generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control This bit is used to enable hardware byte control in slave mode.
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to . Note: WUPEN can be set only when DNF = '0000â
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    }

    /// I2C_CR2 Register bits
    namespace i2c_cr2_bits {
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] should be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t START = (1U << 13);  ///< Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1â to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit generates a START condition once the bus is free. Note: Writing '0â to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In Master Mode: Note: Writing '0â to this bit has no effect.
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing '0â to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes The number of bytes to be transmitted/received is programmed there. This field is donât care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode This bit is set and cleared by software.
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing '0â to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    }

    /// I2C_OAR1 Register bits
    namespace i2c_oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN=0.
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// I2C_OAR2 Register bits
    namespace i2c_oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN=0.
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// I2C_TIMINGR Register bits
    namespace i2c_timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// I2C_TIMEOUTR Register bits
    namespace i2c_timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// I2C_ISR Register bits
    namespace i2c_isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// I2C_ICR Register bits
    namespace i2c_icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// I2C_PECR Register bits
    namespace i2c_pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// I2C_RXDR Register bits
    namespace i2c_rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// I2C_TXDR Register bits
    namespace i2c_txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t IWDG_KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t IWDG_PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t IWDG_RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t IWDG_SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t IWDG_WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// IWDG_KR Register bits
    namespace iwdg_kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// IWDG_PR Register bits
    namespace iwdg_pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider These bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.
    }

    /// IWDG_RLR Register bits
    namespace iwdg_rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// IWDG_SR Register bits
    namespace iwdg_sr_bits {
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Prescaler value can be updated only when PVU bit is reset.
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Reload value can be updated only when RVU bit is reset.
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Window value can be updated only when WVU bit is reset.
    }

    /// IWDG_WINR Register bits
    namespace iwdg_winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM1_BASE = 0x40007C00;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t LPTIM_ISR;  ///< Offset: 0x00 - Interrupt and Status Register
        volatile uint32_t LPTIM_ICR;  ///< Offset: 0x04 - Interrupt Clear Register
        volatile uint32_t LPTIM_IER;  ///< Offset: 0x08 - Interrupt Enable Register
        volatile uint32_t LPTIM_CFGR;  ///< Offset: 0x0C - Configuration Register
        volatile uint32_t LPTIM_CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t LPTIM_CMP;  ///< Offset: 0x14 - Compare Register
        volatile uint32_t LPTIM_ARR;  ///< Offset: 0x18 - Autoreload Register
        volatile uint32_t LPTIM_CNT;  ///< Offset: 0x1C - Counter Register
        volatile uint32_t LPTIM_CFGR2;  ///< Offset: 0x24 - LPTIM configuration register 2
    };

    /// Peripheral instances
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);

    // Bit definitions
    /// LPTIM_ISR Register bits
    namespace lptim_isr_bits {
        constexpr uint32_t CMPM = (1U << 0);  ///< Compare match The CMPM bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registerâs value.
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registerâs value reached the LPTIM_ARR registerâs value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
        constexpr uint32_t CMPOK = (1U << 3);  ///< Compare register update OK CMPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_CMP register has been successfully completed.
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    }

    /// LPTIM_ICR Register bits
    namespace lptim_icr_bits {
        constexpr uint32_t CMPMCF = (1U << 0);  ///< Compare match clear flag Writing 1 to this bit clears the CMP flag in the LPTIM_ISR register
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
        constexpr uint32_t CMPOKCF = (1U << 3);  ///< Compare register update OK clear flag Writing 1 to this bit clears the CMPOK flag in the LPTIM_ISR register
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    }

    /// LPTIM_IER Register bits
    namespace lptim_ier_bits {
        constexpr uint32_t CMPMIE = (1U << 0);  ///< Compare match Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t CMPOKIE = (1U << 3);  ///< Compare register update OK Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    }

    /// LPTIM_CFGR Register bits
    namespace lptim_cfgr_bits {
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector The CKSEL bit selects which clock source the LPTIM will use:
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity If LPTIM is clocked by an external clock source: When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. Refer to for more details about Encoder mode sub-modes.
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources: See for details.
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable The TIMOUT bit controls the Timeout feature
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape The WAVE bit controls the output shape
        constexpr uint32_t WAVPOL = (1U << 21);  ///< Waveform shape polarity The WAVEPOL bit controls the output polarity
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode The PRELOAD bit controls the LPTIM_ARR and the LPTIM_CMP registers update modality
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    }

    /// LPTIM_CR Register bits
    namespace lptim_cr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM enable The ENABLE bit is set and cleared by software.
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00â), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than '00â), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between LPTIM_ARR and LPTIM_CNT registers. This bit can only be set when the LPTIM is enabled. It will be automatically reset by hardware.
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00â), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than '00â), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It will be automatically reset by hardware.
        constexpr uint32_t COUNTRST = (1U << 3);  ///< Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit will trigger a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.
        constexpr uint32_t RSTARE = (1U << 4);  ///< Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register will asynchronously reset LPTIM_CNT register content.
    }

    /// LPTIM_CMP Register bits
    namespace lptim_cmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Compare value
    }

    /// LPTIM_ARR Register bits
    namespace lptim_arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value
    }

    /// LPTIM_CNT Register bits
    namespace lptim_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value
    }

    /// LPTIM_CFGR2 Register bits
    namespace lptim_cfgr2_bits {
        constexpr uint32_t IN1SEL = (2 << 0);  ///< LPTIM input 1 selection The IN1SEL bits control the LPTIM Input 1 multiplexer, which connects LPTIM Input 1 to one of the available inputs. For connection details refer to .
        constexpr uint32_t IN2SEL = (2 << 4);  ///< LPTIM input 2 selection The IN2SEL bits control the LPTIM Input 2 multiplexer, which connect LPTIM Input 2 to one of the available inputs. For connection details refer to . Note: If the LPTIM does not support encoder mode feature, these bits are reserved. Please refer to .
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x40008000;
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t LPUART_CR1_enabled;  ///< Offset: 0x00 - LPUART control register 1 [alternate]
        volatile uint32_t LPUART_CR1_disabled;  ///< Offset: 0x00 - LPUART control register 1 [alternate]
        volatile uint32_t LPUART_CR2;  ///< Offset: 0x04 - LPUART control register 2
        volatile uint32_t LPUART_CR3;  ///< Offset: 0x08 - LPUART control register 3
        volatile uint32_t LPUART_BRR;  ///< Offset: 0x0C - LPUART baud rate register
        volatile uint32_t LPUART_RQR;  ///< Offset: 0x18 - LPUART request register
        volatile uint32_t LPUART_ISR_enabled;  ///< Offset: 0x1C - LPUART interrupt and status register [alternate]
        volatile uint32_t LPUART_ISR_disabled;  ///< Offset: 0x1C - LPUART interrupt and status register [alternate]
        volatile uint32_t LPUART_ICR;  ///< Offset: 0x20 - LPUART interrupt flag clear register
        volatile uint32_t LPUART_RDR;  ///< Offset: 0x24 - LPUART receive data register
        volatile uint32_t LPUART_TDR;  ///< Offset: 0x28 - LPUART transmit data register
        volatile uint32_t LPUART_PRESC;  ///< Offset: 0x2C - LPUART prescaler register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);

    // Bit definitions
    /// LPUART_CR1_enabled Register bits
    namespace lpuart_cr1_enabled_bits {
        constexpr uint32_t UE = (1U << 0);  ///< USART enable 	When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. 	Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. 	The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. 	In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in low-power mode 	When this bit is cleared, the USART cannot wake up the MCU from low-power mode. 	When this bit is set, the USART can wake up the MCU from low-power mode. 	This bit is set and cleared by software. 	Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. 	If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable 	This bit enables the receiver. It is set and cleared by software.
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable 	This bit enables the transmitter. It is set and cleared by software. 	Note: During transmission, a low pulse on the TE bit ('0â followed by '1â) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1â. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. 	In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFIFO not empty interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection 	This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. 	This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable 	This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if MÂ =Â 1; 8th bit if MÂ =Â 0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). 	This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method 	This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. 	This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t M0 = (1U << 12);  ///< Word length 	This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). 	This bit can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable 	This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode 	This bit can only be written when the USART is disabled (UEÂ =Â 0). 	Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time 	This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). 	If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. 	This bitfield can only be written when the USART is disabled (UEÂ =Â 0). 	Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time 	This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). 	This bitfield can only be written when the USART is disabled (UEÂ =Â 0). 	Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable 	This bit is set and cleared by software. 	Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable 	This bit is set and cleared by software. 	Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t M1 = (1U << 28);  ///< Word length 	This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. 	M[1:0] = '00â: 1 start bit, 8 Data bits, n Stop bit 	M[1:0] = '01â: 1 start bit, 9 Data bits, n Stop bit 	M[1:0] = '10â: 1 start bit, 7 Data bits, n Stop bit 	This bit can only be written when the USART is disabled (UEÂ =Â 0). 	Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable 	This bit is set and cleared by software. 	This bitfield can only be written when the USART is disabled (UEÂ =Â 0). 	Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable 	This bit is set and cleared by software.
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable 	This bit is set and cleared by software.
    }

    /// LPUART_CR1_disabled Register bits
    namespace lpuart_cr1_disabled_bits {
        constexpr uint32_t UE = (1U << 0);  ///< USART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable This bit enables the receiver. It is set and cleared by software.
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0â followed by '1â) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1â. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXNEIE = (1U << 5);  ///< Receive data register not empty This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXEIE = (1U << 7);  ///< Transmit data register empty This bit is set and cleared by software.
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if MÂ =Â 1; 8th bit if MÂ =Â 0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t M0 = (1U << 12);  ///< Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UEÂ =Â 0).
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable This bit is set and cleared by software.
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t M1 = (1U << 28);  ///< Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00â: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01â: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10â: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UEÂ =Â 0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UEÂ =Â 0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
    }

    /// LPUART_CR2 Register bits
    namespace lpuart_cr2_bits {
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the LPUART is disabled (UEÂ =Â 0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits These bits are used for programming the stop bits. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the LPUART node ADD[7:4]: These bits give the address of the LPUART node or a character code to be recognized. They are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or Stop mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match. These bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UEÂ =Â 0) ADD[3:0]: These bits give the address of the LPUART node or a character code to be recognized. They are used for wakeup with address mark detection in multiprocessor communication during Mute mode or low-power mode. These bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UEÂ =Â 0)
    }

    /// LPUART_CR3 Register bits
    namespace lpuart_cr3_bits {
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FEÂ =Â 1 or OREÂ =Â 1 or NEÂ =Â 1 in the LPUART_ISR register).
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver This bit is set/reset by software
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter This bit is set/reset by software
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable This bit can only be written when the LPUART is disabled (UEÂ =Â 0)
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register. This bit can only be written when the LPUART is disabled (UEÂ =Â 0). Note: This control bit enables checking the communication flow w/o reading the data.
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error This bit can only be written when the LPUART is disabled (UEÂ =Â 0). Note: The reception errors are: parity error, framing error or noise error.
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag). This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0). Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. If the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFIFO threshold interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration Remaining combinations: Reserved.
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration Remaining combinations: Reserved.
    }

    /// LPUART_BRR Register bits
    namespace lpuart_brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< LPUART baud rate
    }

    /// LPUART_RQR Register bits
    namespace lpuart_rqr_bits {
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request Writing 1 to this bit puts the LPUART in Mute mode and resets the RWU flag.
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request Writing 1 to this bit clears the RXNE flag. This enables discarding the received data without reading it, and avoid an overrun condition.
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request This bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register). Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
    }

    /// LPUART_ISR_enabled Register bits
    namespace lpuart_isr_enabled_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error 	This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. 	An interrupt is generated if PEIE = 1 in the USART_CR1 register. 	Note: This error is associated with the character in the USART_RDR.
        constexpr uint32_t FE = (1U << 1);  ///< Framing error 	This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. 	When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). 	An interrupt is generated if EIEÂ =Â 1 in the USART_CR1 register. 	Note: This error is associated with the character in the USART_RDR.
        constexpr uint32_t NE = (1U << 2);  ///< Noise detection flag 	This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. 	Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. 	When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on pageÂ 903). 	This error is associated with the character in the USART_RDR.
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error 	This bit is set by hardware when the data currently being received in the shift register is 	ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. 	An interrupt is generated if RXFNEIEÂ =Â 1 or EIE = 1 in the USART_CR1 register. 	Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. 	This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected 	This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIEÂ =Â 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. 	Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). 	If Mute mode is enabled (MMEÂ =Â 1), IDLE is set if the USART is not mute (RWUÂ =Â 0), whatever the Mute mode selected by the WAKE bit. If RWUÂ =Â 1, IDLE is not set.
        constexpr uint32_t RXFNE = (1U << 5);  ///< RXFIFO not empty 	RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. 	RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. 	An interrupt is generated if RXFNEIEÂ =Â 1 in the USART_CR1 register.
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete 	This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. 	It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set. 	An interrupt is generated if TCIEÂ =Â 1 in the USART_CR1 register. 	TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. 	Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.
        constexpr uint32_t TXFNF = (1U << 7);  ///< TXFIFO not full 	TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. 	An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register. 	Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). 	This bit is used during single buffer transmission.
        constexpr uint32_t LBDF = (1U << 8);  ///< LIN break detection flag 	This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. 	An interrupt is generated if LBDIE = 1 in the USART_CR2 register. 	Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag 	This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. 	An interrupt is generated if CTSIEÂ =Â 1 in the USART_CR3 register. 	Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag 	This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. 	Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t RTOF = (1U << 11);  ///< Receiver timeout 	This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. 	An interrupt is generated if RTOIEÂ =Â 1 in the USART_CR2 register. 	In Smartcard mode, the timeout corresponds to the CWT or BWT timings. 	Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. 	The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. 	If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
        constexpr uint32_t EOBF = (1U << 12);  ///< End of block flag 	This bit is set by hardware when a complete block has been received (for example TÂ =Â 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. 	An interrupt is generated if the EOBIEÂ =Â 1 in the USART_CR2 register. 	It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. 	Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag 	In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. 	Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t ABRE = (1U << 14);  ///< Auto baud rate error 	This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) 	It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. 	Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t ABRF = (1U << 15);  ///< Auto baud rate flag 	This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABREÂ =Â 1) (ABRE, RXFNE and FE are also set in this case) 	It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. 	Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag 	This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        constexpr uint32_t CMF = (1U << 17);  ///< Character match flag 	This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. 	An interrupt is generated if CMIEÂ =Â 1in the USART_CR1 register.
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag 	This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wakeup from Mute mode 	This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. 	When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. 	Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t WUF = (1U << 20);  ///< Wakeup from low-power mode flag 	This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. 	An interrupt is generated if WUFIEÂ =Â 1 in the USART_CR3 register. 	Note: When UESM is cleared, WUF flag is also cleared. 	If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag 	This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. 	It can be used when an idle frame request is generated by writing TEÂ =Â 0, followed by TEÂ =Â 1 in the USART_CR1 register, in order to respect the TEÂ =Â 0 minimum period.
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag 	This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. 	It can be used to verify that the USART is ready for reception before entering low-power mode. 	Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO empty 	This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register. 	An interrupt is generated if the TXFEIE bit Â =Â 1 (bit 30) in the USART_CR1 register.
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO full 	This bit is set by hardware when the number of received data corresponds to RXFIFOÂ sizeÂ +Â 1 (RXFIFO full + 1 data in the USART_RDR register. 	An interrupt is generated if the RXFFIE bit Â =Â 1 in the USART_CR1 register.
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag 	This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. 	It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIEÂ =Â 1 in the USART_CR3 register. 	This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. 	Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1â. Refer to on pageÂ 877.
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag 	This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit Â =Â 1 (bit 27) in the USART_CR3 register. 	Note: When the RXFTCFG threshold is configured to '101â, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag 	This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit Â =Â 1 (bit 31) in the USART_CR3 register.
    }

    /// LPUART_ISR_disabled Register bits
    namespace lpuart_isr_disabled_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register.
        constexpr uint32_t FE = (1U << 1);  ///< Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIEÂ =Â 1 in the USART_CR1 register.
        constexpr uint32_t NE = (1U << 2);  ///< Noise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on pageÂ 903).
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXNEÂ =Â 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXNEIEÂ =Â 1 or EIE Â =Â  1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIEÂ =Â 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MMEÂ =Â 1), IDLE is set if the USART is not mute (RWUÂ =Â 0), whatever the Mute mode selected by the WAKE bit. If RWUÂ =Â 1, IDLE is not set.
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXNEIEÂ =Â 1 in the USART_CR1 register.
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXE is set. An interrupt is generated if TCIEÂ =Â 1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard TÂ =Â 0 mode, in case of transmission failure). An interrupt is generated if the TXEIE bit Â =Â 1 in the USART_CR1 register.
        constexpr uint32_t LBDF = (1U << 8);  ///< LIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIEÂ =Â 1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t RTOF = (1U << 11);  ///< Receiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIEÂ =Â 1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
        constexpr uint32_t EOBF = (1U << 12);  ///< End of block flag This bit is set by hardware when a complete block has been received (for example TÂ =Â 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIEÂ =Â 1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t ABRE = (1U << 14);  ///< Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t ABRF = (1U << 15);  ///< Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABREÂ =Â 1) (ABRE, RXNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        constexpr uint32_t CMF = (1U << 17);  ///< Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIEÂ =Â 1in the USART_CR1 register.
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t WUF = (1U << 20);  ///< Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIEÂ =Â 1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TEÂ =Â 0, followed by TEÂ =Â 1 in the USART_CR1 register, in order to respect the TEÂ =Â 0 minimum period.
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIEÂ =Â 1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1â. Refer to on pageÂ 877.
    }

    /// LPUART_ICR Register bits
    namespace lpuart_icr_bits {
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag Writing 1 to this bit clears the PE flag in the LPUART_ISR register.
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag Writing 1 to this bit clears the FE flag in the LPUART_ISR register.
        constexpr uint32_t NECF = (1U << 2);  ///< Noise detected clear flag Writing 1 to this bit clears the NE flag in the LPUART_ISR register.
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag Writing 1 to this bit clears the ORE flag in the LPUART_ISR register.
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the LPUART_ISR register.
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag Writing 1 to this bit clears the TC flag in the LPUART_ISR register.
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag Writing 1 to this bit clears the CTSIF flag in the LPUART_ISR register.
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag Writing 1 to this bit clears the CMF flag in the LPUART_ISR register.
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the LPUART_ISR register. Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
    }

    /// LPUART_RDR Register bits
    namespace lpuart_rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value Contains the received data character. The RDR register provides the parallel interface between the input shift register and the internal bus (see ). When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
    }

    /// LPUART_TDR Register bits
    namespace lpuart_tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value Contains the data character to be transmitted. The TDR register provides the parallel interface between the internal bus and the output shift register (see ). When transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity. Note: This register must be written only when TXE/TXFNFÂ =Â 1.
    }

    /// LPUART_PRESC Register bits
    namespace lpuart_presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler The LPUART input clock can be divided by a prescaler: Remaining combinations: Reserved. Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t FPD_LPSLP = (1U << 5);  ///< Flash memory powered down during Low-power sleep mode
        constexpr uint32_t FPD_LPRUN = (1U << 4);  ///< Flash memory powered down during Low-power run mode
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< Flash memory powered down during Stop mode
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PVDE = (1U << 0);  ///< Power voltage detector enable
        constexpr uint32_t PVDFT = (3 << 1);  ///< Power voltage detector falling threshold selection
        constexpr uint32_t PVDRT = (3 << 4);  ///< Power voltage detector rising threshold selection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable WKUP5 wakeup pin
        constexpr uint32_t EWUP6 = (1U << 5);  ///< Enable WKUP6 wakeup pin
        constexpr uint32_t RRS = (1U << 8);  ///< SRAM retention in Standby mode
        constexpr uint32_t ULPEN = (1U << 9);  ///< Enable the periodical sampling mode for PDR detection
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wakeup line
    }

    /// CR4 Register bits
    namespace cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity
        constexpr uint32_t WP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity
        constexpr uint32_t WP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity
        constexpr uint32_t WP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity
        constexpr uint32_t WP6 = (1U << 5);  ///< WKUP6 wakeup pin polarity
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT battery charging resistor selection
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag
        constexpr uint32_t WUFI = (1U << 15);  ///< Wakeup flag internal
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PVDO = (1U << 11);  ///< Power voltage detector output
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started
        constexpr uint32_t FLASH_RDY = (1U << 7);  ///< Flash ready flag
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Clear wakeup flag 6
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1
    }

    /// PUCRA Register bits
    namespace pucra_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..15)
    }

    /// PDCRA Register bits
    namespace pdcra_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..15)
    }

    /// PUCRB Register bits
    namespace pucrb_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15)
    }

    /// PDCRB Register bits
    namespace pdcrb_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..15)
    }

    /// PUCRC Register bits
    namespace pucrc_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y (y=0..15)
    }

    /// PDCRC Register bits
    namespace pdcrc_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15)
    }

    /// PUCRD Register bits
    namespace pucrd_bits {
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15)
    }

    /// PDCRD Register bits
    namespace pdcrd_bits {
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15)
    }

    /// PUCRF Register bits
    namespace pucrf_bits {
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15)
    }

    /// PDCRF Register bits
    namespace pdcrf_bits {
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15)
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40025000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t RNG_CR;  ///< Offset: 0x00 - control register
        volatile uint32_t RNG_SR;  ///< Offset: 0x04 - status register
        volatile uint32_t RNG_DR;  ///< Offset: 0x08 - RNG data register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// RNG_CR Register bits
    namespace rng_cr_bits {
        constexpr uint32_t RNGEN = (1U << 2);  ///< True random number generator enable
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt Enable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection The clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, i.e. to enable or disable CED the RNG must be disabled.
    }

    /// RNG_SR Register bits
    namespace rng_sr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data Ready Once the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated. Note: The DRDY bit can rise when the peripheral is disabled (RNGEN=0 in the RNG_CR register). If IE=1 in the RNG_CR register, an interrupt is generated when DRDY=1.
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status Note: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0.
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status One of the noise source has provided more than 64 consecutive bits at a constant value (â0â or â1â), or more than 32 consecutive occurrence of two bit patterns (â01â or â10â) Both noise sources have delivered more than 32 consecutive bits at a constant value (â0â or â1â), or more than 16 consecutive occurrence of two bit patterns (â01â or â10â)
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect. An interrupt is pending if IE = 1 in the RNG_CR register.
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing 0. Writing 1 has no effect. An interrupt is pending if IE = 1 in the RNG_CR register.
    }

    /// RNG_DR Register bits
    namespace rng_dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data 32-bit random data which are valid when DRDY=1. When DRDY=0 RNDATA value is zero. It is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event).
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_TR;  ///< Offset: 0x00 - RTC time register
        volatile uint32_t RTC_DR;  ///< Offset: 0x04 - RTC date register
        volatile uint32_t RTC_SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t RTC_ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t RTC_PRER;  ///< Offset: 0x10 - RTC prescaler register
        volatile uint32_t RTC_WUTR;  ///< Offset: 0x14 - RTC wakeup timer register
        volatile uint32_t RTC_CR;  ///< Offset: 0x18 - RTC control register
        volatile uint32_t RTC_WPR;  ///< Offset: 0x24 - RTC write protection register
        volatile uint32_t RTC_CALR;  ///< Offset: 0x28 - RTC calibration register
        volatile uint32_t RTC_SHIFTR;  ///< Offset: 0x2C - RTC shift control register
        volatile uint32_t RTC_TSTR;  ///< Offset: 0x30 - RTC timestamp time register
        volatile uint32_t RTC_TSDR;  ///< Offset: 0x34 - RTC timestamp date register
        volatile uint32_t RTC_TSSSR;  ///< Offset: 0x38 - RTC timestamp sub second register
        volatile uint32_t RTC_ALRMAR;  ///< Offset: 0x40 - RTC alarm A register
        volatile uint32_t RTC_ALRMASSR;  ///< Offset: 0x44 - RTC alarm A sub second register
        volatile uint32_t RTC_ALRMBR;  ///< Offset: 0x48 - RTC alarm B register
        volatile uint32_t RTC_ALRMBSSR;  ///< Offset: 0x4C - RTC alarm B sub second register
        volatile uint32_t RTC_SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t RTC_MISR;  ///< Offset: 0x54 - RTC masked interrupt status register
        volatile uint32_t RTC_SCR;  ///< Offset: 0x5C - RTC status clear register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// RTC_TR Register bits
    namespace rtc_tr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_DR Register bits
    namespace rtc_dr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units ...
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
    }

    /// RTC_SSR Register bits
    namespace rtc_ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    }

    /// RTC_ICSR Register bits
    namespace rtc_icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag This bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag This bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (RTC domain reset state).
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to .
    }

    /// RTC_PRER Register bits
    namespace rtc_prer_bits {
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    }

    /// RTC_WUTR Register bits
    namespace rtc_wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]Â +Â 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register. When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.
    }

    /// RTC_CR Register bits
    namespace rtc_cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< ck_wut wakeup clock selection 10x: ck_spre (usually 1Â Hz) clock is selected 11x: ck_spre (usually 1Â Hz) clock is selected and 216Â is added to the WUT counter value
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Timestamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 60Â Hz) Note: PREDIV_S must be 0x00FF.
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers Note: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable Note: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again.
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Timestamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
        constexpr uint32_t BKP = (1U << 18);  ///< Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection When COE = 1, this bit selects which signal is output on CALIB. These frequencies are valid for RTCCLK at 32.768Â kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity This bit is used to configure the polarity of TAMPALRM output.
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection These bits are used to select the flag to be routed to TAMPALRM output.
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable This bit enables the CALIB output
        constexpr uint32_t ITSE = (1U << 24);  ///< timestamp on internal event enable
        constexpr uint32_t TAMPTS = (1U << 25);  ///< Activate timestamp on tamper detection event TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid servicing 2 interrupts.
        constexpr uint32_t TAMPOE = (1U << 26);  ///< Tamper detection output enable on TAMPALRM
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM pull-up enable
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM output type
        constexpr uint32_t OUT2EN = (1U << 31);  ///< RTC_OUT2 output enable Setting this bit allows to remap the RTC outputs on RTC_OUT2 as follows: OUT2EN = 0: RTC output 2 disable If OSEL â  00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1 OUT2EN = 1: RTC output 2 enable If (OSEL â  00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2 If (OSELâ  00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.
    }

    /// RTC_WPR Register bits
    namespace rtc_wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to for a description of how to unlock RTC register write protection.
    }

    /// RTC_CALR Register bits
    namespace rtc_calr_bits {
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768Â Hz). This decreases the frequency of the calendar with a resolution of 0.9537Â ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1. Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5Â ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768Â Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 Ã CALP) - CALM. Refer to .
    }

    /// RTC_SHIFTR Register bits
    namespace rtc_shiftr_bits {
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    }

    /// RTC_TSTR Register bits
    namespace rtc_tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_TSDR Register bits
    namespace rtc_tsdr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
    }

    /// RTC_TSSSR Register bits
    namespace rtc_tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    }

    /// RTC_ALRMAR Register bits
    namespace rtc_alrmar_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
    }

    /// RTC_ALRMASSR Register bits
    namespace rtc_alrmassr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit 2:	SS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared. 3:	SS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared. ... 12:	SS[14:12] are don't care in alarm A comparison. SS[11:0] are compared. 13:	SS[14:13] are don't care in alarm A comparison. SS[12:0] are compared. 14:	SS[14] is don't care in alarm A comparison. SS[13:0] are compared. 15:	All 15 SS bits are compared and must match to activate alarm. The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. Note: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_ALRMBR Register bits
    namespace rtc_alrmbr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
    }

    /// RTC_ALRMBSSR Register bits
    namespace rtc_alrmbssr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_SR Register bits
    namespace rtc_sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
        constexpr uint32_t ALRBF = (1U << 1);  ///< Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
        constexpr uint32_t WUTF = (1U << 2);  ///< Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSF = (1U << 3);  ///< Timestamp flag This flag is set by hardware when a timestamp event occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVF = (1U << 4);  ///< Timestamp overflow flag This flag is set by hardware when a timestamp event occurs while TSF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSF = (1U << 5);  ///< Internal timestamp flag This flag is set by hardware when a timestamp on the internal event occurs.
    }

    /// RTC_MISR Register bits
    namespace rtc_misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< Alarm A masked flag This flag is set by hardware when the alarm A interrupt occurs.
        constexpr uint32_t ALRBMF = (1U << 1);  ///< Alarm B masked flag This flag is set by hardware when the alarm B interrupt occurs.
        constexpr uint32_t WUTMF = (1U << 2);  ///< Wakeup timer masked flag This flag is set by hardware when the wakeup timer interrupt occurs. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSMF = (1U << 3);  ///< Timestamp masked flag This flag is set by hardware when a timestamp interrupt occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVMF = (1U << 4);  ///< Timestamp overflow masked flag This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSMF = (1U << 5);  ///< Internal timestamp masked flag This flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
    }

    /// RTC_SCR Register bits
    namespace rtc_scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< Clear alarm A flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
        constexpr uint32_t CALRBF = (1U << 1);  ///< Clear alarm B flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
        constexpr uint32_t CWUTF = (1U << 2);  ///< Clear wakeup timer flag Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
        constexpr uint32_t CTSF = (1U << 3);  ///< Clear timestamp flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
        constexpr uint32_t CTSOVF = (1U << 4);  ///< Clear timestamp overflow flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t CITSF = (1U << 5);  ///< Clear internal timestamp flag Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x4000B000;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t TAMP_CR1;  ///< Offset: 0x00 - TAMP control register 1
        volatile uint32_t TAMP_CR2;  ///< Offset: 0x04 - TAMP control register 2
        volatile uint32_t TAMP_FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t TAMP_IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t TAMP_SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t TAMP_MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t TAMP_SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t TAMP_BKP0R;  ///< Offset: 0x100 - TAMP backup 0 register
        volatile uint32_t TAMP_BKP1R;  ///< Offset: 0x104 - TAMP backup 1 register
        volatile uint32_t TAMP_BKP2R;  ///< Offset: 0x108 - TAMP backup 2 register
        volatile uint32_t TAMP_BKP3R;  ///< Offset: 0x10C - TAMP backup 3 register
        volatile uint32_t TAMP_BKP4R;  ///< Offset: 0x110 - TAMP backup 4 register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// TAMP_CR1 Register bits
    namespace tamp_cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper detection on TAMP_IN1 enable
        constexpr uint32_t TAMP2E = (1U << 1);  ///< Tamper detection on TAMP_IN2 enable
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< Internal tamper 3 enable: LSE monitoring
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< Internal tamper 4 enable: HSE monitoring
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< Internal tamper 5 enable: RTC calendar overflow
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< Internal tamper 6 enable: ST manufacturer readout
    }

    /// TAMP_CR2 Register bits
    namespace tamp_cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< Tamper 1 no erase
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< Tamper 2 no erase
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< Tamper 1 mask The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< Tamper 2 mask The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< Active level for tamper 1 input (active mode disabled) If TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< Active level for tamper 2 input (active mode disabled) If TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event. If TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper detection event.
    }

    /// TAMP_FLTCR Register bits
    namespace tamp_fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< Tamper sampling frequency Determines the frequency at which each of the TAMP_INx inputs are sampled.
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMP_INx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMP_INx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMP_INx pull-up disable This bit determines if each of the TAMPx pins are precharged before each sample.
    }

    /// TAMP_IER Register bits
    namespace tamp_ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< Tamper 2 interrupt enable
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< Internal tamper 3 interrupt enable: LSE monitoring
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< Internal tamper 4 interrupt enable: HSE monitoring
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< Internal tamper 5 interrupt enable: RTC calendar overflow
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< Internal tamper 6 interrupt enable: ST manufacturer readout
    }

    /// TAMP_SR Register bits
    namespace tamp_sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< LSE monitoring tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< HSE monitoring tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 4.
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< RTC calendar overflow tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ST manufacturer readout tamper detection flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
    }

    /// TAMP_MISR Register bits
    namespace tamp_misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1 interrupt masked flag This flag is set by hardware when the tamper 1 interrupt is raised.
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2 interrupt masked flag This flag is set by hardware when the tamper 2 interrupt is raised.
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< LSE monitoring tamper interrupt masked flag This flag is set by hardware when the internal tamper 3 interrupt is raised.
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< HSE monitoring tamper interrupt masked flag This flag is set by hardware when the internal tamper 4 interrupt is raised.
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< RTC calendar overflow tamper interrupt masked flag This flag is set by hardware when the internal tamper 5 interrupt is raised.
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ST manufacturer readout tamper interrupt masked flag This flag is set by hardware when the internal tamper 6 interrupt is raised.
    }

    /// TAMP_SCR Register bits
    namespace tamp_scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< Clear TAMP1 detection flag Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< Clear TAMP2 detection flag Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< Clear ITAMP3 detection flag Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< Clear ITAMP4 detection flag Writing 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< Clear ITAMP5 detection flag Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< Clear ITAMP6 detection flag Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
    }

    /// TAMP_BKP0R Register bits
    namespace tamp_bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP1R Register bits
    namespace tamp_bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP2R Register bits
    namespace tamp_bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP3R Register bits
    namespace tamp_bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP4R Register bits
    namespace tamp_bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. In the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x40010030;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to for the mode descriptions depending on ENVR bit configuration.
        constexpr uint32_t VRS = (1U << 2);  ///< Voltage reference scale This bit selects the value generated by the voltage reference buffer.
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows the tuning of the internal reference buffer voltage.
    }

}


} // namespace alloy::generated::stm32g061

#endif // ALLOY_GENERATED_STM32G061_PERIPHERALS_HPP