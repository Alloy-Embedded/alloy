/// Auto-generated code for STM32G07x
/// Generated by Alloy Code Generator
/// Source: st_stm32g07.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:04
#ifndef ALLOY_GENERATED_STM32G07X_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32G07X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32g07x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
        volatile uint32_t HWCFGR;  ///< Offset: 0x3F0 - hardware configuration register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - EXTI IP Version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - EXTI Identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - EXTI Size ID register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

    /// HWCFGR Register bits
    namespace hwcfgr_bits {
        constexpr uint32_t WINDOW = (4 << 0);  ///< Support of Window function
        constexpr uint32_t PR_DEFAULT = (4 << 4);  ///< Prescaler default value
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor Revision number
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major Revision number
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IP Identification
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size Identification
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t KEYR;  ///< Offset: 0x08 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x0C - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t CR;  ///< Offset: 0x14 - Flash control register
        volatile uint32_t ECCR;  ///< Offset: 0x18 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x20 - Flash option register
        volatile uint32_t PCROP1ASR;  ///< Offset: 0x24 - Flash PCROP zone A Start address register
        volatile uint32_t PCROP1AER;  ///< Offset: 0x28 - Flash PCROP zone A End address register
        volatile uint32_t WRP1AR;  ///< Offset: 0x2C - Flash WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x30 - Flash WRP area B address register
        volatile uint32_t PCROP1BSR;  ///< Offset: 0x34 - Flash PCROP zone B Start address register
        volatile uint32_t PCROP1BER;  ///< Offset: 0x38 - Flash PCROP zone B End address register
        volatile uint32_t SECR;  ///< Offset: 0x80 - Flash Security register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t EMPTY = (1U << 16);  ///< Flash User area empty
        constexpr uint32_t DBG_SWEN = (1U << 18);  ///< Debug access software enable
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< KEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t MISERR = (1U << 8);  ///< Fast programming data miss error
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error
        constexpr uint32_t RDERR = (1U << 14);  ///< PCROP read error
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option and Engineering bits loading validity error
        constexpr uint32_t BSY = (1U << 16);  ///< Busy
        constexpr uint32_t CFGBSY = (1U << 18);  ///< Programming or erase configuration busy.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t MER = (1U << 2);  ///< Mass erase
        constexpr uint32_t PNB = (6 << 3);  ///< Page number
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t RDERRIE = (1U << 26);  ///< PCROP read error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t SEC_PROT = (1U << 28);  ///< Securable memory area protection enable
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (14 << 0);  ///< ECC fail address
        constexpr uint32_t SYSF_ECC = (1U << 20);  ///< ECC fail for Corrected ECC Error or Double ECC Error in info block
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t BOREN = (1U << 8);  ///< BOR reset Level
        constexpr uint32_t BORF_LEV = (2 << 9);  ///< These bits contain the VDD supply level threshold that activates the reset
        constexpr uint32_t BORR_LEV = (2 << 11);  ///< These bits contain the VDD supply level threshold that releases the reset.
        constexpr uint32_t nRST_STOP = (1U << 13);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 14);  ///< nRST_STDBY
        constexpr uint32_t nRSTS_HDW = (1U << 15);  ///< nRSTS_HDW
        constexpr uint32_t IDWG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t RAM_PARITY_CHECK = (1U << 22);  ///< SRAM parity check control
        constexpr uint32_t nBOOT_SEL = (1U << 24);  ///< nBOOT_SEL
        constexpr uint32_t nBOOT1 = (1U << 25);  ///< Boot configuration
        constexpr uint32_t nBOOT0 = (1U << 26);  ///< nBOOT0 option bit
        constexpr uint32_t NRST_MODE = (2 << 27);  ///< NRST_MODE
        constexpr uint32_t IRHEN = (1U << 29);  ///< Internal reset holder enable bit
    }

    /// PCROP1ASR Register bits
    namespace pcrop1asr_bits {
        constexpr uint32_t PCROP1A_STRT = (8 << 0);  ///< PCROP1A area start offset
    }

    /// PCROP1AER Register bits
    namespace pcrop1aer_bits {
        constexpr uint32_t PCROP1A_END = (8 << 0);  ///< PCROP1A area end offset
        constexpr uint32_t PCROP_RDP = (1U << 31);  ///< PCROP area preserved when RDP level decreased
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (6 << 0);  ///< WRP area A start offset
        constexpr uint32_t WRP1A_END = (6 << 16);  ///< WRP area A end offset
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (6 << 0);  ///< WRP area B start offset
        constexpr uint32_t WRP1B_END = (6 << 16);  ///< WRP area B end offset
    }

    /// PCROP1BSR Register bits
    namespace pcrop1bsr_bits {
        constexpr uint32_t PCROP1B_STRT = (8 << 0);  ///< PCROP1B area start offset
    }

    /// PCROP1BER Register bits
    namespace pcrop1ber_bits {
        constexpr uint32_t PCROP1B_END = (8 << 0);  ///< PCROP1B area end offset
    }

    /// SECR Register bits
    namespace secr_bits {
        constexpr uint32_t SEC_SIZE = (7 << 0);  ///< Securable memory area size
        constexpr uint32_t BOOT_LOCK = (1U << 16);  ///< used to force boot from user area
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x40015800;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - MCU Device ID Code Register
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU Configuration Register
        volatile uint32_t APB_FZ1;  ///< Offset: 0x08 - DBG APB freeze register 1
        volatile uint32_t APB_FZ2;  ///< Offset: 0x0C - DBG APB freeze register 2
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (16 << 0);  ///< Device Identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision Identifier
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop Mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby Mode
    }

    /// APB_FZ1 Register bits
    namespace apb_fz1_bits {
        constexpr uint32_t DBG_TIMER2_STOP = (1U << 0);  ///< Debug Timer 2 stopped when Core is halted
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 counter stopped when core is halted
        constexpr uint32_t DBG_TIMER6_STOP = (1U << 4);  ///< Debug Timer 6 stopped when Core is halted
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 counter stopped when core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< Debug RTC stopped when Core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Debug Window Wachdog stopped when Core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Debug Independent Wachdog stopped when Core is halted
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout mode stopped when core is halted
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 30);  ///< Clocking of LPTIMER2 counter when the core is halted
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 31);  ///< Clocking of LPTIMER1 counter when the core is halted
    }

    /// APB_FZ2 Register bits
    namespace apb_fz2_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< DBG_TIM1_STOP
        constexpr uint32_t DBG_TIM14_STOP = (1U << 15);  ///< DBG_TIM14_STOP
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< DBG_TIM15_STOP
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< DBG_TIM16_STOP
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t PLLSYSCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t AHBRSTR;  ///< Offset: 0x28 - AHB peripheral reset register
        volatile uint32_t IOPRSTR;  ///< Offset: 0x24 - GPIO reset register
        volatile uint32_t APBRSTR1;  ///< Offset: 0x2C - APB peripheral reset register 1
        volatile uint32_t APBRSTR2;  ///< Offset: 0x30 - APB peripheral reset register 2
        volatile uint32_t IOPENR;  ///< Offset: 0x34 - GPIO clock enable register
        volatile uint32_t AHBENR;  ///< Offset: 0x38 - AHB peripheral clock enable register
        volatile uint32_t APBENR1;  ///< Offset: 0x3C - APB peripheral clock enable register 1
        volatile uint32_t APBENR2;  ///< Offset: 0x40 - APB peripheral clock enable register 2
        volatile uint32_t IOPSMENR;  ///< Offset: 0x44 - GPIO in Sleep mode clock enable register
        volatile uint32_t AHBSMENR;  ///< Offset: 0x48 - AHB peripheral clock enable in Sleep mode register
        volatile uint32_t APBSMENR1;  ///< Offset: 0x4C - APB peripheral clock enable in Sleep mode register 1
        volatile uint32_t APBSMENR2;  ///< Offset: 0x50 - APB peripheral clock enable in Sleep mode register 2
        volatile uint32_t CCIPR;  ///< Offset: 0x54 - Peripherals independent clock configuration register
        volatile uint32_t BDCR;  ///< Offset: 0x5C - RTC domain control register
        volatile uint32_t CSR;  ///< Offset: 0x60 - Control/status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 always enable for peripheral kernels
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag
        constexpr uint32_t HSIDIV = (3 << 11);  ///< HSI16 clock division factor
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t HSICAL = (8 << 0);  ///< HSI16 clock calibration
        constexpr uint32_t HSITRIM = (7 << 8);  ///< HSI16 clock trimming
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (3 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (3 << 24);  ///< Microcontroller clock output
        constexpr uint32_t PPRE = (3 << 12);  ///< APB prescaler
        constexpr uint32_t HPRE = (4 << 8);  ///< AHB prescaler
        constexpr uint32_t SWS = (3 << 3);  ///< System clock switch status
        constexpr uint32_t SW = (3 << 0);  ///< System clock switch
    }

    /// PLLSYSCFGR Register bits
    namespace pllsyscfgr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< PLL input clock source
        constexpr uint32_t PLLM = (3 << 4);  ///< Division factor M of the PLL input clock divider
        constexpr uint32_t PLLN = (7 << 8);  ///< PLL frequency multiplication factor N
        constexpr uint32_t PLLPEN = (1U << 16);  ///< PLLPCLK clock output enable
        constexpr uint32_t PLLP = (5 << 17);  ///< PLL VCO division factor P for PLLPCLK clock output
        constexpr uint32_t PLLQEN = (1U << 24);  ///< PLLQCLK clock output enable
        constexpr uint32_t PLLQ = (3 << 25);  ///< PLL VCO division factor Q for PLLQCLK clock output
        constexpr uint32_t PLLREN = (1U << 28);  ///< PLLRCLK clock output enable
        constexpr uint32_t PLLR = (3 << 29);  ///< PLL VCO division factor R for PLLRCLK clock output
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable
        constexpr uint32_t PLLSYSRDYIE = (1U << 5);  ///< PLL ready interrupt enable
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag
        constexpr uint32_t PLLSYSRDYF = (1U << 5);  ///< PLL ready interrupt flag
        constexpr uint32_t CSSF = (1U << 8);  ///< Clock security system interrupt flag
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE Clock security system interrupt flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear
        constexpr uint32_t PLLSYSRDYC = (1U << 5);  ///< PLL ready interrupt clear
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t DMARST = (1U << 0);  ///< DMA1 reset
        constexpr uint32_t FLASHRST = (1U << 8);  ///< FLITF reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
        constexpr uint32_t AESRST = (1U << 16);  ///< AES hardware accelerator reset
        constexpr uint32_t RNGRST = (1U << 18);  ///< Random number generator reset
    }

    /// IOPRSTR Register bits
    namespace ioprstr_bits {
        constexpr uint32_t IOPARST = (1U << 0);  ///< I/O port A reset
        constexpr uint32_t IOPBRST = (1U << 1);  ///< I/O port B reset
        constexpr uint32_t IOPCRST = (1U << 2);  ///< I/O port C reset
        constexpr uint32_t IOPDRST = (1U << 3);  ///< I/O port D reset
        constexpr uint32_t IOPFRST = (1U << 5);  ///< I/O port F reset
    }

    /// APBRSTR1 Register bits
    namespace apbrstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 timer reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 timer reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 timer reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset
        constexpr uint32_t USART4RST = (1U << 19);  ///< USART4 reset
        constexpr uint32_t LPUART1RST = (1U << 20);  ///< LPUART1 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset
        constexpr uint32_t CECRST = (1U << 24);  ///< HDMI CEC reset
        constexpr uint32_t UCPD1RST = (1U << 25);  ///< UCPD1 reset
        constexpr uint32_t UCPD2RST = (1U << 26);  ///< UCPD2 reset
        constexpr uint32_t DBGRST = (1U << 27);  ///< Debug support reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t DAC1RST = (1U << 29);  ///< DAC1 interface reset
        constexpr uint32_t LPTIM2RST = (1U << 30);  ///< Low Power Timer 2 reset
        constexpr uint32_t LPTIM1RST = (1U << 31);  ///< Low Power Timer 1 reset
    }

    /// APBRSTR2 Register bits
    namespace apbrstr2_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG, COMP and VREFBUF reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t TIM14RST = (1U << 15);  ///< TIM14 timer reset
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 timer reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset
        constexpr uint32_t ADCRST = (1U << 20);  ///< ADC reset
    }

    /// IOPENR Register bits
    namespace iopenr_bits {
        constexpr uint32_t IOPAEN = (1U << 0);  ///< I/O port A clock enable
        constexpr uint32_t IOPBEN = (1U << 1);  ///< I/O port B clock enable
        constexpr uint32_t IOPCEN = (1U << 2);  ///< I/O port C clock enable
        constexpr uint32_t IOPDEN = (1U << 3);  ///< I/O port D clock enable
        constexpr uint32_t IOPFEN = (1U << 5);  ///< I/O port F clock enable
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA clock enable
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
        constexpr uint32_t AESEN = (1U << 16);  ///< AES hardware accelerator
        constexpr uint32_t RNGEN = (1U << 18);  ///< Random number generator clock enable
    }

    /// APBENR1 Register bits
    namespace apbenr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 timer clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 timer clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 timer clock enable
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable
        constexpr uint32_t USART4EN = (1U << 19);  ///< USART4 clock enable
        constexpr uint32_t LPUART1EN = (1U << 20);  ///< LPUART1 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t CECEN = (1U << 24);  ///< HDMI CEC clock enable
        constexpr uint32_t UCPD1EN = (1U << 25);  ///< UCPD1 clock enable
        constexpr uint32_t UCPD2EN = (1U << 26);  ///< UCPD2 clock enable
        constexpr uint32_t DBGEN = (1U << 27);  ///< Debug support clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t DAC1EN = (1U << 29);  ///< DAC1 interface clock enable
        constexpr uint32_t LPTIM2EN = (1U << 30);  ///< LPTIM2 clock enable
        constexpr uint32_t LPTIM1EN = (1U << 31);  ///< LPTIM1 clock enable
    }

    /// APBENR2 Register bits
    namespace apbenr2_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable
        constexpr uint32_t TIM14EN = (1U << 15);  ///< TIM14 timer clock enable
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 timer clock enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM16 timer clock enable
        constexpr uint32_t ADCEN = (1U << 20);  ///< ADC clock enable
    }

    /// IOPSMENR Register bits
    namespace iopsmenr_bits {
        constexpr uint32_t IOPASMEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode
        constexpr uint32_t IOPBSMEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode
        constexpr uint32_t IOPCSMEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode
        constexpr uint32_t IOPDSMEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode
        constexpr uint32_t IOPFSMEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode
    }

    /// AHBSMENR Register bits
    namespace ahbsmenr_bits {
        constexpr uint32_t DMASMEN = (1U << 0);  ///< DMA clock enable during Sleep mode
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clock enable during Sleep mode
        constexpr uint32_t SRAMSMEN = (1U << 9);  ///< SRAM clock enable during Sleep mode
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clock enable during Sleep mode
        constexpr uint32_t AESSMEN = (1U << 16);  ///< AES hardware accelerator clock enable during Sleep mode
        constexpr uint32_t RNGSMEN = (1U << 18);  ///< Random number generator clock enable during Sleep mode
    }

    /// APBSMENR1 Register bits
    namespace apbsmenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 timer clock enable during Sleep mode
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clock enable during Sleep mode
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 timer clock enable during Sleep mode
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 timer clock enable during Sleep mode
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep mode
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< WWDG clock enable during Sleep mode
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep mode
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep mode
        constexpr uint32_t USART4SMEN = (1U << 19);  ///< USART4 clock enable during Sleep mode
        constexpr uint32_t LPUART1SMEN = (1U << 20);  ///< LPUART1 clock enable during Sleep mode
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep mode
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode
        constexpr uint32_t CECSMEN = (1U << 24);  ///< HDMI CEC clock enable during Sleep mode
        constexpr uint32_t UCPD1SMEN = (1U << 25);  ///< UCPD1 clock enable during Sleep mode
        constexpr uint32_t UCPD2SMEN = (1U << 26);  ///< UCPD2 clock enable during Sleep mode
        constexpr uint32_t DBGSMEN = (1U << 27);  ///< Debug support clock enable during Sleep mode
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
        constexpr uint32_t DAC1SMEN = (1U << 29);  ///< DAC1 interface clock enable during Sleep mode
        constexpr uint32_t LPTIM2SMEN = (1U << 30);  ///< Low Power Timer 2 clock enable during Sleep mode
        constexpr uint32_t LPTIM1SMEN = (1U << 31);  ///< Low Power Timer 1 clock enable during Sleep mode
    }

    /// APBSMENR2 Register bits
    namespace apbsmenr2_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable during Sleep mode
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clock enable during Sleep mode
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep mode
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t TIM14SMEN = (1U << 15);  ///< TIM14 timer clock enable during Sleep mode
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 timer clock enable during Sleep mode
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM16 timer clock enable during Sleep mode
        constexpr uint32_t ADCSMEN = (1U << 20);  ///< ADC clock enable during Sleep mode
    }

    /// CCIPR Register bits
    namespace ccipr_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 clock source selection
        constexpr uint32_t CECSEL = (1U << 6);  ///< HDMI CEC clock source selection
        constexpr uint32_t LPUART1SEL = (2 << 10);  ///< LPUART1 clock source selection
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection
        constexpr uint32_t I2S2SEL = (2 << 14);  ///< I2S1 clock source selection
        constexpr uint32_t LPTIM1SEL = (2 << 18);  ///< LPTIM1 clock source selection
        constexpr uint32_t LPTIM2SEL = (2 << 20);  ///< LPTIM2 clock source selection
        constexpr uint32_t TIM1SEL = (1U << 22);  ///< TIM1 clock source selection
        constexpr uint32_t TIM15SEL = (1U << 24);  ///< TIM15 clock source selection
        constexpr uint32_t RNGSEL = (2 << 26);  ///< RNG clock source selection
        constexpr uint32_t RNGDIV = (2 << 28);  ///< Division factor of RNG clock divider
        constexpr uint32_t ADCSEL = (2 << 30);  ///< ADCs clock source selection
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure Detection
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t BDRST = (1U << 16);  ///< RTC domain software reset
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flags
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag
        constexpr uint32_t PWRRSTF = (1U << 27);  ///< BOR or POR/PDR flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t FPD_LPSLP = (1U << 5);  ///< Flash memory powered down during Low-power sleep mode
        constexpr uint32_t FPD_LPRUN = (1U << 4);  ///< Flash memory powered down during Low-power run mode
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< Flash memory powered down during Stop mode
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PVDE = (1U << 0);  ///< Power voltage detector enable
        constexpr uint32_t PVDFT = (3 << 1);  ///< Power voltage detector falling threshold selection
        constexpr uint32_t PVDRT = (3 << 4);  ///< Power voltage detector rising threshold selection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable WKUP5 wakeup pin
        constexpr uint32_t EWUP6 = (1U << 5);  ///< Enable WKUP6 wakeup pin
        constexpr uint32_t RRS = (1U << 8);  ///< SRAM retention in Standby mode
        constexpr uint32_t ULPEN = (1U << 9);  ///< Enable the periodical sampling mode for PDR detection
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wakeup line
    }

    /// CR4 Register bits
    namespace cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity
        constexpr uint32_t WP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity
        constexpr uint32_t WP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity
        constexpr uint32_t WP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity
        constexpr uint32_t WP6 = (1U << 5);  ///< WKUP6 wakeup pin polarity
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT battery charging resistor selection
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag
        constexpr uint32_t WUFI = (1U << 15);  ///< Wakeup flag internal
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PVDO = (1U << 11);  ///< Power voltage detector output
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started
        constexpr uint32_t FLASH_RDY = (1U << 7);  ///< Flash ready flag
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Clear wakeup flag 6
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1
    }

    /// PUCRA Register bits
    namespace pucra_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..15)
    }

    /// PDCRA Register bits
    namespace pdcra_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..15)
    }

    /// PUCRB Register bits
    namespace pucrb_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15)
    }

    /// PDCRB Register bits
    namespace pdcrb_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..15)
    }

    /// PUCRC Register bits
    namespace pucrc_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y (y=0..15)
    }

    /// PDCRC Register bits
    namespace pdcrc_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15)
    }

    /// PUCRD Register bits
    namespace pucrd_bits {
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15)
    }

    /// PDCRD Register bits
    namespace pdcrd_bits {
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15)
    }

    /// PUCRF Register bits
    namespace pucrf_bits {
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15)
    }

    /// PDCRF Register bits
    namespace pdcrf_bits {
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15)
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40020000;
    constexpr uint32_t DMAMUX_BASE = 0x40020800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - low interrupt status register
        volatile uint32_t IFCR;  ///< Offset: 0x04 - high interrupt status register
        volatile uint32_t CCR1;  ///< Offset: 0x08 - DMA channel x configuration register
        volatile uint32_t CCR2;  ///< Offset: 0x1C - DMA channel x configuration register
        volatile uint32_t CCR3;  ///< Offset: 0x30 - DMA channel x configuration register
        volatile uint32_t CCR4;  ///< Offset: 0x44 - DMA channel x configuration register
        volatile uint32_t CCR5;  ///< Offset: 0x58 - DMA channel x configuration register
        volatile uint32_t CCR6;  ///< Offset: 0x6C - DMA channel x configuration register
        volatile uint32_t CCR7;  ///< Offset: 0x80 - DMA channel x configuration register
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - DMA channel x number of data register
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - DMA channel x number of data register
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - DMA channel x configuration register
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - DMA channel x configuration register
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - DMA channel x configuration register
        volatile uint32_t CNDTR6;  ///< Offset: 0x70 - DMA channel x configuration register
        volatile uint32_t CNDTR7;  ///< Offset: 0x84 - DMA channel x configuration register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - DMA channel x peripheral address register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - DMA channel x peripheral address register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - DMA channel x peripheral address register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - DMA channel x peripheral address register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - DMA channel x peripheral address register
        volatile uint32_t CPAR6;  ///< Offset: 0x74 - DMA channel x peripheral address register
        volatile uint32_t CPAR7;  ///< Offset: 0x88 - DMA channel x peripheral address register
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - DMA channel x memory address register
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - DMA channel x memory address register
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - DMA channel x memory address register
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - DMA channel x memory address register
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - DMA channel x memory address register
        volatile uint32_t CMAR6;  ///< Offset: 0x78 - DMA channel x memory address register
        volatile uint32_t CMAR7;  ///< Offset: 0x8C - DMA channel x memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t GIF0 = (1U << 0);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF1 = (1U << 1);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF2 = (1U << 2);  ///< Channel half transfer flag
        constexpr uint32_t TEIF3 = (1U << 3);  ///< Channel transfer error flag
        constexpr uint32_t GIF4 = (1U << 4);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF5 = (1U << 5);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF6 = (1U << 6);  ///< Channel half transfer flag
        constexpr uint32_t TEIF7 = (1U << 7);  ///< Channel transfer error flag
        constexpr uint32_t GIF8 = (1U << 8);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF9 = (1U << 9);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF10 = (1U << 10);  ///< Channel half transfer flag
        constexpr uint32_t TEIF11 = (1U << 11);  ///< Channel transfer error flag
        constexpr uint32_t GIF12 = (1U << 12);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF13 = (1U << 13);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF14 = (1U << 14);  ///< Channel half transfer flag
        constexpr uint32_t TEIF15 = (1U << 15);  ///< Channel transfer error flag
        constexpr uint32_t GIF16 = (1U << 16);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF17 = (1U << 17);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF18 = (1U << 18);  ///< Channel half transfer flag
        constexpr uint32_t TEIF19 = (1U << 19);  ///< Channel transfer error flag
        constexpr uint32_t GIF20 = (1U << 20);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF21 = (1U << 21);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF22 = (1U << 22);  ///< Channel half transfer flag
        constexpr uint32_t TEIF23 = (1U << 23);  ///< Channel transfer error flag
        constexpr uint32_t GIF24 = (1U << 24);  ///< Channel global interrupt flag
        constexpr uint32_t TCIF25 = (1U << 25);  ///< Channel transfer complete flag
        constexpr uint32_t HTIF26 = (1U << 26);  ///< Channel half transfer flag
        constexpr uint32_t TEIF27 = (1U << 27);  ///< Channel transfer error flag
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CGIF0 = (1U << 0);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF2 = (1U << 2);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF3 = (1U << 3);  ///< Channel transfer error flag
        constexpr uint32_t CGIF4 = (1U << 4);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF5 = (1U << 5);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF6 = (1U << 6);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF7 = (1U << 7);  ///< Channel transfer error flag
        constexpr uint32_t CGIF8 = (1U << 8);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF9 = (1U << 9);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF10 = (1U << 10);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF11 = (1U << 11);  ///< Channel transfer error flag
        constexpr uint32_t CGIF12 = (1U << 12);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF13 = (1U << 13);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF14 = (1U << 14);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF15 = (1U << 15);  ///< Channel transfer error flag
        constexpr uint32_t CGIF16 = (1U << 16);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF17 = (1U << 17);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF18 = (1U << 18);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF19 = (1U << 19);  ///< Channel transfer error flag
        constexpr uint32_t CGIF20 = (1U << 20);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF21 = (1U << 21);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF22 = (1U << 22);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF23 = (1U << 23);  ///< Channel transfer error flag
        constexpr uint32_t CGIF24 = (1U << 24);  ///< Channel global interrupt flag
        constexpr uint32_t CTCIF25 = (1U << 25);  ///< Channel transfer complete flag
        constexpr uint32_t CHTIF26 = (1U << 26);  ///< Channel half transfer flag
        constexpr uint32_t CTEIF27 = (1U << 27);  ///< Channel transfer error flag
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR6 Register bits
    namespace ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CCR7 Register bits
    namespace ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR6 Register bits
    namespace cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CNDTR7 Register bits
    namespace cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR6 Register bits
    namespace cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR7 Register bits
    namespace cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR6 Register bits
    namespace cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CMAR7 Register bits
    namespace cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOF_BASE = 0x50001400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port Reset bit
        constexpr uint32_t BR1 = (1U << 1);  ///< Port Reset bit
        constexpr uint32_t BR2 = (1U << 2);  ///< Port Reset bit
        constexpr uint32_t BR3 = (1U << 3);  ///< Port Reset bit
        constexpr uint32_t BR4 = (1U << 4);  ///< Port Reset bit
        constexpr uint32_t BR5 = (1U << 5);  ///< Port Reset bit
        constexpr uint32_t BR6 = (1U << 6);  ///< Port Reset bit
        constexpr uint32_t BR7 = (1U << 7);  ///< Port Reset bit
        constexpr uint32_t BR8 = (1U << 8);  ///< Port Reset bit
        constexpr uint32_t BR9 = (1U << 9);  ///< Port Reset bit
        constexpr uint32_t BR10 = (1U << 10);  ///< Port Reset bit
        constexpr uint32_t BR11 = (1U << 11);  ///< Port Reset bit
        constexpr uint32_t BR12 = (1U << 12);  ///< Port Reset bit
        constexpr uint32_t BR13 = (1U << 13);  ///< Port Reset bit
        constexpr uint32_t BR14 = (1U << 14);  ///< Port Reset bit
        constexpr uint32_t BR15 = (1U << 15);  ///< Port Reset bit
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x40026000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DINR;  ///< Offset: 0x08 - data input register
        volatile uint32_t DOUTR;  ///< Offset: 0x0C - data output register
        volatile uint32_t KEYR0;  ///< Offset: 0x10 - key register 0
        volatile uint32_t KEYR1;  ///< Offset: 0x14 - key register 1
        volatile uint32_t KEYR2;  ///< Offset: 0x18 - key register 2
        volatile uint32_t KEYR3;  ///< Offset: 0x1C - key register 3
        volatile uint32_t IVR0;  ///< Offset: 0x20 - initialization vector register 0
        volatile uint32_t IVR1;  ///< Offset: 0x24 - initialization vector register 1
        volatile uint32_t IVR2;  ///< Offset: 0x28 - initialization vector register 2
        volatile uint32_t IVR3;  ///< Offset: 0x2C - initialization vector register 3
        volatile uint32_t KEYR4;  ///< Offset: 0x30 - key register 4
        volatile uint32_t KEYR5;  ///< Offset: 0x34 - key register 5
        volatile uint32_t KEYR6;  ///< Offset: 0x38 - key register 6
        volatile uint32_t KEYR7;  ///< Offset: 0x3C - key register 7
        volatile uint32_t SUSP0R;  ///< Offset: 0x40 - AES suspend register 0
        volatile uint32_t SUSP1R;  ///< Offset: 0x44 - AES suspend register 1
        volatile uint32_t SUSP2R;  ///< Offset: 0x48 - AES suspend register 2
        volatile uint32_t SUSP3R;  ///< Offset: 0x4C - AES suspend register 3
        volatile uint32_t SUSP4R;  ///< Offset: 0x50 - AES suspend register 4
        volatile uint32_t SUSP5R;  ///< Offset: 0x54 - AES suspend register 5
        volatile uint32_t SUSP6R;  ///< Offset: 0x58 - AES suspend register 6
        volatile uint32_t SUSP7R;  ///< Offset: 0x5C - AES suspend register 7
        volatile uint32_t HWCFR;  ///< Offset: 0x3F0 - AES hardware configuration register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - AES version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - AES identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - AES size ID register
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t NPBLB = (4 << 20);  ///< Number of padding bytes in last block of payload
        constexpr uint32_t KEYSIZE = (1U << 18);  ///< Key size selection
        constexpr uint32_t CHMOD2 = (1U << 16);  ///< AES chaining mode Bit2
        constexpr uint32_t GCMPH = (2 << 13);  ///< Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected
        constexpr uint32_t DMAOUTEN = (1U << 12);  ///< Enable DMA management of data output phase
        constexpr uint32_t DMAINEN = (1U << 11);  ///< Enable DMA management of data input phase
        constexpr uint32_t ERRIE = (1U << 10);  ///< Error interrupt enable
        constexpr uint32_t CCFIE = (1U << 9);  ///< CCF flag interrupt enable
        constexpr uint32_t ERRC = (1U << 8);  ///< Error clear
        constexpr uint32_t CCFC = (1U << 7);  ///< Computation Complete Flag Clear
        constexpr uint32_t CHMOD10 = (2 << 5);  ///< AES chaining mode Bit1 Bit0
        constexpr uint32_t MODE = (2 << 3);  ///< AES operating mode
        constexpr uint32_t DATATYPE = (2 << 1);  ///< Data type selection (for data in and data out to/from the cryptographic block)
        constexpr uint32_t EN = (1U << 0);  ///< AES enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy flag
        constexpr uint32_t WRERR = (1U << 2);  ///< Write error flag
        constexpr uint32_t RDERR = (1U << 1);  ///< Read error flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// DINR Register bits
    namespace dinr_bits {
        constexpr uint32_t AES_DINR = (32 << 0);  ///< Data Input Register
    }

    /// DOUTR Register bits
    namespace doutr_bits {
        constexpr uint32_t AES_DOUTR = (32 << 0);  ///< Data output register
    }

    /// KEYR0 Register bits
    namespace keyr0_bits {
        constexpr uint32_t AES_KEYR0 = (32 << 0);  ///< Data Output Register (LSB key [31:0])
    }

    /// KEYR1 Register bits
    namespace keyr1_bits {
        constexpr uint32_t AES_KEYR1 = (32 << 0);  ///< AES key register (key [63:32])
    }

    /// KEYR2 Register bits
    namespace keyr2_bits {
        constexpr uint32_t AES_KEYR2 = (32 << 0);  ///< AES key register (key [95:64])
    }

    /// KEYR3 Register bits
    namespace keyr3_bits {
        constexpr uint32_t AES_KEYR3 = (32 << 0);  ///< AES key register (MSB key [127:96])
    }

    /// IVR0 Register bits
    namespace ivr0_bits {
        constexpr uint32_t AES_IVR0 = (32 << 0);  ///< initialization vector register (LSB IVR [31:0])
    }

    /// IVR1 Register bits
    namespace ivr1_bits {
        constexpr uint32_t AES_IVR1 = (32 << 0);  ///< Initialization Vector Register (IVR [63:32])
    }

    /// IVR2 Register bits
    namespace ivr2_bits {
        constexpr uint32_t AES_IVR2 = (32 << 0);  ///< Initialization Vector Register (IVR [95:64])
    }

    /// IVR3 Register bits
    namespace ivr3_bits {
        constexpr uint32_t AES_IVR3 = (32 << 0);  ///< Initialization Vector Register (MSB IVR [127:96])
    }

    /// KEYR4 Register bits
    namespace keyr4_bits {
        constexpr uint32_t AES_KEYR4 = (32 << 0);  ///< AES key register (MSB key [159:128])
    }

    /// KEYR5 Register bits
    namespace keyr5_bits {
        constexpr uint32_t AES_KEYR5 = (32 << 0);  ///< AES key register (MSB key [191:160])
    }

    /// KEYR6 Register bits
    namespace keyr6_bits {
        constexpr uint32_t AES_KEYR6 = (32 << 0);  ///< AES key register (MSB key [223:192])
    }

    /// KEYR7 Register bits
    namespace keyr7_bits {
        constexpr uint32_t AES_KEYR7 = (32 << 0);  ///< AES key register (MSB key [255:224])
    }

    /// SUSP0R Register bits
    namespace susp0r_bits {
        constexpr uint32_t AES_SUSP0R = (32 << 0);  ///< AES suspend register 0
    }

    /// SUSP1R Register bits
    namespace susp1r_bits {
        constexpr uint32_t AES_SUSP1R = (32 << 0);  ///< AES suspend register 1
    }

    /// SUSP2R Register bits
    namespace susp2r_bits {
        constexpr uint32_t AES_SUSP2R = (32 << 0);  ///< AES suspend register 2
    }

    /// SUSP3R Register bits
    namespace susp3r_bits {
        constexpr uint32_t AES_SUSP3R = (32 << 0);  ///< AES suspend register 3
    }

    /// SUSP4R Register bits
    namespace susp4r_bits {
        constexpr uint32_t AES_SUSP4R = (32 << 0);  ///< AES suspend register 4
    }

    /// SUSP5R Register bits
    namespace susp5r_bits {
        constexpr uint32_t AES_SUSP5R = (32 << 0);  ///< AES suspend register 5
    }

    /// SUSP6R Register bits
    namespace susp6r_bits {
        constexpr uint32_t AES_SUSP6R = (32 << 0);  ///< AES suspend register 6
    }

    /// SUSP7R Register bits
    namespace susp7r_bits {
        constexpr uint32_t AES_SUSP7R = (32 << 0);  ///< AES suspend register 7
    }

    /// HWCFR Register bits
    namespace hwcfr_bits {
        constexpr uint32_t CFG4 = (4 << 12);  ///< HW Generic 4
        constexpr uint32_t CFG3 = (4 << 8);  ///< HW Generic 3
        constexpr uint32_t CFG2 = (4 << 4);  ///< HW Generic 2
        constexpr uint32_t CFG1 = (4 << 0);  ///< HW Generic 1
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major revision
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor revision
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t ID = (32 << 0);  ///< Identification code
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t ID = (32 << 0);  ///< Size Identification code
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40025000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DR;  ///< Offset: 0x08 - data register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RNGEN = (1U << 2);  ///< Random number generator enable
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection
        constexpr uint32_t BYP = (1U << 6);  ///< Bypass mode enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 32-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40021800;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t IMR1;  ///< Offset: 0x80 - EXTI CPU wakeup with interrupt mask register
        volatile uint32_t EMR1;  ///< Offset: 0x80 - EXTI CPU wakeup with event mask register
        volatile uint32_t IMR2;  ///< Offset: 0x90 - EXTI CPU wakeup with interrupt mask register
        volatile uint32_t EMR2;  ///< Offset: 0x94 - EXTI CPU wakeup with event mask register
        volatile uint32_t HWCFGR7;  ///< Offset: 0x3D8 - Hardware configuration registers
        volatile uint32_t HWCFGR6;  ///< Offset: 0x3DC - Hardware configuration registers
        volatile uint32_t HWCFGR5;  ///< Offset: 0x3E0 - Hardware configuration registers
        volatile uint32_t HWCFGR4;  ///< Offset: 0x3E4 - Hardware configuration registers
        volatile uint32_t HWCFGR3;  ///< Offset: 0x3E8 - Hardware configuration registers
        volatile uint32_t HWCFGR2;  ///< Offset: 0x3EC - Hardware configuration registers
        volatile uint32_t HWCFGR1;  ///< Offset: 0x3F0 - Hardware configuration registers
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - AES version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - AES identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - AES size ID register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWIER0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// RPR1 Register bits
    namespace rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF1 = (1U << 1);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF2 = (1U << 2);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF3 = (1U << 3);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF4 = (1U << 4);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge Pending bit
        constexpr uint32_t RPIF6 = (1U << 6);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF7 = (1U << 7);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF8 = (1U << 8);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF9 = (1U << 9);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF10 = (1U << 10);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF11 = (1U << 11);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF12 = (1U << 12);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF13 = (1U << 13);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF14 = (1U << 14);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF15 = (1U << 15);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF16 = (1U << 16);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF17 = (1U << 17);  ///< configurable event inputs x rising edge Pending bit.
        constexpr uint32_t RPIF18 = (1U << 18);  ///< configurable event inputs x rising edge Pending bit.
    }

    /// FPR1 Register bits
    namespace fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF17 = (1U << 17);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF18 = (1U << 18);  ///< configurable event inputs x falling edge pending bit.
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< GPIO port selection
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM17 = (1U << 17);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM18 = (1U << 18);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM26 = (1U << 26);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM27 = (1U << 27);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM28 = (1U << 28);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM29 = (1U << 29);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM30 = (1U << 30);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM31 = (1U << 31);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR1 Register bits
    namespace emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM17 = (1U << 17);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM18 = (1U << 18);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM26 = (1U << 26);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM27 = (1U << 27);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM28 = (1U << 28);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM29 = (1U << 29);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM30 = (1U << 30);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM31 = (1U << 31);  ///< CPU wakeup with event mask on event input
    }

    /// IMR2 Register bits
    namespace imr2_bits {
        constexpr uint32_t IM32 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM33 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR2 Register bits
    namespace emr2_bits {
        constexpr uint32_t EM32 = (1U << 0);  ///< CPU wakeup with event mask on event input
        constexpr uint32_t EM33 = (1U << 1);  ///< CPU wakeup with event mask on event input
    }

    /// HWCFGR7 Register bits
    namespace hwcfgr7_bits {
        constexpr uint32_t CPUEVENT = (32 << 0);  ///< HW configuration CPU event generation
    }

    /// HWCFGR6 Register bits
    namespace hwcfgr6_bits {
        constexpr uint32_t CPUEVENT = (32 << 0);  ///< HW configuration CPU event generation
    }

    /// HWCFGR5 Register bits
    namespace hwcfgr5_bits {
        constexpr uint32_t CPUEVENT = (32 << 0);  ///< HW configuration CPU event generation
    }

    /// HWCFGR4 Register bits
    namespace hwcfgr4_bits {
        constexpr uint32_t EVENT_TRG = (32 << 0);  ///< HW configuration event trigger type
    }

    /// HWCFGR3 Register bits
    namespace hwcfgr3_bits {
        constexpr uint32_t EVENT_TRG = (32 << 0);  ///< HW configuration event trigger type
    }

    /// HWCFGR2 Register bits
    namespace hwcfgr2_bits {
        constexpr uint32_t EVENT_TRG = (32 << 0);  ///< HW configuration event trigger type
    }

    /// HWCFGR1 Register bits
    namespace hwcfgr1_bits {
        constexpr uint32_t NBIOPORT = (8 << 16);  ///< HW configuration of number of IO ports
        constexpr uint32_t CPUEVTEN = (4 << 12);  ///< HW configuration of CPU event output enable
        constexpr uint32_t NBCPUS = (4 << 8);  ///< configuration number of CPUs
        constexpr uint32_t NBEVENTS = (8 << 0);  ///< configuration number of event
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major revision
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor revision
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t ID = (32 << 0);  ///< Identification code
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t ID = (32 << 0);  ///< Size Identification code
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t LPTIM1_BASE = 0x40007C00;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
        volatile uint32_t DCR;  ///< Offset: 0x48 - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x4C - DMA address for full transfer
        volatile uint32_t AF1;  ///< Offset: 0x60 - TIM17 option register 1
        volatile uint32_t TISEL;  ///< Offset: 0x68 - input selection register
    };

    /// Peripheral instances
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t UIFREMAP = (1U << 11);  ///< UIF status bit remapping
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC1M_2 = (1U << 16);  ///< Output Compare 1 mode
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t IC1PSC = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
        constexpr uint32_t UIFCPY = (1U << 31);  ///< UIF Copy
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t BKF = (4 << 16);  ///< Break filter
        constexpr uint32_t BKDSRM = (1U << 26);  ///< Break Disarm
        constexpr uint32_t BKBID = (1U << 28);  ///< Break Bidirectional
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (16 << 0);  ///< DMA register for burst accesses
    }

    /// AF1 Register bits
    namespace af1_bits {
        constexpr uint32_t BKINE = (1U << 0);  ///< BRK BKIN input enable
        constexpr uint32_t BKCMP1E = (1U << 1);  ///< BRK COMP1 enable
        constexpr uint32_t BKCMP2E = (1U << 2);  ///< BRK COMP2 enable
        constexpr uint32_t BKDFBK1E = (1U << 8);  ///< BRK DFSDM_BREAK1 enable
        constexpr uint32_t BKINP = (1U << 9);  ///< BRK BKIN input polarity
        constexpr uint32_t BKCMP1P = (1U << 10);  ///< BRK COMP1 input polarity
        constexpr uint32_t BKCMP2P = (1U << 11);  ///< BRK COMP2 input polarit
    }

    /// TISEL Register bits
    namespace tisel_bits {
        constexpr uint32_t TI1SEL = (4 << 0);  ///< selects input
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t USART4_BASE = 0x40004C00;
    constexpr uint32_t LPUART_BASE = 0x40008000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - Prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* USART4 = reinterpret_cast<Registers*>(USART4_BASE);
    inline Registers* LPUART = reinterpret_cast<Registers*>(LPUART_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4_7 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0_3 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable
        constexpr uint32_t ABRMOD = (2 << 21);  ///< Auto baud rate mode
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t TAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
        constexpr uint32_t DIS_NSS = (1U << 3);  ///< When the DSI_NSS bit is set, the NSS pin input will be ignored
        constexpr uint32_t SLVEN = (1U << 0);  ///< Synchronous Slave mode enable
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration
        constexpr uint32_t TCBGTIE = (1U << 24);  ///< Tr Complete before guard time, interrupt enable
        constexpr uint32_t TXFTIE = (1U << 23);  ///< threshold interrupt enable
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< Ir low-power
        constexpr uint32_t IREN = (1U << 1);  ///< Ir mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR_4_15 = (12 << 4);  ///< BRR_4_15
        constexpr uint32_t BRR_0_3 = (4 << 0);  ///< BRR_0_3
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag
        constexpr uint32_t TCBGT = (1U << 25);  ///< Transmission complete before guard time flag
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO Full
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO Empty
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t ABRF = (1U << 15);  ///< ABRF
        constexpr uint32_t ABRE = (1U << 14);  ///< ABRE
        constexpr uint32_t UDR = (1U << 13);  ///< SPI slave underrun error flag
        constexpr uint32_t EOBF = (1U << 12);  ///< EOBF
        constexpr uint32_t RTOF = (1U << 11);  ///< RTOF
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t LBDF = (1U << 8);  ///< LBDF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NF = (1U << 2);  ///< NF
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t UDRCF = (1U << 13);  ///< SPI slave underrun clear flag
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of block clear flag
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag
        constexpr uint32_t TCBGTCF = (1U << 7);  ///< Transmission complete before Guard time clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t TXFECF = (1U << 5);  ///< TXFIFO empty clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - prescaler register
        volatile uint32_t HWCFGR;  ///< Offset: 0x3F0 - hardware configuration register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - EXTI IP Version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - EXTI Identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - EXTI Size ID register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CKPOL = (1U << 3);  ///< Inactive state clock polarity
        constexpr uint32_t I2SSTD = (2 << 4);  ///< standard selection
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t SE2 = (1U << 10);  ///< I2S enable
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t I2SDIV = (8 << 0);  ///< linear prescaler
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
    }

    /// HWCFGR Register bits
    namespace hwcfgr_bits {
        constexpr uint32_t CRCCFG = (4 << 0);  ///< CRC capable at SPI mode
        constexpr uint32_t I2SCFG = (4 << 4);  ///< I2S mode implementation
        constexpr uint32_t I2SCKCFG = (4 << 8);  ///< I2S master clock generator at I2S mode
        constexpr uint32_t DSCFG = (4 << 12);  ///< SPI data size configuration
        constexpr uint32_t NSSCFG = (4 << 16);  ///< NSS pulse feature enhancement at SPI master
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor Revision number
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major Revision number
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IP Identification
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size Identification
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t CFGR1;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t SMPR;  ///< Offset: 0x14 - ADC sampling time register
        volatile uint32_t AWD1TR;  ///< Offset: 0x20 - watchdog threshold register
        volatile uint32_t AWD2TR;  ///< Offset: 0x24 - watchdog threshold register
        volatile uint32_t CHSELR;  ///< Offset: 0x28 - channel selection register
        volatile uint32_t CHSELR_1;  ///< Offset: 0x28 - channel selection register CHSELRMOD = 1 in ADC_CFGR1
        volatile uint32_t AWD3TR;  ///< Offset: 0x2C - watchdog threshold register
        volatile uint32_t DR;  ///< Offset: 0x40 - ADC group regular conversion data register
        volatile uint32_t AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t AWD3CR;  ///< Offset: 0xA4 - ADC analog watchdog 3 configuration register
        volatile uint32_t CALFACT;  ///< Offset: 0xB4 - ADC calibration factors register
        volatile uint32_t CCR;  ///< Offset: 0x308 - ADC common control register
        volatile uint32_t HWCFGR6;  ///< Offset: 0x3D8 - Hardware Configuration Register
        volatile uint32_t HWCFGR5;  ///< Offset: 0x3DC - Hardware Configuration Register
        volatile uint32_t HWCFGR4;  ///< Offset: 0x3E0 - Hardware Configuration Register
        volatile uint32_t HWCFGR3;  ///< Offset: 0x3E4 - Hardware Configuration Register
        volatile uint32_t HWCFGR2;  ///< Offset: 0x3E8 - Hardware Configuration Register
        volatile uint32_t HWCFGR1;  ///< Offset: 0x3EC - Hardware Configuration Register
        volatile uint32_t HWCFGR0;  ///< Offset: 0x3F0 - Hardware Configuration Register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - EXTI IP Version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - EXTI Identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - EXTI Size ID register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t CCRDY = (1U << 13);  ///< Channel Configuration Ready flag
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag
        constexpr uint32_t AWD3 = (1U << 9);  ///< ADC analog watchdog 3 flag
        constexpr uint32_t AWD2 = (1U << 8);  ///< ADC analog watchdog 2 flag
        constexpr uint32_t AWD1 = (1U << 7);  ///< ADC analog watchdog 1 flag
        constexpr uint32_t OVR = (1U << 4);  ///< ADC group regular overrun flag
        constexpr uint32_t EOS = (1U << 3);  ///< ADC group regular end of sequence conversions flag
        constexpr uint32_t EOC = (1U << 2);  ///< ADC group regular end of unitary conversion flag
        constexpr uint32_t EOSMP = (1U << 1);  ///< ADC group regular end of sampling flag
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t CCRDYIE = (1U << 13);  ///< Channel Configuration Ready Interrupt enable
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable
        constexpr uint32_t AWD3IE = (1U << 9);  ///< ADC analog watchdog 3 interrupt
        constexpr uint32_t AWD2IE = (1U << 8);  ///< ADC analog watchdog 2 interrupt
        constexpr uint32_t AWD1IE = (1U << 7);  ///< ADC analog watchdog 1 interrupt
        constexpr uint32_t OVRIE = (1U << 4);  ///< ADC group regular overrun interrupt
        constexpr uint32_t EOSIE = (1U << 3);  ///< ADC group regular end of sequence conversions interrupt
        constexpr uint32_t EOCIE = (1U << 2);  ///< ADC group regular end of unitary conversion interrupt
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< ADC group regular end of sampling interrupt
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC voltage regulator enable
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC group regular conversion stop
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC group regular conversion start
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t AWDCH1CH = (5 << 26);  ///< ADC analog watchdog 1 monitored channel selection
        constexpr uint32_t AWD1EN = (1U << 23);  ///< ADC analog watchdog 1 enable on scope ADC group regular
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< ADC analog watchdog 1 monitoring a single channel or all channels
        constexpr uint32_t CHSELRMOD = (1U << 21);  ///< Mode selection of the ADC_CHSELR register
        constexpr uint32_t DISCEN = (1U << 16);  ///< ADC group regular sequencer discontinuous mode
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode
        constexpr uint32_t WAIT = (1U << 14);  ///< Wait conversion mode
        constexpr uint32_t CONT = (1U << 13);  ///< ADC group regular continuous conversion mode
        constexpr uint32_t OVRMOD = (1U << 12);  ///< ADC group regular overrun configuration
        constexpr uint32_t EXTEN = (2 << 10);  ///< ADC group regular external trigger polarity
        constexpr uint32_t EXTSEL = (3 << 6);  ///< ADC group regular external trigger source
        constexpr uint32_t ALIGN = (1U << 5);  ///< ADC data alignement
        constexpr uint32_t RES = (2 << 3);  ///< ADC data resolution
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction
        constexpr uint32_t DMACFG = (1U << 1);  ///< ADC DMA transfer configuration
        constexpr uint32_t DMAEN = (1U << 0);  ///< ADC DMA transfer enable
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode
        constexpr uint32_t LFTRIG = (1U << 29);  ///< Low frequency trigger mode enable
        constexpr uint32_t TOVS = (1U << 9);  ///< ADC oversampling discontinuous mode (triggered mode) for ADC group regular
        constexpr uint32_t OVSS = (4 << 5);  ///< ADC oversampling shift
        constexpr uint32_t OVSR = (3 << 2);  ///< ADC oversampling ratio
        constexpr uint32_t OVSE = (1U << 0);  ///< ADC oversampler enable on scope ADC group regular
    }

    /// SMPR Register bits
    namespace smpr_bits {
        constexpr uint32_t SMP1 = (3 << 0);  ///< Sampling time selection
        constexpr uint32_t SMP2 = (3 << 4);  ///< Sampling time selection
        constexpr uint32_t SMPSEL = (19 << 8);  ///< Channel sampling time selection
    }

    /// AWD1TR Register bits
    namespace awd1tr_bits {
        constexpr uint32_t HT1 = (12 << 16);  ///< ADC analog watchdog 1 threshold high
        constexpr uint32_t LT1 = (12 << 0);  ///< ADC analog watchdog 1 threshold low
    }

    /// AWD2TR Register bits
    namespace awd2tr_bits {
        constexpr uint32_t HT2 = (12 << 16);  ///< ADC analog watchdog 2 threshold high
        constexpr uint32_t LT2 = (12 << 0);  ///< ADC analog watchdog 2 threshold low
    }

    /// CHSELR Register bits
    namespace chselr_bits {
        constexpr uint32_t CHSEL = (19 << 0);  ///< Channel-x selection
    }

    /// CHSELR_1 Register bits
    namespace chselr_1_bits {
        constexpr uint32_t SQ1 = (4 << 0);  ///< conversion of the sequence
        constexpr uint32_t SQ2 = (4 << 4);  ///< conversion of the sequence
        constexpr uint32_t SQ3 = (4 << 8);  ///< conversion of the sequence
        constexpr uint32_t SQ4 = (4 << 12);  ///< conversion of the sequence
        constexpr uint32_t SQ5 = (4 << 16);  ///< conversion of the sequence
        constexpr uint32_t SQ6 = (4 << 20);  ///< conversion of the sequence
        constexpr uint32_t SQ7 = (4 << 24);  ///< conversion of the sequence
        constexpr uint32_t SQ8 = (4 << 28);  ///< conversion of the sequence
    }

    /// AWD3TR Register bits
    namespace awd3tr_bits {
        constexpr uint32_t HT3 = (12 << 16);  ///< ADC analog watchdog 3 threshold high
        constexpr uint32_t LT3 = (12 << 0);  ///< ADC analog watchdog 3 threshold high
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t regularDATA = (16 << 0);  ///< ADC group regular conversion data
    }

    /// AWD2CR Register bits
    namespace awd2cr_bits {
        constexpr uint32_t AWD2CH = (19 << 0);  ///< ADC analog watchdog 2 monitored channel selection
    }

    /// AWD3CR Register bits
    namespace awd3cr_bits {
        constexpr uint32_t AWD3CH = (19 << 0);  ///< ADC analog watchdog 3 monitored channel selection
    }

    /// CALFACT Register bits
    namespace calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< ADC calibration factor in single-ended mode
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable
        constexpr uint32_t VBATEN = (1U << 24);  ///< VBAT enable
    }

    /// HWCFGR6 Register bits
    namespace hwcfgr6_bits {
        constexpr uint32_t CHMAP20 = (5 << 0);  ///< Input channel mapping
        constexpr uint32_t CHMAP21 = (5 << 8);  ///< Input channel mapping
        constexpr uint32_t CHMAP22 = (5 << 16);  ///< Input channel mapping
        constexpr uint32_t CHMAP23 = (5 << 24);  ///< Input channel mapping
    }

    /// HWCFGR5 Register bits
    namespace hwcfgr5_bits {
        constexpr uint32_t CHMAP19 = (5 << 0);  ///< Input channel mapping
        constexpr uint32_t CHMAP18 = (5 << 8);  ///< Input channel mapping
        constexpr uint32_t CHMAP17 = (5 << 16);  ///< Input channel mapping
        constexpr uint32_t CHMAP16 = (5 << 24);  ///< Input channel mapping
    }

    /// HWCFGR4 Register bits
    namespace hwcfgr4_bits {
        constexpr uint32_t CHMAP15 = (5 << 0);  ///< Input channel mapping
        constexpr uint32_t CHMAP14 = (5 << 8);  ///< Input channel mapping
        constexpr uint32_t CHMAP13 = (5 << 16);  ///< Input channel mapping
        constexpr uint32_t CHMAP12 = (5 << 24);  ///< Input channel mapping
    }

    /// HWCFGR3 Register bits
    namespace hwcfgr3_bits {
        constexpr uint32_t CHMAP11 = (5 << 0);  ///< Input channel mapping
        constexpr uint32_t CHMAP10 = (5 << 8);  ///< Input channel mapping
        constexpr uint32_t CHMAP9 = (5 << 16);  ///< Input channel mapping
        constexpr uint32_t CHMAP8 = (5 << 24);  ///< Input channel mapping
    }

    /// HWCFGR2 Register bits
    namespace hwcfgr2_bits {
        constexpr uint32_t CHMAP7 = (5 << 0);  ///< Input channel mapping
        constexpr uint32_t CHMAP6 = (5 << 8);  ///< Input channel mapping
        constexpr uint32_t CHMAP5 = (5 << 16);  ///< Input channel mapping
        constexpr uint32_t CHMAP4 = (5 << 24);  ///< Input channel mapping
    }

    /// HWCFGR1 Register bits
    namespace hwcfgr1_bits {
        constexpr uint32_t CHMAP3 = (5 << 0);  ///< Input channel mapping
        constexpr uint32_t CHMAP2 = (5 << 8);  ///< Input channel mapping
        constexpr uint32_t CHMAP1 = (5 << 16);  ///< Input channel mapping
        constexpr uint32_t CHMAP0 = (5 << 24);  ///< Input channel mapping
    }

    /// HWCFGR0 Register bits
    namespace hwcfgr0_bits {
        constexpr uint32_t NUM_CHAN_24 = (4 << 0);  ///< NUM_CHAN_24
        constexpr uint32_t EXTRA_AWDS = (4 << 4);  ///< Extra analog watchdog
        constexpr uint32_t OVS = (4 << 8);  ///< Oversampling
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor Revision number
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major Revision number
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IP Identification
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size Identification
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x40010200;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP1_CSR;  ///< Offset: 0x00 - Comparator 1 control and status register
        volatile uint32_t COMP2_CSR;  ///< Offset: 0x04 - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);

    // Bit definitions
    /// COMP1_CSR Register bits
    namespace comp1_csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< COMP channel 1 enable bit
        constexpr uint32_t INMSEL = (4 << 4);  ///< Comparator 2 signal selector for inverting input INM
        constexpr uint32_t INPSEL = (2 << 8);  ///< Comparator 2 signal selector for non-inverting input
        constexpr uint32_t WINMODE = (1U << 11);  ///< Comparator 2 non-inverting input selector for window mode
        constexpr uint32_t WINOUT = (1U << 14);  ///< Comparator 2 output selector
        constexpr uint32_t POLARITY = (1U << 15);  ///< Comparator 2 polarity selector
        constexpr uint32_t HYST = (2 << 16);  ///< Comparator 2 hysteresis selector
        constexpr uint32_t PWRMODE = (2 << 18);  ///< Comparator 2 power mode selector
        constexpr uint32_t BLANKSEL = (5 << 20);  ///< Comparator 2 blanking source selector
        constexpr uint32_t VALUE = (1U << 30);  ///< Comparator 2 output status
        constexpr uint32_t LOCK = (1U << 31);  ///< COMP2_CSR register lock
    }

    /// COMP2_CSR Register bits
    namespace comp2_csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< COMP channel 1 enable bit
        constexpr uint32_t INMSEL = (4 << 4);  ///< Comparator 2 signal selector for inverting input INM
        constexpr uint32_t INPSEL = (2 << 8);  ///< Comparator 2 signal selector for non-inverting input
        constexpr uint32_t WINMODE = (1U << 11);  ///< Comparator 2 non-inverting input selector for window mode
        constexpr uint32_t WINOUT = (1U << 14);  ///< Comparator 2 output selector
        constexpr uint32_t POLARITY = (1U << 15);  ///< Comparator 2 polarity selector
        constexpr uint32_t HYST = (2 << 16);  ///< Comparator 2 hysteresis selector
        constexpr uint32_t PWRMODE = (2 << 18);  ///< Comparator 2 power mode selector
        constexpr uint32_t BLANKSEL = (5 << 20);  ///< Comparator 2 blanking source selector
        constexpr uint32_t VALUE = (1U << 30);  ///< Comparator 2 output status
        constexpr uint32_t LOCK = (1U << 31);  ///< COMP2_CSR register lock
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_VREFBUF_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x30 - VREFBUF control and status register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x34 - VREFBUF calibration control register
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - SYSCFG configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x18 - SYSCFG configuration register 1
        volatile uint32_t ITLINE0;  ///< Offset: 0x80 - interrupt line 0 status register
        volatile uint32_t ITLINE1;  ///< Offset: 0x84 - interrupt line 1 status register
        volatile uint32_t ITLINE2;  ///< Offset: 0x88 - interrupt line 2 status register
        volatile uint32_t ITLINE3;  ///< Offset: 0x8C - interrupt line 3 status register
        volatile uint32_t ITLINE4;  ///< Offset: 0x90 - interrupt line 4 status register
        volatile uint32_t ITLINE5;  ///< Offset: 0x94 - interrupt line 5 status register
        volatile uint32_t ITLINE6;  ///< Offset: 0x98 - interrupt line 6 status register
        volatile uint32_t ITLINE7;  ///< Offset: 0x9C - interrupt line 7 status register
        volatile uint32_t ITLINE8;  ///< Offset: 0xA0 - interrupt line 8 status register
        volatile uint32_t ITLINE9;  ///< Offset: 0xA4 - interrupt line 9 status register
        volatile uint32_t ITLINE10;  ///< Offset: 0xA8 - interrupt line 10 status register
        volatile uint32_t ITLINE11;  ///< Offset: 0xAC - interrupt line 11 status register
        volatile uint32_t ITLINE12;  ///< Offset: 0xB0 - interrupt line 12 status register
        volatile uint32_t ITLINE13;  ///< Offset: 0xB4 - interrupt line 13 status register
        volatile uint32_t ITLINE14;  ///< Offset: 0xB8 - interrupt line 14 status register
        volatile uint32_t ITLINE15;  ///< Offset: 0xBC - interrupt line 15 status register
        volatile uint32_t ITLINE16;  ///< Offset: 0xC0 - interrupt line 16 status register
        volatile uint32_t ITLINE17;  ///< Offset: 0xC4 - interrupt line 17 status register
        volatile uint32_t ITLINE18;  ///< Offset: 0xC8 - interrupt line 18 status register
        volatile uint32_t ITLINE19;  ///< Offset: 0xCC - interrupt line 19 status register
        volatile uint32_t ITLINE20;  ///< Offset: 0xD0 - interrupt line 20 status register
        volatile uint32_t ITLINE21;  ///< Offset: 0xD4 - interrupt line 21 status register
        volatile uint32_t ITLINE22;  ///< Offset: 0xD8 - interrupt line 22 status register
        volatile uint32_t ITLINE23;  ///< Offset: 0xDC - interrupt line 23 status register
        volatile uint32_t ITLINE24;  ///< Offset: 0xE0 - interrupt line 24 status register
        volatile uint32_t ITLINE25;  ///< Offset: 0xE4 - interrupt line 25 status register
        volatile uint32_t ITLINE26;  ///< Offset: 0xE8 - interrupt line 26 status register
        volatile uint32_t ITLINE27;  ///< Offset: 0xEC - interrupt line 27 status register
        volatile uint32_t ITLINE28;  ///< Offset: 0xF0 - interrupt line 28 status register
        volatile uint32_t ITLINE29;  ///< Offset: 0xF4 - interrupt line 29 status register
        volatile uint32_t ITLINE30;  ///< Offset: 0xF8 - interrupt line 30 status register
        volatile uint32_t ITLINE31;  ///< Offset: 0xFC - interrupt line 31 status register
    };

    /// Peripheral instances
    inline Registers* SYSCFG_VREFBUF = reinterpret_cast<Registers*>(SYSCFG_VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
        constexpr uint32_t VRS = (3 << 4);  ///< Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t I2C_PAx_FMP = (2 << 22);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t I2C2_FMP = (1U << 21);  ///< FM+ driving capability activation for I2C2
        constexpr uint32_t I2C1_FMP = (1U << 20);  ///< FM+ driving capability activation for I2C1
        constexpr uint32_t I2C_PBx_FMP = (4 << 16);  ///< Fast Mode Plus (FM+) driving capability activation bits
        constexpr uint32_t UCPD2_STROBE = (1U << 10);  ///< Strobe signal bit for UCPD2
        constexpr uint32_t UCPD1_STROBE = (1U << 9);  ///< Strobe signal bit for UCPD1
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
        constexpr uint32_t IR_MOD = (2 << 6);  ///< IR Modulation Envelope signal selection.
        constexpr uint32_t IR_POL = (1U << 5);  ///< IR output polarity selection
        constexpr uint32_t PA11_PA12_RMP = (1U << 4);  ///< PA11 and PA12 remapping bit.
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t LOCKUP_LOCK = (1U << 0);  ///< Cortex-M0+ LOCKUP bit enable bit
        constexpr uint32_t SRAM_PARITY_LOCK = (1U << 1);  ///< SRAM parity lock bit
        constexpr uint32_t PVD_LOCK = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t ECC_LOCK = (1U << 3);  ///< ECC error lock bit
        constexpr uint32_t SRAM_PEF = (1U << 8);  ///< SRAM parity error flag
    }

    /// ITLINE0 Register bits
    namespace itline0_bits {
        constexpr uint32_t WWDG = (1U << 0);  ///< Window watchdog interrupt pending flag
    }

    /// ITLINE1 Register bits
    namespace itline1_bits {
        constexpr uint32_t PVDOUT = (1U << 0);  ///< PVD supply monitoring interrupt request pending (EXTI line 16).
    }

    /// ITLINE2 Register bits
    namespace itline2_bits {
        constexpr uint32_t TAMP = (1U << 0);  ///< TAMP
        constexpr uint32_t RTC = (1U << 1);  ///< RTC
    }

    /// ITLINE3 Register bits
    namespace itline3_bits {
        constexpr uint32_t FLASH_ITF = (1U << 0);  ///< FLASH_ITF
        constexpr uint32_t FLASH_ECC = (1U << 1);  ///< FLASH_ECC
    }

    /// ITLINE4 Register bits
    namespace itline4_bits {
        constexpr uint32_t RCC = (1U << 0);  ///< RCC
    }

    /// ITLINE5 Register bits
    namespace itline5_bits {
        constexpr uint32_t EXTI0 = (1U << 0);  ///< EXTI0
        constexpr uint32_t EXTI1 = (1U << 1);  ///< EXTI1
    }

    /// ITLINE6 Register bits
    namespace itline6_bits {
        constexpr uint32_t EXTI2 = (1U << 0);  ///< EXTI2
        constexpr uint32_t EXTI3 = (1U << 1);  ///< EXTI3
    }

    /// ITLINE7 Register bits
    namespace itline7_bits {
        constexpr uint32_t EXTI4 = (1U << 0);  ///< EXTI4
        constexpr uint32_t EXTI5 = (1U << 1);  ///< EXTI5
        constexpr uint32_t EXTI6 = (1U << 2);  ///< EXTI6
        constexpr uint32_t EXTI7 = (1U << 3);  ///< EXTI7
        constexpr uint32_t EXTI8 = (1U << 4);  ///< EXTI8
        constexpr uint32_t EXTI9 = (1U << 5);  ///< EXTI9
        constexpr uint32_t EXTI10 = (1U << 6);  ///< EXTI10
        constexpr uint32_t EXTI11 = (1U << 7);  ///< EXTI11
        constexpr uint32_t EXTI12 = (1U << 8);  ///< EXTI12
        constexpr uint32_t EXTI13 = (1U << 9);  ///< EXTI13
        constexpr uint32_t EXTI14 = (1U << 10);  ///< EXTI14
        constexpr uint32_t EXTI15 = (1U << 11);  ///< EXTI15
    }

    /// ITLINE8 Register bits
    namespace itline8_bits {
        constexpr uint32_t UCPD1 = (1U << 0);  ///< UCPD1
        constexpr uint32_t UCPD2 = (1U << 1);  ///< UCPD2
    }

    /// ITLINE9 Register bits
    namespace itline9_bits {
        constexpr uint32_t DMA1_CH1 = (1U << 0);  ///< DMA1_CH1
    }

    /// ITLINE10 Register bits
    namespace itline10_bits {
        constexpr uint32_t DMA1_CH2 = (1U << 0);  ///< DMA1_CH1
        constexpr uint32_t DMA1_CH3 = (1U << 1);  ///< DMA1_CH3
    }

    /// ITLINE11 Register bits
    namespace itline11_bits {
        constexpr uint32_t DMAMUX = (1U << 0);  ///< DMAMUX
        constexpr uint32_t DMA1_CH4 = (1U << 1);  ///< DMA1_CH4
        constexpr uint32_t DMA1_CH5 = (1U << 2);  ///< DMA1_CH5
        constexpr uint32_t DMA1_CH6 = (1U << 3);  ///< DMA1_CH6
        constexpr uint32_t DMA1_CH7 = (1U << 4);  ///< DMA1_CH7
    }

    /// ITLINE12 Register bits
    namespace itline12_bits {
        constexpr uint32_t ADC = (1U << 0);  ///< ADC
        constexpr uint32_t COMP1 = (1U << 1);  ///< COMP1
        constexpr uint32_t COMP2 = (1U << 2);  ///< COMP2
    }

    /// ITLINE13 Register bits
    namespace itline13_bits {
        constexpr uint32_t TIM1_CCU = (1U << 0);  ///< TIM1_CCU
        constexpr uint32_t TIM1_TRG = (1U << 1);  ///< TIM1_TRG
        constexpr uint32_t TIM1_UPD = (1U << 2);  ///< TIM1_UPD
        constexpr uint32_t TIM1_BRK = (1U << 3);  ///< TIM1_BRK
    }

    /// ITLINE14 Register bits
    namespace itline14_bits {
        constexpr uint32_t TIM1_CC = (1U << 0);  ///< TIM1_CC
    }

    /// ITLINE15 Register bits
    namespace itline15_bits {
        constexpr uint32_t TIM2 = (1U << 0);  ///< TIM2
    }

    /// ITLINE16 Register bits
    namespace itline16_bits {
        constexpr uint32_t TIM3 = (1U << 0);  ///< TIM3
    }

    /// ITLINE17 Register bits
    namespace itline17_bits {
        constexpr uint32_t TIM6 = (1U << 0);  ///< TIM6
        constexpr uint32_t DAC = (1U << 1);  ///< DAC
        constexpr uint32_t LPTIM1 = (1U << 2);  ///< LPTIM1
    }

    /// ITLINE18 Register bits
    namespace itline18_bits {
        constexpr uint32_t TIM7 = (1U << 0);  ///< TIM7
        constexpr uint32_t LPTIM2 = (1U << 1);  ///< LPTIM2
    }

    /// ITLINE19 Register bits
    namespace itline19_bits {
        constexpr uint32_t TIM14 = (1U << 0);  ///< TIM14
    }

    /// ITLINE20 Register bits
    namespace itline20_bits {
        constexpr uint32_t TIM15 = (1U << 0);  ///< TIM15
    }

    /// ITLINE21 Register bits
    namespace itline21_bits {
        constexpr uint32_t TIM16 = (1U << 0);  ///< TIM16
    }

    /// ITLINE22 Register bits
    namespace itline22_bits {
        constexpr uint32_t TIM17 = (1U << 0);  ///< TIM17
    }

    /// ITLINE23 Register bits
    namespace itline23_bits {
        constexpr uint32_t I2C1 = (1U << 0);  ///< I2C1
    }

    /// ITLINE24 Register bits
    namespace itline24_bits {
        constexpr uint32_t I2C2 = (1U << 0);  ///< I2C2
    }

    /// ITLINE25 Register bits
    namespace itline25_bits {
        constexpr uint32_t SPI1 = (1U << 0);  ///< SPI1
    }

    /// ITLINE26 Register bits
    namespace itline26_bits {
        constexpr uint32_t SPI2 = (1U << 0);  ///< SPI2
    }

    /// ITLINE27 Register bits
    namespace itline27_bits {
        constexpr uint32_t USART1 = (1U << 0);  ///< USART1
    }

    /// ITLINE28 Register bits
    namespace itline28_bits {
        constexpr uint32_t USART2 = (1U << 0);  ///< USART2
    }

    /// ITLINE29 Register bits
    namespace itline29_bits {
        constexpr uint32_t USART3 = (1U << 0);  ///< USART3
        constexpr uint32_t USART4 = (1U << 1);  ///< USART4
        constexpr uint32_t USART5 = (1U << 2);  ///< USART5
    }

    /// ITLINE30 Register bits
    namespace itline30_bits {
        constexpr uint32_t USART2 = (1U << 0);  ///< CEC
    }

    /// ITLINE31 Register bits
    namespace itline31_bits {
        constexpr uint32_t RNG = (1U << 0);  ///< RNG
        constexpr uint32_t AES = (1U << 1);  ///< AES
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x4000B000;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t BKP0R;  ///< Offset: 0x100 - TAMP backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x104 - TAMP backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x108 - TAMP backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x10C - TAMP backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x110 - TAMP backup register
        volatile uint32_t HWCFGR2;  ///< Offset: 0x3EC - TAMP hardware configuration register 2
        volatile uint32_t HWCFGR1;  ///< Offset: 0x3F0 - TAMP hardware configuration register 1
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - EXTI IP Version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - EXTI Identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - EXTI Size ID register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< TAMP1E
        constexpr uint32_t TAMP2E = (1U << 1);  ///< TAMP2E
        constexpr uint32_t ITAMP1E = (1U << 16);  ///< ITAMP1E
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< ITAMP3E
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< ITAMP4E
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< ITAMP5E
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< ITAMP6E
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< TAMP1NOER
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< TAMP2NOER
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< TAMP1MSK
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< TAMP2MSK
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< TAMP1TRG
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< TAMP2TRG
    }

    /// FLTCR Register bits
    namespace fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< TAMPFREQ
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMPFLT
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMPPRCH
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMPPUDIS
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< TAMP1IE
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< TAMP2IE
        constexpr uint32_t ITAMP1IE = (1U << 16);  ///< ITAMP1IE
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< ITAMP3IE
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< ITAMP4IE
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< ITAMP5IE
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< ITAMP6IE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1F
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2F
        constexpr uint32_t ITAMP1F = (1U << 16);  ///< ITAMP1F
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< ITAMP3F
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< ITAMP4F
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< ITAMP5F
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ITAMP6F
        constexpr uint32_t ITAMP7F = (1U << 22);  ///< ITAMP7F
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF:
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< ITAMP4MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< CTAMP1F
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< CTAMP2F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< CITAMP3F
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< CITAMP4F
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< CITAMP5F
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< CITAMP6F
        constexpr uint32_t CITAMP7F = (1U << 22);  ///< CITAMP7F
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// HWCFGR2 Register bits
    namespace hwcfgr2_bits {
        constexpr uint32_t PTIONREG_OUT = (8 << 0);  ///< PTIONREG_OUT
        constexpr uint32_t TRUST_ZONE = (4 << 8);  ///< TRUST_ZONE
    }

    /// HWCFGR1 Register bits
    namespace hwcfgr1_bits {
        constexpr uint32_t BACKUP_REGS = (8 << 0);  ///< BACKUP_REGS
        constexpr uint32_t TAMPER = (4 << 8);  ///< TAMPER
        constexpr uint32_t ACTIVE_TAMPER = (4 << 12);  ///< ACTIVE_TAMPER
        constexpr uint32_t INT_TAMPER = (16 << 16);  ///< INT_TAMPER
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor Revision number
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major Revision number
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IP Identification
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size Identification
    }

}

// ============================================================================
// UCPD1 Peripheral
// ============================================================================

namespace ucpd1 {
    /// Base addresses
    constexpr uint32_t UCPD1_BASE = 0x4000A000;

    /// UCPD1 Register structure
    struct Registers {
        volatile uint32_t CFG1;  ///< Offset: 0x00 - UCPD configuration register
        volatile uint32_t CFG2;  ///< Offset: 0x04 - UCPD configuration register 2
        volatile uint32_t CFG3;  ///< Offset: 0x08 - UCPD configuration register 3
        volatile uint32_t CR;  ///< Offset: 0x0C - UCPD control register
        volatile uint32_t IMR;  ///< Offset: 0x10 - UCPD Interrupt Mask Register
        volatile uint32_t SR;  ///< Offset: 0x14 - UCPD Status Register
        volatile uint32_t ICR;  ///< Offset: 0x18 - UCPD Interrupt Clear Register
        volatile uint32_t TX_ORDSET;  ///< Offset: 0x1C - UCPD Tx Ordered Set Type Register
        volatile uint32_t TX_PAYSZ;  ///< Offset: 0x20 - UCPD Tx Paysize Register
        volatile uint32_t TXDR;  ///< Offset: 0x24 - UCPD Tx Data Register
        volatile uint32_t RX_ORDSET;  ///< Offset: 0x28 - UCPD Rx Ordered Set Register
        volatile uint32_t RX_PAYSZ;  ///< Offset: 0x2C - UCPD Rx Paysize Register
        volatile uint32_t RXDR;  ///< Offset: 0x30 - UCPD Receive Data Register
        volatile uint32_t RX_ORDEXT1;  ///< Offset: 0x34 - UCPD Rx Ordered Set Extension Register
        volatile uint32_t RX_ORDEXT2;  ///< Offset: 0x38 - UCPD Rx Ordered Set Extension Register
        volatile uint32_t IPVER;  ///< Offset: 0x3F4 - UCPD IP ID register
        volatile uint32_t IPID;  ///< Offset: 0x3F8 - UCPD IP ID register
        volatile uint32_t MID;  ///< Offset: 0x3FC - UCPD IP ID register
    };

    /// Peripheral instances
    inline Registers* UCPD1 = reinterpret_cast<Registers*>(UCPD1_BASE);

    // Bit definitions
    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t HBITCLKDIV = (6 << 0);  ///< HBITCLKDIV
        constexpr uint32_t IFRGAP = (5 << 6);  ///< IFRGAP
        constexpr uint32_t TRANSWIN = (5 << 11);  ///< TRANSWIN
        constexpr uint32_t PSC_USBPDCLK = (3 << 17);  ///< PSC_USBPDCLK
        constexpr uint32_t RXORDSETEN = (9 << 20);  ///< RXORDSETEN
        constexpr uint32_t TXDMAEN = (1U << 29);  ///< TXDMAEN
        constexpr uint32_t RXDMAEN = (1U << 30);  ///< RXDMAEN:
        constexpr uint32_t UCPDEN = (1U << 31);  ///< UCPDEN
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t RXFILTDIS = (1U << 0);  ///< RXFILTDIS
        constexpr uint32_t RXFILT2N3 = (1U << 1);  ///< RXFILT2N3
        constexpr uint32_t FORCECLK = (1U << 2);  ///< FORCECLK
        constexpr uint32_t WUPEN = (1U << 3);  ///< WUPEN
    }

    /// CFG3 Register bits
    namespace cfg3_bits {
        constexpr uint32_t TRIM1_NG_CCRPD = (4 << 0);  ///< TRIM1_NG_CCRPD
        constexpr uint32_t TRIM1_NG_CC1A5 = (5 << 4);  ///< TRIM1_NG_CC1A5
        constexpr uint32_t TRIM1_NG_CC3A0 = (4 << 9);  ///< TRIM1_NG_CC3A0
        constexpr uint32_t TRIM2_NG_CCRPD = (4 << 16);  ///< TRIM2_NG_CCRPD
        constexpr uint32_t TRIM2_NG_CC1A5 = (5 << 20);  ///< TRIM2_NG_CC1A5
        constexpr uint32_t TRIM2_NG_CC3A0 = (4 << 25);  ///< TRIM2_NG_CC3A0
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TXMODE = (2 << 0);  ///< TXMODE
        constexpr uint32_t TXSEND = (1U << 2);  ///< TXSEND
        constexpr uint32_t TXHRST = (1U << 3);  ///< TXHRST
        constexpr uint32_t RXMODE = (1U << 4);  ///< RXMODE
        constexpr uint32_t PHYRXEN = (1U << 5);  ///< PHYRXEN
        constexpr uint32_t PHYCCSEL = (1U << 6);  ///< PHYCCSEL
        constexpr uint32_t ANASUBMODE = (2 << 7);  ///< ANASUBMODE
        constexpr uint32_t ANAMODE = (1U << 9);  ///< ANAMODE
        constexpr uint32_t CCENABLE = (2 << 10);  ///< CCENABLE
        constexpr uint32_t DBATTEN = (1U << 15);  ///< DBATTEN
        constexpr uint32_t FRSRXEN = (1U << 16);  ///< FRSRXEN
        constexpr uint32_t FRSTX = (1U << 17);  ///< FRSTX
        constexpr uint32_t RDCH = (1U << 18);  ///< RDCH
        constexpr uint32_t CC1TCDIS = (1U << 20);  ///< CC1TCDIS
        constexpr uint32_t CC2TCDIS = (1U << 21);  ///< CC2TCDIS
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t TXISIE = (1U << 0);  ///< TXISIE
        constexpr uint32_t TXMSGDISCIE = (1U << 1);  ///< TXMSGDISCIE
        constexpr uint32_t TXMSGSENTIE = (1U << 2);  ///< TXMSGSENTIE
        constexpr uint32_t TXMSGABTIE = (1U << 3);  ///< TXMSGABTIE
        constexpr uint32_t HRSTDISCIE = (1U << 4);  ///< HRSTDISCIE
        constexpr uint32_t HRSTSENTIE = (1U << 5);  ///< HRSTSENTIE
        constexpr uint32_t TXUNDIE = (1U << 6);  ///< TXUNDIE
        constexpr uint32_t RXNEIE = (1U << 8);  ///< RXNEIE
        constexpr uint32_t RXORDDETIE = (1U << 9);  ///< RXORDDETIE
        constexpr uint32_t RXHRSTDETIE = (1U << 10);  ///< RXHRSTDETIE
        constexpr uint32_t RXOVRIE = (1U << 11);  ///< RXOVRIE
        constexpr uint32_t RXMSGENDIE = (1U << 12);  ///< RXMSGENDIE
        constexpr uint32_t TYPECEVT1IE = (1U << 14);  ///< TYPECEVT1IE
        constexpr uint32_t TYPECEVT2IE = (1U << 15);  ///< TYPECEVT2IE
        constexpr uint32_t FRSEVTIE = (1U << 20);  ///< FRSEVTIE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TXIS = (1U << 0);  ///< TXIS
        constexpr uint32_t TXMSGDISC = (1U << 1);  ///< TXMSGDISC
        constexpr uint32_t TXMSGSENT = (1U << 2);  ///< TXMSGSENT
        constexpr uint32_t TXMSGABT = (1U << 3);  ///< TXMSGABT
        constexpr uint32_t HRSTDISC = (1U << 4);  ///< HRSTDISC
        constexpr uint32_t HRSTSENT = (1U << 5);  ///< HRSTSENT
        constexpr uint32_t TXUND = (1U << 6);  ///< TXUND
        constexpr uint32_t RXNE = (1U << 8);  ///< RXNE
        constexpr uint32_t RXORDDET = (1U << 9);  ///< RXORDDET
        constexpr uint32_t RXHRSTDET = (1U << 10);  ///< RXHRSTDET
        constexpr uint32_t RXOVR = (1U << 11);  ///< RXOVR
        constexpr uint32_t RXMSGEND = (1U << 12);  ///< RXMSGEND
        constexpr uint32_t RXERR = (1U << 13);  ///< RXERR
        constexpr uint32_t TYPECEVT1 = (1U << 14);  ///< TYPECEVT1
        constexpr uint32_t TYPECEVT2 = (1U << 15);  ///< TYPECEVT2
        constexpr uint32_t TYPEC_VSTATE_CC1 = (2 << 16);  ///< TYPEC_VSTATE_CC1
        constexpr uint32_t TYPEC_VSTATE_CC2 = (2 << 18);  ///< TYPEC_VSTATE_CC2
        constexpr uint32_t FRSEVT = (1U << 20);  ///< FRSEVT
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t TXMSGDISCCF = (1U << 1);  ///< TXMSGDISCCF
        constexpr uint32_t TXMSGSENTCF = (1U << 2);  ///< TXMSGSENTCF
        constexpr uint32_t TXMSGABTCF = (1U << 3);  ///< TXMSGABTCF
        constexpr uint32_t HRSTDISCCF = (1U << 4);  ///< HRSTDISCCF
        constexpr uint32_t HRSTSENTCF = (1U << 5);  ///< HRSTSENTCF
        constexpr uint32_t TXUNDCF = (1U << 6);  ///< TXUNDCF
        constexpr uint32_t RXORDDETCF = (1U << 9);  ///< RXORDDETCF
        constexpr uint32_t RXHRSTDETCF = (1U << 10);  ///< RXHRSTDETCF
        constexpr uint32_t RXOVRCF = (1U << 11);  ///< RXOVRCF
        constexpr uint32_t RXMSGENDCF = (1U << 12);  ///< RXMSGENDCF
        constexpr uint32_t TYPECEVT1CF = (1U << 14);  ///< TYPECEVT1CF
        constexpr uint32_t TYPECEVT2CF = (1U << 15);  ///< TYPECEVT2CF
        constexpr uint32_t FRSEVTCF = (1U << 20);  ///< FRSEVTCF
    }

    /// TX_ORDSET Register bits
    namespace tx_ordset_bits {
        constexpr uint32_t TXORDSET = (20 << 0);  ///< TXORDSET
    }

    /// TX_PAYSZ Register bits
    namespace tx_paysz_bits {
        constexpr uint32_t TXPAYSZ = (10 << 0);  ///< TXPAYSZ
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< TXDATA
    }

    /// RX_ORDSET Register bits
    namespace rx_ordset_bits {
        constexpr uint32_t RXORDSET = (3 << 0);  ///< RXORDSET
        constexpr uint32_t RXSOP3OF4 = (1U << 3);  ///< RXSOP3OF4
        constexpr uint32_t RXSOPKINVALID = (3 << 4);  ///< RXSOPKINVALID
    }

    /// RX_PAYSZ Register bits
    namespace rx_paysz_bits {
        constexpr uint32_t RXPAYSZ = (10 << 0);  ///< RXPAYSZ
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< RXDATA
    }

    /// RX_ORDEXT1 Register bits
    namespace rx_ordext1_bits {
        constexpr uint32_t RXSOPX1 = (20 << 0);  ///< RXSOPX1
    }

    /// RX_ORDEXT2 Register bits
    namespace rx_ordext2_bits {
        constexpr uint32_t RXSOPX2 = (20 << 0);  ///< RXSOPX2
    }

    /// IPVER Register bits
    namespace ipver_bits {
        constexpr uint32_t IPVER = (32 << 0);  ///< IPVER
    }

    /// IPID Register bits
    namespace ipid_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IPID
    }

    /// MID Register bits
    namespace mid_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IPID
    }

}

// ============================================================================
// UCPD2 Peripheral
// ============================================================================

namespace ucpd2 {
    /// Base addresses
    constexpr uint32_t UCPD2_BASE = 0x4000A400;

    /// UCPD2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* UCPD2 = reinterpret_cast<Registers*>(UCPD2_BASE);

}

// ============================================================================
// HDMI Peripheral
// ============================================================================

namespace hdmi {
    /// Base addresses
    constexpr uint32_t HDMI_CEC_BASE = 0x40007800;

    /// HDMI Register structure
    struct Registers {
        volatile uint32_t CEC_CR;  ///< Offset: 0x00 - CEC control register
        volatile uint32_t CEC_CFGR;  ///< Offset: 0x04 - This register is used to configure the HDMI-CEC...
        volatile uint32_t CEC_TXDR;  ///< Offset: 0x08 - CEC Tx data register
        volatile uint32_t CEC_RXDR;  ///< Offset: 0x0C - CEC Rx Data Register
        volatile uint32_t CEC_ISR;  ///< Offset: 0x10 - CEC Interrupt and Status Register
        volatile uint32_t CEC_IER;  ///< Offset: 0x14 - CEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* HDMI_CEC = reinterpret_cast<Registers*>(HDMI_CEC_BASE);

    // Bit definitions
    /// CEC_CR Register bits
    namespace cec_cr_bits {
        constexpr uint32_t CECEN = (1U << 0);  ///< CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
        constexpr uint32_t TXSOM = (1U << 1);  ///< Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
        constexpr uint32_t TXEOM = (1U << 2);  ///< Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
    }

    /// CEC_CFGR Register bits
    namespace cec_cfgr_bits {
        constexpr uint32_t SFT = (3 << 0);  ///< Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods
        constexpr uint32_t RXTOL = (1U << 3);  ///< Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
        constexpr uint32_t BRESTP = (1U << 4);  ///< Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
        constexpr uint32_t BREGEN = (1U << 5);  ///< Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
        constexpr uint32_t LBPEGEN = (1U << 6);  ///< Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
        constexpr uint32_t BRDNOGEN = (1U << 7);  ///< Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
        constexpr uint32_t SFTOPT = (1U << 8);  ///< SFT Option Bit The SFTOPT bit is set and cleared by software.
        constexpr uint32_t OAR = (15 << 16);  ///< Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
        constexpr uint32_t LSTN = (1U << 31);  ///< Listen mode LSTN bit is set and cleared by software.
    }

    /// CEC_TXDR Register bits
    namespace cec_txdr_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
    }

    /// CEC_RXDR Register bits
    namespace cec_rxdr_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
    }

    /// CEC_ISR Register bits
    namespace cec_isr_bits {
        constexpr uint32_t RXBR = (1U << 0);  ///< Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
        constexpr uint32_t RXEND = (1U << 1);  ///< End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
        constexpr uint32_t RXOVR = (1U << 2);  ///< Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
        constexpr uint32_t BRE = (1U << 3);  ///< Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
        constexpr uint32_t SBPE = (1U << 4);  ///< Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
        constexpr uint32_t LBPE = (1U << 5);  ///< Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
        constexpr uint32_t RXACKE = (1U << 6);  ///< Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
        constexpr uint32_t ARBLST = (1U << 7);  ///< Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
        constexpr uint32_t TXBR = (1U << 8);  ///< Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
        constexpr uint32_t TXEND = (1U << 9);  ///< End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
        constexpr uint32_t TXUDR = (1U << 10);  ///< Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
        constexpr uint32_t TXERR = (1U << 11);  ///< Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
        constexpr uint32_t TXACKE = (1U << 12);  ///< Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
    }

    /// CEC_IER Register bits
    namespace cec_ier_bits {
        constexpr uint32_t RXBRIE = (1U << 0);  ///< Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.
        constexpr uint32_t RXENDIE = (1U << 1);  ///< End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
        constexpr uint32_t RXOVRIE = (1U << 2);  ///< Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
        constexpr uint32_t BREIE = (1U << 3);  ///< Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
        constexpr uint32_t SBPEIE = (1U << 4);  ///< Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
        constexpr uint32_t LBPEIE = (1U << 5);  ///< Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
        constexpr uint32_t RXACKIE = (1U << 6);  ///< Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
        constexpr uint32_t ARBLSTIE = (1U << 7);  ///< Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
        constexpr uint32_t TXBRIE = (1U << 8);  ///< Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
        constexpr uint32_t TXENDIE = (1U << 9);  ///< Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
        constexpr uint32_t TXUDRIE = (1U << 10);  ///< Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
        constexpr uint32_t TXERRIE = (1U << 11);  ///< Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
        constexpr uint32_t TXACKIE = (1U << 12);  ///< Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC Sample and Hold sample time register 2
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
        volatile uint32_t IP_HWCFGR0;  ///< Offset: 0x3F0 - DAC IP Hardware Configuration Register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - EXTI IP Version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - EXTI Identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - EXTI Size ID register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL2 = (4 << 18);  ///< DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
    }

    /// IP_HWCFGR0 Register bits
    namespace ip_hwcfgr0_bits {
        constexpr uint32_t DUAL = (4 << 0);  ///< Dual DAC capability
        constexpr uint32_t LFSR = (4 << 4);  ///< Pseudonoise wave generation capability
        constexpr uint32_t TRIANGLE = (4 << 8);  ///< Triangle wave generation capability
        constexpr uint32_t SAMPLE = (4 << 12);  ///< Sample and hold mode capability
        constexpr uint32_t OR_CFG = (8 << 16);  ///< option register bit width
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor Revision number
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major Revision number
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IP Identification
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size Identification
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1_0 = (1U << 0);  ///< Interface address
        constexpr uint32_t OA1_7_1 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA1_8_9 = (2 << 8);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - status clear register
        volatile uint32_t HWCFGR;  ///< Offset: 0x3F0 - hardware configuration register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - EXTI IP Version register
        volatile uint32_t IPIDR;  ///< Offset: 0x3F8 - EXTI Identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - EXTI Size ID register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< WUCKSEL
        constexpr uint32_t TSEDGE = (1U << 3);  ///< TSEDGE
        constexpr uint32_t REFCKON = (1U << 4);  ///< REFCKON
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< BYPSHAD
        constexpr uint32_t FMT = (1U << 6);  ///< FMT
        constexpr uint32_t ALRAE = (1U << 8);  ///< ALRAE
        constexpr uint32_t ALRBE = (1U << 9);  ///< ALRBE
        constexpr uint32_t WUTE = (1U << 10);  ///< WUTE
        constexpr uint32_t TSE = (1U << 11);  ///< TSE
        constexpr uint32_t ALRAIE = (1U << 12);  ///< ALRAIE
        constexpr uint32_t ALRBIE = (1U << 13);  ///< ALRBIE
        constexpr uint32_t WUTIE = (1U << 14);  ///< WUTIE
        constexpr uint32_t TSIE = (1U << 15);  ///< TSIE
        constexpr uint32_t ADD1H = (1U << 16);  ///< ADD1H
        constexpr uint32_t SUB1H = (1U << 17);  ///< SUB1H
        constexpr uint32_t BKP = (1U << 18);  ///< BKP
        constexpr uint32_t COSEL = (1U << 19);  ///< COSEL
        constexpr uint32_t POL = (1U << 20);  ///< POL
        constexpr uint32_t OSEL = (2 << 21);  ///< OSEL
        constexpr uint32_t COE = (1U << 23);  ///< COE
        constexpr uint32_t ITSE = (1U << 24);  ///< ITSE
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
    }

    /// HWCFGR Register bits
    namespace hwcfgr_bits {
        constexpr uint32_t ALARMB = (4 << 0);  ///< ALARMB
        constexpr uint32_t WAKEUP = (4 << 4);  ///< WAKEUP
        constexpr uint32_t SMOOTH_CALIB = (4 << 8);  ///< SMOOTH_CALIB
        constexpr uint32_t TIMESTAMP = (4 << 12);  ///< TIMESTAMP
        constexpr uint32_t OPTIONREG_OUT = (8 << 16);  ///< OPTIONREG_OUT
        constexpr uint32_t TRUST_ZONE = (4 << 24);  ///< TRUST_ZONE
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor Revision number
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major Revision number
    }

    /// IPIDR Register bits
    namespace ipidr_bits {
        constexpr uint32_t IPID = (32 << 0);  ///< IP Identification
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size Identification
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER;  ///< Offset: 0x00 - Interrupt Set Enable Register
        volatile uint32_t ICER;  ///< Offset: 0x80 - Interrupt Clear Enable Register
        volatile uint32_t ISPR;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ICPR;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register 1
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register 2
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register 3
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register 4
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register 5
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register 6
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register 7
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// ISER Register bits
    namespace iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER Register bits
    namespace icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR Register bits
    namespace ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR Register bits
    namespace icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< priority for interrupt 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< priority for interrupt 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< priority for interrupt 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< priority for interrupt 3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_5 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_6 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_7 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t PRI_8 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_9 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_10 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_11 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t PRI_12 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_13 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_14 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_15 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t PRI_16 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_17 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_18 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_19 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t PRI_20 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_21 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_22 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_23 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t PRI_24 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_25 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_26 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_27 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t PRI_28 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_29 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_30 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_31 = (8 << 24);  ///< priority for interrupt n
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000ED90;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t MPU_TYPER;  ///< Offset: 0x00 - MPU type register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0x04 - MPU control register
        volatile uint32_t MPU_RNR;  ///< Offset: 0x08 - MPU region number register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0x0C - MPU region base address register
        volatile uint32_t MPU_RASR;  ///< Offset: 0x10 - MPU region attribute and size register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// MPU_TYPER Register bits
    namespace mpu_typer_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate flag
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables the MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enables the operation of MPU during hard fault
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enable priviliged software access to default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< MPU region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< Size of the MPU protection region
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< memory attribute
        constexpr uint32_t C = (1U << 17);  ///< memory attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable memory attribute
        constexpr uint32_t TEX = (3 << 19);  ///< memory attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

}

// ============================================================================
// STK Peripheral
// ============================================================================

namespace stk {
    /// Base addresses
    constexpr uint32_t STK_BASE = 0xE000E010;

    /// STK Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick control and status register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick reload value register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick current value register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick calibration value register
    };

    /// Peripheral instances
    inline Registers* STK = reinterpret_cast<Registers*>(STK_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick exception request enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source selection
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< COUNTFLAG
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< RELOAD value
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Calibration value
        constexpr uint32_t SKEW = (1U << 30);  ///< SKEW flag: Indicates whether the TENMS value is exact
        constexpr uint32_t NOREF = (1U << 31);  ///< NOREF flag. Reads as zero
    }

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED00;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - CPUID base register
        volatile uint32_t ICSR;  ///< Offset: 0x04 - Interrupt control and state register
        volatile uint32_t VTOR;  ///< Offset: 0x08 - Vector table offset register
        volatile uint32_t AIRCR;  ///< Offset: 0x0C - Application interrupt and reset control register
        volatile uint32_t SCR;  ///< Offset: 0x10 - System control register
        volatile uint32_t CCR;  ///< Offset: 0x14 - Configuration and control register
        volatile uint32_t SHPR2;  ///< Offset: 0x1C - System handler priority registers
        volatile uint32_t SHPR3;  ///< Offset: 0x20 - System handler priority registers
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Architecture = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active vector
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to base level
        constexpr uint32_t VECTPENDING = (7 << 12);  ///< Pending vector
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit.
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< SYSRESETREQ
        constexpr uint32_t ENDIANESS = (1U << 15);  ///< ENDIANESS
        constexpr uint32_t VECTKEYSTAT = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< SLEEPONEXIT
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< SLEEPDEEP
        constexpr uint32_t SEVEONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Configures how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< USERSETMPEND
        constexpr uint32_t UNALIGN__TRP = (1U << 3);  ///< UNALIGN_ TRP
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< DIV_0_TRP
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< BFHFNMIGN
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

}


} // namespace alloy::generated::stm32g07x

#endif // ALLOY_GENERATED_STM32G07X_PERIPHERALS_HPP