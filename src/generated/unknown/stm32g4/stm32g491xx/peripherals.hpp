/// Auto-generated code for STM32G491xx
/// Generated by Alloy Code Generator
/// Source: st_stm32g491.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:16
#ifndef ALLOY_GENERATED_STM32G491XX_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32G491XX_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32g491xx {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_dbgmcu = true;
    constexpr uint32_t num_dbgmcu_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 7;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 11;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 3;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 4;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 5;
    constexpr bool has_fmac = true;
    constexpr uint32_t num_fmac_instances = 1;
    constexpr bool has_cordic = true;
    constexpr uint32_t num_cordic_instances = 1;
    constexpr bool has_sai = true;
    constexpr uint32_t num_sai_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_fpu = true;
    constexpr uint32_t num_fpu_instances = 2;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_stk = true;
    constexpr uint32_t num_stk_instances = 1;
    constexpr bool has_scb = true;
    constexpr uint32_t num_scb_instances = 2;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 2;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_ucpd1 = true;
    constexpr uint32_t num_ucpd1_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_crs = true;
    constexpr uint32_t num_crs_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbgmcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 11;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct fmac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cordic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpu_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct stk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ucpd1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crs_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 7;
    constexpr uint32_t max_gpio_pins = 112;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_lpuart1 = true;
}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C3_BASE = 0x40007800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t PDKEYR;  ///< Offset: 0x04 - Power down key register
        volatile uint32_t KEYR;  ///< Offset: 0x08 - Flash key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x0C - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x10 - Status register
        volatile uint32_t CR;  ///< Offset: 0x14 - Flash control register
        volatile uint32_t ECCR;  ///< Offset: 0x18 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x20 - Flash option register
        volatile uint32_t PCROP1SR;  ///< Offset: 0x24 - Flash Bank 1 PCROP Start address register
        volatile uint32_t PCROP1ER;  ///< Offset: 0x28 - Flash Bank 1 PCROP End address register
        volatile uint32_t WRP1AR;  ///< Offset: 0x2C - Flash Bank 1 WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x30 - Flash Bank 1 WRP area B address register
        volatile uint32_t SEC1R;  ///< Offset: 0x70 - securable area bank1 register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (4 << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< Instruction cache enable
        constexpr uint32_t DCEN = (1U << 10);  ///< Data cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< Instruction cache reset
        constexpr uint32_t DCRST = (1U << 12);  ///< Data cache reset
        constexpr uint32_t RUN_PD = (1U << 13);  ///< Flash Power-down mode during Low-power run mode
        constexpr uint32_t SLEEP_PD = (1U << 14);  ///< Flash Power-down mode during Low-power sleep mode
        constexpr uint32_t DBG_SWEN = (1U << 18);  ///< Debug software enable
    }

    /// PDKEYR Register bits
    namespace pdkeyr_bits {
        constexpr uint32_t PDKEYR = (32 << 0);  ///< RUN_PD in FLASH_ACR key
    }

    /// KEYR Register bits
    namespace keyr_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< KEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error
        constexpr uint32_t MISERR = (1U << 8);  ///< Fast programming data miss error
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error
        constexpr uint32_t RDERR = (1U << 14);  ///< PCROP read error
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option validity error
        constexpr uint32_t BSY = (1U << 16);  ///< Busy
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Programming
        constexpr uint32_t PER = (1U << 1);  ///< Page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Bank 1 Mass erase
        constexpr uint32_t PNB = (7 << 3);  ///< Page number
        constexpr uint32_t STRT = (1U << 16);  ///< Start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming
        constexpr uint32_t EOPIE = (1U << 24);  ///< End of operation interrupt enable
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable
        constexpr uint32_t RDERRIE = (1U << 26);  ///< PCROP read error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t SEC_PROT1 = (1U << 28);  ///< SEC_PROT1
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (19 << 0);  ///< ECC fail address
        constexpr uint32_t BK_ECC = (1U << 21);  ///< BK_ECC
        constexpr uint32_t SYSF_ECC = (1U << 22);  ///< SYSF_ECC
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECCIE
        constexpr uint32_t ECCC2 = (1U << 28);  ///< ECC correction
        constexpr uint32_t ECCD2 = (1U << 29);  ///< ECC2 detection
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t BOR_LEV = (3 << 8);  ///< BOR reset Level
        constexpr uint32_t nRST_STOP = (1U << 12);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 13);  ///< nRST_STDBY
        constexpr uint32_t nRST_SHDW = (1U << 14);  ///< nRST_SHDW
        constexpr uint32_t IDWG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t nBOOT1 = (1U << 23);  ///< Boot configuration
        constexpr uint32_t SRAM2_PE = (1U << 24);  ///< SRAM2 parity check enable
        constexpr uint32_t SRAM2_RST = (1U << 25);  ///< SRAM2 Erase when system reset
        constexpr uint32_t nSWBOOT0 = (1U << 26);  ///< nSWBOOT0
        constexpr uint32_t nBOOT0 = (1U << 27);  ///< nBOOT0
        constexpr uint32_t NRST_MODE = (2 << 28);  ///< NRST_MODE
        constexpr uint32_t IRHEN = (1U << 30);  ///< IRHEN
    }

    /// PCROP1SR Register bits
    namespace pcrop1sr_bits {
        constexpr uint32_t PCROP1_STRT = (15 << 0);  ///< Bank 1 PCROP area start offset
    }

    /// PCROP1ER Register bits
    namespace pcrop1er_bits {
        constexpr uint32_t PCROP1_END = (15 << 0);  ///< Bank 1 PCROP area end offset
        constexpr uint32_t PCROP_RDP = (1U << 31);  ///< PCROP area preserved when RDP level decreased
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (7 << 0);  ///< Bank 1 WRP first area start offset
        constexpr uint32_t WRP1A_END = (7 << 16);  ///< Bank 1 WRP first area A end offset
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (7 << 0);  ///< Bank 1 WRP second area B end offset
        constexpr uint32_t WRP1B_END = (7 << 16);  ///< Bank 1 WRP second area B start offset
    }

    /// SEC1R Register bits
    namespace sec1r_bits {
        constexpr uint32_t BOOT_LOCK = (1U << 16);  ///< BOOT_LOCK
        constexpr uint32_t SEC_SIZE1 = (8 << 0);  ///< SEC_SIZE1
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0xE0042000;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - MCU Device ID Code Register
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU Configuration Register
        volatile uint32_t APB1L_FZ;  ///< Offset: 0x08 - APB Low Freeze Register 1
        volatile uint32_t APB1H_FZ;  ///< Offset: 0x0C - APB Low Freeze Register 2
        volatile uint32_t APB2_FZ;  ///< Offset: 0x10 - APB High Freeze Register
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (16 << 0);  ///< Device Identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision Identifier
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_SLEEP = (1U << 0);  ///< Debug Sleep Mode
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop Mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby Mode
        constexpr uint32_t TRACE_IOEN = (1U << 5);  ///< Trace pin assignment control
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< Trace pin assignment control
    }

    /// APB1L_FZ Register bits
    namespace apb1l_fz_bits {
        constexpr uint32_t DBG_TIMER2_STOP = (1U << 0);  ///< Debug Timer 2 stopped when Core is halted
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 counter stopped when core is halted
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< TIM4 counter stopped when core is halted
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< TIM5 counter stopped when core is halted
        constexpr uint32_t DBG_TIMER6_STOP = (1U << 4);  ///< Debug Timer 6 stopped when Core is halted
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 counter stopped when core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< Debug RTC stopped when Core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Debug Window Wachdog stopped when Core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Debug Independent Wachdog stopped when Core is halted
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout mode stopped when core is halted
        constexpr uint32_t DBG_I2C2_STOP = (1U << 22);  ///< I2C2 SMBUS timeout mode stopped when core is halted
        constexpr uint32_t DBG_I2C3_STOP = (1U << 30);  ///< I2C3 SMBUS timeout mode stopped when core is halted
        constexpr uint32_t DBG_LPTIMER_STOP = (1U << 31);  ///< LPTIM1 counter stopped when core is halted
    }

    /// APB1H_FZ Register bits
    namespace apb1h_fz_bits {
        constexpr uint32_t DBG_I2C4_STOP = (1U << 1);  ///< DBG_I2C4_STOP
    }

    /// APB2_FZ Register bits
    namespace apb2_fz_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM8_STOP = (1U << 13);  ///< TIM8 counter stopped when core is halted
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< TIM15 counter stopped when core is halted
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< TIM16 counter stopped when core is halted
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< TIM17 counter stopped when core is halted
        constexpr uint32_t DBG_TIM20_STOP = (1U << 20);  ///< TIM20counter stopped when core is halted
        constexpr uint32_t DBG_HRTIM0_STOP = (1U << 26);  ///< DBG_HRTIM0_STOP
        constexpr uint32_t DBG_HRTIM1_STOP = (1U << 27);  ///< DBG_HRTIM0_STOP
        constexpr uint32_t DBG_HRTIM2_STOP = (1U << 28);  ///< DBG_HRTIM0_STOP
        constexpr uint32_t DBG_HRTIM3_STOP = (1U << 29);  ///< DBG_HRTIM0_STOP
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t RCC_CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t RCC_ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t RCC_CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t RCC_PLLCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t RCC_CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t RCC_CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t RCC_CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t RCC_AHB1RSTR;  ///< Offset: 0x28 - AHB1 peripheral reset register
        volatile uint32_t RCC_AHB2RSTR;  ///< Offset: 0x2C - AHB2 peripheral reset register
        volatile uint32_t RCC_AHB3RSTR;  ///< Offset: 0x30 - AHB3 peripheral reset register
        volatile uint32_t RCC_APB1RSTR1;  ///< Offset: 0x38 - APB1 peripheral reset register 1
        volatile uint32_t RCC_APB1RSTR2;  ///< Offset: 0x3C - APB1 peripheral reset register 2
        volatile uint32_t RCC_APB2RSTR;  ///< Offset: 0x40 - APB2 peripheral reset register
        volatile uint32_t RCC_AHB1ENR;  ///< Offset: 0x48 - AHB1 peripheral clock enable register
        volatile uint32_t RCC_AHB2ENR;  ///< Offset: 0x4C - AHB2 peripheral clock enable register
        volatile uint32_t RCC_AHB3ENR;  ///< Offset: 0x50 - AHB3 peripheral clock enable register
        volatile uint32_t RCC_APB1ENR1;  ///< Offset: 0x58 - APB1 peripheral clock enable register 1
        volatile uint32_t RCC_APB1ENR2;  ///< Offset: 0x5C - APB1 peripheral clock enable register 2
        volatile uint32_t RCC_APB2ENR;  ///< Offset: 0x60 - APB2 peripheral clock enable register
        volatile uint32_t RCC_AHB1SMENR;  ///< Offset: 0x68 - AHB1 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t RCC_AHB2SMENR;  ///< Offset: 0x6C - AHB2 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t RCC_AHB3SMENR;  ///< Offset: 0x70 - AHB3 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t RCC_APB1SMENR1;  ///< Offset: 0x78 - APB1 peripheral clocks enable in Sleep and Stop modes register 1
        volatile uint32_t RCC_APB1SMENR2;  ///< Offset: 0x7C - APB1 peripheral clocks enable in Sleep and Stop modes register 2
        volatile uint32_t RCC_APB2SMENR;  ///< Offset: 0x80 - APB2 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t RCC_CCIPR;  ///< Offset: 0x88 - Peripherals independent clock configuration register
        volatile uint32_t RCC_BDCR;  ///< Offset: 0x90 - RTC domain control register
        volatile uint32_t RCC_CSR;  ///< Offset: 0x94 - Control/status register
        volatile uint32_t RCC_CRRCR;  ///< Offset: 0x98 - Clock recovery RC register
        volatile uint32_t RCC_CCIPR2;  ///< Offset: 0x9C - Peripherals independent clock configuration register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// RCC_CR Register bits
    namespace rcc_cr_bits {
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable Set and cleared by software. Cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby or Shutdown mode. Set by hardware to force the HSI16 oscillator ON when STOPWUCK=1 or HSIASFS = 1 when leaving Stop modes, or in case of failure of the HSE crystal oscillator. This bit is set by hardware if the HSI16 is used directly or indirectly as system clock.
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 always enable for peripheral kernels. Set and cleared by software to force HSI16 ON even in Stop modes. The HSI16 can only feed USARTs and I<sup>2</sup>Cs peripherals configured with HSI16 as kernel clock. Keeping the HSI16 ON in Stop mode allows to avoid slowing down the communication speed because of the HSI16 startup time. This bit has no effect on HSION value.
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag Set by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION. Note: Once the HSION bit is cleared, HSIRDY goes low after 6 HSI16 clock cycles.
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable Set and cleared by software. Cleared by hardware to stop the HSE oscillator when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag Set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after 6 HSE clock cycles.
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass Set and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device. The HSEBYP bit can be written only if the HSE oscillator is disabled.
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable Set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
        constexpr uint32_t PLLON = (1U << 24);  ///< Main PLL enable Set and cleared by software to enable the main PLL. Cleared by hardware when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the PLL clock is used as the system clock.
        constexpr uint32_t PLLRDY = (1U << 25);  ///< Main PLL clock ready flag Set by hardware to indicate that the main PLL is locked.
    }

    /// RCC_ICSCR Register bits
    namespace rcc_icscr_bits {
        constexpr uint32_t HSICAL = (8 << 16);  ///< HSI16 clock calibration These bits are initialized at startup with the factory-programmed HSI16 calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
        constexpr uint32_t HSITRIM = (7 << 24);  ///< HSI16 clock trimming These bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI16. The default value is 16, which, when added to the HSICAL value, should trim the HSI16 to 16 MHz � 1 %.
    }

    /// RCC_CFGR Register bits
    namespace rcc_cfgr_bits {
        constexpr uint32_t SW = (2 << 0);  ///< System clock switch Set and cleared by software to select system clock source (SYSCLK). Configured by hardware to force HSI16 oscillator selection when exiting stop and standby modes or in case of failure of the HSE oscillator.
        constexpr uint32_t SWS = (2 << 2);  ///< System clock switch status Set and cleared by hardware to indicate which clock source is used as system clock.
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler Set and cleared by software to control the division factor of the AHB clock. Note: Depending on the device voltage range, the software has to set correctly these bits to ensure that the system frequency does not exceed the maximum allowed frequency (for more details please refer to Section 6.1.5: Dynamic voltage scaling management). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value has been taken into account. 0xxx: SYSCLK not divided
        constexpr uint32_t PPRE1 = (3 << 8);  ///< APB1 prescaler Set and cleared by software to control the division factor of the APB1 clock (PCLK1). 0xx: HCLK not divided
        constexpr uint32_t PPRE2 = (3 << 11);  ///< APB2 prescaler Set and cleared by software to control the division factor of the APB2 clock (PCLK2). 0xx: HCLK not divided
        constexpr uint32_t MCOSEL = (4 << 24);  ///< Microcontroller clock output Set and cleared by software. Others: Reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
        constexpr uint32_t MCOPRE = (3 << 28);  ///< Microcontroller clock output prescaler These bits are set and cleared by software. It is highly recommended to change this prescaler before MCO output is enabled. Others: not allowed
    }

    /// RCC_PLLCFGR Register bits
    namespace rcc_pllcfgr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< Main PLL entry clock source Set and cleared by software to select PLL clock source. These bits can be written only when PLL is disabled. In order to save power, when no PLL is used, the value of PLLSRC should be 00.
        constexpr uint32_t PLLM = (4 << 4);  ///< Division factor for the main PLL input clock Set and cleared by software to divide the PLL input clock before the VCO. These bits can be written only when all PLLs are disabled. VCO input frequency = PLL input clock frequency / PLLM with 1 <= PLLM <= 16 ... Note: The software has to set these bits correctly to ensure that the VCO input frequency is within the range defined in the device datasheet.
        constexpr uint32_t PLLN = (7 << 8);  ///< Main PLL multiplication factor for VCO Set and cleared by software to control the multiplication factor of the VCO. These bits can be written only when the PLL is disabled. VCO output frequency = VCO input frequency x PLLN with 8 =< PLLN =< 127 ... ... Note: The software has to set correctly these bits to assure that the VCO output frequency is within the range defined in the device datasheet.
        constexpr uint32_t PLLPEN = (1U << 16);  ///< Main PLL PLL “P” clock output enable Set and reset by software to enable the PLL “P” clock output of the PLL. In order to save power, when the PLL “P” clock output of the PLL is not used, the value of PLLPEN should be 0.
        constexpr uint32_t PLLP = (1U << 17);  ///< Main PLL division factor for PLL “P” clock. Set and cleared by software to control the frequency of the main PLL output clock PLL “P” clock. These bits can be written only if PLL is disabled. When the PLLPDIV[4:0] is set to “00000”PLL “P” output clock frequency = VCO frequency / PLLP with PLLP =7, or 17 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
        constexpr uint32_t PLLQEN = (1U << 20);  ///< Main PLL “Q” clock output enable Set and reset by software to enable the PLL “Q” clock output of the PLL. In order to save power, when the PLL “Q” clock output of the PLL is not used, the value of PLLQEN should be 0.
        constexpr uint32_t PLLQ = (2 << 21);  ///< Main PLL division factor for PLL “Q” clock. Set and cleared by software to control the frequency of the main PLL output clock PLL “Q” clock. This output can be selected for USB, RNG, SAI (48 MHz clock). These bits can be written only if PLL is disabled. PLL “Q” output clock frequency = VCO frequency / PLLQ with PLLQ = 2, 4, 6, or 8 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
        constexpr uint32_t PLLREN = (1U << 24);  ///< PLL “R” clock output enable Set and reset by software to enable the PLL “R” clock output of the PLL (used as system clock). This bit cannot be written when PLL “R” clock output of the PLL is used as System Clock. In order to save power, when the PLL “R” clock output of the PLL is not used, the value of PLLREN should be 0.
        constexpr uint32_t PLLR = (2 << 25);  ///< Main PLL division factor for PLL “R” clock (system clock) Set and cleared by software to control the frequency of the main PLL output clock PLLCLK. This output can be selected as system clock. These bits can be written only if PLL is disabled. PLL “R” output clock frequency = VCO frequency / PLLR with PLLR = 2, 4, 6, or 8 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
        constexpr uint32_t PLLPDIV = (5 << 27);  ///< Main PLLP division factor Set and cleared by software to control the PLL “P” frequency. PLL “P” output clock frequency = VCO frequency / PLLPDIV. ....
    }

    /// RCC_CIER Register bits
    namespace rcc_cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization.
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI16 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization.
        constexpr uint32_t PLLRDYIE = (1U << 5);  ///< PLL ready interrupt enable Set and cleared by software to enable/disable interrupt caused by PLL lock.
        constexpr uint32_t LSECSSIE = (1U << 9);  ///< LSE clock security system interrupt enable Set and cleared by software to enable/disable interrupt caused by the clock security system on LSE.
        constexpr uint32_t HSI48RDYIE = (1U << 10);  ///< HSI48 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the internal HSI48 oscillator.
    }

    /// RCC_CIFR Register bits
    namespace rcc_cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag Set by hardware when the LSI clock becomes stable and LSIRDYDIE is set. Cleared by software setting the LSIRDYC bit.
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag Set by hardware when the LSE clock becomes stable and LSERDYDIE is set. Cleared by software setting the LSERDYC bit.
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI16 ready interrupt flag Set by hardware when the HSI16 clock becomes stable and HSIRDYDIE is set in a response to setting the HSION (refer to Clock control register (RCC_CR)). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. Cleared by software setting the HSIRDYC bit.
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag Set by hardware when the HSE clock becomes stable and HSERDYDIE is set. Cleared by software setting the HSERDYC bit.
        constexpr uint32_t PLLRDYF = (1U << 5);  ///< PLL ready interrupt flag Set by hardware when the PLL locks and PLLRDYDIE is set. Cleared by software setting the PLLRDYC bit.
        constexpr uint32_t CSSF = (1U << 8);  ///< Clock security system interrupt flag Set by hardware when a failure is detected in the HSE oscillator. Cleared by software setting the CSSC bit.
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE Clock security system interrupt flag Set by hardware when a failure is detected in the LSE oscillator. Cleared by software setting the LSECSSC bit.
        constexpr uint32_t HSI48RDYF = (1U << 10);  ///< HSI48 ready interrupt flag Set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set in a response to setting the HSI48ON (refer to Clock recovery RC register (RCC_CRRCR)). Cleared by software setting the HSI48RDYC bit.
    }

    /// RCC_CICR Register bits
    namespace rcc_cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear This bit is set by software to clear the LSIRDYF flag.
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear This bit is set by software to clear the LSERDYF flag.
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI16 ready interrupt clear This bit is set software to clear the HSIRDYF flag.
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear This bit is set by software to clear the HSERDYF flag.
        constexpr uint32_t PLLRDYC = (1U << 5);  ///< PLL ready interrupt clear This bit is set by software to clear the PLLRDYF flag.
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear This bit is set by software to clear the CSSF flag.
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear This bit is set by software to clear the LSECSSF flag.
        constexpr uint32_t HSI48RDYC = (1U << 10);  ///< HSI48 oscillator ready interrupt clear This bit is set by software to clear the HSI48RDYF flag.
    }

    /// RCC_AHB1RSTR Register bits
    namespace rcc_ahb1rstr_bits {
        constexpr uint32_t DMA1RST = (1U << 0);  ///< DMA1 reset Set and cleared by software.
        constexpr uint32_t DMA2RST = (1U << 1);  ///< DMA2 reset Set and cleared by software.
        constexpr uint32_t DMAMUX1RST = (1U << 2);  ///< Set and cleared by software.
        constexpr uint32_t CORDICRST = (1U << 3);  ///< Set and cleared by software
        constexpr uint32_t FMACRST = (1U << 4);  ///< Set and cleared by software
        constexpr uint32_t FLASHRST = (1U << 8);  ///< Flash memory interface reset Set and cleared by software. This bit can be activated only when the Flash memory is in power down mode.
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset Set and cleared by software.
    }

    /// RCC_AHB2RSTR Register bits
    namespace rcc_ahb2rstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< IO port A reset Set and cleared by software.
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< IO port B reset Set and cleared by software.
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< IO port C reset Set and cleared by software.
        constexpr uint32_t GPIODRST = (1U << 3);  ///< IO port D reset Set and cleared by software.
        constexpr uint32_t GPIOERST = (1U << 4);  ///< IO port E reset Set and cleared by software.
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< IO port F reset Set and cleared by software.
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< IO port G reset Set and cleared by software.
        constexpr uint32_t ADC12RST = (1U << 13);  ///< ADC12 reset Set and cleared by software.
        constexpr uint32_t ADC345RST = (1U << 14);  ///< ADC345 reset Set and cleared by software.
        constexpr uint32_t DAC1RST = (1U << 16);  ///< DAC1 reset Set and cleared by software.
        constexpr uint32_t DAC2RST = (1U << 17);  ///< DAC2 reset Set and cleared by software.
        constexpr uint32_t DAC3RST = (1U << 18);  ///< DAC3 reset Set and cleared by software.
        constexpr uint32_t DAC4RST = (1U << 19);  ///< DAC4 reset Set and cleared by software.
        constexpr uint32_t AESRST = (1U << 24);  ///< AESRST reset Set and cleared by software.
        constexpr uint32_t RNGRST = (1U << 26);  ///< RNG reset Set and cleared by software.
    }

    /// RCC_AHB3RSTR Register bits
    namespace rcc_ahb3rstr_bits {
        constexpr uint32_t FMCRST = (1U << 0);  ///< Flexible static memory controller reset Set and cleared by software.
        constexpr uint32_t QSPIRST = (1U << 8);  ///< QUADSPI reset Set and cleared by software.
    }

    /// RCC_APB1RSTR1 Register bits
    namespace rcc_apb1rstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 timer reset Set and cleared by software.
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset Set and cleared by software.
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM3 timer reset Set and cleared by software.
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 timer reset Set and cleared by software.
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 timer reset Set and cleared by software.
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 timer reset Set and cleared by software.
        constexpr uint32_t CRSRST = (1U << 8);  ///< CRS reset Set and cleared by software.
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset Set and cleared by software.
        constexpr uint32_t SPI3RST = (1U << 15);  ///< SPI3 reset Set and cleared by software.
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset Set and cleared by software.
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset Set and cleared by software.
        constexpr uint32_t UART4RST = (1U << 19);  ///< UART4 reset Set and cleared by software.
        constexpr uint32_t UART5RST = (1U << 20);  ///< UART5 reset Set and cleared by software.
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset Set and cleared by software.
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset Set and cleared by software.
        constexpr uint32_t USBRST = (1U << 23);  ///< USB device reset Set and reset by software.
        constexpr uint32_t FDCANRST = (1U << 25);  ///< FDCAN reset Set and reset by software.
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset Set and cleared by software.
        constexpr uint32_t I2C3RST = (1U << 30);  ///< I2C3 reset Set and cleared by software.
        constexpr uint32_t LPTIM1RST = (1U << 31);  ///< Low Power Timer 1 reset Set and cleared by software.
    }

    /// RCC_APB1RSTR2 Register bits
    namespace rcc_apb1rstr2_bits {
        constexpr uint32_t LPUART1RST = (1U << 0);  ///< Low-power UART 1 reset Set and cleared by software.
        constexpr uint32_t I2C4RST = (1U << 1);  ///< I2C4 reset Set and cleared by software
        constexpr uint32_t UCPD1RST = (1U << 8);  ///< UCPD1 reset Set and cleared by software.
    }

    /// RCC_APB2RSTR Register bits
    namespace rcc_apb2rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG + COMP + OPAMP + VREFBUF reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset Set and cleared by software.
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset Set and cleared by software.
        constexpr uint32_t TIM8RST = (1U << 13);  ///< TIM8 timer reset Set and cleared by software.
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset Set and cleared by software.
        constexpr uint32_t SPI4RST = (1U << 15);  ///< SPI4 reset Set and cleared by software.
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 timer reset Set and cleared by software.
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset Set and cleared by software.
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset Set and cleared by software.
        constexpr uint32_t TIM20RST = (1U << 20);  ///< TIM20 reset Set and cleared by software.
        constexpr uint32_t SAI1RST = (1U << 21);  ///< Serial audio interface 1 (SAI1) reset Set and cleared by software.
        constexpr uint32_t HRTIM1RST = (1U << 26);  ///< HRTIM1 reset Set and cleared by software.
    }

    /// RCC_AHB1ENR Register bits
    namespace rcc_ahb1enr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 clock enable Set and cleared by software.
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 clock enable Set and cleared by software.
        constexpr uint32_t DMAMUX1EN = (1U << 2);  ///< DMAMUX1 clock enable Set and reset by software.
        constexpr uint32_t CORDICEN = (1U << 3);  ///< CORDIC clock enable Set and reset by software.
        constexpr uint32_t FMACEN = (1U << 4);  ///< FMAC enable Set and reset by software.
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable Set and cleared by software. This bit can be disabled only when the Flash is in power down mode.
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable Set and cleared by software.
    }

    /// RCC_AHB2ENR Register bits
    namespace rcc_ahb2enr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< IO port A clock enable Set and cleared by software.
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< IO port B clock enable Set and cleared by software.
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< IO port C clock enable Set and cleared by software.
        constexpr uint32_t GPIODEN = (1U << 3);  ///< IO port D clock enable Set and cleared by software.
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< IO port E clock enable Set and cleared by software.
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< IO port F clock enable Set and cleared by software.
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< IO port G clock enable Set and cleared by software.
        constexpr uint32_t ADC12EN = (1U << 13);  ///< ADC12 clock enable Set and cleared by software.
        constexpr uint32_t ADC345EN = (1U << 14);  ///< ADC345 clock enable Set and cleared by software
        constexpr uint32_t DAC1EN = (1U << 16);  ///< DAC1 clock enable Set and cleared by software.
        constexpr uint32_t DAC2EN = (1U << 17);  ///< DAC2 clock enable Set and cleared by software.
        constexpr uint32_t DAC3EN = (1U << 18);  ///< DAC3 clock enable Set and cleared by software.
        constexpr uint32_t DAC4EN = (1U << 19);  ///< DAC4 clock enable Set and cleared by software.
        constexpr uint32_t AESEN = (1U << 24);  ///< AES clock enable Set and cleared by software.
        constexpr uint32_t RNGEN = (1U << 26);  ///< RNG enable Set and cleared by software.
    }

    /// RCC_AHB3ENR Register bits
    namespace rcc_ahb3enr_bits {
        constexpr uint32_t FMCEN = (1U << 0);  ///< Flexible static memory controller clock enable Set and cleared by software.
        constexpr uint32_t QSPIEN = (1U << 8);  ///< QUADSPI memory interface clock enable Set and cleared by software.
    }

    /// RCC_APB1ENR1 Register bits
    namespace rcc_apb1enr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 timer clock enable Set and cleared by software.
        constexpr uint32_t CRSEN = (1U << 8);  ///< CRS Recovery System clock enable Set and cleared by software.
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable Set and cleared by software
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable Set by software to enable the window watchdog clock. Reset by hardware system reset. This bit can also be set by hardware if the WWDG_SW option bit is reset.
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable Set and cleared by software.
        constexpr uint32_t SPI3EN = (1U << 15);  ///< SPI3 clock enable Set and cleared by software.
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable Set and cleared by software.
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable Set and cleared by software.
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 clock enable Set and cleared by software.
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 clock enable Set and cleared by software.
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable Set and cleared by software.
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable Set and cleared by software.
        constexpr uint32_t USBEN = (1U << 23);  ///< USB device clock enable Set and cleared by software.
        constexpr uint32_t FDCANEN = (1U << 25);  ///< FDCAN clock enable Set and cleared by software.
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable Set and cleared by software.
        constexpr uint32_t I2C3EN = (1U << 30);  ///< I2C3 clock enable Set and cleared by software.
        constexpr uint32_t LPTIM1EN = (1U << 31);  ///< Low power timer 1 clock enable Set and cleared by software.
    }

    /// RCC_APB1ENR2 Register bits
    namespace rcc_apb1enr2_bits {
        constexpr uint32_t LPUART1EN = (1U << 0);  ///< Low power UART 1 clock enable Set and cleared by software.
        constexpr uint32_t I2C4EN = (1U << 1);  ///< I2C4 clock enable Set and cleared by software
        constexpr uint32_t UCPD1EN = (1U << 8);  ///< UCPD1 clock enable Set and cleared by software.
    }

    /// RCC_APB2ENR Register bits
    namespace rcc_apb2enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG + COMP + VREFBUF + OPAMP clock enable Set and cleared by software.
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable Set and cleared by software.
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable Set and cleared by software.
        constexpr uint32_t TIM8EN = (1U << 13);  ///< TIM8 timer clock enable Set and cleared by software.
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1clock enable Set and cleared by software.
        constexpr uint32_t SPI4EN = (1U << 15);  ///< SPI4 clock enable Set and cleared by software.
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM20EN = (1U << 20);  ///< TIM20 timer clock enable Set and cleared by software.
        constexpr uint32_t SAI1EN = (1U << 21);  ///< SAI1 clock enable Set and cleared by software.
        constexpr uint32_t HRTIM1EN = (1U << 26);  ///< HRTIM1 clock enable Set and cleared by software.
    }

    /// RCC_AHB1SMENR Register bits
    namespace rcc_ahb1smenr_bits {
        constexpr uint32_t DMA1SMEN = (1U << 0);  ///< DMA1 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t DMA2SMEN = (1U << 1);  ///< DMA2 clocks enable during Sleep and Stop modes Set and cleared by software during Sleep mode.
        constexpr uint32_t DMAMUX1SMEN = (1U << 2);  ///< DMAMUX1 clock enable during Sleep and Stop modes. Set and cleared by software.
        constexpr uint32_t CORDICSMEN = (1U << 3);  ///< CORDICSM clock enable. Set and cleared by software.
        constexpr uint32_t FMACSMEN = (1U << 4);  ///< FMACSM clock enable. Set and cleared by software.
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t SRAM1SMEN = (1U << 9);  ///< SRAM1 interface clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clocks enable during Sleep and Stop modes Set and cleared by software.
    }

    /// RCC_AHB2SMENR Register bits
    namespace rcc_ahb2smenr_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< IO port A clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< IO port B clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< IO port C clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< IO port D clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< IO port E clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< IO port F clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t GPIOGSMEN = (1U << 6);  ///< IO port G clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t CCMSRAMSMEN = (1U << 9);  ///< CCM SRAM interface clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t SRAM2SMEN = (1U << 10);  ///< SRAM2 interface clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t ADC12SMEN = (1U << 13);  ///< ADC12 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t ADC345SMEN = (1U << 14);  ///< ADC345 clock enable Set and cleared by software.
        constexpr uint32_t DAC1SMEN = (1U << 16);  ///< DAC1 clock enable Set and cleared by software.
        constexpr uint32_t DAC2SMEN = (1U << 17);  ///< DAC2 clock enable Set and cleared by software.
        constexpr uint32_t DAC3SMEN = (1U << 18);  ///< DAC3 clock enable Set and cleared by software.
        constexpr uint32_t DAC4SMEN = (1U << 19);  ///< DAC4 clock enable Set and cleared by software.
        constexpr uint32_t AESSMEN = (1U << 24);  ///< AESM clocks enable Set and cleared by software.
        constexpr uint32_t RNGEN = (1U << 26);  ///< RNG enable Set and cleared by software.
    }

    /// RCC_AHB3SMENR Register bits
    namespace rcc_ahb3smenr_bits {
        constexpr uint32_t FMCSMEN = (1U << 0);  ///< Flexible static memory controller clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t QSPISMEN = (1U << 8);  ///< QUADSPI memory interface clock enable during Sleep and Stop modes Set and cleared by software.
    }

    /// RCC_APB1SMENR1 Register bits
    namespace rcc_apb1smenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM5SMEN = (1U << 3);  ///< TIM5 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t CRSSMEN = (1U << 8);  ///< CRS timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep and Stop modes Set and cleared by software
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< Window watchdog clocks enable during Sleep and Stop modes Set and cleared by software. This bit is forced to ‘1’ by hardware when the hardware WWDG option is activated.
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t SPI3SMEN = (1U << 15);  ///< SPI3 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t UART4SMEN = (1U << 19);  ///< UART4 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t UART5SMEN = (1U << 20);  ///< UART5 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t USBSMEN = (1U << 23);  ///< USB device clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t FDCANSMEN = (1U << 25);  ///< FDCAN clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t I2C3SMEN = (1U << 30);  ///< I2C3 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t LPTIM1SMEN = (1U << 31);  ///< Low power timer 1 clocks enable during Sleep and Stop modes Set and cleared by software.
    }

    /// RCC_APB1SMENR2 Register bits
    namespace rcc_apb1smenr2_bits {
        constexpr uint32_t LPUART1SMEN = (1U << 0);  ///< Low power UART 1 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t I2C4SMEN = (1U << 1);  ///< I2C4 clocks enable during Sleep and Stop modes Set and cleared by software
        constexpr uint32_t UCPD1SMEN = (1U << 8);  ///< UCPD1 clocks enable during Sleep and Stop modes Set and cleared by software.
    }

    /// RCC_APB2SMENR Register bits
    namespace rcc_apb2smenr_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG + COMP + VREFBUF + OPAMP clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM8SMEN = (1U << 13);  ///< TIM8 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t SPI4SMEN = (1U << 15);  ///< SPI4 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM17 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM20SMEN = (1U << 20);  ///< TIM20 timer clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t SAI1SMEN = (1U << 21);  ///< SAI1 clocks enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t HRTIM1SMEN = (1U << 26);  ///< HRTIM1 timer clocks enable during Sleep and Stop modes Set and cleared by software.
    }

    /// RCC_CCIPR Register bits
    namespace rcc_ccipr_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection This bit is set and cleared by software to select the USART1 clock source.
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 clock source selection This bit is set and cleared by software to select the USART2 clock source.
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 clock source selection This bit is set and cleared by software to select the USART3 clock source.
        constexpr uint32_t UART4SEL = (2 << 6);  ///< UART4 clock source selection This bit is set and cleared by software to select the UART4 clock source.
        constexpr uint32_t UART5SEL = (2 << 8);  ///< UART5 clock source selection These bits are set and cleared by software to select the UART5 clock source.
        constexpr uint32_t LPUART1SEL = (2 << 10);  ///< LPUART1 clock source selection These bits are set and cleared by software to select the LPUART1 clock source.
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection These bits are set and cleared by software to select the I2C1 clock source.
        constexpr uint32_t I2C2SEL = (2 << 14);  ///< I2C2 clock source selection These bits are set and cleared by software to select the I2C2 clock source.
        constexpr uint32_t I2C3SEL = (2 << 16);  ///< I2C3 clock source selection These bits are set and cleared by software to select the I2C3 clock source.
        constexpr uint32_t LPTIM1SEL = (2 << 18);  ///< Low power timer 1 clock source selection These bits are set and cleared by software to select the LPTIM1 clock source.
        constexpr uint32_t SAI1SEL = (2 << 20);  ///< clock source selection These bits are set and cleared by software to select the SAI clock source.
        constexpr uint32_t I2S23SEL = (2 << 22);  ///< clock source selection These bits are set and cleared by software to select the I2S23 clock source.
        constexpr uint32_t FDCANSEL = (2 << 24);  ///< None
        constexpr uint32_t CLK48SEL = (2 << 26);  ///< 48 MHz clock source selection These bits are set and cleared by software to select the 48 MHz clock source used by USB device FS and RNG.
        constexpr uint32_t ADC12SEL = (2 << 28);  ///< ADC1/2 clock source selection These bits are set and cleared by software to select the clock source used by the ADC interface.
        constexpr uint32_t ADC345SEL = (2 << 30);  ///< ADC3/4/5 clock source selection These bits are set and cleared by software to select the clock source used by the ADC345 interface.
    }

    /// RCC_BDCR Register bits
    namespace rcc_bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable Set and cleared by software.
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready Set and cleared by hardware to indicate when the external 32 kHz oscillator is stable. After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass Set and cleared by software to bypass oscillator in debug mode. This bit can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability Set by software to modulate the LSE oscillator’s drive capability. The oscillator is in Xtal mode when it is not in bypass mode.
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable Set by software to enable the Clock Security System on LSE (32 kHz oscillator). LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled this bit cannot be disabled, except after a LSE failure detection (LSECSSD =1). In that case the software MUST disable the LSECSSON bit.
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure Detection Set by hardware to indicate when a failure has been detected by the Clock Security System on the external 32 kHz oscillator (LSE).
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection Set by software to select the clock source for the RTC. Once the RTC clock source has been selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The BDRST bit can be used to reset them.
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable Set and cleared by software.
        constexpr uint32_t BDRST = (1U << 16);  ///< RTC domain software reset Set and cleared by software.
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low speed clock output enable Set and cleared by software.
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low speed clock output selection Set and cleared by software.
    }

    /// RCC_CSR Register bits
    namespace rcc_csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable Set and cleared by software.
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready Set and cleared by hardware to indicate when the LSI oscillator is stable. After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flag Set by software to clear the reset flags.
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag Set by hardware when a reset from the Option Byte loading occurs. Cleared by writing to the RMVF bit.
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag Set by hardware when a reset from the NRST pin occurs. Cleared by writing to the RMVF bit.
        constexpr uint32_t BORRSTF = (1U << 27);  ///< BOR flag Set by hardware when a BOR occurs. Cleared by writing to the RMVF bit.
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag Set by hardware when a software reset occurs. Cleared by writing to the RMVF bit.
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag Set by hardware when an independent watchdog reset domain occurs. Cleared by writing to the RMVF bit.
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag Set by hardware when a window watchdog reset occurs. Cleared by writing to the RMVF bit.
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag Set by hardware when a reset occurs due to illegal Stop, Standby or Shutdown mode entry. Cleared by writing to the RMVF bit.
    }

    /// RCC_CRRCR Register bits
    namespace rcc_crrcr_bits {
        constexpr uint32_t HSI48ON = (1U << 0);  ///< HSI48 clock enable Set and cleared by software. Cleared by hardware to stop the HSI48 when entering in Stop, Standby or Shutdown modes.
        constexpr uint32_t HSI48RDY = (1U << 1);  ///< HSI48 clock ready flag Set by hardware to indicate that HSI48 oscillator is stable. This bit is set only when HSI48 is enabled by software by setting HSI48ON.
        constexpr uint32_t HSI48CAL = (9 << 7);  ///< HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value. They are ready only.
    }

    /// RCC_CCIPR2 Register bits
    namespace rcc_ccipr2_bits {
        constexpr uint32_t I2C4SEL = (2 << 0);  ///< I2C4 clock source selection These bits are set and cleared by software to select the I2C4 clock source.
        constexpr uint32_t QSPISEL = (2 << 20);  ///< QUADSPI clock source selection Set and reset by software.
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWR_CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t PWR_CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t PWR_CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t PWR_CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t PWR_SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t PWR_SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t PWR_SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PWR_PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PWR_PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PWR_PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PWR_PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PWR_PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PWR_PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PWR_PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PWR_PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PWR_PUCRE;  ///< Offset: 0x40 - Power Port E pull-up control register
        volatile uint32_t PWR_PDCRE;  ///< Offset: 0x44 - Power Port E pull-down control register
        volatile uint32_t PWR_PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PWR_PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
        volatile uint32_t PWR_PUCRG;  ///< Offset: 0x50 - Power Port G pull-up control register
        volatile uint32_t PWR_PDCRG;  ///< Offset: 0x54 - Power Port G pull-down control register
        volatile uint32_t PWR_CR5;  ///< Offset: 0x80 - Power control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// PWR_CR1 Register bits
    namespace pwr_cr1_bits {
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection These bits select the low-power mode entered when CPU enters the deepsleep mode. 1xx: Shutdown mode Note: In Standby mode, SRAM2 can be preserved or not, depending on RRS bit configuration in PWR_CR3.
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< FPD_STOP
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection In reset state, the RTC and backup registers are protected against parasitic write access. This bit must be set to enable write access to these registers.
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run When this bit is set, the regulator is switched from main mode (MR) to low-power mode (LPR).
    }

    /// PWR_CR2 Register bits
    namespace pwr_cr2_bits {
        constexpr uint32_t PVDE = (1U << 0);  ///< Programmable voltage detector enable Note: This bit is write-protected when the PVDL bit is set in the SYSCFG_CFGR2 register. The protection can be reset only by a system reset.
        constexpr uint32_t PVDLS = (3 << 1);  ///< Programmable voltage detector level selection. These bits select the PVD falling threshold: Note: These bits are write-protected when the PVDL bit is set in the SYSCFG_CFGR2 register. The protection can be reset only by a system reset.
        constexpr uint32_t PVMEN1 = (1U << 6);  ///< Peripheral voltage monitoring 3 enable: V<sub>DDA</sub> vs. ADC/COMP min voltage 1.62V
        constexpr uint32_t PVMEN2 = (1U << 7);  ///< Peripheral voltage monitoring 4 enable: V<sub>DDA</sub> vs. DAC 1MSPS /DAC 15MSPS min voltage.
    }

    /// PWR_CR3 Register bits
    namespace pwr_cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1 When this bit is set, the external wakeup pin WKUP1 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2 When this bit is set, the external wakeup pin WKUP2 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP3 = (1U << 2);  ///< Enable Wakeup pin WKUP3 When this bit is set, the external wakeup pin WKUP3 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4 When this bit is set, the external wakeup pin WKUP4 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable Wakeup pin WKUP5 When this bit is set, the external wakeup pin WKUP5 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP5 bit in the PWR_CR4 register.
        constexpr uint32_t RRS = (1U << 8);  ///< SRAM2 retention in Standby mode
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied. When this bit is cleared, the PWR_PUCRx and PWR_PDCRx registers are not applied to the I/Os.
        constexpr uint32_t UCPD1_STDBY = (1U << 13);  ///< UCPD1_STDBY USB Type-C and Power Delivery standby mode.
        constexpr uint32_t UCPD1_DBDIS = (1U << 14);  ///< USB Type-C and Power Delivery Dead Battery disable. After exiting reset, the USB Type-C “dead battery” behavior is enabled, which may have a pull-down effect on CC1 and CC2 pins. It is recommended to disable it in all cases, either to stop this pull-down or to hand over control to the UCPD1 (which should therefore be initialized before doing the disable).
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wakeup line
    }

    /// PWR_CR4 Register bits
    namespace pwr_cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP1
        constexpr uint32_t WP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP2
        constexpr uint32_t WP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP3
        constexpr uint32_t WP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP4
        constexpr uint32_t WP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP5
        constexpr uint32_t VBE = (1U << 8);  ///< V<sub>BAT</sub> battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< V<sub>BAT</sub> battery charging resistor selection
    }

    /// PWR_SR1 Register bits
    namespace pwr_sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1 This bit is set when a wakeup event is detected on wakeup pin, WKUP1. It is cleared by writing ‘1’ in the CWUF1 bit of the PWR_SCR register.
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2 This bit is set when a wakeup event is detected on wakeup pin, WKUP2. It is cleared by writing ‘1’ in the CWUF2 bit of the PWR_SCR register.
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3 This bit is set when a wakeup event is detected on wakeup pin, WKUP3. It is cleared by writing ‘1’ in the CWUF3 bit of the PWR_SCR register.
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4 This bit is set when a wakeup event is detected on wakeup pin,WKUP4. It is cleared by writing ‘1’ in the CWUF4 bit of the PWR_SCR register.
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5 This bit is set when a wakeup event is detected on wakeup pin, WKUP5. It is cleared by writing ‘1’ in the CWUF5 bit of the PWR_SCR register.
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag This bit is set by hardware when the device enters the Standby mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
        constexpr uint32_t WUFI = (1U << 15);  ///< Wakeup flag internal This bit is set when a wakeup is detected on the internal wakeup line. It is cleared when all internal wakeup sources are cleared.
    }

    /// PWR_SR2 Register bits
    namespace pwr_sr2_bits {
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started This bit provides the information whether the low-power regulator is ready after a power-on reset or a Standby/Shutdown. If the Standby mode is entered while REGLPS bit is still cleared, the wakeup from Standby mode time may be increased.
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag This bit is set by hardware when the MCU is in Low-power run mode. When the MCU exits the Low-power run mode, this bit remains at 1 until the regulator is ready in main mode. A polling on this bit must be done before increasing the product frequency. This bit is cleared by hardware when the regulator is ready.
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag A delay is required for the internal regulator to be ready after the voltage scaling has been changed. VOSF indicates that the regulator reached the voltage level defined with VOS bits of the PWR_CR1 register.
        constexpr uint32_t PVDO = (1U << 11);  ///< Programmable voltage detector output
        constexpr uint32_t PVMO1 = (1U << 14);  ///< Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.62 V Note: PVMO1 is cleared when PVM1 is disabled (PVME = 0). After enabling PVM1, the PVM1 output is valid after the PVM1 wakeup time.
        constexpr uint32_t PVMO2 = (1U << 15);  ///< Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.8 V Note: PVMO2 is cleared when PVM2 is disabled (PVME = 0). After enabling PVM2, the PVM2 output is valid after the PVM2 wakeup time.
    }

    /// PWR_SCR Register bits
    namespace pwr_scr_bits {
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1 Setting this bit clears the WUF1 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2 Setting this bit clears the WUF2 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Clear wakeup flag 3 Setting this bit clears the WUF3 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4 Setting this bit clears the WUF4 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5 Setting this bit clears the WUF5 flag in the PWR_SR1 register.
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag Setting this bit clears the SBF flag in the PWR_SR1 register.
    }

    /// PWR_PUCRA Register bits
    namespace pwr_pucra_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit 15 When set, this bit activates the pull-up on PA[15] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PD15 bit is also set.
    }

    /// PWR_PDCRA Register bits
    namespace pwr_pdcra_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit 14 When set, this bit activates the pull-down on PA[14] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRB Register bits
    namespace pwr_pucrb_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
    }

    /// PWR_PDCRB Register bits
    namespace pwr_pdcrb_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRC Register bits
    namespace pwr_pucrc_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
    }

    /// PWR_PDCRC Register bits
    namespace pwr_pdcrc_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRD Register bits
    namespace pwr_pucrd_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
    }

    /// PWR_PDCRD Register bits
    namespace pwr_pdcrd_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRE Register bits
    namespace pwr_pucre_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
    }

    /// PWR_PDCRE Register bits
    namespace pwr_pdcre_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRF Register bits
    namespace pwr_pucrf_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
    }

    /// PWR_PDCRF Register bits
    namespace pwr_pdcrf_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRG Register bits
    namespace pwr_pucrg_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
    }

    /// PWR_PDCRG Register bits
    namespace pwr_pdcrg_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_CR5 Register bits
    namespace pwr_cr5_bits {
        constexpr uint32_t R1MODE = (1U << 8);  ///< Main regular range 1 mode This bit is only valid for the main regulator in range 1 and has no effect on range 2. It is recommended to reset this bit when the system frequency is greater than 150 MHz. Refer to
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x50060800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DR;  ///< Offset: 0x08 - data register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t RNGEN = (1U << 2);  ///< Random number generator enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x48000000;
    constexpr uint32_t GPIOB_BASE = 0x48000400;
    constexpr uint32_t GPIOC_BASE = 0x48000800;
    constexpr uint32_t GPIOD_BASE = 0x48000C00;
    constexpr uint32_t GPIOE_BASE = 0x48001000;
    constexpr uint32_t GPIOF_BASE = 0x48001400;
    constexpr uint32_t GPIOG_BASE = 0x48001800;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - GPIO port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFRL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFRH15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port Reset bit
        constexpr uint32_t BR1 = (1U << 1);  ///< Port Reset bit
        constexpr uint32_t BR2 = (1U << 2);  ///< Port Reset bit
        constexpr uint32_t BR3 = (1U << 3);  ///< Port Reset bit
        constexpr uint32_t BR4 = (1U << 4);  ///< Port Reset bit
        constexpr uint32_t BR5 = (1U << 5);  ///< Port Reset bit
        constexpr uint32_t BR6 = (1U << 6);  ///< Port Reset bit
        constexpr uint32_t BR7 = (1U << 7);  ///< Port Reset bit
        constexpr uint32_t BR8 = (1U << 8);  ///< Port Reset bit
        constexpr uint32_t BR9 = (1U << 9);  ///< Port Reset bit
        constexpr uint32_t BR10 = (1U << 10);  ///< Port Reset bit
        constexpr uint32_t BR11 = (1U << 11);  ///< Port Reset bit
        constexpr uint32_t BR12 = (1U << 12);  ///< Port Reset bit
        constexpr uint32_t BR13 = (1U << 13);  ///< Port Reset bit
        constexpr uint32_t BR14 = (1U << 14);  ///< Port Reset bit
        constexpr uint32_t BR15 = (1U << 15);  ///< Port Reset bit
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM8_BASE = 0x40013400;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t LPTIMER1_BASE = 0x40007C00;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SMCR;  ///< Offset: 0x08 - slave mode control register
        volatile uint32_t DIER;  ///< Offset: 0x0C - DMA/Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register (output mode)
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t RCR;  ///< Offset: 0x30 - repetition counter register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t CCR2;  ///< Offset: 0x38 - capture/compare register 2
        volatile uint32_t BDTR;  ///< Offset: 0x44 - break and dead-time register
        volatile uint32_t DTR2;  ///< Offset: 0x54 - timer Deadtime Register 2
        volatile uint32_t TISEL;  ///< Offset: 0x5C - TIM timer input selection register
        volatile uint32_t AF1;  ///< Offset: 0x60 - TIM alternate function option register 1
        volatile uint32_t AF2;  ///< Offset: 0x64 - TIM alternate function option register 2
        volatile uint32_t DCR;  ///< Offset: 0x3DC - DMA control register
        volatile uint32_t DMAR;  ///< Offset: 0x3E0 - DMA address for full transfer
    };

    /// Peripheral instances
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* LPTIMER1 = reinterpret_cast<Registers*>(LPTIMER1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t OPM = (1U << 3);  ///< One-pulse mode
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t UIFREMAP = (1U << 11);  ///< UIF status bit remapping
        constexpr uint32_t DITHEN = (1U << 12);  ///< Dithering Enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t OIS2 = (1U << 10);  ///< Output idle state 2 (OC2 output)
        constexpr uint32_t OIS1N = (1U << 9);  ///< Output Idle state 1
        constexpr uint32_t OIS1 = (1U << 8);  ///< Output Idle state 1
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1 selection
        constexpr uint32_t MMS = (3 << 4);  ///< Master mode selection
        constexpr uint32_t CCDS = (1U << 3);  ///< Capture/compare DMA selection
        constexpr uint32_t CCUS = (1U << 2);  ///< Capture/compare control update selection
        constexpr uint32_t CCPC = (1U << 0);  ///< Capture/compare preloaded control
    }

    /// SMCR Register bits
    namespace smcr_bits {
        constexpr uint32_t TS_4_3 = (2 << 20);  ///< Trigger selection - bit 4:3
        constexpr uint32_t SMS_3 = (1U << 16);  ///< Slave mode selection - bit 3
        constexpr uint32_t MSM = (1U << 7);  ///< Master/Slave mode
        constexpr uint32_t TS = (3 << 4);  ///< Trigger selection
        constexpr uint32_t SMS = (3 << 0);  ///< Slave mode selection
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t TDE = (1U << 14);  ///< Trigger DMA request enable
        constexpr uint32_t COMDE = (1U << 13);  ///< COM DMA request enable
        constexpr uint32_t CC2DE = (1U << 10);  ///< Capture/Compare 2 DMA request enable
        constexpr uint32_t CC1DE = (1U << 9);  ///< Capture/Compare 1 DMA request enable
        constexpr uint32_t UDE = (1U << 8);  ///< Update DMA request enable
        constexpr uint32_t BIE = (1U << 7);  ///< Break interrupt enable
        constexpr uint32_t TIE = (1U << 6);  ///< Trigger interrupt enable
        constexpr uint32_t COMIE = (1U << 5);  ///< COM interrupt enable
        constexpr uint32_t CC2IE = (1U << 2);  ///< Capture/Compare 2 interrupt enable
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC2OF = (1U << 10);  ///< Capture/Compare 2 overcapture flag
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/Compare 1 overcapture flag
        constexpr uint32_t BIF = (1U << 7);  ///< Break interrupt flag
        constexpr uint32_t TIF = (1U << 6);  ///< Trigger interrupt flag
        constexpr uint32_t COMIF = (1U << 5);  ///< COM interrupt flag
        constexpr uint32_t CC2IF = (1U << 2);  ///< Capture/compare 2 interrupt flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t BG = (1U << 7);  ///< Break generation
        constexpr uint32_t TG = (1U << 6);  ///< Trigger generation
        constexpr uint32_t COMG = (1U << 5);  ///< Capture/Compare control update generation
        constexpr uint32_t CC2G = (1U << 2);  ///< Capture/compare 2 generation
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC2M_3 = (1U << 24);  ///< Output Compare 2 mode - bit 3
        constexpr uint32_t OC1M_3 = (1U << 16);  ///< Output Compare 1 mode
        constexpr uint32_t OC2M = (3 << 12);  ///< OC2M
        constexpr uint32_t OC2PE = (1U << 11);  ///< OC2PE
        constexpr uint32_t OC2FE = (1U << 10);  ///< OC2FE
        constexpr uint32_t CC2S = (2 << 8);  ///< CC2S
        constexpr uint32_t OC1CE = (1U << 7);  ///< OC1CE
        constexpr uint32_t OC1M = (3 << 4);  ///< Output Compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output Compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output Compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC2F = (4 << 12);  ///< IC2F
        constexpr uint32_t IC2PSC = (2 << 10);  ///< IC2PSC
        constexpr uint32_t CC2S = (2 << 8);  ///< CC2S
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t IC1PSC = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC2NP = (1U << 7);  ///< Capture/Compare 2 complementary output polarity
        constexpr uint32_t CC2P = (1U << 5);  ///< Capture/Compare 2 output polarity
        constexpr uint32_t CC2E = (1U << 4);  ///< Capture/Compare 2 output enable
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1NE = (1U << 2);  ///< Capture/Compare 1 complementary output enable
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< counter value
        constexpr uint32_t UIFCPY = (1U << 31);  ///< UIF Copy
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< Prescaler value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition counter value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// BDTR Register bits
    namespace bdtr_bits {
        constexpr uint32_t DTG = (8 << 0);  ///< Dead-time generator setup
        constexpr uint32_t LOCK = (2 << 8);  ///< Lock configuration
        constexpr uint32_t OSSI = (1U << 10);  ///< Off-state selection for Idle mode
        constexpr uint32_t OSSR = (1U << 11);  ///< Off-state selection for Run mode
        constexpr uint32_t BKE = (1U << 12);  ///< Break enable
        constexpr uint32_t BKP = (1U << 13);  ///< Break polarity
        constexpr uint32_t AOE = (1U << 14);  ///< Automatic output enable
        constexpr uint32_t MOE = (1U << 15);  ///< Main output enable
        constexpr uint32_t BKF = (4 << 16);  ///< Break filter
        constexpr uint32_t BKDSRM = (1U << 26);  ///< BKDSRM
        constexpr uint32_t BKBID = (1U << 28);  ///< BKBID
    }

    /// DTR2 Register bits
    namespace dtr2_bits {
        constexpr uint32_t DTGF = (8 << 0);  ///< Dead-time generator setup
        constexpr uint32_t DTAE = (1U << 16);  ///< Deadtime Asymmetric Enable
        constexpr uint32_t DTPE = (1U << 17);  ///< Deadtime Preload Enable
    }

    /// TISEL Register bits
    namespace tisel_bits {
        constexpr uint32_t TI1SEL = (4 << 0);  ///< TI1[0] to TI1[15] input selection
        constexpr uint32_t TI2SEL = (4 << 8);  ///< TI2[0] to TI2[15] input selection
    }

    /// AF1 Register bits
    namespace af1_bits {
        constexpr uint32_t BKCMP4P = (1U << 13);  ///< BRK COMP4 input polarity
        constexpr uint32_t BKCMP3P = (1U << 12);  ///< BRK COMP3 input polarity
        constexpr uint32_t BKCMP2P = (1U << 11);  ///< BRK COMP2 input polarity
        constexpr uint32_t BKCMP1P = (1U << 10);  ///< BRK COMP1 input polarity
        constexpr uint32_t BKINP = (1U << 9);  ///< BRK BKIN input polarity
        constexpr uint32_t BKCMP7E = (1U << 7);  ///< BRK COMP7 enable
        constexpr uint32_t BKCMP6E = (1U << 6);  ///< BRK COMP6 enable
        constexpr uint32_t BKCMP5E = (1U << 5);  ///< BRK COMP5 enable
        constexpr uint32_t BKCMP4E = (1U << 4);  ///< BRK COMP4 enable
        constexpr uint32_t BKCMP3E = (1U << 3);  ///< BRK COMP3 enable
        constexpr uint32_t BKCMP2E = (1U << 2);  ///< BRK COMP2 enable
        constexpr uint32_t BKCMP1E = (1U << 1);  ///< BRK COMP1 enable
        constexpr uint32_t BKINE = (1U << 0);  ///< BRK BKIN input enable
    }

    /// AF2 Register bits
    namespace af2_bits {
        constexpr uint32_t OCRSEL = (3 << 16);  ///< OCREF_CLR source selection
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t DBL = (5 << 8);  ///< DMA burst length
        constexpr uint32_t DBA = (5 << 0);  ///< DMA base address
    }

    /// DMAR Register bits
    namespace dmar_bits {
        constexpr uint32_t DMAB = (32 << 0);  ///< DMA register for burst accesses
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;
    constexpr uint32_t LPUART1_BASE = 0x40008000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - USART prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFFIE
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFEIE
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t M1 = (1U << 28);  ///< M1
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable
        constexpr uint32_t DEAT4 = (1U << 25);  ///< Driver Enable assertion time
        constexpr uint32_t DEAT3 = (1U << 24);  ///< DEAT3
        constexpr uint32_t DEAT2 = (1U << 23);  ///< DEAT2
        constexpr uint32_t DEAT1 = (1U << 22);  ///< DEAT1
        constexpr uint32_t DEAT0 = (1U << 21);  ///< DEAT0
        constexpr uint32_t DEDT4 = (1U << 20);  ///< Driver Enable de-assertion time
        constexpr uint32_t DEDT3 = (1U << 19);  ///< DEDT3
        constexpr uint32_t DEDT2 = (1U << 18);  ///< DEDT2
        constexpr uint32_t DEDT1 = (1U << 17);  ///< DEDT1
        constexpr uint32_t DEDT0 = (1U << 16);  ///< DEDT0
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4_7 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0_3 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable
        constexpr uint32_t ABRMOD1 = (1U << 22);  ///< Auto baud rate mode
        constexpr uint32_t ABRMOD0 = (1U << 21);  ///< ABRMOD0
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t TAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
        constexpr uint32_t DIS_NSS = (1U << 3);  ///< DIS_NSS
        constexpr uint32_t SLVEN = (1U << 0);  ///< SLVEN
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFTCFG
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFTIE
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< RXFTCFG
        constexpr uint32_t TCBGTIE = (1U << 24);  ///< TCBGTIE
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFTIE
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< Ir low-power
        constexpr uint32_t IREN = (1U << 1);  ///< Ir mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t DIV_Mantissa = (12 << 4);  ///< DIV_Mantissa
        constexpr uint32_t DIV_Fraction = (4 << 0);  ///< DIV_Fraction
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFT
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFT
        constexpr uint32_t TCBGT = (1U << 25);  ///< TCBGT
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFF
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFE
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t ABRF = (1U << 15);  ///< ABRF
        constexpr uint32_t ABRE = (1U << 14);  ///< ABRE
        constexpr uint32_t UDR = (1U << 13);  ///< UDR
        constexpr uint32_t EOBF = (1U << 12);  ///< EOBF
        constexpr uint32_t RTOF = (1U << 11);  ///< RTOF
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t LBDF = (1U << 8);  ///< LBDF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NF = (1U << 2);  ///< NF
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t UDRCF = (1U << 13);  ///< UDRCF
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of block clear flag
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag
        constexpr uint32_t TCBGTCF = (1U << 7);  ///< TCBGTCF
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t TXFECF = (1U << 5);  ///< TXFECF
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< PRESCALER
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI3_BASE = 0x40003C00;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t CHLEN = (1U << 0);  ///< CHLEN
        constexpr uint32_t DATLEN = (2 << 1);  ///< DATLEN
        constexpr uint32_t CKPOL = (1U << 3);  ///< CKPOL
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2SSTD
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCMSYNC
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2SCFG
        constexpr uint32_t I2SE = (1U << 10);  ///< I2SE
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2SMOD
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2SDIV
        constexpr uint32_t ODD = (1U << 8);  ///< ODD
        constexpr uint32_t MCKOE = (1U << 9);  ///< MCKOE
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40010400;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t IMR1;  ///< Offset: 0x00 - Interrupt mask register
        volatile uint32_t EMR1;  ///< Offset: 0x04 - Event mask register
        volatile uint32_t RTSR1;  ///< Offset: 0x08 - Rising Trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x0C - Falling Trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x10 - Software interrupt event register
        volatile uint32_t PR1;  ///< Offset: 0x14 - Pending register
        volatile uint32_t IMR2;  ///< Offset: 0x20 - Interrupt mask register
        volatile uint32_t EMR2;  ///< Offset: 0x24 - Event mask register
        volatile uint32_t RTSR2;  ///< Offset: 0x28 - Rising Trigger selection register
        volatile uint32_t FTSR2;  ///< Offset: 0x2C - Falling Trigger selection register
        volatile uint32_t SWIER2;  ///< Offset: 0x30 - Software interrupt event register
        volatile uint32_t PR2;  ///< Offset: 0x34 - Pending register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< Interrupt Mask on line 0
        constexpr uint32_t IM1 = (1U << 1);  ///< Interrupt Mask on line 1
        constexpr uint32_t IM2 = (1U << 2);  ///< Interrupt Mask on line 2
        constexpr uint32_t IM3 = (1U << 3);  ///< Interrupt Mask on line 3
        constexpr uint32_t IM4 = (1U << 4);  ///< Interrupt Mask on line 4
        constexpr uint32_t IM5 = (1U << 5);  ///< Interrupt Mask on line 5
        constexpr uint32_t IM6 = (1U << 6);  ///< Interrupt Mask on line 6
        constexpr uint32_t IM7 = (1U << 7);  ///< Interrupt Mask on line 7
        constexpr uint32_t IM8 = (1U << 8);  ///< Interrupt Mask on line 8
        constexpr uint32_t IM9 = (1U << 9);  ///< Interrupt Mask on line 9
        constexpr uint32_t IM10 = (1U << 10);  ///< Interrupt Mask on line 10
        constexpr uint32_t IM11 = (1U << 11);  ///< Interrupt Mask on line 11
        constexpr uint32_t IM12 = (1U << 12);  ///< Interrupt Mask on line 12
        constexpr uint32_t IM13 = (1U << 13);  ///< Interrupt Mask on line 13
        constexpr uint32_t IM14 = (1U << 14);  ///< Interrupt Mask on line 14
        constexpr uint32_t IM15 = (1U << 15);  ///< Interrupt Mask on line 15
        constexpr uint32_t IM16 = (1U << 16);  ///< Interrupt Mask on line 16
        constexpr uint32_t IM17 = (1U << 17);  ///< Interrupt Mask on line 17
        constexpr uint32_t IM18 = (1U << 18);  ///< Interrupt Mask on line 18
        constexpr uint32_t IM19 = (1U << 19);  ///< Interrupt Mask on line 19
        constexpr uint32_t IM20 = (1U << 20);  ///< Interrupt Mask on line 20
        constexpr uint32_t IM21 = (1U << 21);  ///< Interrupt Mask on line 21
        constexpr uint32_t IM22 = (1U << 22);  ///< Interrupt Mask on line 22
        constexpr uint32_t IM23 = (1U << 23);  ///< Interrupt Mask on line 23
        constexpr uint32_t IM24 = (1U << 24);  ///< Interrupt Mask on line 24
        constexpr uint32_t IM25 = (1U << 25);  ///< Interrupt Mask on line 25
        constexpr uint32_t IM26 = (1U << 26);  ///< Interrupt Mask on line 26
        constexpr uint32_t IM27 = (1U << 27);  ///< Interrupt Mask on line 27
        constexpr uint32_t IM28 = (1U << 28);  ///< Interrupt Mask on line 28
        constexpr uint32_t IM29 = (1U << 29);  ///< Interrupt Mask on line 29
        constexpr uint32_t IM30 = (1U << 30);  ///< Interrupt Mask on line 30
        constexpr uint32_t IM31 = (1U << 31);  ///< Interrupt Mask on line 31
    }

    /// EMR1 Register bits
    namespace emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< Event Mask on line 0
        constexpr uint32_t EM1 = (1U << 1);  ///< Event Mask on line 1
        constexpr uint32_t EM2 = (1U << 2);  ///< Event Mask on line 2
        constexpr uint32_t EM3 = (1U << 3);  ///< Event Mask on line 3
        constexpr uint32_t EM4 = (1U << 4);  ///< Event Mask on line 4
        constexpr uint32_t EM5 = (1U << 5);  ///< Event Mask on line 5
        constexpr uint32_t EM6 = (1U << 6);  ///< Event Mask on line 6
        constexpr uint32_t EM7 = (1U << 7);  ///< Event Mask on line 7
        constexpr uint32_t EM8 = (1U << 8);  ///< Event Mask on line 8
        constexpr uint32_t EM9 = (1U << 9);  ///< Event Mask on line 9
        constexpr uint32_t EM10 = (1U << 10);  ///< Event Mask on line 10
        constexpr uint32_t EM11 = (1U << 11);  ///< Event Mask on line 11
        constexpr uint32_t EM12 = (1U << 12);  ///< Event Mask on line 12
        constexpr uint32_t EM13 = (1U << 13);  ///< Event Mask on line 13
        constexpr uint32_t EM14 = (1U << 14);  ///< Event Mask on line 14
        constexpr uint32_t EM15 = (1U << 15);  ///< Event Mask on line 15
        constexpr uint32_t EM16 = (1U << 16);  ///< Event Mask on line 16
        constexpr uint32_t EM17 = (1U << 17);  ///< Event Mask on line 17
        constexpr uint32_t EM18 = (1U << 18);  ///< Event Mask on line 18
        constexpr uint32_t EM19 = (1U << 19);  ///< Event Mask on line 19
        constexpr uint32_t EM20 = (1U << 20);  ///< Event Mask on line 20
        constexpr uint32_t EM21 = (1U << 21);  ///< Event Mask on line 21
        constexpr uint32_t EM22 = (1U << 22);  ///< Event Mask on line 22
        constexpr uint32_t EM23 = (1U << 23);  ///< Event Mask on line 23
        constexpr uint32_t EM24 = (1U << 24);  ///< Event Mask on line 24
        constexpr uint32_t EM25 = (1U << 25);  ///< Event Mask on line 25
        constexpr uint32_t EM26 = (1U << 26);  ///< Event Mask on line 26
        constexpr uint32_t EM27 = (1U << 27);  ///< Event Mask on line 27
        constexpr uint32_t EM28 = (1U << 28);  ///< Event Mask on line 28
        constexpr uint32_t EM29 = (1U << 29);  ///< Event Mask on line 29
        constexpr uint32_t EM30 = (1U << 30);  ///< Event Mask on line 30
        constexpr uint32_t EM31 = (1U << 31);  ///< Event Mask on line 31
    }

    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration of line 0
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration of line 1
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration of line 2
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration of line 3
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration of line 4
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration of line 5
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration of line 6
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration of line 7
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration of line 8
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration of line 9
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration of line 10
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration of line 11
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration of line 12
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration of line 13
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration of line 14
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration of line 15
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration of line 16
        constexpr uint32_t RT18 = (1U << 18);  ///< Rising trigger event configuration of line 18
        constexpr uint32_t RT19 = (1U << 19);  ///< Rising trigger event configuration of line 19
        constexpr uint32_t RT20 = (1U << 20);  ///< Rising trigger event configuration of line 20
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration of line 21
        constexpr uint32_t RT22 = (1U << 22);  ///< Rising trigger event configuration of line 22
        constexpr uint32_t RT = (3 << 29);  ///< RT
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration of line 0
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration of line 1
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration of line 2
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration of line 3
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration of line 4
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration of line 5
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration of line 6
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration of line 7
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration of line 8
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration of line 9
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration of line 10
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration of line 11
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration of line 12
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration of line 13
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration of line 14
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration of line 15
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration of line 16
        constexpr uint32_t FT18 = (1U << 18);  ///< Falling trigger event configuration of line 18
        constexpr uint32_t FT19 = (1U << 19);  ///< Falling trigger event configuration of line 19
        constexpr uint32_t FT20 = (1U << 20);  ///< Falling trigger event configuration of line 20
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration of line 21
        constexpr uint32_t FT22 = (1U << 22);  ///< Falling trigger event configuration of line 22
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software Interrupt on line 0
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software Interrupt on line 1
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software Interrupt on line 2
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software Interrupt on line 3
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software Interrupt on line 4
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software Interrupt on line 5
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software Interrupt on line 6
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software Interrupt on line 7
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software Interrupt on line 8
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software Interrupt on line 9
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software Interrupt on line 10
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software Interrupt on line 11
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software Interrupt on line 12
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software Interrupt on line 13
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software Interrupt on line 14
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software Interrupt on line 15
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software Interrupt on line 16
        constexpr uint32_t SWI18 = (1U << 18);  ///< Software Interrupt on line 18
        constexpr uint32_t SWI19 = (1U << 19);  ///< Software Interrupt on line 19
        constexpr uint32_t SWI20 = (1U << 20);  ///< Software Interrupt on line 20
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software Interrupt on line 21
        constexpr uint32_t SWI22 = (1U << 22);  ///< Software Interrupt on line 22
    }

    /// PR1 Register bits
    namespace pr1_bits {
        constexpr uint32_t PIF0 = (1U << 0);  ///< Pending bit 0
        constexpr uint32_t PIF1 = (1U << 1);  ///< Pending bit 1
        constexpr uint32_t PIF2 = (1U << 2);  ///< Pending bit 2
        constexpr uint32_t PIF3 = (1U << 3);  ///< Pending bit 3
        constexpr uint32_t PIF4 = (1U << 4);  ///< Pending bit 4
        constexpr uint32_t PIF5 = (1U << 5);  ///< Pending bit 5
        constexpr uint32_t PIF6 = (1U << 6);  ///< Pending bit 6
        constexpr uint32_t PIF7 = (1U << 7);  ///< Pending bit 7
        constexpr uint32_t PIF8 = (1U << 8);  ///< Pending bit 8
        constexpr uint32_t PIF9 = (1U << 9);  ///< Pending bit 9
        constexpr uint32_t PIF10 = (1U << 10);  ///< Pending bit 10
        constexpr uint32_t PIF11 = (1U << 11);  ///< Pending bit 11
        constexpr uint32_t PIF12 = (1U << 12);  ///< Pending bit 12
        constexpr uint32_t PIF13 = (1U << 13);  ///< Pending bit 13
        constexpr uint32_t PIF14 = (1U << 14);  ///< Pending bit 14
        constexpr uint32_t PIF15 = (1U << 15);  ///< Pending bit 15
        constexpr uint32_t PIF16 = (1U << 16);  ///< Pending bit 16
        constexpr uint32_t PIF18 = (1U << 18);  ///< Pending bit 18
        constexpr uint32_t PIF19 = (1U << 19);  ///< Pending bit 19
        constexpr uint32_t PIF20 = (1U << 20);  ///< Pending bit 20
        constexpr uint32_t PIF21 = (1U << 21);  ///< Pending bit 21
        constexpr uint32_t PIF22 = (1U << 22);  ///< Pending bit 22
    }

    /// IMR2 Register bits
    namespace imr2_bits {
        constexpr uint32_t IM32 = (1U << 0);  ///< Interrupt Mask on external/internal line 32
        constexpr uint32_t IM33 = (1U << 1);  ///< Interrupt Mask on external/internal line 33
        constexpr uint32_t IM34 = (1U << 2);  ///< Interrupt Mask on external/internal line 34
        constexpr uint32_t IM35 = (1U << 3);  ///< Interrupt Mask on external/internal line 35
        constexpr uint32_t IM36 = (1U << 4);  ///< Interrupt Mask on external/internal line 36
        constexpr uint32_t IM37 = (1U << 5);  ///< Interrupt Mask on external/internal line 37
        constexpr uint32_t IM38 = (1U << 6);  ///< Interrupt Mask on external/internal line 38
        constexpr uint32_t IM39 = (1U << 7);  ///< Interrupt Mask on external/internal line 39
        constexpr uint32_t IM40 = (1U << 8);  ///< Interrupt Mask on external/internal line 40
        constexpr uint32_t IM41 = (1U << 9);  ///< Interrupt Mask on external/internal line 41
        constexpr uint32_t IM42 = (1U << 10);  ///< Interrupt Mask on external/internal line 42
        constexpr uint32_t IM43 = (1U << 11);  ///< Interrupt Mask on external/internal line 43
    }

    /// EMR2 Register bits
    namespace emr2_bits {
        constexpr uint32_t EM32 = (1U << 0);  ///< Event mask on external/internal line 32
        constexpr uint32_t EM33 = (1U << 1);  ///< Event mask on external/internal line 33
        constexpr uint32_t EM34 = (1U << 2);  ///< Event mask on external/internal line 34
        constexpr uint32_t EM35 = (1U << 3);  ///< Event mask on external/internal line 35
        constexpr uint32_t EM36 = (1U << 4);  ///< Event mask on external/internal line 36
        constexpr uint32_t EM37 = (1U << 5);  ///< Event mask on external/internal line 37
        constexpr uint32_t EM38 = (1U << 6);  ///< Event mask on external/internal line 38
        constexpr uint32_t EM39 = (1U << 7);  ///< Event mask on external/internal line 39
        constexpr uint32_t EM40 = (1U << 8);  ///< Event mask on external/internal line 40
    }

    /// RTSR2 Register bits
    namespace rtsr2_bits {
        constexpr uint32_t RT32 = (1U << 0);  ///< Rising trigger event configuration bit of line 32
        constexpr uint32_t RT33 = (1U << 1);  ///< Rising trigger event configuration bit of line 32
        constexpr uint32_t RT38 = (1U << 6);  ///< Rising trigger event configuration bit of line 38
        constexpr uint32_t RT39 = (1U << 7);  ///< Rising trigger event configuration bit of line 39
        constexpr uint32_t RT40 = (1U << 8);  ///< Rising trigger event configuration bit of line 40
        constexpr uint32_t RT41 = (1U << 9);  ///< Rising trigger event configuration bit of line 41
    }

    /// FTSR2 Register bits
    namespace ftsr2_bits {
        constexpr uint32_t FT35 = (1U << 3);  ///< Falling trigger event configuration bit of line 35
        constexpr uint32_t FT36 = (1U << 4);  ///< Falling trigger event configuration bit of line 36
        constexpr uint32_t FT37 = (1U << 5);  ///< Falling trigger event configuration bit of line 37
        constexpr uint32_t FT38 = (1U << 6);  ///< Falling trigger event configuration bit of line 38
    }

    /// SWIER2 Register bits
    namespace swier2_bits {
        constexpr uint32_t SWI35 = (1U << 3);  ///< Software interrupt on line 35
        constexpr uint32_t SWI36 = (1U << 4);  ///< Software interrupt on line 36
        constexpr uint32_t SWI37 = (1U << 5);  ///< Software interrupt on line 37
        constexpr uint32_t SWI38 = (1U << 6);  ///< Software interrupt on line 38
    }

    /// PR2 Register bits
    namespace pr2_bits {
        constexpr uint32_t PIF35 = (1U << 3);  ///< Pending interrupt flag on line 35
        constexpr uint32_t PIF36 = (1U << 4);  ///< Pending interrupt flag on line 36
        constexpr uint32_t PIF37 = (1U << 5);  ///< Pending interrupt flag on line 37
        constexpr uint32_t PIF38 = (1U << 6);  ///< Pending interrupt flag on line 38
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - status register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WCKSEL = (3 << 0);  ///< Wakeup clock selection
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge
        constexpr uint32_t REFCKON = (1U << 4);  ///< Reference clock detection enable (50 or 60 Hz)
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable
        constexpr uint32_t TSE = (1U << 11);  ///< Time stamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change)
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change)
        constexpr uint32_t BKP = (1U << 18);  ///< Backup
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable
        constexpr uint32_t ITSE = (1U << 24);  ///< timestamp on internal event enable
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA1_BASE = 0x40020000;
    constexpr uint32_t DMA2_BASE = 0x40020400;
    constexpr uint32_t DMAMUX_BASE = 0x40020800;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - interrupt status register
        volatile uint32_t IFCR;  ///< Offset: 0x04 - DMA interrupt flag clear register
        volatile uint32_t CCR1;  ///< Offset: 0x08 - DMA channel 1 configuration register
        volatile uint32_t CCR2;  ///< Offset: 0x1C - DMA channel 2 configuration register
        volatile uint32_t CCR3;  ///< Offset: 0x30 - DMA channel 3 configuration register
        volatile uint32_t CCR4;  ///< Offset: 0x44 - DMA channel 3 configuration register
        volatile uint32_t CCR5;  ///< Offset: 0x58 - DMA channel 4 configuration register
        volatile uint32_t CCR6;  ///< Offset: 0x6C - DMA channel 5 configuration register
        volatile uint32_t CCR7;  ///< Offset: 0x80 - DMA channel 6 configuration register
        volatile uint32_t CCR8;  ///< Offset: 0x94 - DMA channel 7 configuration register
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - channel x number of data to transfer register
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - channel x number of data to transfer register
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - channel x number of data to transfer register
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - channel x number of data to transfer register
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - channel x number of data to transfer register
        volatile uint32_t CNDTR6;  ///< Offset: 0x70 - channel x number of data to transfer register
        volatile uint32_t CNDTR7;  ///< Offset: 0x84 - channel x number of data to transfer register
        volatile uint32_t CNDTR8;  ///< Offset: 0x98 - channel x number of data to transfer register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - DMA channel x peripheral address register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - DMA channel x peripheral address register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - DMA channel x peripheral address register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - DMA channel x peripheral address register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - DMA channel x peripheral address register
        volatile uint32_t CPAR6;  ///< Offset: 0x74 - DMA channel x peripheral address register
        volatile uint32_t CPAR7;  ///< Offset: 0x88 - DMA channel x peripheral address register
        volatile uint32_t CPAR8;  ///< Offset: 0x9C - DMA channel x peripheral address register
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - DMA channel x memory address register
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - DMA channel x memory address register
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - DMA channel x memory address register
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - DMA channel x memory address register
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - DMA channel x memory address register
        volatile uint32_t CMAR6;  ///< Offset: 0x78 - DMA channel x memory address register
        volatile uint32_t CMAR7;  ///< Offset: 0x8C - DMA channel x memory address register
        volatile uint32_t CMAR8;  ///< Offset: 0xA0 - DMA channel x memory address register
    };

    /// Peripheral instances
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);
    inline Registers* DMA2 = reinterpret_cast<Registers*>(DMA2_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TEIF8 = (1U << 31);  ///< TEIF8
        constexpr uint32_t HTIF8 = (1U << 30);  ///< HTIF8
        constexpr uint32_t TCIF8 = (1U << 29);  ///< TCIF8
        constexpr uint32_t GIF8 = (1U << 28);  ///< GIF8
        constexpr uint32_t TEIF7 = (1U << 27);  ///< TEIF7
        constexpr uint32_t HTIF7 = (1U << 26);  ///< HTIF7
        constexpr uint32_t TCIF7 = (1U << 25);  ///< TCIF7
        constexpr uint32_t GIF7 = (1U << 24);  ///< GIF7
        constexpr uint32_t TEIF6 = (1U << 23);  ///< TEIF6
        constexpr uint32_t HTIF6 = (1U << 22);  ///< HTIF6
        constexpr uint32_t TCIF6 = (1U << 21);  ///< TCIF6
        constexpr uint32_t GIF6 = (1U << 20);  ///< GIF6
        constexpr uint32_t TEIF5 = (1U << 19);  ///< TEIF5
        constexpr uint32_t HTIF5 = (1U << 18);  ///< HTIF5
        constexpr uint32_t TCIF5 = (1U << 17);  ///< TCIF5
        constexpr uint32_t GIF5 = (1U << 16);  ///< GIF5
        constexpr uint32_t TEIF4 = (1U << 15);  ///< TEIF4
        constexpr uint32_t HTIF4 = (1U << 14);  ///< HTIF4
        constexpr uint32_t TCIF4 = (1U << 13);  ///< TCIF4
        constexpr uint32_t GIF4 = (1U << 12);  ///< GIF4
        constexpr uint32_t TEIF3 = (1U << 11);  ///< TEIF3
        constexpr uint32_t HTIF3 = (1U << 10);  ///< HTIF3
        constexpr uint32_t TCIF3 = (1U << 9);  ///< TCIF3
        constexpr uint32_t GIF3 = (1U << 8);  ///< GIF3
        constexpr uint32_t TEIF2 = (1U << 7);  ///< TEIF2
        constexpr uint32_t HTIF2 = (1U << 6);  ///< HTIF2
        constexpr uint32_t TCIF2 = (1U << 5);  ///< TCIF2
        constexpr uint32_t GIF2 = (1U << 4);  ///< GIF2
        constexpr uint32_t TEIF1 = (1U << 3);  ///< TEIF1
        constexpr uint32_t HTIF1 = (1U << 2);  ///< HTIF1
        constexpr uint32_t TCIF1 = (1U << 1);  ///< TCIF1
        constexpr uint32_t GIF1 = (1U << 0);  ///< GIF1
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t TEIF8 = (1U << 31);  ///< TEIF8
        constexpr uint32_t HTIF8 = (1U << 30);  ///< HTIF8
        constexpr uint32_t TCIF8 = (1U << 29);  ///< TCIF8
        constexpr uint32_t GIF8 = (1U << 28);  ///< GIF8
        constexpr uint32_t TEIF7 = (1U << 27);  ///< TEIF7
        constexpr uint32_t HTIF7 = (1U << 26);  ///< HTIF7
        constexpr uint32_t TCIF7 = (1U << 25);  ///< TCIF7
        constexpr uint32_t GIF7 = (1U << 24);  ///< GIF7
        constexpr uint32_t TEIF6 = (1U << 23);  ///< TEIF6
        constexpr uint32_t HTIF6 = (1U << 22);  ///< HTIF6
        constexpr uint32_t TCIF6 = (1U << 21);  ///< TCIF6
        constexpr uint32_t GIF6 = (1U << 20);  ///< GIF6
        constexpr uint32_t TEIF5 = (1U << 19);  ///< TEIF5
        constexpr uint32_t HTIF5 = (1U << 18);  ///< HTIF5
        constexpr uint32_t TCIF5 = (1U << 17);  ///< TCIF5
        constexpr uint32_t GIF5 = (1U << 16);  ///< GIF5
        constexpr uint32_t TEIF4 = (1U << 15);  ///< TEIF4
        constexpr uint32_t HTIF4 = (1U << 14);  ///< HTIF4
        constexpr uint32_t TCIF4 = (1U << 13);  ///< TCIF4
        constexpr uint32_t GIF4 = (1U << 12);  ///< GIF4
        constexpr uint32_t TEIF3 = (1U << 11);  ///< TEIF3
        constexpr uint32_t HTIF3 = (1U << 10);  ///< HTIF3
        constexpr uint32_t TCIF3 = (1U << 9);  ///< TCIF3
        constexpr uint32_t GIF3 = (1U << 8);  ///< GIF3
        constexpr uint32_t TEIF2 = (1U << 7);  ///< TEIF2
        constexpr uint32_t HTIF2 = (1U << 6);  ///< HTIF2
        constexpr uint32_t TCIF2 = (1U << 5);  ///< TCIF2
        constexpr uint32_t GIF2 = (1U << 4);  ///< GIF2
        constexpr uint32_t TEIF1 = (1U << 3);  ///< TEIF1
        constexpr uint32_t HTIF1 = (1U << 2);  ///< HTIF1
        constexpr uint32_t TCIF1 = (1U << 1);  ///< TCIF1
        constexpr uint32_t GIF1 = (1U << 0);  ///< GIF1
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR6 Register bits
    namespace ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR7 Register bits
    namespace ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CCR8 Register bits
    namespace ccr8_bits {
        constexpr uint32_t EN = (1U << 0);  ///< channel enable
        constexpr uint32_t TCIE = (1U << 1);  ///< TCIE
        constexpr uint32_t HTIE = (1U << 2);  ///< HTIE
        constexpr uint32_t TEIE = (1U << 3);  ///< TEIE
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t CIRC = (1U << 5);  ///< CIRC
        constexpr uint32_t PINC = (1U << 6);  ///< PINC
        constexpr uint32_t MINC = (1U << 7);  ///< MINC
        constexpr uint32_t PSIZE = (2 << 8);  ///< PSIZE
        constexpr uint32_t MSIZE = (2 << 10);  ///< MSIZE
        constexpr uint32_t PL = (2 << 12);  ///< PL
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< MEM2MEM
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR6 Register bits
    namespace cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR7 Register bits
    namespace cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CNDTR8 Register bits
    namespace cndtr8_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data items to transfer
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR6 Register bits
    namespace cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR7 Register bits
    namespace cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CPAR8 Register bits
    namespace cpar8_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR6 Register bits
    namespace cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR7 Register bits
    namespace cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

    /// CMAR8 Register bits
    namespace cmar8_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory 1 address (used in case of Double buffer mode)
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t MEMRMP;  ///< Offset: 0x00 - Remap Memory register
        volatile uint32_t CFGR1;  ///< Offset: 0x04 - peripheral mode configuration register
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
        volatile uint32_t SCSR;  ///< Offset: 0x18 - CCM SRAM control and status register
        volatile uint32_t CFGR2;  ///< Offset: 0x1C - configuration register 2
        volatile uint32_t SWPR;  ///< Offset: 0x20 - SRAM Write protection register 1
        volatile uint32_t SKR;  ///< Offset: 0x24 - SRAM2 Key Register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// MEMRMP Register bits
    namespace memrmp_bits {
        constexpr uint32_t MEM_MODE = (3 << 0);  ///< Memory mapping selection
        constexpr uint32_t FB_mode = (1U << 8);  ///< User Flash Bank mode
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< BOOSTEN
        constexpr uint32_t ANASWVDD = (1U << 9);  ///< GPIO analog switch control voltage selection
        constexpr uint32_t I2C_PB6_FMP = (1U << 16);  ///< FM+ drive capability on PB6
        constexpr uint32_t I2C_PB7_FMP = (1U << 17);  ///< FM+ drive capability on PB6
        constexpr uint32_t I2C_PB8_FMP = (1U << 18);  ///< FM+ drive capability on PB6
        constexpr uint32_t I2C_PB9_FMP = (1U << 19);  ///< FM+ drive capability on PB6
        constexpr uint32_t I2C1_FMP = (1U << 20);  ///< I2C1 FM+ drive capability enable
        constexpr uint32_t I2C2_FMP = (1U << 21);  ///< I2C1 FM+ drive capability enable
        constexpr uint32_t I2C3_FMP = (1U << 22);  ///< I2C1 FM+ drive capability enable
        constexpr uint32_t I2C4_FMP = (1U << 23);  ///< I2C1 FM+ drive capability enable
        constexpr uint32_t FPU_IE = (6 << 26);  ///< FPU Interrupts Enable
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI x configuration (x = 0 to 3)
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI x configuration (x = 4 to 7)
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI10
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI x configuration (x = 8 to 11)
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI x configuration (x = 12 to 15)
    }

    /// SCSR Register bits
    namespace scsr_bits {
        constexpr uint32_t CCMER = (1U << 0);  ///< CCM SRAM Erase
        constexpr uint32_t CCMBSY = (1U << 1);  ///< CCM SRAM busy by erase operation
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t CLL = (1U << 0);  ///< Core Lockup Lock
        constexpr uint32_t SPL = (1U << 1);  ///< SRAM Parity Lock
        constexpr uint32_t PVDL = (1U << 2);  ///< PVD Lock
        constexpr uint32_t ECCL = (1U << 3);  ///< ECC Lock
        constexpr uint32_t SPF = (1U << 8);  ///< SRAM Parity Flag
    }

    /// SWPR Register bits
    namespace swpr_bits {
        constexpr uint32_t Page0_WP = (1U << 0);  ///< Write protection
        constexpr uint32_t Page1_WP = (1U << 1);  ///< Write protection
        constexpr uint32_t Page2_WP = (1U << 2);  ///< Write protection
        constexpr uint32_t Page3_WP = (1U << 3);  ///< Write protection
        constexpr uint32_t Page4_WP = (1U << 4);  ///< Write protection
        constexpr uint32_t Page5_WP = (1U << 5);  ///< Write protection
        constexpr uint32_t Page6_WP = (1U << 6);  ///< Write protection
        constexpr uint32_t Page7_WP = (1U << 7);  ///< Write protection
        constexpr uint32_t Page8_WP = (1U << 8);  ///< Write protection
        constexpr uint32_t Page9_WP = (1U << 9);  ///< Write protection
        constexpr uint32_t Page10_WP = (1U << 10);  ///< Write protection
        constexpr uint32_t Page11_WP = (1U << 11);  ///< Write protection
        constexpr uint32_t Page12_WP = (1U << 12);  ///< Write protection
        constexpr uint32_t Page13_WP = (1U << 13);  ///< Write protection
        constexpr uint32_t Page14_WP = (1U << 14);  ///< Write protection
        constexpr uint32_t Page15_WP = (1U << 15);  ///< Write protection
        constexpr uint32_t Page16_WP = (1U << 16);  ///< Write protection
        constexpr uint32_t Page17_WP = (1U << 17);  ///< Write protection
        constexpr uint32_t Page18_WP = (1U << 18);  ///< Write protection
        constexpr uint32_t Page19_WP = (1U << 19);  ///< Write protection
        constexpr uint32_t Page20_WP = (1U << 20);  ///< Write protection
        constexpr uint32_t Page21_WP = (1U << 21);  ///< Write protection
        constexpr uint32_t Page22_WP = (1U << 22);  ///< Write protection
        constexpr uint32_t Page23_WP = (1U << 23);  ///< Write protection
        constexpr uint32_t Page24_WP = (1U << 24);  ///< Write protection
        constexpr uint32_t Page25_WP = (1U << 25);  ///< Write protection
        constexpr uint32_t Page26_WP = (1U << 26);  ///< Write protection
        constexpr uint32_t Page27_WP = (1U << 27);  ///< Write protection
        constexpr uint32_t Page28_WP = (1U << 28);  ///< Write protection
        constexpr uint32_t Page29_WP = (1U << 29);  ///< Write protection
        constexpr uint32_t Page30_WP = (1U << 30);  ///< Write protection
        constexpr uint32_t Page31_WP = (1U << 31);  ///< Write protection
    }

    /// SKR Register bits
    namespace skr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< SRAM2 Key for software erase
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x40010030;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x00 - VREF_BUF Control and Status Register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x04 - VREF_BUF Calibration Control Register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Enable Voltage Reference
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedence mode for the VREF_BUF
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
        constexpr uint32_t VRS = (2 << 4);  ///< Voltage reference scale
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x40010200;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP_C1CSR;  ///< Offset: 0x00 - Comparator control/status register
        volatile uint32_t COMP_C2CSR;  ///< Offset: 0x04 - Comparator control/status register
        volatile uint32_t COMP_C3CSR;  ///< Offset: 0x08 - Comparator control/status register
        volatile uint32_t COMP_C4CSR;  ///< Offset: 0x0C - Comparator control/status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);

    // Bit definitions
    /// COMP_C1CSR Register bits
    namespace comp_c1csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t INMSEL = (3 << 4);  ///< INMSEL
        constexpr uint32_t INPSEL = (1U << 8);  ///< INPSEL
        constexpr uint32_t POL = (1U << 15);  ///< POL
        constexpr uint32_t HYST = (3 << 16);  ///< HYST
        constexpr uint32_t BLANKSEL = (3 << 19);  ///< BLANKSEL
        constexpr uint32_t BRGEN = (1U << 22);  ///< BRGEN
        constexpr uint32_t SCALEN = (1U << 23);  ///< SCALEN
        constexpr uint32_t VALUE = (1U << 30);  ///< VALUE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// COMP_C2CSR Register bits
    namespace comp_c2csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t INMSEL = (3 << 4);  ///< INMSEL
        constexpr uint32_t INPSEL = (1U << 8);  ///< INPSEL
        constexpr uint32_t POL = (1U << 15);  ///< POL
        constexpr uint32_t HYST = (3 << 16);  ///< HYST
        constexpr uint32_t BLANKSEL = (3 << 19);  ///< BLANKSEL
        constexpr uint32_t BRGEN = (1U << 22);  ///< BRGEN
        constexpr uint32_t SCALEN = (1U << 23);  ///< SCALEN
        constexpr uint32_t VALUE = (1U << 30);  ///< VALUE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// COMP_C3CSR Register bits
    namespace comp_c3csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t INMSEL = (3 << 4);  ///< INMSEL
        constexpr uint32_t INPSEL = (1U << 8);  ///< INPSEL
        constexpr uint32_t POL = (1U << 15);  ///< POL
        constexpr uint32_t HYST = (3 << 16);  ///< HYST
        constexpr uint32_t BLANKSEL = (3 << 19);  ///< BLANKSEL
        constexpr uint32_t BRGEN = (1U << 22);  ///< BRGEN
        constexpr uint32_t SCALEN = (1U << 23);  ///< SCALEN
        constexpr uint32_t VALUE = (1U << 30);  ///< VALUE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// COMP_C4CSR Register bits
    namespace comp_c4csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t INMSEL = (3 << 4);  ///< INMSEL
        constexpr uint32_t INPSEL = (1U << 8);  ///< INPSEL
        constexpr uint32_t POL = (1U << 15);  ///< POL
        constexpr uint32_t HYST = (3 << 16);  ///< HYST
        constexpr uint32_t BLANKSEL = (3 << 19);  ///< BLANKSEL
        constexpr uint32_t BRGEN = (1U << 22);  ///< BRGEN
        constexpr uint32_t SCALEN = (1U << 23);  ///< SCALEN
        constexpr uint32_t VALUE = (1U << 30);  ///< VALUE
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x40010300;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP1_CSR;  ///< Offset: 0x00 - OPAMP1 control/status register
        volatile uint32_t OPAMP2_CSR;  ///< Offset: 0x04 - OPAMP2 control/status register
        volatile uint32_t OPAMP3_CSR;  ///< Offset: 0x08 - OPAMP3 control/status register
        volatile uint32_t OPAMP1_TCMR;  ///< Offset: 0x18 - OPAMP1 control/status register
        volatile uint32_t OPAMP2_TCMR;  ///< Offset: 0x1C - OPAMP2 control/status register
        volatile uint32_t OPAMP3_TCMR;  ///< Offset: 0x20 - OPAMP3 control/status register
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP1_CSR Register bits
    namespace opamp1_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t FORCE_VP = (1U << 1);  ///< FORCE_VP
        constexpr uint32_t VP_SEL = (2 << 2);  ///< VP_SEL
        constexpr uint32_t USERTRIM = (1U << 4);  ///< USERTRIM
        constexpr uint32_t VM_SEL = (2 << 5);  ///< VM_SEL
        constexpr uint32_t OPAHSM = (1U << 7);  ///< OPAHSM
        constexpr uint32_t OPAINTOEN = (1U << 8);  ///< OPAINTOEN
        constexpr uint32_t CALON = (1U << 11);  ///< CALON
        constexpr uint32_t CALSEL = (2 << 12);  ///< CALSEL
        constexpr uint32_t PGA_GAIN = (5 << 14);  ///< PGA_GAIN
        constexpr uint32_t TRIMOFFSETP = (5 << 19);  ///< TRIMOFFSETP
        constexpr uint32_t TRIMOFFSETN = (5 << 24);  ///< TRIMOFFSETN
        constexpr uint32_t CALOUT = (1U << 30);  ///< CALOUT
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// OPAMP2_CSR Register bits
    namespace opamp2_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t FORCE_VP = (1U << 1);  ///< FORCE_VP
        constexpr uint32_t VP_SEL = (2 << 2);  ///< VP_SEL
        constexpr uint32_t USERTRIM = (1U << 4);  ///< USERTRIM
        constexpr uint32_t VM_SEL = (2 << 5);  ///< VM_SEL
        constexpr uint32_t OPAHSM = (1U << 7);  ///< OPAHSM
        constexpr uint32_t OPAINTOEN = (1U << 8);  ///< OPAINTOEN
        constexpr uint32_t CALON = (1U << 11);  ///< CALON
        constexpr uint32_t CALSEL = (2 << 12);  ///< CALSEL
        constexpr uint32_t PGA_GAIN = (5 << 14);  ///< PGA_GAIN
        constexpr uint32_t TRIMOFFSETP = (5 << 19);  ///< TRIMOFFSETP
        constexpr uint32_t TRIMOFFSETN = (5 << 24);  ///< TRIMOFFSETN
        constexpr uint32_t CALOUT = (1U << 30);  ///< CALOUT
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// OPAMP3_CSR Register bits
    namespace opamp3_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t FORCE_VP = (1U << 1);  ///< FORCE_VP
        constexpr uint32_t VP_SEL = (2 << 2);  ///< VP_SEL
        constexpr uint32_t USERTRIM = (1U << 4);  ///< USERTRIM
        constexpr uint32_t VM_SEL = (2 << 5);  ///< VM_SEL
        constexpr uint32_t OPAHSM = (1U << 7);  ///< OPAHSM
        constexpr uint32_t OPAINTOEN = (1U << 8);  ///< OPAINTOEN
        constexpr uint32_t CALON = (1U << 11);  ///< CALON
        constexpr uint32_t CALSEL = (2 << 12);  ///< CALSEL
        constexpr uint32_t PGA_GAIN = (5 << 14);  ///< PGA_GAIN
        constexpr uint32_t TRIMOFFSETP = (5 << 19);  ///< TRIMOFFSETP
        constexpr uint32_t TRIMOFFSETN = (5 << 24);  ///< TRIMOFFSETN
        constexpr uint32_t CALOUT = (1U << 30);  ///< CALOUT
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// OPAMP1_TCMR Register bits
    namespace opamp1_tcmr_bits {
        constexpr uint32_t VMS_SEL = (1U << 0);  ///< VMS_SEL
        constexpr uint32_t VPS_SEL = (2 << 1);  ///< VPS_SEL
        constexpr uint32_t T1CM_EN = (1U << 3);  ///< T1CM_EN
        constexpr uint32_t T8CM_EN = (1U << 4);  ///< T8CM_EN
        constexpr uint32_t T20CM_EN = (1U << 5);  ///< T20CM_EN
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// OPAMP2_TCMR Register bits
    namespace opamp2_tcmr_bits {
        constexpr uint32_t VMS_SEL = (1U << 0);  ///< VMS_SEL
        constexpr uint32_t VPS_SEL = (2 << 1);  ///< VPS_SEL
        constexpr uint32_t T1CM_EN = (1U << 3);  ///< T1CM_EN
        constexpr uint32_t T8CM_EN = (1U << 4);  ///< T8CM_EN
        constexpr uint32_t T20CM_EN = (1U << 5);  ///< T20CM_EN
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

    /// OPAMP3_TCMR Register bits
    namespace opamp3_tcmr_bits {
        constexpr uint32_t VMS_SEL = (1U << 0);  ///< VMS_SEL
        constexpr uint32_t VPS_SEL = (2 << 1);  ///< VPS_SEL
        constexpr uint32_t T1CM_EN = (1U << 3);  ///< T1CM_EN
        constexpr uint32_t T8CM_EN = (1U << 4);  ///< T8CM_EN
        constexpr uint32_t T20CM_EN = (1U << 5);  ///< T20CM_EN
        constexpr uint32_t LOCK = (1U << 31);  ///< LOCK
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC1_BASE = 0x50000800;
    constexpr uint32_t DAC2_BASE = 0x50000C00;
    constexpr uint32_t DAC3_BASE = 0x50001000;
    constexpr uint32_t DAC4_BASE = 0x50001400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC Sample and Hold sample time register 2
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
        volatile uint32_t DAC_STR1;  ///< Offset: 0x58 - Sawtooth register
        volatile uint32_t DAC_STR2;  ///< Offset: 0x5C - Sawtooth register
        volatile uint32_t DAC_STMODR;  ///< Offset: 0x60 - Sawtooth Mode register
    };

    /// Peripheral instances
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);
    inline Registers* DAC2 = reinterpret_cast<Registers*>(DAC2_BASE);
    inline Registers* DAC3 = reinterpret_cast<Registers*>(DAC3_BASE);
    inline Registers* DAC4 = reinterpret_cast<Registers*>(DAC4_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL2 = (4 << 18);  ///< DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
        constexpr uint32_t SWTRIGB1 = (1U << 16);  ///< DAC channel1 software trigger B
        constexpr uint32_t SWTRIGB2 = (1U << 17);  ///< DAC channel2 software trigger B
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC1DHRB = (12 << 16);  ///< DAC channel1 12-bit right-aligned data B
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC1DHRB = (12 << 20);  ///< DAC channel1 12-bit left-aligned data B
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        constexpr uint32_t DACC1DHRB = (8 << 8);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
        constexpr uint32_t DACC2DHRB = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
        constexpr uint32_t DACC2DHRB = (12 << 20);  ///< DAC channel2 12-bit left-aligned data B
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
        constexpr uint32_t DACC2DHRB = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
        constexpr uint32_t DACC1DORB = (12 << 16);  ///< DAC channel1 data output
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
        constexpr uint32_t DACC2DORB = (12 << 16);  ///< DAC channel2 data output
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DAC1RDY = (1U << 11);  ///< DAC channel1 ready status bit
        constexpr uint32_t DORSTAT1 = (1U << 12);  ///< DAC channel1 output register status bit
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
        constexpr uint32_t DAC2RDY = (1U << 27);  ///< DAC channel 2 ready status bit
        constexpr uint32_t DORSTAT2 = (1U << 28);  ///< DAC channel 2 output register status bit
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
        constexpr uint32_t DMADOUBLE1 = (1U << 8);  ///< DAC Channel1 DMA double data mode
        constexpr uint32_t SINFORMAT1 = (1U << 9);  ///< Enable signed format for DAC channel1
        constexpr uint32_t HFSEL = (2 << 14);  ///< High frequency interface mode selection
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
        constexpr uint32_t DMADOUBLE2 = (1U << 24);  ///< DAC Channel2 DMA double data mode
        constexpr uint32_t SINFORMAT2 = (1U << 25);  ///< Enable signed format for DAC channel2
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
    }

    /// DAC_STR1 Register bits
    namespace dac_str1_bits {
        constexpr uint32_t STRSTDATA1 = (12 << 0);  ///< DAC Channel 1 Sawtooth reset value
        constexpr uint32_t STDIR1 = (1U << 12);  ///< DAC Channel1 Sawtooth direction setting
        constexpr uint32_t STINCDATA1 = (16 << 16);  ///< DAC CH1 Sawtooth increment value (12.4 bit format)
    }

    /// DAC_STR2 Register bits
    namespace dac_str2_bits {
        constexpr uint32_t STRSTDATA2 = (12 << 0);  ///< DAC Channel 2 Sawtooth reset value
        constexpr uint32_t STDIR2 = (1U << 12);  ///< DAC Channel2 Sawtooth direction setting
        constexpr uint32_t STINCDATA2 = (16 << 16);  ///< DAC CH2 Sawtooth increment value (12.4 bit format)
    }

    /// DAC_STMODR Register bits
    namespace dac_stmodr_bits {
        constexpr uint32_t STRSTTRIGSEL1 = (4 << 0);  ///< DAC Channel 1 Sawtooth Reset trigger selection
        constexpr uint32_t STINCTRIGSEL1 = (4 << 8);  ///< DAC Channel 1 Sawtooth Increment trigger selection
        constexpr uint32_t STRSTTRIGSEL2 = (4 << 16);  ///< DAC Channel 1 Sawtooth Reset trigger selection
        constexpr uint32_t STINCTRIGSEL2 = (4 << 24);  ///< DAC Channel 2 Sawtooth Increment trigger selection
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x50000000;
    constexpr uint32_t ADC2_BASE = 0x50000100;
    constexpr uint32_t ADC3_BASE = 0x50000400;
    constexpr uint32_t ADC12_Common_BASE = 0x50000300;
    constexpr uint32_t ADC345_Common_BASE = 0x50000700;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - interrupt and status register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t CFGR;  ///< Offset: 0x0C - configuration register
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - configuration register
        volatile uint32_t SMPR1;  ///< Offset: 0x14 - sample time register 1
        volatile uint32_t SMPR2;  ///< Offset: 0x18 - sample time register 2
        volatile uint32_t TR1;  ///< Offset: 0x20 - watchdog threshold register 1
        volatile uint32_t TR2;  ///< Offset: 0x24 - watchdog threshold register
        volatile uint32_t TR3;  ///< Offset: 0x28 - watchdog threshold register 3
        volatile uint32_t SQR1;  ///< Offset: 0x30 - regular sequence register 1
        volatile uint32_t SQR2;  ///< Offset: 0x34 - regular sequence register 2
        volatile uint32_t SQR3;  ///< Offset: 0x38 - regular sequence register 3
        volatile uint32_t SQR4;  ///< Offset: 0x3C - regular sequence register 4
        volatile uint32_t DR;  ///< Offset: 0x40 - regular Data Register
        volatile uint32_t JSQR;  ///< Offset: 0x4C - injected sequence register
        volatile uint32_t OFR1;  ///< Offset: 0x60 - offset register 1
        volatile uint32_t OFR2;  ///< Offset: 0x64 - offset register 2
        volatile uint32_t OFR3;  ///< Offset: 0x68 - offset register 3
        volatile uint32_t OFR4;  ///< Offset: 0x6C - offset register 4
        volatile uint32_t JDR1;  ///< Offset: 0x80 - injected data register 1
        volatile uint32_t JDR2;  ///< Offset: 0x84 - injected data register 2
        volatile uint32_t JDR3;  ///< Offset: 0x88 - injected data register 3
        volatile uint32_t JDR4;  ///< Offset: 0x8C - injected data register 4
        volatile uint32_t AWD2CR;  ///< Offset: 0xA0 - Analog Watchdog 2 Configuration Register
        volatile uint32_t AWD3CR;  ///< Offset: 0xA4 - Analog Watchdog 3 Configuration Register
        volatile uint32_t DIFSEL;  ///< Offset: 0xB0 - Differential Mode Selection Register 2
        volatile uint32_t CALFACT;  ///< Offset: 0xB4 - Calibration Factors
        volatile uint32_t GCOMP;  ///< Offset: 0xC0 - Gain compensation Register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC3 = reinterpret_cast<Registers*>(ADC3_BASE);
    inline Registers* ADC12_Common = reinterpret_cast<Registers*>(ADC12_Common_BASE);
    inline Registers* ADC345_Common = reinterpret_cast<Registers*>(ADC345_Common_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t JQOVF = (1U << 10);  ///< JQOVF
        constexpr uint32_t AWD3 = (1U << 9);  ///< AWD3
        constexpr uint32_t AWD2 = (1U << 8);  ///< AWD2
        constexpr uint32_t AWD1 = (1U << 7);  ///< AWD1
        constexpr uint32_t JEOS = (1U << 6);  ///< JEOS
        constexpr uint32_t JEOC = (1U << 5);  ///< JEOC
        constexpr uint32_t OVR = (1U << 4);  ///< OVR
        constexpr uint32_t EOS = (1U << 3);  ///< EOS
        constexpr uint32_t EOC = (1U << 2);  ///< EOC
        constexpr uint32_t EOSMP = (1U << 1);  ///< EOSMP
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADRDY
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t JQOVFIE = (1U << 10);  ///< JQOVFIE
        constexpr uint32_t AWD3IE = (1U << 9);  ///< AWD3IE
        constexpr uint32_t AWD2IE = (1U << 8);  ///< AWD2IE
        constexpr uint32_t AWD1IE = (1U << 7);  ///< AWD1IE
        constexpr uint32_t JEOSIE = (1U << 6);  ///< JEOSIE
        constexpr uint32_t JEOCIE = (1U << 5);  ///< JEOCIE
        constexpr uint32_t OVRIE = (1U << 4);  ///< OVRIE
        constexpr uint32_t EOSIE = (1U << 3);  ///< EOSIE
        constexpr uint32_t EOCIE = (1U << 2);  ///< EOCIE
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< EOSMPIE
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADRDYIE
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADCAL
        constexpr uint32_t ADCALDIF = (1U << 30);  ///< ADCALDIF
        constexpr uint32_t DEEPPWD = (1U << 29);  ///< DEEPPWD
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADVREGEN
        constexpr uint32_t JADSTP = (1U << 5);  ///< JADSTP
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADSTP
        constexpr uint32_t JADSTART = (1U << 3);  ///< JADSTART
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADSTART
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADDIS
        constexpr uint32_t ADEN = (1U << 0);  ///< ADEN
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t JQDIS = (1U << 31);  ///< Injected Queue disable
        constexpr uint32_t AWD1CH = (5 << 26);  ///< Analog watchdog 1 channel selection
        constexpr uint32_t JAUTO = (1U << 25);  ///< JAUTO
        constexpr uint32_t JAWD1EN = (1U << 24);  ///< JAWD1EN
        constexpr uint32_t AWD1EN = (1U << 23);  ///< AWD1EN
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< AWD1SGL
        constexpr uint32_t JQM = (1U << 21);  ///< JQM
        constexpr uint32_t JDISCEN = (1U << 20);  ///< JDISCEN
        constexpr uint32_t DISCNUM = (3 << 17);  ///< DISCNUM
        constexpr uint32_t DISCEN = (1U << 16);  ///< DISCEN
        constexpr uint32_t ALIGN = (1U << 15);  ///< ALIGN
        constexpr uint32_t AUTDLY = (1U << 14);  ///< AUTDLY
        constexpr uint32_t CONT = (1U << 13);  ///< CONT
        constexpr uint32_t OVRMOD = (1U << 12);  ///< OVRMOD
        constexpr uint32_t EXTEN = (2 << 10);  ///< EXTEN
        constexpr uint32_t EXTSEL = (5 << 5);  ///< External trigger selection for regular group
        constexpr uint32_t RES = (2 << 3);  ///< RES
        constexpr uint32_t DMACFG = (1U << 1);  ///< DMACFG
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMAEN
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t SMPTRIG = (1U << 27);  ///< SMPTRIG
        constexpr uint32_t BULB = (1U << 26);  ///< BULB
        constexpr uint32_t SWTRIG = (1U << 25);  ///< SWTRIG
        constexpr uint32_t GCOMP = (1U << 16);  ///< GCOMP
        constexpr uint32_t ROVSM = (1U << 10);  ///< EXTEN
        constexpr uint32_t TROVS = (1U << 9);  ///< Triggered Regular Oversampling
        constexpr uint32_t OVSS = (4 << 5);  ///< ALIGN
        constexpr uint32_t OVSR = (3 << 2);  ///< RES
        constexpr uint32_t JOVSE = (1U << 1);  ///< DMACFG
        constexpr uint32_t ROVSE = (1U << 0);  ///< DMAEN
    }

    /// SMPR1 Register bits
    namespace smpr1_bits {
        constexpr uint32_t SMP9 = (3 << 27);  ///< SMP9
        constexpr uint32_t SMP8 = (3 << 24);  ///< SMP8
        constexpr uint32_t SMP7 = (3 << 21);  ///< SMP7
        constexpr uint32_t SMP6 = (3 << 18);  ///< SMP6
        constexpr uint32_t SMP5 = (3 << 15);  ///< SMP5
        constexpr uint32_t SMP4 = (3 << 12);  ///< SMP4
        constexpr uint32_t SMP3 = (3 << 9);  ///< SMP3
        constexpr uint32_t SMP2 = (3 << 6);  ///< SMP2
        constexpr uint32_t SMP1 = (3 << 3);  ///< SMP1
        constexpr uint32_t SMPPLUS = (1U << 31);  ///< Addition of one clock cycle to the sampling time
        constexpr uint32_t SMP0 = (3 << 0);  ///< SMP0
    }

    /// SMPR2 Register bits
    namespace smpr2_bits {
        constexpr uint32_t SMP18 = (3 << 24);  ///< SMP18
        constexpr uint32_t SMP17 = (3 << 21);  ///< SMP17
        constexpr uint32_t SMP16 = (3 << 18);  ///< SMP16
        constexpr uint32_t SMP15 = (3 << 15);  ///< SMP15
        constexpr uint32_t SMP14 = (3 << 12);  ///< SMP14
        constexpr uint32_t SMP13 = (3 << 9);  ///< SMP13
        constexpr uint32_t SMP12 = (3 << 6);  ///< SMP12
        constexpr uint32_t SMP11 = (3 << 3);  ///< SMP11
        constexpr uint32_t SMP10 = (3 << 0);  ///< SMP10
    }

    /// TR1 Register bits
    namespace tr1_bits {
        constexpr uint32_t HT1 = (12 << 16);  ///< HT1
        constexpr uint32_t AWDFILT = (3 << 12);  ///< AWDFILT
        constexpr uint32_t LT1 = (12 << 0);  ///< LT1
    }

    /// TR2 Register bits
    namespace tr2_bits {
        constexpr uint32_t HT2 = (8 << 16);  ///< HT2
        constexpr uint32_t LT2 = (8 << 0);  ///< LT2
    }

    /// TR3 Register bits
    namespace tr3_bits {
        constexpr uint32_t HT3 = (8 << 16);  ///< HT3
        constexpr uint32_t LT3 = (8 << 0);  ///< LT3
    }

    /// SQR1 Register bits
    namespace sqr1_bits {
        constexpr uint32_t SQ4 = (5 << 24);  ///< SQ4
        constexpr uint32_t SQ3 = (5 << 18);  ///< SQ3
        constexpr uint32_t SQ2 = (5 << 12);  ///< SQ2
        constexpr uint32_t SQ1 = (5 << 6);  ///< SQ1
        constexpr uint32_t L = (4 << 0);  ///< Regular channel sequence length
    }

    /// SQR2 Register bits
    namespace sqr2_bits {
        constexpr uint32_t SQ9 = (5 << 24);  ///< SQ9
        constexpr uint32_t SQ8 = (5 << 18);  ///< SQ8
        constexpr uint32_t SQ7 = (5 << 12);  ///< SQ7
        constexpr uint32_t SQ6 = (5 << 6);  ///< SQ6
        constexpr uint32_t SQ5 = (5 << 0);  ///< SQ5
    }

    /// SQR3 Register bits
    namespace sqr3_bits {
        constexpr uint32_t SQ14 = (5 << 24);  ///< SQ14
        constexpr uint32_t SQ13 = (5 << 18);  ///< SQ13
        constexpr uint32_t SQ12 = (5 << 12);  ///< SQ12
        constexpr uint32_t SQ11 = (5 << 6);  ///< SQ11
        constexpr uint32_t SQ10 = (5 << 0);  ///< SQ10
    }

    /// SQR4 Register bits
    namespace sqr4_bits {
        constexpr uint32_t SQ16 = (5 << 6);  ///< SQ16
        constexpr uint32_t SQ15 = (5 << 0);  ///< SQ15
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Regular Data converted
    }

    /// JSQR Register bits
    namespace jsqr_bits {
        constexpr uint32_t JSQ4 = (5 << 27);  ///< JSQ4
        constexpr uint32_t JSQ3 = (5 << 21);  ///< JSQ3
        constexpr uint32_t JSQ2 = (5 << 15);  ///< JSQ2
        constexpr uint32_t JSQ1 = (5 << 9);  ///< JSQ1
        constexpr uint32_t JEXTEN = (2 << 7);  ///< JEXTEN
        constexpr uint32_t JEXTSEL = (5 << 2);  ///< JEXTSEL
        constexpr uint32_t JL = (2 << 0);  ///< JL
    }

    /// OFR1 Register bits
    namespace ofr1_bits {
        constexpr uint32_t OFFSET1_EN = (1U << 31);  ///< OFFSET1_EN
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< OFFSET1_CH
        constexpr uint32_t SATEN = (1U << 25);  ///< SATEN
        constexpr uint32_t OFFSETPOS = (1U << 24);  ///< OFFSETPOS
        constexpr uint32_t OFFSET1 = (12 << 0);  ///< OFFSET1
    }

    /// OFR2 Register bits
    namespace ofr2_bits {
        constexpr uint32_t OFFSET1_EN = (1U << 31);  ///< OFFSET1_EN
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< OFFSET1_CH
        constexpr uint32_t SATEN = (1U << 25);  ///< SATEN
        constexpr uint32_t OFFSETPOS = (1U << 24);  ///< OFFSETPOS
        constexpr uint32_t OFFSET1 = (12 << 0);  ///< OFFSET1
    }

    /// OFR3 Register bits
    namespace ofr3_bits {
        constexpr uint32_t OFFSET1_EN = (1U << 31);  ///< OFFSET1_EN
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< OFFSET1_CH
        constexpr uint32_t SATEN = (1U << 25);  ///< SATEN
        constexpr uint32_t OFFSETPOS = (1U << 24);  ///< OFFSETPOS
        constexpr uint32_t OFFSET1 = (12 << 0);  ///< OFFSET1
    }

    /// OFR4 Register bits
    namespace ofr4_bits {
        constexpr uint32_t OFFSET1_EN = (1U << 31);  ///< OFFSET1_EN
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< OFFSET1_CH
        constexpr uint32_t SATEN = (1U << 25);  ///< SATEN
        constexpr uint32_t OFFSETPOS = (1U << 24);  ///< OFFSETPOS
        constexpr uint32_t OFFSET1 = (12 << 0);  ///< OFFSET1
    }

    /// JDR1 Register bits
    namespace jdr1_bits {
        constexpr uint32_t JDATA1 = (16 << 0);  ///< JDATA1
    }

    /// JDR2 Register bits
    namespace jdr2_bits {
        constexpr uint32_t JDATA2 = (16 << 0);  ///< JDATA2
    }

    /// JDR3 Register bits
    namespace jdr3_bits {
        constexpr uint32_t JDATA3 = (16 << 0);  ///< JDATA3
    }

    /// JDR4 Register bits
    namespace jdr4_bits {
        constexpr uint32_t JDATA4 = (16 << 0);  ///< JDATA4
    }

    /// AWD2CR Register bits
    namespace awd2cr_bits {
        constexpr uint32_t AWD2CH = (19 << 0);  ///< AWD2CH
    }

    /// AWD3CR Register bits
    namespace awd3cr_bits {
        constexpr uint32_t AWD3CH = (19 << 0);  ///< AWD3CH
    }

    /// DIFSEL Register bits
    namespace difsel_bits {
        constexpr uint32_t DIFSEL_0 = (1U << 0);  ///< Differential mode for channels 0
        constexpr uint32_t DIFSEL_1_18 = (18 << 1);  ///< Differential mode for channels 15 to 1
    }

    /// CALFACT Register bits
    namespace calfact_bits {
        constexpr uint32_t CALFACT_D = (7 << 16);  ///< CALFACT_D
        constexpr uint32_t CALFACT_S = (7 << 0);  ///< CALFACT_S
    }

    /// GCOMP Register bits
    namespace gcomp_bits {
        constexpr uint32_t GCOMPCOEFF = (14 << 0);  ///< GCOMPCOEFF
    }

}

// ============================================================================
// FMAC Peripheral
// ============================================================================

namespace fmac {
    /// Base addresses
    constexpr uint32_t FMAC_BASE = 0x40021400;

    /// FMAC Register structure
    struct Registers {
        volatile uint32_t X1BUFCFG;  ///< Offset: 0x00 - FMAC X1 Buffer Configuration register
        volatile uint32_t X2BUFCFG;  ///< Offset: 0x04 - FMAC X2 Buffer Configuration register
        volatile uint32_t YBUFCFG;  ///< Offset: 0x08 - FMAC Y Buffer Configuration register
        volatile uint32_t PARAM;  ///< Offset: 0x0C - FMAC Parameter register
        volatile uint32_t CR;  ///< Offset: 0x10 - FMAC Control register
        volatile uint32_t SR;  ///< Offset: 0x14 - FMAC Status register
        volatile uint32_t WDATA;  ///< Offset: 0x18 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x1C - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* FMAC = reinterpret_cast<Registers*>(FMAC_BASE);

    // Bit definitions
    /// X1BUFCFG Register bits
    namespace x1bufcfg_bits {
        constexpr uint32_t X1_BASE = (8 << 0);  ///< X1_BASE
        constexpr uint32_t X1_BUF_SIZE = (8 << 8);  ///< X1_BUF_SIZE
        constexpr uint32_t FULL_WM = (2 << 24);  ///< FULL_WM
    }

    /// X2BUFCFG Register bits
    namespace x2bufcfg_bits {
        constexpr uint32_t X2_BASE = (8 << 0);  ///< X1_BASE
        constexpr uint32_t X2_BUF_SIZE = (8 << 8);  ///< X1_BUF_SIZE
    }

    /// YBUFCFG Register bits
    namespace ybufcfg_bits {
        constexpr uint32_t Y_BASE = (8 << 0);  ///< X1_BASE
        constexpr uint32_t Y_BUF_SIZE = (8 << 8);  ///< X1_BUF_SIZE
        constexpr uint32_t EMPTY_WM = (2 << 24);  ///< EMPTY_WM
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t START = (1U << 31);  ///< START
        constexpr uint32_t FUNC = (7 << 24);  ///< FUNC
        constexpr uint32_t R = (8 << 16);  ///< R
        constexpr uint32_t Q = (8 << 8);  ///< Q
        constexpr uint32_t P = (8 << 0);  ///< P
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 16);  ///< RESET
        constexpr uint32_t CLIPEN = (1U << 15);  ///< CLIPEN
        constexpr uint32_t DMAWEN = (1U << 9);  ///< DMAWEN
        constexpr uint32_t DMAREN = (1U << 8);  ///< DMAREN
        constexpr uint32_t SATIEN = (1U << 4);  ///< SATIEN
        constexpr uint32_t UNFLIEN = (1U << 3);  ///< UNFLIEN
        constexpr uint32_t OVFLIEN = (1U << 2);  ///< OVFLIEN
        constexpr uint32_t WIEN = (1U << 1);  ///< WIEN
        constexpr uint32_t RIEN = (1U << 0);  ///< RIEN
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t YEMPTY = (1U << 0);  ///< YEMPTY
        constexpr uint32_t X1FULL = (1U << 1);  ///< X1FULL
        constexpr uint32_t OVFL = (1U << 8);  ///< OVFL
        constexpr uint32_t UNFL = (1U << 9);  ///< UNFL
        constexpr uint32_t SAT = (1U << 10);  ///< SAT
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< RDATA
    }

}

// ============================================================================
// CORDIC Peripheral
// ============================================================================

namespace cordic {
    /// Base addresses
    constexpr uint32_t CORDIC_BASE = 0x40020C00;

    /// CORDIC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - CORDIC Control Status register
        volatile uint32_t WDATA;  ///< Offset: 0x04 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x08 - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* CORDIC = reinterpret_cast<Registers*>(CORDIC_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t FUNC = (4 << 0);  ///< FUNC
        constexpr uint32_t PRECISION = (4 << 4);  ///< PRECISION
        constexpr uint32_t SCALE = (3 << 8);  ///< SCALE
        constexpr uint32_t IEN = (1U << 16);  ///< IEN
        constexpr uint32_t DMAREN = (1U << 17);  ///< DMAREN
        constexpr uint32_t DMAWEN = (1U << 18);  ///< DMAWEN
        constexpr uint32_t NRES = (1U << 19);  ///< NRES
        constexpr uint32_t NARGS = (1U << 20);  ///< NARGS
        constexpr uint32_t RESSIZE = (1U << 21);  ///< RESSIZE
        constexpr uint32_t ARGSIZE = (1U << 22);  ///< ARGSIZE
        constexpr uint32_t RRDY = (1U << 31);  ///< RRDY
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t ARG = (32 << 0);  ///< ARG
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RES = (32 << 0);  ///< RES
    }

}

// ============================================================================
// SAI Peripheral
// ============================================================================

namespace sai {
    /// Base addresses
    constexpr uint32_t SAI_BASE = 0x40015400;

    /// SAI Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x24 - BConfiguration register 1
        volatile uint32_t BCR2;  ///< Offset: 0x28 - BConfiguration register 2
        volatile uint32_t BFRCR;  ///< Offset: 0x2C - BFRCR
        volatile uint32_t BSLOTR;  ///< Offset: 0x30 - BSlot register
        volatile uint32_t BIM;  ///< Offset: 0x34 - BInterrupt mask register2
        volatile uint32_t BSR;  ///< Offset: 0x38 - BStatus register
        volatile uint32_t BCLRFR;  ///< Offset: 0x3C - BClear flag register
        volatile uint32_t BDR;  ///< Offset: 0x40 - BData register
        volatile uint32_t ACR1;  ///< Offset: 0x04 - AConfiguration register 1
        volatile uint32_t ACR2;  ///< Offset: 0x08 - AConfiguration register 2
        volatile uint32_t AFRCR;  ///< Offset: 0x0C - AFRCR
        volatile uint32_t ASLOTR;  ///< Offset: 0x10 - ASlot register
        volatile uint32_t AIM;  ///< Offset: 0x14 - AInterrupt mask register2
        volatile uint32_t ASR;  ///< Offset: 0x18 - AStatus register
        volatile uint32_t ACLRFR;  ///< Offset: 0x1C - AClear flag register
        volatile uint32_t ADR;  ///< Offset: 0x20 - AData register
        volatile uint32_t PDMCR;  ///< Offset: 0x44 - PDM control register
        volatile uint32_t PDMDLY;  ///< Offset: 0x48 - PDM delay register
    };

    /// Peripheral instances
    inline Registers* SAI = reinterpret_cast<Registers*>(SAI_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCJDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIBEN = (1U << 16);  ///< Audio block B enable
        constexpr uint32_t OutDri = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUS = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// BFRCR Register bits
    namespace bfrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// BSLOTR Register bits
    namespace bslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// BIM Register bits
    namespace bim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// BCLRFR Register bits
    namespace bclrfr_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// BDR Register bits
    namespace bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// ACR1 Register bits
    namespace acr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCJDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OutDri = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// ACR2 Register bits
    namespace acr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUS = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// AFRCR Register bits
    namespace afrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// ASLOTR Register bits
    namespace aslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// AIM Register bits
    namespace aim_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// ASR Register bits
    namespace asr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// ACLRFR Register bits
    namespace aclrfr_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// ADR Register bits
    namespace adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// PDMCR Register bits
    namespace pdmcr_bits {
        constexpr uint32_t PDMEN = (1U << 0);  ///< PDMEN
        constexpr uint32_t MICNBR = (2 << 4);  ///< MICNBR
        constexpr uint32_t CKEN1 = (1U << 8);  ///< CKEN1
        constexpr uint32_t CKEN2 = (1U << 9);  ///< CKEN2
        constexpr uint32_t CKEN3 = (1U << 10);  ///< CKEN3
        constexpr uint32_t CKEN4 = (1U << 11);  ///< CKEN4
    }

    /// PDMDLY Register bits
    namespace pdmdly_bits {
        constexpr uint32_t DLYM1L = (3 << 0);  ///< DLYM1L
        constexpr uint32_t DLYM1R = (3 << 4);  ///< DLYM1R
        constexpr uint32_t DLYM2L = (3 << 8);  ///< DLYM2L
        constexpr uint32_t DLYM2R = (3 << 12);  ///< DLYM2R
        constexpr uint32_t DLYM3L = (3 << 16);  ///< DLYM3L
        constexpr uint32_t DLYM3R = (3 << 20);  ///< DLYM3R
        constexpr uint32_t DLYM4L = (3 << 24);  ///< DLYM4L
        constexpr uint32_t DLYM4R = (3 << 28);  ///< DLYM4R
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x40002400;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t BKP0R;  ///< Offset: 0x100 - TAMP backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x104 - TAMP backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x108 - TAMP backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x10C - TAMP backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x110 - TAMP backup register
        volatile uint32_t BKP5R;  ///< Offset: 0x114 - TAMP backup register
        volatile uint32_t BKP6R;  ///< Offset: 0x118 - TAMP backup register
        volatile uint32_t BKP7R;  ///< Offset: 0x11C - TAMP backup register
        volatile uint32_t BKP8R;  ///< Offset: 0x120 - TAMP backup register
        volatile uint32_t BKP9R;  ///< Offset: 0x124 - TAMP backup register
        volatile uint32_t BKP10R;  ///< Offset: 0x128 - TAMP backup register
        volatile uint32_t BKP11R;  ///< Offset: 0x12C - TAMP backup register
        volatile uint32_t BKP12R;  ///< Offset: 0x130 - TAMP backup register
        volatile uint32_t BKP13R;  ///< Offset: 0x134 - TAMP backup register
        volatile uint32_t BKP14R;  ///< Offset: 0x138 - TAMP backup register
        volatile uint32_t BKP15R;  ///< Offset: 0x13C - TAMP backup register
        volatile uint32_t BKP16R;  ///< Offset: 0x140 - TAMP backup register
        volatile uint32_t BKP17R;  ///< Offset: 0x144 - TAMP backup register
        volatile uint32_t BKP18R;  ///< Offset: 0x148 - TAMP backup register
        volatile uint32_t BKP19R;  ///< Offset: 0x14C - TAMP backup register
        volatile uint32_t BKP20R;  ///< Offset: 0x150 - TAMP backup register
        volatile uint32_t BKP21R;  ///< Offset: 0x154 - TAMP backup register
        volatile uint32_t BKP22R;  ///< Offset: 0x158 - TAMP backup register
        volatile uint32_t BKP23R;  ///< Offset: 0x15C - TAMP backup register
        volatile uint32_t BKP24R;  ///< Offset: 0x160 - TAMP backup register
        volatile uint32_t BKP25R;  ///< Offset: 0x164 - TAMP backup register
        volatile uint32_t BKP26R;  ///< Offset: 0x168 - TAMP backup register
        volatile uint32_t BKP27R;  ///< Offset: 0x16C - TAMP backup register
        volatile uint32_t BKP28R;  ///< Offset: 0x170 - TAMP backup register
        volatile uint32_t BKP29R;  ///< Offset: 0x174 - TAMP backup register
        volatile uint32_t BKP30R;  ///< Offset: 0x178 - TAMP backup register
        volatile uint32_t BKP31R;  ///< Offset: 0x17C - TAMP backup register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< TAMP1E
        constexpr uint32_t TAMP2E = (1U << 1);  ///< TAMP2E
        constexpr uint32_t TAMP3E = (1U << 2);  ///< TAMP2E
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< ITAMP3E
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< ITAMP4E
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< ITAMP5E
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< ITAMP6E
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< TAMP1NOER
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< TAMP2NOER
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< TAMP3NOER
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< TAMP1MSK
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< TAMP2MSK
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< TAMP3MSK
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< TAMP1TRG
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< TAMP2TRG
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< TAMP3TRG
    }

    /// FLTCR Register bits
    namespace fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< TAMPFREQ
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMPFLT
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMPPRCH
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMPPUDIS
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< TAMP1IE
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< TAMP2IE
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< TAMP3IE
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< ITAMP3IE
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< ITAMP4IE
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< ITAMP5IE
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< ITAMP6IE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1F
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2F
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3F
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< ITAMP3F
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< ITAMP4F
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< ITAMP5F
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ITAMP6F
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF:
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< ITAMP4MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< CTAMP1F
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< CTAMP2F
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< CTAMP3F
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< CITAMP3F
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< CITAMP4F
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< CITAMP5F
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< CITAMP6F
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP5R Register bits
    namespace bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP6R Register bits
    namespace bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP7R Register bits
    namespace bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP8R Register bits
    namespace bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP9R Register bits
    namespace bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP10R Register bits
    namespace bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP11R Register bits
    namespace bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP12R Register bits
    namespace bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP13R Register bits
    namespace bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP14R Register bits
    namespace bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP15R Register bits
    namespace bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP16R Register bits
    namespace bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP17R Register bits
    namespace bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP18R Register bits
    namespace bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP19R Register bits
    namespace bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP20R Register bits
    namespace bkp20r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP21R Register bits
    namespace bkp21r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP22R Register bits
    namespace bkp22r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP23R Register bits
    namespace bkp23r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP24R Register bits
    namespace bkp24r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP25R Register bits
    namespace bkp25r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP26R Register bits
    namespace bkp26r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP27R Register bits
    namespace bkp27r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP28R Register bits
    namespace bkp28r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP29R Register bits
    namespace bkp29r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP30R Register bits
    namespace bkp30r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP31R Register bits
    namespace bkp31r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_BASE = 0xE000EF34;
    constexpr uint32_t FPU_CPACR_BASE = 0xE000ED88;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t FPCCR;  ///< Offset: 0x00 - Floating-point context control register
        volatile uint32_t FPCAR;  ///< Offset: 0x04 - Floating-point context address register
        volatile uint32_t FPSCR;  ///< Offset: 0x08 - Floating-point status control register
    };

    /// Peripheral instances
    inline Registers* FPU = reinterpret_cast<Registers*>(FPU_BASE);
    inline Registers* FPU_CPACR = reinterpret_cast<Registers*>(FPU_CPACR_BASE);

    // Bit definitions
    /// FPCCR Register bits
    namespace fpccr_bits {
        constexpr uint32_t LSPACT = (1U << 0);  ///< LSPACT
        constexpr uint32_t USER = (1U << 1);  ///< USER
        constexpr uint32_t THREAD = (1U << 3);  ///< THREAD
        constexpr uint32_t HFRDY = (1U << 4);  ///< HFRDY
        constexpr uint32_t MMRDY = (1U << 5);  ///< MMRDY
        constexpr uint32_t BFRDY = (1U << 6);  ///< BFRDY
        constexpr uint32_t MONRDY = (1U << 8);  ///< MONRDY
        constexpr uint32_t LSPEN = (1U << 30);  ///< LSPEN
        constexpr uint32_t ASPEN = (1U << 31);  ///< ASPEN
    }

    /// FPCAR Register bits
    namespace fpcar_bits {
        constexpr uint32_t ADDRESS = (29 << 3);  ///< Location of unpopulated floating-point
    }

    /// FPSCR Register bits
    namespace fpscr_bits {
        constexpr uint32_t IOC = (1U << 0);  ///< Invalid operation cumulative exception bit
        constexpr uint32_t DZC = (1U << 1);  ///< Division by zero cumulative exception bit.
        constexpr uint32_t OFC = (1U << 2);  ///< Overflow cumulative exception bit
        constexpr uint32_t UFC = (1U << 3);  ///< Underflow cumulative exception bit
        constexpr uint32_t IXC = (1U << 4);  ///< Inexact cumulative exception bit
        constexpr uint32_t IDC = (1U << 7);  ///< Input denormal cumulative exception bit.
        constexpr uint32_t RMode = (2 << 22);  ///< Rounding Mode control field
        constexpr uint32_t FZ = (1U << 24);  ///< Flush-to-zero mode control bit:
        constexpr uint32_t DN = (1U << 25);  ///< Default NaN mode control bit
        constexpr uint32_t AHP = (1U << 26);  ///< Alternative half-precision control bit
        constexpr uint32_t V = (1U << 28);  ///< Overflow condition code flag
        constexpr uint32_t C = (1U << 29);  ///< Carry condition code flag
        constexpr uint32_t Z = (1U << 30);  ///< Zero condition code flag
        constexpr uint32_t N = (1U << 31);  ///< Negative condition code flag
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000E084;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t TYPER;  ///< Offset: 0x00 - MPU type register
        volatile uint32_t CTRL;  ///< Offset: 0x04 - MPU control register
        volatile uint32_t RNR;  ///< Offset: 0x08 - MPU region number register
        volatile uint32_t RBAR;  ///< Offset: 0x0C - MPU region base address register
        volatile uint32_t RASR;  ///< Offset: 0x10 - MPU region attribute and size register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// TYPER Register bits
    namespace typer_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate flag
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of MPU instruction regions
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables the MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enables the operation of MPU during hard fault
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enable priviliged software access to default memory map
    }

    /// RNR Register bits
    namespace rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< MPU region
    }

    /// RBAR Register bits
    namespace rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field
    }

    /// RASR Register bits
    namespace rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< Size of the MPU protection region
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< memory attribute
        constexpr uint32_t C = (1U << 17);  ///< memory attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable memory attribute
        constexpr uint32_t TEX = (3 << 19);  ///< memory attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

}

// ============================================================================
// STK Peripheral
// ============================================================================

namespace stk {
    /// Base addresses
    constexpr uint32_t STK_BASE = 0xE000E010;

    /// STK Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - SysTick control and status register
        volatile uint32_t LOAD;  ///< Offset: 0x04 - SysTick reload value register
        volatile uint32_t VAL;  ///< Offset: 0x08 - SysTick current value register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick calibration value register
    };

    /// Peripheral instances
    inline Registers* STK = reinterpret_cast<Registers*>(STK_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick exception request enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source selection
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< COUNTFLAG
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< RELOAD value
    }

    /// VAL Register bits
    namespace val_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Calibration value
        constexpr uint32_t SKEW = (1U << 30);  ///< SKEW flag: Indicates whether the TENMS value is exact
        constexpr uint32_t NOREF = (1U << 31);  ///< NOREF flag. Reads as zero
    }

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED00;
    constexpr uint32_t SCB_ACTLR_BASE = 0xE000E008;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - CPUID base register
        volatile uint32_t ICSR;  ///< Offset: 0x04 - Interrupt control and state register
        volatile uint32_t VTOR;  ///< Offset: 0x08 - Vector table offset register
        volatile uint32_t AIRCR;  ///< Offset: 0x0C - Application interrupt and reset control register
        volatile uint32_t SCR;  ///< Offset: 0x10 - System control register
        volatile uint32_t CCR;  ///< Offset: 0x14 - Configuration and control register
        volatile uint32_t SHPR1;  ///< Offset: 0x18 - System handler priority registers
        volatile uint32_t SHPR2;  ///< Offset: 0x1C - System handler priority registers
        volatile uint32_t SHPR3;  ///< Offset: 0x20 - System handler priority registers
        volatile uint32_t SHCSR;  ///< Offset: 0x24 - System handler control and state register
        volatile uint32_t CFSR_UFSR_BFSR_MMFSR;  ///< Offset: 0x28 - Configurable fault status register
        volatile uint32_t HFSR;  ///< Offset: 0x2C - Hard fault status register
        volatile uint32_t MMFAR;  ///< Offset: 0x34 - Memory management fault address register
        volatile uint32_t BFAR;  ///< Offset: 0x38 - Bus fault address register
        volatile uint32_t AFSR;  ///< Offset: 0x3C - Auxiliary fault status register
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);
    inline Registers* SCB_ACTLR = reinterpret_cast<Registers*>(SCB_ACTLR_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Constant = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active vector
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to base level
        constexpr uint32_t VECTPENDING = (7 << 12);  ///< Pending vector
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit.
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (21 << 9);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< VECTRESET
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< SYSRESETREQ
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< PRIGROUP
        constexpr uint32_t ENDIANESS = (1U << 15);  ///< ENDIANESS
        constexpr uint32_t VECTKEYSTAT = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< SLEEPONEXIT
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< SLEEPDEEP
        constexpr uint32_t SEVEONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Configures how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< USERSETMPEND
        constexpr uint32_t UNALIGN__TRP = (1U << 3);  ///< UNALIGN_ TRP
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< DIV_0_TRP
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< BFHFNMIGN
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< Memory management fault exception active bit
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< Bus fault exception active bit
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< Usage fault exception active bit
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< SVC call active bit
        constexpr uint32_t MONITORACT = (1U << 8);  ///< Debug monitor active bit
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< PendSV exception active bit
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< SysTick exception active bit
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< Usage fault exception pending bit
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< Memory management fault exception pending bit
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< Bus fault exception pending bit
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< SVC call pending bit
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< Memory management fault enable bit
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< Bus fault enable bit
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< Usage fault enable bit
    }

    /// CFSR_UFSR_BFSR_MMFSR Register bits
    namespace cfsr_ufsr_bfsr_mmfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 1);  ///< Instruction access violation flag
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< Memory manager fault on unstacking for a return from exception
        constexpr uint32_t MSTKERR = (1U << 4);  ///< Memory manager fault on stacking for exception entry.
        constexpr uint32_t MLSPERR = (1U << 5);  ///< MLSPERR
        constexpr uint32_t MMARVALID = (1U << 7);  ///< Memory Management Fault Address Register (MMAR) valid flag
        constexpr uint32_t IBUSERR = (1U << 8);  ///< Instruction bus error
        constexpr uint32_t PRECISERR = (1U << 9);  ///< Precise data bus error
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< Imprecise data bus error
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< Bus fault on unstacking for a return from exception
        constexpr uint32_t STKERR = (1U << 12);  ///< Bus fault on stacking for exception entry
        constexpr uint32_t LSPERR = (1U << 13);  ///< Bus fault on floating-point lazy state preservation
        constexpr uint32_t BFARVALID = (1U << 15);  ///< Bus Fault Address Register (BFAR) valid flag
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< Undefined instruction usage fault
        constexpr uint32_t INVSTATE = (1U << 17);  ///< Invalid state usage fault
        constexpr uint32_t INVPC = (1U << 18);  ///< Invalid PC load usage fault
        constexpr uint32_t NOCP = (1U << 19);  ///< No coprocessor usage fault.
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< Unaligned access usage fault
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< Divide by zero usage fault
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< Vector table hard fault
        constexpr uint32_t FORCED = (1U << 30);  ///< Forced hard fault
        constexpr uint32_t DEBUG_VT = (1U << 31);  ///< Reserved for Debug use
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t MMFAR = (32 << 0);  ///< Memory management fault address
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t BFAR = (32 << 0);  ///< Bus fault address
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t IMPDEF = (32 << 0);  ///< Implementation defined
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;
    constexpr uint32_t NVIC_STIR_BASE = 0xE000EF00;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER0;  ///< Offset: 0x00 - Interrupt Set-Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x04 - Interrupt Set-Enable Register
        volatile uint32_t ISER2;  ///< Offset: 0x08 - Interrupt Set-Enable Register
        volatile uint32_t ISER3;  ///< Offset: 0x0C - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x80 - Interrupt Clear-Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x84 - Interrupt Clear-Enable Register
        volatile uint32_t ICER2;  ///< Offset: 0x88 - Interrupt Clear-Enable Register
        volatile uint32_t ICER3;  ///< Offset: 0x8C - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x104 - Interrupt Set-Pending Register
        volatile uint32_t ISPR2;  ///< Offset: 0x108 - Interrupt Set-Pending Register
        volatile uint32_t ISPR3;  ///< Offset: 0x10C - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x184 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR2;  ///< Offset: 0x188 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR3;  ///< Offset: 0x18C - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x200 - Interrupt Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x204 - Interrupt Active Bit Register
        volatile uint32_t IABR2;  ///< Offset: 0x208 - Interrupt Active Bit Register
        volatile uint32_t IABR3;  ///< Offset: 0x20C - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x320 - Interrupt Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x324 - Interrupt Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x328 - Interrupt Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x32C - Interrupt Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x330 - Interrupt Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x334 - Interrupt Priority Register
        volatile uint32_t IPR14;  ///< Offset: 0x338 - Interrupt Priority Register
        volatile uint32_t IPR15;  ///< Offset: 0x33C - Interrupt Priority Register
        volatile uint32_t IPR16;  ///< Offset: 0x340 - Interrupt Priority Register
        volatile uint32_t IPR17;  ///< Offset: 0x344 - Interrupt Priority Register
        volatile uint32_t IPR18;  ///< Offset: 0x348 - Interrupt Priority Register
        volatile uint32_t IPR19;  ///< Offset: 0x34C - Interrupt Priority Register
        volatile uint32_t IPR20;  ///< Offset: 0x350 - Interrupt Priority Register
        volatile uint32_t IPR21;  ///< Offset: 0x354 - Interrupt Priority Register
        volatile uint32_t IPR22;  ///< Offset: 0x358 - Interrupt Priority Register
        volatile uint32_t IPR23;  ///< Offset: 0x35C - Interrupt Priority Register
        volatile uint32_t IPR24;  ///< Offset: 0x360 - Interrupt Priority Register
        volatile uint32_t IPR25;  ///< Offset: 0x364 - Interrupt Priority Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);
    inline Registers* NVIC_STIR = reinterpret_cast<Registers*>(NVIC_STIR_BASE);

    // Bit definitions
    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER2 Register bits
    namespace iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER3 Register bits
    namespace iser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER2 Register bits
    namespace icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER3 Register bits
    namespace icer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR2 Register bits
    namespace ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR3 Register bits
    namespace ispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR2 Register bits
    namespace icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR3 Register bits
    namespace icpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR2 Register bits
    namespace iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR3 Register bits
    namespace iabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR14 Register bits
    namespace ipr14_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR15 Register bits
    namespace ipr15_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR16 Register bits
    namespace ipr16_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR17 Register bits
    namespace ipr17_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR18 Register bits
    namespace ipr18_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR19 Register bits
    namespace ipr19_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR20 Register bits
    namespace ipr20_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t FDCAN_BASE = 0x4000A400;
    constexpr uint32_t FDCAN1_BASE = 0x40006400;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CREL;  ///< Offset: 0x00 - FDCAN Core Release Register
        volatile uint32_t ENDN;  ///< Offset: 0x04 - FDCAN Core Release Register
        volatile uint32_t DBTP;  ///< Offset: 0x0C - This register is only writable if bits CCCR.CCE and...
        volatile uint32_t TEST;  ///< Offset: 0x10 - Write access to the Test Register has to be enabled by...
        volatile uint32_t RWD;  ///< Offset: 0x14 - The RAM Watchdog monitors the READY output of the...
        volatile uint32_t CCCR;  ///< Offset: 0x18 - For details about setting and resetting of single bits...
        volatile uint32_t NBTP;  ///< Offset: 0x1C - FDCAN_NBTP
        volatile uint32_t TSCC;  ///< Offset: 0x20 - FDCAN Timestamp Counter Configuration Register
        volatile uint32_t TSCV;  ///< Offset: 0x24 - FDCAN Timestamp Counter Value Register
        volatile uint32_t TOCC;  ///< Offset: 0x28 - FDCAN Timeout Counter Configuration Register
        volatile uint32_t TOCV;  ///< Offset: 0x2C - FDCAN Timeout Counter Value Register
        volatile uint32_t ECR;  ///< Offset: 0x40 - FDCAN Error Counter Register
        volatile uint32_t PSR;  ///< Offset: 0x44 - FDCAN Protocol Status Register
        volatile uint32_t TDCR;  ///< Offset: 0x48 - FDCAN Transmitter Delay Compensation Register
        volatile uint32_t IR;  ///< Offset: 0x50 - The flags are set when one of the listed conditions is...
        volatile uint32_t IE;  ///< Offset: 0x54 - The settings in the Interrupt Enable register determine...
        volatile uint32_t ILS;  ///< Offset: 0x58 - The Interrupt Line Select register assigns an interrupt...
        volatile uint32_t ILE;  ///< Offset: 0x5C - Each of the two interrupt lines to the CPU can be...
        volatile uint32_t RXGFC;  ///< Offset: 0x80 - Global settings for Message ID filtering. The Global...
        volatile uint32_t XIDAM;  ///< Offset: 0x84 - FDCAN Extended ID and Mask Register
        volatile uint32_t HPMS;  ///< Offset: 0x88 - This register is updated every time a Message ID filter...
        volatile uint32_t RXF0S;  ///< Offset: 0x90 - FDCAN Rx FIFO 0 Status Register
        volatile uint32_t RXF0A;  ///< Offset: 0x94 - CAN Rx FIFO 0 Acknowledge Register
        volatile uint32_t RXF1S;  ///< Offset: 0x98 - FDCAN Rx FIFO 1 Status Register
        volatile uint32_t RXF1A;  ///< Offset: 0x9C - FDCAN Rx FIFO 1 Acknowledge Register
        volatile uint32_t TXBC;  ///< Offset: 0xC0 - FDCAN Tx Buffer Configuration Register
        volatile uint32_t TXFQS;  ///< Offset: 0xC4 - The Tx FIFO/Queue status is related to the pending Tx...
        volatile uint32_t TXBRP;  ///< Offset: 0xC8 - FDCAN Tx Buffer Request Pending Register
        volatile uint32_t TXBAR;  ///< Offset: 0xCC - FDCAN Tx Buffer Add Request Register
        volatile uint32_t TXBCR;  ///< Offset: 0xD0 - FDCAN Tx Buffer Cancellation Request Register
        volatile uint32_t TXBTO;  ///< Offset: 0xD4 - FDCAN Tx Buffer Transmission Occurred Register
        volatile uint32_t TXBCF;  ///< Offset: 0xD8 - FDCAN Tx Buffer Cancellation Finished Register
        volatile uint32_t TXBTIE;  ///< Offset: 0xDC - FDCAN Tx Buffer Transmission Interrupt Enable Register
        volatile uint32_t TXBCIE;  ///< Offset: 0xE0 - FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        volatile uint32_t TXEFS;  ///< Offset: 0xE4 - FDCAN Tx Event FIFO Status Register
        volatile uint32_t TXEFA;  ///< Offset: 0xE8 - FDCAN Tx Event FIFO Acknowledge Register
        volatile uint32_t CKDIV;  ///< Offset: 0x100 - FDCAN CFG clock divider register
    };

    /// Peripheral instances
    inline Registers* FDCAN = reinterpret_cast<Registers*>(FDCAN_BASE);
    inline Registers* FDCAN1 = reinterpret_cast<Registers*>(FDCAN1_BASE);

    // Bit definitions
    /// CREL Register bits
    namespace crel_bits {
        constexpr uint32_t DAY = (8 << 0);  ///< DAY
        constexpr uint32_t MON = (8 << 8);  ///< MON
        constexpr uint32_t YEAR = (4 << 16);  ///< YEAR
        constexpr uint32_t SUBSTEP = (4 << 20);  ///< SUBSTEP
        constexpr uint32_t STEP = (4 << 24);  ///< STEP
        constexpr uint32_t REL = (4 << 28);  ///< REL
    }

    /// ENDN Register bits
    namespace endn_bits {
        constexpr uint32_t ETV = (32 << 0);  ///< ETV
    }

    /// DBTP Register bits
    namespace dbtp_bits {
        constexpr uint32_t DSJW = (4 << 0);  ///< DSJW
        constexpr uint32_t DTSEG2 = (4 << 4);  ///< DTSEG2
        constexpr uint32_t DTSEG1 = (5 << 8);  ///< DTSEG1
        constexpr uint32_t DBRP = (5 << 16);  ///< DBRP
        constexpr uint32_t TDC = (1U << 23);  ///< TDC
    }

    /// TEST Register bits
    namespace test_bits {
        constexpr uint32_t LBCK = (1U << 4);  ///< LBCK
        constexpr uint32_t TX = (2 << 5);  ///< TX
        constexpr uint32_t RX = (1U << 7);  ///< RX
    }

    /// RWD Register bits
    namespace rwd_bits {
        constexpr uint32_t WDC = (8 << 0);  ///< WDC
        constexpr uint32_t WDV = (8 << 8);  ///< WDV
    }

    /// CCCR Register bits
    namespace cccr_bits {
        constexpr uint32_t INIT = (1U << 0);  ///< INIT
        constexpr uint32_t CCE = (1U << 1);  ///< CCE
        constexpr uint32_t ASM = (1U << 2);  ///< ASM
        constexpr uint32_t CSA = (1U << 3);  ///< CSA
        constexpr uint32_t CSR = (1U << 4);  ///< CSR
        constexpr uint32_t MON = (1U << 5);  ///< MON
        constexpr uint32_t DAR = (1U << 6);  ///< DAR
        constexpr uint32_t TEST = (1U << 7);  ///< TEST
        constexpr uint32_t FDOE = (1U << 8);  ///< FDOE
        constexpr uint32_t BRSE = (1U << 9);  ///< BRSE
        constexpr uint32_t PXHD = (1U << 12);  ///< PXHD
        constexpr uint32_t EFBI = (1U << 13);  ///< EFBI
        constexpr uint32_t TXP = (1U << 14);  ///< TXP
        constexpr uint32_t NISO = (1U << 15);  ///< NISO
    }

    /// NBTP Register bits
    namespace nbtp_bits {
        constexpr uint32_t NTSEG2 = (7 << 0);  ///< NTSEG2
        constexpr uint32_t NTSEG1 = (8 << 8);  ///< NTSEG1
        constexpr uint32_t NBRP = (9 << 16);  ///< NBRP
        constexpr uint32_t NSJW = (7 << 25);  ///< NSJW
    }

    /// TSCC Register bits
    namespace tscc_bits {
        constexpr uint32_t TSS = (2 << 0);  ///< TSS
        constexpr uint32_t TCP = (4 << 16);  ///< TCP
    }

    /// TSCV Register bits
    namespace tscv_bits {
        constexpr uint32_t TSC = (16 << 0);  ///< TSC
    }

    /// TOCC Register bits
    namespace tocc_bits {
        constexpr uint32_t ETOC = (1U << 0);  ///< ETOC
        constexpr uint32_t TOS = (2 << 1);  ///< TOS
        constexpr uint32_t TOP = (16 << 16);  ///< TOP
    }

    /// TOCV Register bits
    namespace tocv_bits {
        constexpr uint32_t TOC = (16 << 0);  ///< TOC
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TEC = (8 << 0);  ///< TEC
        constexpr uint32_t REC = (7 << 8);  ///< TREC
        constexpr uint32_t RP = (1U << 15);  ///< RP
        constexpr uint32_t CEL = (8 << 16);  ///< CEL
    }

    /// PSR Register bits
    namespace psr_bits {
        constexpr uint32_t LEC = (3 << 0);  ///< LEC
        constexpr uint32_t ACT = (2 << 3);  ///< ACT
        constexpr uint32_t EP = (1U << 5);  ///< EP
        constexpr uint32_t EW = (1U << 6);  ///< EW
        constexpr uint32_t BO = (1U << 7);  ///< BO
        constexpr uint32_t DLEC = (3 << 8);  ///< DLEC
        constexpr uint32_t RESI = (1U << 11);  ///< RESI
        constexpr uint32_t RBRS = (1U << 12);  ///< RBRS
        constexpr uint32_t REDL = (1U << 13);  ///< REDL
        constexpr uint32_t PXE = (1U << 14);  ///< PXE
        constexpr uint32_t TDCV = (7 << 16);  ///< TDCV
    }

    /// TDCR Register bits
    namespace tdcr_bits {
        constexpr uint32_t TDCF = (7 << 0);  ///< TDCF
        constexpr uint32_t TDCO = (7 << 8);  ///< TDCO
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t RF0N = (1U << 0);  ///< RF0N
        constexpr uint32_t RF0F = (1U << 1);  ///< RF0F
        constexpr uint32_t RF0L = (1U << 2);  ///< RF0L
        constexpr uint32_t RF1N = (1U << 3);  ///< RF1N
        constexpr uint32_t RF1F = (1U << 4);  ///< RF1F
        constexpr uint32_t RF1L = (1U << 5);  ///< RF1L
        constexpr uint32_t HPM = (1U << 6);  ///< HPM
        constexpr uint32_t TC = (1U << 7);  ///< TC
        constexpr uint32_t TCF = (1U << 8);  ///< TCF
        constexpr uint32_t TFE = (1U << 9);  ///< TFE
        constexpr uint32_t TEFN = (1U << 10);  ///< TEFN
        constexpr uint32_t TEFF = (1U << 11);  ///< TEFF
        constexpr uint32_t TEFL = (1U << 12);  ///< TEFL
        constexpr uint32_t TSW = (1U << 13);  ///< TSW
        constexpr uint32_t MRAF = (1U << 14);  ///< MRAF
        constexpr uint32_t TOO = (1U << 15);  ///< TOO
        constexpr uint32_t ELO = (1U << 16);  ///< ELO
        constexpr uint32_t EP = (1U << 17);  ///< EP
        constexpr uint32_t EW = (1U << 18);  ///< EW
        constexpr uint32_t BO = (1U << 19);  ///< BO
        constexpr uint32_t WDI = (1U << 20);  ///< WDI
        constexpr uint32_t PEA = (1U << 21);  ///< PEA
        constexpr uint32_t PED = (1U << 22);  ///< PED
        constexpr uint32_t ARA = (1U << 23);  ///< ARA
    }

    /// IE Register bits
    namespace ie_bits {
        constexpr uint32_t RF0NE = (1U << 0);  ///< RF0NE
        constexpr uint32_t RF0FE = (1U << 1);  ///< RF0FE
        constexpr uint32_t RF0LE = (1U << 2);  ///< RF0LE
        constexpr uint32_t RF1NE = (1U << 3);  ///< RF1NE
        constexpr uint32_t RF1FE = (1U << 4);  ///< RF1FE
        constexpr uint32_t RF1LE = (1U << 5);  ///< RF1LE
        constexpr uint32_t HPME = (1U << 6);  ///< HPME
        constexpr uint32_t TCE = (1U << 7);  ///< TCE
        constexpr uint32_t TCFE = (1U << 8);  ///< TCFE
        constexpr uint32_t TFEE = (1U << 9);  ///< TFEE
        constexpr uint32_t TEFNE = (1U << 10);  ///< TEFNE
        constexpr uint32_t TEFFE = (1U << 11);  ///< TEFFE
        constexpr uint32_t TEFLE = (1U << 12);  ///< TEFLE
        constexpr uint32_t TSWE = (1U << 13);  ///< TSWE
        constexpr uint32_t MRAFE = (1U << 14);  ///< MRAFE
        constexpr uint32_t TOOE = (1U << 15);  ///< TOOE
        constexpr uint32_t ELOE = (1U << 16);  ///< ELOE
        constexpr uint32_t EPE = (1U << 17);  ///< EPE
        constexpr uint32_t EWE = (1U << 18);  ///< EWE
        constexpr uint32_t BOE = (1U << 19);  ///< BOE
        constexpr uint32_t WDIE = (1U << 20);  ///< WDIE
        constexpr uint32_t PEAE = (1U << 21);  ///< PEAE
        constexpr uint32_t PEDE = (1U << 22);  ///< PEDE
        constexpr uint32_t ARAE = (1U << 23);  ///< ARAE
    }

    /// ILS Register bits
    namespace ils_bits {
        constexpr uint32_t RxFIFO0 = (1U << 0);  ///< RxFIFO0
        constexpr uint32_t RxFIFO1 = (1U << 1);  ///< RxFIFO1
        constexpr uint32_t SMSG = (1U << 2);  ///< SMSG
        constexpr uint32_t TFERR = (1U << 3);  ///< TFERR
        constexpr uint32_t MISC = (1U << 4);  ///< MISC
        constexpr uint32_t BERR = (1U << 5);  ///< BERR
        constexpr uint32_t PERR = (1U << 6);  ///< PERR
    }

    /// ILE Register bits
    namespace ile_bits {
        constexpr uint32_t EINT0 = (1U << 0);  ///< EINT0
        constexpr uint32_t EINT1 = (1U << 1);  ///< EINT1
    }

    /// RXGFC Register bits
    namespace rxgfc_bits {
        constexpr uint32_t RRFE = (1U << 0);  ///< RRFE
        constexpr uint32_t RRFS = (1U << 1);  ///< RRFS
        constexpr uint32_t ANFE = (2 << 2);  ///< ANFE
        constexpr uint32_t ANFS = (2 << 4);  ///< ANFS
        constexpr uint32_t F1OM = (1U << 8);  ///< F1OM
        constexpr uint32_t F0OM = (1U << 9);  ///< F0OM
        constexpr uint32_t LSS = (5 << 16);  ///< LSS
        constexpr uint32_t LSE = (4 << 24);  ///< LSE
    }

    /// XIDAM Register bits
    namespace xidam_bits {
        constexpr uint32_t EIDM = (29 << 0);  ///< EIDM
    }

    /// HPMS Register bits
    namespace hpms_bits {
        constexpr uint32_t BIDX = (3 << 0);  ///< BIDX
        constexpr uint32_t MSI = (2 << 6);  ///< MSI
        constexpr uint32_t FIDX = (5 << 8);  ///< FIDX
        constexpr uint32_t FLST = (1U << 15);  ///< FLST
    }

    /// RXF0S Register bits
    namespace rxf0s_bits {
        constexpr uint32_t F0FL = (4 << 0);  ///< F0FL
        constexpr uint32_t F0GI = (2 << 8);  ///< F0GI
        constexpr uint32_t F0PI = (2 << 16);  ///< F0PI
        constexpr uint32_t F0F = (1U << 24);  ///< F0F
        constexpr uint32_t RF0L = (1U << 25);  ///< RF0L
    }

    /// RXF0A Register bits
    namespace rxf0a_bits {
        constexpr uint32_t F0AI = (3 << 0);  ///< F0AI
    }

    /// RXF1S Register bits
    namespace rxf1s_bits {
        constexpr uint32_t F1FL = (4 << 0);  ///< F1FL
        constexpr uint32_t F1GI = (2 << 8);  ///< F1GI
        constexpr uint32_t F1PI = (2 << 16);  ///< F1PI
        constexpr uint32_t F1F = (1U << 24);  ///< F1F
        constexpr uint32_t RF1L = (1U << 25);  ///< RF1L
    }

    /// RXF1A Register bits
    namespace rxf1a_bits {
        constexpr uint32_t F1AI = (3 << 0);  ///< F1AI
    }

    /// TXBC Register bits
    namespace txbc_bits {
        constexpr uint32_t TFQM = (1U << 24);  ///< TFQM
    }

    /// TXFQS Register bits
    namespace txfqs_bits {
        constexpr uint32_t TFFL = (3 << 0);  ///< TFFL
        constexpr uint32_t TFGI = (2 << 8);  ///< TFGI
        constexpr uint32_t TFQPI = (2 << 16);  ///< TFQPI
        constexpr uint32_t TFQF = (1U << 21);  ///< TFQF
    }

    /// TXBRP Register bits
    namespace txbrp_bits {
        constexpr uint32_t TRP = (3 << 0);  ///< TRP
    }

    /// TXBAR Register bits
    namespace txbar_bits {
        constexpr uint32_t AR = (3 << 0);  ///< AR
    }

    /// TXBCR Register bits
    namespace txbcr_bits {
        constexpr uint32_t CR = (3 << 0);  ///< CR
    }

    /// TXBTO Register bits
    namespace txbto_bits {
        constexpr uint32_t TO = (3 << 0);  ///< TO
    }

    /// TXBCF Register bits
    namespace txbcf_bits {
        constexpr uint32_t CF = (3 << 0);  ///< CF
    }

    /// TXBTIE Register bits
    namespace txbtie_bits {
        constexpr uint32_t TIE = (3 << 0);  ///< TIE
    }

    /// TXBCIE Register bits
    namespace txbcie_bits {
        constexpr uint32_t CFIE = (3 << 0);  ///< CFIE
    }

    /// TXEFS Register bits
    namespace txefs_bits {
        constexpr uint32_t EFFL = (3 << 0);  ///< EFFL
        constexpr uint32_t EFGI = (2 << 8);  ///< EFGI
        constexpr uint32_t EFPI = (2 << 16);  ///< EFPI
        constexpr uint32_t EFF = (1U << 24);  ///< EFF
        constexpr uint32_t TEFL = (1U << 25);  ///< TEFL
    }

    /// TXEFA Register bits
    namespace txefa_bits {
        constexpr uint32_t EFAI = (2 << 0);  ///< EFAI
    }

    /// CKDIV Register bits
    namespace ckdiv_bits {
        constexpr uint32_t PDIV = (4 << 0);  ///< input clock divider. the APB clock could be divided prior to be used by the CAN sub
    }

}

// ============================================================================
// UCPD1 Peripheral
// ============================================================================

namespace ucpd1 {
    /// Base addresses
    constexpr uint32_t UCPD1_BASE = 0x4000A000;

    /// UCPD1 Register structure
    struct Registers {
        volatile uint32_t CFG1;  ///< Offset: 0x00 - UCPD configuration register 1
        volatile uint32_t CFG2;  ///< Offset: 0x04 - UCPD configuration register 2
        volatile uint32_t CR;  ///< Offset: 0x0C - UCPD configuration register 2
        volatile uint32_t IMR;  ///< Offset: 0x10 - UCPD Interrupt Mask Register
        volatile uint32_t SR;  ///< Offset: 0x14 - UCPD Status Register
        volatile uint32_t ICR;  ///< Offset: 0x18 - UCPD Interrupt Clear Register
        volatile uint32_t TX_ORDSET;  ///< Offset: 0x1C - UCPD Tx Ordered Set Type Register
        volatile uint32_t TX_PAYSZ;  ///< Offset: 0x20 - UCPD Tx Paysize Register
        volatile uint32_t TXDR;  ///< Offset: 0x24 - UCPD Tx Data Register
        volatile uint32_t RX_ORDSET;  ///< Offset: 0x28 - UCPD Rx Ordered Set Register
        volatile uint32_t RX_PAYSZ;  ///< Offset: 0x2C - UCPD Rx Paysize Register
        volatile uint32_t RXDR;  ///< Offset: 0x30 - UCPD Rx Data Register
        volatile uint32_t RX_ORDEXT1;  ///< Offset: 0x34 - UCPD Rx Ordered Set Extension Register 1
        volatile uint32_t RX_ORDEXT2;  ///< Offset: 0x38 - UCPD Rx Ordered Set Extension Register 2
    };

    /// Peripheral instances
    inline Registers* UCPD1 = reinterpret_cast<Registers*>(UCPD1_BASE);

    // Bit definitions
    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t HBITCLKDIV = (6 << 0);  ///< HBITCLKDIV
        constexpr uint32_t IFRGAP = (5 << 6);  ///< IFRGAP
        constexpr uint32_t TRANSWIN = (5 << 11);  ///< TRANSWIN
        constexpr uint32_t PSC_USBPDCLK = (3 << 17);  ///< PSC_USBPDCLK
        constexpr uint32_t RXORDSETEN = (9 << 20);  ///< RXORDSETEN
        constexpr uint32_t TXDMAEN = (1U << 29);  ///< TXDMAEN
        constexpr uint32_t RXDMAEN = (1U << 30);  ///< RXDMAEN
        constexpr uint32_t UCPDEN = (1U << 31);  ///< UCPDEN
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t RXFILTDIS = (1U << 0);  ///< RXFILTDIS
        constexpr uint32_t RXFILT2N3 = (1U << 1);  ///< RXFILT2N3
        constexpr uint32_t FORCECLK = (1U << 2);  ///< FORCECLK
        constexpr uint32_t WUPEN = (1U << 3);  ///< WUPEN
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TXMODE = (2 << 0);  ///< TXMODE
        constexpr uint32_t TXSEND = (1U << 2);  ///< TXSEND
        constexpr uint32_t TXHRST = (1U << 3);  ///< TXHRST
        constexpr uint32_t RXMODE = (1U << 4);  ///< RXMODE
        constexpr uint32_t PHYRXEN = (1U << 5);  ///< PHYRXEN
        constexpr uint32_t PHYCCSEL = (1U << 6);  ///< PHYCCSEL
        constexpr uint32_t ANASUBMODE = (2 << 7);  ///< ANASUBMODE
        constexpr uint32_t ANAMODE = (1U << 9);  ///< ANAMODE
        constexpr uint32_t CCENABLE = (2 << 10);  ///< CCENABLE
        constexpr uint32_t FRSRXEN = (1U << 16);  ///< FRSRXEN
        constexpr uint32_t FRSTX = (1U << 17);  ///< FRSTX
        constexpr uint32_t RDCH = (1U << 18);  ///< RDCH
        constexpr uint32_t CC1TCDIS = (1U << 20);  ///< CC1TCDIS
        constexpr uint32_t CC2TCDIS = (1U << 21);  ///< CC2TCDIS
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t TXISIE = (1U << 0);  ///< TXISIE
        constexpr uint32_t TXMSGDISCIE = (1U << 1);  ///< TXMSGDISCIE
        constexpr uint32_t TXMSGSENTIE = (1U << 2);  ///< TXMSGSENTIE
        constexpr uint32_t TXMSGABTIE = (1U << 3);  ///< TXMSGABTIE
        constexpr uint32_t HRSTDISCIE = (1U << 4);  ///< HRSTDISCIE
        constexpr uint32_t HRSTSENTIE = (1U << 5);  ///< HRSTSENTIE
        constexpr uint32_t TXUNDIE = (1U << 6);  ///< TXUNDIE
        constexpr uint32_t RXNEIE = (1U << 8);  ///< RXNEIE
        constexpr uint32_t RXORDDETIE = (1U << 9);  ///< RXORDDETIE
        constexpr uint32_t RXHRSTDETIE = (1U << 10);  ///< RXHRSTDETIE
        constexpr uint32_t RXOVRIE = (1U << 11);  ///< RXOVRIE
        constexpr uint32_t RXMSGENDIE = (1U << 12);  ///< RXMSGENDIE
        constexpr uint32_t TYPECEVT1IE = (1U << 14);  ///< TYPECEVT1IE
        constexpr uint32_t TYPECEVT2IE = (1U << 15);  ///< TYPECEVT2IE
        constexpr uint32_t FRSEVTIE = (1U << 20);  ///< FRSEVTIE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TXIS = (1U << 0);  ///< TXIS
        constexpr uint32_t TXMSGDISC = (1U << 1);  ///< TXMSGDISC
        constexpr uint32_t TXMSGSENT = (1U << 2);  ///< TXMSGSENT
        constexpr uint32_t TXMSGABT = (1U << 3);  ///< TXMSGABT
        constexpr uint32_t HRSTDISC = (1U << 4);  ///< HRSTDISC
        constexpr uint32_t HRSTSENT = (1U << 5);  ///< HRSTSENT
        constexpr uint32_t TXUND = (1U << 6);  ///< TXUND
        constexpr uint32_t RXNE = (1U << 8);  ///< RXNE
        constexpr uint32_t RXORDDET = (1U << 9);  ///< RXORDDET
        constexpr uint32_t RXHRSTDET = (1U << 10);  ///< RXHRSTDET
        constexpr uint32_t RXOVR = (1U << 11);  ///< RXOVR
        constexpr uint32_t RXMSGEND = (1U << 12);  ///< RXMSGEND
        constexpr uint32_t RXERR = (1U << 13);  ///< RXERR
        constexpr uint32_t TYPECEVT1 = (1U << 14);  ///< TYPECEVT1
        constexpr uint32_t TYPECEVT2 = (1U << 15);  ///< TYPECEVT2
        constexpr uint32_t TYPEC_VSTATE_CC1 = (2 << 16);  ///< TYPEC_VSTATE_CC1
        constexpr uint32_t TYPEC_VSTATE_CC2 = (2 << 18);  ///< TYPEC_VSTATE_CC2
        constexpr uint32_t FRSEVT = (1U << 20);  ///< FRSEVT
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t TXMSGDISCCF = (1U << 1);  ///< TXMSGDISCCF
        constexpr uint32_t TXMSGSENTCF = (1U << 2);  ///< TXMSGSENTCF
        constexpr uint32_t TXMSGABTCF = (1U << 3);  ///< TXMSGABTCF
        constexpr uint32_t HRSTDISCCF = (1U << 4);  ///< HRSTDISCCF
        constexpr uint32_t HRSTSENTCF = (1U << 5);  ///< HRSTSENTCF
        constexpr uint32_t TXUNDCF = (1U << 6);  ///< TXUNDCF
        constexpr uint32_t RXORDDETCF = (1U << 9);  ///< RXORDDETCF
        constexpr uint32_t RXHRSTDETCF = (1U << 10);  ///< RXHRSTDETCF
        constexpr uint32_t RXOVRCF = (1U << 11);  ///< RXOVRCF
        constexpr uint32_t RXMSGENDCF = (1U << 12);  ///< RXMSGENDCF
        constexpr uint32_t TYPECEVT1CF = (1U << 14);  ///< TYPECEVT1CF
        constexpr uint32_t TYPECEVT2CF = (1U << 15);  ///< TYPECEVT2CF
        constexpr uint32_t FRSEVTCF = (1U << 20);  ///< FRSEVTCF
    }

    /// TX_ORDSET Register bits
    namespace tx_ordset_bits {
        constexpr uint32_t TXORDSET = (20 << 0);  ///< TXORDSET
    }

    /// TX_PAYSZ Register bits
    namespace tx_paysz_bits {
        constexpr uint32_t TXPAYSZ = (10 << 0);  ///< TXPAYSZ
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< TXDATA
    }

    /// RX_ORDSET Register bits
    namespace rx_ordset_bits {
        constexpr uint32_t RXORDSET = (3 << 0);  ///< RXORDSET
        constexpr uint32_t RXSOP3OF4 = (1U << 3);  ///< RXSOP3OF4
        constexpr uint32_t RXSOPKINVALID = (3 << 4);  ///< RXSOPKINVALID
    }

    /// RX_PAYSZ Register bits
    namespace rx_paysz_bits {
        constexpr uint32_t RXPAYSZ = (10 << 0);  ///< RXPAYSZ
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< RXDATA
    }

    /// RX_ORDEXT1 Register bits
    namespace rx_ordext1_bits {
        constexpr uint32_t RXSOPX1 = (20 << 0);  ///< RXSOPX1
    }

    /// RX_ORDEXT2 Register bits
    namespace rx_ordext2_bits {
        constexpr uint32_t RXSOPX2 = (20 << 0);  ///< RXSOPX2
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_FS_device_BASE = 0x40005C00;

    /// USB Register structure
    struct Registers {
        volatile uint32_t EP0R;  ///< Offset: 0x00 - USB endpoint n register
        volatile uint32_t EP1R;  ///< Offset: 0x04 - USB endpoint n register
        volatile uint32_t EP2R;  ///< Offset: 0x08 - USB endpoint n register
        volatile uint32_t EP3R;  ///< Offset: 0x0C - USB endpoint n register
        volatile uint32_t EP4R;  ///< Offset: 0x10 - USB endpoint n register
        volatile uint32_t EP5R;  ///< Offset: 0x14 - USB endpoint n register
        volatile uint32_t EP6R;  ///< Offset: 0x18 - USB endpoint n register
        volatile uint32_t EP7R;  ///< Offset: 0x1C - USB endpoint n register
        volatile uint32_t CNTR;  ///< Offset: 0x40 - USB control register
        volatile uint32_t ISTR;  ///< Offset: 0x44 - USB interrupt status register
        volatile uint32_t FNR;  ///< Offset: 0x48 - USB frame number register
        volatile uint32_t DADDR;  ///< Offset: 0x4C - USB device address
        volatile uint32_t BTABLE;  ///< Offset: 0x50 - Buffer table address
    };

    /// Peripheral instances
    inline Registers* USB_FS_device = reinterpret_cast<Registers*>(USB_FS_device_BASE);

    // Bit definitions
    /// EP0R Register bits
    namespace ep0r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP1R Register bits
    namespace ep1r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP2R Register bits
    namespace ep2r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP3R Register bits
    namespace ep3r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP4R Register bits
    namespace ep4r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP5R Register bits
    namespace ep5r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP6R Register bits
    namespace ep6r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// EP7R Register bits
    namespace ep7r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< EA
        constexpr uint32_t STAT_TX = (2 << 4);  ///< STAT_TX
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< DTOG_TX
        constexpr uint32_t CTR_TX = (1U << 7);  ///< CTR_TX
        constexpr uint32_t EP_KIND = (1U << 8);  ///< EP_KIND
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< EP_TYPE
        constexpr uint32_t SETUP = (1U << 11);  ///< SETUP
        constexpr uint32_t STAT_RX = (2 << 12);  ///< STAT_RX
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< DTOG_RX
        constexpr uint32_t CTR_RX = (1U << 15);  ///< CTR_RX
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t FRES = (1U << 0);  ///< FRES
        constexpr uint32_t PDWN = (1U << 1);  ///< PDWN
        constexpr uint32_t LP_MODE = (1U << 2);  ///< LP_MODE
        constexpr uint32_t FSUSP = (1U << 3);  ///< FSUSP
        constexpr uint32_t RESUME = (1U << 4);  ///< RESUME
        constexpr uint32_t L1RESUME = (1U << 5);  ///< L1RESUME
        constexpr uint32_t L1REQM = (1U << 7);  ///< L1REQM
        constexpr uint32_t ESOFM = (1U << 8);  ///< ESOFM
        constexpr uint32_t SOFM = (1U << 9);  ///< SOFM
        constexpr uint32_t RESETM = (1U << 10);  ///< RESETM
        constexpr uint32_t SUSPM = (1U << 11);  ///< SUSPM
        constexpr uint32_t WKUPM = (1U << 12);  ///< WKUPM
        constexpr uint32_t ERRM = (1U << 13);  ///< ERRM
        constexpr uint32_t PMAOVRM = (1U << 14);  ///< PMAOVRM
        constexpr uint32_t CTRM = (1U << 15);  ///< CTRM
    }

    /// ISTR Register bits
    namespace istr_bits {
        constexpr uint32_t EP_ID = (4 << 0);  ///< EP_ID
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t L1REQ = (1U << 7);  ///< L1REQ
        constexpr uint32_t ESOF = (1U << 8);  ///< ESOF
        constexpr uint32_t SOF = (1U << 9);  ///< SOF
        constexpr uint32_t RESET = (1U << 10);  ///< RESET
        constexpr uint32_t SUSP = (1U << 11);  ///< SUSP
        constexpr uint32_t WKUP = (1U << 12);  ///< WKUP
        constexpr uint32_t ERR = (1U << 13);  ///< ERR
        constexpr uint32_t PMAOVR = (1U << 14);  ///< PMAOVR
        constexpr uint32_t CTR = (1U << 15);  ///< CTR
    }

    /// FNR Register bits
    namespace fnr_bits {
        constexpr uint32_t FN = (11 << 0);  ///< FN
        constexpr uint32_t LSOF = (2 << 11);  ///< LSOF
        constexpr uint32_t LCK = (1U << 13);  ///< LCK
        constexpr uint32_t RXDM = (1U << 14);  ///< RXDM
        constexpr uint32_t RXDP = (1U << 15);  ///< RXDP
    }

    /// DADDR Register bits
    namespace daddr_bits {
        constexpr uint32_t ADD = (7 << 0);  ///< ADD
        constexpr uint32_t EF = (1U << 7);  ///< EF
    }

    /// BTABLE Register bits
    namespace btable_bits {
        constexpr uint32_t BTABLE = (13 << 3);  ///< BTABLE
    }

}

// ============================================================================
// CRS Peripheral
// ============================================================================

namespace crs {
    /// Base addresses
    constexpr uint32_t CRS_BASE = 0x40002000;

    /// CRS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - CRS control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - This register can be written only when the frequency...
        volatile uint32_t ISR;  ///< Offset: 0x08 - CRS interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x0C - CRS interrupt flag clear register
    };

    /// Peripheral instances
    inline Registers* CRS = reinterpret_cast<Registers*>(CRS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SYNCOKIE = (1U << 0);  ///< SYNC event OK interrupt enable
        constexpr uint32_t SYNCWARNIE = (1U << 1);  ///< SYNC warning interrupt enable
        constexpr uint32_t ERRIE = (1U << 2);  ///< Synchronization or trimming error interrupt enable
        constexpr uint32_t ESYNCIE = (1U << 3);  ///< Expected SYNC interrupt enable
        constexpr uint32_t CEN = (1U << 5);  ///< Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
        constexpr uint32_t AUTOTRIMEN = (1U << 6);  ///< Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
        constexpr uint32_t SWSYNC = (1U << 7);  ///< Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
        constexpr uint32_t TRIM = (7 << 8);  ///< HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t RELOAD = (16 << 0);  ///< Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
        constexpr uint32_t FELIM = (8 << 16);  ///< Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
        constexpr uint32_t SYNCDIV = (3 << 24);  ///< SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
        constexpr uint32_t SYNCSRC = (2 << 28);  ///< SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
        constexpr uint32_t SYNCPOL = (1U << 31);  ///< SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t SYNCOKF = (1U << 0);  ///< SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
        constexpr uint32_t SYNCWARNF = (1U << 1);  ///< SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
        constexpr uint32_t ERRF = (1U << 2);  ///< Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
        constexpr uint32_t ESYNCF = (1U << 3);  ///< Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
        constexpr uint32_t SYNCERR = (1U << 8);  ///< SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
        constexpr uint32_t SYNCMISS = (1U << 9);  ///< SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
        constexpr uint32_t TRIMOVF = (1U << 10);  ///< Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
        constexpr uint32_t FEDIR = (1U << 15);  ///< Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
        constexpr uint32_t FECAP = (16 << 16);  ///< Frequency error capture FECAP is the frequency error counter value latched in the time ofthe last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t SYNCOKC = (1U << 0);  ///< SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
        constexpr uint32_t SYNCWARNC = (1U << 1);  ///< SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
        constexpr uint32_t ERRC = (1U << 2);  ///< Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
        constexpr uint32_t ESYNCC = (1U << 3);  ///< Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
    }

}


} // namespace alloy::generated::stm32g491xx

#endif // ALLOY_GENERATED_STM32G491XX_PERIPHERALS_HPP