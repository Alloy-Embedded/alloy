/// Auto-generated code for STM32H753x
/// Generated by Alloy Code Generator
/// Source: st_stm32h753.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:23
#ifndef ALLOY_GENERATED_STM32H753X_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32H753X_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32h753x {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_crs = true;
    constexpr uint32_t num_crs_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 8;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_cec = true;
    constexpr uint32_t num_cec_instances = 1;
    constexpr bool has_hsem = true;
    constexpr uint32_t num_hsem_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 4;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 11;
    constexpr bool has_jpeg = true;
    constexpr uint32_t num_jpeg_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 8;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sai4 = true;
    constexpr uint32_t num_sai4_instances = 1;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai2 = true;
    constexpr uint32_t num_sai2_instances = 1;
    constexpr bool has_sai3 = true;
    constexpr uint32_t num_sai3_instances = 1;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 4;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 3;
    constexpr bool has_ltdc = true;
    constexpr uint32_t num_ltdc_instances = 1;
    constexpr bool has_spdifrx = true;
    constexpr uint32_t num_spdifrx_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 5;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 26;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 9;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_axi = true;
    constexpr uint32_t num_axi_instances = 1;
    constexpr bool has_hash = true;
    constexpr uint32_t num_hash_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_dcmi = true;
    constexpr uint32_t num_dcmi_instances = 1;
    constexpr bool has_otg1 = true;
    constexpr uint32_t num_otg1_instances = 3;
    constexpr bool has_otg2 = true;
    constexpr uint32_t num_otg2_instances = 3;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 2;
    constexpr bool has_dfsdm = true;
    constexpr uint32_t num_dfsdm_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 3;
    constexpr bool has_mdios = true;
    constexpr uint32_t num_mdios_instances = 1;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_swpmi = true;
    constexpr uint32_t num_swpmi_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 2;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_stk = true;
    constexpr uint32_t num_stk_instances = 1;
    constexpr bool has_fpu = true;
    constexpr uint32_t num_fpu_instances = 2;
    constexpr bool has_scb = true;
    constexpr uint32_t num_scb_instances = 2;
    constexpr bool has_pf = true;
    constexpr uint32_t num_pf_instances = 1;
    constexpr bool has_ac = true;
    constexpr uint32_t num_ac_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cec_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hsem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 11;
    };
    template<>
    struct peripheral_count<struct jpeg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct ltdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spdifrx_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 26;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otg1_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct otg2_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dfsdm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct mdios_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct swpmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct stk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpu_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct scb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ac_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 11;
    constexpr uint32_t max_gpio_pins = 176;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_usart6 = true;
    constexpr bool has_uart7 = true;
    constexpr bool has_uart8 = true;
}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP1_BASE = 0x58003800;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Comparator status register
        volatile uint32_t ICFR;  ///< Offset: 0x04 - Comparator interrupt clear flag register
        volatile uint32_t OR;  ///< Offset: 0x08 - Comparator option register
        volatile uint32_t CFGR1;  ///< Offset: 0x0C - Comparator configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - Comparator configuration register 2
    };

    /// Peripheral instances
    inline Registers* COMP1 = reinterpret_cast<Registers*>(COMP1_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t C1VAL = (1U << 0);  ///< COMP channel 1 output status bit
        constexpr uint32_t C2VAL = (1U << 1);  ///< COMP channel 2 output status bit
        constexpr uint32_t C1IF = (1U << 16);  ///< COMP channel 1 Interrupt Flag
        constexpr uint32_t C2IF = (1U << 17);  ///< COMP channel 2 Interrupt Flag
    }

    /// ICFR Register bits
    namespace icfr_bits {
        constexpr uint32_t CC1IF = (1U << 16);  ///< Clear COMP channel 1 Interrupt Flag
        constexpr uint32_t CC2IF = (1U << 17);  ///< Clear COMP channel 2 Interrupt Flag
    }

    /// OR Register bits
    namespace or_bits {
        constexpr uint32_t AFOP = (11 << 0);  ///< Selection of source for alternate function of output ports
        constexpr uint32_t OR = (21 << 11);  ///< Option Register
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< COMP channel 1 enable bit
        constexpr uint32_t BRGEN = (1U << 1);  ///< Scaler bridge enable
        constexpr uint32_t SCALEN = (1U << 2);  ///< Voltage scaler enable bit
        constexpr uint32_t POLARITY = (1U << 3);  ///< COMP channel 1 polarity selection bit
        constexpr uint32_t ITEN = (1U << 6);  ///< COMP channel 1 interrupt enable
        constexpr uint32_t HYST = (2 << 8);  ///< COMP channel 1 hysteresis selection bits
        constexpr uint32_t PWRMODE = (2 << 12);  ///< Power Mode of the COMP channel 1
        constexpr uint32_t INMSEL = (3 << 16);  ///< COMP channel 1 inverting input selection field
        constexpr uint32_t INPSEL = (1U << 20);  ///< COMP channel 1 non-inverting input selection bit
        constexpr uint32_t BLANKING = (4 << 24);  ///< COMP channel 1 blanking source selection bits
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock bit
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< COMP channel 1 enable bit
        constexpr uint32_t BRGEN = (1U << 1);  ///< Scaler bridge enable
        constexpr uint32_t SCALEN = (1U << 2);  ///< Voltage scaler enable bit
        constexpr uint32_t POLARITY = (1U << 3);  ///< COMP channel 1 polarity selection bit
        constexpr uint32_t WINMODE = (1U << 4);  ///< Window comparator mode selection bit
        constexpr uint32_t ITEN = (1U << 6);  ///< COMP channel 1 interrupt enable
        constexpr uint32_t HYST = (2 << 8);  ///< COMP channel 1 hysteresis selection bits
        constexpr uint32_t PWRMODE = (2 << 12);  ///< Power Mode of the COMP channel 1
        constexpr uint32_t INMSEL = (3 << 16);  ///< COMP channel 1 inverting input selection field
        constexpr uint32_t INPSEL = (1U << 20);  ///< COMP channel 1 non-inverting input selection bit
        constexpr uint32_t BLANKING = (4 << 24);  ///< COMP channel 1 blanking source selection bits
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock bit
    }

}

// ============================================================================
// CRS Peripheral
// ============================================================================

namespace crs {
    /// Base addresses
    constexpr uint32_t CRS_BASE = 0x40008400;

    /// CRS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - CRS control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - This register can be written only when the frequency...
        volatile uint32_t ISR;  ///< Offset: 0x08 - CRS interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x0C - CRS interrupt flag clear register
    };

    /// Peripheral instances
    inline Registers* CRS = reinterpret_cast<Registers*>(CRS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SYNCOKIE = (1U << 0);  ///< SYNC event OK interrupt enable
        constexpr uint32_t SYNCWARNIE = (1U << 1);  ///< SYNC warning interrupt enable
        constexpr uint32_t ERRIE = (1U << 2);  ///< Synchronization or trimming error interrupt enable
        constexpr uint32_t ESYNCIE = (1U << 3);  ///< Expected SYNC interrupt enable
        constexpr uint32_t CEN = (1U << 5);  ///< Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
        constexpr uint32_t AUTOTRIMEN = (1U << 6);  ///< Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
        constexpr uint32_t SWSYNC = (1U << 7);  ///< Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
        constexpr uint32_t TRIM = (6 << 8);  ///< HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t RELOAD = (16 << 0);  ///< Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
        constexpr uint32_t FELIM = (8 << 16);  ///< Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
        constexpr uint32_t SYNCDIV = (3 << 24);  ///< SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
        constexpr uint32_t SYNCSRC = (2 << 28);  ///< SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
        constexpr uint32_t SYNCPOL = (1U << 31);  ///< SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t SYNCOKF = (1U << 0);  ///< SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
        constexpr uint32_t SYNCWARNF = (1U << 1);  ///< SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
        constexpr uint32_t ERRF = (1U << 2);  ///< Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
        constexpr uint32_t ESYNCF = (1U << 3);  ///< Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
        constexpr uint32_t SYNCERR = (1U << 8);  ///< SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
        constexpr uint32_t SYNCMISS = (1U << 9);  ///< SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
        constexpr uint32_t TRIMOVF = (1U << 10);  ///< Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
        constexpr uint32_t FEDIR = (1U << 15);  ///< Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
        constexpr uint32_t FECAP = (16 << 16);  ///< Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t SYNCOKC = (1U << 0);  ///< SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
        constexpr uint32_t SYNCWARNC = (1U << 1);  ///< SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
        constexpr uint32_t ERRC = (1U << 2);  ///< Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
        constexpr uint32_t ESYNCC = (1U << 3);  ///< Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t SHSR2;  ///< Offset: 0x44 - DAC Sample and Hold sample time register 2
        volatile uint32_t SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL1 = (3 << 2);  ///< DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL2 = (3 << 18);  ///< DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    }

    /// SWTRGR Register bits
    namespace swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
    }

    /// DHR12R1 Register bits
    namespace dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    }

    /// DHR12L1 Register bits
    namespace dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    }

    /// DHR8R1 Register bits
    namespace dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
    }

    /// DHR12R2 Register bits
    namespace dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DHR12L2 Register bits
    namespace dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
    }

    /// DHR8R2 Register bits
    namespace dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DHR12RD Register bits
    namespace dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DHR12LD Register bits
    namespace dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DHR8RD Register bits
    namespace dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DOR1 Register bits
    namespace dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
    }

    /// DOR2 Register bits
    namespace dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
    }

    /// SHSR1 Register bits
    namespace shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
    }

    /// SHSR2 Register bits
    namespace shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
    }

    /// SHHR Register bits
    namespace shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
    }

    /// SHRR Register bits
    namespace shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t BDMA_BASE = 0x58025400;
    constexpr uint32_t DMA2D_BASE = 0x52001000;
    constexpr uint32_t DMAMUX2_BASE = 0x58025800;
    constexpr uint32_t MDMA_BASE = 0x52000000;
    constexpr uint32_t DMAMUX1_BASE = 0x40020800;
    constexpr uint32_t Ethernet_DMA_BASE = 0x40029000;
    constexpr uint32_t DMA1_BASE = 0x40020000;
    constexpr uint32_t DMA2_BASE = 0x40020400;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - DMA interrupt status register
        volatile uint32_t IFCR;  ///< Offset: 0x04 - DMA interrupt flag clear register
        volatile uint32_t CCR1;  ///< Offset: 0x08 - DMA channel x configuration register
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - DMA channel x number of data register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - This register must not be written when the channel is enabled.
        volatile uint32_t CCR2;  ///< Offset: 0x1C - DMA channel x configuration register
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - DMA channel x number of data register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - This register must not be written when the channel is enabled.
        volatile uint32_t CCR3;  ///< Offset: 0x30 - DMA channel x configuration register
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - DMA channel x number of data register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - This register must not be written when the channel is enabled.
        volatile uint32_t CCR4;  ///< Offset: 0x44 - DMA channel x configuration register
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - DMA channel x number of data register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - This register must not be written when the channel is enabled.
        volatile uint32_t CCR5;  ///< Offset: 0x58 - DMA channel x configuration register
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - DMA channel x number of data register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - This register must not be written when the channel is enabled.
        volatile uint32_t CCR6;  ///< Offset: 0x6C - DMA channel x configuration register
        volatile uint32_t CNDTR6;  ///< Offset: 0x70 - DMA channel x number of data register
        volatile uint32_t CPAR6;  ///< Offset: 0x74 - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR6;  ///< Offset: 0x78 - This register must not be written when the channel is enabled.
        volatile uint32_t CCR7;  ///< Offset: 0x80 - DMA channel x configuration register
        volatile uint32_t CNDTR7;  ///< Offset: 0x84 - DMA channel x number of data register
        volatile uint32_t CPAR7;  ///< Offset: 0x88 - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR7;  ///< Offset: 0x8C - This register must not be written when the channel is enabled.
        volatile uint32_t CCR8;  ///< Offset: 0x94 - DMA channel x configuration register
        volatile uint32_t CNDTR8;  ///< Offset: 0x98 - DMA channel x number of data register
        volatile uint32_t CPAR8;  ///< Offset: 0x9C - This register must not be written when the channel is enabled.
        volatile uint32_t CMAR8;  ///< Offset: 0xA0 - This register must not be written when the channel is enabled.
    };

    /// Peripheral instances
    inline Registers* BDMA = reinterpret_cast<Registers*>(BDMA_BASE);
    inline Registers* DMA2D = reinterpret_cast<Registers*>(DMA2D_BASE);
    inline Registers* DMAMUX2 = reinterpret_cast<Registers*>(DMAMUX2_BASE);
    inline Registers* MDMA = reinterpret_cast<Registers*>(MDMA_BASE);
    inline Registers* DMAMUX1 = reinterpret_cast<Registers*>(DMAMUX1_BASE);
    inline Registers* Ethernet_DMA = reinterpret_cast<Registers*>(Ethernet_DMA_BASE);
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);
    inline Registers* DMA2 = reinterpret_cast<Registers*>(DMA2_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t GIF1 = (1U << 0);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF1 = (1U << 1);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF1 = (1U << 2);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF1 = (1U << 3);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF2 = (1U << 4);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF2 = (1U << 5);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF2 = (1U << 6);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF2 = (1U << 7);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF3 = (1U << 8);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF3 = (1U << 9);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF3 = (1U << 10);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF3 = (1U << 11);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF4 = (1U << 12);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF4 = (1U << 13);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF4 = (1U << 14);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF4 = (1U << 15);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF5 = (1U << 16);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF5 = (1U << 17);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF5 = (1U << 18);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF5 = (1U << 19);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF6 = (1U << 20);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF6 = (1U << 21);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF6 = (1U << 22);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF6 = (1U << 23);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF7 = (1U << 24);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF7 = (1U << 25);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF7 = (1U << 26);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF7 = (1U << 27);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t GIF8 = (1U << 28);  ///< Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TCIF8 = (1U << 29);  ///< Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t HTIF8 = (1U << 30);  ///< Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
        constexpr uint32_t TEIF8 = (1U << 31);  ///< Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CGIF1 = (1U << 0);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF2 = (1U << 4);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF3 = (1U << 8);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF4 = (1U << 12);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF5 = (1U << 16);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF6 = (1U << 20);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF7 = (1U << 24);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< Channel x transfer error clear This bit is set and cleared by software.
        constexpr uint32_t CGIF8 = (1U << 28);  ///< Channel x global interrupt clear This bit is set and cleared by software.
        constexpr uint32_t CTCIF8 = (1U << 29);  ///< Channel x transfer complete clear This bit is set and cleared by software.
        constexpr uint32_t CHTIF8 = (1U << 30);  ///< Channel x half transfer clear This bit is set and cleared by software.
        constexpr uint32_t CTEIF8 = (1U << 31);  ///< Channel x transfer error clear This bit is set and cleared by software.
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR6 Register bits
    namespace ccr6_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR6 Register bits
    namespace cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR6 Register bits
    namespace cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR6 Register bits
    namespace cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR7 Register bits
    namespace ccr7_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR7 Register bits
    namespace cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR7 Register bits
    namespace cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR7 Register bits
    namespace cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CCR8 Register bits
    namespace ccr8_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction This bit is set and cleared by software.
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode This bit is set and cleared by software.
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode This bit is set and cleared by software.
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode This bit is set and cleared by software.
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size These bits are set and cleared by software.
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size These bits are set and cleared by software.
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level These bits are set and cleared by software.
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode This bit is set and cleared by software.
    }

    /// CNDTR8 Register bits
    namespace cndtr8_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    }

    /// CPAR8 Register bits
    namespace cpar8_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    }

    /// CMAR8 Register bits
    namespace cmar8_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x52004000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x00 - This register contains the control information of each...
        volatile uint32_t BTR1;  ///< Offset: 0x04 - This register contains the control information of each...
        volatile uint32_t BCR2;  ///< Offset: 0x08 - This register contains the control information of each...
        volatile uint32_t BTR2;  ///< Offset: 0x0C - This register contains the control information of each...
        volatile uint32_t BCR3;  ///< Offset: 0x10 - This register contains the control information of each...
        volatile uint32_t BTR3;  ///< Offset: 0x14 - This register contains the control information of each...
        volatile uint32_t BCR4;  ///< Offset: 0x18 - This register contains the control information of each...
        volatile uint32_t BTR4;  ///< Offset: 0x1C - This register contains the control information of each...
        volatile uint32_t PCR;  ///< Offset: 0x80 - NAND Flash control registers
        volatile uint32_t SR;  ///< Offset: 0x84 - This register contains information about the FIFO status...
        volatile uint32_t PMEM;  ///< Offset: 0x88 - The FMC_PMEM read/write register contains the timing...
        volatile uint32_t PATT;  ///< Offset: 0x8C - The FMC_PATT read/write register contains the timing...
        volatile uint32_t ECCR;  ///< Offset: 0x94 - This register contain the current error correction code...
        volatile uint32_t BWTR1;  ///< Offset: 0x104 - This register contains the control information of each...
        volatile uint32_t BWTR2;  ///< Offset: 0x10C - This register contains the control information of each...
        volatile uint32_t BWTR3;  ///< Offset: 0x114 - This register contains the control information of each...
        volatile uint32_t BWTR4;  ///< Offset: 0x11C - This register contains the control information of each...
        volatile uint32_t SDCR1;  ///< Offset: 0x140 - This register contains the control parameters for each...
        volatile uint32_t SDCR2;  ///< Offset: 0x144 - This register contains the control parameters for each...
        volatile uint32_t SDTR1;  ///< Offset: 0x148 - This register contains the timing parameters of each SDRAM bank
        volatile uint32_t SDTR2;  ///< Offset: 0x14C - This register contains the timing parameters of each SDRAM bank
        volatile uint32_t SDCMR;  ///< Offset: 0x150 - This register contains the command issued when the SDRAM...
        volatile uint32_t SDRTR;  ///< Offset: 0x154 - This register sets the refresh rate in number of SDCLK...
        volatile uint32_t SDSR;  ///< Offset: 0x158 - SDRAM Status register
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t BMAP = (2 << 24);  ///< FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    }

    /// BTR1 Register bits
    namespace btr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t BMAP = (2 << 24);  ///< FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    }

    /// BTR2 Register bits
    namespace btr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// BCR3 Register bits
    namespace bcr3_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t BMAP = (2 << 24);  ///< FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    }

    /// BTR3 Register bits
    namespace btr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// BCR4 Register bits
    namespace bcr4_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t BMAP = (2 << 24);  ///< FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    }

    /// BTR4 Register bits
    namespace btr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PWAITEN = (1U << 1);  ///< Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:
        constexpr uint32_t PBKEN = (1U << 2);  ///< NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
        constexpr uint32_t PWID = (2 << 4);  ///< Data bus width. These bits define the external memory device width.
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECC computation logic enable bit
        constexpr uint32_t TCLR = (4 << 9);  ///< CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
        constexpr uint32_t TAR = (4 << 13);  ///< ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECC page size. These bits define the page size for the extended ECC:
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t IRS = (1U << 0);  ///< Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t ILS = (1U << 1);  ///< Interrupt high-level status The flag is set by hardware and reset by software.
        constexpr uint32_t IFS = (1U << 2);  ///< Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t IREN = (1U << 3);  ///< Interrupt rising edge detection enable bit
        constexpr uint32_t ILEN = (1U << 4);  ///< Interrupt high-level detection enable bit
        constexpr uint32_t IFEN = (1U << 5);  ///< Interrupt falling edge detection enable bit
        constexpr uint32_t FEMPT = (1U << 6);  ///< FIFO empty. Read-only bit that provides the status of the FIFO
    }

    /// PMEM Register bits
    namespace pmem_bits {
        constexpr uint32_t MEMSET = (8 << 0);  ///< Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMWAIT = (8 << 8);  ///< Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t MEMHOLD = (8 << 16);  ///< Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMHIZ = (8 << 24);  ///< Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
    }

    /// PATT Register bits
    namespace patt_bits {
        constexpr uint32_t ATTSET = (8 << 0);  ///< Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTWAIT = (8 << 8);  ///< Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t ATTHOLD = (8 << 16);  ///< Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTHIZ = (8 << 24);  ///< Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ECC = (32 << 0);  ///< ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
    }

    /// BWTR1 Register bits
    namespace bwtr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// BWTR2 Register bits
    namespace bwtr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// BWTR3 Register bits
    namespace bwtr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// BWTR4 Register bits
    namespace bwtr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// SDCR1 Register bits
    namespace sdcr1_bits {
        constexpr uint32_t NC = (2 << 0);  ///< Number of column address bits These bits define the number of bits of a column address.
        constexpr uint32_t NR = (2 << 2);  ///< Number of row address bits These bits define the number of bits of a row address.
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width. These bits define the memory device width.
        constexpr uint32_t NB = (1U << 6);  ///< Number of internal banks This bit sets the number of internal banks.
        constexpr uint32_t CAS = (2 << 7);  ///< CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
        constexpr uint32_t WP = (1U << 9);  ///< Write protection This bit enables write mode access to the SDRAM bank.
        constexpr uint32_t SDCLK = (2 << 10);  ///< SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
        constexpr uint32_t RBURST = (1U << 12);  ///< Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
        constexpr uint32_t RPIPE = (2 << 13);  ///< Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
    }

    /// SDCR2 Register bits
    namespace sdcr2_bits {
        constexpr uint32_t NC = (2 << 0);  ///< Number of column address bits These bits define the number of bits of a column address.
        constexpr uint32_t NR = (2 << 2);  ///< Number of row address bits These bits define the number of bits of a row address.
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width. These bits define the memory device width.
        constexpr uint32_t NB = (1U << 6);  ///< Number of internal banks This bit sets the number of internal banks.
        constexpr uint32_t CAS = (2 << 7);  ///< CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
        constexpr uint32_t WP = (1U << 9);  ///< Write protection This bit enables write mode access to the SDRAM bank.
        constexpr uint32_t SDCLK = (2 << 10);  ///< SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
        constexpr uint32_t RBURST = (1U << 12);  ///< Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
        constexpr uint32_t RPIPE = (2 << 13);  ///< Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
    }

    /// SDTR1 Register bits
    namespace sdtr1_bits {
        constexpr uint32_t TMRD = (4 << 0);  ///< Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
        constexpr uint32_t TXSR = (4 << 4);  ///< Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
        constexpr uint32_t TRAS = (4 << 8);  ///< Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
        constexpr uint32_t TRC = (4 << 12);  ///< Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
        constexpr uint32_t TWR = (4 << 16);  ///< Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
        constexpr uint32_t TRP = (4 << 20);  ///< Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
        constexpr uint32_t TRCD = (4 << 24);  ///< Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
    }

    /// SDTR2 Register bits
    namespace sdtr2_bits {
        constexpr uint32_t TMRD = (4 << 0);  ///< Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
        constexpr uint32_t TXSR = (4 << 4);  ///< Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
        constexpr uint32_t TRAS = (4 << 8);  ///< Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
        constexpr uint32_t TRC = (4 << 12);  ///< Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
        constexpr uint32_t TWR = (4 << 16);  ///< Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
        constexpr uint32_t TRP = (4 << 20);  ///< Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
        constexpr uint32_t TRCD = (4 << 24);  ///< Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
    }

    /// SDCMR Register bits
    namespace sdcmr_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< Command mode These bits define the command issued to the SDRAM device. Note: When a command is issued, at least one Command Target Bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: If two SDRAM banks are used, the Auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: If only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0.
        constexpr uint32_t CTB2 = (1U << 3);  ///< Command Target Bank 2 This bit indicates whether the command will be issued to SDRAM Bank 2 or not.
        constexpr uint32_t CTB1 = (1U << 4);  ///< Command Target Bank 1 This bit indicates whether the command will be issued to SDRAM Bank 1 or not.
        constexpr uint32_t NRFS = (4 << 5);  ///< Number of Auto-refresh These bits define the number of consecutive Auto-refresh commands issued when MODE = 011. ....
        constexpr uint32_t MRD = (14 << 9);  ///< Mode Register definition This 14-bit field defines the SDRAM Mode Register content. The Mode Register is programmed using the Load Mode Register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM.
    }

    /// SDRTR Register bits
    namespace sdrtr_bits {
        constexpr uint32_t CRE = (1U << 0);  ///< Clear Refresh error flag This bit is used to clear the Refresh Error Flag (RE) in the Status Register.
        constexpr uint32_t COUNT = (13 << 1);  ///< Refresh Timer Count This 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / Number of rows) - 20
        constexpr uint32_t REIE = (1U << 14);  ///< RES Interrupt Enable
    }

    /// SDSR Register bits
    namespace sdsr_bits {
        constexpr uint32_t RE = (1U << 0);  ///< Refresh error flag An interrupt is generated if REIE = 1 and RE = 1
        constexpr uint32_t MODES1 = (2 << 1);  ///< Status Mode for Bank 1 These bits define the Status Mode of SDRAM Bank 1.
        constexpr uint32_t MODES2 = (2 << 3);  ///< Status Mode for Bank 2 These bits define the Status Mode of SDRAM Bank 2.
    }

}

// ============================================================================
// CEC Peripheral
// ============================================================================

namespace cec {
    /// Base addresses
    constexpr uint32_t CEC_BASE = 0x40006C00;

    /// CEC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - CEC control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - This register is used to configure the HDMI-CEC...
        volatile uint32_t TXDR;  ///< Offset: 0x08 - CEC Tx data register
        volatile uint32_t RXDR;  ///< Offset: 0x0C - CEC Rx Data Register
        volatile uint32_t ISR;  ///< Offset: 0x10 - CEC Interrupt and Status Register
        volatile uint32_t IER;  ///< Offset: 0x14 - CEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* CEC = reinterpret_cast<Registers*>(CEC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CECEN = (1U << 0);  ///< CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
        constexpr uint32_t TXSOM = (1U << 1);  ///< Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
        constexpr uint32_t TXEOM = (1U << 2);  ///< Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SFT = (3 << 0);  ///< Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods
        constexpr uint32_t RXTOL = (1U << 3);  ///< Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
        constexpr uint32_t BRESTP = (1U << 4);  ///< Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
        constexpr uint32_t BREGEN = (1U << 5);  ///< Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
        constexpr uint32_t LBPEGEN = (1U << 6);  ///< Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
        constexpr uint32_t BRDNOGEN = (1U << 7);  ///< Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
        constexpr uint32_t SFTOPT = (1U << 8);  ///< SFT Option Bit The SFTOPT bit is set and cleared by software.
        constexpr uint32_t OAR = (15 << 16);  ///< Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
        constexpr uint32_t LSTN = (1U << 31);  ///< Listen mode LSTN bit is set and cleared by software.
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXD = (8 << 0);  ///< Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXD = (8 << 0);  ///< Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RXBR = (1U << 0);  ///< Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
        constexpr uint32_t RXEND = (1U << 1);  ///< End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
        constexpr uint32_t RXOVR = (1U << 2);  ///< Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
        constexpr uint32_t BRE = (1U << 3);  ///< Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
        constexpr uint32_t SBPE = (1U << 4);  ///< Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
        constexpr uint32_t LBPE = (1U << 5);  ///< Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
        constexpr uint32_t RXACKE = (1U << 6);  ///< Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
        constexpr uint32_t ARBLST = (1U << 7);  ///< Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
        constexpr uint32_t TXBR = (1U << 8);  ///< Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
        constexpr uint32_t TXEND = (1U << 9);  ///< End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
        constexpr uint32_t TXUDR = (1U << 10);  ///< Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
        constexpr uint32_t TXERR = (1U << 11);  ///< Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
        constexpr uint32_t TXACKE = (1U << 12);  ///< Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t RXBRIE = (1U << 0);  ///< Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.
        constexpr uint32_t RXENDIE = (1U << 1);  ///< End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
        constexpr uint32_t RXOVRIE = (1U << 2);  ///< Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
        constexpr uint32_t BREIE = (1U << 3);  ///< Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
        constexpr uint32_t SBPEIE = (1U << 4);  ///< Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
        constexpr uint32_t LBPEIE = (1U << 5);  ///< Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
        constexpr uint32_t RXACKIE = (1U << 6);  ///< Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
        constexpr uint32_t ARBLSTIE = (1U << 7);  ///< Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
        constexpr uint32_t TXBRIE = (1U << 8);  ///< Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
        constexpr uint32_t TXENDIE = (1U << 9);  ///< Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
        constexpr uint32_t TXUDRIE = (1U << 10);  ///< Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
        constexpr uint32_t TXERRIE = (1U << 11);  ///< Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
        constexpr uint32_t TXACKIE = (1U << 12);  ///< Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
    }

}

// ============================================================================
// HSEM Peripheral
// ============================================================================

namespace hsem {
    /// Base addresses
    constexpr uint32_t HSEM_BASE = 0x58026400;

    /// HSEM Register structure
    struct Registers {
        volatile uint32_t HSEM_R0;  ///< Offset: 0x00 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R1;  ///< Offset: 0x04 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R2;  ///< Offset: 0x08 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R3;  ///< Offset: 0x0C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R4;  ///< Offset: 0x10 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R5;  ///< Offset: 0x14 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R6;  ///< Offset: 0x18 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R7;  ///< Offset: 0x1C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R8;  ///< Offset: 0x20 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R9;  ///< Offset: 0x24 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R10;  ///< Offset: 0x28 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R11;  ///< Offset: 0x2C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R12;  ///< Offset: 0x30 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R13;  ///< Offset: 0x34 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R14;  ///< Offset: 0x38 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R15;  ///< Offset: 0x3C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R16;  ///< Offset: 0x40 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R17;  ///< Offset: 0x44 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R18;  ///< Offset: 0x48 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R19;  ///< Offset: 0x4C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R20;  ///< Offset: 0x50 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R21;  ///< Offset: 0x54 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R22;  ///< Offset: 0x58 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R23;  ///< Offset: 0x5C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R24;  ///< Offset: 0x60 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R25;  ///< Offset: 0x64 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R26;  ///< Offset: 0x68 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R27;  ///< Offset: 0x6C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R28;  ///< Offset: 0x70 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R29;  ///< Offset: 0x74 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R30;  ///< Offset: 0x78 - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_R31;  ///< Offset: 0x7C - HSEM register HSEM_R0 HSEM_R31
        volatile uint32_t HSEM_RLR0;  ///< Offset: 0x80 - HSEM Read lock register
        volatile uint32_t HSEM_RLR1;  ///< Offset: 0x84 - HSEM Read lock register
        volatile uint32_t HSEM_RLR2;  ///< Offset: 0x88 - HSEM Read lock register
        volatile uint32_t HSEM_RLR3;  ///< Offset: 0x8C - HSEM Read lock register
        volatile uint32_t HSEM_RLR4;  ///< Offset: 0x90 - HSEM Read lock register
        volatile uint32_t HSEM_RLR5;  ///< Offset: 0x94 - HSEM Read lock register
        volatile uint32_t HSEM_RLR6;  ///< Offset: 0x98 - HSEM Read lock register
        volatile uint32_t HSEM_RLR7;  ///< Offset: 0x9C - HSEM Read lock register
        volatile uint32_t HSEM_RLR8;  ///< Offset: 0xA0 - HSEM Read lock register
        volatile uint32_t HSEM_RLR9;  ///< Offset: 0xA4 - HSEM Read lock register
        volatile uint32_t HSEM_RLR10;  ///< Offset: 0xA8 - HSEM Read lock register
        volatile uint32_t HSEM_RLR11;  ///< Offset: 0xAC - HSEM Read lock register
        volatile uint32_t HSEM_RLR12;  ///< Offset: 0xB0 - HSEM Read lock register
        volatile uint32_t HSEM_RLR13;  ///< Offset: 0xB4 - HSEM Read lock register
        volatile uint32_t HSEM_RLR14;  ///< Offset: 0xB8 - HSEM Read lock register
        volatile uint32_t HSEM_RLR15;  ///< Offset: 0xBC - HSEM Read lock register
        volatile uint32_t HSEM_RLR16;  ///< Offset: 0xC0 - HSEM Read lock register
        volatile uint32_t HSEM_RLR17;  ///< Offset: 0xC4 - HSEM Read lock register
        volatile uint32_t HSEM_RLR18;  ///< Offset: 0xC8 - HSEM Read lock register
        volatile uint32_t HSEM_RLR19;  ///< Offset: 0xCC - HSEM Read lock register
        volatile uint32_t HSEM_RLR20;  ///< Offset: 0xD0 - HSEM Read lock register
        volatile uint32_t HSEM_RLR21;  ///< Offset: 0xD4 - HSEM Read lock register
        volatile uint32_t HSEM_RLR22;  ///< Offset: 0xD8 - HSEM Read lock register
        volatile uint32_t HSEM_RLR23;  ///< Offset: 0xDC - HSEM Read lock register
        volatile uint32_t HSEM_RLR24;  ///< Offset: 0xE0 - HSEM Read lock register
        volatile uint32_t HSEM_RLR25;  ///< Offset: 0xE4 - HSEM Read lock register
        volatile uint32_t HSEM_RLR26;  ///< Offset: 0xE8 - HSEM Read lock register
        volatile uint32_t HSEM_RLR27;  ///< Offset: 0xEC - HSEM Read lock register
        volatile uint32_t HSEM_RLR28;  ///< Offset: 0xF0 - HSEM Read lock register
        volatile uint32_t HSEM_RLR29;  ///< Offset: 0xF4 - HSEM Read lock register
        volatile uint32_t HSEM_RLR30;  ///< Offset: 0xF8 - HSEM Read lock register
        volatile uint32_t HSEM_RLR31;  ///< Offset: 0xFC - HSEM Read lock register
        volatile uint32_t HSEM_IER;  ///< Offset: 0x100 - HSEM Interrupt enable register
        volatile uint32_t HSEM_ICR;  ///< Offset: 0x104 - HSEM Interrupt clear register
        volatile uint32_t HSEM_ISR;  ///< Offset: 0x108 - HSEM Interrupt status register
        volatile uint32_t HSEM_MISR;  ///< Offset: 0x10C - HSEM Masked interrupt status register
        volatile uint32_t HSEM_CR;  ///< Offset: 0x140 - HSEM Clear register
        volatile uint32_t HSEM_KEYR;  ///< Offset: 0x144 - HSEM Interrupt clear register
    };

    /// Peripheral instances
    inline Registers* HSEM = reinterpret_cast<Registers*>(HSEM_BASE);

    // Bit definitions
    /// HSEM_R0 Register bits
    namespace hsem_r0_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R1 Register bits
    namespace hsem_r1_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R2 Register bits
    namespace hsem_r2_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R3 Register bits
    namespace hsem_r3_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R4 Register bits
    namespace hsem_r4_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R5 Register bits
    namespace hsem_r5_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R6 Register bits
    namespace hsem_r6_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R7 Register bits
    namespace hsem_r7_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R8 Register bits
    namespace hsem_r8_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R9 Register bits
    namespace hsem_r9_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R10 Register bits
    namespace hsem_r10_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R11 Register bits
    namespace hsem_r11_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R12 Register bits
    namespace hsem_r12_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R13 Register bits
    namespace hsem_r13_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R14 Register bits
    namespace hsem_r14_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R15 Register bits
    namespace hsem_r15_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R16 Register bits
    namespace hsem_r16_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R17 Register bits
    namespace hsem_r17_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R18 Register bits
    namespace hsem_r18_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R19 Register bits
    namespace hsem_r19_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R20 Register bits
    namespace hsem_r20_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R21 Register bits
    namespace hsem_r21_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R22 Register bits
    namespace hsem_r22_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R23 Register bits
    namespace hsem_r23_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R24 Register bits
    namespace hsem_r24_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R25 Register bits
    namespace hsem_r25_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R26 Register bits
    namespace hsem_r26_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R27 Register bits
    namespace hsem_r27_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R28 Register bits
    namespace hsem_r28_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R29 Register bits
    namespace hsem_r29_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R30 Register bits
    namespace hsem_r30_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_R31 Register bits
    namespace hsem_r31_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR0 Register bits
    namespace hsem_rlr0_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR1 Register bits
    namespace hsem_rlr1_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR2 Register bits
    namespace hsem_rlr2_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR3 Register bits
    namespace hsem_rlr3_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR4 Register bits
    namespace hsem_rlr4_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR5 Register bits
    namespace hsem_rlr5_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR6 Register bits
    namespace hsem_rlr6_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR7 Register bits
    namespace hsem_rlr7_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR8 Register bits
    namespace hsem_rlr8_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR9 Register bits
    namespace hsem_rlr9_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR10 Register bits
    namespace hsem_rlr10_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR11 Register bits
    namespace hsem_rlr11_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR12 Register bits
    namespace hsem_rlr12_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR13 Register bits
    namespace hsem_rlr13_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR14 Register bits
    namespace hsem_rlr14_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR15 Register bits
    namespace hsem_rlr15_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR16 Register bits
    namespace hsem_rlr16_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR17 Register bits
    namespace hsem_rlr17_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR18 Register bits
    namespace hsem_rlr18_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR19 Register bits
    namespace hsem_rlr19_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR20 Register bits
    namespace hsem_rlr20_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR21 Register bits
    namespace hsem_rlr21_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR22 Register bits
    namespace hsem_rlr22_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR23 Register bits
    namespace hsem_rlr23_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR24 Register bits
    namespace hsem_rlr24_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR25 Register bits
    namespace hsem_rlr25_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR26 Register bits
    namespace hsem_rlr26_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR27 Register bits
    namespace hsem_rlr27_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR28 Register bits
    namespace hsem_rlr28_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR29 Register bits
    namespace hsem_rlr29_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR30 Register bits
    namespace hsem_rlr30_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_RLR31 Register bits
    namespace hsem_rlr31_bits {
        constexpr uint32_t PROCID = (8 << 0);  ///< Semaphore ProcessID
        constexpr uint32_t MASTERID = (8 << 8);  ///< Semaphore MasterID
        constexpr uint32_t LOCK = (1U << 31);  ///< Lock indication
    }

    /// HSEM_IER Register bits
    namespace hsem_ier_bits {
        constexpr uint32_t ISEM0 = (1U << 0);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM1 = (1U << 1);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM2 = (1U << 2);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM3 = (1U << 3);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM4 = (1U << 4);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM5 = (1U << 5);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM6 = (1U << 6);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM7 = (1U << 7);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM8 = (1U << 8);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM9 = (1U << 9);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM10 = (1U << 10);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM11 = (1U << 11);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM12 = (1U << 12);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM13 = (1U << 13);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM14 = (1U << 14);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM15 = (1U << 15);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM16 = (1U << 16);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM17 = (1U << 17);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM18 = (1U << 18);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM19 = (1U << 19);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM20 = (1U << 20);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM21 = (1U << 21);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM22 = (1U << 22);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM23 = (1U << 23);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM24 = (1U << 24);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM25 = (1U << 25);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM26 = (1U << 26);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM27 = (1U << 27);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM28 = (1U << 28);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM29 = (1U << 29);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM30 = (1U << 30);  ///< Interrupt semaphore n enable bit
        constexpr uint32_t ISEM31 = (1U << 31);  ///< Interrupt(N) semaphore n enable bit.
    }

    /// HSEM_ICR Register bits
    namespace hsem_icr_bits {
        constexpr uint32_t ISEM0 = (1U << 0);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM1 = (1U << 1);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM2 = (1U << 2);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM3 = (1U << 3);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM4 = (1U << 4);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM5 = (1U << 5);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM6 = (1U << 6);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM7 = (1U << 7);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM8 = (1U << 8);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM9 = (1U << 9);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM10 = (1U << 10);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM11 = (1U << 11);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM12 = (1U << 12);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM13 = (1U << 13);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM14 = (1U << 14);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM15 = (1U << 15);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM16 = (1U << 16);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM17 = (1U << 17);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM18 = (1U << 18);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM19 = (1U << 19);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM20 = (1U << 20);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM21 = (1U << 21);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM22 = (1U << 22);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM23 = (1U << 23);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM24 = (1U << 24);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM25 = (1U << 25);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM26 = (1U << 26);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM27 = (1U << 27);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM28 = (1U << 28);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM29 = (1U << 29);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM30 = (1U << 30);  ///< Interrupt(N) semaphore n clear bit
        constexpr uint32_t ISEM31 = (1U << 31);  ///< Interrupt(N) semaphore n clear bit
    }

    /// HSEM_ISR Register bits
    namespace hsem_isr_bits {
        constexpr uint32_t ISEM0 = (1U << 0);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM1 = (1U << 1);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM2 = (1U << 2);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM3 = (1U << 3);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM4 = (1U << 4);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM5 = (1U << 5);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM6 = (1U << 6);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM7 = (1U << 7);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM8 = (1U << 8);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM9 = (1U << 9);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM10 = (1U << 10);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM11 = (1U << 11);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM12 = (1U << 12);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM13 = (1U << 13);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM14 = (1U << 14);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM15 = (1U << 15);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM16 = (1U << 16);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM17 = (1U << 17);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM18 = (1U << 18);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM19 = (1U << 19);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM20 = (1U << 20);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM21 = (1U << 21);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM22 = (1U << 22);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM23 = (1U << 23);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM24 = (1U << 24);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM25 = (1U << 25);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM26 = (1U << 26);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM27 = (1U << 27);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM28 = (1U << 28);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM29 = (1U << 29);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM30 = (1U << 30);  ///< Interrupt(N) semaphore n status bit before enable (mask)
        constexpr uint32_t ISEM31 = (1U << 31);  ///< Interrupt(N) semaphore n status bit before enable (mask)
    }

    /// HSEM_MISR Register bits
    namespace hsem_misr_bits {
        constexpr uint32_t ISEM0 = (1U << 0);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM1 = (1U << 1);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM2 = (1U << 2);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM3 = (1U << 3);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM4 = (1U << 4);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM5 = (1U << 5);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM6 = (1U << 6);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM7 = (1U << 7);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM8 = (1U << 8);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM9 = (1U << 9);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM10 = (1U << 10);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM11 = (1U << 11);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM12 = (1U << 12);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM13 = (1U << 13);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM14 = (1U << 14);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM15 = (1U << 15);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM16 = (1U << 16);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM17 = (1U << 17);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM18 = (1U << 18);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM19 = (1U << 19);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM20 = (1U << 20);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM21 = (1U << 21);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM22 = (1U << 22);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM23 = (1U << 23);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM24 = (1U << 24);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM25 = (1U << 25);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM26 = (1U << 26);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM27 = (1U << 27);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM28 = (1U << 28);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM29 = (1U << 29);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM30 = (1U << 30);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
        constexpr uint32_t ISEM31 = (1U << 31);  ///< masked interrupt(N) semaphore n status bit after enable (mask)
    }

    /// HSEM_CR Register bits
    namespace hsem_cr_bits {
        constexpr uint32_t MASTERID = (8 << 8);  ///< MasterID of semaphores to be cleared
        constexpr uint32_t KEY = (16 << 16);  ///< Semaphore clear Key
    }

    /// HSEM_KEYR Register bits
    namespace hsem_keyr_bits {
        constexpr uint32_t KEY = (16 << 16);  ///< Semaphore Clear Key
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C3_BASE = 0x40005C00;
    constexpr uint32_t I2C4_BASE = 0x58001C00;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Access: No wait states, except if a write access occurs...
        volatile uint32_t CR2;  ///< Offset: 0x04 - Access: No wait states, except if a write access occurs...
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Access: No wait states, except if a write access occurs...
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Access: No wait states, except if a write access occurs...
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Access: No wait states
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Access: No wait states, except if a write access occurs...
        volatile uint32_t ISR;  ///< Offset: 0x18 - Access: No wait states
        volatile uint32_t ICR;  ///< Offset: 0x1C - Access: No wait states
        volatile uint32_t PECR;  ///< Offset: 0x20 - Access: No wait states
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Access: No wait states
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Access: No wait states
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match Interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received Interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control This bit is used to enable hardware byte control in slave mode.
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t SADD0 = (1U << 0);  ///< Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD1 = (1U << 1);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD2 = (1U << 2);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD3 = (1U << 3);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD4 = (1U << 4);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD5 = (1U << 5);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD6 = (1U << 6);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD7 = (1U << 7);  ///< Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD8 = (1U << 8);  ///< Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t SADD9 = (1U << 9);  ///< Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t START = (1U << 13);  ///< Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode This bit is set and cleared by software.
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t NACKF = (1U << 4);  ///< Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data Data byte received from the I2C bus.
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x58020000;
    constexpr uint32_t GPIOB_BASE = 0x58020400;
    constexpr uint32_t GPIOC_BASE = 0x58020800;
    constexpr uint32_t GPIOD_BASE = 0x58020C00;
    constexpr uint32_t GPIOE_BASE = 0x58021000;
    constexpr uint32_t GPIOF_BASE = 0x58021400;
    constexpr uint32_t GPIOG_BASE = 0x58021800;
    constexpr uint32_t GPIOH_BASE = 0x58021C00;
    constexpr uint32_t GPIOI_BASE = 0x58022000;
    constexpr uint32_t GPIOJ_BASE = 0x58022400;
    constexpr uint32_t GPIOK_BASE = 0x58022800;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - This register is used to lock the configuration of the...
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* GPIOI = reinterpret_cast<Registers*>(GPIOI_BASE);
    inline Registers* GPIOJ = reinterpret_cast<Registers*>(GPIOJ_BASE);
    inline Registers* GPIOK = reinterpret_cast<Registers*>(GPIOK_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODE0 = (2 << 0);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE1 = (2 << 2);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE2 = (2 << 4);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE3 = (2 << 6);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE4 = (2 << 8);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE5 = (2 << 10);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE6 = (2 << 12);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE7 = (2 << 14);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE8 = (2 << 16);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE9 = (2 << 18);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE10 = (2 << 20);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE11 = (2 << 22);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE12 = (2 << 24);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE13 = (2 << 26);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE14 = (2 << 28);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE15 = (2 << 30);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEED0 = (2 << 0);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED1 = (2 << 2);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED2 = (2 << 4);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED3 = (2 << 6);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED4 = (2 << 8);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED5 = (2 << 10);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED6 = (2 << 12);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED7 = (2 << 14);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED8 = (2 << 16);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED9 = (2 << 18);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED10 = (2 << 20);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED11 = (2 << 22);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED12 = (2 << 24);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED13 = (2 << 26);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED14 = (2 << 28);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
        constexpr uint32_t OSPEED15 = (2 << 30);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPD0 = (2 << 0);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD1 = (2 << 2);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD2 = (2 << 4);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD3 = (2 << 6);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD4 = (2 << 8);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD5 = (2 << 10);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD6 = (2 << 12);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD7 = (2 << 14);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD8 = (2 << 16);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD9 = (2 << 18);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD10 = (2 << 20);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD11 = (2 << 22);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD12 = (2 << 24);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD13 = (2 << 26);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD14 = (2 << 28);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD15 = (2 << 30);  ///< [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t ID0 = (1U << 0);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID1 = (1U << 1);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID2 = (1U << 2);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID3 = (1U << 3);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID4 = (1U << 4);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID5 = (1U << 5);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID6 = (1U << 6);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID7 = (1U << 7);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID8 = (1U << 8);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID9 = (1U << 9);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID10 = (1U << 10);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID11 = (1U << 11);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID12 = (1U << 12);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID13 = (1U << 13);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID14 = (1U << 14);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID15 = (1U << 15);  ///< Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t OD0 = (1U << 0);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD1 = (1U << 1);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD2 = (1U << 2);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD3 = (1U << 3);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD4 = (1U << 4);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD5 = (1U << 5);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD6 = (1U << 6);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD7 = (1U << 7);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD8 = (1U << 8);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD9 = (1U << 9);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD10 = (1U << 10);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD11 = (1U << 11);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD12 = (1U << 12);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD13 = (1U << 13);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD14 = (1U << 14);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
        constexpr uint32_t OD15 = (1U << 15);  ///< Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCKK = (1U << 16);  ///< Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    }

}

// ============================================================================
// JPEG Peripheral
// ============================================================================

namespace jpeg {
    /// Base addresses
    constexpr uint32_t JPEG_BASE = 0x52003000;

    /// JPEG Register structure
    struct Registers {
        volatile uint32_t CONFR0;  ///< Offset: 0x00 - JPEG codec control register
        volatile uint32_t CONFR1;  ///< Offset: 0x04 - JPEG codec configuration register 1
        volatile uint32_t CONFR2;  ///< Offset: 0x08 - JPEG codec configuration register 2
        volatile uint32_t CONFR3;  ///< Offset: 0x0C - JPEG codec configuration register 3
        volatile uint32_t CONFRN1;  ///< Offset: 0x10 - JPEG codec configuration register 4-7
        volatile uint32_t CONFRN2;  ///< Offset: 0x14 - JPEG codec configuration register 4-7
        volatile uint32_t CONFRN3;  ///< Offset: 0x18 - JPEG codec configuration register 4-7
        volatile uint32_t CONFRN4;  ///< Offset: 0x1C - JPEG codec configuration register 4-7
        volatile uint32_t CR;  ///< Offset: 0x30 - JPEG control register
        volatile uint32_t SR;  ///< Offset: 0x34 - JPEG status register
        volatile uint32_t CFR;  ///< Offset: 0x38 - JPEG clear flag register
        volatile uint32_t DIR;  ///< Offset: 0x40 - JPEG data input register
        volatile uint32_t DOR;  ///< Offset: 0x44 - JPEG data output register
    };

    /// Peripheral instances
    inline Registers* JPEG = reinterpret_cast<Registers*>(JPEG_BASE);

    // Bit definitions
    /// CONFR0 Register bits
    namespace confr0_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start This bit start or stop the encoding or decoding process. Read this register always return 0.
    }

    /// CONFR1 Register bits
    namespace confr1_bits {
        constexpr uint32_t NF = (2 << 0);  ///< Number of color components This field defines the number of color components minus 1.
        constexpr uint32_t DE = (1U << 3);  ///< Decoding Enable This bit selects the coding or decoding process
        constexpr uint32_t COLORSPACE = (2 << 4);  ///< Color Space This filed defines the number of quantization tables minus 1 to insert in the output stream.
        constexpr uint32_t NS = (2 << 6);  ///< Number of components for Scan This field defines the number of components minus 1 for scan header marker segment.
        constexpr uint32_t HDR = (1U << 8);  ///< Header Processing This bit enable the header processing (generation/parsing).
        constexpr uint32_t YSIZE = (16 << 16);  ///< Y Size This field defines the number of lines in source image.
    }

    /// CONFR2 Register bits
    namespace confr2_bits {
        constexpr uint32_t NMCU = (26 << 0);  ///< Number of MCU For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated.
    }

    /// CONFR3 Register bits
    namespace confr3_bits {
        constexpr uint32_t XSIZE = (16 << 16);  ///< X size This field defines the number of pixels per line.
    }

    /// CONFRN1 Register bits
    namespace confrn1_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding the DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding the AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization Table Selects quantization table associated with a color component.
        constexpr uint32_t NB = (4 << 4);  ///< Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical Sampling Factor Vertical sampling factor for component i.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal Sampling Factor Horizontal sampling factor for component i.
    }

    /// CONFRN2 Register bits
    namespace confrn2_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding the DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding the AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization Table Selects quantization table associated with a color component.
        constexpr uint32_t NB = (4 << 4);  ///< Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical Sampling Factor Vertical sampling factor for component i.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal Sampling Factor Horizontal sampling factor for component i.
    }

    /// CONFRN3 Register bits
    namespace confrn3_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding the DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding the AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization Table Selects quantization table associated with a color component.
        constexpr uint32_t NB = (4 << 4);  ///< Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical Sampling Factor Vertical sampling factor for component i.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal Sampling Factor Horizontal sampling factor for component i.
    }

    /// CONFRN4 Register bits
    namespace confrn4_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding the DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding the AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization Table Selects quantization table associated with a color component.
        constexpr uint32_t NB = (4 << 4);  ///< Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical Sampling Factor Vertical sampling factor for component i.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal Sampling Factor Horizontal sampling factor for component i.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t JCEN = (1U << 0);  ///< JPEG Core Enable Enable the JPEG codec Core.
        constexpr uint32_t IFTIE = (1U << 1);  ///< Input FIFO Threshold Interrupt Enable This bit enables the interrupt generation when input FIFO reach the threshold.
        constexpr uint32_t IFNFIE = (1U << 2);  ///< Input FIFO Not Full Interrupt Enable This bit enables the interrupt generation when input FIFO is not empty.
        constexpr uint32_t OFTIE = (1U << 3);  ///< Output FIFO Threshold Interrupt Enable This bit enables the interrupt generation when output FIFO reach the threshold.
        constexpr uint32_t OFNEIE = (1U << 4);  ///< Output FIFO Not Empty Interrupt Enable This bit enables the interrupt generation when output FIFO is not empty.
        constexpr uint32_t EOCIE = (1U << 5);  ///< End of Conversion Interrupt Enable This bit enables the interrupt generation on the end of conversion.
        constexpr uint32_t HPDIE = (1U << 6);  ///< Header Parsing Done Interrupt Enable This bit enables the interrupt generation on the Header Parsing Operation.
        constexpr uint32_t IDMAEN = (1U << 11);  ///< Input DMA Enable Enable the DMA request generation for the input FIFO.
        constexpr uint32_t ODMAEN = (1U << 12);  ///< Output DMA Enable Enable the DMA request generation for the output FIFO.
        constexpr uint32_t IFF = (1U << 13);  ///< Input FIFO Flush This bit flush the input FIFO. This bit is always read as 0.
        constexpr uint32_t OFF = (1U << 14);  ///< Output FIFO Flush This bit flush the output FIFO. This bit is always read as 0.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t IFTF = (1U << 1);  ///< Input FIFO Threshold Flag This bit is set when the input FIFO is not full and is bellow its threshold.
        constexpr uint32_t IFNFF = (1U << 2);  ///< Input FIFO Not Full Flag This bit is set when the input FIFO is not full (a data can be written).
        constexpr uint32_t OFTF = (1U << 3);  ///< Output FIFO Threshold Flag This bit is set when the output FIFO is not empty and has reach its threshold.
        constexpr uint32_t OFNEF = (1U << 4);  ///< Output FIFO Not Empty Flag This bit is set when the output FIFO is not empty (a data is available).
        constexpr uint32_t EOCF = (1U << 5);  ///< End of Conversion Flag This bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO.
        constexpr uint32_t HPDF = (1U << 6);  ///< Header Parsing Done Flag This bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated.
        constexpr uint32_t COF = (1U << 7);  ///< Codec Operation Flag This bit is set when when a JPEG codec operation is on going (encoding or decoding).
    }

    /// CFR Register bits
    namespace cfr_bits {
        constexpr uint32_t CEOCF = (1U << 5);  ///< Clear End of Conversion Flag Writing 1 clears the End of Conversion Flag of the JPEG Status Register.
        constexpr uint32_t CHPDF = (1U << 6);  ///< Clear Header Parsing Done Flag Writing 1 clears the Header Parsing Done Flag of the JPEG Status Register.
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data Input FIFO Input FIFO data register.
    }

    /// DOR Register bits
    namespace dor_bits {
        constexpr uint32_t DATAOUT = (32 << 0);  ///< Data Output FIFO Output FIFO data register.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t QUADSPI_BASE = 0x52005000;
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SPI3_BASE = 0x40003C00;
    constexpr uint32_t SPI4_BASE = 0x40013400;
    constexpr uint32_t SPI5_BASE = 0x40015000;
    constexpr uint32_t SPI6_BASE = 0x58001400;
    constexpr uint32_t DELAY_Block_QUADSPI_BASE = 0x52006000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - QUADSPI control register
        volatile uint32_t DCR;  ///< Offset: 0x04 - QUADSPI device configuration register
        volatile uint32_t SR;  ///< Offset: 0x08 - QUADSPI status register
        volatile uint32_t FCR;  ///< Offset: 0x0C - QUADSPI flag clear register
        volatile uint32_t DLR;  ///< Offset: 0x10 - QUADSPI data length register
        volatile uint32_t CCR;  ///< Offset: 0x14 - QUADSPI communication configuration register
        volatile uint32_t AR;  ///< Offset: 0x18 - QUADSPI address register
        volatile uint32_t ABR;  ///< Offset: 0x1C - QUADSPI alternate bytes registers
        volatile uint32_t DR;  ///< Offset: 0x20 - QUADSPI data register
        volatile uint32_t PSMKR;  ///< Offset: 0x24 - QUADSPI polling status mask register
        volatile uint32_t PSMAR;  ///< Offset: 0x28 - QUADSPI polling status match register
        volatile uint32_t PIR;  ///< Offset: 0x2C - QUADSPI polling interval register
        volatile uint32_t LPTR;  ///< Offset: 0x30 - QUADSPI low-power timeout register
    };

    /// Peripheral instances
    inline Registers* QUADSPI = reinterpret_cast<Registers*>(QUADSPI_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SPI4 = reinterpret_cast<Registers*>(SPI4_BASE);
    inline Registers* SPI5 = reinterpret_cast<Registers*>(SPI5_BASE);
    inline Registers* SPI6 = reinterpret_cast<Registers*>(SPI6_BASE);
    inline Registers* DELAY_Block_QUADSPI = reinterpret_cast<Registers*>(DELAY_Block_QUADSPI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Enable the QUADSPI.
        constexpr uint32_t ABORT = (1U << 1);  ///< Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit.
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA enable In indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set.
        constexpr uint32_t TCEN = (1U << 3);  ///< Timeout counter enable This bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (nCS) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with nCS maintained low, even if no access to the Flash memory occurs for a long time. Since Flash memories tend to consume more when nCS is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that nCS is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0.
        constexpr uint32_t SSHIFT = (1U << 4);  ///< Sample shift By default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the Flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0.
        constexpr uint32_t DFM = (1U << 6);  ///< Dual-flash mode This bit activates dual-flash mode, where two external Flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0.
        constexpr uint32_t FSEL = (1U << 7);  ///< Flash memory selection This bit selects the Flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1.
        constexpr uint32_t FTHRES = (5 << 8);  ///< FIFO threshold level Defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value.
        constexpr uint32_t TEIE = (1U << 16);  ///< Transfer error interrupt enable This bit enables the transfer error interrupt.
        constexpr uint32_t TCIE = (1U << 17);  ///< Transfer complete interrupt enable This bit enables the transfer complete interrupt.
        constexpr uint32_t FTIE = (1U << 18);  ///< FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
        constexpr uint32_t SMIE = (1U << 19);  ///< Status match interrupt enable This bit enables the status match interrupt.
        constexpr uint32_t TOIE = (1U << 20);  ///< TimeOut interrupt enable This bit enables the TimeOut interrupt.
        constexpr uint32_t APMS = (1U << 22);  ///< Automatic poll mode stop This bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0.
        constexpr uint32_t PMM = (1U << 23);  ///< Polling match mode This bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0.
        constexpr uint32_t PRESCALER = (8 << 24);  ///< clock prescaler
    }

    /// DCR Register bits
    namespace dcr_bits {
        constexpr uint32_t CKMODE = (1U << 0);  ///< indicates the level that clk takes between command
        constexpr uint32_t CSHT = (3 << 8);  ///< Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (nCS) must remain high between commands issued to the Flash memory. ... This field can be modified only when BUSY = 0.
        constexpr uint32_t FSIZE = (5 << 16);  ///< Flash memory size This field defines the size of external memory using the following formula: Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the Flash memory. The Flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two Flash memories together. This field can be modified only when BUSY = 0.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TEF = (1U << 0);  ///< Transfer error flag This bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF.
        constexpr uint32_t TCF = (1U << 1);  ///< Transfer complete flag This bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
        constexpr uint32_t FTF = (1U << 2);  ///< FIFO threshold flag In indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the Flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
        constexpr uint32_t SMF = (1U << 3);  ///< Status match flag This bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF.
        constexpr uint32_t TOF = (1U << 4);  ///< Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
        constexpr uint32_t BUSY = (1U << 5);  ///< Busy This bit is set when an operation is on going. This bit clears automatically when the operation with the Flash memory is finished and the FIFO is empty.
        constexpr uint32_t FLEVEL = (6 << 8);  ///< FIFO level This field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero.
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t CTEF = (1U << 0);  ///< Clear transfer error flag Writing 1 clears the TEF flag in the QUADSPI_SR register
        constexpr uint32_t CTCF = (1U << 1);  ///< Clear transfer complete flag Writing 1 clears the TCF flag in the QUADSPI_SR register
        constexpr uint32_t CSMF = (1U << 3);  ///< Clear status match flag Writing 1 clears the SMF flag in the QUADSPI_SR register
        constexpr uint32_t CTOF = (1U << 4);  ///< Clear timeout flag Writing 1 clears the TOF flag in the QUADSPI_SR register
    }

    /// DLR Register bits
    namespace dlr_bits {
        constexpr uint32_t DL = (32 << 0);  ///< Data length Number of data to be retrieved (value+1) in indirect and status-polling modes. A value no greater than 3 (indicating 4 bytes) should be used for status-polling mode. All 1s in indirect mode means undefined length, where QUADSPI will continue until the end of memory, as defined by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001: 2 bytes are to be transferred 0x0000_0002: 3 bytes are to be transferred 0x0000_0003: 4 bytes are to be transferred ... 0xFFFF_FFFD: 4,294,967,294 (4G-2) bytes are to be transferred 0xFFFF_FFFE: 4,294,967,295 (4G-1) bytes are to be transferred 0xFFFF_FFFF: undefined length -- all bytes until the end of Flash memory (as defined by FSIZE) are to be transferred. Continue reading indefinitely if FSIZE = 0x1F. DL[0] is stuck at 1 in dual-flash mode (DFM = 1) even when 0 is written to this bit, thus assuring that each access transfers an even number of bytes. This field has no effect when in memory-mapped mode (FMODE = 10). This field can be written only when BUSY = 0.
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t INSTRUCTION = (8 << 0);  ///< Instruction Instruction to be send to the external SPI device. This field can be written only when BUSY = 0.
        constexpr uint32_t IMODE = (2 << 8);  ///< Instruction mode This field defines the instruction phase mode of operation: This field can be written only when BUSY = 0.
        constexpr uint32_t ADMODE = (2 << 10);  ///< Address mode This field defines the address phase mode of operation: This field can be written only when BUSY = 0.
        constexpr uint32_t ADSIZE = (2 << 12);  ///< Address size This bit defines address size: This field can be written only when BUSY = 0.
        constexpr uint32_t ABMODE = (2 << 14);  ///< Alternate bytes mode This field defines the alternate-bytes phase mode of operation: This field can be written only when BUSY = 0.
        constexpr uint32_t ABSIZE = (2 << 16);  ///< Alternate bytes size This bit defines alternate bytes size: This field can be written only when BUSY = 0.
        constexpr uint32_t DCYC = (5 << 18);  ///< Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0.
        constexpr uint32_t DMODE = (2 << 24);  ///< Data mode This field defines the data phases mode of operation: This field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0.
        constexpr uint32_t FMODE = (2 << 26);  ///< Functional mode This field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0.
        constexpr uint32_t SIOO = (1U << 28);  ///< Send instruction only once mode See Section15.3.11: Sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0.
        constexpr uint32_t DHHC = (1U << 30);  ///< DDR hold Delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: This feature is only active in DDR mode. This field can be written only when BUSY = 0.
        constexpr uint32_t DDRM = (1U << 31);  ///< Double data rate mode This bit sets the DDR mode for the address, alternate byte and data phase: This field can be written only when BUSY = 0.
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< [31 0]: Address Address to be send to the external Flash memory Writes to this field are ignored when BUSY = 0 or when FMODE = 11 (memory-mapped mode). In dual flash mode, ADDRESS[0] is automatically stuck to 0 as the address should always be even
    }

    /// ABR Register bits
    namespace abr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< Alternate Bytes Optional data to be send to the external SPI device right after the address. This field can be written only when BUSY = 0.
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data Data to be sent/received to/from the external SPI device. In indirect write mode, data written to this register is stored on the FIFO before it is sent to the Flash memory during the data phase. If the FIFO is too full, a write operation is stalled until the FIFO has enough space to accept the amount of data being written. In indirect read mode, reading this register gives (via the FIFO) the data which was received from the Flash memory. If the FIFO does not have as many bytes as requested by the read operation and if BUSY=1, the read operation is stalled until enough data is present or until the transfer is complete, whichever happens first. In automatic polling mode, this register contains the last data read from the Flash memory (without masking). Word, halfword, and byte accesses to this register are supported. In indirect write mode, a byte write adds 1 byte to the FIFO, a halfword write 2, and a word write 4. Similarly, in indirect read mode, a byte read removes 1 byte from the FIFO, a halfword read 2, and a word read 4. Accesses in indirect mode must be aligned to the bottom of this register: a byte read must read DATA[7:0] and a halfword read must read DATA[15:0].
    }

    /// PSMKR Register bits
    namespace psmkr_bits {
        constexpr uint32_t MASK = (32 << 0);  ///< Status mask Mask to be applied to the status bytes received in polling mode. For bit n: This field can be written only when BUSY = 0.
    }

    /// PSMAR Register bits
    namespace psmar_bits {
        constexpr uint32_t MATCH = (32 << 0);  ///< Status match Value to be compared with the masked status register to get a match. This field can be written only when BUSY = 0.
    }

    /// PIR Register bits
    namespace pir_bits {
        constexpr uint32_t INTERVAL = (16 << 0);  ///< Polling interval Number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0.
    }

    /// LPTR Register bits
    namespace lptr_bits {
        constexpr uint32_t TIMEOUT = (16 << 0);  ///< Timeout period After each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises nCS, putting the Flash memory in a lower-consumption state. This field can be written only when BUSY = 0.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x48021800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - RNG control register
        volatile uint32_t SR;  ///< Offset: 0x04 - RNG status register
        volatile uint32_t DR;  ///< Offset: 0x08 - The RNG_DR register is a read-only register that...
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RNGEN = (1U << 2);  ///< Random number generator enable
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated.
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01)
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register.
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data 32-bit random data which are valid when DRDY=1.
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x58004000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_TR;  ///< Offset: 0x00 - The RTC_TR is the calendar time shadow register. This...
        volatile uint32_t RTC_DR;  ///< Offset: 0x04 - The RTC_DR is the calendar date shadow register. This...
        volatile uint32_t RTC_CR;  ///< Offset: 0x08 - RTC control register
        volatile uint32_t RTC_ISR;  ///< Offset: 0x0C - This register is write protected (except for...
        volatile uint32_t RTC_PRER;  ///< Offset: 0x10 - This register must be written in initialization mode...
        volatile uint32_t RTC_WUTR;  ///< Offset: 0x14 - This register can be written only when WUTWF is set to 1...
        volatile uint32_t RTC_ALRMAR;  ///< Offset: 0x1C - This register can be written only when ALRAWF is set to...
        volatile uint32_t RTC_ALRMBR;  ///< Offset: 0x20 - This register can be written only when ALRBWF is set to...
        volatile uint32_t RTC_WPR;  ///< Offset: 0x24 - RTC write protection register
        volatile uint32_t RTC_SSR;  ///< Offset: 0x28 - RTC sub second register
        volatile uint32_t RTC_SHIFTR;  ///< Offset: 0x2C - This register is write protected. The write access...
        volatile uint32_t RTC_TSTR;  ///< Offset: 0x30 - The content of this register is valid only when TSF is...
        volatile uint32_t RTC_TSDR;  ///< Offset: 0x34 - The content of this register is valid only when TSF is...
        volatile uint32_t RTC_TSSSR;  ///< Offset: 0x38 - The content of this register is valid only when...
        volatile uint32_t RTC_CALR;  ///< Offset: 0x3C - This register is write protected. The write access...
        volatile uint32_t RTC_TAMPCR;  ///< Offset: 0x40 - RTC tamper and alternate function configuration register
        volatile uint32_t RTC_ALRMASSR;  ///< Offset: 0x44 - This register can be written only when ALRAE is reset in...
        volatile uint32_t RTC_ALRMBSSR;  ///< Offset: 0x48 - This register can be written only when ALRBE is reset in...
        volatile uint32_t RTC_BKP0R;  ///< Offset: 0x50 - RTC backup registers
        volatile uint32_t RTC_BKP1R;  ///< Offset: 0x54 - RTC backup registers
        volatile uint32_t RTC_BKP2R;  ///< Offset: 0x58 - RTC backup registers
        volatile uint32_t RTC_BKP3R;  ///< Offset: 0x5C - RTC backup registers
        volatile uint32_t RTC_BKP4R;  ///< Offset: 0x60 - RTC backup registers
        volatile uint32_t RTC_BKP5R;  ///< Offset: 0x64 - RTC backup registers
        volatile uint32_t RTC_BKP6R;  ///< Offset: 0x68 - RTC backup registers
        volatile uint32_t RTC_BKP7R;  ///< Offset: 0x6C - RTC backup registers
        volatile uint32_t RTC_BKP8R;  ///< Offset: 0x70 - RTC backup registers
        volatile uint32_t RTC_BKP9R;  ///< Offset: 0x74 - RTC backup registers
        volatile uint32_t RTC_BKP10R;  ///< Offset: 0x78 - RTC backup registers
        volatile uint32_t RTC_BKP11R;  ///< Offset: 0x7C - RTC backup registers
        volatile uint32_t RTC_BKP12R;  ///< Offset: 0x80 - RTC backup registers
        volatile uint32_t RTC_BKP13R;  ///< Offset: 0x84 - RTC backup registers
        volatile uint32_t RTC_BKP14R;  ///< Offset: 0x88 - RTC backup registers
        volatile uint32_t RTC_BKP15R;  ///< Offset: 0x8C - RTC backup registers
        volatile uint32_t RTC_OR;  ///< Offset: 0x4C - RTC option register
        volatile uint32_t RTC_BKP16R;  ///< Offset: 0x90 - RTC backup registers
        volatile uint32_t RTC_BKP17R;  ///< Offset: 0x94 - RTC backup registers
        volatile uint32_t RTC_BKP18R;  ///< Offset: 0x98 - RTC backup registers
        volatile uint32_t RTC_BKP19R;  ///< Offset: 0x9C - RTC backup registers
        volatile uint32_t RTC_BKP20R;  ///< Offset: 0xA0 - RTC backup registers
        volatile uint32_t RTC_BKP21R;  ///< Offset: 0xA4 - RTC backup registers
        volatile uint32_t RTC_BKP22R;  ///< Offset: 0xA8 - RTC backup registers
        volatile uint32_t RTC_BKP23R;  ///< Offset: 0xAC - RTC backup registers
        volatile uint32_t RTC_BKP24R;  ///< Offset: 0xB0 - RTC backup registers
        volatile uint32_t RTC_BKP25R;  ///< Offset: 0xB4 - RTC backup registers
        volatile uint32_t RTC_BKP26R;  ///< Offset: 0xB8 - RTC backup registers
        volatile uint32_t RTC_BKP27R;  ///< Offset: 0xBC - RTC backup registers
        volatile uint32_t RTC_BKP28R;  ///< Offset: 0xC0 - RTC backup registers
        volatile uint32_t RTC_BKP29R;  ///< Offset: 0xC4 - RTC backup registers
        volatile uint32_t RTC_BKP30R;  ///< Offset: 0xC8 - RTC backup registers
        volatile uint32_t RTC_BKP31R;  ///< Offset: 0xCC - RTC backup registers
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// RTC_TR Register bits
    namespace rtc_tr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_DR Register bits
    namespace rtc_dr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
    }

    /// RTC_CR Register bits
    namespace rtc_cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< Wakeup clock selection
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
        constexpr uint32_t BKP = (1U << 18);  ///< Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection When COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to Section24.3.15: Calibration clock output
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity This bit is used to configure the polarity of RTC_ALARM output
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection These bits are used to select the flag to be routed to RTC_ALARM output
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable This bit enables the RTC_CALIB output
        constexpr uint32_t ITSE = (1U << 24);  ///< timestamp on internal event enable
    }

    /// RTC_ISR Register bits
    namespace rtc_isr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag This bit is set by hardware when Alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag This bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set.
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t ALRAF = (1U << 8);  ///< Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0.
        constexpr uint32_t ALRBF = (1U << 9);  ///< Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0.
        constexpr uint32_t WUTF = (1U << 10);  ///< Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSF = (1U << 11);  ///< Time-stamp flag This flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0.
        constexpr uint32_t TSOVF = (1U << 12);  ///< Time-stamp overflow flag This flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t TAMP1F = (1U << 13);  ///< RTC_TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0
        constexpr uint32_t TAMP2F = (1U << 14);  ///< RTC_TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0
        constexpr uint32_t TAMP3F = (1U << 15);  ///< RTC_TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
        constexpr uint32_t ITSF = (1U << 17);  ///< Internal tTime-stamp flag
    }

    /// RTC_PRER Register bits
    namespace rtc_prer_bits {
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    }

    /// RTC_WUTR Register bits
    namespace rtc_wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden.
    }

    /// RTC_ALRMAR Register bits
    namespace rtc_alrmar_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format.
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format.
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
    }

    /// RTC_ALRMBR Register bits
    namespace rtc_alrmbr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
    }

    /// RTC_WPR Register bits
    namespace rtc_wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection.
    }

    /// RTC_SSR Register bits
    namespace rtc_ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    }

    /// RTC_SHIFTR Register bits
    namespace rtc_shiftr_bits {
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time.
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    }

    /// RTC_TSTR Register bits
    namespace rtc_tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_TSDR Register bits
    namespace rtc_tsdr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
    }

    /// RTC_TSSSR Register bits
    namespace rtc_tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    }

    /// RTC_CALR Register bits
    namespace rtc_calr_bits {
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section24.3.12: RTC smooth digital calibration on page13.
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12: RTC smooth digital calibration.
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to Section24.3.12: RTC smooth digital calibration.
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to Section24.3.12: RTC smooth digital calibration.
    }

    /// RTC_TAMPCR Register bits
    namespace rtc_tampcr_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< RTC_TAMP1 input detection enable
        constexpr uint32_t TAMP1TRG = (1U << 1);  ///< Active level for RTC_TAMP1 input If TAMPFLT != 00 if TAMPFLT = 00:
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP2E = (1U << 3);  ///< RTC_TAMP2 input detection enable
        constexpr uint32_t TAMP2TRG = (1U << 4);  ///< Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:
        constexpr uint32_t TAMP3E = (1U << 5);  ///< RTC_TAMP3 detection enable
        constexpr uint32_t TAMP3TRG = (1U << 6);  ///< Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:
        constexpr uint32_t TAMPTS = (1U << 7);  ///< Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register.
        constexpr uint32_t TAMPFREQ = (3 << 8);  ///< Tamper sampling frequency Determines the frequency at which each of the RTC_TAMPx inputs are sampled.
        constexpr uint32_t TAMPFLT = (2 << 11);  ///< RTC_TAMPx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a Tamper event. TAMPFLT is valid for each of the RTC_TAMPx inputs.
        constexpr uint32_t TAMPPRCH = (2 << 13);  ///< RTC_TAMPx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the RTC_TAMPx inputs.
        constexpr uint32_t TAMPPUDIS = (1U << 15);  ///< RTC_TAMPx pull-up disable This bit determines if each of the RTC_TAMPx pins are pre-charged before each sample.
        constexpr uint32_t TAMP1IE = (1U << 16);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMP1NOERASE = (1U << 17);  ///< Tamper 1 no erase
        constexpr uint32_t TAMP1MF = (1U << 18);  ///< Tamper 1 mask flag
        constexpr uint32_t TAMP2IE = (1U << 19);  ///< Tamper 2 interrupt enable
        constexpr uint32_t TAMP2NOERASE = (1U << 20);  ///< Tamper 2 no erase
        constexpr uint32_t TAMP2MF = (1U << 21);  ///< Tamper 2 mask flag
        constexpr uint32_t TAMP3IE = (1U << 22);  ///< Tamper 3 interrupt enable
        constexpr uint32_t TAMP3NOERASE = (1U << 23);  ///< Tamper 3 no erase
        constexpr uint32_t TAMP3MF = (1U << 24);  ///< Tamper 3 mask flag
    }

    /// RTC_ALRMASSR Register bits
    namespace rtc_alrmassr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_ALRMBSSR Register bits
    namespace rtc_alrmbssr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    }

    /// RTC_BKP0R Register bits
    namespace rtc_bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP1R Register bits
    namespace rtc_bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP2R Register bits
    namespace rtc_bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP3R Register bits
    namespace rtc_bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP4R Register bits
    namespace rtc_bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP5R Register bits
    namespace rtc_bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP6R Register bits
    namespace rtc_bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP7R Register bits
    namespace rtc_bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP8R Register bits
    namespace rtc_bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP9R Register bits
    namespace rtc_bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP10R Register bits
    namespace rtc_bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP11R Register bits
    namespace rtc_bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP12R Register bits
    namespace rtc_bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP13R Register bits
    namespace rtc_bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP14R Register bits
    namespace rtc_bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP15R Register bits
    namespace rtc_bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_OR Register bits
    namespace rtc_or_bits {
        constexpr uint32_t RTC_ALARM_TYPE = (1U << 0);  ///< RTC_ALARM output type on PC13
        constexpr uint32_t RTC_OUT_RMP = (1U << 1);  ///< RTC_OUT remap
    }

    /// RTC_BKP16R Register bits
    namespace rtc_bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP17R Register bits
    namespace rtc_bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP18R Register bits
    namespace rtc_bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP19R Register bits
    namespace rtc_bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP20R Register bits
    namespace rtc_bkp20r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP21R Register bits
    namespace rtc_bkp21r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP22R Register bits
    namespace rtc_bkp22r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP23R Register bits
    namespace rtc_bkp23r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP24R Register bits
    namespace rtc_bkp24r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP25R Register bits
    namespace rtc_bkp25r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP26R Register bits
    namespace rtc_bkp26r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP27R Register bits
    namespace rtc_bkp27r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP28R Register bits
    namespace rtc_bkp28r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP29R Register bits
    namespace rtc_bkp29r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP30R Register bits
    namespace rtc_bkp30r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

    /// RTC_BKP31R Register bits
    namespace rtc_bkp31r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    }

}

// ============================================================================
// SAI4 Peripheral
// ============================================================================

namespace sai4 {
    /// Base addresses
    constexpr uint32_t SAI4_BASE = 0x58005400;

    /// SAI4 Register structure
    struct Registers {
        volatile uint32_t SAI_GCR;  ///< Offset: 0x00 - Global configuration register
        volatile uint32_t SAI_ACR1;  ///< Offset: 0x04 - Configuration register 1
        volatile uint32_t SAI_ACR2;  ///< Offset: 0x08 - Configuration register 2
        volatile uint32_t SAI_AFRCR;  ///< Offset: 0x0C - This register has no meaning in AC97 and SPDIF audio protocol
        volatile uint32_t SAI_ASLOTR;  ///< Offset: 0x10 - This register has no meaning in AC97 and SPDIF audio protocol
        volatile uint32_t SAI_AIM;  ///< Offset: 0x14 - Interrupt mask register 2
        volatile uint32_t SAI_ASR;  ///< Offset: 0x18 - Status register
        volatile uint32_t SAI_ACLRFR;  ///< Offset: 0x1C - Clear flag register
        volatile uint32_t SAI_ADR;  ///< Offset: 0x20 - Data register
        volatile uint32_t SAI_BCR1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t SAI_BCR2;  ///< Offset: 0x28 - Configuration register 2
        volatile uint32_t SAI_BFRCR;  ///< Offset: 0x2C - This register has no meaning in AC97 and SPDIF audio protocol
        volatile uint32_t SAI_BSLOTR;  ///< Offset: 0x30 - This register has no meaning in AC97 and SPDIF audio protocol
        volatile uint32_t SAI_BIM;  ///< Offset: 0x34 - Interrupt mask register 2
        volatile uint32_t SAI_BSR;  ///< Offset: 0x38 - Status register
        volatile uint32_t SAI_BCLRFR;  ///< Offset: 0x3C - Clear flag register
        volatile uint32_t SAI_BDR;  ///< Offset: 0x40 - Data register
        volatile uint32_t SAI_PDMCR;  ///< Offset: 0x44 - PDM control register
        volatile uint32_t SAI_PDMDLY;  ///< Offset: 0x48 - PDM delay register
    };

    /// Peripheral instances
    inline Registers* SAI4 = reinterpret_cast<Registers*>(SAI4_BASE);

    // Bit definitions
    /// SAI_GCR Register bits
    namespace sai_gcr_bits {
        constexpr uint32_t SYNCOUT = (2 << 4);  ///< Synchronization outputs These bits are set and cleared by software.
        constexpr uint32_t SYNCIN = (2 << 0);  ///< Synchronization inputs
    }

    /// SAI_ACR1 Register bits
    namespace sai_acr1_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< SAIx audio block mode immediately
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
        constexpr uint32_t DS = (3 << 5);  ///< Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
        constexpr uint32_t SAIXEN = (1U << 16);  ///< Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
        constexpr uint32_t NOMCK = (1U << 19);  ///< No divider
        constexpr uint32_t MCKDIV = (4 << 20);  ///< Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
        constexpr uint32_t OSR = (1U << 26);  ///< Oversampling ratio for master clock
    }

    /// SAI_ACR2 Register bits
    namespace sai_acr2_bits {
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold. This bit is set and cleared by software.
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
        constexpr uint32_t MUTECNT = (6 << 7);  ///< Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    }

    /// SAI_AFRCR Register bits
    namespace sai_afrcr_bits {
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    }

    /// SAI_ASLOTR Register bits
    namespace sai_aslotr_bits {
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    }

    /// SAI_AIM Register bits
    namespace sai_aim_bits {
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    }

    /// SAI_ASR Register bits
    namespace sai_asr_bits {
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    }

    /// SAI_ACLRFR Register bits
    namespace sai_aclrfr_bits {
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    }

    /// SAI_ADR Register bits
    namespace sai_adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    }

    /// SAI_BCR1 Register bits
    namespace sai_bcr1_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< SAIx audio block mode immediately
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
        constexpr uint32_t DS = (3 << 5);  ///< Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
        constexpr uint32_t SAIXEN = (1U << 16);  ///< Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
        constexpr uint32_t NOMCK = (1U << 19);  ///< No divider
        constexpr uint32_t MCKDIV = (4 << 20);  ///< Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
        constexpr uint32_t OSR = (1U << 26);  ///< Oversampling ratio for master clock
    }

    /// SAI_BCR2 Register bits
    namespace sai_bcr2_bits {
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold. This bit is set and cleared by software.
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
        constexpr uint32_t MUTECNT = (6 << 7);  ///< Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    }

    /// SAI_BFRCR Register bits
    namespace sai_bfrcr_bits {
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    }

    /// SAI_BSLOTR Register bits
    namespace sai_bslotr_bits {
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    }

    /// SAI_BIM Register bits
    namespace sai_bim_bits {
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    }

    /// SAI_BSR Register bits
    namespace sai_bsr_bits {
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    }

    /// SAI_BCLRFR Register bits
    namespace sai_bclrfr_bits {
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    }

    /// SAI_BDR Register bits
    namespace sai_bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    }

    /// SAI_PDMCR Register bits
    namespace sai_pdmcr_bits {
        constexpr uint32_t PDMEN = (1U << 0);  ///< PDM enable
        constexpr uint32_t MICNBR = (2 << 4);  ///< Number of microphones
        constexpr uint32_t CKEN1 = (1U << 8);  ///< Clock enable of bitstream clock number 1
        constexpr uint32_t CKEN2 = (1U << 9);  ///< Clock enable of bitstream clock number 2
        constexpr uint32_t CKEN3 = (1U << 10);  ///< Clock enable of bitstream clock number 3
        constexpr uint32_t CKEN4 = (1U << 11);  ///< Clock enable of bitstream clock number 4
    }

    /// SAI_PDMDLY Register bits
    namespace sai_pdmdly_bits {
        constexpr uint32_t DLYM1L = (3 << 0);  ///< Delay line adjust for first microphone of pair 1
        constexpr uint32_t DLYM1R = (3 << 4);  ///< Delay line adjust for second microphone of pair 1
        constexpr uint32_t DLYM2L = (3 << 8);  ///< Delay line for first microphone of pair 2
        constexpr uint32_t DLYM2R = (3 << 12);  ///< Delay line for second microphone of pair 2
        constexpr uint32_t DLYM3L = (3 << 16);  ///< Delay line for first microphone of pair 3
        constexpr uint32_t DLYM3R = (3 << 20);  ///< Delay line for second microphone of pair 3
        constexpr uint32_t DLYM4L = (3 << 24);  ///< Delay line for first microphone of pair 4
        constexpr uint32_t DLYM4R = (3 << 28);  ///< Delay line for second microphone of pair 4
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40015800;

    /// SAI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

}

// ============================================================================
// SAI2 Peripheral
// ============================================================================

namespace sai2 {
    /// Base addresses
    constexpr uint32_t SAI2_BASE = 0x40015C00;

    /// SAI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI2 = reinterpret_cast<Registers*>(SAI2_BASE);

}

// ============================================================================
// SAI3 Peripheral
// ============================================================================

namespace sai3 {
    /// Base addresses
    constexpr uint32_t SAI3_BASE = 0x40016000;

    /// SAI3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI3 = reinterpret_cast<Registers*>(SAI3_BASE);

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC1_BASE = 0x52007000;
    constexpr uint32_t SDMMC2_BASE = 0x48022400;
    constexpr uint32_t DELAY_Block_SDMMC1_BASE = 0x52008000;
    constexpr uint32_t DELAY_Block_SDMMC2_BASE = 0x48022800;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t POWER;  ///< Offset: 0x00 - SDMMC power control register
        volatile uint32_t CLKCR;  ///< Offset: 0x04 - The SDMMC_CLKCR register controls the SDMMC_CK output...
        volatile uint32_t ARGR;  ///< Offset: 0x08 - The SDMMC_ARGR register contains a 32-bit command...
        volatile uint32_t CMDR;  ///< Offset: 0x0C - The SDMMC_CMDR register contains the command index and...
        volatile uint32_t RESP1R;  ///< Offset: 0x14 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t RESP2R;  ///< Offset: 0x18 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t RESP3R;  ///< Offset: 0x1C - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t RESP4R;  ///< Offset: 0x20 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t DTIMER;  ///< Offset: 0x24 - The SDMMC_DTIMER register contains the data timeout...
        volatile uint32_t DLENR;  ///< Offset: 0x28 - The SDMMC_DLENR register contains the number of data...
        volatile uint32_t DCTRL;  ///< Offset: 0x2C - The SDMMC_DCTRL register control the data path state...
        volatile uint32_t DCNTR;  ///< Offset: 0x30 - The SDMMC_DCNTR register loads the value from the data...
        volatile uint32_t STAR;  ///< Offset: 0x34 - The SDMMC_STAR register is a read-only register. It...
        volatile uint32_t ICR;  ///< Offset: 0x38 - The SDMMC_ICR register is a write-only register. Writing...
        volatile uint32_t MASKR;  ///< Offset: 0x3C - The interrupt mask register determines which status...
        volatile uint32_t ACKTIMER;  ///< Offset: 0x40 - The SDMMC_ACKTIMER register contains the acknowledgment...
        volatile uint32_t IDMACTRLR;  ///< Offset: 0x50 - The receive and transmit FIFOs can be read or written as...
        volatile uint32_t IDMABSIZER;  ///< Offset: 0x54 - The SDMMC_IDMABSIZER register contains the buffers size...
        volatile uint32_t IDMABASE0R;  ///< Offset: 0x58 - The SDMMC_IDMABASE0R register contains the memory buffer...
        volatile uint32_t IDMABASE1R;  ///< Offset: 0x5C - The SDMMC_IDMABASE1R register contains the double buffer...
        volatile uint32_t FIFOR;  ///< Offset: 0x80 - The receive and transmit FIFOs can be only read or...
        volatile uint32_t VER;  ///< Offset: 0x3F4 - SDMMC IP version register
        volatile uint32_t ID;  ///< Offset: 0x3F8 - SDMMC IP identification register
        volatile uint32_t RESPCMDR;  ///< Offset: 0x10 - SDMMC command response register
    };

    /// Peripheral instances
    inline Registers* SDMMC1 = reinterpret_cast<Registers*>(SDMMC1_BASE);
    inline Registers* SDMMC2 = reinterpret_cast<Registers*>(SDMMC2_BASE);
    inline Registers* DELAY_Block_SDMMC1 = reinterpret_cast<Registers*>(DELAY_Block_SDMMC1_BASE);
    inline Registers* DELAY_Block_SDMMC2 = reinterpret_cast<Registers*>(DELAY_Block_SDMMC2_BASE);

    // Bit definitions
    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t PWRCTRL = (2 << 0);  ///< SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
        constexpr uint32_t VSWITCH = (1U << 2);  ///< Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
        constexpr uint32_t VSWITCHEN = (1U << 3);  ///< Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
        constexpr uint32_t DIRPOL = (1U << 4);  ///< Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    }

    /// CLKCR Register bits
    namespace clkcr_bits {
        constexpr uint32_t CLKDIV = (10 << 0);  ///< Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
        constexpr uint32_t PWRSAV = (1U << 12);  ///< Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
        constexpr uint32_t WIDBUS = (2 << 14);  ///< Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        constexpr uint32_t NEGEDGE = (1U << 16);  ///< SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
        constexpr uint32_t HWFC_EN = (1U << 17);  ///< Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
        constexpr uint32_t DDR = (1U << 18);  ///< Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
        constexpr uint32_t BUSSPEED = (1U << 19);  ///< Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        constexpr uint32_t SELCLKRX = (2 << 20);  ///< Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    }

    /// ARGR Register bits
    namespace argr_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
    }

    /// CMDR Register bits
    namespace cmdr_bits {
        constexpr uint32_t CMDINDEX = (6 << 0);  ///< Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
        constexpr uint32_t CMDTRANS = (1U << 6);  ///< The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
        constexpr uint32_t CMDSTOP = (1U << 7);  ///< The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
        constexpr uint32_t WAITRESP = (2 << 8);  ///< Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
        constexpr uint32_t WAITINT = (1U << 10);  ///< CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
        constexpr uint32_t WAITPEND = (1U << 11);  ///< CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
        constexpr uint32_t CPSMEN = (1U << 12);  ///< Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
        constexpr uint32_t DTHOLD = (1U << 13);  ///< Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
        constexpr uint32_t BOOTMODE = (1U << 14);  ///< Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
        constexpr uint32_t BOOTEN = (1U << 15);  ///< Enable boot mode procedure.
        constexpr uint32_t CMDSUSPEND = (1U << 16);  ///< The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    }

    /// RESP1R Register bits
    namespace resp1r_bits {
        constexpr uint32_t CARDSTATUS1 = (32 << 0);  ///< see Table 432
    }

    /// RESP2R Register bits
    namespace resp2r_bits {
        constexpr uint32_t CARDSTATUS2 = (32 << 0);  ///< see Table404.
    }

    /// RESP3R Register bits
    namespace resp3r_bits {
        constexpr uint32_t CARDSTATUS3 = (32 << 0);  ///< see Table404.
    }

    /// RESP4R Register bits
    namespace resp4r_bits {
        constexpr uint32_t CARDSTATUS4 = (32 << 0);  ///< see Table404.
    }

    /// DTIMER Register bits
    namespace dtimer_bits {
        constexpr uint32_t DATATIME = (32 << 0);  ///< Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
    }

    /// DLENR Register bits
    namespace dlenr_bits {
        constexpr uint32_t DATALENGTH = (25 << 0);  ///< Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
    }

    /// DCTRL Register bits
    namespace dctrl_bits {
        constexpr uint32_t DTEN = (1U << 0);  ///< Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
        constexpr uint32_t DTDIR = (1U << 1);  ///< Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t DTMODE = (2 << 2);  ///< Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t DBLOCKSIZE = (4 << 4);  ///< Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
        constexpr uint32_t RWSTART = (1U << 8);  ///< Read wait start. If this bit is set, read wait operation starts.
        constexpr uint32_t RWSTOP = (1U << 9);  ///< Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
        constexpr uint32_t RWMOD = (1U << 10);  ///< Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
        constexpr uint32_t BOOTACKEN = (1U << 12);  ///< Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t FIFORST = (1U << 13);  ///< FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    }

    /// DCNTR Register bits
    namespace dcntr_bits {
        constexpr uint32_t DATACOUNT = (25 << 0);  ///< Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t CCRCFAIL = (1U << 0);  ///< Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DCRCFAIL = (1U << 1);  ///< Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CTIMEOUT = (1U << 2);  ///< Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
        constexpr uint32_t DTIMEOUT = (1U << 3);  ///< Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t TXUNDERR = (1U << 4);  ///< Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t RXOVERR = (1U << 5);  ///< Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CMDREND = (1U << 6);  ///< Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CMDSENT = (1U << 7);  ///< Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DATAEND = (1U << 8);  ///< Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DHOLD = (1U << 9);  ///< Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DBCKEND = (1U << 10);  ///< Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DABORT = (1U << 11);  ///< Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DPSMACT = (1U << 12);  ///< Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
        constexpr uint32_t CPSMACT = (1U << 13);  ///< Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
        constexpr uint32_t TXFIFOHE = (1U << 14);  ///< Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
        constexpr uint32_t RXFIFOHF = (1U << 15);  ///< Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
        constexpr uint32_t TXFIFOF = (1U << 16);  ///< Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
        constexpr uint32_t RXFIFOF = (1U << 17);  ///< Receive FIFO full This bit is cleared when one FIFO location becomes empty.
        constexpr uint32_t TXFIFOE = (1U << 18);  ///< Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
        constexpr uint32_t RXFIFOE = (1U << 19);  ///< Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
        constexpr uint32_t BUSYD0 = (1U << 20);  ///< Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
        constexpr uint32_t BUSYD0END = (1U << 21);  ///< end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t SDIOIT = (1U << 22);  ///< SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t ACKFAIL = (1U << 23);  ///< Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t ACKTIMEOUT = (1U << 24);  ///< Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t VSWEND = (1U << 25);  ///< Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CKSTOP = (1U << 26);  ///< SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t IDMATE = (1U << 27);  ///< IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t IDMABTC = (1U << 28);  ///< IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t CCRCFAILC = (1U << 0);  ///< CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
        constexpr uint32_t DCRCFAILC = (1U << 1);  ///< DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
        constexpr uint32_t CTIMEOUTC = (1U << 2);  ///< CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
        constexpr uint32_t DTIMEOUTC = (1U << 3);  ///< DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
        constexpr uint32_t TXUNDERRC = (1U << 4);  ///< TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
        constexpr uint32_t RXOVERRC = (1U << 5);  ///< RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
        constexpr uint32_t CMDRENDC = (1U << 6);  ///< CMDREND flag clear bit Set by software to clear the CMDREND flag.
        constexpr uint32_t CMDSENTC = (1U << 7);  ///< CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
        constexpr uint32_t DATAENDC = (1U << 8);  ///< DATAEND flag clear bit Set by software to clear the DATAEND flag.
        constexpr uint32_t DHOLDC = (1U << 9);  ///< DHOLD flag clear bit Set by software to clear the DHOLD flag.
        constexpr uint32_t DBCKENDC = (1U << 10);  ///< DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
        constexpr uint32_t DABORTC = (1U << 11);  ///< DABORT flag clear bit Set by software to clear the DABORT flag.
        constexpr uint32_t BUSYD0ENDC = (1U << 21);  ///< BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
        constexpr uint32_t SDIOITC = (1U << 22);  ///< SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
        constexpr uint32_t ACKFAILC = (1U << 23);  ///< ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
        constexpr uint32_t ACKTIMEOUTC = (1U << 24);  ///< ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
        constexpr uint32_t VSWENDC = (1U << 25);  ///< VSWEND flag clear bit Set by software to clear the VSWEND flag.
        constexpr uint32_t CKSTOPC = (1U << 26);  ///< CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
        constexpr uint32_t IDMATEC = (1U << 27);  ///< IDMA transfer error clear bit Set by software to clear the IDMATE flag.
        constexpr uint32_t IDMABTCC = (1U << 28);  ///< IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    }

    /// MASKR Register bits
    namespace maskr_bits {
        constexpr uint32_t CCRCFAILIE = (1U << 0);  ///< Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
        constexpr uint32_t DCRCFAILIE = (1U << 1);  ///< Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
        constexpr uint32_t CTIMEOUTIE = (1U << 2);  ///< Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
        constexpr uint32_t DTIMEOUTIE = (1U << 3);  ///< Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
        constexpr uint32_t TXUNDERRIE = (1U << 4);  ///< Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
        constexpr uint32_t RXOVERRIE = (1U << 5);  ///< Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
        constexpr uint32_t CMDRENDIE = (1U << 6);  ///< Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
        constexpr uint32_t CMDSENTIE = (1U << 7);  ///< Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
        constexpr uint32_t DATAENDIE = (1U << 8);  ///< Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
        constexpr uint32_t DHOLDIE = (1U << 9);  ///< Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
        constexpr uint32_t DBCKENDIE = (1U << 10);  ///< Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
        constexpr uint32_t DABORTIE = (1U << 11);  ///< Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
        constexpr uint32_t TXFIFOHEIE = (1U << 14);  ///< Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
        constexpr uint32_t RXFIFOHFIE = (1U << 15);  ///< Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
        constexpr uint32_t RXFIFOFIE = (1U << 17);  ///< Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
        constexpr uint32_t TXFIFOEIE = (1U << 18);  ///< Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
        constexpr uint32_t BUSYD0ENDIE = (1U << 21);  ///< BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
        constexpr uint32_t SDIOITIE = (1U << 22);  ///< SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
        constexpr uint32_t ACKFAILIE = (1U << 23);  ///< Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
        constexpr uint32_t ACKTIMEOUTIE = (1U << 24);  ///< Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
        constexpr uint32_t VSWENDIE = (1U << 25);  ///< Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
        constexpr uint32_t CKSTOPIE = (1U << 26);  ///< Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
        constexpr uint32_t IDMABTCIE = (1U << 28);  ///< IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    }

    /// ACKTIMER Register bits
    namespace acktimer_bits {
        constexpr uint32_t ACKTIME = (25 << 0);  ///< Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
    }

    /// IDMACTRLR Register bits
    namespace idmactrlr_bits {
        constexpr uint32_t IDMAEN = (1U << 0);  ///< IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABMODE = (1U << 1);  ///< Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABACT = (1U << 2);  ///< Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    }

    /// IDMABSIZER Register bits
    namespace idmabsizer_bits {
        constexpr uint32_t IDMABNDT = (8 << 5);  ///< Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    }

    /// IDMABASE0R Register bits
    namespace idmabase0r_bits {
        constexpr uint32_t IDMABASE0 = (32 << 0);  ///< Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
    }

    /// IDMABASE1R Register bits
    namespace idmabase1r_bits {
        constexpr uint32_t IDMABASE1 = (32 << 0);  ///< Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
    }

    /// FIFOR Register bits
    namespace fifor_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
    }

    /// VER Register bits
    namespace ver_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< IP minor revision number.
        constexpr uint32_t MAJREV = (4 << 4);  ///< IP major revision number.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t IP_ID = (32 << 0);  ///< SDMMC IP identification.
    }

    /// RESPCMDR Register bits
    namespace respcmdr_bits {
        constexpr uint32_t RESPCMD = (6 << 0);  ///< Response command index
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x58003C00;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
        constexpr uint32_t VRS = (3 << 4);  ///< Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x58004800;
    constexpr uint32_t WWDG_BASE = 0x50003000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000) These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section23.3.6: Register access protection) Writing the key value CCCCh starts the watchdog (except if the hardware watchdog option is selected)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider These bits are write access protected see Section23.3.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset.
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value These bits are write access protected see Section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Prescaler value can be updated only when PVU bit is reset.
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Reload value can be updated only when RVU bit is reset.
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value These bits are write access protected see Section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 The WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset.
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x58024800;
    constexpr uint32_t OTG1_HS_PWRCLK_BASE = 0x40040E00;
    constexpr uint32_t OTG2_HS_PWRCLK_BASE = 0x40080E00;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - PWR control register 1
        volatile uint32_t CSR1;  ///< Offset: 0x04 - PWR control status register 1
        volatile uint32_t CR2;  ///< Offset: 0x08 - This register is not reset by wakeup from Standby mode,...
        volatile uint32_t CR3;  ///< Offset: 0x0C - Reset only by POR only, not reset by wakeup from Standby...
        volatile uint32_t CPUCR;  ///< Offset: 0x10 - This register allows controlling CPU1 power.
        volatile uint32_t D3CR;  ///< Offset: 0x18 - This register allows controlling D3 domain...
        volatile uint32_t WKUPCR;  ///< Offset: 0x20 - reset only by system reset, not reset by wakeup from...
        volatile uint32_t WKUPFR;  ///< Offset: 0x24 - reset only by system reset, not reset by wakeup from Standby mode
        volatile uint32_t WKUPEPR;  ///< Offset: 0x28 - Reset only by system reset, not reset by wakeup from Standby mode
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);
    inline Registers* OTG1_HS_PWRCLK = reinterpret_cast<Registers*>(OTG1_HS_PWRCLK_BASE);
    inline Registers* OTG2_HS_PWRCLK = reinterpret_cast<Registers*>(OTG2_HS_PWRCLK_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPDS = (1U << 0);  ///< Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit)
        constexpr uint32_t PVDE = (1U << 4);  ///< Programmable voltage detector enable
        constexpr uint32_t PLS = (3 << 5);  ///< Programmable voltage detector level selection These bits select the voltage threshold detected by the PVD. Note: Refer to Section Electrical characteristics of the product datasheet for more details.
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection In reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers.
        constexpr uint32_t FLPS = (1U << 9);  ///< Flash low-power mode in DStop mode This bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from DStop mode. When it is set, the Flash memory enters low-power mode when D1 domain is in DStop mode.
        constexpr uint32_t SVOS = (2 << 14);  ///< System Stop mode voltage scaling selection These bits control the VCORE voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance.
        constexpr uint32_t AVDEN = (1U << 16);  ///< Peripheral voltage monitor on VDDA enable
        constexpr uint32_t ALS = (2 << 17);  ///< Analog voltage detector level selection These bits select the voltage threshold detected by the AVD.
    }

    /// CSR1 Register bits
    namespace csr1_bits {
        constexpr uint32_t PVDO = (1U << 4);  ///< Programmable voltage detect output This bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set.
        constexpr uint32_t ACTVOSRDY = (1U << 13);  ///< Voltage levels ready bit for currently used VOS and SDLEVEL This bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and Bypass mode is selected in PWR control register 3 (PWR_CR3).
        constexpr uint32_t ACTVOS = (2 << 14);  ///< VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU.
        constexpr uint32_t AVDO = (1U << 16);  ///< Analog voltage detector output on VDDA This bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: Since the AVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the AVDEN bit is set.
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t BREN = (1U << 0);  ///< Backup regulator enable When set, the Backup regulator (used to maintain the backup RAM content in Standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in Run and Stop modes. However, its content will be lost in Standby and VBAT modes. If BREN is set, the application must wait till the Backup Regulator Ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in Standby and VBAT modes.
        constexpr uint32_t MONEN = (1U << 4);  ///< VBAT and temperature monitoring enable When set, the VBAT supply and temperature monitoring is enabled.
        constexpr uint32_t BRRDY = (1U << 16);  ///< Backup regulator ready This bit is set by hardware to indicate that the Backup regulator is ready.
        constexpr uint32_t VBATL = (1U << 20);  ///< VBAT level monitoring versus low threshold
        constexpr uint32_t VBATH = (1U << 21);  ///< VBAT level monitoring versus high threshold
        constexpr uint32_t TEMPL = (1U << 22);  ///< Temperature level monitoring versus low threshold
        constexpr uint32_t TEMPH = (1U << 23);  ///< Temperature level monitoring versus high threshold
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t BYPASS = (1U << 0);  ///< Power management unit bypass
        constexpr uint32_t LDOEN = (1U << 1);  ///< Low drop-out regulator enable
        constexpr uint32_t SCUEN = (1U << 2);  ///< SD converter Enable
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT charging resistor selection
        constexpr uint32_t USB33DEN = (1U << 24);  ///< VDD33USB voltage level detector enable.
        constexpr uint32_t USBREGEN = (1U << 25);  ///< USB regulator enable.
        constexpr uint32_t USB33RDY = (1U << 26);  ///< USB supply ready.
    }

    /// CPUCR Register bits
    namespace cpucr_bits {
        constexpr uint32_t PDDS_D1 = (1U << 0);  ///< D1 domain Power Down Deepsleep selection. This bit allows CPU1 to define the Deepsleep mode for D1 domain.
        constexpr uint32_t PDDS_D2 = (1U << 1);  ///< D2 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for D2 domain.
        constexpr uint32_t PDDS_D3 = (1U << 2);  ///< System D3 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for System D3 domain.
        constexpr uint32_t STOPF = (1U << 5);  ///< STOP flag This bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit.
        constexpr uint32_t SBF = (1U << 6);  ///< System Standby flag This bit is set by hardware and cleared only by a POR (Power-on Reset) or by setting the CPU1 CSSF bit
        constexpr uint32_t SBF_D1 = (1U << 7);  ///< D1 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in DStandby mode.
        constexpr uint32_t SBF_D2 = (1U << 8);  ///< D2 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in DStandby mode.
        constexpr uint32_t CSSF = (1U << 9);  ///< Clear D1 domain CPU1 Standby, Stop and HOLD flags (always read as 0) This bit is cleared to 0 by hardware.
        constexpr uint32_t RUN_D3 = (1U << 11);  ///< Keep system D3 domain in Run mode regardless of the CPU sub-systems modes
    }

    /// D3CR Register bits
    namespace d3cr_bits {
        constexpr uint32_t VOSRDY = (1U << 13);  ///< VOS Ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when Bypass mode is selected in PWR control register 3 (PWR_CR3).
        constexpr uint32_t VOS = (2 << 14);  ///< Voltage scaling selection according to performance These bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: When increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling.
    }

    /// WKUPCR Register bits
    namespace wkupcr_bits {
        constexpr uint32_t WKUPC = (6 << 0);  ///< Clear Wakeup pin flag for WKUP. These bits are always read as 0.
    }

    /// WKUPFR Register bits
    namespace wkupfr_bits {
        constexpr uint32_t WKUPF1 = (1U << 0);  ///< Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
        constexpr uint32_t WKUPF2 = (1U << 1);  ///< Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
        constexpr uint32_t WKUPF3 = (1U << 2);  ///< Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
        constexpr uint32_t WKUPF4 = (1U << 3);  ///< Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
        constexpr uint32_t WKUPF5 = (1U << 4);  ///< Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
        constexpr uint32_t WKUPF6 = (1U << 5);  ///< Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    }

    /// WKUPEPR Register bits
    namespace wkupepr_bits {
        constexpr uint32_t WKUPEN1 = (1U << 0);  ///< Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
        constexpr uint32_t WKUPEN2 = (1U << 1);  ///< Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
        constexpr uint32_t WKUPEN3 = (1U << 2);  ///< Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
        constexpr uint32_t WKUPEN4 = (1U << 3);  ///< Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
        constexpr uint32_t WKUPEN5 = (1U << 4);  ///< Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
        constexpr uint32_t WKUPEN6 = (1U << 5);  ///< Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
        constexpr uint32_t WKUPP1 = (1U << 8);  ///< Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
        constexpr uint32_t WKUPP2 = (1U << 9);  ///< Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
        constexpr uint32_t WKUPP3 = (1U << 10);  ///< Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
        constexpr uint32_t WKUPP4 = (1U << 11);  ///< Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
        constexpr uint32_t WKUPP5 = (1U << 12);  ///< Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
        constexpr uint32_t WKUPP6 = (1U << 13);  ///< Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
        constexpr uint32_t WKUPPUPD1 = (2 << 16);  ///< Wakeup pin pull configuration
        constexpr uint32_t WKUPPUPD2 = (2 << 18);  ///< Wakeup pin pull configuration
        constexpr uint32_t WKUPPUPD3 = (2 << 20);  ///< Wakeup pin pull configuration
        constexpr uint32_t WKUPPUPD4 = (2 << 22);  ///< Wakeup pin pull configuration
        constexpr uint32_t WKUPPUPD5 = (2 << 24);  ///< Wakeup pin pull configuration
        constexpr uint32_t WKUPPUPD6 = (2 << 26);  ///< Wakeup pin pull configuration for WKUP(truncate(n/2)-7) These bits define the I/O pad pull configuration used when WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The Wakeup pin pull configuration is kept in Standby mode.
    }

}

// ============================================================================
// LTDC Peripheral
// ============================================================================

namespace ltdc {
    /// Base addresses
    constexpr uint32_t LTDC_BASE = 0x50001000;

    /// LTDC Register structure
    struct Registers {
        volatile uint32_t SSCR;  ///< Offset: 0x08 - Synchronization Size Configuration Register
        volatile uint32_t BPCR;  ///< Offset: 0x0C - Back Porch Configuration Register
        volatile uint32_t AWCR;  ///< Offset: 0x10 - Active Width Configuration Register
        volatile uint32_t TWCR;  ///< Offset: 0x14 - Total Width Configuration Register
        volatile uint32_t GCR;  ///< Offset: 0x18 - Global Control Register
        volatile uint32_t SRCR;  ///< Offset: 0x24 - Shadow Reload Configuration Register
        volatile uint32_t BCCR;  ///< Offset: 0x2C - Background Color Configuration Register
        volatile uint32_t IER;  ///< Offset: 0x34 - Interrupt Enable Register
        volatile uint32_t ISR;  ///< Offset: 0x38 - Interrupt Status Register
        volatile uint32_t ICR;  ///< Offset: 0x3C - Interrupt Clear Register
        volatile uint32_t LIPCR;  ///< Offset: 0x40 - Line Interrupt Position Configuration Register
        volatile uint32_t CPSR;  ///< Offset: 0x44 - Current Position Status Register
        volatile uint32_t CDSR;  ///< Offset: 0x48 - Current Display Status Register
        volatile uint32_t L1CR;  ///< Offset: 0x84 - Layerx Control Register
        volatile uint32_t L1WHPCR;  ///< Offset: 0x88 - Layerx Window Horizontal Position Configuration Register
        volatile uint32_t L1WVPCR;  ///< Offset: 0x8C - Layerx Window Vertical Position Configuration Register
        volatile uint32_t L1CKCR;  ///< Offset: 0x90 - Layerx Color Keying Configuration Register
        volatile uint32_t L1PFCR;  ///< Offset: 0x94 - Layerx Pixel Format Configuration Register
        volatile uint32_t L1CACR;  ///< Offset: 0x98 - Layerx Constant Alpha Configuration Register
        volatile uint32_t L1DCCR;  ///< Offset: 0x9C - Layerx Default Color Configuration Register
        volatile uint32_t L1BFCR;  ///< Offset: 0xA0 - Layerx Blending Factors Configuration Register
        volatile uint32_t L1CFBAR;  ///< Offset: 0xAC - Layerx Color Frame Buffer Address Register
        volatile uint32_t L1CFBLR;  ///< Offset: 0xB0 - Layerx Color Frame Buffer Length Register
        volatile uint32_t L1CFBLNR;  ///< Offset: 0xB4 - Layerx ColorFrame Buffer Line Number Register
        volatile uint32_t L1CLUTWR;  ///< Offset: 0xC4 - Layerx CLUT Write Register
        volatile uint32_t L2CR;  ///< Offset: 0x104 - Layerx Control Register
        volatile uint32_t L2WHPCR;  ///< Offset: 0x108 - Layerx Window Horizontal Position Configuration Register
        volatile uint32_t L2WVPCR;  ///< Offset: 0x10C - Layerx Window Vertical Position Configuration Register
        volatile uint32_t L2CKCR;  ///< Offset: 0x110 - Layerx Color Keying Configuration Register
        volatile uint32_t L2PFCR;  ///< Offset: 0x114 - Layerx Pixel Format Configuration Register
        volatile uint32_t L2CACR;  ///< Offset: 0x118 - Layerx Constant Alpha Configuration Register
        volatile uint32_t L2DCCR;  ///< Offset: 0x11C - Layerx Default Color Configuration Register
        volatile uint32_t L2BFCR;  ///< Offset: 0x120 - Layerx Blending Factors Configuration Register
        volatile uint32_t L2CFBAR;  ///< Offset: 0x12C - Layerx Color Frame Buffer Address Register
        volatile uint32_t L2CFBLR;  ///< Offset: 0x130 - Layerx Color Frame Buffer Length Register
        volatile uint32_t L2CFBLNR;  ///< Offset: 0x134 - Layerx ColorFrame Buffer Line Number Register
        volatile uint32_t L2CLUTWR;  ///< Offset: 0x144 - Layerx CLUT Write Register
    };

    /// Peripheral instances
    inline Registers* LTDC = reinterpret_cast<Registers*>(LTDC_BASE);

    // Bit definitions
    /// SSCR Register bits
    namespace sscr_bits {
        constexpr uint32_t HSW = (10 << 16);  ///< Horizontal Synchronization Width (in units of pixel clock period)
        constexpr uint32_t VSH = (11 << 0);  ///< Vertical Synchronization Height (in units of horizontal scan line)
    }

    /// BPCR Register bits
    namespace bpcr_bits {
        constexpr uint32_t AHBP = (12 << 16);  ///< Accumulated Horizontal back porch (in units of pixel clock period)
        constexpr uint32_t AVBP = (11 << 0);  ///< Accumulated Vertical back porch (in units of horizontal scan line)
    }

    /// AWCR Register bits
    namespace awcr_bits {
        constexpr uint32_t AAV = (12 << 16);  ///< AAV
        constexpr uint32_t AAH = (11 << 0);  ///< Accumulated Active Height (in units of horizontal scan line)
    }

    /// TWCR Register bits
    namespace twcr_bits {
        constexpr uint32_t TOTALW = (12 << 16);  ///< Total Width (in units of pixel clock period)
        constexpr uint32_t TOTALH = (11 << 0);  ///< Total Height (in units of horizontal scan line)
    }

    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t HSPOL = (1U << 31);  ///< Horizontal Synchronization Polarity
        constexpr uint32_t VSPOL = (1U << 30);  ///< Vertical Synchronization Polarity
        constexpr uint32_t DEPOL = (1U << 29);  ///< Data Enable Polarity
        constexpr uint32_t PCPOL = (1U << 28);  ///< Pixel Clock Polarity
        constexpr uint32_t DEN = (1U << 16);  ///< Dither Enable
        constexpr uint32_t DRW = (3 << 12);  ///< Dither Red Width
        constexpr uint32_t DGW = (3 << 8);  ///< Dither Green Width
        constexpr uint32_t DBW = (3 << 4);  ///< Dither Blue Width
        constexpr uint32_t LTDCEN = (1U << 0);  ///< LCD-TFT controller enable bit
    }

    /// SRCR Register bits
    namespace srcr_bits {
        constexpr uint32_t VBR = (1U << 1);  ///< Vertical Blanking Reload
        constexpr uint32_t IMR = (1U << 0);  ///< Immediate Reload
    }

    /// BCCR Register bits
    namespace bccr_bits {
        constexpr uint32_t BCBLUE = (8 << 0);  ///< Background Color Blue value
        constexpr uint32_t BCGREEN = (8 << 8);  ///< Background Color Green value
        constexpr uint32_t BCRED = (8 << 16);  ///< Background Color Red value
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t RRIE = (1U << 3);  ///< Register Reload interrupt enable
        constexpr uint32_t TERRIE = (1U << 2);  ///< Transfer Error Interrupt Enable
        constexpr uint32_t FUIE = (1U << 1);  ///< FIFO Underrun Interrupt Enable
        constexpr uint32_t LIE = (1U << 0);  ///< Line Interrupt Enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RRIF = (1U << 3);  ///< Register Reload Interrupt Flag
        constexpr uint32_t TERRIF = (1U << 2);  ///< Transfer Error interrupt flag
        constexpr uint32_t FUIF = (1U << 1);  ///< FIFO Underrun Interrupt flag
        constexpr uint32_t LIF = (1U << 0);  ///< Line Interrupt flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t CRRIF = (1U << 3);  ///< Clears Register Reload Interrupt Flag
        constexpr uint32_t CTERRIF = (1U << 2);  ///< Clears the Transfer Error Interrupt Flag
        constexpr uint32_t CFUIF = (1U << 1);  ///< Clears the FIFO Underrun Interrupt flag
        constexpr uint32_t CLIF = (1U << 0);  ///< Clears the Line Interrupt Flag
    }

    /// LIPCR Register bits
    namespace lipcr_bits {
        constexpr uint32_t LIPOS = (11 << 0);  ///< Line Interrupt Position
    }

    /// CPSR Register bits
    namespace cpsr_bits {
        constexpr uint32_t CXPOS = (16 << 16);  ///< Current X Position
        constexpr uint32_t CYPOS = (16 << 0);  ///< Current Y Position
    }

    /// CDSR Register bits
    namespace cdsr_bits {
        constexpr uint32_t HSYNCS = (1U << 3);  ///< Horizontal Synchronization display Status
        constexpr uint32_t VSYNCS = (1U << 2);  ///< Vertical Synchronization display Status
        constexpr uint32_t HDES = (1U << 1);  ///< Horizontal Data Enable display Status
        constexpr uint32_t VDES = (1U << 0);  ///< Vertical Data Enable display Status
    }

    /// L1CR Register bits
    namespace l1cr_bits {
        constexpr uint32_t CLUTEN = (1U << 4);  ///< Color Look-Up Table Enable
        constexpr uint32_t COLKEN = (1U << 1);  ///< Color Keying Enable
        constexpr uint32_t LEN = (1U << 0);  ///< Layer Enable
    }

    /// L1WHPCR Register bits
    namespace l1whpcr_bits {
        constexpr uint32_t WHSPPOS = (12 << 16);  ///< Window Horizontal Stop Position
        constexpr uint32_t WHSTPOS = (12 << 0);  ///< Window Horizontal Start Position
    }

    /// L1WVPCR Register bits
    namespace l1wvpcr_bits {
        constexpr uint32_t WVSPPOS = (11 << 16);  ///< Window Vertical Stop Position
        constexpr uint32_t WVSTPOS = (11 << 0);  ///< Window Vertical Start Position
    }

    /// L1CKCR Register bits
    namespace l1ckcr_bits {
        constexpr uint32_t CKRED = (8 << 16);  ///< Color Key Red value
        constexpr uint32_t CKGREEN = (8 << 8);  ///< Color Key Green value
        constexpr uint32_t CKBLUE = (8 << 0);  ///< Color Key Blue value
    }

    /// L1PFCR Register bits
    namespace l1pfcr_bits {
        constexpr uint32_t PF = (3 << 0);  ///< Pixel Format
    }

    /// L1CACR Register bits
    namespace l1cacr_bits {
        constexpr uint32_t CONSTA = (8 << 0);  ///< Constant Alpha
    }

    /// L1DCCR Register bits
    namespace l1dccr_bits {
        constexpr uint32_t DCALPHA = (8 << 24);  ///< Default Color Alpha
        constexpr uint32_t DCRED = (8 << 16);  ///< Default Color Red
        constexpr uint32_t DCGREEN = (8 << 8);  ///< Default Color Green
        constexpr uint32_t DCBLUE = (8 << 0);  ///< Default Color Blue
    }

    /// L1BFCR Register bits
    namespace l1bfcr_bits {
        constexpr uint32_t BF1 = (3 << 8);  ///< Blending Factor 1
        constexpr uint32_t BF2 = (3 << 0);  ///< Blending Factor 2
    }

    /// L1CFBAR Register bits
    namespace l1cfbar_bits {
        constexpr uint32_t CFBADD = (32 << 0);  ///< Color Frame Buffer Start Address
    }

    /// L1CFBLR Register bits
    namespace l1cfblr_bits {
        constexpr uint32_t CFBP = (13 << 16);  ///< Color Frame Buffer Pitch in bytes
        constexpr uint32_t CFBLL = (13 << 0);  ///< Color Frame Buffer Line Length
    }

    /// L1CFBLNR Register bits
    namespace l1cfblnr_bits {
        constexpr uint32_t CFBLNBR = (11 << 0);  ///< Frame Buffer Line Number
    }

    /// L1CLUTWR Register bits
    namespace l1clutwr_bits {
        constexpr uint32_t CLUTADD = (8 << 24);  ///< CLUT Address
        constexpr uint32_t RED = (8 << 16);  ///< Red value
        constexpr uint32_t GREEN = (8 << 8);  ///< Green value
        constexpr uint32_t BLUE = (8 << 0);  ///< Blue value
    }

    /// L2CR Register bits
    namespace l2cr_bits {
        constexpr uint32_t CLUTEN = (1U << 4);  ///< Color Look-Up Table Enable
        constexpr uint32_t COLKEN = (1U << 1);  ///< Color Keying Enable
        constexpr uint32_t LEN = (1U << 0);  ///< Layer Enable
    }

    /// L2WHPCR Register bits
    namespace l2whpcr_bits {
        constexpr uint32_t WHSPPOS = (12 << 16);  ///< Window Horizontal Stop Position
        constexpr uint32_t WHSTPOS = (12 << 0);  ///< Window Horizontal Start Position
    }

    /// L2WVPCR Register bits
    namespace l2wvpcr_bits {
        constexpr uint32_t WVSPPOS = (11 << 16);  ///< Window Vertical Stop Position
        constexpr uint32_t WVSTPOS = (11 << 0);  ///< Window Vertical Start Position
    }

    /// L2CKCR Register bits
    namespace l2ckcr_bits {
        constexpr uint32_t CKRED = (8 << 16);  ///< Color Key Red value
        constexpr uint32_t CKGREEN = (8 << 8);  ///< Color Key Green value
        constexpr uint32_t CKBLUE = (8 << 0);  ///< Color Key Blue value
    }

    /// L2PFCR Register bits
    namespace l2pfcr_bits {
        constexpr uint32_t PF = (3 << 0);  ///< Pixel Format
    }

    /// L2CACR Register bits
    namespace l2cacr_bits {
        constexpr uint32_t CONSTA = (8 << 0);  ///< Constant Alpha
    }

    /// L2DCCR Register bits
    namespace l2dccr_bits {
        constexpr uint32_t DCALPHA = (8 << 24);  ///< Default Color Alpha
        constexpr uint32_t DCRED = (8 << 16);  ///< Default Color Red
        constexpr uint32_t DCGREEN = (8 << 8);  ///< Default Color Green
        constexpr uint32_t DCBLUE = (8 << 0);  ///< Default Color Blue
    }

    /// L2BFCR Register bits
    namespace l2bfcr_bits {
        constexpr uint32_t BF1 = (3 << 8);  ///< Blending Factor 1
        constexpr uint32_t BF2 = (3 << 0);  ///< Blending Factor 2
    }

    /// L2CFBAR Register bits
    namespace l2cfbar_bits {
        constexpr uint32_t CFBADD = (32 << 0);  ///< Color Frame Buffer Start Address
    }

    /// L2CFBLR Register bits
    namespace l2cfblr_bits {
        constexpr uint32_t CFBP = (13 << 16);  ///< Color Frame Buffer Pitch in bytes
        constexpr uint32_t CFBLL = (13 << 0);  ///< Color Frame Buffer Line Length
    }

    /// L2CFBLNR Register bits
    namespace l2cfblnr_bits {
        constexpr uint32_t CFBLNBR = (11 << 0);  ///< Frame Buffer Line Number
    }

    /// L2CLUTWR Register bits
    namespace l2clutwr_bits {
        constexpr uint32_t CLUTADD = (8 << 24);  ///< CLUT Address
        constexpr uint32_t RED = (8 << 16);  ///< Red value
        constexpr uint32_t GREEN = (8 << 8);  ///< Green value
        constexpr uint32_t BLUE = (8 << 0);  ///< Blue value
    }

}

// ============================================================================
// SPDIFRX Peripheral
// ============================================================================

namespace spdifrx {
    /// Base addresses
    constexpr uint32_t SPDIFRX_BASE = 0x40004000;

    /// SPDIFRX Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control register
        volatile uint32_t IMR;  ///< Offset: 0x04 - Interrupt mask register
        volatile uint32_t SR;  ///< Offset: 0x08 - Status register
        volatile uint32_t IFCR;  ///< Offset: 0x0C - Interrupt Flag Clear register
        volatile uint32_t DR_00;  ///< Offset: 0x10 - Data input register
        volatile uint32_t CSR;  ///< Offset: 0x14 - Channel Status register
        volatile uint32_t DIR;  ///< Offset: 0x18 - Debug Information register
        volatile uint32_t VERR;  ///< Offset: 0x3F4 - SPDIFRX version register
        volatile uint32_t IDR;  ///< Offset: 0x3F8 - SPDIFRX identification register
        volatile uint32_t SIDR;  ///< Offset: 0x3FC - SPDIFRX size identification register
        volatile uint32_t DR_01;  ///< Offset: 0x10 - Data input register
        volatile uint32_t DR_10;  ///< Offset: 0x10 - Data input register
    };

    /// Peripheral instances
    inline Registers* SPDIFRX = reinterpret_cast<Registers*>(SPDIFRX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SPDIFRXEN = (2 << 0);  ///< Peripheral Block Enable
        constexpr uint32_t RXDMAEN = (1U << 2);  ///< Receiver DMA ENable for data flow
        constexpr uint32_t RXSTEO = (1U << 3);  ///< STerEO Mode
        constexpr uint32_t DRFMT = (2 << 4);  ///< RX Data format
        constexpr uint32_t PMSK = (1U << 6);  ///< Mask Parity error bit
        constexpr uint32_t VMSK = (1U << 7);  ///< Mask of Validity bit
        constexpr uint32_t CUMSK = (1U << 8);  ///< Mask of channel status and user bits
        constexpr uint32_t PTMSK = (1U << 9);  ///< Mask of Preamble Type bits
        constexpr uint32_t CBDMAEN = (1U << 10);  ///< Control Buffer DMA ENable for control flow
        constexpr uint32_t CHSEL = (1U << 11);  ///< Channel Selection
        constexpr uint32_t NBTR = (2 << 12);  ///< Maximum allowed re-tries during synchronization phase
        constexpr uint32_t WFA = (1U << 14);  ///< Wait For Activity
        constexpr uint32_t INSEL = (3 << 16);  ///< input selection
        constexpr uint32_t CKSEN = (1U << 20);  ///< Symbol Clock Enable
        constexpr uint32_t CKSBKPEN = (1U << 21);  ///< Backup Symbol Clock Enable
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t RXNEIE = (1U << 0);  ///< RXNE interrupt enable
        constexpr uint32_t CSRNEIE = (1U << 1);  ///< Control Buffer Ready Interrupt Enable
        constexpr uint32_t PERRIE = (1U << 2);  ///< Parity error interrupt enable
        constexpr uint32_t OVRIE = (1U << 3);  ///< Overrun error Interrupt Enable
        constexpr uint32_t SBLKIE = (1U << 4);  ///< Synchronization Block Detected Interrupt Enable
        constexpr uint32_t SYNCDIE = (1U << 5);  ///< Synchronization Done
        constexpr uint32_t IFEIE = (1U << 6);  ///< Serial Interface Error Interrupt Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Read data register not empty
        constexpr uint32_t CSRNE = (1U << 1);  ///< Control Buffer register is not empty
        constexpr uint32_t PERR = (1U << 2);  ///< Parity error
        constexpr uint32_t OVR = (1U << 3);  ///< Overrun error
        constexpr uint32_t SBD = (1U << 4);  ///< Synchronization Block Detected
        constexpr uint32_t SYNCD = (1U << 5);  ///< Synchronization Done
        constexpr uint32_t FERR = (1U << 6);  ///< Framing error
        constexpr uint32_t SERR = (1U << 7);  ///< Synchronization error
        constexpr uint32_t TERR = (1U << 8);  ///< Time-out error
        constexpr uint32_t WIDTH5 = (15 << 16);  ///< Duration of 5 symbols counted with SPDIF_CLK
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t PERRCF = (1U << 2);  ///< Clears the Parity error flag
        constexpr uint32_t OVRCF = (1U << 3);  ///< Clears the Overrun error flag
        constexpr uint32_t SBDCF = (1U << 4);  ///< Clears the Synchronization Block Detected flag
        constexpr uint32_t SYNCDCF = (1U << 5);  ///< Clears the Synchronization Done flag
    }

    /// DR_00 Register bits
    namespace dr_00_bits {
        constexpr uint32_t DR = (24 << 0);  ///< Parity Error bit
        constexpr uint32_t PE = (1U << 24);  ///< Parity Error bit
        constexpr uint32_t V = (1U << 25);  ///< Validity bit
        constexpr uint32_t U = (1U << 26);  ///< User bit
        constexpr uint32_t C = (1U << 27);  ///< Channel Status bit
        constexpr uint32_t PT = (2 << 28);  ///< Preamble Type
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t USR = (16 << 0);  ///< User data information
        constexpr uint32_t CS = (8 << 16);  ///< Channel A status information
        constexpr uint32_t SOB = (1U << 24);  ///< Start Of Block
    }

    /// DIR Register bits
    namespace dir_bits {
        constexpr uint32_t THI = (13 << 0);  ///< Threshold HIGH
        constexpr uint32_t TLO = (13 << 16);  ///< Threshold LOW
    }

    /// VERR Register bits
    namespace verr_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< Minor revision
        constexpr uint32_t MAJREV = (4 << 4);  ///< Major revision
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t ID = (32 << 0);  ///< SPDIFRX identifier
    }

    /// SIDR Register bits
    namespace sidr_bits {
        constexpr uint32_t SID = (32 << 0);  ///< Size identification
    }

    /// DR_01 Register bits
    namespace dr_01_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity Error bit
        constexpr uint32_t V = (1U << 1);  ///< Validity bit
        constexpr uint32_t U = (1U << 2);  ///< User bit
        constexpr uint32_t C = (1U << 3);  ///< Channel Status bit
        constexpr uint32_t PT = (2 << 4);  ///< Preamble Type
        constexpr uint32_t DR = (24 << 8);  ///< Data value
    }

    /// DR_10 Register bits
    namespace dr_10_bits {
        constexpr uint32_t DRNL1 = (16 << 0);  ///< Data value
        constexpr uint32_t DRNL2 = (16 << 16);  ///< Data value
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC3_BASE = 0x58026000;
    constexpr uint32_t ADC1_BASE = 0x40022000;
    constexpr uint32_t ADC2_BASE = 0x40022100;
    constexpr uint32_t ADC3_Common_BASE = 0x58026300;
    constexpr uint32_t ADC12_Common_BASE = 0x40022300;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t CFGR;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t SMPR1;  ///< Offset: 0x14 - ADC sampling time register 1
        volatile uint32_t SMPR2;  ///< Offset: 0x18 - ADC sampling time register 2
        volatile uint32_t LTR1;  ///< Offset: 0x20 - ADC analog watchdog 1 threshold register
        volatile uint32_t LHTR1;  ///< Offset: 0x24 - ADC analog watchdog 2 threshold register
        volatile uint32_t SQR1;  ///< Offset: 0x30 - ADC group regular sequencer ranks register 1
        volatile uint32_t SQR2;  ///< Offset: 0x34 - ADC group regular sequencer ranks register 2
        volatile uint32_t SQR3;  ///< Offset: 0x38 - ADC group regular sequencer ranks register 3
        volatile uint32_t SQR4;  ///< Offset: 0x3C - ADC group regular sequencer ranks register 4
        volatile uint32_t DR;  ///< Offset: 0x40 - ADC group regular conversion data register
        volatile uint32_t JSQR;  ///< Offset: 0x4C - ADC group injected sequencer register
        volatile uint32_t OFR1;  ///< Offset: 0x60 - ADC offset number 1 register
        volatile uint32_t OFR2;  ///< Offset: 0x64 - ADC offset number 2 register
        volatile uint32_t OFR3;  ///< Offset: 0x68 - ADC offset number 3 register
        volatile uint32_t OFR4;  ///< Offset: 0x6C - ADC offset number 4 register
        volatile uint32_t JDR1;  ///< Offset: 0x80 - ADC group injected sequencer rank 1 register
        volatile uint32_t JDR2;  ///< Offset: 0x84 - ADC group injected sequencer rank 2 register
        volatile uint32_t JDR3;  ///< Offset: 0x88 - ADC group injected sequencer rank 3 register
        volatile uint32_t JDR4;  ///< Offset: 0x8C - ADC group injected sequencer rank 4 register
        volatile uint32_t AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t AWD3CR;  ///< Offset: 0xA4 - ADC analog watchdog 3 configuration register
        volatile uint32_t DIFSEL;  ///< Offset: 0xC0 - ADC channel differential or single-ended mode selection register
        volatile uint32_t CALFACT;  ///< Offset: 0xC4 - ADC calibration factors register
        volatile uint32_t PCSEL;  ///< Offset: 0x1C - ADC pre channel selection register
        volatile uint32_t LTR2;  ///< Offset: 0xB0 - ADC watchdog lower threshold register 2
        volatile uint32_t HTR2;  ///< Offset: 0xB4 - ADC watchdog higher threshold register 2
        volatile uint32_t LTR3;  ///< Offset: 0xB8 - ADC watchdog lower threshold register 3
        volatile uint32_t HTR3;  ///< Offset: 0xBC - ADC watchdog higher threshold register 3
        volatile uint32_t CALFACT2;  ///< Offset: 0xC8 - ADC Calibration Factor register 2
    };

    /// Peripheral instances
    inline Registers* ADC3 = reinterpret_cast<Registers*>(ADC3_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* ADC3_Common = reinterpret_cast<Registers*>(ADC3_Common_BASE);
    inline Registers* ADC12_Common = reinterpret_cast<Registers*>(ADC12_Common_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t JQOVF = (1U << 10);  ///< ADC group injected contexts queue overflow flag
        constexpr uint32_t AWD3 = (1U << 9);  ///< ADC analog watchdog 3 flag
        constexpr uint32_t AWD2 = (1U << 8);  ///< ADC analog watchdog 2 flag
        constexpr uint32_t AWD1 = (1U << 7);  ///< ADC analog watchdog 1 flag
        constexpr uint32_t JEOS = (1U << 6);  ///< ADC group injected end of sequence conversions flag
        constexpr uint32_t JEOC = (1U << 5);  ///< ADC group injected end of unitary conversion flag
        constexpr uint32_t OVR = (1U << 4);  ///< ADC group regular overrun flag
        constexpr uint32_t EOS = (1U << 3);  ///< ADC group regular end of sequence conversions flag
        constexpr uint32_t EOC = (1U << 2);  ///< ADC group regular end of unitary conversion flag
        constexpr uint32_t EOSMP = (1U << 1);  ///< ADC group regular end of sampling flag
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t JQOVFIE = (1U << 10);  ///< ADC group injected contexts queue overflow interrupt
        constexpr uint32_t AWD3IE = (1U << 9);  ///< ADC analog watchdog 3 interrupt
        constexpr uint32_t AWD2IE = (1U << 8);  ///< ADC analog watchdog 2 interrupt
        constexpr uint32_t AWD1IE = (1U << 7);  ///< ADC analog watchdog 1 interrupt
        constexpr uint32_t JEOSIE = (1U << 6);  ///< ADC group injected end of sequence conversions interrupt
        constexpr uint32_t JEOCIE = (1U << 5);  ///< ADC group injected end of unitary conversion interrupt
        constexpr uint32_t OVRIE = (1U << 4);  ///< ADC group regular overrun interrupt
        constexpr uint32_t EOSIE = (1U << 3);  ///< ADC group regular end of sequence conversions interrupt
        constexpr uint32_t EOCIE = (1U << 2);  ///< ADC group regular end of unitary conversion interrupt
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< ADC group regular end of sampling interrupt
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration
        constexpr uint32_t ADCALDIF = (1U << 30);  ///< ADC differential mode for calibration
        constexpr uint32_t DEEPPWD = (1U << 29);  ///< ADC deep power down enable
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC voltage regulator enable
        constexpr uint32_t LINCALRDYW6 = (1U << 27);  ///< Linearity calibration ready Word 6
        constexpr uint32_t LINCALRDYW5 = (1U << 26);  ///< Linearity calibration ready Word 5
        constexpr uint32_t LINCALRDYW4 = (1U << 25);  ///< Linearity calibration ready Word 4
        constexpr uint32_t LINCALRDYW3 = (1U << 24);  ///< Linearity calibration ready Word 3
        constexpr uint32_t LINCALRDYW2 = (1U << 23);  ///< Linearity calibration ready Word 2
        constexpr uint32_t LINCALRDYW1 = (1U << 22);  ///< Linearity calibration ready Word 1
        constexpr uint32_t ADCALLIN = (1U << 16);  ///< Linearity calibration
        constexpr uint32_t BOOST = (1U << 8);  ///< Boost mode control
        constexpr uint32_t JADSTP = (1U << 5);  ///< ADC group injected conversion stop
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC group regular conversion stop
        constexpr uint32_t JADSTART = (1U << 3);  ///< ADC group injected conversion start
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC group regular conversion start
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t JQDIS = (1U << 31);  ///< ADC group injected contexts queue disable
        constexpr uint32_t AWDCH1CH = (5 << 26);  ///< ADC analog watchdog 1 monitored channel selection
        constexpr uint32_t JAUTO = (1U << 25);  ///< ADC group injected automatic trigger mode
        constexpr uint32_t JAWD1EN = (1U << 24);  ///< ADC analog watchdog 1 enable on scope ADC group injected
        constexpr uint32_t AWD1EN = (1U << 23);  ///< ADC analog watchdog 1 enable on scope ADC group regular
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< ADC analog watchdog 1 monitoring a single channel or all channels
        constexpr uint32_t JQM = (1U << 21);  ///< ADC group injected contexts queue mode
        constexpr uint32_t JDISCEN = (1U << 20);  ///< ADC group injected sequencer discontinuous mode
        constexpr uint32_t DISCNUM = (3 << 17);  ///< ADC group regular sequencer discontinuous number of ranks
        constexpr uint32_t DISCEN = (1U << 16);  ///< ADC group regular sequencer discontinuous mode
        constexpr uint32_t AUTDLY = (1U << 14);  ///< ADC low power auto wait
        constexpr uint32_t CONT = (1U << 13);  ///< ADC group regular continuous conversion mode
        constexpr uint32_t OVRMOD = (1U << 12);  ///< ADC group regular overrun configuration
        constexpr uint32_t EXTEN = (2 << 10);  ///< ADC group regular external trigger polarity
        constexpr uint32_t EXTSEL = (5 << 5);  ///< ADC group regular external trigger source
        constexpr uint32_t RES = (3 << 2);  ///< ADC data resolution
        constexpr uint32_t DMNGT = (2 << 0);  ///< ADC DMA transfer enable
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t ROVSE = (1U << 0);  ///< ADC oversampler enable on scope ADC group regular
        constexpr uint32_t JOVSE = (1U << 1);  ///< ADC oversampler enable on scope ADC group injected
        constexpr uint32_t OVSS = (4 << 5);  ///< ADC oversampling shift
        constexpr uint32_t TROVS = (1U << 9);  ///< ADC oversampling discontinuous mode (triggered mode) for ADC group regular
        constexpr uint32_t ROVSM = (1U << 10);  ///< Regular Oversampling mode
        constexpr uint32_t RSHIFT1 = (1U << 11);  ///< Right-shift data after Offset 1 correction
        constexpr uint32_t RSHIFT2 = (1U << 12);  ///< Right-shift data after Offset 2 correction
        constexpr uint32_t RSHIFT3 = (1U << 13);  ///< Right-shift data after Offset 3 correction
        constexpr uint32_t RSHIFT4 = (1U << 14);  ///< Right-shift data after Offset 4 correction
        constexpr uint32_t OSR = (10 << 16);  ///< Oversampling ratio
        constexpr uint32_t LSHIFT = (4 << 28);  ///< Left shift factor
    }

    /// SMPR1 Register bits
    namespace smpr1_bits {
        constexpr uint32_t SMP9 = (3 << 27);  ///< ADC channel 9 sampling time selection
        constexpr uint32_t SMP8 = (3 << 24);  ///< ADC channel 8 sampling time selection
        constexpr uint32_t SMP7 = (3 << 21);  ///< ADC channel 7 sampling time selection
        constexpr uint32_t SMP6 = (3 << 18);  ///< ADC channel 6 sampling time selection
        constexpr uint32_t SMP5 = (3 << 15);  ///< ADC channel 5 sampling time selection
        constexpr uint32_t SMP4 = (3 << 12);  ///< ADC channel 4 sampling time selection
        constexpr uint32_t SMP3 = (3 << 9);  ///< ADC channel 3 sampling time selection
        constexpr uint32_t SMP2 = (3 << 6);  ///< ADC channel 2 sampling time selection
        constexpr uint32_t SMP1 = (3 << 3);  ///< ADC channel 1 sampling time selection
    }

    /// SMPR2 Register bits
    namespace smpr2_bits {
        constexpr uint32_t SMP19 = (3 << 27);  ///< ADC channel 18 sampling time selection
        constexpr uint32_t SMP18 = (3 << 24);  ///< ADC channel 18 sampling time selection
        constexpr uint32_t SMP17 = (3 << 21);  ///< ADC channel 17 sampling time selection
        constexpr uint32_t SMP16 = (3 << 18);  ///< ADC channel 16 sampling time selection
        constexpr uint32_t SMP15 = (3 << 15);  ///< ADC channel 15 sampling time selection
        constexpr uint32_t SMP14 = (3 << 12);  ///< ADC channel 14 sampling time selection
        constexpr uint32_t SMP13 = (3 << 9);  ///< ADC channel 13 sampling time selection
        constexpr uint32_t SMP12 = (3 << 6);  ///< ADC channel 12 sampling time selection
        constexpr uint32_t SMP11 = (3 << 3);  ///< ADC channel 11 sampling time selection
        constexpr uint32_t SMP10 = (3 << 0);  ///< ADC channel 10 sampling time selection
    }

    /// LTR1 Register bits
    namespace ltr1_bits {
        constexpr uint32_t LTR1 = (26 << 0);  ///< ADC analog watchdog 1 threshold low
    }

    /// LHTR1 Register bits
    namespace lhtr1_bits {
        constexpr uint32_t LHTR1 = (26 << 0);  ///< ADC analog watchdog 2 threshold low
    }

    /// SQR1 Register bits
    namespace sqr1_bits {
        constexpr uint32_t SQ4 = (5 << 24);  ///< ADC group regular sequencer rank 4
        constexpr uint32_t SQ3 = (5 << 18);  ///< ADC group regular sequencer rank 3
        constexpr uint32_t SQ2 = (5 << 12);  ///< ADC group regular sequencer rank 2
        constexpr uint32_t SQ1 = (5 << 6);  ///< ADC group regular sequencer rank 1
        constexpr uint32_t L3 = (4 << 0);  ///< L3
    }

    /// SQR2 Register bits
    namespace sqr2_bits {
        constexpr uint32_t SQ9 = (5 << 24);  ///< ADC group regular sequencer rank 9
        constexpr uint32_t SQ8 = (5 << 18);  ///< ADC group regular sequencer rank 8
        constexpr uint32_t SQ7 = (5 << 12);  ///< ADC group regular sequencer rank 7
        constexpr uint32_t SQ6 = (5 << 6);  ///< ADC group regular sequencer rank 6
        constexpr uint32_t SQ5 = (5 << 0);  ///< ADC group regular sequencer rank 5
    }

    /// SQR3 Register bits
    namespace sqr3_bits {
        constexpr uint32_t SQ14 = (5 << 24);  ///< ADC group regular sequencer rank 14
        constexpr uint32_t SQ13 = (5 << 18);  ///< ADC group regular sequencer rank 13
        constexpr uint32_t SQ12 = (5 << 12);  ///< ADC group regular sequencer rank 12
        constexpr uint32_t SQ11 = (5 << 6);  ///< ADC group regular sequencer rank 11
        constexpr uint32_t SQ10 = (5 << 0);  ///< ADC group regular sequencer rank 10
    }

    /// SQR4 Register bits
    namespace sqr4_bits {
        constexpr uint32_t SQ16 = (5 << 6);  ///< ADC group regular sequencer rank 16
        constexpr uint32_t SQ15 = (5 << 0);  ///< ADC group regular sequencer rank 15
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< ADC group regular conversion data
    }

    /// JSQR Register bits
    namespace jsqr_bits {
        constexpr uint32_t JSQ4 = (5 << 27);  ///< ADC group injected sequencer rank 4
        constexpr uint32_t JSQ3 = (5 << 21);  ///< ADC group injected sequencer rank 3
        constexpr uint32_t JSQ2 = (5 << 15);  ///< ADC group injected sequencer rank 2
        constexpr uint32_t JSQ1 = (5 << 9);  ///< ADC group injected sequencer rank 1
        constexpr uint32_t JEXTEN = (2 << 7);  ///< ADC group injected external trigger polarity
        constexpr uint32_t JEXTSEL = (5 << 2);  ///< ADC group injected external trigger source
        constexpr uint32_t JL = (2 << 0);  ///< ADC group injected sequencer scan length
    }

    /// OFR1 Register bits
    namespace ofr1_bits {
        constexpr uint32_t SSATE = (1U << 31);  ///< ADC offset number 1 enable
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< ADC offset number 1 channel selection
        constexpr uint32_t OFFSET1 = (26 << 0);  ///< ADC offset number 1 offset level
    }

    /// OFR2 Register bits
    namespace ofr2_bits {
        constexpr uint32_t SSATE = (1U << 31);  ///< ADC offset number 1 enable
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< ADC offset number 1 channel selection
        constexpr uint32_t OFFSET1 = (26 << 0);  ///< ADC offset number 1 offset level
    }

    /// OFR3 Register bits
    namespace ofr3_bits {
        constexpr uint32_t SSATE = (1U << 31);  ///< ADC offset number 1 enable
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< ADC offset number 1 channel selection
        constexpr uint32_t OFFSET1 = (26 << 0);  ///< ADC offset number 1 offset level
    }

    /// OFR4 Register bits
    namespace ofr4_bits {
        constexpr uint32_t SSATE = (1U << 31);  ///< ADC offset number 1 enable
        constexpr uint32_t OFFSET1_CH = (5 << 26);  ///< ADC offset number 1 channel selection
        constexpr uint32_t OFFSET1 = (26 << 0);  ///< ADC offset number 1 offset level
    }

    /// JDR1 Register bits
    namespace jdr1_bits {
        constexpr uint32_t JDATA1 = (32 << 0);  ///< ADC group injected sequencer rank 1 conversion data
    }

    /// JDR2 Register bits
    namespace jdr2_bits {
        constexpr uint32_t JDATA2 = (32 << 0);  ///< ADC group injected sequencer rank 2 conversion data
    }

    /// JDR3 Register bits
    namespace jdr3_bits {
        constexpr uint32_t JDATA3 = (32 << 0);  ///< ADC group injected sequencer rank 3 conversion data
    }

    /// JDR4 Register bits
    namespace jdr4_bits {
        constexpr uint32_t JDATA4 = (32 << 0);  ///< ADC group injected sequencer rank 4 conversion data
    }

    /// AWD2CR Register bits
    namespace awd2cr_bits {
        constexpr uint32_t AWD2CH = (20 << 0);  ///< ADC analog watchdog 2 monitored channel selection
    }

    /// AWD3CR Register bits
    namespace awd3cr_bits {
        constexpr uint32_t AWD3CH = (20 << 1);  ///< ADC analog watchdog 3 monitored channel selection
    }

    /// DIFSEL Register bits
    namespace difsel_bits {
        constexpr uint32_t DIFSEL = (20 << 0);  ///< ADC channel differential or single-ended mode for channel
    }

    /// CALFACT Register bits
    namespace calfact_bits {
        constexpr uint32_t CALFACT_D = (11 << 16);  ///< ADC calibration factor in differential mode
        constexpr uint32_t CALFACT_S = (11 << 0);  ///< ADC calibration factor in single-ended mode
    }

    /// PCSEL Register bits
    namespace pcsel_bits {
        constexpr uint32_t PCSEL = (20 << 0);  ///< Channel x (VINP[i]) pre selection
    }

    /// LTR2 Register bits
    namespace ltr2_bits {
        constexpr uint32_t LTR2 = (26 << 0);  ///< Analog watchdog 2 lower threshold
    }

    /// HTR2 Register bits
    namespace htr2_bits {
        constexpr uint32_t HTR2 = (26 << 0);  ///< Analog watchdog 2 higher threshold
    }

    /// LTR3 Register bits
    namespace ltr3_bits {
        constexpr uint32_t LTR3 = (26 << 0);  ///< Analog watchdog 3 lower threshold
    }

    /// HTR3 Register bits
    namespace htr3_bits {
        constexpr uint32_t HTR3 = (26 << 0);  ///< Analog watchdog 3 higher threshold
    }

    /// CALFACT2 Register bits
    namespace calfact2_bits {
        constexpr uint32_t LINCALFACT = (30 << 0);  ///< Linearity Calibration Factor
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x58024C00;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent Data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x0C - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x10 - CRC polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data Register
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< Independent Data register
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x58024400;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - RCC Internal Clock Source Calibration Register
        volatile uint32_t CRRCR;  ///< Offset: 0x08 - RCC Clock Recovery RC Register
        volatile uint32_t CFGR;  ///< Offset: 0x10 - RCC Clock Configuration Register
        volatile uint32_t D1CFGR;  ///< Offset: 0x18 - RCC Domain 1 Clock Configuration Register
        volatile uint32_t D2CFGR;  ///< Offset: 0x1C - RCC Domain 2 Clock Configuration Register
        volatile uint32_t D3CFGR;  ///< Offset: 0x20 - RCC Domain 3 Clock Configuration Register
        volatile uint32_t PLLCKSELR;  ///< Offset: 0x28 - RCC PLLs Clock Source Selection Register
        volatile uint32_t PLLCFGR;  ///< Offset: 0x2C - RCC PLLs Configuration Register
        volatile uint32_t PLL1DIVR;  ///< Offset: 0x30 - RCC PLL1 Dividers Configuration Register
        volatile uint32_t PLL1FRACR;  ///< Offset: 0x34 - RCC PLL1 Fractional Divider Register
        volatile uint32_t PLL2DIVR;  ///< Offset: 0x38 - RCC PLL2 Dividers Configuration Register
        volatile uint32_t PLL2FRACR;  ///< Offset: 0x3C - RCC PLL2 Fractional Divider Register
        volatile uint32_t PLL3DIVR;  ///< Offset: 0x40 - RCC PLL3 Dividers Configuration Register
        volatile uint32_t PLL3FRACR;  ///< Offset: 0x44 - RCC PLL3 Fractional Divider Register
        volatile uint32_t D1CCIPR;  ///< Offset: 0x4C - RCC Domain 1 Kernel Clock Configuration Register
        volatile uint32_t D2CCIP1R;  ///< Offset: 0x50 - RCC Domain 2 Kernel Clock Configuration Register
        volatile uint32_t D2CCIP2R;  ///< Offset: 0x54 - RCC Domain 2 Kernel Clock Configuration Register
        volatile uint32_t D3CCIPR;  ///< Offset: 0x58 - RCC Domain 3 Kernel Clock Configuration Register
        volatile uint32_t CIER;  ///< Offset: 0x60 - RCC Clock Source Interrupt Enable Register
        volatile uint32_t CIFR;  ///< Offset: 0x64 - RCC Clock Source Interrupt Flag Register
        volatile uint32_t CICR;  ///< Offset: 0x68 - RCC Clock Source Interrupt Clear Register
        volatile uint32_t BDCR;  ///< Offset: 0x70 - RCC Backup Domain Control Register
        volatile uint32_t CSR;  ///< Offset: 0x74 - RCC Clock Control and Status Register
        volatile uint32_t AHB3RSTR;  ///< Offset: 0x7C - RCC AHB3 Reset Register
        volatile uint32_t AHB1RSTR;  ///< Offset: 0x80 - RCC AHB1 Peripheral Reset Register
        volatile uint32_t AHB2RSTR;  ///< Offset: 0x84 - RCC AHB2 Peripheral Reset Register
        volatile uint32_t AHB4RSTR;  ///< Offset: 0x88 - RCC AHB4 Peripheral Reset Register
        volatile uint32_t APB3RSTR;  ///< Offset: 0x8C - RCC APB3 Peripheral Reset Register
        volatile uint32_t APB1LRSTR;  ///< Offset: 0x90 - RCC APB1 Peripheral Reset Register
        volatile uint32_t APB1HRSTR;  ///< Offset: 0x94 - RCC APB1 Peripheral Reset Register
        volatile uint32_t APB2RSTR;  ///< Offset: 0x98 - RCC APB2 Peripheral Reset Register
        volatile uint32_t APB4RSTR;  ///< Offset: 0x9C - RCC APB4 Peripheral Reset Register
        volatile uint32_t GCR;  ///< Offset: 0xA0 - RCC Global Control Register
        volatile uint32_t D3AMR;  ///< Offset: 0xA8 - RCC D3 Autonomous mode Register
        volatile uint32_t RSR;  ///< Offset: 0xD0 - RCC Reset Status Register
        volatile uint32_t C1_RSR;  ///< Offset: 0x130 - RCC Reset Status Register
        volatile uint32_t C1_AHB3ENR;  ///< Offset: 0x134 - RCC AHB3 Clock Register
        volatile uint32_t AHB3ENR;  ///< Offset: 0xD4 - RCC AHB3 Clock Register
        volatile uint32_t AHB1ENR;  ///< Offset: 0xD8 - RCC AHB1 Clock Register
        volatile uint32_t C1_AHB1ENR;  ///< Offset: 0x138 - RCC AHB1 Clock Register
        volatile uint32_t C1_AHB2ENR;  ///< Offset: 0x13C - RCC AHB2 Clock Register
        volatile uint32_t AHB2ENR;  ///< Offset: 0xDC - RCC AHB2 Clock Register
        volatile uint32_t AHB4ENR;  ///< Offset: 0xE0 - RCC AHB4 Clock Register
        volatile uint32_t C1_AHB4ENR;  ///< Offset: 0x140 - RCC AHB4 Clock Register
        volatile uint32_t C1_APB3ENR;  ///< Offset: 0x144 - RCC APB3 Clock Register
        volatile uint32_t APB3ENR;  ///< Offset: 0xE4 - RCC APB3 Clock Register
        volatile uint32_t APB1LENR;  ///< Offset: 0xE8 - RCC APB1 Clock Register
        volatile uint32_t C1_APB1LENR;  ///< Offset: 0x148 - RCC APB1 Clock Register
        volatile uint32_t APB1HENR;  ///< Offset: 0xEC - RCC APB1 Clock Register
        volatile uint32_t C1_APB1HENR;  ///< Offset: 0x14C - RCC APB1 Clock Register
        volatile uint32_t C1_APB2ENR;  ///< Offset: 0x150 - RCC APB2 Clock Register
        volatile uint32_t APB2ENR;  ///< Offset: 0xF0 - RCC APB2 Clock Register
        volatile uint32_t APB4ENR;  ///< Offset: 0xF4 - RCC APB4 Clock Register
        volatile uint32_t C1_APB4ENR;  ///< Offset: 0x154 - RCC APB4 Clock Register
        volatile uint32_t C1_AHB3LPENR;  ///< Offset: 0x15C - RCC AHB3 Sleep Clock Register
        volatile uint32_t AHB3LPENR;  ///< Offset: 0xFC - RCC AHB3 Sleep Clock Register
        volatile uint32_t AHB1LPENR;  ///< Offset: 0x100 - RCC AHB1 Sleep Clock Register
        volatile uint32_t C1_AHB1LPENR;  ///< Offset: 0x160 - RCC AHB1 Sleep Clock Register
        volatile uint32_t C1_AHB2LPENR;  ///< Offset: 0x164 - RCC AHB2 Sleep Clock Register
        volatile uint32_t AHB2LPENR;  ///< Offset: 0x104 - RCC AHB2 Sleep Clock Register
        volatile uint32_t AHB4LPENR;  ///< Offset: 0x108 - RCC AHB4 Sleep Clock Register
        volatile uint32_t C1_AHB4LPENR;  ///< Offset: 0x168 - RCC AHB4 Sleep Clock Register
        volatile uint32_t C1_APB3LPENR;  ///< Offset: 0x16C - RCC APB3 Sleep Clock Register
        volatile uint32_t APB3LPENR;  ///< Offset: 0x10C - RCC APB3 Sleep Clock Register
        volatile uint32_t APB1LLPENR;  ///< Offset: 0x110 - RCC APB1 Low Sleep Clock Register
        volatile uint32_t C1_APB1LLPENR;  ///< Offset: 0x170 - RCC APB1 Low Sleep Clock Register
        volatile uint32_t C1_APB1HLPENR;  ///< Offset: 0x174 - RCC APB1 High Sleep Clock Register
        volatile uint32_t APB1HLPENR;  ///< Offset: 0x114 - RCC APB1 High Sleep Clock Register
        volatile uint32_t APB2LPENR;  ///< Offset: 0x118 - RCC APB2 Sleep Clock Register
        volatile uint32_t C1_APB2LPENR;  ///< Offset: 0x178 - RCC APB2 Sleep Clock Register
        volatile uint32_t C1_APB4LPENR;  ///< Offset: 0x17C - RCC APB4 Sleep Clock Register
        volatile uint32_t APB4LPENR;  ///< Offset: 0x11C - RCC APB4 Sleep Clock Register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t HSION = (1U << 0);  ///< Internal high-speed clock enable
        constexpr uint32_t HSIKERON = (1U << 1);  ///< High Speed Internal clock enable in Stop mode
        constexpr uint32_t HSIRDY = (1U << 2);  ///< HSI clock ready flag
        constexpr uint32_t HSIDIV = (2 << 3);  ///< HSI clock divider
        constexpr uint32_t HSIDIVF = (1U << 5);  ///< HSI divider flag
        constexpr uint32_t CSION = (1U << 7);  ///< CSI clock enable
        constexpr uint32_t CSIRDY = (1U << 8);  ///< CSI clock ready flag
        constexpr uint32_t CSIKERON = (1U << 9);  ///< CSI clock enable in Stop mode
        constexpr uint32_t RC48ON = (1U << 12);  ///< RC48 clock enable
        constexpr uint32_t RC48RDY = (1U << 13);  ///< RC48 clock ready flag
        constexpr uint32_t D1CKRDY = (1U << 14);  ///< D1 domain clocks ready flag
        constexpr uint32_t D2CKRDY = (1U << 15);  ///< D2 domain clocks ready flag
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE clock bypass
        constexpr uint32_t HSECSSON = (1U << 19);  ///< HSE Clock Security System enable
        constexpr uint32_t PLL1ON = (1U << 24);  ///< PLL1 enable
        constexpr uint32_t PLL1RDY = (1U << 25);  ///< PLL1 clock ready flag
        constexpr uint32_t PLL2ON = (1U << 26);  ///< PLL2 enable
        constexpr uint32_t PLL2RDY = (1U << 27);  ///< PLL2 clock ready flag
        constexpr uint32_t PLL3ON = (1U << 28);  ///< PLL3 enable
        constexpr uint32_t PLL3RDY = (1U << 29);  ///< PLL3 clock ready flag
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t HSICAL = (12 << 0);  ///< HSI clock calibration
        constexpr uint32_t HSITRIM = (6 << 12);  ///< HSI clock trimming
        constexpr uint32_t CSICAL = (8 << 18);  ///< CSI clock calibration
        constexpr uint32_t CSITRIM = (5 << 26);  ///< CSI clock trimming
    }

    /// CRRCR Register bits
    namespace crrcr_bits {
        constexpr uint32_t RC48CAL = (10 << 0);  ///< Internal RC 48 MHz clock calibration
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SW = (3 << 0);  ///< System clock switch
        constexpr uint32_t SWS = (3 << 3);  ///< System clock switch status
        constexpr uint32_t STOPWUCK = (1U << 6);  ///< System clock selection after a wake up from system Stop
        constexpr uint32_t STOPKERWUCK = (1U << 7);  ///< Kernel clock selection after a wake up from system Stop
        constexpr uint32_t RTCPRE = (6 << 8);  ///< HSE division factor for RTC clock
        constexpr uint32_t HRTIMSEL = (1U << 14);  ///< High Resolution Timer clock prescaler selection
        constexpr uint32_t TIMPRE = (1U << 15);  ///< Timers clocks prescaler selection
        constexpr uint32_t MCO1PRE = (4 << 18);  ///< MCO1 prescaler
        constexpr uint32_t MCO1SEL = (3 << 22);  ///< Micro-controller clock output 1
        constexpr uint32_t MCO2PRE = (4 << 25);  ///< MCO2 prescaler
        constexpr uint32_t MCO2SEL = (3 << 29);  ///< Micro-controller clock output 2
    }

    /// D1CFGR Register bits
    namespace d1cfgr_bits {
        constexpr uint32_t HPRE = (4 << 0);  ///< D1 domain AHB prescaler
        constexpr uint32_t D1PPRE = (3 << 4);  ///< D1 domain APB3 prescaler
        constexpr uint32_t D1CPRE = (4 << 8);  ///< D1 domain Core prescaler
    }

    /// D2CFGR Register bits
    namespace d2cfgr_bits {
        constexpr uint32_t D2PPRE1 = (3 << 4);  ///< D2 domain APB1 prescaler
        constexpr uint32_t D2PPRE2 = (3 << 8);  ///< D2 domain APB2 prescaler
    }

    /// D3CFGR Register bits
    namespace d3cfgr_bits {
        constexpr uint32_t D3PPRE = (3 << 4);  ///< D3 domain APB4 prescaler
    }

    /// PLLCKSELR Register bits
    namespace pllckselr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< DIVMx and PLLs clock source selection
        constexpr uint32_t DIVM1 = (6 << 4);  ///< Prescaler for PLL1
        constexpr uint32_t DIVM2 = (6 << 12);  ///< Prescaler for PLL2
        constexpr uint32_t DIVM3 = (6 << 20);  ///< Prescaler for PLL3
    }

    /// PLLCFGR Register bits
    namespace pllcfgr_bits {
        constexpr uint32_t PLL1FRACEN = (1U << 0);  ///< PLL1 fractional latch enable
        constexpr uint32_t PLL1VCOSEL = (1U << 1);  ///< PLL1 VCO selection
        constexpr uint32_t PLL1RGE = (2 << 2);  ///< PLL1 input frequency range
        constexpr uint32_t PLL2FRACEN = (1U << 4);  ///< PLL2 fractional latch enable
        constexpr uint32_t PLL2VCOSEL = (1U << 5);  ///< PLL2 VCO selection
        constexpr uint32_t PLL2RGE = (2 << 6);  ///< PLL2 input frequency range
        constexpr uint32_t PLL3FRACEN = (1U << 8);  ///< PLL3 fractional latch enable
        constexpr uint32_t PLL3VCOSEL = (1U << 9);  ///< PLL3 VCO selection
        constexpr uint32_t PLL3RGE = (2 << 10);  ///< PLL3 input frequency range
        constexpr uint32_t DIVP1EN = (1U << 16);  ///< PLL1 DIVP divider output enable
        constexpr uint32_t DIVQ1EN = (1U << 17);  ///< PLL1 DIVQ divider output enable
        constexpr uint32_t DIVR1EN = (1U << 18);  ///< PLL1 DIVR divider output enable
        constexpr uint32_t DIVP2EN = (1U << 19);  ///< PLL2 DIVP divider output enable
        constexpr uint32_t DIVQ2EN = (1U << 20);  ///< PLL2 DIVQ divider output enable
        constexpr uint32_t DIVR2EN = (1U << 21);  ///< PLL2 DIVR divider output enable
        constexpr uint32_t DIVP3EN = (1U << 22);  ///< PLL3 DIVP divider output enable
        constexpr uint32_t DIVQ3EN = (1U << 23);  ///< PLL3 DIVQ divider output enable
        constexpr uint32_t DIVR3EN = (1U << 24);  ///< PLL3 DIVR divider output enable
    }

    /// PLL1DIVR Register bits
    namespace pll1divr_bits {
        constexpr uint32_t DIVN1 = (9 << 0);  ///< Multiplication factor for PLL1 VCO
        constexpr uint32_t DIVP1 = (7 << 9);  ///< PLL1 DIVP division factor
        constexpr uint32_t DIVQ1 = (7 << 16);  ///< PLL1 DIVQ division factor
        constexpr uint32_t DIVR1 = (7 << 24);  ///< PLL1 DIVR division factor
    }

    /// PLL1FRACR Register bits
    namespace pll1fracr_bits {
        constexpr uint32_t FRACN1 = (13 << 3);  ///< Fractional part of the multiplication factor for PLL1 VCO
    }

    /// PLL2DIVR Register bits
    namespace pll2divr_bits {
        constexpr uint32_t DIVN1 = (9 << 0);  ///< Multiplication factor for PLL1 VCO
        constexpr uint32_t DIVP1 = (7 << 9);  ///< PLL1 DIVP division factor
        constexpr uint32_t DIVQ1 = (7 << 16);  ///< PLL1 DIVQ division factor
        constexpr uint32_t DIVR1 = (7 << 24);  ///< PLL1 DIVR division factor
    }

    /// PLL2FRACR Register bits
    namespace pll2fracr_bits {
        constexpr uint32_t FRACN2 = (13 << 3);  ///< Fractional part of the multiplication factor for PLL VCO
    }

    /// PLL3DIVR Register bits
    namespace pll3divr_bits {
        constexpr uint32_t DIVN3 = (9 << 0);  ///< Multiplication factor for PLL1 VCO
        constexpr uint32_t DIVP3 = (7 << 9);  ///< PLL DIVP division factor
        constexpr uint32_t DIVQ3 = (7 << 16);  ///< PLL DIVQ division factor
        constexpr uint32_t DIVR3 = (7 << 24);  ///< PLL DIVR division factor
    }

    /// PLL3FRACR Register bits
    namespace pll3fracr_bits {
        constexpr uint32_t FRACN3 = (13 << 3);  ///< Fractional part of the multiplication factor for PLL3 VCO
    }

    /// D1CCIPR Register bits
    namespace d1ccipr_bits {
        constexpr uint32_t FMCSRC = (2 << 0);  ///< FMC kernel clock source selection
        constexpr uint32_t QSPISRC = (2 << 4);  ///< QUADSPI kernel clock source selection
        constexpr uint32_t SDMMCSRC = (1U << 16);  ///< SDMMC kernel clock source selection
        constexpr uint32_t CKPERSRC = (2 << 28);  ///< per_ck clock source selection
    }

    /// D2CCIP1R Register bits
    namespace d2ccip1r_bits {
        constexpr uint32_t SAI1SRC = (3 << 0);  ///< SAI1 and DFSDM1 kernel Aclk clock source selection
        constexpr uint32_t SAI23SRC = (3 << 6);  ///< SAI2 and SAI3 kernel clock source selection
        constexpr uint32_t SPI123SRC = (3 << 12);  ///< SPI/I2S1,2 and 3 kernel clock source selection
        constexpr uint32_t SPI45SRC = (3 << 16);  ///< SPI4 and 5 kernel clock source selection
        constexpr uint32_t SPDIFSRC = (2 << 20);  ///< SPDIFRX kernel clock source selection
        constexpr uint32_t DFSDM1SRC = (1U << 24);  ///< DFSDM1 kernel Clk clock source selection
        constexpr uint32_t FDCANSRC = (2 << 28);  ///< FDCAN kernel clock source selection
        constexpr uint32_t SWPSRC = (1U << 31);  ///< SWPMI kernel clock source selection
    }

    /// D2CCIP2R Register bits
    namespace d2ccip2r_bits {
        constexpr uint32_t USART234578SRC = (3 << 0);  ///< USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection
        constexpr uint32_t USART16SRC = (3 << 3);  ///< USART1 and 6 kernel clock source selection
        constexpr uint32_t RNGSRC = (2 << 8);  ///< RNG kernel clock source selection
        constexpr uint32_t I2C123SRC = (2 << 12);  ///< I2C1,2,3 kernel clock source selection
        constexpr uint32_t USBSRC = (2 << 20);  ///< USBOTG 1 and 2 kernel clock source selection
        constexpr uint32_t CECSRC = (2 << 22);  ///< HDMI-CEC kernel clock source selection
        constexpr uint32_t LPTIM1SRC = (3 << 28);  ///< LPTIM1 kernel clock source selection
    }

    /// D3CCIPR Register bits
    namespace d3ccipr_bits {
        constexpr uint32_t LPUART1SRC = (3 << 0);  ///< LPUART1 kernel clock source selection
        constexpr uint32_t I2C4SRC = (2 << 8);  ///< I2C4 kernel clock source selection
        constexpr uint32_t LPTIM2SRC = (3 << 10);  ///< LPTIM2 kernel clock source selection
        constexpr uint32_t LPTIM345SRC = (3 << 13);  ///< LPTIM3,4,5 kernel clock source selection
        constexpr uint32_t ADCSRC = (2 << 16);  ///< SAR ADC kernel clock source selection
        constexpr uint32_t SAI4ASRC = (3 << 21);  ///< Sub-Block A of SAI4 kernel clock source selection
        constexpr uint32_t SAI4BSRC = (3 << 24);  ///< Sub-Block B of SAI4 kernel clock source selection
        constexpr uint32_t SPI6SRC = (3 << 28);  ///< SPI6 kernel clock source selection
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready Interrupt Enable
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready Interrupt Enable
        constexpr uint32_t HSIRDYIE = (1U << 2);  ///< HSI ready Interrupt Enable
        constexpr uint32_t HSERDYIE = (1U << 3);  ///< HSE ready Interrupt Enable
        constexpr uint32_t CSIRDYIE = (1U << 4);  ///< CSI ready Interrupt Enable
        constexpr uint32_t RC48RDYIE = (1U << 5);  ///< RC48 ready Interrupt Enable
        constexpr uint32_t PLL1RDYIE = (1U << 6);  ///< PLL1 ready Interrupt Enable
        constexpr uint32_t PLL2RDYIE = (1U << 7);  ///< PLL2 ready Interrupt Enable
        constexpr uint32_t PLL3RDYIE = (1U << 8);  ///< PLL3 ready Interrupt Enable
        constexpr uint32_t LSECSSIE = (1U << 9);  ///< LSE clock security system Interrupt Enable
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready Interrupt Flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready Interrupt Flag
        constexpr uint32_t HSIRDYF = (1U << 2);  ///< HSI ready Interrupt Flag
        constexpr uint32_t HSERDYF = (1U << 3);  ///< HSE ready Interrupt Flag
        constexpr uint32_t CSIRDY = (1U << 4);  ///< CSI ready Interrupt Flag
        constexpr uint32_t RC48RDYF = (1U << 5);  ///< RC48 ready Interrupt Flag
        constexpr uint32_t PLL1RDYF = (1U << 6);  ///< PLL1 ready Interrupt Flag
        constexpr uint32_t PLL2RDYF = (1U << 7);  ///< PLL2 ready Interrupt Flag
        constexpr uint32_t PLL3RDYF = (1U << 8);  ///< PLL3 ready Interrupt Flag
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE clock security system Interrupt Flag
        constexpr uint32_t HSECSSF = (1U << 10);  ///< HSE clock security system Interrupt Flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready Interrupt Clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready Interrupt Clear
        constexpr uint32_t HSIRDYC = (1U << 2);  ///< HSI ready Interrupt Clear
        constexpr uint32_t HSERDYC = (1U << 3);  ///< HSE ready Interrupt Clear
        constexpr uint32_t HSE_ready_Interrupt_Clear = (1U << 4);  ///< CSI ready Interrupt Clear
        constexpr uint32_t RC48RDYC = (1U << 5);  ///< RC48 ready Interrupt Clear
        constexpr uint32_t PLL1RDYC = (1U << 6);  ///< PLL1 ready Interrupt Clear
        constexpr uint32_t PLL2RDYC = (1U << 7);  ///< PLL2 ready Interrupt Clear
        constexpr uint32_t PLL3RDYC = (1U << 8);  ///< PLL3 ready Interrupt Clear
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE clock security system Interrupt Clear
        constexpr uint32_t HSECSSC = (1U << 10);  ///< HSE clock security system Interrupt Clear
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enabled
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator driving capability
        constexpr uint32_t LSECSSON = (1U << 5);  ///< LSE clock security system enable
        constexpr uint32_t LSECSSD = (1U << 6);  ///< LSE clock security system failure detection
        constexpr uint32_t RTCSRC = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t VSWRST = (1U << 16);  ///< VSwitch domain software reset
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready
    }

    /// AHB3RSTR Register bits
    namespace ahb3rstr_bits {
        constexpr uint32_t MDMARST = (1U << 0);  ///< MDMA block reset
        constexpr uint32_t DMA2DRST = (1U << 4);  ///< DMA2D block reset
        constexpr uint32_t JPGDECRST = (1U << 5);  ///< JPGDEC block reset
        constexpr uint32_t FMCRST = (1U << 12);  ///< FMC block reset
        constexpr uint32_t QSPIRST = (1U << 14);  ///< QUADSPI and QUADSPI delay block reset
        constexpr uint32_t SDMMC1RST = (1U << 16);  ///< SDMMC1 and SDMMC1 delay block reset
        constexpr uint32_t CPURST = (1U << 31);  ///< CPU reset
    }

    /// AHB1RSTR Register bits
    namespace ahb1rstr_bits {
        constexpr uint32_t DMA1RST = (1U << 0);  ///< DMA1 block reset
        constexpr uint32_t DMA2RST = (1U << 1);  ///< DMA2 block reset
        constexpr uint32_t ADC12RST = (1U << 5);  ///< ADC1&2 block reset
        constexpr uint32_t ETH1MACRST = (1U << 15);  ///< ETH1MAC block reset
        constexpr uint32_t USB1OTGRST = (1U << 25);  ///< USB1OTG block reset
        constexpr uint32_t USB2OTGRST = (1U << 27);  ///< USB2OTG block reset
    }

    /// AHB2RSTR Register bits
    namespace ahb2rstr_bits {
        constexpr uint32_t CAMITFRST = (1U << 0);  ///< CAMITF block reset
        constexpr uint32_t CRYPTRST = (1U << 4);  ///< Cryptography block reset
        constexpr uint32_t HASHRST = (1U << 5);  ///< Hash block reset
        constexpr uint32_t RNGRST = (1U << 6);  ///< Random Number Generator block reset
        constexpr uint32_t SDMMC2RST = (1U << 9);  ///< SDMMC2 and SDMMC2 Delay block reset
    }

    /// AHB4RSTR Register bits
    namespace ahb4rstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< GPIO block reset
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< GPIO block reset
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< GPIO block reset
        constexpr uint32_t GPIODRST = (1U << 3);  ///< GPIO block reset
        constexpr uint32_t GPIOERST = (1U << 4);  ///< GPIO block reset
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< GPIO block reset
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< GPIO block reset
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< GPIO block reset
        constexpr uint32_t GPIOIRST = (1U << 8);  ///< GPIO block reset
        constexpr uint32_t GPIOJRST = (1U << 9);  ///< GPIO block reset
        constexpr uint32_t GPIOKRST = (1U << 10);  ///< GPIO block reset
        constexpr uint32_t CRCRST = (1U << 19);  ///< CRC block reset
        constexpr uint32_t BDMARST = (1U << 21);  ///< BDMA block reset
        constexpr uint32_t ADC3RST = (1U << 24);  ///< ADC3 block reset
        constexpr uint32_t HSEMRST = (1U << 25);  ///< HSEM block reset
    }

    /// APB3RSTR Register bits
    namespace apb3rstr_bits {
        constexpr uint32_t LTDCRST = (1U << 3);  ///< LTDC block reset
    }

    /// APB1LRSTR Register bits
    namespace apb1lrstr_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM block reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM block reset
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM block reset
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM block reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM block reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM block reset
        constexpr uint32_t TIM12RST = (1U << 6);  ///< TIM block reset
        constexpr uint32_t TIM13RST = (1U << 7);  ///< TIM block reset
        constexpr uint32_t TIM14RST = (1U << 8);  ///< TIM block reset
        constexpr uint32_t LPTIM1RST = (1U << 9);  ///< TIM block reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 block reset
        constexpr uint32_t SPI3RST = (1U << 15);  ///< SPI3 block reset
        constexpr uint32_t SPDIFRXRST = (1U << 16);  ///< SPDIFRX block reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 block reset
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 block reset
        constexpr uint32_t UART4RST = (1U << 19);  ///< UART4 block reset
        constexpr uint32_t UART5RST = (1U << 20);  ///< UART5 block reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 block reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 block reset
        constexpr uint32_t I2C3RST = (1U << 23);  ///< I2C3 block reset
        constexpr uint32_t CECRST = (1U << 27);  ///< HDMI-CEC block reset
        constexpr uint32_t DAC12RST = (1U << 29);  ///< DAC1 and 2 Blocks Reset
        constexpr uint32_t USART7RST = (1U << 30);  ///< USART7 block reset
        constexpr uint32_t USART8RST = (1U << 31);  ///< USART8 block reset
    }

    /// APB1HRSTR Register bits
    namespace apb1hrstr_bits {
        constexpr uint32_t CRSRST = (1U << 1);  ///< Clock Recovery System reset
        constexpr uint32_t SWPRST = (1U << 2);  ///< SWPMI block reset
        constexpr uint32_t OPAMPRST = (1U << 4);  ///< OPAMP block reset
        constexpr uint32_t MDIOSRST = (1U << 5);  ///< MDIOS block reset
        constexpr uint32_t FDCANRST = (1U << 8);  ///< FDCAN block reset
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t TIM1RST = (1U << 0);  ///< TIM1 block reset
        constexpr uint32_t TIM8RST = (1U << 1);  ///< TIM8 block reset
        constexpr uint32_t USART1RST = (1U << 4);  ///< USART1 block reset
        constexpr uint32_t USART6RST = (1U << 5);  ///< USART6 block reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 block reset
        constexpr uint32_t SPI4RST = (1U << 13);  ///< SPI4 block reset
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 block reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 block reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 block reset
        constexpr uint32_t SPI5RST = (1U << 20);  ///< SPI5 block reset
        constexpr uint32_t SAI1RST = (1U << 22);  ///< SAI1 block reset
        constexpr uint32_t SAI2RST = (1U << 23);  ///< SAI2 block reset
        constexpr uint32_t SAI3RST = (1U << 24);  ///< SAI3 block reset
        constexpr uint32_t DFSDM1RST = (1U << 28);  ///< DFSDM1 block reset
        constexpr uint32_t HRTIMRST = (1U << 29);  ///< HRTIM block reset
    }

    /// APB4RSTR Register bits
    namespace apb4rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 1);  ///< SYSCFG block reset
        constexpr uint32_t LPUART1RST = (1U << 3);  ///< LPUART1 block reset
        constexpr uint32_t SPI6RST = (1U << 5);  ///< SPI6 block reset
        constexpr uint32_t I2C4RST = (1U << 7);  ///< I2C4 block reset
        constexpr uint32_t LPTIM2RST = (1U << 9);  ///< LPTIM2 block reset
        constexpr uint32_t LPTIM3RST = (1U << 10);  ///< LPTIM3 block reset
        constexpr uint32_t LPTIM4RST = (1U << 11);  ///< LPTIM4 block reset
        constexpr uint32_t LPTIM5RST = (1U << 12);  ///< LPTIM5 block reset
        constexpr uint32_t COMP12RST = (1U << 14);  ///< COMP12 Blocks Reset
        constexpr uint32_t VREFRST = (1U << 15);  ///< VREF block reset
        constexpr uint32_t SAI4RST = (1U << 21);  ///< SAI4 block reset
    }

    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t WW1RSC = (1U << 0);  ///< WWDG1 reset scope control
    }

    /// D3AMR Register bits
    namespace d3amr_bits {
        constexpr uint32_t BDMAAMEN = (1U << 0);  ///< BDMA and DMAMUX Autonomous mode enable
        constexpr uint32_t LPUART1AMEN = (1U << 3);  ///< LPUART1 Autonomous mode enable
        constexpr uint32_t SPI6AMEN = (1U << 5);  ///< SPI6 Autonomous mode enable
        constexpr uint32_t I2C4AMEN = (1U << 7);  ///< I2C4 Autonomous mode enable
        constexpr uint32_t LPTIM2AMEN = (1U << 9);  ///< LPTIM2 Autonomous mode enable
        constexpr uint32_t LPTIM3AMEN = (1U << 10);  ///< LPTIM3 Autonomous mode enable
        constexpr uint32_t LPTIM4AMEN = (1U << 11);  ///< LPTIM4 Autonomous mode enable
        constexpr uint32_t LPTIM5AMEN = (1U << 12);  ///< LPTIM5 Autonomous mode enable
        constexpr uint32_t COMP12AMEN = (1U << 14);  ///< COMP12 Autonomous mode enable
        constexpr uint32_t VREFAMEN = (1U << 15);  ///< VREF Autonomous mode enable
        constexpr uint32_t RTCAMEN = (1U << 16);  ///< RTC Autonomous mode enable
        constexpr uint32_t CRCAMEN = (1U << 19);  ///< CRC Autonomous mode enable
        constexpr uint32_t SAI4AMEN = (1U << 21);  ///< SAI4 Autonomous mode enable
        constexpr uint32_t ADC3AMEN = (1U << 24);  ///< ADC3 Autonomous mode enable
        constexpr uint32_t BKPRAMAMEN = (1U << 28);  ///< Backup RAM Autonomous mode enable
        constexpr uint32_t SRAM4AMEN = (1U << 29);  ///< SRAM4 Autonomous mode enable
    }

    /// RSR Register bits
    namespace rsr_bits {
        constexpr uint32_t RMVF = (1U << 16);  ///< Remove reset flag
        constexpr uint32_t CPURSTF = (1U << 17);  ///< CPU reset flag
        constexpr uint32_t D1RSTF = (1U << 19);  ///< D1 domain power switch reset flag
        constexpr uint32_t D2RSTF = (1U << 20);  ///< D2 domain power switch reset flag
        constexpr uint32_t BORRSTF = (1U << 21);  ///< BOR reset flag
        constexpr uint32_t PINRSTF = (1U << 22);  ///< Pin reset flag (NRST)
        constexpr uint32_t PORRSTF = (1U << 23);  ///< POR/PDR reset flag
        constexpr uint32_t SFTRSTF = (1U << 24);  ///< System reset from CPU reset flag
        constexpr uint32_t IWDG1RSTF = (1U << 26);  ///< Independent Watchdog reset flag
        constexpr uint32_t WWDG1RSTF = (1U << 28);  ///< Window Watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 30);  ///< Reset due to illegal D1 DStandby or CPU CStop flag
    }

    /// C1_RSR Register bits
    namespace c1_rsr_bits {
        constexpr uint32_t RMVF = (1U << 16);  ///< Remove reset flag
        constexpr uint32_t CPURSTF = (1U << 17);  ///< CPU reset flag
        constexpr uint32_t D1RSTF = (1U << 19);  ///< D1 domain power switch reset flag
        constexpr uint32_t D2RSTF = (1U << 20);  ///< D2 domain power switch reset flag
        constexpr uint32_t BORRSTF = (1U << 21);  ///< BOR reset flag
        constexpr uint32_t PINRSTF = (1U << 22);  ///< Pin reset flag (NRST)
        constexpr uint32_t PORRSTF = (1U << 23);  ///< POR/PDR reset flag
        constexpr uint32_t SFTRSTF = (1U << 24);  ///< System reset from CPU reset flag
        constexpr uint32_t IWDG1RSTF = (1U << 26);  ///< Independent Watchdog reset flag
        constexpr uint32_t WWDG1RSTF = (1U << 28);  ///< Window Watchdog reset flag
        constexpr uint32_t LPWRRSTF = (1U << 30);  ///< Reset due to illegal D1 DStandby or CPU CStop flag
    }

    /// C1_AHB3ENR Register bits
    namespace c1_ahb3enr_bits {
        constexpr uint32_t MDMAEN = (1U << 0);  ///< MDMA Peripheral Clock Enable
        constexpr uint32_t DMA2DEN = (1U << 4);  ///< DMA2D Peripheral Clock Enable
        constexpr uint32_t JPGDECEN = (1U << 5);  ///< JPGDEC Peripheral Clock Enable
        constexpr uint32_t FMCEN = (1U << 12);  ///< FMC Peripheral Clocks Enable
        constexpr uint32_t QSPIEN = (1U << 14);  ///< QUADSPI and QUADSPI Delay Clock Enable
        constexpr uint32_t SDMMC1EN = (1U << 16);  ///< SDMMC1 and SDMMC1 Delay Clock Enable
    }

    /// AHB3ENR Register bits
    namespace ahb3enr_bits {
        constexpr uint32_t MDMAEN = (1U << 0);  ///< MDMA Peripheral Clock Enable
        constexpr uint32_t DMA2DEN = (1U << 4);  ///< DMA2D Peripheral Clock Enable
        constexpr uint32_t JPGDECEN = (1U << 5);  ///< JPGDEC Peripheral Clock Enable
        constexpr uint32_t FMCEN = (1U << 12);  ///< FMC Peripheral Clocks Enable
        constexpr uint32_t QSPIEN = (1U << 14);  ///< QUADSPI and QUADSPI Delay Clock Enable
        constexpr uint32_t SDMMC1EN = (1U << 16);  ///< SDMMC1 and SDMMC1 Delay Clock Enable
    }

    /// AHB1ENR Register bits
    namespace ahb1enr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 Clock Enable
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 Clock Enable
        constexpr uint32_t ADC12EN = (1U << 5);  ///< ADC1/2 Peripheral Clocks Enable
        constexpr uint32_t ETH1MACEN = (1U << 15);  ///< Ethernet MAC bus interface Clock Enable
        constexpr uint32_t ETH1TXEN = (1U << 16);  ///< Ethernet Transmission Clock Enable
        constexpr uint32_t ETH1RXEN = (1U << 17);  ///< Ethernet Reception Clock Enable
        constexpr uint32_t USB2OTGHSULPIEN = (1U << 18);  ///< Enable USB_PHY2 clocks
        constexpr uint32_t USB1OTGEN = (1U << 25);  ///< USB1OTG Peripheral Clocks Enable
        constexpr uint32_t USB1ULPIEN = (1U << 26);  ///< USB_PHY1 Clocks Enable
        constexpr uint32_t USB2OTGEN = (1U << 27);  ///< USB2OTG Peripheral Clocks Enable
        constexpr uint32_t USB2ULPIEN = (1U << 28);  ///< USB_PHY2 Clocks Enable
    }

    /// C1_AHB1ENR Register bits
    namespace c1_ahb1enr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 Clock Enable
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 Clock Enable
        constexpr uint32_t ADC12EN = (1U << 5);  ///< ADC1/2 Peripheral Clocks Enable
        constexpr uint32_t ETH1MACEN = (1U << 15);  ///< Ethernet MAC bus interface Clock Enable
        constexpr uint32_t ETH1TXEN = (1U << 16);  ///< Ethernet Transmission Clock Enable
        constexpr uint32_t ETH1RXEN = (1U << 17);  ///< Ethernet Reception Clock Enable
        constexpr uint32_t USB1OTGEN = (1U << 25);  ///< USB1OTG Peripheral Clocks Enable
        constexpr uint32_t USB1ULPIEN = (1U << 26);  ///< USB_PHY1 Clocks Enable
        constexpr uint32_t USB2OTGEN = (1U << 27);  ///< USB2OTG Peripheral Clocks Enable
        constexpr uint32_t USB2ULPIEN = (1U << 28);  ///< USB_PHY2 Clocks Enable
    }

    /// C1_AHB2ENR Register bits
    namespace c1_ahb2enr_bits {
        constexpr uint32_t CAMITFEN = (1U << 0);  ///< CAMITF peripheral clock enable
        constexpr uint32_t CRYPTEN = (1U << 4);  ///< CRYPT peripheral clock enable
        constexpr uint32_t HASHEN = (1U << 5);  ///< HASH peripheral clock enable
        constexpr uint32_t RNGEN = (1U << 6);  ///< RNG peripheral clocks enable
        constexpr uint32_t SDMMC2EN = (1U << 9);  ///< SDMMC2 and SDMMC2 delay clock enable
        constexpr uint32_t SRAM1EN = (1U << 29);  ///< SRAM1 block enable
        constexpr uint32_t SRAM2EN = (1U << 30);  ///< SRAM2 block enable
        constexpr uint32_t SRAM3EN = (1U << 31);  ///< SRAM3 block enable
    }

    /// AHB2ENR Register bits
    namespace ahb2enr_bits {
        constexpr uint32_t CAMITFEN = (1U << 0);  ///< CAMITF peripheral clock enable
        constexpr uint32_t CRYPTEN = (1U << 4);  ///< CRYPT peripheral clock enable
        constexpr uint32_t HASHEN = (1U << 5);  ///< HASH peripheral clock enable
        constexpr uint32_t RNGEN = (1U << 6);  ///< RNG peripheral clocks enable
        constexpr uint32_t SDMMC2EN = (1U << 9);  ///< SDMMC2 and SDMMC2 delay clock enable
        constexpr uint32_t SRAM1EN = (1U << 29);  ///< SRAM1 block enable
        constexpr uint32_t SRAM2EN = (1U << 30);  ///< SRAM2 block enable
        constexpr uint32_t SRAM3EN = (1U << 31);  ///< SRAM3 block enable
    }

    /// AHB4ENR Register bits
    namespace ahb4enr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIODEN = (1U << 3);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOIEN = (1U << 8);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOJEN = (1U << 9);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOKEN = (1U << 10);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t CRCEN = (1U << 19);  ///< CRC peripheral clock enable
        constexpr uint32_t BDMAEN = (1U << 21);  ///< BDMA and DMAMUX2 Clock Enable
        constexpr uint32_t ADC3EN = (1U << 24);  ///< ADC3 Peripheral Clocks Enable
        constexpr uint32_t HSEMEN = (1U << 25);  ///< HSEM peripheral clock enable
        constexpr uint32_t BKPRAMEN = (1U << 28);  ///< Backup RAM Clock Enable
    }

    /// C1_AHB4ENR Register bits
    namespace c1_ahb4enr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIODEN = (1U << 3);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOIEN = (1U << 8);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOJEN = (1U << 9);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t GPIOKEN = (1U << 10);  ///< 0GPIO peripheral clock enable
        constexpr uint32_t CRCEN = (1U << 19);  ///< CRC peripheral clock enable
        constexpr uint32_t BDMAEN = (1U << 21);  ///< BDMA and DMAMUX2 Clock Enable
        constexpr uint32_t ADC3EN = (1U << 24);  ///< ADC3 Peripheral Clocks Enable
        constexpr uint32_t HSEMEN = (1U << 25);  ///< HSEM peripheral clock enable
        constexpr uint32_t BKPRAMEN = (1U << 28);  ///< Backup RAM Clock Enable
    }

    /// C1_APB3ENR Register bits
    namespace c1_apb3enr_bits {
        constexpr uint32_t LTDCEN = (1U << 3);  ///< LTDC peripheral clock enable
        constexpr uint32_t WWDG1EN = (1U << 6);  ///< WWDG1 Clock Enable
    }

    /// APB3ENR Register bits
    namespace apb3enr_bits {
        constexpr uint32_t LTDCEN = (1U << 3);  ///< LTDC peripheral clock enable
        constexpr uint32_t WWDG1EN = (1U << 6);  ///< WWDG1 Clock Enable
    }

    /// APB1LENR Register bits
    namespace apb1lenr_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM12EN = (1U << 6);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM13EN = (1U << 7);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM14EN = (1U << 8);  ///< TIM peripheral clock enable
        constexpr uint32_t LPTIM1EN = (1U << 9);  ///< LPTIM1 Peripheral Clocks Enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 Peripheral Clocks Enable
        constexpr uint32_t SPI3EN = (1U << 15);  ///< SPI3 Peripheral Clocks Enable
        constexpr uint32_t SPDIFRXEN = (1U << 16);  ///< SPDIFRX Peripheral Clocks Enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 Peripheral Clocks Enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 Peripheral Clocks Enable
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 Peripheral Clocks Enable
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 Peripheral Clocks Enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 Peripheral Clocks Enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 Peripheral Clocks Enable
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 Peripheral Clocks Enable
        constexpr uint32_t CECEN = (1U << 27);  ///< HDMI-CEC peripheral clock enable
        constexpr uint32_t DAC12EN = (1U << 29);  ///< DAC1&2 peripheral clock enable
        constexpr uint32_t USART7EN = (1U << 30);  ///< USART7 Peripheral Clocks Enable
        constexpr uint32_t USART8EN = (1U << 31);  ///< USART8 Peripheral Clocks Enable
    }

    /// C1_APB1LENR Register bits
    namespace c1_apb1lenr_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM12EN = (1U << 6);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM13EN = (1U << 7);  ///< TIM peripheral clock enable
        constexpr uint32_t TIM14EN = (1U << 8);  ///< TIM peripheral clock enable
        constexpr uint32_t LPTIM1EN = (1U << 9);  ///< LPTIM1 Peripheral Clocks Enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 Peripheral Clocks Enable
        constexpr uint32_t SPI3EN = (1U << 15);  ///< SPI3 Peripheral Clocks Enable
        constexpr uint32_t SPDIFRXEN = (1U << 16);  ///< SPDIFRX Peripheral Clocks Enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 Peripheral Clocks Enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 Peripheral Clocks Enable
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 Peripheral Clocks Enable
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 Peripheral Clocks Enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 Peripheral Clocks Enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 Peripheral Clocks Enable
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 Peripheral Clocks Enable
        constexpr uint32_t HDMICECEN = (1U << 27);  ///< HDMI-CEC peripheral clock enable
        constexpr uint32_t DAC12EN = (1U << 29);  ///< DAC1&2 peripheral clock enable
        constexpr uint32_t USART7EN = (1U << 30);  ///< USART7 Peripheral Clocks Enable
        constexpr uint32_t USART8EN = (1U << 31);  ///< USART8 Peripheral Clocks Enable
    }

    /// APB1HENR Register bits
    namespace apb1henr_bits {
        constexpr uint32_t CRSEN = (1U << 1);  ///< Clock Recovery System peripheral clock enable
        constexpr uint32_t SWPEN = (1U << 2);  ///< SWPMI Peripheral Clocks Enable
        constexpr uint32_t OPAMPEN = (1U << 4);  ///< OPAMP peripheral clock enable
        constexpr uint32_t MDIOSEN = (1U << 5);  ///< MDIOS peripheral clock enable
        constexpr uint32_t FDCANEN = (1U << 8);  ///< FDCAN Peripheral Clocks Enable
    }

    /// C1_APB1HENR Register bits
    namespace c1_apb1henr_bits {
        constexpr uint32_t CRSEN = (1U << 1);  ///< Clock Recovery System peripheral clock enable
        constexpr uint32_t SWPEN = (1U << 2);  ///< SWPMI Peripheral Clocks Enable
        constexpr uint32_t OPAMPEN = (1U << 4);  ///< OPAMP peripheral clock enable
        constexpr uint32_t MDIOSEN = (1U << 5);  ///< MDIOS peripheral clock enable
        constexpr uint32_t FDCANEN = (1U << 8);  ///< FDCAN Peripheral Clocks Enable
    }

    /// C1_APB2ENR Register bits
    namespace c1_apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 0);  ///< TIM1 peripheral clock enable
        constexpr uint32_t TIM8EN = (1U << 1);  ///< TIM8 peripheral clock enable
        constexpr uint32_t USART1EN = (1U << 4);  ///< USART1 Peripheral Clocks Enable
        constexpr uint32_t USART6EN = (1U << 5);  ///< USART6 Peripheral Clocks Enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 Peripheral Clocks Enable
        constexpr uint32_t SPI4EN = (1U << 13);  ///< SPI4 Peripheral Clocks Enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 peripheral clock enable
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 peripheral clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 peripheral clock enable
        constexpr uint32_t SPI5EN = (1U << 20);  ///< SPI5 Peripheral Clocks Enable
        constexpr uint32_t SAI1EN = (1U << 22);  ///< SAI1 Peripheral Clocks Enable
        constexpr uint32_t SAI2EN = (1U << 23);  ///< SAI2 Peripheral Clocks Enable
        constexpr uint32_t SAI3EN = (1U << 24);  ///< SAI3 Peripheral Clocks Enable
        constexpr uint32_t DFSDM1EN = (1U << 28);  ///< DFSDM1 Peripheral Clocks Enable
        constexpr uint32_t HRTIMEN = (1U << 29);  ///< HRTIM peripheral clock enable
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 0);  ///< TIM1 peripheral clock enable
        constexpr uint32_t TIM8EN = (1U << 1);  ///< TIM8 peripheral clock enable
        constexpr uint32_t USART1EN = (1U << 4);  ///< USART1 Peripheral Clocks Enable
        constexpr uint32_t USART6EN = (1U << 5);  ///< USART6 Peripheral Clocks Enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 Peripheral Clocks Enable
        constexpr uint32_t SPI4EN = (1U << 13);  ///< SPI4 Peripheral Clocks Enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 peripheral clock enable
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 peripheral clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 peripheral clock enable
        constexpr uint32_t SPI5EN = (1U << 20);  ///< SPI5 Peripheral Clocks Enable
        constexpr uint32_t SAI1EN = (1U << 22);  ///< SAI1 Peripheral Clocks Enable
        constexpr uint32_t SAI2EN = (1U << 23);  ///< SAI2 Peripheral Clocks Enable
        constexpr uint32_t SAI3EN = (1U << 24);  ///< SAI3 Peripheral Clocks Enable
        constexpr uint32_t DFSDM1EN = (1U << 28);  ///< DFSDM1 Peripheral Clocks Enable
        constexpr uint32_t HRTIMEN = (1U << 29);  ///< HRTIM peripheral clock enable
    }

    /// APB4ENR Register bits
    namespace apb4enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 1);  ///< SYSCFG peripheral clock enable
        constexpr uint32_t LPUART1EN = (1U << 3);  ///< LPUART1 Peripheral Clocks Enable
        constexpr uint32_t SPI6EN = (1U << 5);  ///< SPI6 Peripheral Clocks Enable
        constexpr uint32_t I2C4EN = (1U << 7);  ///< I2C4 Peripheral Clocks Enable
        constexpr uint32_t LPTIM2EN = (1U << 9);  ///< LPTIM2 Peripheral Clocks Enable
        constexpr uint32_t LPTIM3EN = (1U << 10);  ///< LPTIM3 Peripheral Clocks Enable
        constexpr uint32_t LPTIM4EN = (1U << 11);  ///< LPTIM4 Peripheral Clocks Enable
        constexpr uint32_t LPTIM5EN = (1U << 12);  ///< LPTIM5 Peripheral Clocks Enable
        constexpr uint32_t COMP12EN = (1U << 14);  ///< COMP1/2 peripheral clock enable
        constexpr uint32_t VREFEN = (1U << 15);  ///< VREF peripheral clock enable
        constexpr uint32_t RTCAPBEN = (1U << 16);  ///< RTC APB Clock Enable
        constexpr uint32_t SAI4EN = (1U << 21);  ///< SAI4 Peripheral Clocks Enable
    }

    /// C1_APB4ENR Register bits
    namespace c1_apb4enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 1);  ///< SYSCFG peripheral clock enable
        constexpr uint32_t LPUART1EN = (1U << 3);  ///< LPUART1 Peripheral Clocks Enable
        constexpr uint32_t SPI6EN = (1U << 5);  ///< SPI6 Peripheral Clocks Enable
        constexpr uint32_t I2C4EN = (1U << 7);  ///< I2C4 Peripheral Clocks Enable
        constexpr uint32_t LPTIM2EN = (1U << 9);  ///< LPTIM2 Peripheral Clocks Enable
        constexpr uint32_t LPTIM3EN = (1U << 10);  ///< LPTIM3 Peripheral Clocks Enable
        constexpr uint32_t LPTIM4EN = (1U << 11);  ///< LPTIM4 Peripheral Clocks Enable
        constexpr uint32_t LPTIM5EN = (1U << 12);  ///< LPTIM5 Peripheral Clocks Enable
        constexpr uint32_t COMP12EN = (1U << 14);  ///< COMP1/2 peripheral clock enable
        constexpr uint32_t VREFEN = (1U << 15);  ///< VREF peripheral clock enable
        constexpr uint32_t RTCAPBEN = (1U << 16);  ///< RTC APB Clock Enable
        constexpr uint32_t SAI4EN = (1U << 21);  ///< SAI4 Peripheral Clocks Enable
    }

    /// C1_AHB3LPENR Register bits
    namespace c1_ahb3lpenr_bits {
        constexpr uint32_t MDMALPEN = (1U << 0);  ///< MDMA Clock Enable During CSleep Mode
        constexpr uint32_t DMA2DLPEN = (1U << 4);  ///< DMA2D Clock Enable During CSleep Mode
        constexpr uint32_t JPGDECLPEN = (1U << 5);  ///< JPGDEC Clock Enable During CSleep Mode
        constexpr uint32_t FLITFLPEN = (1U << 8);  ///< FLITF Clock Enable During CSleep Mode
        constexpr uint32_t FMCLPEN = (1U << 12);  ///< FMC Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t QSPILPEN = (1U << 14);  ///< QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
        constexpr uint32_t SDMMC1LPEN = (1U << 16);  ///< SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
        constexpr uint32_t D1DTCM1LPEN = (1U << 28);  ///< D1DTCM1 Block Clock Enable During CSleep mode
        constexpr uint32_t DTCM2LPEN = (1U << 29);  ///< D1 DTCM2 Block Clock Enable During CSleep mode
        constexpr uint32_t ITCMLPEN = (1U << 30);  ///< D1ITCM Block Clock Enable During CSleep mode
        constexpr uint32_t AXISRAMLPEN = (1U << 31);  ///< AXISRAM Block Clock Enable During CSleep mode
    }

    /// AHB3LPENR Register bits
    namespace ahb3lpenr_bits {
        constexpr uint32_t MDMALPEN = (1U << 0);  ///< MDMA Clock Enable During CSleep Mode
        constexpr uint32_t DMA2DLPEN = (1U << 4);  ///< DMA2D Clock Enable During CSleep Mode
        constexpr uint32_t JPGDECLPEN = (1U << 5);  ///< JPGDEC Clock Enable During CSleep Mode
        constexpr uint32_t FLASHLPEN = (1U << 8);  ///< FLITF Clock Enable During CSleep Mode
        constexpr uint32_t FMCLPEN = (1U << 12);  ///< FMC Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t QSPILPEN = (1U << 14);  ///< QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
        constexpr uint32_t SDMMC1LPEN = (1U << 16);  ///< SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
        constexpr uint32_t D1DTCM1LPEN = (1U << 28);  ///< D1DTCM1 Block Clock Enable During CSleep mode
        constexpr uint32_t DTCM2LPEN = (1U << 29);  ///< D1 DTCM2 Block Clock Enable During CSleep mode
        constexpr uint32_t ITCMLPEN = (1U << 30);  ///< D1ITCM Block Clock Enable During CSleep mode
        constexpr uint32_t AXISRAMLPEN = (1U << 31);  ///< AXISRAM Block Clock Enable During CSleep mode
    }

    /// AHB1LPENR Register bits
    namespace ahb1lpenr_bits {
        constexpr uint32_t DMA1LPEN = (1U << 0);  ///< DMA1 Clock Enable During CSleep Mode
        constexpr uint32_t DMA2LPEN = (1U << 1);  ///< DMA2 Clock Enable During CSleep Mode
        constexpr uint32_t ADC12LPEN = (1U << 5);  ///< ADC1/2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t ETH1MACLPEN = (1U << 15);  ///< Ethernet MAC bus interface Clock Enable During CSleep Mode
        constexpr uint32_t ETH1TXLPEN = (1U << 16);  ///< Ethernet Transmission Clock Enable During CSleep Mode
        constexpr uint32_t ETH1RXLPEN = (1U << 17);  ///< Ethernet Reception Clock Enable During CSleep Mode
        constexpr uint32_t USB1OTGHSLPEN = (1U << 25);  ///< USB1OTG peripheral clock enable during CSleep mode
        constexpr uint32_t USB1OTGHSULPILPEN = (1U << 26);  ///< USB_PHY1 clock enable during CSleep mode
        constexpr uint32_t USB2OTGHSLPEN = (1U << 27);  ///< USB2OTG peripheral clock enable during CSleep mode
        constexpr uint32_t USB2OTGHSULPILPEN = (1U << 28);  ///< USB_PHY2 clocks enable during CSleep mode
    }

    /// C1_AHB1LPENR Register bits
    namespace c1_ahb1lpenr_bits {
        constexpr uint32_t DMA1LPEN = (1U << 0);  ///< DMA1 Clock Enable During CSleep Mode
        constexpr uint32_t DMA2LPEN = (1U << 1);  ///< DMA2 Clock Enable During CSleep Mode
        constexpr uint32_t ADC12LPEN = (1U << 5);  ///< ADC1/2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t ETH1MACLPEN = (1U << 15);  ///< Ethernet MAC bus interface Clock Enable During CSleep Mode
        constexpr uint32_t ETH1TXLPEN = (1U << 16);  ///< Ethernet Transmission Clock Enable During CSleep Mode
        constexpr uint32_t ETH1RXLPEN = (1U << 17);  ///< Ethernet Reception Clock Enable During CSleep Mode
        constexpr uint32_t USB1OTGLPEN = (1U << 25);  ///< USB1OTG peripheral clock enable during CSleep mode
        constexpr uint32_t USB1ULPILPEN = (1U << 26);  ///< USB_PHY1 clock enable during CSleep mode
        constexpr uint32_t USB2OTGLPEN = (1U << 27);  ///< USB2OTG peripheral clock enable during CSleep mode
        constexpr uint32_t USB2ULPILPEN = (1U << 28);  ///< USB_PHY2 clocks enable during CSleep mode
    }

    /// C1_AHB2LPENR Register bits
    namespace c1_ahb2lpenr_bits {
        constexpr uint32_t CAMITFLPEN = (1U << 0);  ///< CAMITF peripheral clock enable during CSleep mode
        constexpr uint32_t CRYPTLPEN = (1U << 4);  ///< CRYPT peripheral clock enable during CSleep mode
        constexpr uint32_t HASHLPEN = (1U << 5);  ///< HASH peripheral clock enable during CSleep mode
        constexpr uint32_t SDMMC2LPEN = (1U << 9);  ///< SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
        constexpr uint32_t RNGLPEN = (1U << 6);  ///< RNG peripheral clock enable during CSleep mode
        constexpr uint32_t SRAM1LPEN = (1U << 29);  ///< SRAM1 Clock Enable During CSleep Mode
        constexpr uint32_t SRAM2LPEN = (1U << 30);  ///< SRAM2 Clock Enable During CSleep Mode
        constexpr uint32_t SRAM3LPEN = (1U << 31);  ///< SRAM3 Clock Enable During CSleep Mode
    }

    /// AHB2LPENR Register bits
    namespace ahb2lpenr_bits {
        constexpr uint32_t CAMITFLPEN = (1U << 0);  ///< CAMITF peripheral clock enable during CSleep mode
        constexpr uint32_t CRYPTLPEN = (1U << 4);  ///< CRYPT peripheral clock enable during CSleep mode
        constexpr uint32_t HASHLPEN = (1U << 5);  ///< HASH peripheral clock enable during CSleep mode
        constexpr uint32_t SDMMC2LPEN = (1U << 9);  ///< SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
        constexpr uint32_t RNGLPEN = (1U << 6);  ///< RNG peripheral clock enable during CSleep mode
        constexpr uint32_t SRAM1LPEN = (1U << 29);  ///< SRAM1 Clock Enable During CSleep Mode
        constexpr uint32_t SRAM2LPEN = (1U << 30);  ///< SRAM2 Clock Enable During CSleep Mode
        constexpr uint32_t SRAM3LPEN = (1U << 31);  ///< SRAM3 Clock Enable During CSleep Mode
    }

    /// AHB4LPENR Register bits
    namespace ahb4lpenr_bits {
        constexpr uint32_t GPIOALPEN = (1U << 0);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOBLPEN = (1U << 1);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOCLPEN = (1U << 2);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIODLPEN = (1U << 3);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOELPEN = (1U << 4);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOFLPEN = (1U << 5);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOGLPEN = (1U << 6);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOHLPEN = (1U << 7);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOILPEN = (1U << 8);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOJLPEN = (1U << 9);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOKLPEN = (1U << 10);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t CRCLPEN = (1U << 19);  ///< CRC peripheral clock enable during CSleep mode
        constexpr uint32_t BDMALPEN = (1U << 21);  ///< BDMA Clock Enable During CSleep Mode
        constexpr uint32_t ADC3LPEN = (1U << 24);  ///< ADC3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t BKPRAMLPEN = (1U << 28);  ///< Backup RAM Clock Enable During CSleep Mode
        constexpr uint32_t SRAM4LPEN = (1U << 29);  ///< SRAM4 Clock Enable During CSleep Mode
    }

    /// C1_AHB4LPENR Register bits
    namespace c1_ahb4lpenr_bits {
        constexpr uint32_t GPIOALPEN = (1U << 0);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOBLPEN = (1U << 1);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOCLPEN = (1U << 2);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIODLPEN = (1U << 3);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOELPEN = (1U << 4);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOFLPEN = (1U << 5);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOGLPEN = (1U << 6);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOHLPEN = (1U << 7);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOILPEN = (1U << 8);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOJLPEN = (1U << 9);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t GPIOKLPEN = (1U << 10);  ///< GPIO peripheral clock enable during CSleep mode
        constexpr uint32_t CRCLPEN = (1U << 19);  ///< CRC peripheral clock enable during CSleep mode
        constexpr uint32_t BDMALPEN = (1U << 21);  ///< BDMA Clock Enable During CSleep Mode
        constexpr uint32_t ADC3LPEN = (1U << 24);  ///< ADC3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t BKPRAMLPEN = (1U << 28);  ///< Backup RAM Clock Enable During CSleep Mode
        constexpr uint32_t SRAM4LPEN = (1U << 29);  ///< SRAM4 Clock Enable During CSleep Mode
    }

    /// C1_APB3LPENR Register bits
    namespace c1_apb3lpenr_bits {
        constexpr uint32_t LTDCLPEN = (1U << 3);  ///< LTDC peripheral clock enable during CSleep mode
        constexpr uint32_t WWDG1LPEN = (1U << 6);  ///< WWDG1 Clock Enable During CSleep Mode
    }

    /// APB3LPENR Register bits
    namespace apb3lpenr_bits {
        constexpr uint32_t LTDCLPEN = (1U << 3);  ///< LTDC peripheral clock enable during CSleep mode
        constexpr uint32_t WWDG1LPEN = (1U << 6);  ///< WWDG1 Clock Enable During CSleep Mode
    }

    /// APB1LLPENR Register bits
    namespace apb1llpenr_bits {
        constexpr uint32_t TIM2LPEN = (1U << 0);  ///< TIM2 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM3LPEN = (1U << 1);  ///< TIM3 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM4LPEN = (1U << 2);  ///< TIM4 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM5LPEN = (1U << 3);  ///< TIM5 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM6LPEN = (1U << 4);  ///< TIM6 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM7LPEN = (1U << 5);  ///< TIM7 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM12LPEN = (1U << 6);  ///< TIM12 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM13LPEN = (1U << 7);  ///< TIM13 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM14LPEN = (1U << 8);  ///< TIM14 peripheral clock enable during CSleep mode
        constexpr uint32_t LPTIM1LPEN = (1U << 9);  ///< LPTIM1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI2LPEN = (1U << 14);  ///< SPI2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI3LPEN = (1U << 15);  ///< SPI3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPDIFRXLPEN = (1U << 16);  ///< SPDIFRX Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART2LPEN = (1U << 17);  ///< USART2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART3LPEN = (1U << 18);  ///< USART3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t UART4LPEN = (1U << 19);  ///< UART4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t UART5LPEN = (1U << 20);  ///< UART5 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C1LPEN = (1U << 21);  ///< I2C1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C2LPEN = (1U << 22);  ///< I2C2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C3LPEN = (1U << 23);  ///< I2C3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t HDMICECLPEN = (1U << 27);  ///< HDMI-CEC Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t DAC12LPEN = (1U << 29);  ///< DAC1/2 peripheral clock enable during CSleep mode
        constexpr uint32_t USART7LPEN = (1U << 30);  ///< USART7 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART8LPEN = (1U << 31);  ///< USART8 Peripheral Clocks Enable During CSleep Mode
    }

    /// C1_APB1LLPENR Register bits
    namespace c1_apb1llpenr_bits {
        constexpr uint32_t TIM2LPEN = (1U << 0);  ///< TIM2 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM3LPEN = (1U << 1);  ///< TIM3 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM4LPEN = (1U << 2);  ///< TIM4 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM5LPEN = (1U << 3);  ///< TIM5 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM6LPEN = (1U << 4);  ///< TIM6 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM7LPEN = (1U << 5);  ///< TIM7 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM12LPEN = (1U << 6);  ///< TIM12 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM13LPEN = (1U << 7);  ///< TIM13 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM14LPEN = (1U << 8);  ///< TIM14 peripheral clock enable during CSleep mode
        constexpr uint32_t LPTIM1LPEN = (1U << 9);  ///< LPTIM1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI2LPEN = (1U << 14);  ///< SPI2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI3LPEN = (1U << 15);  ///< SPI3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPDIFRXLPEN = (1U << 16);  ///< SPDIFRX Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART2LPEN = (1U << 17);  ///< USART2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART3LPEN = (1U << 18);  ///< USART3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t UART4LPEN = (1U << 19);  ///< UART4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t UART5LPEN = (1U << 20);  ///< UART5 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C1LPEN = (1U << 21);  ///< I2C1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C2LPEN = (1U << 22);  ///< I2C2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C3LPEN = (1U << 23);  ///< I2C3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t HDMICECLPEN = (1U << 27);  ///< HDMI-CEC Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t DAC12LPEN = (1U << 29);  ///< DAC1/2 peripheral clock enable during CSleep mode
        constexpr uint32_t USART7LPEN = (1U << 30);  ///< USART7 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART8LPEN = (1U << 31);  ///< USART8 Peripheral Clocks Enable During CSleep Mode
    }

    /// C1_APB1HLPENR Register bits
    namespace c1_apb1hlpenr_bits {
        constexpr uint32_t CRSLPEN = (1U << 1);  ///< Clock Recovery System peripheral clock enable during CSleep mode
        constexpr uint32_t SWPLPEN = (1U << 2);  ///< SWPMI Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t OPAMPLPEN = (1U << 4);  ///< OPAMP peripheral clock enable during CSleep mode
        constexpr uint32_t MDIOSLPEN = (1U << 5);  ///< MDIOS peripheral clock enable during CSleep mode
        constexpr uint32_t FDCANLPEN = (1U << 8);  ///< FDCAN Peripheral Clocks Enable During CSleep Mode
    }

    /// APB1HLPENR Register bits
    namespace apb1hlpenr_bits {
        constexpr uint32_t CRSLPEN = (1U << 1);  ///< Clock Recovery System peripheral clock enable during CSleep mode
        constexpr uint32_t SWPLPEN = (1U << 2);  ///< SWPMI Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t OPAMPLPEN = (1U << 4);  ///< OPAMP peripheral clock enable during CSleep mode
        constexpr uint32_t MDIOSLPEN = (1U << 5);  ///< MDIOS peripheral clock enable during CSleep mode
        constexpr uint32_t FDCANLPEN = (1U << 8);  ///< FDCAN Peripheral Clocks Enable During CSleep Mode
    }

    /// APB2LPENR Register bits
    namespace apb2lpenr_bits {
        constexpr uint32_t TIM1LPEN = (1U << 0);  ///< TIM1 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM8LPEN = (1U << 1);  ///< TIM8 peripheral clock enable during CSleep mode
        constexpr uint32_t USART1LPEN = (1U << 4);  ///< USART1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART6LPEN = (1U << 5);  ///< USART6 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI1LPEN = (1U << 12);  ///< SPI1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI4LPEN = (1U << 13);  ///< SPI4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t TIM15LPEN = (1U << 16);  ///< TIM15 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM16LPEN = (1U << 17);  ///< TIM16 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM17LPEN = (1U << 18);  ///< TIM17 peripheral clock enable during CSleep mode
        constexpr uint32_t SPI5LPEN = (1U << 20);  ///< SPI5 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SAI1LPEN = (1U << 22);  ///< SAI1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SAI2LPEN = (1U << 23);  ///< SAI2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SAI3LPEN = (1U << 24);  ///< SAI3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t DFSDM1LPEN = (1U << 28);  ///< DFSDM1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t HRTIMLPEN = (1U << 29);  ///< HRTIM peripheral clock enable during CSleep mode
    }

    /// C1_APB2LPENR Register bits
    namespace c1_apb2lpenr_bits {
        constexpr uint32_t TIM1LPEN = (1U << 0);  ///< TIM1 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM8LPEN = (1U << 1);  ///< TIM8 peripheral clock enable during CSleep mode
        constexpr uint32_t USART1LPEN = (1U << 4);  ///< USART1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t USART6LPEN = (1U << 5);  ///< USART6 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI1LPEN = (1U << 12);  ///< SPI1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI4LPEN = (1U << 13);  ///< SPI4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t TIM15LPEN = (1U << 16);  ///< TIM15 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM16LPEN = (1U << 17);  ///< TIM16 peripheral clock enable during CSleep mode
        constexpr uint32_t TIM17LPEN = (1U << 18);  ///< TIM17 peripheral clock enable during CSleep mode
        constexpr uint32_t SPI5LPEN = (1U << 20);  ///< SPI5 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SAI1LPEN = (1U << 22);  ///< SAI1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SAI2LPEN = (1U << 23);  ///< SAI2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SAI3LPEN = (1U << 24);  ///< SAI3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t DFSDM1LPEN = (1U << 28);  ///< DFSDM1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t HRTIMLPEN = (1U << 29);  ///< HRTIM peripheral clock enable during CSleep mode
    }

    /// C1_APB4LPENR Register bits
    namespace c1_apb4lpenr_bits {
        constexpr uint32_t SYSCFGLPEN = (1U << 1);  ///< SYSCFG peripheral clock enable during CSleep mode
        constexpr uint32_t LPUART1LPEN = (1U << 3);  ///< LPUART1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI6LPEN = (1U << 5);  ///< SPI6 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C4LPEN = (1U << 7);  ///< I2C4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM2LPEN = (1U << 9);  ///< LPTIM2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM3LPEN = (1U << 10);  ///< LPTIM3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM4LPEN = (1U << 11);  ///< LPTIM4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM5LPEN = (1U << 12);  ///< LPTIM5 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t COMP12LPEN = (1U << 14);  ///< COMP1/2 peripheral clock enable during CSleep mode
        constexpr uint32_t VREFLPEN = (1U << 15);  ///< VREF peripheral clock enable during CSleep mode
        constexpr uint32_t RTCAPBLPEN = (1U << 16);  ///< RTC APB Clock Enable During CSleep Mode
        constexpr uint32_t SAI4LPEN = (1U << 21);  ///< SAI4 Peripheral Clocks Enable During CSleep Mode
    }

    /// APB4LPENR Register bits
    namespace apb4lpenr_bits {
        constexpr uint32_t SYSCFGLPEN = (1U << 1);  ///< SYSCFG peripheral clock enable during CSleep mode
        constexpr uint32_t LPUART1LPEN = (1U << 3);  ///< LPUART1 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t SPI6LPEN = (1U << 5);  ///< SPI6 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t I2C4LPEN = (1U << 7);  ///< I2C4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM2LPEN = (1U << 9);  ///< LPTIM2 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM3LPEN = (1U << 10);  ///< LPTIM3 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM4LPEN = (1U << 11);  ///< LPTIM4 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t LPTIM5LPEN = (1U << 12);  ///< LPTIM5 Peripheral Clocks Enable During CSleep Mode
        constexpr uint32_t COMP12LPEN = (1U << 14);  ///< COMP1/2 peripheral clock enable during CSleep mode
        constexpr uint32_t VREFLPEN = (1U << 15);  ///< VREF peripheral clock enable during CSleep mode
        constexpr uint32_t RTCAPBLPEN = (1U << 16);  ///< RTC APB Clock Enable During CSleep Mode
        constexpr uint32_t SAI4LPEN = (1U << 21);  ///< SAI4 Peripheral Clocks Enable During CSleep Mode
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM1_BASE = 0x40002400;
    constexpr uint32_t LPTIM2_BASE = 0x58002400;
    constexpr uint32_t LPTIM3_BASE = 0x58002800;
    constexpr uint32_t LPTIM4_BASE = 0x58002C00;
    constexpr uint32_t LPTIM5_BASE = 0x58003000;
    constexpr uint32_t HRTIM_Master_BASE = 0x40017400;
    constexpr uint32_t HRTIM_TIMA_BASE = 0x40017480;
    constexpr uint32_t HRTIM_TIMB_BASE = 0x40017500;
    constexpr uint32_t HRTIM_TIMC_BASE = 0x40017580;
    constexpr uint32_t HRTIM_TIMD_BASE = 0x40017600;
    constexpr uint32_t HRTIM_TIME_BASE = 0x40017680;
    constexpr uint32_t HRTIM_Common_BASE = 0x40017780;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t TIM1_BASE = 0x40010000;
    constexpr uint32_t TIM8_BASE = 0x40010400;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t TIM12_BASE = 0x40001800;
    constexpr uint32_t TIM13_BASE = 0x40001C00;
    constexpr uint32_t TIM14_BASE = 0x40002000;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - Interrupt and Status Register
        volatile uint32_t ICR;  ///< Offset: 0x04 - Interrupt Clear Register
        volatile uint32_t IER;  ///< Offset: 0x08 - Interrupt Enable Register
        volatile uint32_t CFGR;  ///< Offset: 0x0C - Configuration Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t CMP;  ///< Offset: 0x14 - Compare Register
        volatile uint32_t ARR;  ///< Offset: 0x18 - Autoreload Register
        volatile uint32_t CNT;  ///< Offset: 0x1C - Counter Register
        volatile uint32_t CFGR2;  ///< Offset: 0x24 - LPTIM configuration register 2
    };

    /// Peripheral instances
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* LPTIM3 = reinterpret_cast<Registers*>(LPTIM3_BASE);
    inline Registers* LPTIM4 = reinterpret_cast<Registers*>(LPTIM4_BASE);
    inline Registers* LPTIM5 = reinterpret_cast<Registers*>(LPTIM5_BASE);
    inline Registers* HRTIM_Master = reinterpret_cast<Registers*>(HRTIM_Master_BASE);
    inline Registers* HRTIM_TIMA = reinterpret_cast<Registers*>(HRTIM_TIMA_BASE);
    inline Registers* HRTIM_TIMB = reinterpret_cast<Registers*>(HRTIM_TIMB_BASE);
    inline Registers* HRTIM_TIMC = reinterpret_cast<Registers*>(HRTIM_TIMC_BASE);
    inline Registers* HRTIM_TIMD = reinterpret_cast<Registers*>(HRTIM_TIMD_BASE);
    inline Registers* HRTIM_TIME = reinterpret_cast<Registers*>(HRTIM_TIME_BASE);
    inline Registers* HRTIM_Common = reinterpret_cast<Registers*>(HRTIM_Common_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* TIM12 = reinterpret_cast<Registers*>(TIM12_BASE);
    inline Registers* TIM13 = reinterpret_cast<Registers*>(TIM13_BASE);
    inline Registers* TIM14 = reinterpret_cast<Registers*>(TIM14_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t CMPOK = (1U << 3);  ///< Compare register update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CMPM = (1U << 0);  ///< Compare match
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t CMPOKCF = (1U << 3);  ///< Compare register update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CMPMCF = (1U << 0);  ///< compare match Clear Flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t CMPOKIE = (1U << 3);  ///< Compare register update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CMPMIE = (1U << 0);  ///< Compare match Interrupt Enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode
        constexpr uint32_t WAVPOL = (1U << 21);  ///< Waveform shape polarity
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM Enable
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in single mode
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in continuous mode
        constexpr uint32_t COUNTRST = (1U << 3);  ///< Counter reset
        constexpr uint32_t RSTARE = (1U << 4);  ///< Reset after read enable
    }

    /// CMP Register bits
    namespace cmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Compare value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t IN1SEL = (2 << 0);  ///< LPTIM Input 1 selection
        constexpr uint32_t IN2SEL = (2 << 4);  ///< LPTIM Input 2 selection
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x58000C00;
    constexpr uint32_t USART1_BASE = 0x40011000;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;
    constexpr uint32_t USART6_BASE = 0x40011400;
    constexpr uint32_t UART7_BASE = 0x40007800;
    constexpr uint32_t UART8_BASE = 0x40007C00;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - Prescaler register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* USART6 = reinterpret_cast<Registers*>(USART6_BASE);
    inline Registers* UART7 = reinterpret_cast<Registers*>(UART7_BASE);
    inline Registers* UART8 = reinterpret_cast<Registers*>(UART8_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the USART node
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFIFO threshold interrupt enable
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< BRR
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO Full
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO Empty
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NE = (1U << 2);  ///< NE
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x58000400;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t PMCR;  ///< Offset: 0x04 - peripheral mode configuration register
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
        volatile uint32_t CCCSR;  ///< Offset: 0x20 - compensation cell control/status register
        volatile uint32_t CCVR;  ///< Offset: 0x24 - SYSCFG compensation cell value register
        volatile uint32_t CCCR;  ///< Offset: 0x28 - SYSCFG compensation cell code register
        volatile uint32_t PWRCR;  ///< Offset: 0x2C - SYSCFG power control register
        volatile uint32_t PKGR;  ///< Offset: 0x124 - SYSCFG package register
        volatile uint32_t UR0;  ///< Offset: 0x300 - SYSCFG user register 0
        volatile uint32_t UR2;  ///< Offset: 0x308 - SYSCFG user register 2
        volatile uint32_t UR3;  ///< Offset: 0x30C - SYSCFG user register 3
        volatile uint32_t UR4;  ///< Offset: 0x310 - SYSCFG user register 4
        volatile uint32_t UR5;  ///< Offset: 0x314 - SYSCFG user register 5
        volatile uint32_t UR6;  ///< Offset: 0x318 - SYSCFG user register 6
        volatile uint32_t UR7;  ///< Offset: 0x31C - SYSCFG user register 7
        volatile uint32_t UR8;  ///< Offset: 0x320 - SYSCFG user register 8
        volatile uint32_t UR9;  ///< Offset: 0x324 - SYSCFG user register 9
        volatile uint32_t UR10;  ///< Offset: 0x328 - SYSCFG user register 10
        volatile uint32_t UR11;  ///< Offset: 0x32C - SYSCFG user register 11
        volatile uint32_t UR12;  ///< Offset: 0x330 - SYSCFG user register 12
        volatile uint32_t UR13;  ///< Offset: 0x334 - SYSCFG user register 13
        volatile uint32_t UR14;  ///< Offset: 0x338 - SYSCFG user register 14
        volatile uint32_t UR15;  ///< Offset: 0x33C - SYSCFG user register 15
        volatile uint32_t UR16;  ///< Offset: 0x340 - SYSCFG user register 16
        volatile uint32_t UR17;  ///< Offset: 0x344 - SYSCFG user register 17
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// PMCR Register bits
    namespace pmcr_bits {
        constexpr uint32_t I2C1FMP = (1U << 0);  ///< I2C1 Fm+
        constexpr uint32_t I2C2FMP = (1U << 1);  ///< I2C2 Fm+
        constexpr uint32_t I2C3FMP = (1U << 2);  ///< I2C3 Fm+
        constexpr uint32_t I2C4FMP = (1U << 3);  ///< I2C4 Fm+
        constexpr uint32_t PB6FMP = (1U << 4);  ///< PB(6) Fm+
        constexpr uint32_t PB7FMP = (1U << 5);  ///< PB(7) Fast Mode Plus
        constexpr uint32_t PB8FMP = (1U << 6);  ///< PB(8) Fast Mode Plus
        constexpr uint32_t PB9FMP = (1U << 7);  ///< PB(9) Fm+
        constexpr uint32_t BOOSTE = (1U << 8);  ///< Booster Enable
        constexpr uint32_t BOOSTVDDSEL = (1U << 9);  ///< Analog switch supply voltage selection
        constexpr uint32_t EPIS = (3 << 21);  ///< Ethernet PHY Interface Selection
        constexpr uint32_t PA0SO = (1U << 24);  ///< PA0 Switch Open
        constexpr uint32_t PA1SO = (1U << 25);  ///< PA1 Switch Open
        constexpr uint32_t PC2SO = (1U << 26);  ///< PC2 Switch Open
        constexpr uint32_t PC3SO = (1U << 27);  ///< PC3 Switch Open
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI x configuration (x = 0 to 3)
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI x configuration (x = 4 to 7)
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI10
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI x configuration (x = 8 to 11)
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI x configuration (x = 12 to 15)
    }

    /// CCCSR Register bits
    namespace cccsr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable
        constexpr uint32_t CS = (1U << 1);  ///< Code selection
        constexpr uint32_t READY = (1U << 8);  ///< Compensation cell ready flag
        constexpr uint32_t HSLV = (1U << 16);  ///< High-speed at low-voltage
    }

    /// CCVR Register bits
    namespace ccvr_bits {
        constexpr uint32_t NCV = (4 << 0);  ///< NMOS compensation value
        constexpr uint32_t PCV = (4 << 4);  ///< PMOS compensation value
    }

    /// CCCR Register bits
    namespace cccr_bits {
        constexpr uint32_t NCC = (4 << 0);  ///< NMOS compensation code
        constexpr uint32_t PCC = (4 << 4);  ///< PMOS compensation code
    }

    /// PWRCR Register bits
    namespace pwrcr_bits {
        constexpr uint32_t ODEN = (4 << 0);  ///< Overdrive enable
    }

    /// PKGR Register bits
    namespace pkgr_bits {
        constexpr uint32_t PKG = (4 << 0);  ///< Package
    }

    /// UR0 Register bits
    namespace ur0_bits {
        constexpr uint32_t BKS = (1U << 0);  ///< Bank Swap
        constexpr uint32_t RDP = (8 << 16);  ///< Readout protection
    }

    /// UR2 Register bits
    namespace ur2_bits {
        constexpr uint32_t BORH = (2 << 0);  ///< BOR_LVL Brownout Reset Threshold Level
        constexpr uint32_t BOOT_ADD0 = (16 << 16);  ///< Boot Address 0
    }

    /// UR3 Register bits
    namespace ur3_bits {
        constexpr uint32_t BOOT_ADD1 = (16 << 16);  ///< Boot Address 1
    }

    /// UR4 Register bits
    namespace ur4_bits {
        constexpr uint32_t MEPAD_1 = (1U << 16);  ///< Mass Erase Protected Area Disabled for bank 1
    }

    /// UR5 Register bits
    namespace ur5_bits {
        constexpr uint32_t MESAD_1 = (1U << 0);  ///< Mass erase secured area disabled for bank 1
        constexpr uint32_t WRPN_1 = (8 << 16);  ///< Write protection for flash bank 1
    }

    /// UR6 Register bits
    namespace ur6_bits {
        constexpr uint32_t PA_BEG_1 = (12 << 0);  ///< Protected area start address for bank 1
        constexpr uint32_t PA_END_1 = (12 << 16);  ///< Protected area end address for bank 1
    }

    /// UR7 Register bits
    namespace ur7_bits {
        constexpr uint32_t SA_BEG_1 = (12 << 0);  ///< Secured area start address for bank 1
        constexpr uint32_t SA_END_1 = (12 << 16);  ///< Secured area end address for bank 1
    }

    /// UR8 Register bits
    namespace ur8_bits {
        constexpr uint32_t MEPAD_2 = (1U << 0);  ///< Mass erase protected area disabled for bank 2
        constexpr uint32_t MESAD_2 = (1U << 16);  ///< Mass erase secured area disabled for bank 2
    }

    /// UR9 Register bits
    namespace ur9_bits {
        constexpr uint32_t WRPN_2 = (8 << 0);  ///< Write protection for flash bank 2
        constexpr uint32_t PA_BEG_2 = (12 << 16);  ///< Protected area start address for bank 2
    }

    /// UR10 Register bits
    namespace ur10_bits {
        constexpr uint32_t PA_END_2 = (12 << 0);  ///< Protected area end address for bank 2
        constexpr uint32_t SA_BEG_2 = (12 << 16);  ///< Secured area start address for bank 2
    }

    /// UR11 Register bits
    namespace ur11_bits {
        constexpr uint32_t SA_END_2 = (12 << 0);  ///< Secured area end address for bank 2
        constexpr uint32_t IWDG1M = (1U << 16);  ///< Independent Watchdog 1 mode
    }

    /// UR12 Register bits
    namespace ur12_bits {
        constexpr uint32_t SECURE = (1U << 16);  ///< Secure mode
    }

    /// UR13 Register bits
    namespace ur13_bits {
        constexpr uint32_t SDRS = (2 << 0);  ///< Secured DTCM RAM Size
        constexpr uint32_t D1SBRST = (1U << 16);  ///< D1 Standby reset
    }

    /// UR14 Register bits
    namespace ur14_bits {
        constexpr uint32_t D1STPRST = (1U << 0);  ///< D1 Stop Reset
    }

    /// UR15 Register bits
    namespace ur15_bits {
        constexpr uint32_t FZIWDGSTB = (1U << 16);  ///< Freeze independent watchdog in Standby mode
    }

    /// UR16 Register bits
    namespace ur16_bits {
        constexpr uint32_t FZIWDGSTP = (1U << 0);  ///< Freeze independent watchdog in Stop mode
        constexpr uint32_t PKP = (1U << 16);  ///< Private key programmed
    }

    /// UR17 Register bits
    namespace ur17_bits {
        constexpr uint32_t IO_HSLV = (1U << 0);  ///< I/O high speed / low voltage
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x58000000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t D3PMR1;  ///< Offset: 0x0C - EXTI D3 pending mask register
        volatile uint32_t D3PCR1L;  ///< Offset: 0x10 - EXTI D3 pending clear selection register low
        volatile uint32_t D3PCR1H;  ///< Offset: 0x14 - EXTI D3 pending clear selection register high
        volatile uint32_t RTSR2;  ///< Offset: 0x20 - EXTI rising trigger selection register
        volatile uint32_t FTSR2;  ///< Offset: 0x24 - EXTI falling trigger selection register
        volatile uint32_t SWIER2;  ///< Offset: 0x28 - EXTI software interrupt event register
        volatile uint32_t D3PMR2;  ///< Offset: 0x2C - EXTI D3 pending mask register
        volatile uint32_t D3PCR2L;  ///< Offset: 0x30 - EXTI D3 pending clear selection register low
        volatile uint32_t D3PCR2H;  ///< Offset: 0x34 - EXTI D3 pending clear selection register high
        volatile uint32_t RTSR3;  ///< Offset: 0x40 - EXTI rising trigger selection register
        volatile uint32_t FTSR3;  ///< Offset: 0x44 - EXTI falling trigger selection register
        volatile uint32_t SWIER3;  ///< Offset: 0x48 - EXTI software interrupt event register
        volatile uint32_t D3PMR3;  ///< Offset: 0x4C - EXTI D3 pending mask register
        volatile uint32_t D3PCR3H;  ///< Offset: 0x54 - EXTI D3 pending clear selection register high
        volatile uint32_t CPUIMR1;  ///< Offset: 0x80 - EXTI interrupt mask register
        volatile uint32_t CPUEMR1;  ///< Offset: 0x84 - EXTI event mask register
        volatile uint32_t CPUPR1;  ///< Offset: 0x88 - EXTI pending register
        volatile uint32_t CPUIMR2;  ///< Offset: 0x90 - EXTI interrupt mask register
        volatile uint32_t CPUEMR2;  ///< Offset: 0x94 - EXTI event mask register
        volatile uint32_t CPUPR2;  ///< Offset: 0x98 - EXTI pending register
        volatile uint32_t CPUIMR3;  ///< Offset: 0xA0 - EXTI interrupt mask register
        volatile uint32_t CPUEMR3;  ///< Offset: 0xA4 - EXTI event mask register
        volatile uint32_t CPUPR3;  ///< Offset: 0xA8 - EXTI pending register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR19 = (1U << 19);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR20 = (1U << 20);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR21 = (1U << 21);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t TR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR19 = (1U << 19);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR20 = (1U << 20);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t TR21 = (1U << 21);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWIER0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER19 = (1U << 19);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER20 = (1U << 20);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t SWIER21 = (1U << 21);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// D3PMR1 Register bits
    namespace d3pmr1_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR19 = (1U << 19);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR20 = (1U << 20);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR21 = (1U << 21);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR25 = (1U << 25);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// D3PCR1L Register bits
    namespace d3pcr1l_bits {
        constexpr uint32_t PCS0 = (2 << 0);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS1 = (2 << 2);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS2 = (2 << 4);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS3 = (2 << 6);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS4 = (2 << 8);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS5 = (2 << 10);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS6 = (2 << 12);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS7 = (2 << 14);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS8 = (2 << 16);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS9 = (2 << 18);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS10 = (2 << 20);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS11 = (2 << 22);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS12 = (2 << 24);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS13 = (2 << 26);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS14 = (2 << 28);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
        constexpr uint32_t PCS15 = (2 << 30);  ///< D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    }

    /// D3PCR1H Register bits
    namespace d3pcr1h_bits {
        constexpr uint32_t PCS19 = (2 << 6);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
        constexpr uint32_t PCS20 = (2 << 8);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
        constexpr uint32_t PCS21 = (2 << 10);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
        constexpr uint32_t PCS25 = (2 << 18);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
    }

    /// RTSR2 Register bits
    namespace rtsr2_bits {
        constexpr uint32_t TR49 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input x+32
        constexpr uint32_t TR51 = (1U << 19);  ///< Rising trigger event configuration bit of Configurable Event input x+32
    }

    /// FTSR2 Register bits
    namespace ftsr2_bits {
        constexpr uint32_t TR49 = (1U << 17);  ///< Falling trigger event configuration bit of Configurable Event input x+32
        constexpr uint32_t TR51 = (1U << 19);  ///< Falling trigger event configuration bit of Configurable Event input x+32
    }

    /// SWIER2 Register bits
    namespace swier2_bits {
        constexpr uint32_t SWIER49 = (1U << 17);  ///< Software interrupt on line x+32
        constexpr uint32_t SWIER51 = (1U << 19);  ///< Software interrupt on line x+32
    }

    /// D3PMR2 Register bits
    namespace d3pmr2_bits {
        constexpr uint32_t MR34 = (1U << 2);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR35 = (1U << 3);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR41 = (1U << 9);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR48 = (1U << 16);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR49 = (1U << 17);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR50 = (1U << 18);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR51 = (1U << 19);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR52 = (1U << 20);  ///< D3 Pending Mask on Event input x+32
        constexpr uint32_t MR53 = (1U << 21);  ///< D3 Pending Mask on Event input x+32
    }

    /// D3PCR2L Register bits
    namespace d3pcr2l_bits {
        constexpr uint32_t PCS35 = (2 << 6);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
        constexpr uint32_t PCS34 = (2 << 4);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
        constexpr uint32_t PCS41 = (2 << 18);  ///< D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
    }

    /// D3PCR2H Register bits
    namespace d3pcr2h_bits {
        constexpr uint32_t PCS48 = (2 << 0);  ///< Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
        constexpr uint32_t PCS49 = (2 << 2);  ///< Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
        constexpr uint32_t PCS50 = (2 << 4);  ///< Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
        constexpr uint32_t PCS51 = (2 << 6);  ///< Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
        constexpr uint32_t PCS52 = (2 << 8);  ///< Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
        constexpr uint32_t PCS53 = (2 << 10);  ///< Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    }

    /// RTSR3 Register bits
    namespace rtsr3_bits {
        constexpr uint32_t TR82 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input x+64
        constexpr uint32_t TR84 = (1U << 20);  ///< Rising trigger event configuration bit of Configurable Event input x+64
        constexpr uint32_t TR85 = (1U << 21);  ///< Rising trigger event configuration bit of Configurable Event input x+64
        constexpr uint32_t TR86 = (1U << 22);  ///< Rising trigger event configuration bit of Configurable Event input x+64
    }

    /// FTSR3 Register bits
    namespace ftsr3_bits {
        constexpr uint32_t TR82 = (1U << 18);  ///< Falling trigger event configuration bit of Configurable Event input x+64
        constexpr uint32_t TR84 = (1U << 20);  ///< Falling trigger event configuration bit of Configurable Event input x+64
        constexpr uint32_t TR85 = (1U << 21);  ///< Falling trigger event configuration bit of Configurable Event input x+64
        constexpr uint32_t TR86 = (1U << 22);  ///< Falling trigger event configuration bit of Configurable Event input x+64
    }

    /// SWIER3 Register bits
    namespace swier3_bits {
        constexpr uint32_t SWIER82 = (1U << 18);  ///< Software interrupt on line x+64
        constexpr uint32_t SWIER84 = (1U << 20);  ///< Software interrupt on line x+64
        constexpr uint32_t SWIER85 = (1U << 21);  ///< Software interrupt on line x+64
        constexpr uint32_t SWIER86 = (1U << 22);  ///< Software interrupt on line x+64
    }

    /// D3PMR3 Register bits
    namespace d3pmr3_bits {
        constexpr uint32_t MR88 = (1U << 24);  ///< D3 Pending Mask on Event input x+64
    }

    /// D3PCR3H Register bits
    namespace d3pcr3h_bits {
        constexpr uint32_t PCS88 = (2 << 18);  ///< D3 Pending request clear input signal selection on Event input x= truncate N+160/2
    }

    /// CPUIMR1 Register bits
    namespace cpuimr1_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR1 = (1U << 1);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR2 = (1U << 2);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR3 = (1U << 3);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR4 = (1U << 4);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR5 = (1U << 5);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR6 = (1U << 6);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR7 = (1U << 7);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR8 = (1U << 8);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR9 = (1U << 9);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR10 = (1U << 10);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR11 = (1U << 11);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR12 = (1U << 12);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR13 = (1U << 13);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR14 = (1U << 14);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR15 = (1U << 15);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR16 = (1U << 16);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR17 = (1U << 17);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR18 = (1U << 18);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR19 = (1U << 19);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR20 = (1U << 20);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR21 = (1U << 21);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR22 = (1U << 22);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR23 = (1U << 23);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR24 = (1U << 24);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR25 = (1U << 25);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR26 = (1U << 26);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR27 = (1U << 27);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR28 = (1U << 28);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR29 = (1U << 29);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR30 = (1U << 30);  ///< Rising trigger event configuration bit of Configurable Event input
        constexpr uint32_t MR31 = (1U << 31);  ///< Rising trigger event configuration bit of Configurable Event input
    }

    /// CPUEMR1 Register bits
    namespace cpuemr1_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR1 = (1U << 1);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR2 = (1U << 2);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR3 = (1U << 3);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR4 = (1U << 4);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR5 = (1U << 5);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR6 = (1U << 6);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR7 = (1U << 7);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR8 = (1U << 8);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR9 = (1U << 9);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR10 = (1U << 10);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR11 = (1U << 11);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR12 = (1U << 12);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR13 = (1U << 13);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR14 = (1U << 14);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR15 = (1U << 15);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR16 = (1U << 16);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR17 = (1U << 17);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR18 = (1U << 18);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR19 = (1U << 19);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR20 = (1U << 20);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR21 = (1U << 21);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR22 = (1U << 22);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR23 = (1U << 23);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR24 = (1U << 24);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR25 = (1U << 25);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR26 = (1U << 26);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR27 = (1U << 27);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR28 = (1U << 28);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR29 = (1U << 29);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR30 = (1U << 30);  ///< CPU Event mask on Event input x
        constexpr uint32_t MR31 = (1U << 31);  ///< CPU Event mask on Event input x
    }

    /// CPUPR1 Register bits
    namespace cpupr1_bits {
        constexpr uint32_t PR0 = (1U << 0);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR1 = (1U << 1);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR2 = (1U << 2);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR3 = (1U << 3);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR4 = (1U << 4);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR5 = (1U << 5);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR6 = (1U << 6);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR7 = (1U << 7);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR8 = (1U << 8);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR9 = (1U << 9);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR10 = (1U << 10);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR11 = (1U << 11);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR12 = (1U << 12);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR13 = (1U << 13);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR14 = (1U << 14);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR15 = (1U << 15);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR16 = (1U << 16);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR17 = (1U << 17);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR18 = (1U << 18);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR19 = (1U << 19);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR20 = (1U << 20);  ///< CPU Event mask on Event input x
        constexpr uint32_t PR21 = (1U << 21);  ///< CPU Event mask on Event input x
    }

    /// CPUIMR2 Register bits
    namespace cpuimr2_bits {
        constexpr uint32_t MR0 = (1U << 0);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR1 = (1U << 1);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR2 = (1U << 2);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR3 = (1U << 3);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR4 = (1U << 4);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR5 = (1U << 5);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR6 = (1U << 6);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR7 = (1U << 7);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR8 = (1U << 8);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR9 = (1U << 9);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR10 = (1U << 10);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR11 = (1U << 11);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR12 = (1U << 12);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR14 = (1U << 14);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR15 = (1U << 15);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR16 = (1U << 16);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR17 = (1U << 17);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR18 = (1U << 18);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR19 = (1U << 19);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR20 = (1U << 20);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR21 = (1U << 21);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR22 = (1U << 22);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR23 = (1U << 23);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR24 = (1U << 24);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR25 = (1U << 25);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR26 = (1U << 26);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR27 = (1U << 27);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR28 = (1U << 28);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR29 = (1U << 29);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR30 = (1U << 30);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR31 = (1U << 31);  ///< CPU Interrupt Mask on Direct Event input x+32
    }

    /// CPUEMR2 Register bits
    namespace cpuemr2_bits {
        constexpr uint32_t MR32 = (1U << 0);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR33 = (1U << 1);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR34 = (1U << 2);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR35 = (1U << 3);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR36 = (1U << 4);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR37 = (1U << 5);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR38 = (1U << 6);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR39 = (1U << 7);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR40 = (1U << 8);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR41 = (1U << 9);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR42 = (1U << 10);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR43 = (1U << 11);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR44 = (1U << 12);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR46 = (1U << 14);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR47 = (1U << 15);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR48 = (1U << 16);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR49 = (1U << 17);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR50 = (1U << 18);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR51 = (1U << 19);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR52 = (1U << 20);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR53 = (1U << 21);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR54 = (1U << 22);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR55 = (1U << 23);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR56 = (1U << 24);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR57 = (1U << 25);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR58 = (1U << 26);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR59 = (1U << 27);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR60 = (1U << 28);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR61 = (1U << 29);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR62 = (1U << 30);  ///< CPU Interrupt Mask on Direct Event input x+32
        constexpr uint32_t MR63 = (1U << 31);  ///< CPU Interrupt Mask on Direct Event input x+32
    }

    /// CPUPR2 Register bits
    namespace cpupr2_bits {
        constexpr uint32_t PR49 = (1U << 17);  ///< Configurable event inputs x+32 Pending bit
        constexpr uint32_t PR51 = (1U << 19);  ///< Configurable event inputs x+32 Pending bit
    }

    /// CPUIMR3 Register bits
    namespace cpuimr3_bits {
        constexpr uint32_t MR64 = (1U << 0);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR65 = (1U << 1);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR66 = (1U << 2);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR67 = (1U << 3);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR68 = (1U << 4);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR69 = (1U << 5);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR70 = (1U << 6);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR71 = (1U << 7);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR72 = (1U << 8);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR73 = (1U << 9);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR74 = (1U << 10);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR75 = (1U << 11);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR76 = (1U << 12);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR77 = (1U << 13);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR78 = (1U << 14);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR79 = (1U << 15);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR80 = (1U << 16);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR82 = (1U << 18);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR84 = (1U << 20);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR85 = (1U << 21);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR86 = (1U << 22);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR87 = (1U << 23);  ///< CPU Interrupt Mask on Direct Event input x+64
        constexpr uint32_t MR88 = (1U << 24);  ///< CPU Interrupt Mask on Direct Event input x+64
    }

    /// CPUEMR3 Register bits
    namespace cpuemr3_bits {
        constexpr uint32_t MR64 = (1U << 0);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR65 = (1U << 1);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR66 = (1U << 2);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR67 = (1U << 3);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR68 = (1U << 4);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR69 = (1U << 5);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR70 = (1U << 6);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR71 = (1U << 7);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR72 = (1U << 8);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR73 = (1U << 9);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR74 = (1U << 10);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR75 = (1U << 11);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR76 = (1U << 12);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR77 = (1U << 13);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR78 = (1U << 14);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR79 = (1U << 15);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR80 = (1U << 16);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR82 = (1U << 18);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR84 = (1U << 20);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR85 = (1U << 21);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR86 = (1U << 22);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR87 = (1U << 23);  ///< CPU Event mask on Event input x+64
        constexpr uint32_t MR88 = (1U << 24);  ///< CPU Event mask on Event input x+64
    }

    /// CPUPR3 Register bits
    namespace cpupr3_bits {
        constexpr uint32_t PR82 = (1U << 18);  ///< Configurable event inputs x+64 Pending bit
        constexpr uint32_t PR84 = (1U << 20);  ///< Configurable event inputs x+64 Pending bit
        constexpr uint32_t PR85 = (1U << 21);  ///< Configurable event inputs x+64 Pending bit
        constexpr uint32_t PR86 = (1U << 22);  ///< Configurable event inputs x+64 Pending bit
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t Flash_BASE = 0x52002000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t ACR_;  ///< Offset: 0x100 - Access control register
        volatile uint32_t KEYR1;  ///< Offset: 0x04 - FLASH key register for bank 1
        volatile uint32_t OPTKEYR;  ///< Offset: 0x08 - FLASH option key register
        volatile uint32_t OPTKEYR_;  ///< Offset: 0x108 - FLASH option key register
        volatile uint32_t CR1;  ///< Offset: 0x0C - FLASH control register for bank 1
        volatile uint32_t SR1;  ///< Offset: 0x10 - FLASH status register for bank 1
        volatile uint32_t CCR1;  ///< Offset: 0x14 - FLASH clear control register for bank 1
        volatile uint32_t OPTCR;  ///< Offset: 0x18 - FLASH option control register
        volatile uint32_t OPTCR_;  ///< Offset: 0x118 - FLASH option control register
        volatile uint32_t OPTSR_CUR_;  ///< Offset: 0x11C - FLASH option status register
        volatile uint32_t OPTSR_CUR;  ///< Offset: 0x1C - FLASH option status register
        volatile uint32_t OPTSR_PRG;  ///< Offset: 0x20 - FLASH option status register
        volatile uint32_t OPTSR_PRG_;  ///< Offset: 0x120 - FLASH option status register
        volatile uint32_t OPTCCR_;  ///< Offset: 0x124 - FLASH option clear control register
        volatile uint32_t OPTCCR;  ///< Offset: 0x24 - FLASH option clear control register
        volatile uint32_t PRAR_CUR1;  ///< Offset: 0x28 - FLASH protection address for bank 1
        volatile uint32_t PRAR_PRG1;  ///< Offset: 0x2C - FLASH protection address for bank 1
        volatile uint32_t SCAR_CUR1;  ///< Offset: 0x30 - FLASH secure address for bank 1
        volatile uint32_t SCAR_PRG1;  ///< Offset: 0x34 - FLASH secure address for bank 1
        volatile uint32_t WPSN_CUR1R;  ///< Offset: 0x38 - FLASH write sector protection for bank 1
        volatile uint32_t WPSN_PRG1R;  ///< Offset: 0x3C - FLASH write sector protection for bank 1
        volatile uint32_t BOOT_CURR;  ///< Offset: 0x40 - FLASH register with boot address
        volatile uint32_t BOOT_PRGR;  ///< Offset: 0x44 - FLASH register with boot address
        volatile uint32_t CRCCR1;  ///< Offset: 0x50 - FLASH CRC control register for bank 1
        volatile uint32_t CRCSADD1R;  ///< Offset: 0x54 - FLASH CRC start address register for bank 1
        volatile uint32_t CRCEADD1R;  ///< Offset: 0x58 - FLASH CRC end address register for bank 1
        volatile uint32_t CRCDATAR;  ///< Offset: 0x5C - FLASH CRC data register
        volatile uint32_t ECC_FA1R;  ///< Offset: 0x60 - FLASH ECC fail address for bank 1
        volatile uint32_t KEYR2;  ///< Offset: 0x104 - FLASH key register for bank 2
        volatile uint32_t CR2;  ///< Offset: 0x10C - FLASH control register for bank 2
        volatile uint32_t SR2;  ///< Offset: 0x110 - FLASH status register for bank 2
        volatile uint32_t CCR2;  ///< Offset: 0x114 - FLASH clear control register for bank 2
        volatile uint32_t PRAR_CUR2;  ///< Offset: 0x128 - FLASH protection address for bank 1
        volatile uint32_t PRAR_PRG2;  ///< Offset: 0x2C - FLASH protection address for bank 2
        volatile uint32_t SCAR_CUR2;  ///< Offset: 0x130 - FLASH secure address for bank 2
        volatile uint32_t SCAR_PRG2;  ///< Offset: 0x134 - FLASH secure address for bank 2
        volatile uint32_t WPSN_CUR2R;  ///< Offset: 0x138 - FLASH write sector protection for bank 2
        volatile uint32_t WPSN_PRG2R;  ///< Offset: 0x13C - FLASH write sector protection for bank 2
        volatile uint32_t CRCCR2;  ///< Offset: 0x150 - FLASH CRC control register for bank 1
        volatile uint32_t CRCSADD2R;  ///< Offset: 0x154 - FLASH CRC start address register for bank 2
        volatile uint32_t CRCEADD2R;  ///< Offset: 0x158 - FLASH CRC end address register for bank 2
        volatile uint32_t ECC_FA2R;  ///< Offset: 0x160 - FLASH ECC fail address for bank 2
    };

    /// Peripheral instances
    inline Registers* Flash = reinterpret_cast<Registers*>(Flash_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Read latency
        constexpr uint32_t WRHIGHFREQ = (2 << 4);  ///< Flash signal delay
    }

    /// ACR_ Register bits
    namespace acr__bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Read latency
        constexpr uint32_t WRHIGHFREQ = (2 << 4);  ///< Flash signal delay
    }

    /// KEYR1 Register bits
    namespace keyr1_bits {
        constexpr uint32_t KEYR1 = (32 << 0);  ///< Bank 1 access configuration unlock key
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Unlock key option bytes
    }

    /// OPTKEYR_ Register bits
    namespace optkeyr__bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Unlock key option bytes
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LOCK1 = (1U << 0);  ///< Bank 1 configuration lock bit
        constexpr uint32_t PG1 = (1U << 1);  ///< Bank 1 program enable bit
        constexpr uint32_t SER1 = (1U << 2);  ///< Bank 1 sector erase request
        constexpr uint32_t BER1 = (1U << 3);  ///< Bank 1 erase request
        constexpr uint32_t PSIZE1 = (2 << 4);  ///< Bank 1 program size
        constexpr uint32_t FW1 = (1U << 6);  ///< Bank 1 write forcing control bit
        constexpr uint32_t START1 = (1U << 7);  ///< Bank 1 bank or sector erase start control bit
        constexpr uint32_t SNB1 = (3 << 8);  ///< Bank 1 sector erase selection number
        constexpr uint32_t CRC_EN = (1U << 15);  ///< Bank 1 CRC control bit
        constexpr uint32_t EOPIE1 = (1U << 16);  ///< Bank 1 end-of-program interrupt control bit
        constexpr uint32_t WRPERRIE1 = (1U << 17);  ///< Bank 1 write protection error interrupt enable bit
        constexpr uint32_t PGSERRIE1 = (1U << 18);  ///< Bank 1 programming sequence error interrupt enable bit
        constexpr uint32_t STRBERRIE1 = (1U << 19);  ///< Bank 1 strobe error interrupt enable bit
        constexpr uint32_t INCERRIE1 = (1U << 21);  ///< Bank 1 inconsistency error interrupt enable bit
        constexpr uint32_t OPERRIE1 = (1U << 22);  ///< Bank 1 write/erase error interrupt enable bit
        constexpr uint32_t RDPERRIE1 = (1U << 23);  ///< Bank 1 read protection error interrupt enable bit
        constexpr uint32_t RDSERRIE1 = (1U << 24);  ///< Bank 1 secure error interrupt enable bit
        constexpr uint32_t SNECCERRIE1 = (1U << 25);  ///< Bank 1 ECC single correction error interrupt enable bit
        constexpr uint32_t DBECCERRIE1 = (1U << 26);  ///< Bank 1 ECC double detection error interrupt enable bit
        constexpr uint32_t CRCENDIE1 = (1U << 27);  ///< Bank 1 end of CRC calculation interrupt enable bit
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t BSY1 = (1U << 0);  ///< Bank 1 ongoing program flag
        constexpr uint32_t WBNE1 = (1U << 1);  ///< Bank 1 write buffer not empty flag
        constexpr uint32_t QW1 = (1U << 2);  ///< Bank 1 wait queue flag
        constexpr uint32_t CRC_BUSY1 = (1U << 3);  ///< Bank 1 CRC busy flag
        constexpr uint32_t EOP1 = (1U << 16);  ///< Bank 1 end-of-program flag
        constexpr uint32_t WRPERR1 = (1U << 17);  ///< Bank 1 write protection error flag
        constexpr uint32_t PGSERR1 = (1U << 18);  ///< Bank 1 programming sequence error flag
        constexpr uint32_t STRBERR1 = (1U << 19);  ///< Bank 1 strobe error flag
        constexpr uint32_t INCERR1 = (1U << 21);  ///< Bank 1 inconsistency error flag
        constexpr uint32_t OPERR1 = (1U << 22);  ///< Bank 1 write/erase error flag
        constexpr uint32_t RDPERR1 = (1U << 23);  ///< Bank 1 read protection error flag
        constexpr uint32_t RDSERR1 = (1U << 24);  ///< Bank 1 secure error flag
        constexpr uint32_t SNECCERR11 = (1U << 25);  ///< Bank 1 single correction error flag
        constexpr uint32_t DBECCERR1 = (1U << 26);  ///< Bank 1 ECC double detection error flag
        constexpr uint32_t CRCEND1 = (1U << 27);  ///< Bank 1 CRC-complete flag
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CLR_EOP1 = (1U << 16);  ///< Bank 1 EOP1 flag clear bit
        constexpr uint32_t CLR_WRPERR1 = (1U << 17);  ///< Bank 1 WRPERR1 flag clear bit
        constexpr uint32_t CLR_PGSERR1 = (1U << 18);  ///< Bank 1 PGSERR1 flag clear bi
        constexpr uint32_t CLR_STRBERR1 = (1U << 19);  ///< Bank 1 STRBERR1 flag clear bit
        constexpr uint32_t CLR_INCERR1 = (1U << 21);  ///< Bank 1 INCERR1 flag clear bit
        constexpr uint32_t CLR_OPERR1 = (1U << 22);  ///< Bank 1 OPERR1 flag clear bit
        constexpr uint32_t CLR_RDPERR1 = (1U << 23);  ///< Bank 1 RDPERR1 flag clear bit
        constexpr uint32_t CLR_RDSERR1 = (1U << 24);  ///< Bank 1 RDSERR1 flag clear bit
        constexpr uint32_t CLR_SNECCERR1 = (1U << 25);  ///< Bank 1 SNECCERR1 flag clear bit
        constexpr uint32_t CLR_DBECCERR1 = (1U << 26);  ///< Bank 1 DBECCERR1 flag clear bit
        constexpr uint32_t CLR_CRCEND1 = (1U << 27);  ///< Bank 1 CRCEND1 flag clear bit
    }

    /// OPTCR Register bits
    namespace optcr_bits {
        constexpr uint32_t OPTLOCK = (1U << 0);  ///< FLASH_OPTCR lock option configuration bit
        constexpr uint32_t OPTSTART = (1U << 1);  ///< Option byte start change option configuration bit
        constexpr uint32_t MER = (1U << 4);  ///< Flash mass erase enable bit
        constexpr uint32_t OPTCHANGEERRIE = (1U << 30);  ///< Option byte change error interrupt enable bit
        constexpr uint32_t SWAP_BANK = (1U << 31);  ///< Bank swapping configuration bit
    }

    /// OPTCR_ Register bits
    namespace optcr__bits {
        constexpr uint32_t OPTLOCK = (1U << 0);  ///< FLASH_OPTCR lock option configuration bit
        constexpr uint32_t OPTSTART = (1U << 1);  ///< Option byte start change option configuration bit
        constexpr uint32_t MER = (1U << 4);  ///< Flash mass erase enable bit
        constexpr uint32_t OPTCHANGEERRIE = (1U << 30);  ///< Option byte change error interrupt enable bit
        constexpr uint32_t SWAP_BANK = (1U << 31);  ///< Bank swapping configuration bit
    }

    /// OPTSR_CUR_ Register bits
    namespace optsr_cur__bits {
        constexpr uint32_t OPT_BUSY = (1U << 0);  ///< Option byte change ongoing flag
        constexpr uint32_t BOR_LEV = (2 << 2);  ///< Brownout level option status bit
        constexpr uint32_t IWDG1_HW = (1U << 4);  ///< IWDG1 control option status bit
        constexpr uint32_t nRST_STOP_D1 = (1U << 6);  ///< D1 DStop entry reset option status bit
        constexpr uint32_t nRST_STBY_D1 = (1U << 7);  ///< D1 DStandby entry reset option status bit
        constexpr uint32_t RDP = (8 << 8);  ///< Readout protection level option status byte
        constexpr uint32_t FZ_IWDG_STOP = (1U << 17);  ///< IWDG Stop mode freeze option status bit
        constexpr uint32_t FZ_IWDG_SDBY = (1U << 18);  ///< IWDG Standby mode freeze option status bit
        constexpr uint32_t ST_RAM_SIZE = (2 << 19);  ///< DTCM RAM size option status
        constexpr uint32_t SECURITY = (1U << 21);  ///< Security enable option status bit
        constexpr uint32_t RSS1 = (1U << 26);  ///< User option bit 1
        constexpr uint32_t PERSO_OK = (1U << 28);  ///< Device personalization status bit
        constexpr uint32_t IO_HSLV = (1U << 29);  ///< I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
        constexpr uint32_t OPTCHANGEERR = (1U << 30);  ///< Option byte change error flag
        constexpr uint32_t SWAP_BANK_OPT = (1U << 31);  ///< Bank swapping option status bit
    }

    /// OPTSR_CUR Register bits
    namespace optsr_cur_bits {
        constexpr uint32_t OPT_BUSY = (1U << 0);  ///< Option byte change ongoing flag
        constexpr uint32_t BOR_LEV = (2 << 2);  ///< Brownout level option status bit
        constexpr uint32_t IWDG1_HW = (1U << 4);  ///< IWDG1 control option status bit
        constexpr uint32_t nRST_STOP_D1 = (1U << 6);  ///< D1 DStop entry reset option status bit
        constexpr uint32_t nRST_STBY_D1 = (1U << 7);  ///< D1 DStandby entry reset option status bit
        constexpr uint32_t RDP = (8 << 8);  ///< Readout protection level option status byte
        constexpr uint32_t FZ_IWDG_STOP = (1U << 17);  ///< IWDG Stop mode freeze option status bit
        constexpr uint32_t FZ_IWDG_SDBY = (1U << 18);  ///< IWDG Standby mode freeze option status bit
        constexpr uint32_t ST_RAM_SIZE = (2 << 19);  ///< DTCM RAM size option status
        constexpr uint32_t SECURITY = (1U << 21);  ///< Security enable option status bit
        constexpr uint32_t RSS1 = (1U << 26);  ///< User option bit 1
        constexpr uint32_t PERSO_OK = (1U << 28);  ///< Device personalization status bit
        constexpr uint32_t IO_HSLV = (1U << 29);  ///< I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
        constexpr uint32_t OPTCHANGEERR = (1U << 30);  ///< Option byte change error flag
        constexpr uint32_t SWAP_BANK_OPT = (1U << 31);  ///< Bank swapping option status bit
    }

    /// OPTSR_PRG Register bits
    namespace optsr_prg_bits {
        constexpr uint32_t BOR_LEV = (2 << 2);  ///< BOR reset level option configuration bits
        constexpr uint32_t IWDG1_HW = (1U << 4);  ///< IWDG1 option configuration bit
        constexpr uint32_t nRST_STOP_D1 = (1U << 6);  ///< Option byte erase after D1 DStop option configuration bit
        constexpr uint32_t nRST_STBY_D1 = (1U << 7);  ///< Option byte erase after D1 DStandby option configuration bit
        constexpr uint32_t RDP = (8 << 8);  ///< Readout protection level option configuration byte
        constexpr uint32_t FZ_IWDG_STOP = (1U << 17);  ///< IWDG Stop mode freeze option configuration bit
        constexpr uint32_t FZ_IWDG_SDBY = (1U << 18);  ///< IWDG Standby mode freeze option configuration bit
        constexpr uint32_t ST_RAM_SIZE = (2 << 19);  ///< DTCM size select option configuration bits
        constexpr uint32_t SECURITY = (1U << 21);  ///< Security option configuration bit
        constexpr uint32_t RSS1 = (1U << 26);  ///< User option configuration bit 1
        constexpr uint32_t RSS2 = (1U << 27);  ///< User option configuration bit 2
        constexpr uint32_t IO_HSLV = (1U << 29);  ///< I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
        constexpr uint32_t SWAP_BANK_OPT = (1U << 31);  ///< Bank swapping option configuration bit
    }

    /// OPTSR_PRG_ Register bits
    namespace optsr_prg__bits {
        constexpr uint32_t BOR_LEV = (2 << 2);  ///< BOR reset level option configuration bits
        constexpr uint32_t IWDG1_HW = (1U << 4);  ///< IWDG1 option configuration bit
        constexpr uint32_t nRST_STOP_D1 = (1U << 6);  ///< Option byte erase after D1 DStop option configuration bit
        constexpr uint32_t nRST_STBY_D1 = (1U << 7);  ///< Option byte erase after D1 DStandby option configuration bit
        constexpr uint32_t RDP = (8 << 8);  ///< Readout protection level option configuration byte
        constexpr uint32_t FZ_IWDG_STOP = (1U << 17);  ///< IWDG Stop mode freeze option configuration bit
        constexpr uint32_t FZ_IWDG_SDBY = (1U << 18);  ///< IWDG Standby mode freeze option configuration bit
        constexpr uint32_t ST_RAM_SIZE = (2 << 19);  ///< DTCM size select option configuration bits
        constexpr uint32_t SECURITY = (1U << 21);  ///< Security option configuration bit
        constexpr uint32_t RSS1 = (1U << 26);  ///< User option configuration bit 1
        constexpr uint32_t RSS2 = (1U << 27);  ///< User option configuration bit 2
        constexpr uint32_t IO_HSLV = (1U << 29);  ///< I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
        constexpr uint32_t SWAP_BANK_OPT = (1U << 31);  ///< Bank swapping option configuration bit
    }

    /// OPTCCR_ Register bits
    namespace optccr__bits {
        constexpr uint32_t CLR_OPTCHANGEERR = (1U << 30);  ///< OPTCHANGEERR reset bit
    }

    /// OPTCCR Register bits
    namespace optccr_bits {
        constexpr uint32_t CLR_OPTCHANGEERR = (1U << 30);  ///< OPTCHANGEERR reset bit
    }

    /// PRAR_CUR1 Register bits
    namespace prar_cur1_bits {
        constexpr uint32_t PROT_AREA_START1 = (12 << 0);  ///< Bank 1 lowest PCROP protected address
        constexpr uint32_t PROT_AREA_END1 = (12 << 16);  ///< Bank 1 highest PCROP protected address
        constexpr uint32_t DMEP1 = (1U << 31);  ///< Bank 1 PCROP protected erase enable option status bit
    }

    /// PRAR_PRG1 Register bits
    namespace prar_prg1_bits {
        constexpr uint32_t PROT_AREA_START1 = (12 << 0);  ///< Bank 1 lowest PCROP protected address configuration
        constexpr uint32_t PROT_AREA_END1 = (12 << 16);  ///< Bank 1 highest PCROP protected address configuration
        constexpr uint32_t DMEP1 = (1U << 31);  ///< Bank 1 PCROP protected erase enable option configuration bit
    }

    /// SCAR_CUR1 Register bits
    namespace scar_cur1_bits {
        constexpr uint32_t SEC_AREA_START1 = (12 << 0);  ///< Bank 1 lowest secure protected address
        constexpr uint32_t SEC_AREA_END1 = (12 << 16);  ///< Bank 1 highest secure protected address
        constexpr uint32_t DMES1 = (1U << 31);  ///< Bank 1 secure protected erase enable option status bit
    }

    /// SCAR_PRG1 Register bits
    namespace scar_prg1_bits {
        constexpr uint32_t SEC_AREA_START1 = (12 << 0);  ///< Bank 1 lowest secure protected address configuration
        constexpr uint32_t SEC_AREA_END1 = (12 << 16);  ///< Bank 1 highest secure protected address configuration
        constexpr uint32_t DMES1 = (1U << 31);  ///< Bank 1 secure protected erase enable option configuration bit
    }

    /// WPSN_CUR1R Register bits
    namespace wpsn_cur1r_bits {
        constexpr uint32_t WRPSn1 = (8 << 0);  ///< Bank 1 sector write protection option status byte
    }

    /// WPSN_PRG1R Register bits
    namespace wpsn_prg1r_bits {
        constexpr uint32_t WRPSn1 = (8 << 0);  ///< Bank 1 sector write protection configuration byte
    }

    /// BOOT_CURR Register bits
    namespace boot_curr_bits {
        constexpr uint32_t BOOT_ADD0 = (16 << 0);  ///< Boot address 0
        constexpr uint32_t BOOT_ADD1 = (16 << 16);  ///< Boot address 1
    }

    /// BOOT_PRGR Register bits
    namespace boot_prgr_bits {
        constexpr uint32_t BOOT_ADD0 = (16 << 0);  ///< Boot address 0
        constexpr uint32_t BOOT_ADD1 = (16 << 16);  ///< Boot address 1
    }

    /// CRCCR1 Register bits
    namespace crccr1_bits {
        constexpr uint32_t CRC_SECT = (3 << 0);  ///< Bank 1 CRC sector number
        constexpr uint32_t ALL_BANK = (1U << 7);  ///< Bank 1 CRC select bit
        constexpr uint32_t CRC_BY_SECT = (1U << 8);  ///< Bank 1 CRC sector mode select bit
        constexpr uint32_t ADD_SECT = (1U << 9);  ///< Bank 1 CRC sector select bit
        constexpr uint32_t CLEAN_SECT = (1U << 10);  ///< Bank 1 CRC sector list clear bit
        constexpr uint32_t START_CRC = (1U << 16);  ///< Bank 1 CRC start bit
        constexpr uint32_t CLEAN_CRC = (1U << 17);  ///< Bank 1 CRC clear bit
        constexpr uint32_t CRC_BURST = (2 << 20);  ///< Bank 1 CRC burst size
    }

    /// CRCSADD1R Register bits
    namespace crcsadd1r_bits {
        constexpr uint32_t CRC_START_ADDR = (32 << 0);  ///< CRC start address on bank 1
    }

    /// CRCEADD1R Register bits
    namespace crceadd1r_bits {
        constexpr uint32_t CRC_END_ADDR = (32 << 0);  ///< CRC end address on bank 1
    }

    /// CRCDATAR Register bits
    namespace crcdatar_bits {
        constexpr uint32_t CRC_DATA = (32 << 0);  ///< CRC result
    }

    /// ECC_FA1R Register bits
    namespace ecc_fa1r_bits {
        constexpr uint32_t FAIL_ECC_ADDR1 = (15 << 0);  ///< Bank 1 ECC error address
    }

    /// KEYR2 Register bits
    namespace keyr2_bits {
        constexpr uint32_t KEYR2 = (32 << 0);  ///< Bank 2 access configuration unlock key
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LOCK2 = (1U << 0);  ///< Bank 2 configuration lock bit
        constexpr uint32_t PG2 = (1U << 1);  ///< Bank 2 program enable bit
        constexpr uint32_t SER2 = (1U << 2);  ///< Bank 2 sector erase request
        constexpr uint32_t BER2 = (1U << 3);  ///< Bank 2 erase request
        constexpr uint32_t PSIZE2 = (2 << 4);  ///< Bank 2 program size
        constexpr uint32_t FW2 = (1U << 6);  ///< Bank 2 write forcing control bit
        constexpr uint32_t START2 = (1U << 7);  ///< Bank 2 bank or sector erase start control bit
        constexpr uint32_t SNB2 = (3 << 8);  ///< Bank 2 sector erase selection number
        constexpr uint32_t CRC_EN = (1U << 15);  ///< Bank 2 CRC control bit
        constexpr uint32_t EOPIE2 = (1U << 16);  ///< Bank 2 end-of-program interrupt control bit
        constexpr uint32_t WRPERRIE2 = (1U << 17);  ///< Bank 2 write protection error interrupt enable bit
        constexpr uint32_t PGSERRIE2 = (1U << 18);  ///< Bank 2 programming sequence error interrupt enable bit
        constexpr uint32_t STRBERRIE2 = (1U << 19);  ///< Bank 2 strobe error interrupt enable bit
        constexpr uint32_t INCERRIE2 = (1U << 21);  ///< Bank 2 inconsistency error interrupt enable bit
        constexpr uint32_t OPERRIE2 = (1U << 22);  ///< Bank 2 write/erase error interrupt enable bit
        constexpr uint32_t RDPERRIE2 = (1U << 23);  ///< Bank 2 read protection error interrupt enable bit
        constexpr uint32_t RDSERRIE2 = (1U << 24);  ///< Bank 2 secure error interrupt enable bit
        constexpr uint32_t SNECCERRIE2 = (1U << 25);  ///< Bank 2 ECC single correction error interrupt enable bit
        constexpr uint32_t DBECCERRIE2 = (1U << 26);  ///< Bank 2 ECC double detection error interrupt enable bit
        constexpr uint32_t CRCENDIE2 = (1U << 27);  ///< Bank 2 end of CRC calculation interrupt enable bit
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t BSY2 = (1U << 0);  ///< Bank 2 ongoing program flag
        constexpr uint32_t WBNE2 = (1U << 1);  ///< Bank 2 write buffer not empty flag
        constexpr uint32_t QW2 = (1U << 2);  ///< Bank 2 wait queue flag
        constexpr uint32_t CRC_BUSY2 = (1U << 3);  ///< Bank 2 CRC busy flag
        constexpr uint32_t EOP2 = (1U << 16);  ///< Bank 2 end-of-program flag
        constexpr uint32_t WRPERR2 = (1U << 17);  ///< Bank 2 write protection error flag
        constexpr uint32_t PGSERR2 = (1U << 18);  ///< Bank 2 programming sequence error flag
        constexpr uint32_t STRBERR2 = (1U << 19);  ///< Bank 2 strobe error flag
        constexpr uint32_t INCERR2 = (1U << 21);  ///< Bank 2 inconsistency error flag
        constexpr uint32_t OPERR2 = (1U << 22);  ///< Bank 2 write/erase error flag
        constexpr uint32_t RDPERR2 = (1U << 23);  ///< Bank 2 read protection error flag
        constexpr uint32_t RDSERR2 = (1U << 24);  ///< Bank 2 secure error flag
        constexpr uint32_t SNECCERR2 = (1U << 25);  ///< Bank 2 single correction error flag
        constexpr uint32_t DBECCERR2 = (1U << 26);  ///< Bank 2 ECC double detection error flag
        constexpr uint32_t CRCEND2 = (1U << 27);  ///< Bank 2 CRC-complete flag
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CLR_EOP2 = (1U << 16);  ///< Bank 1 EOP1 flag clear bit
        constexpr uint32_t CLR_WRPERR2 = (1U << 17);  ///< Bank 2 WRPERR1 flag clear bit
        constexpr uint32_t CLR_PGSERR2 = (1U << 18);  ///< Bank 2 PGSERR1 flag clear bi
        constexpr uint32_t CLR_STRBERR2 = (1U << 19);  ///< Bank 2 STRBERR1 flag clear bit
        constexpr uint32_t CLR_INCERR2 = (1U << 21);  ///< Bank 2 INCERR1 flag clear bit
        constexpr uint32_t CLR_OPERR2 = (1U << 22);  ///< Bank 2 OPERR1 flag clear bit
        constexpr uint32_t CLR_RDPERR2 = (1U << 23);  ///< Bank 2 RDPERR1 flag clear bit
        constexpr uint32_t CLR_RDSERR1 = (1U << 24);  ///< Bank 1 RDSERR1 flag clear bit
        constexpr uint32_t CLR_SNECCERR2 = (1U << 25);  ///< Bank 2 SNECCERR1 flag clear bit
        constexpr uint32_t CLR_DBECCERR1 = (1U << 26);  ///< Bank 1 DBECCERR1 flag clear bit
        constexpr uint32_t CLR_CRCEND2 = (1U << 27);  ///< Bank 2 CRCEND1 flag clear bit
    }

    /// PRAR_CUR2 Register bits
    namespace prar_cur2_bits {
        constexpr uint32_t PROT_AREA_START2 = (12 << 0);  ///< Bank 2 lowest PCROP protected address
        constexpr uint32_t PROT_AREA_END2 = (12 << 16);  ///< Bank 2 highest PCROP protected address
        constexpr uint32_t DMEP2 = (1U << 31);  ///< Bank 2 PCROP protected erase enable option status bit
    }

    /// PRAR_PRG2 Register bits
    namespace prar_prg2_bits {
        constexpr uint32_t PROT_AREA_START2 = (12 << 0);  ///< Bank 2 lowest PCROP protected address configuration
        constexpr uint32_t PROT_AREA_END2 = (12 << 16);  ///< Bank 2 highest PCROP protected address configuration
        constexpr uint32_t DMEP2 = (1U << 31);  ///< Bank 2 PCROP protected erase enable option configuration bit
    }

    /// SCAR_CUR2 Register bits
    namespace scar_cur2_bits {
        constexpr uint32_t SEC_AREA_START2 = (12 << 0);  ///< Bank 2 lowest secure protected address
        constexpr uint32_t SEC_AREA_END2 = (12 << 16);  ///< Bank 2 highest secure protected address
        constexpr uint32_t DMES2 = (1U << 31);  ///< Bank 2 secure protected erase enable option status bit
    }

    /// SCAR_PRG2 Register bits
    namespace scar_prg2_bits {
        constexpr uint32_t SEC_AREA_START2 = (12 << 0);  ///< Bank 2 lowest secure protected address configuration
        constexpr uint32_t SEC_AREA_END2 = (12 << 16);  ///< Bank 2 highest secure protected address configuration
        constexpr uint32_t DMES2 = (1U << 31);  ///< Bank 2 secure protected erase enable option configuration bit
    }

    /// WPSN_CUR2R Register bits
    namespace wpsn_cur2r_bits {
        constexpr uint32_t WRPSn2 = (8 << 0);  ///< Bank 2 sector write protection option status byte
    }

    /// WPSN_PRG2R Register bits
    namespace wpsn_prg2r_bits {
        constexpr uint32_t WRPSn2 = (8 << 0);  ///< Bank 2 sector write protection configuration byte
    }

    /// CRCCR2 Register bits
    namespace crccr2_bits {
        constexpr uint32_t CRC_SECT = (3 << 0);  ///< Bank 2 CRC sector number
        constexpr uint32_t ALL_BANK = (1U << 7);  ///< Bank 2 CRC select bit
        constexpr uint32_t CRC_BY_SECT = (1U << 8);  ///< Bank 2 CRC sector mode select bit
        constexpr uint32_t ADD_SECT = (1U << 9);  ///< Bank 2 CRC sector select bit
        constexpr uint32_t CLEAN_SECT = (1U << 10);  ///< Bank 2 CRC sector list clear bit
        constexpr uint32_t START_CRC = (1U << 16);  ///< Bank 2 CRC start bit
        constexpr uint32_t CLEAN_CRC = (1U << 17);  ///< Bank 2 CRC clear bit
        constexpr uint32_t CRC_BURST = (2 << 20);  ///< Bank 2 CRC burst size
    }

    /// CRCSADD2R Register bits
    namespace crcsadd2r_bits {
        constexpr uint32_t CRC_START_ADDR = (32 << 0);  ///< CRC start address on bank 2
    }

    /// CRCEADD2R Register bits
    namespace crceadd2r_bits {
        constexpr uint32_t CRC_END_ADDR = (32 << 0);  ///< CRC end address on bank 2
    }

    /// ECC_FA2R Register bits
    namespace ecc_fa2r_bits {
        constexpr uint32_t FAIL_ECC_ADDR2 = (15 << 0);  ///< Bank 2 ECC error address
    }

}

// ============================================================================
// AXI Peripheral
// ============================================================================

namespace axi {
    /// Base addresses
    constexpr uint32_t AXI_BASE = 0x51000000;

    /// AXI Register structure
    struct Registers {
        volatile uint32_t AXI_PERIPH_ID_4;  ///< Offset: 0x1FD0 - AXI interconnect - peripheral ID4 register
        volatile uint32_t AXI_PERIPH_ID_0;  ///< Offset: 0x1FE0 - AXI interconnect - peripheral ID0 register
        volatile uint32_t AXI_PERIPH_ID_1;  ///< Offset: 0x1FE4 - AXI interconnect - peripheral ID1 register
        volatile uint32_t AXI_PERIPH_ID_2;  ///< Offset: 0x1FE8 - AXI interconnect - peripheral ID2 register
        volatile uint32_t AXI_PERIPH_ID_3;  ///< Offset: 0x1FEC - AXI interconnect - peripheral ID3 register
        volatile uint32_t AXI_COMP_ID_0;  ///< Offset: 0x1FF0 - AXI interconnect - component ID0 register
        volatile uint32_t AXI_COMP_ID_1;  ///< Offset: 0x1FF4 - AXI interconnect - component ID1 register
        volatile uint32_t AXI_COMP_ID_2;  ///< Offset: 0x1FF8 - AXI interconnect - component ID2 register
        volatile uint32_t AXI_COMP_ID_3;  ///< Offset: 0x1FFC - AXI interconnect - component ID3 register
        volatile uint32_t AXI_TARG1_FN_MOD_ISS_BM;  ///< Offset: 0x2008 - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG2_FN_MOD_ISS_BM;  ///< Offset: 0x3008 - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG3_FN_MOD_ISS_BM;  ///< Offset: 0x4008 - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG4_FN_MOD_ISS_BM;  ///< Offset: 0x5008 - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG5_FN_MOD_ISS_BM;  ///< Offset: 0x6008 - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG6_FN_MOD_ISS_BM;  ///< Offset: 0x7008 - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG7_FN_MOD_ISS_BM;  ///< Offset: 0x800C - AXI interconnect - TARG x bus matrix issuing...
        volatile uint32_t AXI_TARG1_FN_MOD2;  ///< Offset: 0x2024 - AXI interconnect - TARG x bus matrix functionality 2 register
        volatile uint32_t AXI_TARG2_FN_MOD2;  ///< Offset: 0x3024 - AXI interconnect - TARG x bus matrix functionality 2 register
        volatile uint32_t AXI_TARG7_FN_MOD2;  ///< Offset: 0x8024 - AXI interconnect - TARG x bus matrix functionality 2 register
        volatile uint32_t AXI_TARG1_FN_MOD_LB;  ///< Offset: 0x202C - AXI interconnect - TARG x long burst functionality modification
        volatile uint32_t AXI_TARG2_FN_MOD_LB;  ///< Offset: 0x302C - AXI interconnect - TARG x long burst functionality modification
        volatile uint32_t AXI_TARG1_FN_MOD;  ///< Offset: 0x2108 - AXI interconnect - TARG x long burst functionality modification
        volatile uint32_t AXI_TARG2_FN_MOD;  ///< Offset: 0x3108 - AXI interconnect - TARG x long burst functionality modification
        volatile uint32_t AXI_TARG7_FN_MOD;  ///< Offset: 0x8108 - AXI interconnect - TARG x long burst functionality modification
        volatile uint32_t AXI_INI1_FN_MOD2;  ///< Offset: 0x42024 - AXI interconnect - INI x functionality modification 2 register
        volatile uint32_t AXI_INI3_FN_MOD2;  ///< Offset: 0x44024 - AXI interconnect - INI x functionality modification 2 register
        volatile uint32_t AXI_INI1_FN_MOD_AHB;  ///< Offset: 0x42028 - AXI interconnect - INI x AHB functionality modification register
        volatile uint32_t AXI_INI3_FN_MOD_AHB;  ///< Offset: 0x44028 - AXI interconnect - INI x AHB functionality modification register
        volatile uint32_t AXI_INI1_READ_QOS;  ///< Offset: 0x42100 - AXI interconnect - INI x read QoS register
        volatile uint32_t AXI_INI2_READ_QOS;  ///< Offset: 0x43100 - AXI interconnect - INI x read QoS register
        volatile uint32_t AXI_INI3_READ_QOS;  ///< Offset: 0x44100 - AXI interconnect - INI x read QoS register
        volatile uint32_t AXI_INI4_READ_QOS;  ///< Offset: 0x45100 - AXI interconnect - INI x read QoS register
        volatile uint32_t AXI_INI5_READ_QOS;  ///< Offset: 0x46100 - AXI interconnect - INI x read QoS register
        volatile uint32_t AXI_INI6_READ_QOS;  ///< Offset: 0x47100 - AXI interconnect - INI x read QoS register
        volatile uint32_t AXI_INI1_WRITE_QOS;  ///< Offset: 0x42104 - AXI interconnect - INI x write QoS register
        volatile uint32_t AXI_INI2_WRITE_QOS;  ///< Offset: 0x43104 - AXI interconnect - INI x write QoS register
        volatile uint32_t AXI_INI3_WRITE_QOS;  ///< Offset: 0x44104 - AXI interconnect - INI x write QoS register
        volatile uint32_t AXI_INI4_WRITE_QOS;  ///< Offset: 0x45104 - AXI interconnect - INI x write QoS register
        volatile uint32_t AXI_INI5_WRITE_QOS;  ///< Offset: 0x46104 - AXI interconnect - INI x write QoS register
        volatile uint32_t AXI_INI6_WRITE_QOS;  ///< Offset: 0x47104 - AXI interconnect - INI x write QoS register
        volatile uint32_t AXI_INI1_FN_MOD;  ///< Offset: 0x42108 - AXI interconnect - INI x issuing functionality...
        volatile uint32_t AXI_INI2_FN_MOD;  ///< Offset: 0x43108 - AXI interconnect - INI x issuing functionality...
        volatile uint32_t AXI_INI3_FN_MOD;  ///< Offset: 0x44108 - AXI interconnect - INI x issuing functionality...
        volatile uint32_t AXI_INI4_FN_MOD;  ///< Offset: 0x45108 - AXI interconnect - INI x issuing functionality...
        volatile uint32_t AXI_INI5_FN_MOD;  ///< Offset: 0x46108 - AXI interconnect - INI x issuing functionality...
        volatile uint32_t AXI_INI6_FN_MOD;  ///< Offset: 0x47108 - AXI interconnect - INI x issuing functionality...
    };

    /// Peripheral instances
    inline Registers* AXI = reinterpret_cast<Registers*>(AXI_BASE);

    // Bit definitions
    /// AXI_PERIPH_ID_4 Register bits
    namespace axi_periph_id_4_bits {
        constexpr uint32_t JEP106CON = (4 << 0);  ///< JEP106 continuation code
        constexpr uint32_t KCOUNT4 = (4 << 4);  ///< Register file size
    }

    /// AXI_PERIPH_ID_0 Register bits
    namespace axi_periph_id_0_bits {
        constexpr uint32_t PARTNUM = (8 << 0);  ///< Peripheral part number bits 0 to 7
    }

    /// AXI_PERIPH_ID_1 Register bits
    namespace axi_periph_id_1_bits {
        constexpr uint32_t PARTNUM = (4 << 0);  ///< Peripheral part number bits 8 to 11
        constexpr uint32_t JEP106I = (4 << 4);  ///< JEP106 identity bits 0 to 3
    }

    /// AXI_PERIPH_ID_2 Register bits
    namespace axi_periph_id_2_bits {
        constexpr uint32_t JEP106ID = (3 << 0);  ///< JEP106 Identity bits 4 to 6
        constexpr uint32_t JEDEC = (1U << 3);  ///< JEP106 code flag
        constexpr uint32_t REVISION = (4 << 4);  ///< Peripheral revision number
    }

    /// AXI_PERIPH_ID_3 Register bits
    namespace axi_periph_id_3_bits {
        constexpr uint32_t CUST_MOD_NUM = (4 << 0);  ///< Customer modification
        constexpr uint32_t REV_AND = (4 << 4);  ///< Customer version
    }

    /// AXI_COMP_ID_0 Register bits
    namespace axi_comp_id_0_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< Preamble bits 0 to 7
    }

    /// AXI_COMP_ID_1 Register bits
    namespace axi_comp_id_1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< Preamble bits 8 to 11
        constexpr uint32_t CLASS = (4 << 4);  ///< Component class
    }

    /// AXI_COMP_ID_2 Register bits
    namespace axi_comp_id_2_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< Preamble bits 12 to 19
    }

    /// AXI_COMP_ID_3 Register bits
    namespace axi_comp_id_3_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< Preamble bits 20 to 27
    }

    /// AXI_TARG1_FN_MOD_ISS_BM Register bits
    namespace axi_targ1_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG2_FN_MOD_ISS_BM Register bits
    namespace axi_targ2_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG3_FN_MOD_ISS_BM Register bits
    namespace axi_targ3_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG4_FN_MOD_ISS_BM Register bits
    namespace axi_targ4_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG5_FN_MOD_ISS_BM Register bits
    namespace axi_targ5_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG6_FN_MOD_ISS_BM Register bits
    namespace axi_targ6_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG7_FN_MOD_ISS_BM Register bits
    namespace axi_targ7_fn_mod_iss_bm_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< READ_ISS_OVERRIDE
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Switch matrix write issuing override for target
    }

    /// AXI_TARG1_FN_MOD2 Register bits
    namespace axi_targ1_fn_mod2_bits {
        constexpr uint32_t BYPASS_MERGE = (1U << 0);  ///< Disable packing of beats to match the output data width
    }

    /// AXI_TARG2_FN_MOD2 Register bits
    namespace axi_targ2_fn_mod2_bits {
        constexpr uint32_t BYPASS_MERGE = (1U << 0);  ///< Disable packing of beats to match the output data width
    }

    /// AXI_TARG7_FN_MOD2 Register bits
    namespace axi_targ7_fn_mod2_bits {
        constexpr uint32_t BYPASS_MERGE = (1U << 0);  ///< Disable packing of beats to match the output data width
    }

    /// AXI_TARG1_FN_MOD_LB Register bits
    namespace axi_targ1_fn_mod_lb_bits {
        constexpr uint32_t FN_MOD_LB = (1U << 0);  ///< Controls burst breaking of long bursts
    }

    /// AXI_TARG2_FN_MOD_LB Register bits
    namespace axi_targ2_fn_mod_lb_bits {
        constexpr uint32_t FN_MOD_LB = (1U << 0);  ///< Controls burst breaking of long bursts
    }

    /// AXI_TARG1_FN_MOD Register bits
    namespace axi_targ1_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override AMIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override AMIB write issuing capability
    }

    /// AXI_TARG2_FN_MOD Register bits
    namespace axi_targ2_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override AMIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override AMIB write issuing capability
    }

    /// AXI_TARG7_FN_MOD Register bits
    namespace axi_targ7_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override AMIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override AMIB write issuing capability
    }

    /// AXI_INI1_FN_MOD2 Register bits
    namespace axi_ini1_fn_mod2_bits {
        constexpr uint32_t BYPASS_MERGE = (1U << 0);  ///< Disables alteration of transactions by the up-sizer unless required by the protocol
    }

    /// AXI_INI3_FN_MOD2 Register bits
    namespace axi_ini3_fn_mod2_bits {
        constexpr uint32_t BYPASS_MERGE = (1U << 0);  ///< Disables alteration of transactions by the up-sizer unless required by the protocol
    }

    /// AXI_INI1_FN_MOD_AHB Register bits
    namespace axi_ini1_fn_mod_ahb_bits {
        constexpr uint32_t RD_INC_OVERRIDE = (1U << 0);  ///< Converts all AHB-Lite write transactions to a series of single beat AXI
        constexpr uint32_t WR_INC_OVERRIDE = (1U << 1);  ///< Converts all AHB-Lite read transactions to a series of single beat AXI
    }

    /// AXI_INI3_FN_MOD_AHB Register bits
    namespace axi_ini3_fn_mod_ahb_bits {
        constexpr uint32_t RD_INC_OVERRIDE = (1U << 0);  ///< Converts all AHB-Lite write transactions to a series of single beat AXI
        constexpr uint32_t WR_INC_OVERRIDE = (1U << 1);  ///< Converts all AHB-Lite read transactions to a series of single beat AXI
    }

    /// AXI_INI1_READ_QOS Register bits
    namespace axi_ini1_read_qos_bits {
        constexpr uint32_t AR_QOS = (4 << 0);  ///< Read channel QoS setting
    }

    /// AXI_INI2_READ_QOS Register bits
    namespace axi_ini2_read_qos_bits {
        constexpr uint32_t AR_QOS = (4 << 0);  ///< Read channel QoS setting
    }

    /// AXI_INI3_READ_QOS Register bits
    namespace axi_ini3_read_qos_bits {
        constexpr uint32_t AR_QOS = (4 << 0);  ///< Read channel QoS setting
    }

    /// AXI_INI4_READ_QOS Register bits
    namespace axi_ini4_read_qos_bits {
        constexpr uint32_t AR_QOS = (4 << 0);  ///< Read channel QoS setting
    }

    /// AXI_INI5_READ_QOS Register bits
    namespace axi_ini5_read_qos_bits {
        constexpr uint32_t AR_QOS = (4 << 0);  ///< Read channel QoS setting
    }

    /// AXI_INI6_READ_QOS Register bits
    namespace axi_ini6_read_qos_bits {
        constexpr uint32_t AR_QOS = (4 << 0);  ///< Read channel QoS setting
    }

    /// AXI_INI1_WRITE_QOS Register bits
    namespace axi_ini1_write_qos_bits {
        constexpr uint32_t AW_QOS = (4 << 0);  ///< Write channel QoS setting
    }

    /// AXI_INI2_WRITE_QOS Register bits
    namespace axi_ini2_write_qos_bits {
        constexpr uint32_t AW_QOS = (4 << 0);  ///< Write channel QoS setting
    }

    /// AXI_INI3_WRITE_QOS Register bits
    namespace axi_ini3_write_qos_bits {
        constexpr uint32_t AW_QOS = (4 << 0);  ///< Write channel QoS setting
    }

    /// AXI_INI4_WRITE_QOS Register bits
    namespace axi_ini4_write_qos_bits {
        constexpr uint32_t AW_QOS = (4 << 0);  ///< Write channel QoS setting
    }

    /// AXI_INI5_WRITE_QOS Register bits
    namespace axi_ini5_write_qos_bits {
        constexpr uint32_t AW_QOS = (4 << 0);  ///< Write channel QoS setting
    }

    /// AXI_INI6_WRITE_QOS Register bits
    namespace axi_ini6_write_qos_bits {
        constexpr uint32_t AW_QOS = (4 << 0);  ///< Write channel QoS setting
    }

    /// AXI_INI1_FN_MOD Register bits
    namespace axi_ini1_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override ASIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override ASIB write issuing capability
    }

    /// AXI_INI2_FN_MOD Register bits
    namespace axi_ini2_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override ASIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override ASIB write issuing capability
    }

    /// AXI_INI3_FN_MOD Register bits
    namespace axi_ini3_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override ASIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override ASIB write issuing capability
    }

    /// AXI_INI4_FN_MOD Register bits
    namespace axi_ini4_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override ASIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override ASIB write issuing capability
    }

    /// AXI_INI5_FN_MOD Register bits
    namespace axi_ini5_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override ASIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override ASIB write issuing capability
    }

    /// AXI_INI6_FN_MOD Register bits
    namespace axi_ini6_fn_mod_bits {
        constexpr uint32_t READ_ISS_OVERRIDE = (1U << 0);  ///< Override ASIB read issuing capability
        constexpr uint32_t WRITE_ISS_OVERRIDE = (1U << 1);  ///< Override ASIB write issuing capability
    }

}

// ============================================================================
// HASH Peripheral
// ============================================================================

namespace hash {
    /// Base addresses
    constexpr uint32_t HASH_BASE = 0x48021400;

    /// HASH Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DIN;  ///< Offset: 0x04 - data input register
        volatile uint32_t STR;  ///< Offset: 0x08 - start register
        volatile uint32_t HR0;  ///< Offset: 0x0C - digest registers
        volatile uint32_t HR1;  ///< Offset: 0x10 - digest registers
        volatile uint32_t HR2;  ///< Offset: 0x14 - digest registers
        volatile uint32_t HR3;  ///< Offset: 0x18 - digest registers
        volatile uint32_t HR4;  ///< Offset: 0x1C - digest registers
        volatile uint32_t IMR;  ///< Offset: 0x20 - interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x24 - status register
        volatile uint32_t CSR0;  ///< Offset: 0xF8 - context swap registers
        volatile uint32_t CSR1;  ///< Offset: 0xFC - context swap registers
        volatile uint32_t CSR2;  ///< Offset: 0x100 - context swap registers
        volatile uint32_t CSR3;  ///< Offset: 0x104 - context swap registers
        volatile uint32_t CSR4;  ///< Offset: 0x108 - context swap registers
        volatile uint32_t CSR5;  ///< Offset: 0x10C - context swap registers
        volatile uint32_t CSR6;  ///< Offset: 0x110 - context swap registers
        volatile uint32_t CSR7;  ///< Offset: 0x114 - context swap registers
        volatile uint32_t CSR8;  ///< Offset: 0x118 - context swap registers
        volatile uint32_t CSR9;  ///< Offset: 0x11C - context swap registers
        volatile uint32_t CSR10;  ///< Offset: 0x120 - context swap registers
        volatile uint32_t CSR11;  ///< Offset: 0x124 - context swap registers
        volatile uint32_t CSR12;  ///< Offset: 0x128 - context swap registers
        volatile uint32_t CSR13;  ///< Offset: 0x12C - context swap registers
        volatile uint32_t CSR14;  ///< Offset: 0x130 - context swap registers
        volatile uint32_t CSR15;  ///< Offset: 0x134 - context swap registers
        volatile uint32_t CSR16;  ///< Offset: 0x138 - context swap registers
        volatile uint32_t CSR17;  ///< Offset: 0x13C - context swap registers
        volatile uint32_t CSR18;  ///< Offset: 0x140 - context swap registers
        volatile uint32_t CSR19;  ///< Offset: 0x144 - context swap registers
        volatile uint32_t CSR20;  ///< Offset: 0x148 - context swap registers
        volatile uint32_t CSR21;  ///< Offset: 0x14C - context swap registers
        volatile uint32_t CSR22;  ///< Offset: 0x150 - context swap registers
        volatile uint32_t CSR23;  ///< Offset: 0x154 - context swap registers
        volatile uint32_t CSR24;  ///< Offset: 0x158 - context swap registers
        volatile uint32_t CSR25;  ///< Offset: 0x15C - context swap registers
        volatile uint32_t CSR26;  ///< Offset: 0x160 - context swap registers
        volatile uint32_t CSR27;  ///< Offset: 0x164 - context swap registers
        volatile uint32_t CSR28;  ///< Offset: 0x168 - context swap registers
        volatile uint32_t CSR29;  ///< Offset: 0x16C - context swap registers
        volatile uint32_t CSR30;  ///< Offset: 0x170 - context swap registers
        volatile uint32_t CSR31;  ///< Offset: 0x174 - context swap registers
        volatile uint32_t CSR32;  ///< Offset: 0x178 - context swap registers
        volatile uint32_t CSR33;  ///< Offset: 0x17C - context swap registers
        volatile uint32_t CSR34;  ///< Offset: 0x180 - context swap registers
        volatile uint32_t CSR35;  ///< Offset: 0x184 - context swap registers
        volatile uint32_t CSR36;  ///< Offset: 0x188 - context swap registers
        volatile uint32_t CSR37;  ///< Offset: 0x18C - context swap registers
        volatile uint32_t CSR38;  ///< Offset: 0x190 - context swap registers
        volatile uint32_t CSR39;  ///< Offset: 0x194 - context swap registers
        volatile uint32_t CSR40;  ///< Offset: 0x198 - context swap registers
        volatile uint32_t CSR41;  ///< Offset: 0x19C - context swap registers
        volatile uint32_t CSR42;  ///< Offset: 0x1A0 - context swap registers
        volatile uint32_t CSR43;  ///< Offset: 0x1A4 - context swap registers
        volatile uint32_t CSR44;  ///< Offset: 0x1A8 - context swap registers
        volatile uint32_t CSR45;  ///< Offset: 0x1AC - context swap registers
        volatile uint32_t CSR46;  ///< Offset: 0x1B0 - context swap registers
        volatile uint32_t CSR47;  ///< Offset: 0x1B4 - context swap registers
        volatile uint32_t CSR48;  ///< Offset: 0x1B8 - context swap registers
        volatile uint32_t CSR49;  ///< Offset: 0x1BC - context swap registers
        volatile uint32_t CSR50;  ///< Offset: 0x1C0 - context swap registers
        volatile uint32_t CSR51;  ///< Offset: 0x1C4 - context swap registers
        volatile uint32_t CSR52;  ///< Offset: 0x1C8 - context swap registers
        volatile uint32_t CSR53;  ///< Offset: 0x1CC - context swap registers
        volatile uint32_t HASH_HR0;  ///< Offset: 0x310 - HASH digest register
        volatile uint32_t HASH_HR1;  ///< Offset: 0x314 - read-only
        volatile uint32_t HASH_HR2;  ///< Offset: 0x318 - read-only
        volatile uint32_t HASH_HR3;  ///< Offset: 0x31C - read-only
        volatile uint32_t HASH_HR4;  ///< Offset: 0x320 - read-only
        volatile uint32_t HASH_HR5;  ///< Offset: 0x324 - read-only
        volatile uint32_t HASH_HR6;  ///< Offset: 0x328 - read-only
        volatile uint32_t HASH_HR7;  ///< Offset: 0x32C - read-only
    };

    /// Peripheral instances
    inline Registers* HASH = reinterpret_cast<Registers*>(HASH_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t INIT = (1U << 2);  ///< Initialize message digest calculation
        constexpr uint32_t DMAE = (1U << 3);  ///< DMA enable
        constexpr uint32_t DATATYPE = (2 << 4);  ///< Data type selection
        constexpr uint32_t MODE = (1U << 6);  ///< Mode selection
        constexpr uint32_t ALGO0 = (1U << 7);  ///< Algorithm selection
        constexpr uint32_t NBW = (4 << 8);  ///< Number of words already pushed
        constexpr uint32_t DINNE = (1U << 12);  ///< DIN not empty
        constexpr uint32_t MDMAT = (1U << 13);  ///< Multiple DMA Transfers
        constexpr uint32_t LKEY = (1U << 16);  ///< Long key selection
        constexpr uint32_t ALGO1 = (1U << 18);  ///< ALGO
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data input
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t DCAL = (1U << 8);  ///< Digest calculation
        constexpr uint32_t NBLW = (5 << 0);  ///< Number of valid bits in the last word of the message
    }

    /// HR0 Register bits
    namespace hr0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HR1 Register bits
    namespace hr1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HR2 Register bits
    namespace hr2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HR3 Register bits
    namespace hr3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HR4 Register bits
    namespace hr4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t DCIE = (1U << 1);  ///< Digest calculation completion interrupt enable
        constexpr uint32_t DINIE = (1U << 0);  ///< Data input interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy bit
        constexpr uint32_t DMAS = (1U << 2);  ///< DMA Status
        constexpr uint32_t DCIS = (1U << 1);  ///< Digest calculation completion interrupt status
        constexpr uint32_t DINIS = (1U << 0);  ///< Data input interrupt status
    }

    /// CSR0 Register bits
    namespace csr0_bits {
        constexpr uint32_t CSR0 = (32 << 0);  ///< CSR0
    }

    /// CSR1 Register bits
    namespace csr1_bits {
        constexpr uint32_t CSR1 = (32 << 0);  ///< CSR1
    }

    /// CSR2 Register bits
    namespace csr2_bits {
        constexpr uint32_t CSR2 = (32 << 0);  ///< CSR2
    }

    /// CSR3 Register bits
    namespace csr3_bits {
        constexpr uint32_t CSR3 = (32 << 0);  ///< CSR3
    }

    /// CSR4 Register bits
    namespace csr4_bits {
        constexpr uint32_t CSR4 = (32 << 0);  ///< CSR4
    }

    /// CSR5 Register bits
    namespace csr5_bits {
        constexpr uint32_t CSR5 = (32 << 0);  ///< CSR5
    }

    /// CSR6 Register bits
    namespace csr6_bits {
        constexpr uint32_t CSR6 = (32 << 0);  ///< CSR6
    }

    /// CSR7 Register bits
    namespace csr7_bits {
        constexpr uint32_t CSR7 = (32 << 0);  ///< CSR7
    }

    /// CSR8 Register bits
    namespace csr8_bits {
        constexpr uint32_t CSR8 = (32 << 0);  ///< CSR8
    }

    /// CSR9 Register bits
    namespace csr9_bits {
        constexpr uint32_t CSR9 = (32 << 0);  ///< CSR9
    }

    /// CSR10 Register bits
    namespace csr10_bits {
        constexpr uint32_t CSR10 = (32 << 0);  ///< CSR10
    }

    /// CSR11 Register bits
    namespace csr11_bits {
        constexpr uint32_t CSR11 = (32 << 0);  ///< CSR11
    }

    /// CSR12 Register bits
    namespace csr12_bits {
        constexpr uint32_t CSR12 = (32 << 0);  ///< CSR12
    }

    /// CSR13 Register bits
    namespace csr13_bits {
        constexpr uint32_t CSR13 = (32 << 0);  ///< CSR13
    }

    /// CSR14 Register bits
    namespace csr14_bits {
        constexpr uint32_t CSR14 = (32 << 0);  ///< CSR14
    }

    /// CSR15 Register bits
    namespace csr15_bits {
        constexpr uint32_t CSR15 = (32 << 0);  ///< CSR15
    }

    /// CSR16 Register bits
    namespace csr16_bits {
        constexpr uint32_t CSR16 = (32 << 0);  ///< CSR16
    }

    /// CSR17 Register bits
    namespace csr17_bits {
        constexpr uint32_t CSR17 = (32 << 0);  ///< CSR17
    }

    /// CSR18 Register bits
    namespace csr18_bits {
        constexpr uint32_t CSR18 = (32 << 0);  ///< CSR18
    }

    /// CSR19 Register bits
    namespace csr19_bits {
        constexpr uint32_t CSR19 = (32 << 0);  ///< CSR19
    }

    /// CSR20 Register bits
    namespace csr20_bits {
        constexpr uint32_t CSR20 = (32 << 0);  ///< CSR20
    }

    /// CSR21 Register bits
    namespace csr21_bits {
        constexpr uint32_t CSR21 = (32 << 0);  ///< CSR21
    }

    /// CSR22 Register bits
    namespace csr22_bits {
        constexpr uint32_t CSR22 = (32 << 0);  ///< CSR22
    }

    /// CSR23 Register bits
    namespace csr23_bits {
        constexpr uint32_t CSR23 = (32 << 0);  ///< CSR23
    }

    /// CSR24 Register bits
    namespace csr24_bits {
        constexpr uint32_t CSR24 = (32 << 0);  ///< CSR24
    }

    /// CSR25 Register bits
    namespace csr25_bits {
        constexpr uint32_t CSR25 = (32 << 0);  ///< CSR25
    }

    /// CSR26 Register bits
    namespace csr26_bits {
        constexpr uint32_t CSR26 = (32 << 0);  ///< CSR26
    }

    /// CSR27 Register bits
    namespace csr27_bits {
        constexpr uint32_t CSR27 = (32 << 0);  ///< CSR27
    }

    /// CSR28 Register bits
    namespace csr28_bits {
        constexpr uint32_t CSR28 = (32 << 0);  ///< CSR28
    }

    /// CSR29 Register bits
    namespace csr29_bits {
        constexpr uint32_t CSR29 = (32 << 0);  ///< CSR29
    }

    /// CSR30 Register bits
    namespace csr30_bits {
        constexpr uint32_t CSR30 = (32 << 0);  ///< CSR30
    }

    /// CSR31 Register bits
    namespace csr31_bits {
        constexpr uint32_t CSR31 = (32 << 0);  ///< CSR31
    }

    /// CSR32 Register bits
    namespace csr32_bits {
        constexpr uint32_t CSR32 = (32 << 0);  ///< CSR32
    }

    /// CSR33 Register bits
    namespace csr33_bits {
        constexpr uint32_t CSR33 = (32 << 0);  ///< CSR33
    }

    /// CSR34 Register bits
    namespace csr34_bits {
        constexpr uint32_t CSR34 = (32 << 0);  ///< CSR34
    }

    /// CSR35 Register bits
    namespace csr35_bits {
        constexpr uint32_t CSR35 = (32 << 0);  ///< CSR35
    }

    /// CSR36 Register bits
    namespace csr36_bits {
        constexpr uint32_t CSR36 = (32 << 0);  ///< CSR36
    }

    /// CSR37 Register bits
    namespace csr37_bits {
        constexpr uint32_t CSR37 = (32 << 0);  ///< CSR37
    }

    /// CSR38 Register bits
    namespace csr38_bits {
        constexpr uint32_t CSR38 = (32 << 0);  ///< CSR38
    }

    /// CSR39 Register bits
    namespace csr39_bits {
        constexpr uint32_t CSR39 = (32 << 0);  ///< CSR39
    }

    /// CSR40 Register bits
    namespace csr40_bits {
        constexpr uint32_t CSR40 = (32 << 0);  ///< CSR40
    }

    /// CSR41 Register bits
    namespace csr41_bits {
        constexpr uint32_t CSR41 = (32 << 0);  ///< CSR41
    }

    /// CSR42 Register bits
    namespace csr42_bits {
        constexpr uint32_t CSR42 = (32 << 0);  ///< CSR42
    }

    /// CSR43 Register bits
    namespace csr43_bits {
        constexpr uint32_t CSR43 = (32 << 0);  ///< CSR43
    }

    /// CSR44 Register bits
    namespace csr44_bits {
        constexpr uint32_t CSR44 = (32 << 0);  ///< CSR44
    }

    /// CSR45 Register bits
    namespace csr45_bits {
        constexpr uint32_t CSR45 = (32 << 0);  ///< CSR45
    }

    /// CSR46 Register bits
    namespace csr46_bits {
        constexpr uint32_t CSR46 = (32 << 0);  ///< CSR46
    }

    /// CSR47 Register bits
    namespace csr47_bits {
        constexpr uint32_t CSR47 = (32 << 0);  ///< CSR47
    }

    /// CSR48 Register bits
    namespace csr48_bits {
        constexpr uint32_t CSR48 = (32 << 0);  ///< CSR48
    }

    /// CSR49 Register bits
    namespace csr49_bits {
        constexpr uint32_t CSR49 = (32 << 0);  ///< CSR49
    }

    /// CSR50 Register bits
    namespace csr50_bits {
        constexpr uint32_t CSR50 = (32 << 0);  ///< CSR50
    }

    /// CSR51 Register bits
    namespace csr51_bits {
        constexpr uint32_t CSR51 = (32 << 0);  ///< CSR51
    }

    /// CSR52 Register bits
    namespace csr52_bits {
        constexpr uint32_t CSR52 = (32 << 0);  ///< CSR52
    }

    /// CSR53 Register bits
    namespace csr53_bits {
        constexpr uint32_t CSR53 = (32 << 0);  ///< CSR53
    }

    /// HASH_HR0 Register bits
    namespace hash_hr0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HASH_HR1 Register bits
    namespace hash_hr1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HASH_HR2 Register bits
    namespace hash_hr2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HASH_HR3 Register bits
    namespace hash_hr3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HASH_HR4 Register bits
    namespace hash_hr4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HASH_HR5 Register bits
    namespace hash_hr5_bits {
        constexpr uint32_t H5 = (32 << 0);  ///< H5
    }

    /// HASH_HR6 Register bits
    namespace hash_hr6_bits {
        constexpr uint32_t H6 = (32 << 0);  ///< H6
    }

    /// HASH_HR7 Register bits
    namespace hash_hr7_bits {
        constexpr uint32_t H7 = (32 << 0);  ///< H7
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t CRYP_BASE = 0x48021000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DIN;  ///< Offset: 0x08 - data input register
        volatile uint32_t DOUT;  ///< Offset: 0x0C - data output register
        volatile uint32_t DMACR;  ///< Offset: 0x10 - DMA control register
        volatile uint32_t IMSCR;  ///< Offset: 0x14 - interrupt mask set/clear register
        volatile uint32_t RISR;  ///< Offset: 0x18 - raw interrupt status register
        volatile uint32_t MISR;  ///< Offset: 0x1C - masked interrupt status register
        volatile uint32_t K0LR;  ///< Offset: 0x20 - key registers
        volatile uint32_t K0RR;  ///< Offset: 0x24 - key registers
        volatile uint32_t K1LR;  ///< Offset: 0x28 - key registers
        volatile uint32_t K1RR;  ///< Offset: 0x2C - key registers
        volatile uint32_t K2LR;  ///< Offset: 0x30 - key registers
        volatile uint32_t K2RR;  ///< Offset: 0x34 - key registers
        volatile uint32_t K3LR;  ///< Offset: 0x38 - key registers
        volatile uint32_t K3RR;  ///< Offset: 0x3C - key registers
        volatile uint32_t IV0LR;  ///< Offset: 0x40 - initialization vector registers
        volatile uint32_t IV0RR;  ///< Offset: 0x44 - initialization vector registers
        volatile uint32_t IV1LR;  ///< Offset: 0x48 - initialization vector registers
        volatile uint32_t IV1RR;  ///< Offset: 0x4C - initialization vector registers
        volatile uint32_t CSGCMCCM0R;  ///< Offset: 0x50 - context swap register
        volatile uint32_t CSGCMCCM1R;  ///< Offset: 0x54 - context swap register
        volatile uint32_t CSGCMCCM2R;  ///< Offset: 0x58 - context swap register
        volatile uint32_t CSGCMCCM3R;  ///< Offset: 0x5C - context swap register
        volatile uint32_t CSGCMCCM4R;  ///< Offset: 0x60 - context swap register
        volatile uint32_t CSGCMCCM5R;  ///< Offset: 0x64 - context swap register
        volatile uint32_t CSGCMCCM6R;  ///< Offset: 0x68 - context swap register
        volatile uint32_t CSGCMCCM7R;  ///< Offset: 0x6C - context swap register
        volatile uint32_t CSGCM0R;  ///< Offset: 0x70 - context swap register
        volatile uint32_t CSGCM1R;  ///< Offset: 0x74 - context swap register
        volatile uint32_t CSGCM2R;  ///< Offset: 0x78 - context swap register
        volatile uint32_t CSGCM3R;  ///< Offset: 0x7C - context swap register
        volatile uint32_t CSGCM4R;  ///< Offset: 0x80 - context swap register
        volatile uint32_t CSGCM5R;  ///< Offset: 0x84 - context swap register
        volatile uint32_t CSGCM6R;  ///< Offset: 0x88 - context swap register
        volatile uint32_t CSGCM7R;  ///< Offset: 0x8C - context swap register
    };

    /// Peripheral instances
    inline Registers* CRYP = reinterpret_cast<Registers*>(CRYP_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ALGODIR = (1U << 2);  ///< Algorithm direction
        constexpr uint32_t ALGOMODE0 = (3 << 3);  ///< Algorithm mode
        constexpr uint32_t DATATYPE = (2 << 6);  ///< Data type selection
        constexpr uint32_t KEYSIZE = (2 << 8);  ///< Key size selection (AES mode only)
        constexpr uint32_t FFLUSH = (1U << 14);  ///< FIFO flush
        constexpr uint32_t CRYPEN = (1U << 15);  ///< Cryptographic processor enable
        constexpr uint32_t GCM_CCMPH = (2 << 16);  ///< GCM_CCMPH
        constexpr uint32_t ALGOMODE3 = (1U << 19);  ///< ALGOMODE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 4);  ///< Busy bit
        constexpr uint32_t OFFU = (1U << 3);  ///< Output FIFO full
        constexpr uint32_t OFNE = (1U << 2);  ///< Output FIFO not empty
        constexpr uint32_t IFNF = (1U << 1);  ///< Input FIFO not full
        constexpr uint32_t IFEM = (1U << 0);  ///< Input FIFO empty
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data input
    }

    /// DOUT Register bits
    namespace dout_bits {
        constexpr uint32_t DATAOUT = (32 << 0);  ///< Data output
    }

    /// DMACR Register bits
    namespace dmacr_bits {
        constexpr uint32_t DOEN = (1U << 1);  ///< DMA output enable
        constexpr uint32_t DIEN = (1U << 0);  ///< DMA input enable
    }

    /// IMSCR Register bits
    namespace imscr_bits {
        constexpr uint32_t OUTIM = (1U << 1);  ///< Output FIFO service interrupt mask
        constexpr uint32_t INIM = (1U << 0);  ///< Input FIFO service interrupt mask
    }

    /// RISR Register bits
    namespace risr_bits {
        constexpr uint32_t OUTRIS = (1U << 1);  ///< Output FIFO service raw interrupt status
        constexpr uint32_t INRIS = (1U << 0);  ///< Input FIFO service raw interrupt status
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t OUTMIS = (1U << 1);  ///< Output FIFO service masked interrupt status
        constexpr uint32_t INMIS = (1U << 0);  ///< Input FIFO service masked interrupt status
    }

    /// K0LR Register bits
    namespace k0lr_bits {
        constexpr uint32_t K224 = (1U << 0);  ///< K224
        constexpr uint32_t K225 = (1U << 1);  ///< K225
        constexpr uint32_t K226 = (1U << 2);  ///< K226
        constexpr uint32_t K227 = (1U << 3);  ///< K227
        constexpr uint32_t K228 = (1U << 4);  ///< K228
        constexpr uint32_t K229 = (1U << 5);  ///< K229
        constexpr uint32_t K230 = (1U << 6);  ///< K230
        constexpr uint32_t K231 = (1U << 7);  ///< K231
        constexpr uint32_t K232 = (1U << 8);  ///< K232
        constexpr uint32_t K233 = (1U << 9);  ///< K233
        constexpr uint32_t K234 = (1U << 10);  ///< K234
        constexpr uint32_t K235 = (1U << 11);  ///< K235
        constexpr uint32_t K236 = (1U << 12);  ///< K236
        constexpr uint32_t K237 = (1U << 13);  ///< K237
        constexpr uint32_t K238 = (1U << 14);  ///< K238
        constexpr uint32_t K239 = (1U << 15);  ///< K239
        constexpr uint32_t K240 = (1U << 16);  ///< K240
        constexpr uint32_t K241 = (1U << 17);  ///< K241
        constexpr uint32_t K242 = (1U << 18);  ///< K242
        constexpr uint32_t K243 = (1U << 19);  ///< K243
        constexpr uint32_t K244 = (1U << 20);  ///< K244
        constexpr uint32_t K245 = (1U << 21);  ///< K245
        constexpr uint32_t K246 = (1U << 22);  ///< K246
        constexpr uint32_t K247 = (1U << 23);  ///< K247
        constexpr uint32_t K248 = (1U << 24);  ///< K248
        constexpr uint32_t K249 = (1U << 25);  ///< K249
        constexpr uint32_t K250 = (1U << 26);  ///< K250
        constexpr uint32_t K251 = (1U << 27);  ///< K251
        constexpr uint32_t K252 = (1U << 28);  ///< K252
        constexpr uint32_t K253 = (1U << 29);  ///< K253
        constexpr uint32_t K254 = (1U << 30);  ///< K254
        constexpr uint32_t K255 = (1U << 31);  ///< K255
    }

    /// K0RR Register bits
    namespace k0rr_bits {
        constexpr uint32_t K192 = (1U << 0);  ///< K192
        constexpr uint32_t K193 = (1U << 1);  ///< K193
        constexpr uint32_t K194 = (1U << 2);  ///< K194
        constexpr uint32_t K195 = (1U << 3);  ///< K195
        constexpr uint32_t K196 = (1U << 4);  ///< K196
        constexpr uint32_t K197 = (1U << 5);  ///< K197
        constexpr uint32_t K198 = (1U << 6);  ///< K198
        constexpr uint32_t K199 = (1U << 7);  ///< K199
        constexpr uint32_t K200 = (1U << 8);  ///< K200
        constexpr uint32_t K201 = (1U << 9);  ///< K201
        constexpr uint32_t K202 = (1U << 10);  ///< K202
        constexpr uint32_t K203 = (1U << 11);  ///< K203
        constexpr uint32_t K204 = (1U << 12);  ///< K204
        constexpr uint32_t K205 = (1U << 13);  ///< K205
        constexpr uint32_t K206 = (1U << 14);  ///< K206
        constexpr uint32_t K207 = (1U << 15);  ///< K207
        constexpr uint32_t K208 = (1U << 16);  ///< K208
        constexpr uint32_t K209 = (1U << 17);  ///< K209
        constexpr uint32_t K210 = (1U << 18);  ///< K210
        constexpr uint32_t K211 = (1U << 19);  ///< K211
        constexpr uint32_t K212 = (1U << 20);  ///< K212
        constexpr uint32_t K213 = (1U << 21);  ///< K213
        constexpr uint32_t K214 = (1U << 22);  ///< K214
        constexpr uint32_t K215 = (1U << 23);  ///< K215
        constexpr uint32_t K216 = (1U << 24);  ///< K216
        constexpr uint32_t K217 = (1U << 25);  ///< K217
        constexpr uint32_t K218 = (1U << 26);  ///< K218
        constexpr uint32_t K219 = (1U << 27);  ///< K219
        constexpr uint32_t K220 = (1U << 28);  ///< K220
        constexpr uint32_t K221 = (1U << 29);  ///< K221
        constexpr uint32_t K222 = (1U << 30);  ///< K222
        constexpr uint32_t K223 = (1U << 31);  ///< K223
    }

    /// K1LR Register bits
    namespace k1lr_bits {
        constexpr uint32_t K160 = (1U << 0);  ///< K160
        constexpr uint32_t K161 = (1U << 1);  ///< K161
        constexpr uint32_t K162 = (1U << 2);  ///< K162
        constexpr uint32_t K163 = (1U << 3);  ///< K163
        constexpr uint32_t K164 = (1U << 4);  ///< K164
        constexpr uint32_t K165 = (1U << 5);  ///< K165
        constexpr uint32_t K166 = (1U << 6);  ///< K166
        constexpr uint32_t K167 = (1U << 7);  ///< K167
        constexpr uint32_t K168 = (1U << 8);  ///< K168
        constexpr uint32_t K169 = (1U << 9);  ///< K169
        constexpr uint32_t K170 = (1U << 10);  ///< K170
        constexpr uint32_t K171 = (1U << 11);  ///< K171
        constexpr uint32_t K172 = (1U << 12);  ///< K172
        constexpr uint32_t K173 = (1U << 13);  ///< K173
        constexpr uint32_t K174 = (1U << 14);  ///< K174
        constexpr uint32_t K175 = (1U << 15);  ///< K175
        constexpr uint32_t K176 = (1U << 16);  ///< K176
        constexpr uint32_t K177 = (1U << 17);  ///< K177
        constexpr uint32_t K178 = (1U << 18);  ///< K178
        constexpr uint32_t K179 = (1U << 19);  ///< K179
        constexpr uint32_t K180 = (1U << 20);  ///< K180
        constexpr uint32_t K181 = (1U << 21);  ///< K181
        constexpr uint32_t K182 = (1U << 22);  ///< K182
        constexpr uint32_t K183 = (1U << 23);  ///< K183
        constexpr uint32_t K184 = (1U << 24);  ///< K184
        constexpr uint32_t K185 = (1U << 25);  ///< K185
        constexpr uint32_t K186 = (1U << 26);  ///< K186
        constexpr uint32_t K187 = (1U << 27);  ///< K187
        constexpr uint32_t K188 = (1U << 28);  ///< K188
        constexpr uint32_t K189 = (1U << 29);  ///< K189
        constexpr uint32_t K190 = (1U << 30);  ///< K190
        constexpr uint32_t K191 = (1U << 31);  ///< K191
    }

    /// K1RR Register bits
    namespace k1rr_bits {
        constexpr uint32_t K128 = (1U << 0);  ///< K128
        constexpr uint32_t K129 = (1U << 1);  ///< K129
        constexpr uint32_t K130 = (1U << 2);  ///< K130
        constexpr uint32_t K131 = (1U << 3);  ///< K131
        constexpr uint32_t K132 = (1U << 4);  ///< K132
        constexpr uint32_t K133 = (1U << 5);  ///< K133
        constexpr uint32_t K134 = (1U << 6);  ///< K134
        constexpr uint32_t K135 = (1U << 7);  ///< K135
        constexpr uint32_t K136 = (1U << 8);  ///< K136
        constexpr uint32_t K137 = (1U << 9);  ///< K137
        constexpr uint32_t K138 = (1U << 10);  ///< K138
        constexpr uint32_t K139 = (1U << 11);  ///< K139
        constexpr uint32_t K140 = (1U << 12);  ///< K140
        constexpr uint32_t K141 = (1U << 13);  ///< K141
        constexpr uint32_t K142 = (1U << 14);  ///< K142
        constexpr uint32_t K143 = (1U << 15);  ///< K143
        constexpr uint32_t K144 = (1U << 16);  ///< K144
        constexpr uint32_t K145 = (1U << 17);  ///< K145
        constexpr uint32_t K146 = (1U << 18);  ///< K146
        constexpr uint32_t K147 = (1U << 19);  ///< K147
        constexpr uint32_t K148 = (1U << 20);  ///< K148
        constexpr uint32_t K149 = (1U << 21);  ///< K149
        constexpr uint32_t K150 = (1U << 22);  ///< K150
        constexpr uint32_t K151 = (1U << 23);  ///< K151
        constexpr uint32_t K152 = (1U << 24);  ///< K152
        constexpr uint32_t K153 = (1U << 25);  ///< K153
        constexpr uint32_t K154 = (1U << 26);  ///< K154
        constexpr uint32_t K155 = (1U << 27);  ///< K155
        constexpr uint32_t K156 = (1U << 28);  ///< K156
        constexpr uint32_t K157 = (1U << 29);  ///< K157
        constexpr uint32_t K158 = (1U << 30);  ///< K158
        constexpr uint32_t K159 = (1U << 31);  ///< K159
    }

    /// K2LR Register bits
    namespace k2lr_bits {
        constexpr uint32_t K96 = (1U << 0);  ///< K96
        constexpr uint32_t K97 = (1U << 1);  ///< K97
        constexpr uint32_t K98 = (1U << 2);  ///< K98
        constexpr uint32_t K99 = (1U << 3);  ///< K99
        constexpr uint32_t K100 = (1U << 4);  ///< K100
        constexpr uint32_t K101 = (1U << 5);  ///< K101
        constexpr uint32_t K102 = (1U << 6);  ///< K102
        constexpr uint32_t K103 = (1U << 7);  ///< K103
        constexpr uint32_t K104 = (1U << 8);  ///< K104
        constexpr uint32_t K105 = (1U << 9);  ///< K105
        constexpr uint32_t K106 = (1U << 10);  ///< K106
        constexpr uint32_t K107 = (1U << 11);  ///< K107
        constexpr uint32_t K108 = (1U << 12);  ///< K108
        constexpr uint32_t K109 = (1U << 13);  ///< K109
        constexpr uint32_t K110 = (1U << 14);  ///< K110
        constexpr uint32_t K111 = (1U << 15);  ///< K111
        constexpr uint32_t K112 = (1U << 16);  ///< K112
        constexpr uint32_t K113 = (1U << 17);  ///< K113
        constexpr uint32_t K114 = (1U << 18);  ///< K114
        constexpr uint32_t K115 = (1U << 19);  ///< K115
        constexpr uint32_t K116 = (1U << 20);  ///< K116
        constexpr uint32_t K117 = (1U << 21);  ///< K117
        constexpr uint32_t K118 = (1U << 22);  ///< K118
        constexpr uint32_t K119 = (1U << 23);  ///< K119
        constexpr uint32_t K120 = (1U << 24);  ///< K120
        constexpr uint32_t K121 = (1U << 25);  ///< K121
        constexpr uint32_t K122 = (1U << 26);  ///< K122
        constexpr uint32_t K123 = (1U << 27);  ///< K123
        constexpr uint32_t K124 = (1U << 28);  ///< K124
        constexpr uint32_t K125 = (1U << 29);  ///< K125
        constexpr uint32_t K126 = (1U << 30);  ///< K126
        constexpr uint32_t K127 = (1U << 31);  ///< K127
    }

    /// K2RR Register bits
    namespace k2rr_bits {
        constexpr uint32_t K64 = (1U << 0);  ///< K64
        constexpr uint32_t K65 = (1U << 1);  ///< K65
        constexpr uint32_t K66 = (1U << 2);  ///< K66
        constexpr uint32_t K67 = (1U << 3);  ///< K67
        constexpr uint32_t K68 = (1U << 4);  ///< K68
        constexpr uint32_t K69 = (1U << 5);  ///< K69
        constexpr uint32_t K70 = (1U << 6);  ///< K70
        constexpr uint32_t K71 = (1U << 7);  ///< K71
        constexpr uint32_t K72 = (1U << 8);  ///< K72
        constexpr uint32_t K73 = (1U << 9);  ///< K73
        constexpr uint32_t K74 = (1U << 10);  ///< K74
        constexpr uint32_t K75 = (1U << 11);  ///< K75
        constexpr uint32_t K76 = (1U << 12);  ///< K76
        constexpr uint32_t K77 = (1U << 13);  ///< K77
        constexpr uint32_t K78 = (1U << 14);  ///< K78
        constexpr uint32_t K79 = (1U << 15);  ///< K79
        constexpr uint32_t K80 = (1U << 16);  ///< K80
        constexpr uint32_t K81 = (1U << 17);  ///< K81
        constexpr uint32_t K82 = (1U << 18);  ///< K82
        constexpr uint32_t K83 = (1U << 19);  ///< K83
        constexpr uint32_t K84 = (1U << 20);  ///< K84
        constexpr uint32_t K85 = (1U << 21);  ///< K85
        constexpr uint32_t K86 = (1U << 22);  ///< K86
        constexpr uint32_t K87 = (1U << 23);  ///< K87
        constexpr uint32_t K88 = (1U << 24);  ///< K88
        constexpr uint32_t K89 = (1U << 25);  ///< K89
        constexpr uint32_t K90 = (1U << 26);  ///< K90
        constexpr uint32_t K91 = (1U << 27);  ///< K91
        constexpr uint32_t K92 = (1U << 28);  ///< K92
        constexpr uint32_t K93 = (1U << 29);  ///< K93
        constexpr uint32_t K94 = (1U << 30);  ///< K94
        constexpr uint32_t K95 = (1U << 31);  ///< K95
    }

    /// K3LR Register bits
    namespace k3lr_bits {
        constexpr uint32_t K32 = (1U << 0);  ///< K32
        constexpr uint32_t K33 = (1U << 1);  ///< K33
        constexpr uint32_t K34 = (1U << 2);  ///< K34
        constexpr uint32_t K35 = (1U << 3);  ///< K35
        constexpr uint32_t K36 = (1U << 4);  ///< K36
        constexpr uint32_t K37 = (1U << 5);  ///< K37
        constexpr uint32_t K38 = (1U << 6);  ///< K38
        constexpr uint32_t K39 = (1U << 7);  ///< K39
        constexpr uint32_t K40 = (1U << 8);  ///< K40
        constexpr uint32_t K41 = (1U << 9);  ///< K41
        constexpr uint32_t K42 = (1U << 10);  ///< K42
        constexpr uint32_t K43 = (1U << 11);  ///< K43
        constexpr uint32_t K44 = (1U << 12);  ///< K44
        constexpr uint32_t K45 = (1U << 13);  ///< K45
        constexpr uint32_t K46 = (1U << 14);  ///< K46
        constexpr uint32_t K47 = (1U << 15);  ///< K47
        constexpr uint32_t K48 = (1U << 16);  ///< K48
        constexpr uint32_t K49 = (1U << 17);  ///< K49
        constexpr uint32_t K50 = (1U << 18);  ///< K50
        constexpr uint32_t K51 = (1U << 19);  ///< K51
        constexpr uint32_t K52 = (1U << 20);  ///< K52
        constexpr uint32_t K53 = (1U << 21);  ///< K53
        constexpr uint32_t K54 = (1U << 22);  ///< K54
        constexpr uint32_t K55 = (1U << 23);  ///< K55
        constexpr uint32_t K56 = (1U << 24);  ///< K56
        constexpr uint32_t K57 = (1U << 25);  ///< K57
        constexpr uint32_t K58 = (1U << 26);  ///< K58
        constexpr uint32_t K59 = (1U << 27);  ///< K59
        constexpr uint32_t K60 = (1U << 28);  ///< K60
        constexpr uint32_t K61 = (1U << 29);  ///< K61
        constexpr uint32_t K62 = (1U << 30);  ///< K62
        constexpr uint32_t K63 = (1U << 31);  ///< K63
    }

    /// K3RR Register bits
    namespace k3rr_bits {
        constexpr uint32_t K0 = (1U << 0);  ///< K0
        constexpr uint32_t K1 = (1U << 1);  ///< K1
        constexpr uint32_t K2 = (1U << 2);  ///< K2
        constexpr uint32_t K3 = (1U << 3);  ///< K3
        constexpr uint32_t K4 = (1U << 4);  ///< K4
        constexpr uint32_t K5 = (1U << 5);  ///< K5
        constexpr uint32_t K6 = (1U << 6);  ///< K6
        constexpr uint32_t K7 = (1U << 7);  ///< K7
        constexpr uint32_t K8 = (1U << 8);  ///< K8
        constexpr uint32_t K9 = (1U << 9);  ///< K9
        constexpr uint32_t K10 = (1U << 10);  ///< K10
        constexpr uint32_t K11 = (1U << 11);  ///< K11
        constexpr uint32_t K12 = (1U << 12);  ///< K12
        constexpr uint32_t K13 = (1U << 13);  ///< K13
        constexpr uint32_t K14 = (1U << 14);  ///< K14
        constexpr uint32_t K15 = (1U << 15);  ///< K15
        constexpr uint32_t K16 = (1U << 16);  ///< K16
        constexpr uint32_t K17 = (1U << 17);  ///< K17
        constexpr uint32_t K18 = (1U << 18);  ///< K18
        constexpr uint32_t K19 = (1U << 19);  ///< K19
        constexpr uint32_t K20 = (1U << 20);  ///< K20
        constexpr uint32_t K21 = (1U << 21);  ///< K21
        constexpr uint32_t K22 = (1U << 22);  ///< K22
        constexpr uint32_t K23 = (1U << 23);  ///< K23
        constexpr uint32_t K24 = (1U << 24);  ///< K24
        constexpr uint32_t K25 = (1U << 25);  ///< K25
        constexpr uint32_t K26 = (1U << 26);  ///< K26
        constexpr uint32_t K27 = (1U << 27);  ///< K27
        constexpr uint32_t K28 = (1U << 28);  ///< K28
        constexpr uint32_t K29 = (1U << 29);  ///< K29
        constexpr uint32_t K30 = (1U << 30);  ///< K30
        constexpr uint32_t K31 = (1U << 31);  ///< K31
    }

    /// IV0LR Register bits
    namespace iv0lr_bits {
        constexpr uint32_t IV31 = (1U << 0);  ///< IV31
        constexpr uint32_t IV30 = (1U << 1);  ///< IV30
        constexpr uint32_t IV29 = (1U << 2);  ///< IV29
        constexpr uint32_t IV28 = (1U << 3);  ///< IV28
        constexpr uint32_t IV27 = (1U << 4);  ///< IV27
        constexpr uint32_t IV26 = (1U << 5);  ///< IV26
        constexpr uint32_t IV25 = (1U << 6);  ///< IV25
        constexpr uint32_t IV24 = (1U << 7);  ///< IV24
        constexpr uint32_t IV23 = (1U << 8);  ///< IV23
        constexpr uint32_t IV22 = (1U << 9);  ///< IV22
        constexpr uint32_t IV21 = (1U << 10);  ///< IV21
        constexpr uint32_t IV20 = (1U << 11);  ///< IV20
        constexpr uint32_t IV19 = (1U << 12);  ///< IV19
        constexpr uint32_t IV18 = (1U << 13);  ///< IV18
        constexpr uint32_t IV17 = (1U << 14);  ///< IV17
        constexpr uint32_t IV16 = (1U << 15);  ///< IV16
        constexpr uint32_t IV15 = (1U << 16);  ///< IV15
        constexpr uint32_t IV14 = (1U << 17);  ///< IV14
        constexpr uint32_t IV13 = (1U << 18);  ///< IV13
        constexpr uint32_t IV12 = (1U << 19);  ///< IV12
        constexpr uint32_t IV11 = (1U << 20);  ///< IV11
        constexpr uint32_t IV10 = (1U << 21);  ///< IV10
        constexpr uint32_t IV9 = (1U << 22);  ///< IV9
        constexpr uint32_t IV8 = (1U << 23);  ///< IV8
        constexpr uint32_t IV7 = (1U << 24);  ///< IV7
        constexpr uint32_t IV6 = (1U << 25);  ///< IV6
        constexpr uint32_t IV5 = (1U << 26);  ///< IV5
        constexpr uint32_t IV4 = (1U << 27);  ///< IV4
        constexpr uint32_t IV3 = (1U << 28);  ///< IV3
        constexpr uint32_t IV2 = (1U << 29);  ///< IV2
        constexpr uint32_t IV1 = (1U << 30);  ///< IV1
        constexpr uint32_t IV0 = (1U << 31);  ///< IV0
    }

    /// IV0RR Register bits
    namespace iv0rr_bits {
        constexpr uint32_t IV63 = (1U << 0);  ///< IV63
        constexpr uint32_t IV62 = (1U << 1);  ///< IV62
        constexpr uint32_t IV61 = (1U << 2);  ///< IV61
        constexpr uint32_t IV60 = (1U << 3);  ///< IV60
        constexpr uint32_t IV59 = (1U << 4);  ///< IV59
        constexpr uint32_t IV58 = (1U << 5);  ///< IV58
        constexpr uint32_t IV57 = (1U << 6);  ///< IV57
        constexpr uint32_t IV56 = (1U << 7);  ///< IV56
        constexpr uint32_t IV55 = (1U << 8);  ///< IV55
        constexpr uint32_t IV54 = (1U << 9);  ///< IV54
        constexpr uint32_t IV53 = (1U << 10);  ///< IV53
        constexpr uint32_t IV52 = (1U << 11);  ///< IV52
        constexpr uint32_t IV51 = (1U << 12);  ///< IV51
        constexpr uint32_t IV50 = (1U << 13);  ///< IV50
        constexpr uint32_t IV49 = (1U << 14);  ///< IV49
        constexpr uint32_t IV48 = (1U << 15);  ///< IV48
        constexpr uint32_t IV47 = (1U << 16);  ///< IV47
        constexpr uint32_t IV46 = (1U << 17);  ///< IV46
        constexpr uint32_t IV45 = (1U << 18);  ///< IV45
        constexpr uint32_t IV44 = (1U << 19);  ///< IV44
        constexpr uint32_t IV43 = (1U << 20);  ///< IV43
        constexpr uint32_t IV42 = (1U << 21);  ///< IV42
        constexpr uint32_t IV41 = (1U << 22);  ///< IV41
        constexpr uint32_t IV40 = (1U << 23);  ///< IV40
        constexpr uint32_t IV39 = (1U << 24);  ///< IV39
        constexpr uint32_t IV38 = (1U << 25);  ///< IV38
        constexpr uint32_t IV37 = (1U << 26);  ///< IV37
        constexpr uint32_t IV36 = (1U << 27);  ///< IV36
        constexpr uint32_t IV35 = (1U << 28);  ///< IV35
        constexpr uint32_t IV34 = (1U << 29);  ///< IV34
        constexpr uint32_t IV33 = (1U << 30);  ///< IV33
        constexpr uint32_t IV32 = (1U << 31);  ///< IV32
    }

    /// IV1LR Register bits
    namespace iv1lr_bits {
        constexpr uint32_t IV95 = (1U << 0);  ///< IV95
        constexpr uint32_t IV94 = (1U << 1);  ///< IV94
        constexpr uint32_t IV93 = (1U << 2);  ///< IV93
        constexpr uint32_t IV92 = (1U << 3);  ///< IV92
        constexpr uint32_t IV91 = (1U << 4);  ///< IV91
        constexpr uint32_t IV90 = (1U << 5);  ///< IV90
        constexpr uint32_t IV89 = (1U << 6);  ///< IV89
        constexpr uint32_t IV88 = (1U << 7);  ///< IV88
        constexpr uint32_t IV87 = (1U << 8);  ///< IV87
        constexpr uint32_t IV86 = (1U << 9);  ///< IV86
        constexpr uint32_t IV85 = (1U << 10);  ///< IV85
        constexpr uint32_t IV84 = (1U << 11);  ///< IV84
        constexpr uint32_t IV83 = (1U << 12);  ///< IV83
        constexpr uint32_t IV82 = (1U << 13);  ///< IV82
        constexpr uint32_t IV81 = (1U << 14);  ///< IV81
        constexpr uint32_t IV80 = (1U << 15);  ///< IV80
        constexpr uint32_t IV79 = (1U << 16);  ///< IV79
        constexpr uint32_t IV78 = (1U << 17);  ///< IV78
        constexpr uint32_t IV77 = (1U << 18);  ///< IV77
        constexpr uint32_t IV76 = (1U << 19);  ///< IV76
        constexpr uint32_t IV75 = (1U << 20);  ///< IV75
        constexpr uint32_t IV74 = (1U << 21);  ///< IV74
        constexpr uint32_t IV73 = (1U << 22);  ///< IV73
        constexpr uint32_t IV72 = (1U << 23);  ///< IV72
        constexpr uint32_t IV71 = (1U << 24);  ///< IV71
        constexpr uint32_t IV70 = (1U << 25);  ///< IV70
        constexpr uint32_t IV69 = (1U << 26);  ///< IV69
        constexpr uint32_t IV68 = (1U << 27);  ///< IV68
        constexpr uint32_t IV67 = (1U << 28);  ///< IV67
        constexpr uint32_t IV66 = (1U << 29);  ///< IV66
        constexpr uint32_t IV65 = (1U << 30);  ///< IV65
        constexpr uint32_t IV64 = (1U << 31);  ///< IV64
    }

    /// IV1RR Register bits
    namespace iv1rr_bits {
        constexpr uint32_t IV127 = (1U << 0);  ///< IV127
        constexpr uint32_t IV126 = (1U << 1);  ///< IV126
        constexpr uint32_t IV125 = (1U << 2);  ///< IV125
        constexpr uint32_t IV124 = (1U << 3);  ///< IV124
        constexpr uint32_t IV123 = (1U << 4);  ///< IV123
        constexpr uint32_t IV122 = (1U << 5);  ///< IV122
        constexpr uint32_t IV121 = (1U << 6);  ///< IV121
        constexpr uint32_t IV120 = (1U << 7);  ///< IV120
        constexpr uint32_t IV119 = (1U << 8);  ///< IV119
        constexpr uint32_t IV118 = (1U << 9);  ///< IV118
        constexpr uint32_t IV117 = (1U << 10);  ///< IV117
        constexpr uint32_t IV116 = (1U << 11);  ///< IV116
        constexpr uint32_t IV115 = (1U << 12);  ///< IV115
        constexpr uint32_t IV114 = (1U << 13);  ///< IV114
        constexpr uint32_t IV113 = (1U << 14);  ///< IV113
        constexpr uint32_t IV112 = (1U << 15);  ///< IV112
        constexpr uint32_t IV111 = (1U << 16);  ///< IV111
        constexpr uint32_t IV110 = (1U << 17);  ///< IV110
        constexpr uint32_t IV109 = (1U << 18);  ///< IV109
        constexpr uint32_t IV108 = (1U << 19);  ///< IV108
        constexpr uint32_t IV107 = (1U << 20);  ///< IV107
        constexpr uint32_t IV106 = (1U << 21);  ///< IV106
        constexpr uint32_t IV105 = (1U << 22);  ///< IV105
        constexpr uint32_t IV104 = (1U << 23);  ///< IV104
        constexpr uint32_t IV103 = (1U << 24);  ///< IV103
        constexpr uint32_t IV102 = (1U << 25);  ///< IV102
        constexpr uint32_t IV101 = (1U << 26);  ///< IV101
        constexpr uint32_t IV100 = (1U << 27);  ///< IV100
        constexpr uint32_t IV99 = (1U << 28);  ///< IV99
        constexpr uint32_t IV98 = (1U << 29);  ///< IV98
        constexpr uint32_t IV97 = (1U << 30);  ///< IV97
        constexpr uint32_t IV96 = (1U << 31);  ///< IV96
    }

    /// CSGCMCCM0R Register bits
    namespace csgcmccm0r_bits {
        constexpr uint32_t CSGCMCCM0 = (32 << 0);  ///< CSGCMCCM0
    }

    /// CSGCMCCM1R Register bits
    namespace csgcmccm1r_bits {
        constexpr uint32_t CSGCMCCM1 = (32 << 0);  ///< CSGCMCCM1
    }

    /// CSGCMCCM2R Register bits
    namespace csgcmccm2r_bits {
        constexpr uint32_t CSGCMCCM2 = (32 << 0);  ///< CSGCMCCM2
    }

    /// CSGCMCCM3R Register bits
    namespace csgcmccm3r_bits {
        constexpr uint32_t CSGCMCCM3 = (32 << 0);  ///< CSGCMCCM3
    }

    /// CSGCMCCM4R Register bits
    namespace csgcmccm4r_bits {
        constexpr uint32_t CSGCMCCM4 = (32 << 0);  ///< CSGCMCCM4
    }

    /// CSGCMCCM5R Register bits
    namespace csgcmccm5r_bits {
        constexpr uint32_t CSGCMCCM5 = (32 << 0);  ///< CSGCMCCM5
    }

    /// CSGCMCCM6R Register bits
    namespace csgcmccm6r_bits {
        constexpr uint32_t CSGCMCCM6 = (32 << 0);  ///< CSGCMCCM6
    }

    /// CSGCMCCM7R Register bits
    namespace csgcmccm7r_bits {
        constexpr uint32_t CSGCMCCM7 = (32 << 0);  ///< CSGCMCCM7
    }

    /// CSGCM0R Register bits
    namespace csgcm0r_bits {
        constexpr uint32_t CSGCM0 = (32 << 0);  ///< CSGCM0
    }

    /// CSGCM1R Register bits
    namespace csgcm1r_bits {
        constexpr uint32_t CSGCM1 = (32 << 0);  ///< CSGCM1
    }

    /// CSGCM2R Register bits
    namespace csgcm2r_bits {
        constexpr uint32_t CSGCM2 = (32 << 0);  ///< CSGCM2
    }

    /// CSGCM3R Register bits
    namespace csgcm3r_bits {
        constexpr uint32_t CSGCM3 = (32 << 0);  ///< CSGCM3
    }

    /// CSGCM4R Register bits
    namespace csgcm4r_bits {
        constexpr uint32_t CSGCM4 = (32 << 0);  ///< CSGCM4
    }

    /// CSGCM5R Register bits
    namespace csgcm5r_bits {
        constexpr uint32_t CSGCM5 = (32 << 0);  ///< CSGCM5
    }

    /// CSGCM6R Register bits
    namespace csgcm6r_bits {
        constexpr uint32_t CSGCM6 = (32 << 0);  ///< CSGCM6
    }

    /// CSGCM7R Register bits
    namespace csgcm7r_bits {
        constexpr uint32_t CSGCM7 = (32 << 0);  ///< CSGCM7
    }

}

// ============================================================================
// DCMI Peripheral
// ============================================================================

namespace dcmi {
    /// Base addresses
    constexpr uint32_t DCMI_BASE = 0x48020000;

    /// DCMI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register 1
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - interrupt clear register
        volatile uint32_t ESCR;  ///< Offset: 0x18 - embedded synchronization code register
        volatile uint32_t ESUR;  ///< Offset: 0x1C - embedded synchronization unmask register
        volatile uint32_t CWSTRT;  ///< Offset: 0x20 - crop window start
        volatile uint32_t CWSIZE;  ///< Offset: 0x24 - crop window size
        volatile uint32_t DR;  ///< Offset: 0x28 - data register
    };

    /// Peripheral instances
    inline Registers* DCMI = reinterpret_cast<Registers*>(DCMI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OELS = (1U << 20);  ///< Odd/Even Line Select (Line Select Start)
        constexpr uint32_t LSM = (1U << 19);  ///< Line Select mode
        constexpr uint32_t OEBS = (1U << 18);  ///< Odd/Even Byte Select (Byte Select Start)
        constexpr uint32_t BSM = (2 << 16);  ///< Byte Select mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< DCMI enable
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t FCRC = (2 << 8);  ///< Frame capture rate control
        constexpr uint32_t VSPOL = (1U << 7);  ///< Vertical synchronization polarity
        constexpr uint32_t HSPOL = (1U << 6);  ///< Horizontal synchronization polarity
        constexpr uint32_t PCKPOL = (1U << 5);  ///< Pixel clock polarity
        constexpr uint32_t ESS = (1U << 4);  ///< Embedded synchronization select
        constexpr uint32_t JPEG = (1U << 3);  ///< JPEG format
        constexpr uint32_t CROP = (1U << 2);  ///< Crop feature
        constexpr uint32_t CM = (1U << 1);  ///< Capture mode
        constexpr uint32_t CAPTURE = (1U << 0);  ///< Capture enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t FNE = (1U << 2);  ///< FIFO not empty
        constexpr uint32_t VSYNC = (1U << 1);  ///< VSYNC
        constexpr uint32_t HSYNC = (1U << 0);  ///< HSYNC
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t LINE_RIS = (1U << 4);  ///< Line raw interrupt status
        constexpr uint32_t VSYNC_RIS = (1U << 3);  ///< VSYNC raw interrupt status
        constexpr uint32_t ERR_RIS = (1U << 2);  ///< Synchronization error raw interrupt status
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< Overrun raw interrupt status
        constexpr uint32_t FRAME_RIS = (1U << 0);  ///< Capture complete raw interrupt status
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t LINE_IE = (1U << 4);  ///< Line interrupt enable
        constexpr uint32_t VSYNC_IE = (1U << 3);  ///< VSYNC interrupt enable
        constexpr uint32_t ERR_IE = (1U << 2);  ///< Synchronization error interrupt enable
        constexpr uint32_t OVR_IE = (1U << 1);  ///< Overrun interrupt enable
        constexpr uint32_t FRAME_IE = (1U << 0);  ///< Capture complete interrupt enable
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t LINE_MIS = (1U << 4);  ///< Line masked interrupt status
        constexpr uint32_t VSYNC_MIS = (1U << 3);  ///< VSYNC masked interrupt status
        constexpr uint32_t ERR_MIS = (1U << 2);  ///< Synchronization error masked interrupt status
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< Overrun masked interrupt status
        constexpr uint32_t FRAME_MIS = (1U << 0);  ///< Capture complete masked interrupt status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t LINE_ISC = (1U << 4);  ///< line interrupt status clear
        constexpr uint32_t VSYNC_ISC = (1U << 3);  ///< Vertical synch interrupt status clear
        constexpr uint32_t ERR_ISC = (1U << 2);  ///< Synchronization error interrupt status clear
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< Overrun interrupt status clear
        constexpr uint32_t FRAME_ISC = (1U << 0);  ///< Capture complete interrupt status clear
    }

    /// ESCR Register bits
    namespace escr_bits {
        constexpr uint32_t FEC = (8 << 24);  ///< Frame end delimiter code
        constexpr uint32_t LEC = (8 << 16);  ///< Line end delimiter code
        constexpr uint32_t LSC = (8 << 8);  ///< Line start delimiter code
        constexpr uint32_t FSC = (8 << 0);  ///< Frame start delimiter code
    }

    /// ESUR Register bits
    namespace esur_bits {
        constexpr uint32_t FEU = (8 << 24);  ///< Frame end delimiter unmask
        constexpr uint32_t LEU = (8 << 16);  ///< Line end delimiter unmask
        constexpr uint32_t LSU = (8 << 8);  ///< Line start delimiter unmask
        constexpr uint32_t FSU = (8 << 0);  ///< Frame start delimiter unmask
    }

    /// CWSTRT Register bits
    namespace cwstrt_bits {
        constexpr uint32_t VST = (13 << 16);  ///< Vertical start line count
        constexpr uint32_t HOFFCNT = (14 << 0);  ///< Horizontal offset count
    }

    /// CWSIZE Register bits
    namespace cwsize_bits {
        constexpr uint32_t VLINE = (14 << 16);  ///< Vertical line count
        constexpr uint32_t CAPCNT = (14 << 0);  ///< Capture count
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t Byte3 = (8 << 24);  ///< Data byte 3
        constexpr uint32_t Byte2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t Byte1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t Byte0 = (8 << 0);  ///< Data byte 0
    }

}

// ============================================================================
// OTG1 Peripheral
// ============================================================================

namespace otg1 {
    /// Base addresses
    constexpr uint32_t OTG1_HS_GLOBAL_BASE = 0x40040000;
    constexpr uint32_t OTG1_HS_HOST_BASE = 0x40040400;
    constexpr uint32_t OTG1_HS_DEVICE_BASE = 0x40040800;

    /// OTG1 Register structure
    struct Registers {
        volatile uint32_t OTG_HS_GOTGCTL;  ///< Offset: 0x00 - OTG_HS control and status register
        volatile uint32_t OTG_HS_GOTGINT;  ///< Offset: 0x04 - OTG_HS interrupt register
        volatile uint32_t OTG_HS_GAHBCFG;  ///< Offset: 0x08 - OTG_HS AHB configuration register
        volatile uint32_t OTG_HS_GUSBCFG;  ///< Offset: 0x0C - OTG_HS USB configuration register
        volatile uint32_t OTG_HS_GRSTCTL;  ///< Offset: 0x10 - OTG_HS reset register
        volatile uint32_t OTG_HS_GINTSTS;  ///< Offset: 0x14 - OTG_HS core interrupt register
        volatile uint32_t OTG_HS_GINTMSK;  ///< Offset: 0x18 - OTG_HS interrupt mask register
        volatile uint32_t OTG_HS_GRXSTSR_Host;  ///< Offset: 0x1C - OTG_HS Receive status debug read register (host mode)
        volatile uint32_t OTG_HS_GRXSTSP_Host;  ///< Offset: 0x20 - OTG_HS status read and pop register (host mode)
        volatile uint32_t OTG_HS_GRXFSIZ;  ///< Offset: 0x24 - OTG_HS Receive FIFO size register
        volatile uint32_t OTG_HS_HNPTXFSIZ_Host;  ///< Offset: 0x28 - OTG_HS nonperiodic transmit FIFO size register (host mode)
        volatile uint32_t OTG_HS_DIEPTXF0_Device;  ///< Offset: 0x28 - Endpoint 0 transmit FIFO size (peripheral mode)
        volatile uint32_t OTG_HS_GNPTXSTS;  ///< Offset: 0x2C - OTG_HS nonperiodic transmit FIFO/queue status register
        volatile uint32_t OTG_HS_GCCFG;  ///< Offset: 0x38 - OTG_HS general core configuration register
        volatile uint32_t OTG_HS_CID;  ///< Offset: 0x3C - OTG_HS core ID register
        volatile uint32_t OTG_HS_HPTXFSIZ;  ///< Offset: 0x100 - OTG_HS Host periodic transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF1;  ///< Offset: 0x104 - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF2;  ///< Offset: 0x108 - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF3;  ///< Offset: 0x11C - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF4;  ///< Offset: 0x120 - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF5;  ///< Offset: 0x124 - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF6;  ///< Offset: 0x128 - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_DIEPTXF7;  ///< Offset: 0x12C - OTG_HS device IN endpoint transmit FIFO size register
        volatile uint32_t OTG_HS_GRXSTSR_Device;  ///< Offset: 0x1C - OTG_HS Receive status debug read register (peripheral mode mode)
        volatile uint32_t OTG_HS_GRXSTSP_Device;  ///< Offset: 0x20 - OTG_HS status read and pop register (peripheral mode)
        volatile uint32_t OTG_HS_GLPMCFG;  ///< Offset: 0x54 - OTG core LPM configuration register
    };

    /// Peripheral instances
    inline Registers* OTG1_HS_GLOBAL = reinterpret_cast<Registers*>(OTG1_HS_GLOBAL_BASE);
    inline Registers* OTG1_HS_HOST = reinterpret_cast<Registers*>(OTG1_HS_HOST_BASE);
    inline Registers* OTG1_HS_DEVICE = reinterpret_cast<Registers*>(OTG1_HS_DEVICE_BASE);

    // Bit definitions
    /// OTG_HS_GOTGCTL Register bits
    namespace otg_hs_gotgctl_bits {
        constexpr uint32_t SRQSCS = (1U << 0);  ///< Session request success
        constexpr uint32_t SRQ = (1U << 1);  ///< Session request
        constexpr uint32_t HNGSCS = (1U << 8);  ///< Host negotiation success
        constexpr uint32_t HNPRQ = (1U << 9);  ///< HNP request
        constexpr uint32_t HSHNPEN = (1U << 10);  ///< Host set HNP enable
        constexpr uint32_t DHNPEN = (1U << 11);  ///< Device HNP enabled
        constexpr uint32_t CIDSTS = (1U << 16);  ///< Connector ID status
        constexpr uint32_t DBCT = (1U << 17);  ///< Long/short debounce time
        constexpr uint32_t ASVLD = (1U << 18);  ///< A-session valid
        constexpr uint32_t BSVLD = (1U << 19);  ///< B-session valid
        constexpr uint32_t EHEN = (1U << 12);  ///< Embedded host enable
    }

    /// OTG_HS_GOTGINT Register bits
    namespace otg_hs_gotgint_bits {
        constexpr uint32_t SEDET = (1U << 2);  ///< Session end detected
        constexpr uint32_t SRSSCHG = (1U << 8);  ///< Session request success status change
        constexpr uint32_t HNSSCHG = (1U << 9);  ///< Host negotiation success status change
        constexpr uint32_t HNGDET = (1U << 17);  ///< Host negotiation detected
        constexpr uint32_t ADTOCHG = (1U << 18);  ///< A-device timeout change
        constexpr uint32_t DBCDNE = (1U << 19);  ///< Debounce done
        constexpr uint32_t IDCHNG = (1U << 20);  ///< ID input pin changed
    }

    /// OTG_HS_GAHBCFG Register bits
    namespace otg_hs_gahbcfg_bits {
        constexpr uint32_t GINT = (1U << 0);  ///< Global interrupt mask
        constexpr uint32_t HBSTLEN = (4 << 1);  ///< Burst length/type
        constexpr uint32_t DMAEN = (1U << 5);  ///< DMA enable
        constexpr uint32_t TXFELVL = (1U << 7);  ///< TxFIFO empty level
        constexpr uint32_t PTXFELVL = (1U << 8);  ///< Periodic TxFIFO empty level
    }

    /// OTG_HS_GUSBCFG Register bits
    namespace otg_hs_gusbcfg_bits {
        constexpr uint32_t TOCAL = (3 << 0);  ///< FS timeout calibration
        constexpr uint32_t PHYSEL = (1U << 6);  ///< USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
        constexpr uint32_t SRPCAP = (1U << 8);  ///< SRP-capable
        constexpr uint32_t HNPCAP = (1U << 9);  ///< HNP-capable
        constexpr uint32_t TRDT = (4 << 10);  ///< USB turnaround time
        constexpr uint32_t PHYLPCS = (1U << 15);  ///< PHY Low-power clock select
        constexpr uint32_t ULPIFSLS = (1U << 17);  ///< ULPI FS/LS select
        constexpr uint32_t ULPIAR = (1U << 18);  ///< ULPI Auto-resume
        constexpr uint32_t ULPICSM = (1U << 19);  ///< ULPI Clock SuspendM
        constexpr uint32_t ULPIEVBUSD = (1U << 20);  ///< ULPI External VBUS Drive
        constexpr uint32_t ULPIEVBUSI = (1U << 21);  ///< ULPI external VBUS indicator
        constexpr uint32_t TSDPS = (1U << 22);  ///< TermSel DLine pulsing selection
        constexpr uint32_t PCCI = (1U << 23);  ///< Indicator complement
        constexpr uint32_t PTCI = (1U << 24);  ///< Indicator pass through
        constexpr uint32_t ULPIIPD = (1U << 25);  ///< ULPI interface protect disable
        constexpr uint32_t FHMOD = (1U << 29);  ///< Forced host mode
        constexpr uint32_t FDMOD = (1U << 30);  ///< Forced peripheral mode
    }

    /// OTG_HS_GRSTCTL Register bits
    namespace otg_hs_grstctl_bits {
        constexpr uint32_t CSRST = (1U << 0);  ///< Core soft reset
        constexpr uint32_t HSRST = (1U << 1);  ///< HCLK soft reset
        constexpr uint32_t FCRST = (1U << 2);  ///< Host frame counter reset
        constexpr uint32_t RXFFLSH = (1U << 4);  ///< RxFIFO flush
        constexpr uint32_t TXFFLSH = (1U << 5);  ///< TxFIFO flush
        constexpr uint32_t TXFNUM = (5 << 6);  ///< TxFIFO number
        constexpr uint32_t AHBIDL = (1U << 31);  ///< AHB master idle
        constexpr uint32_t DMAREQ = (1U << 30);  ///< DMA request signal enabled for USB OTG HS
    }

    /// OTG_HS_GINTSTS Register bits
    namespace otg_hs_gintsts_bits {
        constexpr uint32_t CMOD = (1U << 0);  ///< Current mode of operation
        constexpr uint32_t MMIS = (1U << 1);  ///< Mode mismatch interrupt
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTG interrupt
        constexpr uint32_t SOF = (1U << 3);  ///< Start of frame
        constexpr uint32_t RXFLVL = (1U << 4);  ///< RxFIFO nonempty
        constexpr uint32_t NPTXFE = (1U << 5);  ///< Nonperiodic TxFIFO empty
        constexpr uint32_t GINAKEFF = (1U << 6);  ///< Global IN nonperiodic NAK effective
        constexpr uint32_t BOUTNAKEFF = (1U << 7);  ///< Global OUT NAK effective
        constexpr uint32_t ESUSP = (1U << 10);  ///< Early suspend
        constexpr uint32_t USBSUSP = (1U << 11);  ///< USB suspend
        constexpr uint32_t USBRST = (1U << 12);  ///< USB reset
        constexpr uint32_t ENUMDNE = (1U << 13);  ///< Enumeration done
        constexpr uint32_t ISOODRP = (1U << 14);  ///< Isochronous OUT packet dropped interrupt
        constexpr uint32_t EOPF = (1U << 15);  ///< End of periodic frame interrupt
        constexpr uint32_t IEPINT = (1U << 18);  ///< IN endpoint interrupt
        constexpr uint32_t OEPINT = (1U << 19);  ///< OUT endpoint interrupt
        constexpr uint32_t IISOIXFR = (1U << 20);  ///< Incomplete isochronous IN transfer
        constexpr uint32_t PXFR_INCOMPISOOUT = (1U << 21);  ///< Incomplete periodic transfer
        constexpr uint32_t DATAFSUSP = (1U << 22);  ///< Data fetch suspended
        constexpr uint32_t HPRTINT = (1U << 24);  ///< Host port interrupt
        constexpr uint32_t HCINT = (1U << 25);  ///< Host channels interrupt
        constexpr uint32_t PTXFE = (1U << 26);  ///< Periodic TxFIFO empty
        constexpr uint32_t CIDSCHG = (1U << 28);  ///< Connector ID status change
        constexpr uint32_t DISCINT = (1U << 29);  ///< Disconnect detected interrupt
        constexpr uint32_t SRQINT = (1U << 30);  ///< Session request/new session detected interrupt
        constexpr uint32_t WKUINT = (1U << 31);  ///< Resume/remote wakeup detected interrupt
    }

    /// OTG_HS_GINTMSK Register bits
    namespace otg_hs_gintmsk_bits {
        constexpr uint32_t MMISM = (1U << 1);  ///< Mode mismatch interrupt mask
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTG interrupt mask
        constexpr uint32_t SOFM = (1U << 3);  ///< Start of frame mask
        constexpr uint32_t RXFLVLM = (1U << 4);  ///< Receive FIFO nonempty mask
        constexpr uint32_t NPTXFEM = (1U << 5);  ///< Nonperiodic TxFIFO empty mask
        constexpr uint32_t GINAKEFFM = (1U << 6);  ///< Global nonperiodic IN NAK effective mask
        constexpr uint32_t GONAKEFFM = (1U << 7);  ///< Global OUT NAK effective mask
        constexpr uint32_t ESUSPM = (1U << 10);  ///< Early suspend mask
        constexpr uint32_t USBSUSPM = (1U << 11);  ///< USB suspend mask
        constexpr uint32_t USBRST = (1U << 12);  ///< USB reset mask
        constexpr uint32_t ENUMDNEM = (1U << 13);  ///< Enumeration done mask
        constexpr uint32_t ISOODRPM = (1U << 14);  ///< Isochronous OUT packet dropped interrupt mask
        constexpr uint32_t EOPFM = (1U << 15);  ///< End of periodic frame interrupt mask
        constexpr uint32_t IEPINT = (1U << 18);  ///< IN endpoints interrupt mask
        constexpr uint32_t OEPINT = (1U << 19);  ///< OUT endpoints interrupt mask
        constexpr uint32_t IISOIXFRM = (1U << 20);  ///< Incomplete isochronous IN transfer mask
        constexpr uint32_t PXFRM_IISOOXFRM = (1U << 21);  ///< Incomplete periodic transfer mask
        constexpr uint32_t FSUSPM = (1U << 22);  ///< Data fetch suspended mask
        constexpr uint32_t PRTIM = (1U << 24);  ///< Host port interrupt mask
        constexpr uint32_t HCIM = (1U << 25);  ///< Host channels interrupt mask
        constexpr uint32_t PTXFEM = (1U << 26);  ///< Periodic TxFIFO empty mask
        constexpr uint32_t CIDSCHGM = (1U << 28);  ///< Connector ID status change mask
        constexpr uint32_t DISCINT = (1U << 29);  ///< Disconnect detected interrupt mask
        constexpr uint32_t SRQIM = (1U << 30);  ///< Session request/new session detected interrupt mask
        constexpr uint32_t WUIM = (1U << 31);  ///< Resume/remote wakeup detected interrupt mask
        constexpr uint32_t RSTDE = (1U << 23);  ///< Reset detected interrupt mask
        constexpr uint32_t LPMINTM = (1U << 27);  ///< LPM interrupt mask
    }

    /// OTG_HS_GRXSTSR_Host Register bits
    namespace otg_hs_grxstsr_host_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< Channel number
        constexpr uint32_t BCNT = (11 << 4);  ///< Byte count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< Packet status
    }

    /// OTG_HS_GRXSTSP_Host Register bits
    namespace otg_hs_grxstsp_host_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< Channel number
        constexpr uint32_t BCNT = (11 << 4);  ///< Byte count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< Packet status
    }

    /// OTG_HS_GRXFSIZ Register bits
    namespace otg_hs_grxfsiz_bits {
        constexpr uint32_t RXFD = (16 << 0);  ///< RxFIFO depth
    }

    /// OTG_HS_HNPTXFSIZ_Host Register bits
    namespace otg_hs_hnptxfsiz_host_bits {
        constexpr uint32_t NPTXFSA = (16 << 0);  ///< Nonperiodic transmit RAM start address
        constexpr uint32_t NPTXFD = (16 << 16);  ///< Nonperiodic TxFIFO depth
    }

    /// OTG_HS_DIEPTXF0_Device Register bits
    namespace otg_hs_dieptxf0_device_bits {
        constexpr uint32_t TX0FSA = (16 << 0);  ///< Endpoint 0 transmit RAM start address
        constexpr uint32_t TX0FD = (16 << 16);  ///< Endpoint 0 TxFIFO depth
    }

    /// OTG_HS_GNPTXSTS Register bits
    namespace otg_hs_gnptxsts_bits {
        constexpr uint32_t NPTXFSAV = (16 << 0);  ///< Nonperiodic TxFIFO space available
        constexpr uint32_t NPTQXSAV = (8 << 16);  ///< Nonperiodic transmit request queue space available
        constexpr uint32_t NPTXQTOP = (7 << 24);  ///< Top of the nonperiodic transmit request queue
    }

    /// OTG_HS_GCCFG Register bits
    namespace otg_hs_gccfg_bits {
        constexpr uint32_t PWRDWN = (1U << 16);  ///< Power down
        constexpr uint32_t BCDEN = (1U << 17);  ///< Battery charging detector (BCD) enable
        constexpr uint32_t DCDEN = (1U << 18);  ///< Data contact detection (DCD) mode enable
        constexpr uint32_t PDEN = (1U << 19);  ///< Primary detection (PD) mode enable
        constexpr uint32_t SDEN = (1U << 20);  ///< Secondary detection (SD) mode enable
        constexpr uint32_t VBDEN = (1U << 21);  ///< USB VBUS detection enable
        constexpr uint32_t DCDET = (1U << 0);  ///< Data contact detection (DCD) status
        constexpr uint32_t PDET = (1U << 1);  ///< Primary detection (PD) status
        constexpr uint32_t SDET = (1U << 2);  ///< Secondary detection (SD) status
        constexpr uint32_t PS2DET = (1U << 3);  ///< DM pull-up detection status
    }

    /// OTG_HS_CID Register bits
    namespace otg_hs_cid_bits {
        constexpr uint32_t PRODUCT_ID = (32 << 0);  ///< Product ID field
    }

    /// OTG_HS_HPTXFSIZ Register bits
    namespace otg_hs_hptxfsiz_bits {
        constexpr uint32_t PTXSA = (16 << 0);  ///< Host periodic TxFIFO start address
        constexpr uint32_t PTXFD = (16 << 16);  ///< Host periodic TxFIFO depth
    }

    /// OTG_HS_DIEPTXF1 Register bits
    namespace otg_hs_dieptxf1_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_DIEPTXF2 Register bits
    namespace otg_hs_dieptxf2_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_DIEPTXF3 Register bits
    namespace otg_hs_dieptxf3_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_DIEPTXF4 Register bits
    namespace otg_hs_dieptxf4_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_DIEPTXF5 Register bits
    namespace otg_hs_dieptxf5_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_DIEPTXF6 Register bits
    namespace otg_hs_dieptxf6_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_DIEPTXF7 Register bits
    namespace otg_hs_dieptxf7_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< IN endpoint FIFOx transmit RAM start address
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< IN endpoint TxFIFO depth
    }

    /// OTG_HS_GRXSTSR_Device Register bits
    namespace otg_hs_grxstsr_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint number
        constexpr uint32_t BCNT = (11 << 4);  ///< Byte count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< Packet status
        constexpr uint32_t FRMNUM = (4 << 21);  ///< Frame number
    }

    /// OTG_HS_GRXSTSP_Device Register bits
    namespace otg_hs_grxstsp_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< Endpoint number
        constexpr uint32_t BCNT = (11 << 4);  ///< Byte count
        constexpr uint32_t DPID = (2 << 15);  ///< Data PID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< Packet status
        constexpr uint32_t FRMNUM = (4 << 21);  ///< Frame number
    }

    /// OTG_HS_GLPMCFG Register bits
    namespace otg_hs_glpmcfg_bits {
        constexpr uint32_t LPMEN = (1U << 0);  ///< LPM support enable
        constexpr uint32_t LPMACK = (1U << 1);  ///< LPM token acknowledge enable
        constexpr uint32_t BESL = (4 << 2);  ///< Best effort service latency
        constexpr uint32_t REMWAKE = (1U << 6);  ///< bRemoteWake value
        constexpr uint32_t L1SSEN = (1U << 7);  ///< L1 Shallow Sleep enable
        constexpr uint32_t BESLTHRS = (4 << 8);  ///< BESL threshold
        constexpr uint32_t L1DSEN = (1U << 12);  ///< L1 deep sleep enable
        constexpr uint32_t LPMRST = (2 << 13);  ///< LPM response
        constexpr uint32_t SLPSTS = (1U << 15);  ///< Port sleep status
        constexpr uint32_t L1RSMOK = (1U << 16);  ///< Sleep State Resume OK
        constexpr uint32_t LPMCHIDX = (4 << 17);  ///< LPM Channel Index
        constexpr uint32_t LPMRCNT = (3 << 21);  ///< LPM retry count
        constexpr uint32_t SNDLPM = (1U << 24);  ///< Send LPM transaction
        constexpr uint32_t LPMRCNTSTS = (3 << 25);  ///< LPM retry count status
        constexpr uint32_t ENBESL = (1U << 28);  ///< Enable best effort service latency
    }

}

// ============================================================================
// OTG2 Peripheral
// ============================================================================

namespace otg2 {
    /// Base addresses
    constexpr uint32_t OTG2_HS_GLOBAL_BASE = 0x40080000;
    constexpr uint32_t OTG2_HS_HOST_BASE = 0x40080400;
    constexpr uint32_t OTG2_HS_DEVICE_BASE = 0x40080800;

    /// OTG2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* OTG2_HS_GLOBAL = reinterpret_cast<Registers*>(OTG2_HS_GLOBAL_BASE);
    inline Registers* OTG2_HS_HOST = reinterpret_cast<Registers*>(OTG2_HS_HOST_BASE);
    inline Registers* OTG2_HS_DEVICE = reinterpret_cast<Registers*>(OTG2_HS_DEVICE_BASE);

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t Ethernet_MTL_BASE = 0x40028C00;
    constexpr uint32_t Ethernet_MAC_BASE = 0x40028000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t MTLOMR;  ///< Offset: 0x00 - Operating mode Register
        volatile uint32_t MTLISR;  ///< Offset: 0x20 - Interrupt status Register
        volatile uint32_t MTLTxQOMR;  ///< Offset: 0x100 - Tx queue operating mode Register
        volatile uint32_t MTLTxQUR;  ///< Offset: 0x104 - Tx queue underflow register
        volatile uint32_t MTLTxQDR;  ///< Offset: 0x108 - Tx queue debug Register
        volatile uint32_t MTLQICSR;  ///< Offset: 0x12C - Queue interrupt control status Register
        volatile uint32_t MTLRxQOMR;  ///< Offset: 0x130 - Rx queue operating mode register
        volatile uint32_t MTLRxQMPOCR;  ///< Offset: 0x134 - Rx queue missed packet and overflow counter register
        volatile uint32_t MTLRxQDR;  ///< Offset: 0x138 - Rx queue debug register
    };

    /// Peripheral instances
    inline Registers* Ethernet_MTL = reinterpret_cast<Registers*>(Ethernet_MTL_BASE);
    inline Registers* Ethernet_MAC = reinterpret_cast<Registers*>(Ethernet_MAC_BASE);

    // Bit definitions
    /// MTLOMR Register bits
    namespace mtlomr_bits {
        constexpr uint32_t DTXSTS = (1U << 1);  ///< DTXSTS
        constexpr uint32_t CNTPRST = (1U << 8);  ///< CNTPRST
        constexpr uint32_t CNTCLR = (1U << 9);  ///< CNTCLR
    }

    /// MTLISR Register bits
    namespace mtlisr_bits {
        constexpr uint32_t Q0IS = (1U << 0);  ///< Queue interrupt status
    }

    /// MTLTxQOMR Register bits
    namespace mtltxqomr_bits {
        constexpr uint32_t FTQ = (1U << 0);  ///< Flush Transmit Queue
        constexpr uint32_t TSF = (1U << 1);  ///< Transmit Store and Forward
        constexpr uint32_t TXQEN = (2 << 2);  ///< Transmit Queue Enable
        constexpr uint32_t TTC = (3 << 4);  ///< Transmit Threshold Control
        constexpr uint32_t TQS = (3 << 16);  ///< Transmit Queue Size
    }

    /// MTLTxQUR Register bits
    namespace mtltxqur_bits {
        constexpr uint32_t UFFRMCNT = (11 << 0);  ///< Underflow Packet Counter
        constexpr uint32_t UFCNTOVF = (1U << 11);  ///< UFCNTOVF
    }

    /// MTLTxQDR Register bits
    namespace mtltxqdr_bits {
        constexpr uint32_t TXQPAUSED = (1U << 0);  ///< TXQPAUSED
        constexpr uint32_t TRCSTS = (2 << 1);  ///< TRCSTS
        constexpr uint32_t TWCSTS = (1U << 3);  ///< TWCSTS
        constexpr uint32_t TXQSTS = (1U << 4);  ///< TXQSTS
        constexpr uint32_t TXSTSFSTS = (1U << 5);  ///< TXSTSFSTS
        constexpr uint32_t PTXQ = (3 << 16);  ///< PTXQ
        constexpr uint32_t STXSTSF = (3 << 20);  ///< STXSTSF
    }

    /// MTLQICSR Register bits
    namespace mtlqicsr_bits {
        constexpr uint32_t TXUNFIS = (1U << 0);  ///< TXUNFIS
        constexpr uint32_t TXUIE = (1U << 8);  ///< TXUIE
        constexpr uint32_t RXOVFIS = (1U << 16);  ///< RXOVFIS
        constexpr uint32_t RXOIE = (1U << 24);  ///< RXOIE
    }

    /// MTLRxQOMR Register bits
    namespace mtlrxqomr_bits {
        constexpr uint32_t RTC = (2 << 0);  ///< RTC
        constexpr uint32_t FUP = (1U << 3);  ///< FUP
        constexpr uint32_t FEP = (1U << 4);  ///< FEP
        constexpr uint32_t RSF = (1U << 5);  ///< RSF
        constexpr uint32_t DIS_TCP_EF = (1U << 6);  ///< DIS_TCP_EF
        constexpr uint32_t EHFC = (1U << 7);  ///< EHFC
        constexpr uint32_t RFA = (3 << 8);  ///< RFA
        constexpr uint32_t RFD = (3 << 14);  ///< RFD
        constexpr uint32_t RQS = (3 << 20);  ///< RQS
    }

    /// MTLRxQMPOCR Register bits
    namespace mtlrxqmpocr_bits {
        constexpr uint32_t OVFPKTCNT = (11 << 0);  ///< OVFPKTCNT
        constexpr uint32_t OVFCNTOVF = (1U << 11);  ///< OVFCNTOVF
        constexpr uint32_t MISPKTCNT = (11 << 16);  ///< MISPKTCNT
        constexpr uint32_t MISCNTOVF = (1U << 27);  ///< MISCNTOVF
    }

    /// MTLRxQDR Register bits
    namespace mtlrxqdr_bits {
        constexpr uint32_t RWCSTS = (1U << 0);  ///< RWCSTS
        constexpr uint32_t RRCSTS = (2 << 1);  ///< RRCSTS
        constexpr uint32_t RXQSTS = (2 << 4);  ///< RXQSTS
        constexpr uint32_t PRXQ = (14 << 16);  ///< PRXQ
    }

}

// ============================================================================
// DFSDM Peripheral
// ============================================================================

namespace dfsdm {
    /// Base addresses
    constexpr uint32_t DFSDM_BASE = 0x40017000;

    /// DFSDM Register structure
    struct Registers {
        volatile uint32_t DFSDM_CHCFG0R1;  ///< Offset: 0x00 - DFSDM channel configuration 0 register 1
        volatile uint32_t DFSDM_CHCFG1R1;  ///< Offset: 0x04 - DFSDM channel configuration 1 register 1
        volatile uint32_t DFSDM_CHCFG2R1;  ///< Offset: 0x08 - DFSDM channel configuration 2 register 1
        volatile uint32_t DFSDM_CHCFG3R1;  ///< Offset: 0x0C - DFSDM channel configuration 3 register 1
        volatile uint32_t DFSDM_CHCFG4R1;  ///< Offset: 0x10 - DFSDM channel configuration 4 register 1
        volatile uint32_t DFSDM_CHCFG5R1;  ///< Offset: 0x14 - DFSDM channel configuration 5 register 1
        volatile uint32_t DFSDM_CHCFG6R1;  ///< Offset: 0x18 - DFSDM channel configuration 6 register 1
        volatile uint32_t DFSDM_CHCFG7R1;  ///< Offset: 0x1C - DFSDM channel configuration 7 register 1
        volatile uint32_t DFSDM_CHCFG0R2;  ///< Offset: 0x20 - DFSDM channel configuration 0 register 2
        volatile uint32_t DFSDM_CHCFG1R2;  ///< Offset: 0x24 - DFSDM channel configuration 1 register 2
        volatile uint32_t DFSDM_CHCFG2R2;  ///< Offset: 0x28 - DFSDM channel configuration 2 register 2
        volatile uint32_t DFSDM_CHCFG3R2;  ///< Offset: 0x2C - DFSDM channel configuration 3 register 2
        volatile uint32_t DFSDM_CHCFG4R2;  ///< Offset: 0x30 - DFSDM channel configuration 4 register 2
        volatile uint32_t DFSDM_CHCFG5R2;  ///< Offset: 0x34 - DFSDM channel configuration 5 register 2
        volatile uint32_t DFSDM_CHCFG6R2;  ///< Offset: 0x38 - DFSDM channel configuration 6 register 2
        volatile uint32_t DFSDM_CHCFG7R2;  ///< Offset: 0x3C - DFSDM channel configuration 7 register 2
        volatile uint32_t DFSDM_AWSCD0R;  ///< Offset: 0x40 - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD1R;  ///< Offset: 0x44 - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD2R;  ///< Offset: 0x48 - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD3R;  ///< Offset: 0x4C - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD4R;  ///< Offset: 0x50 - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD5R;  ///< Offset: 0x54 - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD6R;  ///< Offset: 0x58 - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_AWSCD7R;  ///< Offset: 0x5C - DFSDM analog watchdog and short-circuit detector register
        volatile uint32_t DFSDM_CHWDAT0R;  ///< Offset: 0x60 - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT1R;  ///< Offset: 0x64 - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT2R;  ///< Offset: 0x68 - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT3R;  ///< Offset: 0x6C - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT4R;  ///< Offset: 0x70 - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT5R;  ///< Offset: 0x74 - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT6R;  ///< Offset: 0x78 - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHWDAT7R;  ///< Offset: 0x7C - DFSDM channel watchdog filter data register
        volatile uint32_t DFSDM_CHDATIN0R;  ///< Offset: 0x80 - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN1R;  ///< Offset: 0x84 - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN2R;  ///< Offset: 0x88 - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN3R;  ///< Offset: 0x8C - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN4R;  ///< Offset: 0x90 - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN5R;  ///< Offset: 0x94 - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN6R;  ///< Offset: 0x98 - DFSDM channel data input register
        volatile uint32_t DFSDM_CHDATIN7R;  ///< Offset: 0x9C - DFSDM channel data input register
        volatile uint32_t DFSDM0_CR1;  ///< Offset: 0xA0 - DFSDM control register 1
        volatile uint32_t DFSDM1_CR1;  ///< Offset: 0xA4 - DFSDM control register 1
        volatile uint32_t DFSDM2_CR1;  ///< Offset: 0xA8 - DFSDM control register 1
        volatile uint32_t DFSDM3_CR1;  ///< Offset: 0xAC - DFSDM control register 1
        volatile uint32_t DFSDM0_CR2;  ///< Offset: 0xB0 - DFSDM control register 2
        volatile uint32_t DFSDM1_CR2;  ///< Offset: 0xB4 - DFSDM control register 2
        volatile uint32_t DFSDM2_CR2;  ///< Offset: 0xB8 - DFSDM control register 2
        volatile uint32_t DFSDM3_CR2;  ///< Offset: 0xBC - DFSDM control register 2
        volatile uint32_t DFSDM0_ISR;  ///< Offset: 0xC0 - DFSDM interrupt and status register
        volatile uint32_t DFSDM1_ISR;  ///< Offset: 0xC4 - DFSDM interrupt and status register
        volatile uint32_t DFSDM2_ISR;  ///< Offset: 0xC8 - DFSDM interrupt and status register
        volatile uint32_t DFSDM3_ISR;  ///< Offset: 0xCC - DFSDM interrupt and status register
        volatile uint32_t DFSDM0_ICR;  ///< Offset: 0xD0 - DFSDM interrupt flag clear register
        volatile uint32_t DFSDM1_ICR;  ///< Offset: 0xD4 - DFSDM interrupt flag clear register
        volatile uint32_t DFSDM2_ICR;  ///< Offset: 0xD8 - DFSDM interrupt flag clear register
        volatile uint32_t DFSDM3_ICR;  ///< Offset: 0xDC - DFSDM interrupt flag clear register
        volatile uint32_t DFSDM0_JCHGR;  ///< Offset: 0xE0 - DFSDM injected channel group selection register
        volatile uint32_t DFSDM1_JCHGR;  ///< Offset: 0xE4 - DFSDM injected channel group selection register
        volatile uint32_t DFSDM2_JCHGR;  ///< Offset: 0xE8 - DFSDM injected channel group selection register
        volatile uint32_t DFSDM3_JCHGR;  ///< Offset: 0xEC - DFSDM injected channel group selection register
        volatile uint32_t DFSDM0_FCR;  ///< Offset: 0xF0 - DFSDM filter control register
        volatile uint32_t DFSDM1_FCR;  ///< Offset: 0xF4 - DFSDM filter control register
        volatile uint32_t DFSDM2_FCR;  ///< Offset: 0xF8 - DFSDM filter control register
        volatile uint32_t DFSDM3_FCR;  ///< Offset: 0xFC - DFSDM filter control register
        volatile uint32_t DFSDM0_JDATAR;  ///< Offset: 0x100 - DFSDM data register for injected group
        volatile uint32_t DFSDM1_JDATAR;  ///< Offset: 0x104 - DFSDM data register for injected group
        volatile uint32_t DFSDM2_JDATAR;  ///< Offset: 0x108 - DFSDM data register for injected group
        volatile uint32_t DFSDM3_JDATAR;  ///< Offset: 0x10C - DFSDM data register for injected group
        volatile uint32_t DFSDM0_RDATAR;  ///< Offset: 0x110 - DFSDM data register for the regular channel
        volatile uint32_t DFSDM1_RDATAR;  ///< Offset: 0x114 - DFSDM data register for the regular channel
        volatile uint32_t DFSDM2_RDATAR;  ///< Offset: 0x118 - DFSDM data register for the regular channel
        volatile uint32_t DFSDM3_RDATAR;  ///< Offset: 0x11C - DFSDM data register for the regular channel
        volatile uint32_t DFSDM0_AWHTR;  ///< Offset: 0x120 - DFSDM analog watchdog high threshold register
        volatile uint32_t DFSDM1_AWHTR;  ///< Offset: 0x124 - DFSDM analog watchdog high threshold register
        volatile uint32_t DFSDM2_AWHTR;  ///< Offset: 0x128 - DFSDM analog watchdog high threshold register
        volatile uint32_t DFSDM3_AWHTR;  ///< Offset: 0x12C - DFSDM analog watchdog high threshold register
        volatile uint32_t DFSDM0_AWLTR;  ///< Offset: 0x130 - DFSDM analog watchdog low threshold register
        volatile uint32_t DFSDM1_AWLTR;  ///< Offset: 0x134 - DFSDM analog watchdog low threshold register
        volatile uint32_t DFSDM2_AWLTR;  ///< Offset: 0x138 - DFSDM analog watchdog low threshold register
        volatile uint32_t DFSDM3_AWLTR;  ///< Offset: 0x13C - DFSDM analog watchdog low threshold register
        volatile uint32_t DFSDM0_AWSR;  ///< Offset: 0x140 - DFSDM analog watchdog status register
        volatile uint32_t DFSDM1_AWSR;  ///< Offset: 0x144 - DFSDM analog watchdog status register
        volatile uint32_t DFSDM2_AWSR;  ///< Offset: 0x148 - DFSDM analog watchdog status register
        volatile uint32_t DFSDM3_AWSR;  ///< Offset: 0x14C - DFSDM analog watchdog status register
        volatile uint32_t DFSDM0_AWCFR;  ///< Offset: 0x150 - DFSDM analog watchdog clear flag register
        volatile uint32_t DFSDM1_AWCFR;  ///< Offset: 0x154 - DFSDM analog watchdog clear flag register
        volatile uint32_t DFSDM2_AWCFR;  ///< Offset: 0x158 - DFSDM analog watchdog clear flag register
        volatile uint32_t DFSDM3_AWCFR;  ///< Offset: 0x15C - DFSDM analog watchdog clear flag register
        volatile uint32_t DFSDM0_EXMAX;  ///< Offset: 0x160 - DFSDM Extremes detector maximum register
        volatile uint32_t DFSDM1_EXMAX;  ///< Offset: 0x164 - DFSDM Extremes detector maximum register
        volatile uint32_t DFSDM2_EXMAX;  ///< Offset: 0x168 - DFSDM Extremes detector maximum register
        volatile uint32_t DFSDM3_EXMAX;  ///< Offset: 0x16C - DFSDM Extremes detector maximum register
        volatile uint32_t DFSDM0_EXMIN;  ///< Offset: 0x170 - DFSDM Extremes detector minimum register
        volatile uint32_t DFSDM1_EXMIN;  ///< Offset: 0x174 - DFSDM Extremes detector minimum register
        volatile uint32_t DFSDM2_EXMIN;  ///< Offset: 0x178 - DFSDM Extremes detector minimum register
        volatile uint32_t DFSDM3_EXMIN;  ///< Offset: 0x17C - DFSDM Extremes detector minimum register
        volatile uint32_t DFSDM0_CNVTIMR;  ///< Offset: 0x180 - DFSDM conversion timer register
        volatile uint32_t DFSDM1_CNVTIMR;  ///< Offset: 0x184 - DFSDM conversion timer register
        volatile uint32_t DFSDM2_CNVTIMR;  ///< Offset: 0x188 - DFSDM conversion timer register
        volatile uint32_t DFSDM3_CNVTIMR;  ///< Offset: 0x18C - DFSDM conversion timer register
    };

    /// Peripheral instances
    inline Registers* DFSDM = reinterpret_cast<Registers*>(DFSDM_BASE);

    // Bit definitions
    /// DFSDM_CHCFG0R1 Register bits
    namespace dfsdm_chcfg0r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 0
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 0
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 0
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 0
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 0 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 0
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG1R1 Register bits
    namespace dfsdm_chcfg1r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 1
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 1
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 1
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 1
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 1 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 1
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG2R1 Register bits
    namespace dfsdm_chcfg2r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 2
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 2
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 2
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 2
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 2 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 2
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG3R1 Register bits
    namespace dfsdm_chcfg3r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 3
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 3
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 3
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 3
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 3 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 3
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG4R1 Register bits
    namespace dfsdm_chcfg4r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 4
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 4
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 4
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 4
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 4 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 4
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG5R1 Register bits
    namespace dfsdm_chcfg5r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 5
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 5
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 5
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 5
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 5 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 5
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG6R1 Register bits
    namespace dfsdm_chcfg6r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 6
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 6
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 6
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 6
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 6 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 6
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG7R1 Register bits
    namespace dfsdm_chcfg7r1_bits {
        constexpr uint32_t SITP = (2 << 0);  ///< Serial interface type for channel 7
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPI clock select for channel 7
        constexpr uint32_t SCDEN = (1U << 5);  ///< Short-circuit detector enable on channel 7
        constexpr uint32_t CKABEN = (1U << 6);  ///< Clock absence detector enable on channel 7
        constexpr uint32_t CHEN = (1U << 7);  ///< Channel 7 enable
        constexpr uint32_t CHINSEL = (1U << 8);  ///< Channel inputs selection
        constexpr uint32_t DATMPX = (2 << 12);  ///< Input data multiplexer for channel 7
        constexpr uint32_t DATPACK = (2 << 14);  ///< Data packing mode in DFSDM_CHDATINyR register
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// DFSDM_CHCFG0R2 Register bits
    namespace dfsdm_chcfg0r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 0
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 0
    }

    /// DFSDM_CHCFG1R2 Register bits
    namespace dfsdm_chcfg1r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 1
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 1
    }

    /// DFSDM_CHCFG2R2 Register bits
    namespace dfsdm_chcfg2r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 2
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 2
    }

    /// DFSDM_CHCFG3R2 Register bits
    namespace dfsdm_chcfg3r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 3
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 3
    }

    /// DFSDM_CHCFG4R2 Register bits
    namespace dfsdm_chcfg4r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 4
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 4
    }

    /// DFSDM_CHCFG5R2 Register bits
    namespace dfsdm_chcfg5r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 5
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 5
    }

    /// DFSDM_CHCFG6R2 Register bits
    namespace dfsdm_chcfg6r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 6
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 6
    }

    /// DFSDM_CHCFG7R2 Register bits
    namespace dfsdm_chcfg7r2_bits {
        constexpr uint32_t DTRBS = (5 << 3);  ///< Data right bit-shift for channel 7
        constexpr uint32_t OFFSET = (24 << 8);  ///< 24-bit calibration offset for channel 7
    }

    /// DFSDM_AWSCD0R Register bits
    namespace dfsdm_awscd0r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 0
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 0
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 0
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 0
    }

    /// DFSDM_AWSCD1R Register bits
    namespace dfsdm_awscd1r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 1
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 1
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 1
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 1
    }

    /// DFSDM_AWSCD2R Register bits
    namespace dfsdm_awscd2r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 2
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 2
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 2
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 2
    }

    /// DFSDM_AWSCD3R Register bits
    namespace dfsdm_awscd3r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 3
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 3
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 3
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 3
    }

    /// DFSDM_AWSCD4R Register bits
    namespace dfsdm_awscd4r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 4
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 4
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 4
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 4
    }

    /// DFSDM_AWSCD5R Register bits
    namespace dfsdm_awscd5r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 5
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 5
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 5
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 5
    }

    /// DFSDM_AWSCD6R Register bits
    namespace dfsdm_awscd6r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 6
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 6
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 6
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 6
    }

    /// DFSDM_AWSCD7R Register bits
    namespace dfsdm_awscd7r_bits {
        constexpr uint32_t SCDT = (8 << 0);  ///< short-circuit detector threshold for channel 7
        constexpr uint32_t BKSCD = (4 << 12);  ///< Break signal assignment for short-circuit detector on channel 7
        constexpr uint32_t AWFOSR = (5 << 16);  ///< Analog watchdog filter oversampling ratio (decimation rate) on channel 7
        constexpr uint32_t AWFORD = (2 << 22);  ///< Analog watchdog Sinc filter order on channel 7
    }

    /// DFSDM_CHWDAT0R Register bits
    namespace dfsdm_chwdat0r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT1R Register bits
    namespace dfsdm_chwdat1r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT2R Register bits
    namespace dfsdm_chwdat2r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT3R Register bits
    namespace dfsdm_chwdat3r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT4R Register bits
    namespace dfsdm_chwdat4r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT5R Register bits
    namespace dfsdm_chwdat5r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT6R Register bits
    namespace dfsdm_chwdat6r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHWDAT7R Register bits
    namespace dfsdm_chwdat7r_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Input channel y watchdog data
    }

    /// DFSDM_CHDATIN0R Register bits
    namespace dfsdm_chdatin0r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 0
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 1
    }

    /// DFSDM_CHDATIN1R Register bits
    namespace dfsdm_chdatin1r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 1
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 2
    }

    /// DFSDM_CHDATIN2R Register bits
    namespace dfsdm_chdatin2r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 2
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 3
    }

    /// DFSDM_CHDATIN3R Register bits
    namespace dfsdm_chdatin3r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 3
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 4
    }

    /// DFSDM_CHDATIN4R Register bits
    namespace dfsdm_chdatin4r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 4
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 5
    }

    /// DFSDM_CHDATIN5R Register bits
    namespace dfsdm_chdatin5r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 5
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 6
    }

    /// DFSDM_CHDATIN6R Register bits
    namespace dfsdm_chdatin6r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 6
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 7
    }

    /// DFSDM_CHDATIN7R Register bits
    namespace dfsdm_chdatin7r_bits {
        constexpr uint32_t INDAT0 = (16 << 0);  ///< Input data for channel 7
        constexpr uint32_t INDAT1 = (16 << 16);  ///< Input data for channel 8
    }

    /// DFSDM0_CR1 Register bits
    namespace dfsdm0_cr1_bits {
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JEXTSEL = (5 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
    }

    /// DFSDM1_CR1 Register bits
    namespace dfsdm1_cr1_bits {
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JEXTSEL = (5 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
    }

    /// DFSDM2_CR1 Register bits
    namespace dfsdm2_cr1_bits {
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JEXTSEL = (5 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
    }

    /// DFSDM3_CR1 Register bits
    namespace dfsdm3_cr1_bits {
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JEXTSEL = (5 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
    }

    /// DFSDM0_CR2 Register bits
    namespace dfsdm0_cr2_bits {
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
    }

    /// DFSDM1_CR2 Register bits
    namespace dfsdm1_cr2_bits {
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
    }

    /// DFSDM2_CR2 Register bits
    namespace dfsdm2_cr2_bits {
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
    }

    /// DFSDM3_CR2 Register bits
    namespace dfsdm3_cr2_bits {
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
    }

    /// DFSDM0_ISR Register bits
    namespace dfsdm0_isr_bits {
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
    }

    /// DFSDM1_ISR Register bits
    namespace dfsdm1_isr_bits {
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
    }

    /// DFSDM2_ISR Register bits
    namespace dfsdm2_isr_bits {
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
    }

    /// DFSDM3_ISR Register bits
    namespace dfsdm3_isr_bits {
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
    }

    /// DFSDM0_ICR Register bits
    namespace dfsdm0_icr_bits {
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
    }

    /// DFSDM1_ICR Register bits
    namespace dfsdm1_icr_bits {
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
    }

    /// DFSDM2_ICR Register bits
    namespace dfsdm2_icr_bits {
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
    }

    /// DFSDM3_ICR Register bits
    namespace dfsdm3_icr_bits {
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
    }

    /// DFSDM0_JCHGR Register bits
    namespace dfsdm0_jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// DFSDM1_JCHGR Register bits
    namespace dfsdm1_jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// DFSDM2_JCHGR Register bits
    namespace dfsdm2_jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// DFSDM3_JCHGR Register bits
    namespace dfsdm3_jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// DFSDM0_FCR Register bits
    namespace dfsdm0_fcr_bits {
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
    }

    /// DFSDM1_FCR Register bits
    namespace dfsdm1_fcr_bits {
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
    }

    /// DFSDM2_FCR Register bits
    namespace dfsdm2_fcr_bits {
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
    }

    /// DFSDM3_FCR Register bits
    namespace dfsdm3_fcr_bits {
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
    }

    /// DFSDM0_JDATAR Register bits
    namespace dfsdm0_jdatar_bits {
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
    }

    /// DFSDM1_JDATAR Register bits
    namespace dfsdm1_jdatar_bits {
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
    }

    /// DFSDM2_JDATAR Register bits
    namespace dfsdm2_jdatar_bits {
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
    }

    /// DFSDM3_JDATAR Register bits
    namespace dfsdm3_jdatar_bits {
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
    }

    /// DFSDM0_RDATAR Register bits
    namespace dfsdm0_rdatar_bits {
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
    }

    /// DFSDM1_RDATAR Register bits
    namespace dfsdm1_rdatar_bits {
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
    }

    /// DFSDM2_RDATAR Register bits
    namespace dfsdm2_rdatar_bits {
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
    }

    /// DFSDM3_RDATAR Register bits
    namespace dfsdm3_rdatar_bits {
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
    }

    /// DFSDM0_AWHTR Register bits
    namespace dfsdm0_awhtr_bits {
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
    }

    /// DFSDM1_AWHTR Register bits
    namespace dfsdm1_awhtr_bits {
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
    }

    /// DFSDM2_AWHTR Register bits
    namespace dfsdm2_awhtr_bits {
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
    }

    /// DFSDM3_AWHTR Register bits
    namespace dfsdm3_awhtr_bits {
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
    }

    /// DFSDM0_AWLTR Register bits
    namespace dfsdm0_awltr_bits {
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
    }

    /// DFSDM1_AWLTR Register bits
    namespace dfsdm1_awltr_bits {
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
    }

    /// DFSDM2_AWLTR Register bits
    namespace dfsdm2_awltr_bits {
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
    }

    /// DFSDM3_AWLTR Register bits
    namespace dfsdm3_awltr_bits {
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
    }

    /// DFSDM0_AWSR Register bits
    namespace dfsdm0_awsr_bits {
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
    }

    /// DFSDM1_AWSR Register bits
    namespace dfsdm1_awsr_bits {
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
    }

    /// DFSDM2_AWSR Register bits
    namespace dfsdm2_awsr_bits {
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
    }

    /// DFSDM3_AWSR Register bits
    namespace dfsdm3_awsr_bits {
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
    }

    /// DFSDM0_AWCFR Register bits
    namespace dfsdm0_awcfr_bits {
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
    }

    /// DFSDM1_AWCFR Register bits
    namespace dfsdm1_awcfr_bits {
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
    }

    /// DFSDM2_AWCFR Register bits
    namespace dfsdm2_awcfr_bits {
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
    }

    /// DFSDM3_AWCFR Register bits
    namespace dfsdm3_awcfr_bits {
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
    }

    /// DFSDM0_EXMAX Register bits
    namespace dfsdm0_exmax_bits {
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
    }

    /// DFSDM1_EXMAX Register bits
    namespace dfsdm1_exmax_bits {
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
    }

    /// DFSDM2_EXMAX Register bits
    namespace dfsdm2_exmax_bits {
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
    }

    /// DFSDM3_EXMAX Register bits
    namespace dfsdm3_exmax_bits {
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
    }

    /// DFSDM0_EXMIN Register bits
    namespace dfsdm0_exmin_bits {
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
        constexpr uint32_t EXMIN = (24 << 8);  ///< Extremes detector minimum value
    }

    /// DFSDM1_EXMIN Register bits
    namespace dfsdm1_exmin_bits {
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
        constexpr uint32_t EXMIN = (24 << 8);  ///< Extremes detector minimum value
    }

    /// DFSDM2_EXMIN Register bits
    namespace dfsdm2_exmin_bits {
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
        constexpr uint32_t EXMIN = (24 << 8);  ///< Extremes detector minimum value
    }

    /// DFSDM3_EXMIN Register bits
    namespace dfsdm3_exmin_bits {
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
        constexpr uint32_t EXMIN = (24 << 8);  ///< Extremes detector minimum value
    }

    /// DFSDM0_CNVTIMR Register bits
    namespace dfsdm0_cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time
    }

    /// DFSDM1_CNVTIMR Register bits
    namespace dfsdm1_cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time
    }

    /// DFSDM2_CNVTIMR Register bits
    namespace dfsdm2_cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time
    }

    /// DFSDM3_CNVTIMR Register bits
    namespace dfsdm3_cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t FDCAN1_BASE = 0x4000A000;
    constexpr uint32_t FDCAN2_BASE = 0x4000A400;
    constexpr uint32_t CAN_CCU_BASE = 0x4000A800;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t FDCAN_CREL;  ///< Offset: 0x00 - FDCAN Core Release Register
        volatile uint32_t FDCAN_ENDN;  ///< Offset: 0x04 - FDCAN Core Release Register
        volatile uint32_t FDCAN_DBTP;  ///< Offset: 0x0C - FDCAN Data Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TEST;  ///< Offset: 0x10 - FDCAN Test Register
        volatile uint32_t FDCAN_RWD;  ///< Offset: 0x14 - FDCAN RAM Watchdog Register
        volatile uint32_t FDCAN_CCCR;  ///< Offset: 0x18 - FDCAN CC Control Register
        volatile uint32_t FDCAN_NBTP;  ///< Offset: 0x1C - FDCAN Nominal Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TSCC;  ///< Offset: 0x20 - FDCAN Timestamp Counter Configuration Register
        volatile uint32_t FDCAN_TSCV;  ///< Offset: 0x24 - FDCAN Timestamp Counter Value Register
        volatile uint32_t FDCAN_TOCC;  ///< Offset: 0x28 - FDCAN Timeout Counter Configuration Register
        volatile uint32_t FDCAN_TOCV;  ///< Offset: 0x2C - FDCAN Timeout Counter Value Register
        volatile uint32_t FDCAN_ECR;  ///< Offset: 0x40 - FDCAN Error Counter Register
        volatile uint32_t FDCAN_PSR;  ///< Offset: 0x44 - FDCAN Protocol Status Register
        volatile uint32_t FDCAN_TDCR;  ///< Offset: 0x48 - FDCAN Transmitter Delay Compensation Register
        volatile uint32_t FDCAN_IR;  ///< Offset: 0x50 - FDCAN Interrupt Register
        volatile uint32_t FDCAN_IE;  ///< Offset: 0x54 - FDCAN Interrupt Enable Register
        volatile uint32_t FDCAN_ILS;  ///< Offset: 0x58 - FDCAN Interrupt Line Select Register
        volatile uint32_t FDCAN_ILE;  ///< Offset: 0x5C - FDCAN Interrupt Line Enable Register
        volatile uint32_t FDCAN_GFC;  ///< Offset: 0x80 - FDCAN Global Filter Configuration Register
        volatile uint32_t FDCAN_SIDFC;  ///< Offset: 0x84 - FDCAN Standard ID Filter Configuration Register
        volatile uint32_t FDCAN_XIDFC;  ///< Offset: 0x88 - FDCAN Extended ID Filter Configuration Register
        volatile uint32_t FDCAN_XIDAM;  ///< Offset: 0x90 - FDCAN Extended ID and Mask Register
        volatile uint32_t FDCAN_HPMS;  ///< Offset: 0x94 - FDCAN High Priority Message Status Register
        volatile uint32_t FDCAN_NDAT1;  ///< Offset: 0x98 - FDCAN New Data 1 Register
        volatile uint32_t FDCAN_NDAT2;  ///< Offset: 0x9C - FDCAN New Data 2 Register
        volatile uint32_t FDCAN_RXF0C;  ///< Offset: 0xA0 - FDCAN Rx FIFO 0 Configuration Register
        volatile uint32_t FDCAN_RXF0S;  ///< Offset: 0xA4 - FDCAN Rx FIFO 0 Status Register
        volatile uint32_t FDCAN_RXF0A;  ///< Offset: 0xA8 - CAN Rx FIFO 0 Acknowledge Register
        volatile uint32_t FDCAN_RXBC;  ///< Offset: 0xAC - FDCAN Rx Buffer Configuration Register
        volatile uint32_t FDCAN_RXF1C;  ///< Offset: 0xB0 - FDCAN Rx FIFO 1 Configuration Register
        volatile uint32_t FDCAN_RXF1S;  ///< Offset: 0xB4 - FDCAN Rx FIFO 1 Status Register
        volatile uint32_t FDCAN_RXF1A;  ///< Offset: 0xB8 - FDCAN Rx FIFO 1 Acknowledge Register
        volatile uint32_t FDCAN_RXESC;  ///< Offset: 0xBC - FDCAN Rx Buffer Element Size Configuration Register
        volatile uint32_t FDCAN_TXBC;  ///< Offset: 0xC0 - FDCAN Tx Buffer Configuration Register
        volatile uint32_t FDCAN_TXFQS;  ///< Offset: 0xC4 - FDCAN Tx FIFO/Queue Status Register
        volatile uint32_t FDCAN_TXESC;  ///< Offset: 0xC8 - FDCAN Tx Buffer Element Size Configuration Register
        volatile uint32_t FDCAN_TXBRP;  ///< Offset: 0xCC - FDCAN Tx Buffer Request Pending Register
        volatile uint32_t FDCAN_TXBAR;  ///< Offset: 0xD0 - FDCAN Tx Buffer Add Request Register
        volatile uint32_t FDCAN_TXBCR;  ///< Offset: 0xD4 - FDCAN Tx Buffer Cancellation Request Register
        volatile uint32_t FDCAN_TXBTO;  ///< Offset: 0xD8 - FDCAN Tx Buffer Transmission Occurred Register
        volatile uint32_t FDCAN_TXBCF;  ///< Offset: 0xDC - FDCAN Tx Buffer Cancellation Finished Register
        volatile uint32_t FDCAN_TXBTIE;  ///< Offset: 0xE0 - FDCAN Tx Buffer Transmission Interrupt Enable Register
        volatile uint32_t FDCAN_TXBCIE;  ///< Offset: 0xE4 - FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        volatile uint32_t FDCAN_TXEFC;  ///< Offset: 0xF0 - FDCAN Tx Event FIFO Configuration Register
        volatile uint32_t FDCAN_TXEFS;  ///< Offset: 0xF4 - FDCAN Tx Event FIFO Status Register
        volatile uint32_t FDCAN_TXEFA;  ///< Offset: 0xF8 - FDCAN Tx Event FIFO Acknowledge Register
        volatile uint32_t FDCAN_TTTMC;  ///< Offset: 0x100 - FDCAN TT Trigger Memory Configuration Register
        volatile uint32_t FDCAN_TTRMC;  ///< Offset: 0x104 - FDCAN TT Reference Message Configuration Register
        volatile uint32_t FDCAN_TTOCF;  ///< Offset: 0x108 - FDCAN TT Operation Configuration Register
        volatile uint32_t FDCAN_TTMLM;  ///< Offset: 0x10C - FDCAN TT Matrix Limits Register
        volatile uint32_t FDCAN_TURCF;  ///< Offset: 0x110 - FDCAN TUR Configuration Register
        volatile uint32_t FDCAN_TTOCN;  ///< Offset: 0x114 - FDCAN TT Operation Control Register
        volatile uint32_t CAN_TTGTP;  ///< Offset: 0x118 - FDCAN TT Global Time Preset Register
        volatile uint32_t FDCAN_TTTMK;  ///< Offset: 0x11C - FDCAN TT Time Mark Register
        volatile uint32_t FDCAN_TTIR;  ///< Offset: 0x120 - FDCAN TT Interrupt Register
        volatile uint32_t FDCAN_TTIE;  ///< Offset: 0x124 - FDCAN TT Interrupt Enable Register
        volatile uint32_t FDCAN_TTILS;  ///< Offset: 0x128 - FDCAN TT Interrupt Line Select Register
        volatile uint32_t FDCAN_TTOST;  ///< Offset: 0x12C - FDCAN TT Operation Status Register
        volatile uint32_t FDCAN_TURNA;  ///< Offset: 0x130 - FDCAN TUR Numerator Actual Register
        volatile uint32_t FDCAN_TTLGT;  ///< Offset: 0x134 - FDCAN TT Local and Global Time Register
        volatile uint32_t FDCAN_TTCTC;  ///< Offset: 0x138 - FDCAN TT Cycle Time and Count Register
        volatile uint32_t FDCAN_TTCPT;  ///< Offset: 0x13C - FDCAN TT Capture Time Register
        volatile uint32_t FDCAN_TTCSM;  ///< Offset: 0x140 - FDCAN TT Cycle Sync Mark Register
        volatile uint32_t FDCAN_TTTS;  ///< Offset: 0x300 - FDCAN TT Trigger Select Register
    };

    /// Peripheral instances
    inline Registers* FDCAN1 = reinterpret_cast<Registers*>(FDCAN1_BASE);
    inline Registers* FDCAN2 = reinterpret_cast<Registers*>(FDCAN2_BASE);
    inline Registers* CAN_CCU = reinterpret_cast<Registers*>(CAN_CCU_BASE);

    // Bit definitions
    /// FDCAN_CREL Register bits
    namespace fdcan_crel_bits {
        constexpr uint32_t REL = (4 << 28);  ///< Core release
        constexpr uint32_t STEP = (4 << 24);  ///< Step of Core release
        constexpr uint32_t SUBSTEP = (4 << 20);  ///< Sub-step of Core release
        constexpr uint32_t YEAR = (4 << 16);  ///< Timestamp Year
        constexpr uint32_t MON = (8 << 8);  ///< Timestamp Month
        constexpr uint32_t DAY = (8 << 0);  ///< Timestamp Day
    }

    /// FDCAN_ENDN Register bits
    namespace fdcan_endn_bits {
        constexpr uint32_t ETV = (32 << 0);  ///< Endiannes Test Value
    }

    /// FDCAN_DBTP Register bits
    namespace fdcan_dbtp_bits {
        constexpr uint32_t DSJW = (4 << 0);  ///< Synchronization Jump Width
        constexpr uint32_t DTSEG2 = (4 << 4);  ///< Data time segment after sample point
        constexpr uint32_t DTSEG1 = (5 << 8);  ///< Data time segment after sample point
        constexpr uint32_t DBRP = (5 << 16);  ///< Data BIt Rate Prescaler
        constexpr uint32_t TDC = (1U << 23);  ///< Transceiver Delay Compensation
    }

    /// FDCAN_TEST Register bits
    namespace fdcan_test_bits {
        constexpr uint32_t LBCK = (1U << 4);  ///< Loop Back mode
        constexpr uint32_t TX = (2 << 5);  ///< Loop Back mode
        constexpr uint32_t RX = (1U << 7);  ///< Control of Transmit Pin
    }

    /// FDCAN_RWD Register bits
    namespace fdcan_rwd_bits {
        constexpr uint32_t WDV = (8 << 8);  ///< Watchdog value
        constexpr uint32_t WDC = (8 << 0);  ///< Watchdog configuration
    }

    /// FDCAN_CCCR Register bits
    namespace fdcan_cccr_bits {
        constexpr uint32_t INIT = (1U << 0);  ///< Initialization
        constexpr uint32_t CCE = (1U << 1);  ///< Configuration Change Enable
        constexpr uint32_t ASM = (1U << 2);  ///< ASM Restricted Operation Mode
        constexpr uint32_t CSA = (1U << 3);  ///< Clock Stop Acknowledge
        constexpr uint32_t CSR = (1U << 4);  ///< Clock Stop Request
        constexpr uint32_t MON = (1U << 5);  ///< Bus Monitoring Mode
        constexpr uint32_t DAR = (1U << 6);  ///< Disable Automatic Retransmission
        constexpr uint32_t TEST = (1U << 7);  ///< Test Mode Enable
        constexpr uint32_t FDOE = (1U << 8);  ///< FD Operation Enable
        constexpr uint32_t BSE = (1U << 9);  ///< FDCAN Bit Rate Switching
        constexpr uint32_t PXHD = (1U << 12);  ///< Protocol Exception Handling Disable
        constexpr uint32_t EFBI = (1U << 13);  ///< Edge Filtering during Bus Integration
        constexpr uint32_t TXP = (1U << 14);  ///< TXP
        constexpr uint32_t NISO = (1U << 15);  ///< Non ISO Operation
    }

    /// FDCAN_NBTP Register bits
    namespace fdcan_nbtp_bits {
        constexpr uint32_t NSJW = (7 << 25);  ///< NSJW: Nominal (Re)Synchronization Jump Width
        constexpr uint32_t NBRP = (9 << 16);  ///< Bit Rate Prescaler
        constexpr uint32_t NTSEG1 = (8 << 8);  ///< Nominal Time segment before sample point
        constexpr uint32_t TSEG2 = (7 << 0);  ///< Nominal Time segment after sample point
    }

    /// FDCAN_TSCC Register bits
    namespace fdcan_tscc_bits {
        constexpr uint32_t TCP = (4 << 16);  ///< Timestamp Counter Prescaler
        constexpr uint32_t TSS = (2 << 0);  ///< Timestamp Select
    }

    /// FDCAN_TSCV Register bits
    namespace fdcan_tscv_bits {
        constexpr uint32_t TSC = (16 << 0);  ///< Timestamp Counter
    }

    /// FDCAN_TOCC Register bits
    namespace fdcan_tocc_bits {
        constexpr uint32_t ETOC = (1U << 0);  ///< Enable Timeout Counter
        constexpr uint32_t TOS = (2 << 1);  ///< Timeout Select
        constexpr uint32_t TOP = (16 << 16);  ///< Timeout Period
    }

    /// FDCAN_TOCV Register bits
    namespace fdcan_tocv_bits {
        constexpr uint32_t TOC = (16 << 0);  ///< Timeout Counter
    }

    /// FDCAN_ECR Register bits
    namespace fdcan_ecr_bits {
        constexpr uint32_t CEL = (8 << 16);  ///< AN Error Logging
        constexpr uint32_t RP = (1U << 15);  ///< Receive Error Passive
        constexpr uint32_t TREC = (7 << 8);  ///< Receive Error Counter
        constexpr uint32_t TEC = (8 << 0);  ///< Transmit Error Counter
    }

    /// FDCAN_PSR Register bits
    namespace fdcan_psr_bits {
        constexpr uint32_t LEC = (3 << 0);  ///< Last Error Code
        constexpr uint32_t ACT = (2 << 3);  ///< Activity
        constexpr uint32_t EP = (1U << 5);  ///< Error Passive
        constexpr uint32_t EW = (1U << 6);  ///< Warning Status
        constexpr uint32_t BO = (1U << 7);  ///< Bus_Off Status
        constexpr uint32_t DLEC = (3 << 8);  ///< Data Last Error Code
        constexpr uint32_t RESI = (1U << 11);  ///< ESI flag of last received FDCAN Message
        constexpr uint32_t RBRS = (1U << 12);  ///< BRS flag of last received FDCAN Message
        constexpr uint32_t REDL = (1U << 13);  ///< Received FDCAN Message
        constexpr uint32_t PXE = (1U << 14);  ///< Protocol Exception Event
        constexpr uint32_t TDCV = (7 << 16);  ///< Transmitter Delay Compensation Value
    }

    /// FDCAN_TDCR Register bits
    namespace fdcan_tdcr_bits {
        constexpr uint32_t TDCF = (7 << 0);  ///< Transmitter Delay Compensation Filter Window Length
        constexpr uint32_t TDCO = (7 << 8);  ///< Transmitter Delay Compensation Offset
    }

    /// FDCAN_IR Register bits
    namespace fdcan_ir_bits {
        constexpr uint32_t RF0N = (1U << 0);  ///< Rx FIFO 0 New Message
        constexpr uint32_t RF0W = (1U << 1);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0F = (1U << 2);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0L = (1U << 3);  ///< Rx FIFO 0 Message Lost
        constexpr uint32_t RF1N = (1U << 4);  ///< Rx FIFO 1 New Message
        constexpr uint32_t RF1W = (1U << 5);  ///< Rx FIFO 1 Watermark Reached
        constexpr uint32_t RF1F = (1U << 6);  ///< Rx FIFO 1 Watermark Reached
        constexpr uint32_t RF1L = (1U << 7);  ///< Rx FIFO 1 Message Lost
        constexpr uint32_t HPM = (1U << 8);  ///< High Priority Message
        constexpr uint32_t TC = (1U << 9);  ///< Transmission Completed
        constexpr uint32_t TCF = (1U << 10);  ///< Transmission Cancellation Finished
        constexpr uint32_t TEF = (1U << 11);  ///< Tx FIFO Empty
        constexpr uint32_t TEFN = (1U << 12);  ///< Tx Event FIFO New Entry
        constexpr uint32_t TEFW = (1U << 13);  ///< Tx Event FIFO Watermark Reached
        constexpr uint32_t TEFF = (1U << 14);  ///< Tx Event FIFO Full
        constexpr uint32_t TEFL = (1U << 15);  ///< Tx Event FIFO Element Lost
        constexpr uint32_t TSW = (1U << 16);  ///< Timestamp Wraparound
        constexpr uint32_t MRAF = (1U << 17);  ///< Message RAM Access Failure
        constexpr uint32_t TOO = (1U << 18);  ///< Timeout Occurred
        constexpr uint32_t DRX = (1U << 19);  ///< Message stored to Dedicated Rx Buffer
        constexpr uint32_t ELO = (1U << 22);  ///< Error Logging Overflow
        constexpr uint32_t EP = (1U << 23);  ///< Error Passive
        constexpr uint32_t EW = (1U << 24);  ///< Warning Status
        constexpr uint32_t BO = (1U << 25);  ///< Bus_Off Status
        constexpr uint32_t WDI = (1U << 26);  ///< Watchdog Interrupt
        constexpr uint32_t PEA = (1U << 27);  ///< Protocol Error in Arbitration Phase (Nominal Bit Time is used)
        constexpr uint32_t PED = (1U << 28);  ///< Protocol Error in Data Phase (Data Bit Time is used)
        constexpr uint32_t ARA = (1U << 29);  ///< Access to Reserved Address
    }

    /// FDCAN_IE Register bits
    namespace fdcan_ie_bits {
        constexpr uint32_t RF0NE = (1U << 0);  ///< Rx FIFO 0 New Message Enable
        constexpr uint32_t RF0WE = (1U << 1);  ///< Rx FIFO 0 Full Enable
        constexpr uint32_t RF0FE = (1U << 2);  ///< Rx FIFO 0 Full Enable
        constexpr uint32_t RF0LE = (1U << 3);  ///< Rx FIFO 0 Message Lost Enable
        constexpr uint32_t RF1NE = (1U << 4);  ///< Rx FIFO 1 New Message Enable
        constexpr uint32_t RF1WE = (1U << 5);  ///< Rx FIFO 1 Watermark Reached Enable
        constexpr uint32_t RF1FE = (1U << 6);  ///< Rx FIFO 1 Watermark Reached Enable
        constexpr uint32_t RF1LE = (1U << 7);  ///< Rx FIFO 1 Message Lost Enable
        constexpr uint32_t HPME = (1U << 8);  ///< High Priority Message Enable
        constexpr uint32_t TCE = (1U << 9);  ///< Transmission Completed Enable
        constexpr uint32_t TCFE = (1U << 10);  ///< Transmission Cancellation Finished Enable
        constexpr uint32_t TEFE = (1U << 11);  ///< Tx FIFO Empty Enable
        constexpr uint32_t TEFNE = (1U << 12);  ///< Tx Event FIFO New Entry Enable
        constexpr uint32_t TEFWE = (1U << 13);  ///< Tx Event FIFO Watermark Reached Enable
        constexpr uint32_t TEFFE = (1U << 14);  ///< Tx Event FIFO Full Enable
        constexpr uint32_t TEFLE = (1U << 15);  ///< Tx Event FIFO Element Lost Enable
        constexpr uint32_t TSWE = (1U << 16);  ///< Timestamp Wraparound Enable
        constexpr uint32_t MRAFE = (1U << 17);  ///< Message RAM Access Failure Enable
        constexpr uint32_t TOOE = (1U << 18);  ///< Timeout Occurred Enable
        constexpr uint32_t DRXE = (1U << 19);  ///< Message stored to Dedicated Rx Buffer Enable
        constexpr uint32_t BECE = (1U << 20);  ///< Bit Error Corrected Interrupt Enable
        constexpr uint32_t BEUE = (1U << 21);  ///< Bit Error Uncorrected Interrupt Enable
        constexpr uint32_t ELOE = (1U << 22);  ///< Error Logging Overflow Enable
        constexpr uint32_t EPE = (1U << 23);  ///< Error Passive Enable
        constexpr uint32_t EWE = (1U << 24);  ///< Warning Status Enable
        constexpr uint32_t BOE = (1U << 25);  ///< Bus_Off Status Enable
        constexpr uint32_t WDIE = (1U << 26);  ///< Watchdog Interrupt Enable
        constexpr uint32_t PEAE = (1U << 27);  ///< Protocol Error in Arbitration Phase Enable
        constexpr uint32_t PEDE = (1U << 28);  ///< Protocol Error in Data Phase Enable
        constexpr uint32_t ARAE = (1U << 29);  ///< Access to Reserved Address Enable
    }

    /// FDCAN_ILS Register bits
    namespace fdcan_ils_bits {
        constexpr uint32_t RF0NL = (1U << 0);  ///< Rx FIFO 0 New Message Interrupt Line
        constexpr uint32_t RF0WL = (1U << 1);  ///< Rx FIFO 0 Watermark Reached Interrupt Line
        constexpr uint32_t RF0FL = (1U << 2);  ///< Rx FIFO 0 Full Interrupt Line
        constexpr uint32_t RF0LL = (1U << 3);  ///< Rx FIFO 0 Message Lost Interrupt Line
        constexpr uint32_t RF1NL = (1U << 4);  ///< Rx FIFO 1 New Message Interrupt Line
        constexpr uint32_t RF1WL = (1U << 5);  ///< Rx FIFO 1 Watermark Reached Interrupt Line
        constexpr uint32_t RF1FL = (1U << 6);  ///< Rx FIFO 1 Full Interrupt Line
        constexpr uint32_t RF1LL = (1U << 7);  ///< Rx FIFO 1 Message Lost Interrupt Line
        constexpr uint32_t HPML = (1U << 8);  ///< High Priority Message Interrupt Line
        constexpr uint32_t TCL = (1U << 9);  ///< Transmission Completed Interrupt Line
        constexpr uint32_t TCFL = (1U << 10);  ///< Transmission Cancellation Finished Interrupt Line
        constexpr uint32_t TEFL = (1U << 11);  ///< Tx FIFO Empty Interrupt Line
        constexpr uint32_t TEFNL = (1U << 12);  ///< Tx Event FIFO New Entry Interrupt Line
        constexpr uint32_t TEFWL = (1U << 13);  ///< Tx Event FIFO Watermark Reached Interrupt Line
        constexpr uint32_t TEFFL = (1U << 14);  ///< Tx Event FIFO Full Interrupt Line
        constexpr uint32_t TEFLL = (1U << 15);  ///< Tx Event FIFO Element Lost Interrupt Line
        constexpr uint32_t TSWL = (1U << 16);  ///< Timestamp Wraparound Interrupt Line
        constexpr uint32_t MRAFL = (1U << 17);  ///< Message RAM Access Failure Interrupt Line
        constexpr uint32_t TOOL = (1U << 18);  ///< Timeout Occurred Interrupt Line
        constexpr uint32_t DRXL = (1U << 19);  ///< Message stored to Dedicated Rx Buffer Interrupt Line
        constexpr uint32_t BECL = (1U << 20);  ///< Bit Error Corrected Interrupt Line
        constexpr uint32_t BEUL = (1U << 21);  ///< Bit Error Uncorrected Interrupt Line
        constexpr uint32_t ELOL = (1U << 22);  ///< Error Logging Overflow Interrupt Line
        constexpr uint32_t EPL = (1U << 23);  ///< Error Passive Interrupt Line
        constexpr uint32_t EWL = (1U << 24);  ///< Warning Status Interrupt Line
        constexpr uint32_t BOL = (1U << 25);  ///< Bus_Off Status
        constexpr uint32_t WDIL = (1U << 26);  ///< Watchdog Interrupt Line
        constexpr uint32_t PEAL = (1U << 27);  ///< Protocol Error in Arbitration Phase Line
        constexpr uint32_t PEDL = (1U << 28);  ///< Protocol Error in Data Phase Line
        constexpr uint32_t ARAL = (1U << 29);  ///< Access to Reserved Address Line
    }

    /// FDCAN_ILE Register bits
    namespace fdcan_ile_bits {
        constexpr uint32_t EINT0 = (1U << 0);  ///< Enable Interrupt Line 0
        constexpr uint32_t EINT1 = (1U << 1);  ///< Enable Interrupt Line 1
    }

    /// FDCAN_GFC Register bits
    namespace fdcan_gfc_bits {
        constexpr uint32_t RRFE = (1U << 0);  ///< Reject Remote Frames Extended
        constexpr uint32_t RRFS = (1U << 1);  ///< Reject Remote Frames Standard
        constexpr uint32_t ANFE = (2 << 2);  ///< Accept Non-matching Frames Extended
        constexpr uint32_t ANFS = (2 << 4);  ///< Accept Non-matching Frames Standard
    }

    /// FDCAN_SIDFC Register bits
    namespace fdcan_sidfc_bits {
        constexpr uint32_t FLSSA = (14 << 2);  ///< Filter List Standard Start Address
        constexpr uint32_t LSS = (8 << 16);  ///< List Size Standard
    }

    /// FDCAN_XIDFC Register bits
    namespace fdcan_xidfc_bits {
        constexpr uint32_t FLESA = (14 << 2);  ///< Filter List Standard Start Address
        constexpr uint32_t LSE = (8 << 16);  ///< List Size Extended
    }

    /// FDCAN_XIDAM Register bits
    namespace fdcan_xidam_bits {
        constexpr uint32_t EIDM = (29 << 0);  ///< Extended ID Mask
    }

    /// FDCAN_HPMS Register bits
    namespace fdcan_hpms_bits {
        constexpr uint32_t BIDX = (6 << 0);  ///< Buffer Index
        constexpr uint32_t MSI = (2 << 6);  ///< Message Storage Indicator
        constexpr uint32_t FIDX = (7 << 8);  ///< Filter Index
        constexpr uint32_t FLST = (1U << 15);  ///< Filter List
    }

    /// FDCAN_NDAT1 Register bits
    namespace fdcan_ndat1_bits {
        constexpr uint32_t ND0 = (1U << 0);  ///< New data
        constexpr uint32_t ND1 = (1U << 1);  ///< New data
        constexpr uint32_t ND2 = (1U << 2);  ///< New data
        constexpr uint32_t ND3 = (1U << 3);  ///< New data
        constexpr uint32_t ND4 = (1U << 4);  ///< New data
        constexpr uint32_t ND5 = (1U << 5);  ///< New data
        constexpr uint32_t ND6 = (1U << 6);  ///< New data
        constexpr uint32_t ND7 = (1U << 7);  ///< New data
        constexpr uint32_t ND8 = (1U << 8);  ///< New data
        constexpr uint32_t ND9 = (1U << 9);  ///< New data
        constexpr uint32_t ND10 = (1U << 10);  ///< New data
        constexpr uint32_t ND11 = (1U << 11);  ///< New data
        constexpr uint32_t ND12 = (1U << 12);  ///< New data
        constexpr uint32_t ND13 = (1U << 13);  ///< New data
        constexpr uint32_t ND14 = (1U << 14);  ///< New data
        constexpr uint32_t ND15 = (1U << 15);  ///< New data
        constexpr uint32_t ND16 = (1U << 16);  ///< New data
        constexpr uint32_t ND17 = (1U << 17);  ///< New data
        constexpr uint32_t ND18 = (1U << 18);  ///< New data
        constexpr uint32_t ND19 = (1U << 19);  ///< New data
        constexpr uint32_t ND20 = (1U << 20);  ///< New data
        constexpr uint32_t ND21 = (1U << 21);  ///< New data
        constexpr uint32_t ND22 = (1U << 22);  ///< New data
        constexpr uint32_t ND23 = (1U << 23);  ///< New data
        constexpr uint32_t ND24 = (1U << 24);  ///< New data
        constexpr uint32_t ND25 = (1U << 25);  ///< New data
        constexpr uint32_t ND26 = (1U << 26);  ///< New data
        constexpr uint32_t ND27 = (1U << 27);  ///< New data
        constexpr uint32_t ND28 = (1U << 28);  ///< New data
        constexpr uint32_t ND29 = (1U << 29);  ///< New data
        constexpr uint32_t ND30 = (1U << 30);  ///< New data
        constexpr uint32_t ND31 = (1U << 31);  ///< New data
    }

    /// FDCAN_NDAT2 Register bits
    namespace fdcan_ndat2_bits {
        constexpr uint32_t ND32 = (1U << 0);  ///< New data
        constexpr uint32_t ND33 = (1U << 1);  ///< New data
        constexpr uint32_t ND34 = (1U << 2);  ///< New data
        constexpr uint32_t ND35 = (1U << 3);  ///< New data
        constexpr uint32_t ND36 = (1U << 4);  ///< New data
        constexpr uint32_t ND37 = (1U << 5);  ///< New data
        constexpr uint32_t ND38 = (1U << 6);  ///< New data
        constexpr uint32_t ND39 = (1U << 7);  ///< New data
        constexpr uint32_t ND40 = (1U << 8);  ///< New data
        constexpr uint32_t ND41 = (1U << 9);  ///< New data
        constexpr uint32_t ND42 = (1U << 10);  ///< New data
        constexpr uint32_t ND43 = (1U << 11);  ///< New data
        constexpr uint32_t ND44 = (1U << 12);  ///< New data
        constexpr uint32_t ND45 = (1U << 13);  ///< New data
        constexpr uint32_t ND46 = (1U << 14);  ///< New data
        constexpr uint32_t ND47 = (1U << 15);  ///< New data
        constexpr uint32_t ND48 = (1U << 16);  ///< New data
        constexpr uint32_t ND49 = (1U << 17);  ///< New data
        constexpr uint32_t ND50 = (1U << 18);  ///< New data
        constexpr uint32_t ND51 = (1U << 19);  ///< New data
        constexpr uint32_t ND52 = (1U << 20);  ///< New data
        constexpr uint32_t ND53 = (1U << 21);  ///< New data
        constexpr uint32_t ND54 = (1U << 22);  ///< New data
        constexpr uint32_t ND55 = (1U << 23);  ///< New data
        constexpr uint32_t ND56 = (1U << 24);  ///< New data
        constexpr uint32_t ND57 = (1U << 25);  ///< New data
        constexpr uint32_t ND58 = (1U << 26);  ///< New data
        constexpr uint32_t ND59 = (1U << 27);  ///< New data
        constexpr uint32_t ND60 = (1U << 28);  ///< New data
        constexpr uint32_t ND61 = (1U << 29);  ///< New data
        constexpr uint32_t ND62 = (1U << 30);  ///< New data
        constexpr uint32_t ND63 = (1U << 31);  ///< New data
    }

    /// FDCAN_RXF0C Register bits
    namespace fdcan_rxf0c_bits {
        constexpr uint32_t F0SA = (14 << 2);  ///< Rx FIFO 0 Start Address
        constexpr uint32_t F0S = (8 << 16);  ///< Rx FIFO 0 Size
        constexpr uint32_t F0WM = (8 << 24);  ///< FIFO 0 Watermark
    }

    /// FDCAN_RXF0S Register bits
    namespace fdcan_rxf0s_bits {
        constexpr uint32_t F0FL = (7 << 0);  ///< Rx FIFO 0 Fill Level
        constexpr uint32_t F0G = (6 << 8);  ///< Rx FIFO 0 Get Index
        constexpr uint32_t F0P = (6 << 16);  ///< Rx FIFO 0 Put Index
        constexpr uint32_t F0F = (1U << 24);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0L = (1U << 25);  ///< Rx FIFO 0 Message Lost
    }

    /// FDCAN_RXF0A Register bits
    namespace fdcan_rxf0a_bits {
        constexpr uint32_t FA01 = (6 << 0);  ///< Rx FIFO 0 Acknowledge Index
    }

    /// FDCAN_RXBC Register bits
    namespace fdcan_rxbc_bits {
        constexpr uint32_t RBSA = (14 << 2);  ///< Rx Buffer Start Address
    }

    /// FDCAN_RXF1C Register bits
    namespace fdcan_rxf1c_bits {
        constexpr uint32_t F1SA = (14 << 2);  ///< Rx FIFO 1 Start Address
        constexpr uint32_t F1S = (7 << 16);  ///< Rx FIFO 1 Size
        constexpr uint32_t F1WM = (7 << 24);  ///< Rx FIFO 1 Watermark
    }

    /// FDCAN_RXF1S Register bits
    namespace fdcan_rxf1s_bits {
        constexpr uint32_t F1FL = (7 << 0);  ///< Rx FIFO 1 Fill Level
        constexpr uint32_t F1GI = (7 << 8);  ///< Rx FIFO 1 Get Index
        constexpr uint32_t F1PI = (7 << 16);  ///< Rx FIFO 1 Put Index
        constexpr uint32_t F1F = (1U << 24);  ///< Rx FIFO 1 Full
        constexpr uint32_t RF1L = (1U << 25);  ///< Rx FIFO 1 Message Lost
        constexpr uint32_t DMS = (2 << 30);  ///< Debug Message Status
    }

    /// FDCAN_RXF1A Register bits
    namespace fdcan_rxf1a_bits {
        constexpr uint32_t F1AI = (6 << 0);  ///< Rx FIFO 1 Acknowledge Index
    }

    /// FDCAN_RXESC Register bits
    namespace fdcan_rxesc_bits {
        constexpr uint32_t F0DS = (3 << 0);  ///< Rx FIFO 1 Data Field Size:
        constexpr uint32_t F1DS = (3 << 4);  ///< Rx FIFO 0 Data Field Size:
        constexpr uint32_t RBDS = (3 << 8);  ///< Rx Buffer Data Field Size:
    }

    /// FDCAN_TXBC Register bits
    namespace fdcan_txbc_bits {
        constexpr uint32_t TBSA = (14 << 2);  ///< Tx Buffers Start Address
        constexpr uint32_t NDTB = (6 << 16);  ///< Number of Dedicated Transmit Buffers
        constexpr uint32_t TFQS = (6 << 24);  ///< Transmit FIFO/Queue Size
        constexpr uint32_t TFQM = (1U << 30);  ///< Tx FIFO/Queue Mode
    }

    /// FDCAN_TXFQS Register bits
    namespace fdcan_txfqs_bits {
        constexpr uint32_t TFFL = (6 << 0);  ///< Tx FIFO Free Level
        constexpr uint32_t TFGI = (5 << 8);  ///< TFGI
        constexpr uint32_t TFQPI = (5 << 16);  ///< Tx FIFO/Queue Put Index
        constexpr uint32_t TFQF = (1U << 21);  ///< Tx FIFO/Queue Full
    }

    /// FDCAN_TXESC Register bits
    namespace fdcan_txesc_bits {
        constexpr uint32_t TBDS = (3 << 0);  ///< Tx Buffer Data Field Size:
    }

    /// FDCAN_TXBRP Register bits
    namespace fdcan_txbrp_bits {
        constexpr uint32_t TRP = (32 << 0);  ///< Transmission Request Pending
    }

    /// FDCAN_TXBAR Register bits
    namespace fdcan_txbar_bits {
        constexpr uint32_t AR = (32 << 0);  ///< Add Request
    }

    /// FDCAN_TXBCR Register bits
    namespace fdcan_txbcr_bits {
        constexpr uint32_t CR = (32 << 0);  ///< Cancellation Request
    }

    /// FDCAN_TXBTO Register bits
    namespace fdcan_txbto_bits {
        constexpr uint32_t TO = (32 << 0);  ///< Transmission Occurred.
    }

    /// FDCAN_TXBCF Register bits
    namespace fdcan_txbcf_bits {
        constexpr uint32_t CF = (32 << 0);  ///< Cancellation Finished
    }

    /// FDCAN_TXBTIE Register bits
    namespace fdcan_txbtie_bits {
        constexpr uint32_t TIE = (32 << 0);  ///< Transmission Interrupt Enable
    }

    /// FDCAN_TXBCIE Register bits
    namespace fdcan_txbcie_bits {
        constexpr uint32_t CF = (32 << 0);  ///< Cancellation Finished Interrupt Enable
    }

    /// FDCAN_TXEFC Register bits
    namespace fdcan_txefc_bits {
        constexpr uint32_t EFSA = (14 << 2);  ///< Event FIFO Start Address
        constexpr uint32_t EFS = (6 << 16);  ///< Event FIFO Size
        constexpr uint32_t EFWM = (6 << 24);  ///< Event FIFO Watermark
    }

    /// FDCAN_TXEFS Register bits
    namespace fdcan_txefs_bits {
        constexpr uint32_t EFFL = (6 << 0);  ///< Event FIFO Fill Level
        constexpr uint32_t EFGI = (5 << 8);  ///< Event FIFO Get Index.
        constexpr uint32_t EFF = (1U << 24);  ///< Event FIFO Full.
        constexpr uint32_t TEFL = (1U << 25);  ///< Tx Event FIFO Element Lost.
    }

    /// FDCAN_TXEFA Register bits
    namespace fdcan_txefa_bits {
        constexpr uint32_t EFAI = (5 << 0);  ///< Event FIFO Acknowledge Index
    }

    /// FDCAN_TTTMC Register bits
    namespace fdcan_tttmc_bits {
        constexpr uint32_t TMSA = (14 << 2);  ///< Trigger Memory Start Address
        constexpr uint32_t TME = (7 << 16);  ///< Trigger Memory Elements
    }

    /// FDCAN_TTRMC Register bits
    namespace fdcan_ttrmc_bits {
        constexpr uint32_t RID = (29 << 0);  ///< Reference Identifier.
        constexpr uint32_t XTD = (1U << 30);  ///< Extended Identifier
        constexpr uint32_t RMPS = (1U << 31);  ///< Reference Message Payload Select
    }

    /// FDCAN_TTOCF Register bits
    namespace fdcan_ttocf_bits {
        constexpr uint32_t OM = (2 << 0);  ///< Operation Mode
        constexpr uint32_t GEN = (1U << 3);  ///< Gap Enable
        constexpr uint32_t TM = (1U << 4);  ///< Time Master
        constexpr uint32_t LDSDL = (3 << 5);  ///< LD of Synchronization Deviation Limit
        constexpr uint32_t IRTO = (7 << 8);  ///< Initial Reference Trigger Offset
        constexpr uint32_t EECS = (1U << 15);  ///< Enable External Clock Synchronization
        constexpr uint32_t AWL = (8 << 16);  ///< Application Watchdog Limit
        constexpr uint32_t EGTF = (1U << 24);  ///< Enable Global Time Filtering
        constexpr uint32_t ECC = (1U << 25);  ///< Enable Clock Calibration
        constexpr uint32_t EVTP = (1U << 26);  ///< Event Trigger Polarity
    }

    /// FDCAN_TTMLM Register bits
    namespace fdcan_ttmlm_bits {
        constexpr uint32_t CCM = (6 << 0);  ///< Cycle Count Max
        constexpr uint32_t CSS = (2 << 6);  ///< Cycle Start Synchronization
        constexpr uint32_t TXEW = (4 << 8);  ///< Tx Enable Window
        constexpr uint32_t ENTT = (12 << 16);  ///< Expected Number of Tx Triggers
    }

    /// FDCAN_TURCF Register bits
    namespace fdcan_turcf_bits {
        constexpr uint32_t NCL = (16 << 0);  ///< Numerator Configuration Low.
        constexpr uint32_t DC = (14 << 16);  ///< Denominator Configuration.
        constexpr uint32_t ELT = (1U << 31);  ///< Enable Local Time
    }

    /// FDCAN_TTOCN Register bits
    namespace fdcan_ttocn_bits {
        constexpr uint32_t SGT = (1U << 0);  ///< Set Global time
        constexpr uint32_t ECS = (1U << 1);  ///< External Clock Synchronization
        constexpr uint32_t SWP = (1U << 2);  ///< Stop Watch Polarity
        constexpr uint32_t SWS = (2 << 3);  ///< Stop Watch Source.
        constexpr uint32_t RTIE = (1U << 5);  ///< Register Time Mark Interrupt Pulse Enable
        constexpr uint32_t TMC = (2 << 6);  ///< Register Time Mark Compare
        constexpr uint32_t TTIE = (1U << 8);  ///< Trigger Time Mark Interrupt Pulse Enable
        constexpr uint32_t GCS = (1U << 9);  ///< Gap Control Select
        constexpr uint32_t FGP = (1U << 10);  ///< Finish Gap.
        constexpr uint32_t TMG = (1U << 11);  ///< Time Mark Gap
        constexpr uint32_t NIG = (1U << 12);  ///< Next is Gap
        constexpr uint32_t ESCN = (1U << 13);  ///< External Synchronization Control
        constexpr uint32_t LCKC = (1U << 15);  ///< TT Operation Control Register Locked
    }

    /// CAN_TTGTP Register bits
    namespace can_ttgtp_bits {
        constexpr uint32_t NCL = (16 << 0);  ///< Time Preset
        constexpr uint32_t CTP = (16 << 16);  ///< Cycle Time Target Phase
    }

    /// FDCAN_TTTMK Register bits
    namespace fdcan_tttmk_bits {
        constexpr uint32_t TM = (16 << 0);  ///< Time Mark
        constexpr uint32_t TICC = (7 << 16);  ///< Time Mark Cycle Code
        constexpr uint32_t LCKM = (1U << 31);  ///< TT Time Mark Register Locked
    }

    /// FDCAN_TTIR Register bits
    namespace fdcan_ttir_bits {
        constexpr uint32_t SBC = (1U << 0);  ///< Start of Basic Cycle
        constexpr uint32_t SMC = (1U << 1);  ///< Start of Matrix Cycle
        constexpr uint32_t CSM = (1U << 2);  ///< Change of Synchronization Mode
        constexpr uint32_t SOG = (1U << 3);  ///< Start of Gap
        constexpr uint32_t RTMI = (1U << 4);  ///< Register Time Mark Interrupt.
        constexpr uint32_t TTMI = (1U << 5);  ///< Trigger Time Mark Event Internal
        constexpr uint32_t SWE = (1U << 6);  ///< Stop Watch Event
        constexpr uint32_t GTW = (1U << 7);  ///< Global Time Wrap
        constexpr uint32_t GTD = (1U << 8);  ///< Global Time Discontinuity
        constexpr uint32_t GTE = (1U << 9);  ///< Global Time Error
        constexpr uint32_t TXU = (1U << 10);  ///< Tx Count Underflow
        constexpr uint32_t TXO = (1U << 11);  ///< Tx Count Overflow
        constexpr uint32_t SE1 = (1U << 12);  ///< Scheduling Error 1
        constexpr uint32_t SE2 = (1U << 13);  ///< Scheduling Error 2
        constexpr uint32_t ELC = (1U << 14);  ///< Error Level Changed.
        constexpr uint32_t IWTG = (1U << 15);  ///< Initialization Watch Trigger
        constexpr uint32_t WT = (1U << 16);  ///< Watch Trigger
        constexpr uint32_t AW = (1U << 17);  ///< Application Watchdog
        constexpr uint32_t CER = (1U << 18);  ///< Configuration Error
    }

    /// FDCAN_TTIE Register bits
    namespace fdcan_ttie_bits {
        constexpr uint32_t SBCE = (1U << 0);  ///< Start of Basic Cycle Interrupt Enable
        constexpr uint32_t SMCE = (1U << 1);  ///< Start of Matrix Cycle Interrupt Enable
        constexpr uint32_t CSME = (1U << 2);  ///< Change of Synchronization Mode Interrupt Enable
        constexpr uint32_t SOGE = (1U << 3);  ///< Start of Gap Interrupt Enable
        constexpr uint32_t RTMIE = (1U << 4);  ///< Register Time Mark Interrupt Enable
        constexpr uint32_t TTMIE = (1U << 5);  ///< Trigger Time Mark Event Internal Interrupt Enable
        constexpr uint32_t SWEE = (1U << 6);  ///< Stop Watch Event Interrupt Enable
        constexpr uint32_t GTWE = (1U << 7);  ///< Global Time Wrap Interrupt Enable
        constexpr uint32_t GTDE = (1U << 8);  ///< Global Time Discontinuity Interrupt Enable
        constexpr uint32_t GTEE = (1U << 9);  ///< Global Time Error Interrupt Enable
        constexpr uint32_t TXUE = (1U << 10);  ///< Tx Count Underflow Interrupt Enable
        constexpr uint32_t TXOE = (1U << 11);  ///< Tx Count Overflow Interrupt Enable
        constexpr uint32_t SE1E = (1U << 12);  ///< Scheduling Error 1 Interrupt Enable
        constexpr uint32_t SE2E = (1U << 13);  ///< Scheduling Error 2 Interrupt Enable
        constexpr uint32_t ELCE = (1U << 14);  ///< Change Error Level Interrupt Enable
        constexpr uint32_t IWTGE = (1U << 15);  ///< Initialization Watch Trigger Interrupt Enable
        constexpr uint32_t WTE = (1U << 16);  ///< Watch Trigger Interrupt Enable
        constexpr uint32_t AWE = (1U << 17);  ///< Application Watchdog Interrupt Enable
        constexpr uint32_t CERE = (1U << 18);  ///< Configuration Error Interrupt Enable
    }

    /// FDCAN_TTILS Register bits
    namespace fdcan_ttils_bits {
        constexpr uint32_t SBCL = (1U << 0);  ///< Start of Basic Cycle Interrupt Line
        constexpr uint32_t SMCL = (1U << 1);  ///< Start of Matrix Cycle Interrupt Line
        constexpr uint32_t CSML = (1U << 2);  ///< Change of Synchronization Mode Interrupt Line
        constexpr uint32_t SOGL = (1U << 3);  ///< Start of Gap Interrupt Line
        constexpr uint32_t RTMIL = (1U << 4);  ///< Register Time Mark Interrupt Line
        constexpr uint32_t TTMIL = (1U << 5);  ///< Trigger Time Mark Event Internal Interrupt Line
        constexpr uint32_t SWEL = (1U << 6);  ///< Stop Watch Event Interrupt Line
        constexpr uint32_t GTWL = (1U << 7);  ///< Global Time Wrap Interrupt Line
        constexpr uint32_t GTDL = (1U << 8);  ///< Global Time Discontinuity Interrupt Line
        constexpr uint32_t GTEL = (1U << 9);  ///< Global Time Error Interrupt Line
        constexpr uint32_t TXUL = (1U << 10);  ///< Tx Count Underflow Interrupt Line
        constexpr uint32_t TXOL = (1U << 11);  ///< Tx Count Overflow Interrupt Line
        constexpr uint32_t SE1L = (1U << 12);  ///< Scheduling Error 1 Interrupt Line
        constexpr uint32_t SE2L = (1U << 13);  ///< Scheduling Error 2 Interrupt Line
        constexpr uint32_t ELCL = (1U << 14);  ///< Change Error Level Interrupt Line
        constexpr uint32_t IWTGL = (1U << 15);  ///< Initialization Watch Trigger Interrupt Line
        constexpr uint32_t WTL = (1U << 16);  ///< Watch Trigger Interrupt Line
        constexpr uint32_t AWL = (1U << 17);  ///< Application Watchdog Interrupt Line
        constexpr uint32_t CERL = (1U << 18);  ///< Configuration Error Interrupt Line
    }

    /// FDCAN_TTOST Register bits
    namespace fdcan_ttost_bits {
        constexpr uint32_t EL = (2 << 0);  ///< Error Level
        constexpr uint32_t MS = (2 << 2);  ///< Master State.
        constexpr uint32_t SYS = (2 << 4);  ///< Synchronization State
        constexpr uint32_t GTP = (1U << 6);  ///< Quality of Global Time Phase
        constexpr uint32_t QCS = (1U << 7);  ///< Quality of Clock Speed
        constexpr uint32_t RTO = (8 << 8);  ///< Reference Trigger Offset
        constexpr uint32_t WGTD = (1U << 22);  ///< Wait for Global Time Discontinuity
        constexpr uint32_t GFI = (1U << 23);  ///< Gap Finished Indicator.
        constexpr uint32_t TMP = (3 << 24);  ///< Time Master Priority
        constexpr uint32_t GSI = (1U << 27);  ///< Gap Started Indicator.
        constexpr uint32_t WFE = (1U << 28);  ///< Wait for Event
        constexpr uint32_t AWE = (1U << 29);  ///< Application Watchdog Event
        constexpr uint32_t WECS = (1U << 30);  ///< Wait for External Clock Synchronization
        constexpr uint32_t SPL = (1U << 31);  ///< Schedule Phase Lock
    }

    /// FDCAN_TURNA Register bits
    namespace fdcan_turna_bits {
        constexpr uint32_t NAV = (18 << 0);  ///< Numerator Actual Value
    }

    /// FDCAN_TTLGT Register bits
    namespace fdcan_ttlgt_bits {
        constexpr uint32_t LT = (16 << 0);  ///< Local Time
        constexpr uint32_t GT = (16 << 16);  ///< Global Time
    }

    /// FDCAN_TTCTC Register bits
    namespace fdcan_ttctc_bits {
        constexpr uint32_t CT = (16 << 0);  ///< Cycle Time
        constexpr uint32_t CC = (6 << 16);  ///< Cycle Count
    }

    /// FDCAN_TTCPT Register bits
    namespace fdcan_ttcpt_bits {
        constexpr uint32_t CT = (6 << 0);  ///< Cycle Count Value
        constexpr uint32_t SWV = (16 << 16);  ///< Stop Watch Value
    }

    /// FDCAN_TTCSM Register bits
    namespace fdcan_ttcsm_bits {
        constexpr uint32_t CSM = (16 << 0);  ///< Cycle Sync Mark
    }

    /// FDCAN_TTTS Register bits
    namespace fdcan_ttts_bits {
        constexpr uint32_t SWTDEL = (2 << 0);  ///< Stop watch trigger input selection
        constexpr uint32_t EVTSEL = (2 << 4);  ///< Event trigger input selection
    }

}

// ============================================================================
// MDIOS Peripheral
// ============================================================================

namespace mdios {
    /// Base addresses
    constexpr uint32_t MDIOS_BASE = 0x40009400;

    /// MDIOS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - MDIOS configuration register
        volatile uint32_t WRFR;  ///< Offset: 0x04 - MDIOS write flag register
        volatile uint32_t CWRFR;  ///< Offset: 0x08 - MDIOS clear write flag register
        volatile uint32_t RDFR;  ///< Offset: 0x0C - MDIOS read flag register
        volatile uint32_t CRDFR;  ///< Offset: 0x10 - MDIOS clear read flag register
        volatile uint32_t SR;  ///< Offset: 0x14 - MDIOS status register
        volatile uint32_t CLRFR;  ///< Offset: 0x18 - MDIOS clear flag register
        volatile uint32_t DINR0;  ///< Offset: 0x1C - MDIOS input data register 0
        volatile uint32_t DINR1;  ///< Offset: 0x20 - MDIOS input data register 1
        volatile uint32_t DINR2;  ///< Offset: 0x24 - MDIOS input data register 2
        volatile uint32_t DINR3;  ///< Offset: 0x28 - MDIOS input data register 3
        volatile uint32_t DINR4;  ///< Offset: 0x2C - MDIOS input data register 4
        volatile uint32_t DINR5;  ///< Offset: 0x30 - MDIOS input data register 5
        volatile uint32_t DINR6;  ///< Offset: 0x34 - MDIOS input data register 6
        volatile uint32_t DINR7;  ///< Offset: 0x38 - MDIOS input data register 7
        volatile uint32_t DINR8;  ///< Offset: 0x3C - MDIOS input data register 8
        volatile uint32_t DINR9;  ///< Offset: 0x40 - MDIOS input data register 9
        volatile uint32_t DINR10;  ///< Offset: 0x44 - MDIOS input data register 10
        volatile uint32_t DINR11;  ///< Offset: 0x48 - MDIOS input data register 11
        volatile uint32_t DINR12;  ///< Offset: 0x4C - MDIOS input data register 12
        volatile uint32_t DINR13;  ///< Offset: 0x50 - MDIOS input data register 13
        volatile uint32_t DINR14;  ///< Offset: 0x54 - MDIOS input data register 14
        volatile uint32_t DINR15;  ///< Offset: 0x58 - MDIOS input data register 15
        volatile uint32_t DINR16;  ///< Offset: 0x5C - MDIOS input data register 16
        volatile uint32_t DINR17;  ///< Offset: 0x60 - MDIOS input data register 17
        volatile uint32_t DINR18;  ///< Offset: 0x64 - MDIOS input data register 18
        volatile uint32_t DINR19;  ///< Offset: 0x68 - MDIOS input data register 19
        volatile uint32_t DINR20;  ///< Offset: 0x6C - MDIOS input data register 20
        volatile uint32_t DINR21;  ///< Offset: 0x70 - MDIOS input data register 21
        volatile uint32_t DINR22;  ///< Offset: 0x74 - MDIOS input data register 22
        volatile uint32_t DINR23;  ///< Offset: 0x78 - MDIOS input data register 23
        volatile uint32_t DINR24;  ///< Offset: 0x7C - MDIOS input data register 24
        volatile uint32_t DINR25;  ///< Offset: 0x80 - MDIOS input data register 25
        volatile uint32_t DINR26;  ///< Offset: 0x84 - MDIOS input data register 26
        volatile uint32_t DINR27;  ///< Offset: 0x88 - MDIOS input data register 27
        volatile uint32_t DINR28;  ///< Offset: 0x8C - MDIOS input data register 28
        volatile uint32_t DINR29;  ///< Offset: 0x90 - MDIOS input data register 29
        volatile uint32_t DINR30;  ///< Offset: 0x94 - MDIOS input data register 30
        volatile uint32_t DINR31;  ///< Offset: 0x98 - MDIOS input data register 31
        volatile uint32_t DOUTR0;  ///< Offset: 0x9C - MDIOS output data register 0
        volatile uint32_t DOUTR1;  ///< Offset: 0xA0 - MDIOS output data register 1
        volatile uint32_t DOUTR2;  ///< Offset: 0xA4 - MDIOS output data register 2
        volatile uint32_t DOUTR3;  ///< Offset: 0xA8 - MDIOS output data register 3
        volatile uint32_t DOUTR4;  ///< Offset: 0xAC - MDIOS output data register 4
        volatile uint32_t DOUTR5;  ///< Offset: 0xB0 - MDIOS output data register 5
        volatile uint32_t DOUTR6;  ///< Offset: 0xB4 - MDIOS output data register 6
        volatile uint32_t DOUTR7;  ///< Offset: 0xB8 - MDIOS output data register 7
        volatile uint32_t DOUTR8;  ///< Offset: 0xBC - MDIOS output data register 8
        volatile uint32_t DOUTR9;  ///< Offset: 0xC0 - MDIOS output data register 9
        volatile uint32_t DOUTR10;  ///< Offset: 0xC4 - MDIOS output data register 10
        volatile uint32_t DOUTR11;  ///< Offset: 0xC8 - MDIOS output data register 11
        volatile uint32_t DOUTR12;  ///< Offset: 0xCC - MDIOS output data register 12
        volatile uint32_t DOUTR13;  ///< Offset: 0xD0 - MDIOS output data register 13
        volatile uint32_t DOUTR14;  ///< Offset: 0xD4 - MDIOS output data register 14
        volatile uint32_t DOUTR15;  ///< Offset: 0xD8 - MDIOS output data register 15
        volatile uint32_t DOUTR16;  ///< Offset: 0xDC - MDIOS output data register 16
        volatile uint32_t DOUTR17;  ///< Offset: 0xE0 - MDIOS output data register 17
        volatile uint32_t DOUTR18;  ///< Offset: 0xE4 - MDIOS output data register 18
        volatile uint32_t DOUTR19;  ///< Offset: 0xE8 - MDIOS output data register 19
        volatile uint32_t DOUTR20;  ///< Offset: 0xEC - MDIOS output data register 20
        volatile uint32_t DOUTR21;  ///< Offset: 0xF0 - MDIOS output data register 21
        volatile uint32_t DOUTR22;  ///< Offset: 0xF4 - MDIOS output data register 22
        volatile uint32_t DOUTR23;  ///< Offset: 0xF8 - MDIOS output data register 23
        volatile uint32_t DOUTR24;  ///< Offset: 0xFC - MDIOS output data register 24
        volatile uint32_t DOUTR25;  ///< Offset: 0x100 - MDIOS output data register 25
        volatile uint32_t DOUTR26;  ///< Offset: 0x104 - MDIOS output data register 26
        volatile uint32_t DOUTR27;  ///< Offset: 0x108 - MDIOS output data register 27
        volatile uint32_t DOUTR28;  ///< Offset: 0x10C - MDIOS output data register 28
        volatile uint32_t DOUTR29;  ///< Offset: 0x110 - MDIOS output data register 29
        volatile uint32_t DOUTR30;  ///< Offset: 0x114 - MDIOS output data register 30
        volatile uint32_t DOUTR31;  ///< Offset: 0x118 - MDIOS output data register 31
    };

    /// Peripheral instances
    inline Registers* MDIOS = reinterpret_cast<Registers*>(MDIOS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t WRIE = (1U << 1);  ///< Register write interrupt enable
        constexpr uint32_t RDIE = (1U << 2);  ///< Register Read Interrupt Enable
        constexpr uint32_t EIE = (1U << 3);  ///< Error interrupt enable
        constexpr uint32_t DPC = (1U << 7);  ///< Disable Preamble Check
        constexpr uint32_t PORT_ADDRESS = (5 << 8);  ///< Slaves's address
    }

    /// WRFR Register bits
    namespace wrfr_bits {
        constexpr uint32_t WRF = (32 << 0);  ///< Write flags for MDIO registers 0 to 31
    }

    /// CWRFR Register bits
    namespace cwrfr_bits {
        constexpr uint32_t CWRF = (32 << 0);  ///< Clear the write flag
    }

    /// RDFR Register bits
    namespace rdfr_bits {
        constexpr uint32_t RDF = (32 << 0);  ///< Read flags for MDIO registers 0 to 31
    }

    /// CRDFR Register bits
    namespace crdfr_bits {
        constexpr uint32_t CRDF = (32 << 0);  ///< Clear the read flag
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t PERF = (1U << 0);  ///< Preamble error flag
        constexpr uint32_t SERF = (1U << 1);  ///< Start error flag
        constexpr uint32_t TERF = (1U << 2);  ///< Turnaround error flag
    }

    /// CLRFR Register bits
    namespace clrfr_bits {
        constexpr uint32_t CPERF = (1U << 0);  ///< Clear the preamble error flag
        constexpr uint32_t CSERF = (1U << 1);  ///< Clear the start error flag
        constexpr uint32_t CTERF = (1U << 2);  ///< Clear the turnaround error flag
    }

    /// DINR0 Register bits
    namespace dinr0_bits {
        constexpr uint32_t DIN0 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR1 Register bits
    namespace dinr1_bits {
        constexpr uint32_t DIN1 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR2 Register bits
    namespace dinr2_bits {
        constexpr uint32_t DIN2 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR3 Register bits
    namespace dinr3_bits {
        constexpr uint32_t DIN3 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR4 Register bits
    namespace dinr4_bits {
        constexpr uint32_t DIN4 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR5 Register bits
    namespace dinr5_bits {
        constexpr uint32_t DIN5 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR6 Register bits
    namespace dinr6_bits {
        constexpr uint32_t DIN6 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR7 Register bits
    namespace dinr7_bits {
        constexpr uint32_t DIN7 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR8 Register bits
    namespace dinr8_bits {
        constexpr uint32_t DIN8 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR9 Register bits
    namespace dinr9_bits {
        constexpr uint32_t DIN9 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR10 Register bits
    namespace dinr10_bits {
        constexpr uint32_t DIN10 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR11 Register bits
    namespace dinr11_bits {
        constexpr uint32_t DIN11 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR12 Register bits
    namespace dinr12_bits {
        constexpr uint32_t DIN12 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR13 Register bits
    namespace dinr13_bits {
        constexpr uint32_t DIN13 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR14 Register bits
    namespace dinr14_bits {
        constexpr uint32_t DIN14 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR15 Register bits
    namespace dinr15_bits {
        constexpr uint32_t DIN15 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR16 Register bits
    namespace dinr16_bits {
        constexpr uint32_t DIN16 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR17 Register bits
    namespace dinr17_bits {
        constexpr uint32_t DIN17 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR18 Register bits
    namespace dinr18_bits {
        constexpr uint32_t DIN18 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR19 Register bits
    namespace dinr19_bits {
        constexpr uint32_t DIN19 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR20 Register bits
    namespace dinr20_bits {
        constexpr uint32_t DIN20 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR21 Register bits
    namespace dinr21_bits {
        constexpr uint32_t DIN21 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR22 Register bits
    namespace dinr22_bits {
        constexpr uint32_t DIN22 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR23 Register bits
    namespace dinr23_bits {
        constexpr uint32_t DIN23 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR24 Register bits
    namespace dinr24_bits {
        constexpr uint32_t DIN24 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR25 Register bits
    namespace dinr25_bits {
        constexpr uint32_t DIN25 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR26 Register bits
    namespace dinr26_bits {
        constexpr uint32_t DIN26 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR27 Register bits
    namespace dinr27_bits {
        constexpr uint32_t DIN27 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR28 Register bits
    namespace dinr28_bits {
        constexpr uint32_t DIN28 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR29 Register bits
    namespace dinr29_bits {
        constexpr uint32_t DIN29 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR30 Register bits
    namespace dinr30_bits {
        constexpr uint32_t DIN30 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DINR31 Register bits
    namespace dinr31_bits {
        constexpr uint32_t DIN31 = (16 << 0);  ///< Input data received from MDIO Master during write frames
    }

    /// DOUTR0 Register bits
    namespace doutr0_bits {
        constexpr uint32_t DOUT0 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR1 Register bits
    namespace doutr1_bits {
        constexpr uint32_t DOUT1 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR2 Register bits
    namespace doutr2_bits {
        constexpr uint32_t DOUT2 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR3 Register bits
    namespace doutr3_bits {
        constexpr uint32_t DOUT3 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR4 Register bits
    namespace doutr4_bits {
        constexpr uint32_t DOUT4 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR5 Register bits
    namespace doutr5_bits {
        constexpr uint32_t DOUT5 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR6 Register bits
    namespace doutr6_bits {
        constexpr uint32_t DOUT6 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR7 Register bits
    namespace doutr7_bits {
        constexpr uint32_t DOUT7 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR8 Register bits
    namespace doutr8_bits {
        constexpr uint32_t DOUT8 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR9 Register bits
    namespace doutr9_bits {
        constexpr uint32_t DOUT9 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR10 Register bits
    namespace doutr10_bits {
        constexpr uint32_t DOUT10 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR11 Register bits
    namespace doutr11_bits {
        constexpr uint32_t DOUT11 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR12 Register bits
    namespace doutr12_bits {
        constexpr uint32_t DOUT12 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR13 Register bits
    namespace doutr13_bits {
        constexpr uint32_t DOUT13 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR14 Register bits
    namespace doutr14_bits {
        constexpr uint32_t DOUT14 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR15 Register bits
    namespace doutr15_bits {
        constexpr uint32_t DOUT15 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR16 Register bits
    namespace doutr16_bits {
        constexpr uint32_t DOUT16 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR17 Register bits
    namespace doutr17_bits {
        constexpr uint32_t DOUT17 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR18 Register bits
    namespace doutr18_bits {
        constexpr uint32_t DOUT18 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR19 Register bits
    namespace doutr19_bits {
        constexpr uint32_t DOUT19 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR20 Register bits
    namespace doutr20_bits {
        constexpr uint32_t DOUT20 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR21 Register bits
    namespace doutr21_bits {
        constexpr uint32_t DOUT21 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR22 Register bits
    namespace doutr22_bits {
        constexpr uint32_t DOUT22 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR23 Register bits
    namespace doutr23_bits {
        constexpr uint32_t DOUT23 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR24 Register bits
    namespace doutr24_bits {
        constexpr uint32_t DOUT24 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR25 Register bits
    namespace doutr25_bits {
        constexpr uint32_t DOUT25 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR26 Register bits
    namespace doutr26_bits {
        constexpr uint32_t DOUT26 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR27 Register bits
    namespace doutr27_bits {
        constexpr uint32_t DOUT27 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR28 Register bits
    namespace doutr28_bits {
        constexpr uint32_t DOUT28 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR29 Register bits
    namespace doutr29_bits {
        constexpr uint32_t DOUT29 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR30 Register bits
    namespace doutr30_bits {
        constexpr uint32_t DOUT30 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

    /// DOUTR31 Register bits
    namespace doutr31_bits {
        constexpr uint32_t DOUT31 = (16 << 0);  ///< Output data sent to MDIO Master during read frames
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x40009000;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP1_CSR;  ///< Offset: 0x00 - OPAMP1 control/status register
        volatile uint32_t OPAMP1_OTR;  ///< Offset: 0x04 - OPAMP1 offset trimming register in normal mode
        volatile uint32_t OPAMP1_HSOTR;  ///< Offset: 0x08 - OPAMP1 offset trimming register in low-power mode
        volatile uint32_t OPAMP2_CSR;  ///< Offset: 0x10 - OPAMP2 control/status register
        volatile uint32_t OPAMP2_OTR;  ///< Offset: 0x14 - OPAMP2 offset trimming register in normal mode
        volatile uint32_t OPAMP2_HSOTR;  ///< Offset: 0x18 - OPAMP2 offset trimming register in low-power mode
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP1_CSR Register bits
    namespace opamp1_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t FORCE_VP = (1U << 1);  ///< Force internal reference on VP (reserved for test
        constexpr uint32_t VP_SEL = (2 << 2);  ///< Operational amplifier PGA mode
        constexpr uint32_t VM_SEL = (2 << 5);  ///< Inverting input selection
        constexpr uint32_t OPAHSM = (1U << 8);  ///< Operational amplifier high-speed mode
        constexpr uint32_t CALON = (1U << 11);  ///< Calibration mode enabled
        constexpr uint32_t CALSEL = (2 << 12);  ///< Calibration selection
        constexpr uint32_t PGA_GAIN = (4 << 14);  ///< allows to switch from AOP offset trimmed values to AOP offset
        constexpr uint32_t USERTRIM = (1U << 18);  ///< User trimming enable
        constexpr uint32_t TSTREF = (1U << 29);  ///< OPAMP calibration reference voltage output control (reserved for test)
        constexpr uint32_t CALOUT = (1U << 30);  ///< Operational amplifier calibration output
    }

    /// OPAMP1_OTR Register bits
    namespace opamp1_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP1_HSOTR Register bits
    namespace opamp1_hsotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_CSR Register bits
    namespace opamp2_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t FORCE_VP = (1U << 1);  ///< Force internal reference on VP (reserved for test)
        constexpr uint32_t VM_SEL = (2 << 5);  ///< Inverting input selection
        constexpr uint32_t OPAHSM = (1U << 8);  ///< Operational amplifier high-speed mode
        constexpr uint32_t CALON = (1U << 11);  ///< Calibration mode enabled
        constexpr uint32_t CALSEL = (2 << 12);  ///< Calibration selection
        constexpr uint32_t PGA_GAIN = (4 << 14);  ///< Operational amplifier Programmable amplifier gain value
        constexpr uint32_t USERTRIM = (1U << 18);  ///< User trimming enable
        constexpr uint32_t TSTREF = (1U << 29);  ///< OPAMP calibration reference voltage output control (reserved for test)
        constexpr uint32_t CALOUT = (1U << 30);  ///< Operational amplifier calibration output
    }

    /// OPAMP2_OTR Register bits
    namespace opamp2_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_HSOTR Register bits
    namespace opamp2_hsotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

}

// ============================================================================
// SWPMI Peripheral
// ============================================================================

namespace swpmi {
    /// Base addresses
    constexpr uint32_t SWPMI_BASE = 0x40008800;

    /// SWPMI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - SWPMI Configuration/Control register
        volatile uint32_t BRR;  ///< Offset: 0x04 - SWPMI Bitrate register
        volatile uint32_t ISR;  ///< Offset: 0x0C - SWPMI Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x10 - SWPMI Interrupt Flag Clear register
        volatile uint32_t IER;  ///< Offset: 0x14 - SWPMI Interrupt Enable register
        volatile uint32_t RFL;  ///< Offset: 0x18 - SWPMI Receive Frame Length register
        volatile uint32_t TDR;  ///< Offset: 0x1C - SWPMI Transmit data register
        volatile uint32_t RDR;  ///< Offset: 0x20 - SWPMI Receive data register
        volatile uint32_t OR;  ///< Offset: 0x24 - SWPMI Option register
    };

    /// Peripheral instances
    inline Registers* SWPMI = reinterpret_cast<Registers*>(SWPMI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RXDMA = (1U << 0);  ///< Reception DMA enable
        constexpr uint32_t TXDMA = (1U << 1);  ///< Transmission DMA enable
        constexpr uint32_t RXMODE = (1U << 2);  ///< Reception buffering mode
        constexpr uint32_t TXMODE = (1U << 3);  ///< Transmission buffering mode
        constexpr uint32_t LPBK = (1U << 4);  ///< Loopback mode enable
        constexpr uint32_t SWPACT = (1U << 5);  ///< Single wire protocol master interface activate
        constexpr uint32_t DEACT = (1U << 10);  ///< Single wire protocol master interface deactivate
        constexpr uint32_t SWPTEN = (1U << 11);  ///< Single wire protocol master transceiver enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR = (8 << 0);  ///< Bitrate prescaler
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RXBFF = (1U << 0);  ///< Receive buffer full flag
        constexpr uint32_t TXBEF = (1U << 1);  ///< Transmit buffer empty flag
        constexpr uint32_t RXBERF = (1U << 2);  ///< Receive CRC error flag
        constexpr uint32_t RXOVRF = (1U << 3);  ///< Receive overrun error flag
        constexpr uint32_t TXUNRF = (1U << 4);  ///< Transmit underrun error flag
        constexpr uint32_t RXNE = (1U << 5);  ///< Receive data register not empty
        constexpr uint32_t TXE = (1U << 6);  ///< Transmit data register empty
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer complete flag
        constexpr uint32_t SRF = (1U << 8);  ///< Slave resume flag
        constexpr uint32_t SUSP = (1U << 9);  ///< SUSPEND flag
        constexpr uint32_t DEACTF = (1U << 10);  ///< DEACTIVATED flag
        constexpr uint32_t RDYF = (1U << 11);  ///< transceiver ready flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t CRXBFF = (1U << 0);  ///< Clear receive buffer full flag
        constexpr uint32_t CTXBEF = (1U << 1);  ///< Clear transmit buffer empty flag
        constexpr uint32_t CRXBERF = (1U << 2);  ///< Clear receive CRC error flag
        constexpr uint32_t CRXOVRF = (1U << 3);  ///< Clear receive overrun error flag
        constexpr uint32_t CTXUNRF = (1U << 4);  ///< Clear transmit underrun error flag
        constexpr uint32_t CTCF = (1U << 7);  ///< Clear transfer complete flag
        constexpr uint32_t CSRF = (1U << 8);  ///< Clear slave resume flag
        constexpr uint32_t CRDYF = (1U << 11);  ///< Clear transceiver ready flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t RXBFIE = (1U << 0);  ///< Receive buffer full interrupt enable
        constexpr uint32_t TXBEIE = (1U << 1);  ///< Transmit buffer empty interrupt enable
        constexpr uint32_t RXBERIE = (1U << 2);  ///< Receive CRC error interrupt enable
        constexpr uint32_t RXOVRIE = (1U << 3);  ///< Receive overrun error interrupt enable
        constexpr uint32_t TXUNRIE = (1U << 4);  ///< Transmit underrun error interrupt enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receive interrupt enable
        constexpr uint32_t TIE = (1U << 6);  ///< Transmit interrupt enable
        constexpr uint32_t TCIE = (1U << 7);  ///< Transmit complete interrupt enable
        constexpr uint32_t SRIE = (1U << 8);  ///< Slave resume interrupt enable
        constexpr uint32_t RDYIE = (1U << 11);  ///< Transceiver ready interrupt enable
    }

    /// RFL Register bits
    namespace rfl_bits {
        constexpr uint32_t RFL = (5 << 0);  ///< Receive frame length
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TD = (32 << 0);  ///< Transmit data
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RD = (32 << 0);  ///< received data
    }

    /// OR Register bits
    namespace or_bits {
        constexpr uint32_t SWP_TBYP = (1U << 0);  ///< SWP transceiver bypass
        constexpr uint32_t SWP_CLASS = (1U << 1);  ///< SWP class selection
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;
    constexpr uint32_t NVIC_STIR_BASE = 0xE000EF00;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER0;  ///< Offset: 0x00 - Interrupt Set-Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x04 - Interrupt Set-Enable Register
        volatile uint32_t ISER2;  ///< Offset: 0x08 - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x80 - Interrupt Clear-Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x84 - Interrupt Clear-Enable Register
        volatile uint32_t ICER2;  ///< Offset: 0x88 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x104 - Interrupt Set-Pending Register
        volatile uint32_t ISPR2;  ///< Offset: 0x108 - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x184 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR2;  ///< Offset: 0x188 - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x200 - Interrupt Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x204 - Interrupt Active Bit Register
        volatile uint32_t IABR2;  ///< Offset: 0x208 - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x320 - Interrupt Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x324 - Interrupt Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x328 - Interrupt Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x32C - Interrupt Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x330 - Interrupt Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x334 - Interrupt Priority Register
        volatile uint32_t IPR14;  ///< Offset: 0x338 - Interrupt Priority Register
        volatile uint32_t IPR15;  ///< Offset: 0x33C - Interrupt Priority Register
        volatile uint32_t IPR16;  ///< Offset: 0x340 - Interrupt Priority Register
        volatile uint32_t IPR17;  ///< Offset: 0x344 - Interrupt Priority Register
        volatile uint32_t IPR18;  ///< Offset: 0x348 - Interrupt Priority Register
        volatile uint32_t IPR19;  ///< Offset: 0x34C - Interrupt Priority Register
        volatile uint32_t IPR20;  ///< Offset: 0x350 - Interrupt Priority Register
        volatile uint32_t IPR21;  ///< Offset: 0x354 - Interrupt Priority Register
        volatile uint32_t IPR22;  ///< Offset: 0x358 - Interrupt Priority Register
        volatile uint32_t IPR23;  ///< Offset: 0x35C - Interrupt Priority Register
        volatile uint32_t IPR24;  ///< Offset: 0x360 - Interrupt Priority Register
        volatile uint32_t IPR25;  ///< Offset: 0x364 - Interrupt Priority Register
        volatile uint32_t IPR26;  ///< Offset: 0x368 - Interrupt Priority Register
        volatile uint32_t IPR27;  ///< Offset: 0x36C - Interrupt Priority Register
        volatile uint32_t IPR28;  ///< Offset: 0x370 - Interrupt Priority Register
        volatile uint32_t IPR29;  ///< Offset: 0x374 - Interrupt Priority Register
        volatile uint32_t IPR30;  ///< Offset: 0x378 - Interrupt Priority Register
        volatile uint32_t IPR31;  ///< Offset: 0x37C - Interrupt Priority Register
        volatile uint32_t IPR32;  ///< Offset: 0x380 - Interrupt Priority Register
        volatile uint32_t IPR33;  ///< Offset: 0x384 - Interrupt Priority Register
        volatile uint32_t IPR34;  ///< Offset: 0x388 - Interrupt Priority Register
        volatile uint32_t IPR35;  ///< Offset: 0x38C - Interrupt Priority Register
        volatile uint32_t IPR36;  ///< Offset: 0x390 - Interrupt Priority Register
        volatile uint32_t IPR37;  ///< Offset: 0x394 - Interrupt Priority Register
        volatile uint32_t IPR38;  ///< Offset: 0x398 - Interrupt Priority Register
        volatile uint32_t IPR39;  ///< Offset: 0x39C - Interrupt Priority Register
        volatile uint32_t ISER3;  ///< Offset: 0x0C - Interrupt Set-Enable Register
        volatile uint32_t ISER4;  ///< Offset: 0x10 - Interrupt Set-Enable Register
        volatile uint32_t ICER3;  ///< Offset: 0x8C - Interrupt Clear-Enable Register
        volatile uint32_t ICER4;  ///< Offset: 0x90 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR3;  ///< Offset: 0x10C - Interrupt Set-Pending Register
        volatile uint32_t ISPR4;  ///< Offset: 0x110 - Interrupt Set-Pending Register
        volatile uint32_t ICPR3;  ///< Offset: 0x1C0 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR4;  ///< Offset: 0x1C4 - Interrupt Clear-Pending Register
        volatile uint32_t IABR3;  ///< Offset: 0x20C - Interrupt Active Bit Register
        volatile uint32_t IABR4;  ///< Offset: 0x210 - Interrupt Active Bit Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);
    inline Registers* NVIC_STIR = reinterpret_cast<Registers*>(NVIC_STIR_BASE);

    // Bit definitions
    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER2 Register bits
    namespace iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER2 Register bits
    namespace icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR2 Register bits
    namespace ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR2 Register bits
    namespace icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR2 Register bits
    namespace iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR14 Register bits
    namespace ipr14_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR15 Register bits
    namespace ipr15_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR16 Register bits
    namespace ipr16_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR17 Register bits
    namespace ipr17_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR18 Register bits
    namespace ipr18_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR19 Register bits
    namespace ipr19_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR20 Register bits
    namespace ipr20_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR21 Register bits
    namespace ipr21_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR22 Register bits
    namespace ipr22_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR23 Register bits
    namespace ipr23_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR24 Register bits
    namespace ipr24_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR25 Register bits
    namespace ipr25_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR26 Register bits
    namespace ipr26_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR27 Register bits
    namespace ipr27_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR28 Register bits
    namespace ipr28_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR29 Register bits
    namespace ipr29_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR30 Register bits
    namespace ipr30_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR31 Register bits
    namespace ipr31_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR32 Register bits
    namespace ipr32_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR33 Register bits
    namespace ipr33_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR34 Register bits
    namespace ipr34_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR35 Register bits
    namespace ipr35_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR36 Register bits
    namespace ipr36_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR37 Register bits
    namespace ipr37_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR38 Register bits
    namespace ipr38_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR39 Register bits
    namespace ipr39_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000ED90;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t MPU_TYPER;  ///< Offset: 0x00 - MPU type register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0x04 - MPU control register
        volatile uint32_t MPU_RNR;  ///< Offset: 0x08 - MPU region number register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0x0C - MPU region base address register
        volatile uint32_t MPU_RASR;  ///< Offset: 0x10 - MPU region attribute and size register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// MPU_TYPER Register bits
    namespace mpu_typer_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate flag
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables the MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enables the operation of MPU during hard fault
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enable priviliged software access to default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< MPU region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< Size of the MPU protection region
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< memory attribute
        constexpr uint32_t C = (1U << 17);  ///< memory attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable memory attribute
        constexpr uint32_t TEX = (3 << 19);  ///< memory attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

}

// ============================================================================
// STK Peripheral
// ============================================================================

namespace stk {
    /// Base addresses
    constexpr uint32_t STK_BASE = 0xE000E010;

    /// STK Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick control and status register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick reload value register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick current value register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick calibration value register
    };

    /// Peripheral instances
    inline Registers* STK = reinterpret_cast<Registers*>(STK_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick exception request enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source selection
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< COUNTFLAG
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< RELOAD value
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Calibration value
        constexpr uint32_t SKEW = (1U << 30);  ///< SKEW flag: Indicates whether the TENMS value is exact
        constexpr uint32_t NOREF = (1U << 31);  ///< NOREF flag. Reads as zero
    }

}

// ============================================================================
// FPU Peripheral
// ============================================================================

namespace fpu {
    /// Base addresses
    constexpr uint32_t FPU_CPACR_BASE = 0xE000ED88;
    constexpr uint32_t FPU_BASE = 0xE000EF34;

    /// FPU Register structure
    struct Registers {
        volatile uint32_t CPACR;  ///< Offset: 0x00 - Coprocessor access control register
    };

    /// Peripheral instances
    inline Registers* FPU_CPACR = reinterpret_cast<Registers*>(FPU_CPACR_BASE);
    inline Registers* FPU = reinterpret_cast<Registers*>(FPU_BASE);

    // Bit definitions
    /// CPACR Register bits
    namespace cpacr_bits {
        constexpr uint32_t CP = (4 << 20);  ///< CP
    }

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_ACTRL_BASE = 0xE000E008;
    constexpr uint32_t SCB_BASE = 0xE000ED00;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t ACTRL;  ///< Offset: 0x00 - Auxiliary control register
    };

    /// Peripheral instances
    inline Registers* SCB_ACTRL = reinterpret_cast<Registers*>(SCB_ACTRL_BASE);
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);

    // Bit definitions
    /// ACTRL Register bits
    namespace actrl_bits {
        constexpr uint32_t DISFOLD = (1U << 2);  ///< DISFOLD
        constexpr uint32_t FPEXCODIS = (1U << 10);  ///< FPEXCODIS
        constexpr uint32_t DISRAMODE = (1U << 11);  ///< DISRAMODE
        constexpr uint32_t DISITMATBFLUSH = (1U << 12);  ///< DISITMATBFLUSH
    }

}

// ============================================================================
// PF Peripheral
// ============================================================================

namespace pf {
    /// Base addresses
    constexpr uint32_t PF_BASE = 0xE000ED78;

    /// PF Register structure
    struct Registers {
        volatile uint32_t CLIDR;  ///< Offset: 0x00 - Cache Level ID register
        volatile uint32_t CTR;  ///< Offset: 0x04 - Cache Type register
        volatile uint32_t CCSIDR;  ///< Offset: 0x08 - Cache Size ID register
    };

    /// Peripheral instances
    inline Registers* PF = reinterpret_cast<Registers*>(PF_BASE);

    // Bit definitions
    /// CLIDR Register bits
    namespace clidr_bits {
        constexpr uint32_t CL1 = (3 << 0);  ///< CL1
        constexpr uint32_t CL2 = (3 << 3);  ///< CL2
        constexpr uint32_t CL3 = (3 << 6);  ///< CL3
        constexpr uint32_t CL4 = (3 << 9);  ///< CL4
        constexpr uint32_t CL5 = (3 << 12);  ///< CL5
        constexpr uint32_t CL6 = (3 << 15);  ///< CL6
        constexpr uint32_t CL7 = (3 << 18);  ///< CL7
        constexpr uint32_t LoUIS = (3 << 21);  ///< LoUIS
        constexpr uint32_t LoC = (3 << 24);  ///< LoC
        constexpr uint32_t LoU = (3 << 27);  ///< LoU
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t _IminLine = (4 << 0);  ///< IminLine
        constexpr uint32_t DMinLine = (4 << 16);  ///< DMinLine
        constexpr uint32_t ERG = (4 << 20);  ///< ERG
        constexpr uint32_t CWG = (4 << 24);  ///< CWG
        constexpr uint32_t Format = (3 << 29);  ///< Format
    }

    /// CCSIDR Register bits
    namespace ccsidr_bits {
        constexpr uint32_t LineSize = (3 << 0);  ///< LineSize
        constexpr uint32_t Associativity = (10 << 3);  ///< Associativity
        constexpr uint32_t NumSets = (15 << 13);  ///< NumSets
        constexpr uint32_t WA = (1U << 28);  ///< WA
        constexpr uint32_t RA = (1U << 29);  ///< RA
        constexpr uint32_t WB = (1U << 30);  ///< WB
        constexpr uint32_t WT = (1U << 31);  ///< WT
    }

}

// ============================================================================
// AC Peripheral
// ============================================================================

namespace ac {
    /// Base addresses
    constexpr uint32_t AC_BASE = 0xE000EF90;

    /// AC Register structure
    struct Registers {
        volatile uint32_t ITCMCR;  ///< Offset: 0x00 - Instruction and Data Tightly-Coupled Memory Control Registers
        volatile uint32_t DTCMCR;  ///< Offset: 0x04 - Instruction and Data Tightly-Coupled Memory Control Registers
        volatile uint32_t AHBPCR;  ///< Offset: 0x08 - AHBP Control register
        volatile uint32_t CACR;  ///< Offset: 0x0C - Auxiliary Cache Control register
        volatile uint32_t AHBSCR;  ///< Offset: 0x10 - AHB Slave Control register
        volatile uint32_t ABFSR;  ///< Offset: 0x18 - Auxiliary Bus Fault Status register
    };

    /// Peripheral instances
    inline Registers* AC = reinterpret_cast<Registers*>(AC_BASE);

    // Bit definitions
    /// ITCMCR Register bits
    namespace itcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t RMW = (1U << 1);  ///< RMW
        constexpr uint32_t RETEN = (1U << 2);  ///< RETEN
        constexpr uint32_t SZ = (4 << 3);  ///< SZ
    }

    /// DTCMCR Register bits
    namespace dtcmcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t RMW = (1U << 1);  ///< RMW
        constexpr uint32_t RETEN = (1U << 2);  ///< RETEN
        constexpr uint32_t SZ = (4 << 3);  ///< SZ
    }

    /// AHBPCR Register bits
    namespace ahbpcr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t SZ = (3 << 1);  ///< SZ
    }

    /// CACR Register bits
    namespace cacr_bits {
        constexpr uint32_t SIWT = (1U << 0);  ///< SIWT
        constexpr uint32_t ECCEN = (1U << 1);  ///< ECCEN
        constexpr uint32_t FORCEWT = (1U << 2);  ///< FORCEWT
    }

    /// AHBSCR Register bits
    namespace ahbscr_bits {
        constexpr uint32_t CTL = (2 << 0);  ///< CTL
        constexpr uint32_t TPRI = (9 << 2);  ///< TPRI
        constexpr uint32_t INITCOUNT = (5 << 11);  ///< INITCOUNT
    }

    /// ABFSR Register bits
    namespace abfsr_bits {
        constexpr uint32_t ITCM = (1U << 0);  ///< ITCM
        constexpr uint32_t DTCM = (1U << 1);  ///< DTCM
        constexpr uint32_t AHBP = (1U << 2);  ///< AHBP
        constexpr uint32_t AXIM = (1U << 3);  ///< AXIM
        constexpr uint32_t EPPB = (1U << 4);  ///< EPPB
        constexpr uint32_t AXIMTYPE = (2 << 8);  ///< AXIMTYPE
    }

}


} // namespace alloy::generated::stm32h753x

#endif // ALLOY_GENERATED_STM32H753X_PERIPHERALS_HPP