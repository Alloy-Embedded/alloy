/// Auto-generated code for STM32L0x1
/// Generated by Alloy Code Generator
/// Source: st_stm32l0.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:52
#ifndef ALLOY_GENERATED_STM32L0X1_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32L0X1_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32l0x1 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 6;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 7;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 5;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_firewall = true;
    constexpr uint32_t num_firewall_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_dbg = true;
    constexpr uint32_t num_dbg_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_stk = true;
    constexpr uint32_t num_stk_instances = 1;
    constexpr bool has_scb = true;
    constexpr uint32_t num_scb_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct firewall_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct stk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 6;
    constexpr uint32_t max_gpio_pins = 96;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart4 = true;
    constexpr bool has_usart5 = true;
    constexpr bool has_lpuart1 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x40026000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DINR;  ///< Offset: 0x08 - data input register
        volatile uint32_t DOUTR;  ///< Offset: 0x0C - data output register
        volatile uint32_t KEYR0;  ///< Offset: 0x10 - key register 0
        volatile uint32_t KEYR1;  ///< Offset: 0x14 - key register 1
        volatile uint32_t KEYR2;  ///< Offset: 0x18 - key register 2
        volatile uint32_t KEYR3;  ///< Offset: 0x1C - key register 3
        volatile uint32_t IVR0;  ///< Offset: 0x20 - initialization vector register 0
        volatile uint32_t IVR1;  ///< Offset: 0x24 - initialization vector register 1
        volatile uint32_t IVR2;  ///< Offset: 0x28 - initialization vector register 2
        volatile uint32_t IVR3;  ///< Offset: 0x2C - initialization vector register 3
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DMAOUTEN = (1U << 12);  ///< Enable DMA management of data output phase
        constexpr uint32_t DMAINEN = (1U << 11);  ///< Enable DMA management of data input phase
        constexpr uint32_t ERRIE = (1U << 10);  ///< Error interrupt enable
        constexpr uint32_t CCFIE = (1U << 9);  ///< CCF flag interrupt enable
        constexpr uint32_t ERRC = (1U << 8);  ///< Error clear
        constexpr uint32_t CCFC = (1U << 7);  ///< Computation Complete Flag Clear
        constexpr uint32_t CHMOD = (2 << 5);  ///< AES chaining mode
        constexpr uint32_t MODE = (2 << 3);  ///< AES operating mode
        constexpr uint32_t DATATYPE = (2 << 1);  ///< Data type selection (for data in and data out to/from the cryptographic block)
        constexpr uint32_t EN = (1U << 0);  ///< AES enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WRERR = (1U << 2);  ///< Write error flag
        constexpr uint32_t RDERR = (1U << 1);  ///< Read error flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// DINR Register bits
    namespace dinr_bits {
        constexpr uint32_t AES_DINR = (32 << 0);  ///< Data Input Register.
    }

    /// DOUTR Register bits
    namespace doutr_bits {
        constexpr uint32_t AES_DOUTR = (32 << 0);  ///< Data output register
    }

    /// KEYR0 Register bits
    namespace keyr0_bits {
        constexpr uint32_t AES_KEYR0 = (32 << 0);  ///< Data Output Register (LSB key [31:0])
    }

    /// KEYR1 Register bits
    namespace keyr1_bits {
        constexpr uint32_t AES_KEYR1 = (32 << 0);  ///< AES key register (key [63:32])
    }

    /// KEYR2 Register bits
    namespace keyr2_bits {
        constexpr uint32_t AES_KEYR2 = (32 << 0);  ///< AES key register (key [95:64])
    }

    /// KEYR3 Register bits
    namespace keyr3_bits {
        constexpr uint32_t AES_KEYR3 = (32 << 0);  ///< AES key register (MSB key [127:96])
    }

    /// IVR0 Register bits
    namespace ivr0_bits {
        constexpr uint32_t AES_IVR0 = (32 << 0);  ///< initialization vector register (LSB IVR [31:0])
    }

    /// IVR1 Register bits
    namespace ivr1_bits {
        constexpr uint32_t AES_IVR1 = (32 << 0);  ///< Initialization Vector Register (IVR [63:32])
    }

    /// IVR2 Register bits
    namespace ivr2_bits {
        constexpr uint32_t AES_IVR2 = (32 << 0);  ///< Initialization Vector Register (IVR [95:64])
    }

    /// IVR3 Register bits
    namespace ivr3_bits {
        constexpr uint32_t AES_IVR3 = (32 << 0);  ///< Initialization Vector Register (MSB IVR [127:96])
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA1_BASE = 0x40020000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - interrupt status register
        volatile uint32_t IFCR;  ///< Offset: 0x04 - interrupt flag clear register
        volatile uint32_t CCR1;  ///< Offset: 0x08 - channel x configuration register
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - channel x number of data register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - channel x peripheral address register
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - channel x memory address register
        volatile uint32_t CCR2;  ///< Offset: 0x1C - channel x configuration register
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - channel x number of data register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - channel x peripheral address register
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - channel x memory address register
        volatile uint32_t CCR3;  ///< Offset: 0x30 - channel x configuration register
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - channel x number of data register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - channel x peripheral address register
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - channel x memory address register
        volatile uint32_t CCR4;  ///< Offset: 0x44 - channel x configuration register
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - channel x number of data register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - channel x peripheral address register
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - channel x memory address register
        volatile uint32_t CCR5;  ///< Offset: 0x58 - channel x configuration register
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - channel x number of data register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - channel x peripheral address register
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - channel x memory address register
        volatile uint32_t CCR6;  ///< Offset: 0x6C - channel x configuration register
        volatile uint32_t CNDTR6;  ///< Offset: 0x70 - channel x number of data register
        volatile uint32_t CPAR6;  ///< Offset: 0x74 - channel x peripheral address register
        volatile uint32_t CMAR6;  ///< Offset: 0x78 - channel x memory address register
        volatile uint32_t CCR7;  ///< Offset: 0x80 - channel x configuration register
        volatile uint32_t CNDTR7;  ///< Offset: 0x84 - channel x number of data register
        volatile uint32_t CPAR7;  ///< Offset: 0x88 - channel x peripheral address register
        volatile uint32_t CMAR7;  ///< Offset: 0x8C - channel x memory address register
        volatile uint32_t CSELR;  ///< Offset: 0xA8 - channel selection register
    };

    /// Peripheral instances
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TEIF7 = (1U << 27);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF7 = (1U << 26);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF7 = (1U << 25);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF7 = (1U << 24);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF6 = (1U << 23);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF6 = (1U << 22);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF6 = (1U << 21);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF6 = (1U << 20);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF5 = (1U << 19);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF5 = (1U << 18);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF5 = (1U << 17);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF5 = (1U << 16);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF4 = (1U << 15);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF4 = (1U << 14);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF4 = (1U << 13);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF4 = (1U << 12);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF3 = (1U << 11);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF3 = (1U << 10);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF3 = (1U << 9);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF3 = (1U << 8);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF2 = (1U << 7);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF2 = (1U << 6);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF2 = (1U << 5);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF2 = (1U << 4);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF1 = (1U << 3);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF1 = (1U << 2);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF1 = (1U << 1);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF1 = (1U << 0);  ///< Channel x global interrupt flag (x = 1 ..7)
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF7 = (1U << 24);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF6 = (1U << 20);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF5 = (1U << 16);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF4 = (1U << 12);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF3 = (1U << 8);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF2 = (1U << 4);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF1 = (1U << 0);  ///< Channel x global interrupt clear (x = 1 ..7)
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR6 Register bits
    namespace ccr6_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR6 Register bits
    namespace cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR6 Register bits
    namespace cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR6 Register bits
    namespace cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR7 Register bits
    namespace ccr7_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR7 Register bits
    namespace cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR7 Register bits
    namespace cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR7 Register bits
    namespace cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CSELR Register bits
    namespace cselr_bits {
        constexpr uint32_t C7S = (4 << 24);  ///< DMA channel 7 selection
        constexpr uint32_t C6S = (4 << 20);  ///< DMA channel 6 selection
        constexpr uint32_t C5S = (4 << 16);  ///< DMA channel 5 selection
        constexpr uint32_t C4S = (4 << 12);  ///< DMA channel 4 selection
        constexpr uint32_t C3S = (4 << 8);  ///< DMA channel 3 selection
        constexpr uint32_t C2S = (4 << 4);  ///< DMA channel 2 selection
        constexpr uint32_t C1S = (4 << 0);  ///< DMA channel 1 selection
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (8 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t Polynomialcoefficients = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOH_BASE = 0x50001C00;
    constexpr uint32_t GPIOE_BASE = 0x50001000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - GPIO port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODE0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODE15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEED15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEED0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPD15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPD0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t ID15 = (1U << 15);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID14 = (1U << 14);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID13 = (1U << 13);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID12 = (1U << 12);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID11 = (1U << 11);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID10 = (1U << 10);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID9 = (1U << 9);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID8 = (1U << 8);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID7 = (1U << 7);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID6 = (1U << 6);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID5 = (1U << 5);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID4 = (1U << 4);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID3 = (1U << 3);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID2 = (1U << 2);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID1 = (1U << 1);  ///< Port input data bit (y = 0..15)
        constexpr uint32_t ID0 = (1U << 0);  ///< Port input data bit (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t OD15 = (1U << 15);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD14 = (1U << 14);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD13 = (1U << 13);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD12 = (1U << 12);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD11 = (1U << 11);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD10 = (1U << 10);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD9 = (1U << 9);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD8 = (1U << 8);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD7 = (1U << 7);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD6 = (1U << 6);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD5 = (1U << 5);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD4 = (1U << 4);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD3 = (1U << 3);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD2 = (1U << 2);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD1 = (1U << 1);  ///< Port output data bit (y = 0..15)
        constexpr uint32_t OD0 = (1U << 0);  ///< Port output data bit (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x pin y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x pin y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x pin y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x pin y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x Reset bit y (y= 0 .. 15)
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x Reset bit y (y= 0 .. 15)
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM_BASE = 0x40007C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t TIM21_BASE = 0x40010800;
    constexpr uint32_t TIM22_BASE = 0x40011400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - Interrupt and Status Register
        volatile uint32_t ICR;  ///< Offset: 0x04 - Interrupt Clear Register
        volatile uint32_t IER;  ///< Offset: 0x08 - Interrupt Enable Register
        volatile uint32_t CFGR;  ///< Offset: 0x0C - Configuration Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t CMP;  ///< Offset: 0x14 - Compare Register
        volatile uint32_t ARR;  ///< Offset: 0x18 - Autoreload Register
        volatile uint32_t CNT;  ///< Offset: 0x1C - Counter Register
    };

    /// Peripheral instances
    inline Registers* LPTIM = reinterpret_cast<Registers*>(LPTIM_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* TIM21 = reinterpret_cast<Registers*>(TIM21_BASE);
    inline Registers* TIM22 = reinterpret_cast<Registers*>(TIM22_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t CMPOK = (1U << 3);  ///< Compare register update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CMPM = (1U << 0);  ///< Compare match
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t CMPOKCF = (1U << 3);  ///< Compare register update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CMPMCF = (1U << 0);  ///< compare match Clear Flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t CMPOKIE = (1U << 3);  ///< Compare register update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CMPMIE = (1U << 0);  ///< Compare match Interrupt Enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode
        constexpr uint32_t WAVPOL = (1U << 21);  ///< Waveform shape polarity
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in continuous mode
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in single mode
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM Enable
    }

    /// CMP Register bits
    namespace cmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Compare value.
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value.
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value.
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - RTC time register
        volatile uint32_t DR;  ///< Offset: 0x04 - RTC date register
        volatile uint32_t CR;  ///< Offset: 0x08 - RTC control register
        volatile uint32_t ISR;  ///< Offset: 0x0C - RTC initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - RTC prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - RTC wakeup timer register
        volatile uint32_t ALRMAR;  ///< Offset: 0x1C - RTC alarm A register
        volatile uint32_t ALRMBR;  ///< Offset: 0x20 - RTC alarm B register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t SSR;  ///< Offset: 0x28 - RTC sub second register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - RTC shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - RTC timestamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - RTC timestamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - RTC time-stamp sub second register
        volatile uint32_t CALR;  ///< Offset: 0x3C - RTC calibration register
        volatile uint32_t TAMPCR;  ///< Offset: 0x40 - RTC tamper configuration register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - RTC alarm A sub second register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x48 - RTC alarm B sub second register
        volatile uint32_t OR_;  ///< Offset: 0x4C - option register (renamed from OR_)
        volatile uint32_t BKP0R;  ///< Offset: 0x50 - RTC backup registers
        volatile uint32_t BKP1R;  ///< Offset: 0x54 - RTC backup registers
        volatile uint32_t BKP2R;  ///< Offset: 0x58 - RTC backup registers
        volatile uint32_t BKP3R;  ///< Offset: 0x5C - RTC backup registers
        volatile uint32_t BKP4R;  ///< Offset: 0x60 - RTC backup registers
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection
        constexpr uint32_t BKP = (1U << 18);  ///< Backup
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change)
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change)
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 60 Hz)
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< Wakeup clock selection
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TAMP2F = (1U << 14);  ///< RTC_TAMP2 detection flag
        constexpr uint32_t TAMP1F = (1U << 13);  ///< RTC_TAMP1 detection flag
        constexpr uint32_t TSOVF = (1U << 12);  ///< Time-stamp overflow flag
        constexpr uint32_t TSF = (1U << 11);  ///< Time-stamp flag
        constexpr uint32_t WUTF = (1U << 10);  ///< Wakeup timer flag
        constexpr uint32_t ALRBF = (1U << 9);  ///< Alarm B flag
        constexpr uint32_t ALRAF = (1U << 8);  ///< Alarm A flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (16 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format.
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format.
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// TAMPCR Register bits
    namespace tampcr_bits {
        constexpr uint32_t TAMP2MF = (1U << 21);  ///< Tamper 2 mask flag
        constexpr uint32_t TAMP2NOERASE = (1U << 20);  ///< Tamper 2 no erase
        constexpr uint32_t TAMP2IE = (1U << 19);  ///< Tamper 2 interrupt enable
        constexpr uint32_t TAMP1MF = (1U << 18);  ///< Tamper 1 mask flag
        constexpr uint32_t TAMP1NOERASE = (1U << 17);  ///< Tamper 1 no erase
        constexpr uint32_t TAMP1IE = (1U << 16);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMPPUDIS = (1U << 15);  ///< RTC_TAMPx pull-up disable
        constexpr uint32_t TAMPPRCH = (2 << 13);  ///< RTC_TAMPx precharge duration
        constexpr uint32_t TAMPFLT = (2 << 11);  ///< RTC_TAMPx filter count
        constexpr uint32_t TAMPFREQ = (3 << 8);  ///< Tamper sampling frequency
        constexpr uint32_t TAMPTS = (1U << 7);  ///< Activate timestamp on tamper detection event
        constexpr uint32_t TAMP2_TRG = (1U << 4);  ///< Active level for RTC_TAMP2 input
        constexpr uint32_t TAMP2E = (1U << 3);  ///< RTC_TAMP2 input detection enable
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP1TRG = (1U << 1);  ///< Active level for RTC_TAMP1 input
        constexpr uint32_t TAMP1E = (1U << 0);  ///< RTC_TAMP1 input detection enable
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// OR_ Register bits
    namespace or__bits {
        constexpr uint32_t RTC_OUT_RMP = (1U << 1);  ///< RTC_ALARM on PC13 output type
        constexpr uint32_t RTC_ALARM_TYPE = (1U << 0);  ///< RTC_ALARM on PC13 output type
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART4_BASE = 0x40004C00;
    constexpr uint32_t USART5_BASE = 0x40005000;
    constexpr uint32_t LPUART1_BASE = 0x40004800;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t GTPR;  ///< Offset: 0x10 - Guard time and prescaler register
        volatile uint32_t RTOR;  ///< Offset: 0x14 - Receiver timeout register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART4 = reinterpret_cast<Registers*>(USART4_BASE);
    inline Registers* USART5 = reinterpret_cast<Registers*>(USART5_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t EOBIE = (1U << 27);  ///< End of Block interrupt enable
        constexpr uint32_t RTOIE = (1U << 26);  ///< Receiver timeout interrupt enable
        constexpr uint32_t DEAT4 = (1U << 25);  ///< Driver Enable assertion time
        constexpr uint32_t DEAT3 = (1U << 24);  ///< DEAT3
        constexpr uint32_t DEAT2 = (1U << 23);  ///< DEAT2
        constexpr uint32_t DEAT1 = (1U << 22);  ///< DEAT1
        constexpr uint32_t DEAT0 = (1U << 21);  ///< DEAT0
        constexpr uint32_t DEDT4 = (1U << 20);  ///< Driver Enable de-assertion time
        constexpr uint32_t DEDT3 = (1U << 19);  ///< DEDT3
        constexpr uint32_t DEDT2 = (1U << 18);  ///< DEDT2
        constexpr uint32_t DEDT1 = (1U << 17);  ///< DEDT1
        constexpr uint32_t DEDT0 = (1U << 16);  ///< DEDT0
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4_7 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0_3 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t RTOEN = (1U << 23);  ///< Receiver timeout enable
        constexpr uint32_t ABRMOD1 = (1U << 22);  ///< Auto baud rate mode
        constexpr uint32_t ABRMOD0 = (1U << 21);  ///< ABRMOD0
        constexpr uint32_t ABREN = (1U << 20);  ///< Auto baud rate enable
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t TAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< LIN break detection length
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t SCARCNT = (3 << 17);  ///< Smartcard auto-retry count
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< Ir low-power
        constexpr uint32_t IREN = (1U << 1);  ///< Ir mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t DIV_Mantissa = (12 << 4);  ///< DIV_Mantissa
        constexpr uint32_t DIV_Fraction = (4 << 0);  ///< DIV_Fraction
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

    /// RTOR Register bits
    namespace rtor_bits {
        constexpr uint32_t BLEN = (8 << 24);  ///< Block Length
        constexpr uint32_t RTO = (24 << 0);  ///< Receiver timeout value
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t ABRRQ = (1U << 0);  ///< Auto baud rate request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t ABRF = (1U << 15);  ///< ABRF
        constexpr uint32_t ABRE = (1U << 14);  ///< ABRE
        constexpr uint32_t EOBF = (1U << 12);  ///< EOBF
        constexpr uint32_t RTOF = (1U << 11);  ///< RTOF
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t LBDF = (1U << 8);  ///< LBDF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NF = (1U << 2);  ///< NF
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t EOBCF = (1U << 12);  ///< End of block clear flag
        constexpr uint32_t RTOCF = (1U << 11);  ///< Receiver timeout clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t LBDCF = (1U << 8);  ///< LIN break detection clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// Firewall Peripheral
// ============================================================================

namespace firewall {
    /// Base addresses
    constexpr uint32_t Firewall_BASE = 0x40011C00;

    /// Firewall Register structure
    struct Registers {
        volatile uint32_t FIREWALL_CSSA;  ///< Offset: 0x00 - Code segment start address
        volatile uint32_t FIREWALL_CSL;  ///< Offset: 0x04 - Code segment length
        volatile uint32_t FIREWALL_NVDSSA;  ///< Offset: 0x08 - Non-volatile data segment start address
        volatile uint32_t FIREWALL_NVDSL;  ///< Offset: 0x0C - Non-volatile data segment length
        volatile uint32_t FIREWALL_VDSSA;  ///< Offset: 0x10 - Volatile data segment start address
        volatile uint32_t FIREWALL_VDSL;  ///< Offset: 0x14 - Volatile data segment length
        volatile uint32_t FIREWALL_CR;  ///< Offset: 0x20 - Configuration register
    };

    /// Peripheral instances
    inline Registers* Firewall = reinterpret_cast<Registers*>(Firewall_BASE);

    // Bit definitions
    /// FIREWALL_CSSA Register bits
    namespace firewall_cssa_bits {
        constexpr uint32_t ADD = (16 << 8);  ///< code segment start address
    }

    /// FIREWALL_CSL Register bits
    namespace firewall_csl_bits {
        constexpr uint32_t LENG = (14 << 8);  ///< code segment length
    }

    /// FIREWALL_NVDSSA Register bits
    namespace firewall_nvdssa_bits {
        constexpr uint32_t ADD = (16 << 8);  ///< Non-volatile data segment start address
    }

    /// FIREWALL_NVDSL Register bits
    namespace firewall_nvdsl_bits {
        constexpr uint32_t LENG = (14 << 8);  ///< Non-volatile data segment length
    }

    /// FIREWALL_VDSSA Register bits
    namespace firewall_vdssa_bits {
        constexpr uint32_t ADD = (10 << 6);  ///< Volatile data segment start address
    }

    /// FIREWALL_VDSL Register bits
    namespace firewall_vdsl_bits {
        constexpr uint32_t LENG = (10 << 6);  ///< Non-volatile data segment length
    }

    /// FIREWALL_CR Register bits
    namespace firewall_cr_bits {
        constexpr uint32_t VDE = (1U << 2);  ///< Volatile data execution
        constexpr uint32_t VDS = (1U << 1);  ///< Volatile data shared
        constexpr uint32_t FPA = (1U << 0);  ///< Firewall pre alarm
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x0C - Clock configuration register
        volatile uint32_t CIER;  ///< Offset: 0x10 - Clock interrupt enable register
        volatile uint32_t CIFR;  ///< Offset: 0x14 - Clock interrupt flag register
        volatile uint32_t CICR;  ///< Offset: 0x18 - Clock interrupt clear register
        volatile uint32_t IOPRSTR;  ///< Offset: 0x1C - GPIO reset register
        volatile uint32_t AHBRSTR;  ///< Offset: 0x20 - AHB peripheral reset register
        volatile uint32_t APB2RSTR;  ///< Offset: 0x24 - APB2 peripheral reset register
        volatile uint32_t APB1RSTR;  ///< Offset: 0x28 - APB1 peripheral reset register
        volatile uint32_t IOPENR;  ///< Offset: 0x2C - GPIO clock enable register
        volatile uint32_t AHBENR;  ///< Offset: 0x30 - AHB peripheral clock enable register
        volatile uint32_t APB2ENR;  ///< Offset: 0x34 - APB2 peripheral clock enable register
        volatile uint32_t APB1ENR;  ///< Offset: 0x38 - APB1 peripheral clock enable register
        volatile uint32_t IOPSMEN;  ///< Offset: 0x3C - GPIO clock enable in sleep mode register
        volatile uint32_t AHBSMENR;  ///< Offset: 0x40 - AHB peripheral clock enable in sleep mode register
        volatile uint32_t APB2SMENR;  ///< Offset: 0x44 - APB2 peripheral clock enable in sleep mode register
        volatile uint32_t APB1SMENR;  ///< Offset: 0x48 - APB1 peripheral clock enable in sleep mode register
        volatile uint32_t CCIPR;  ///< Offset: 0x4C - Clock configuration register
        volatile uint32_t CSR;  ///< Offset: 0x50 - Control and status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable bit
        constexpr uint32_t RTCPRE = (2 << 20);  ///< TC/LCD prescaler
        constexpr uint32_t CSSLSEON = (1U << 19);  ///< Clock security system on HSE enable bit
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE clock bypass bit
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable bit
        constexpr uint32_t MSIRDY = (1U << 9);  ///< MSI clock ready flag
        constexpr uint32_t MSION = (1U << 8);  ///< MSI clock enable bit
        constexpr uint32_t HSI16DIVF = (1U << 4);  ///< HSI16DIVF
        constexpr uint32_t HSI16DIVEN = (1U << 3);  ///< HSI16DIVEN
        constexpr uint32_t HSI16RDYF = (1U << 2);  ///< Internal high-speed clock ready flag
        constexpr uint32_t HSI16KERON = (1U << 1);  ///< High-speed internal clock enable bit for some IP kernels
        constexpr uint32_t HSI16ON = (1U << 0);  ///< 16 MHz high-speed internal clock enable
        constexpr uint32_t HSI16OUTEN = (1U << 5);  ///< 16 MHz high-speed internal clock output enable
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t MSITRIM = (8 << 24);  ///< MSI clock trimming
        constexpr uint32_t MSICAL = (8 << 16);  ///< MSI clock calibration
        constexpr uint32_t MSIRANGE = (3 << 13);  ///< MSI clock ranges
        constexpr uint32_t HSI16TRIM = (5 << 8);  ///< High speed internal clock trimming
        constexpr uint32_t HSI16CAL = (8 << 0);  ///< nternal high speed clock calibration
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (3 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (3 << 24);  ///< Microcontroller clock output selection
        constexpr uint32_t PLLDIV = (2 << 22);  ///< PLL output division
        constexpr uint32_t PLLMUL = (4 << 18);  ///< PLL multiplication factor
        constexpr uint32_t PLLSRC = (1U << 16);  ///< PLL entry clock source
        constexpr uint32_t STOPWUCK = (1U << 15);  ///< Wake-up from stop clock selection
        constexpr uint32_t PPRE2 = (3 << 11);  ///< APB high-speed prescaler (APB2)
        constexpr uint32_t PPRE1 = (3 << 8);  ///< APB low-speed prescaler (APB1)
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler
        constexpr uint32_t SWS = (2 << 2);  ///< System clock switch status
        constexpr uint32_t SW = (2 << 0);  ///< System clock switch
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t CSSLSE = (1U << 7);  ///< LSE CSS interrupt flag
        constexpr uint32_t MSIRDYIE = (1U << 5);  ///< MSI ready interrupt flag
        constexpr uint32_t PLLRDYIE = (1U << 4);  ///< PLL ready interrupt flag
        constexpr uint32_t HSERDYIE = (1U << 3);  ///< HSE ready interrupt flag
        constexpr uint32_t HSI16RDYIE = (1U << 2);  ///< HSI16 ready interrupt flag
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt flag
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t CSSHSEF = (1U << 8);  ///< Clock Security System Interrupt flag
        constexpr uint32_t CSSLSEF = (1U << 7);  ///< LSE Clock Security System Interrupt flag
        constexpr uint32_t MSIRDYF = (1U << 5);  ///< MSI ready interrupt flag
        constexpr uint32_t PLLRDYF = (1U << 4);  ///< PLL ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 3);  ///< HSE ready interrupt flag
        constexpr uint32_t HSI16RDYF = (1U << 2);  ///< HSI16 ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t CSSHSEC = (1U << 8);  ///< Clock Security System Interrupt clear
        constexpr uint32_t CSSLSEC = (1U << 7);  ///< LSE Clock Security System Interrupt clear
        constexpr uint32_t MSIRDYC = (1U << 5);  ///< MSI ready Interrupt clear
        constexpr uint32_t PLLRDYC = (1U << 4);  ///< PLL ready Interrupt clear
        constexpr uint32_t HSERDYC = (1U << 3);  ///< HSE ready Interrupt clear
        constexpr uint32_t HSI16RDYC = (1U << 2);  ///< HSI16 ready Interrupt clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready Interrupt clear
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready Interrupt clear
    }

    /// IOPRSTR Register bits
    namespace ioprstr_bits {
        constexpr uint32_t IOPHRST = (1U << 7);  ///< I/O port H reset
        constexpr uint32_t IOPDRST = (1U << 3);  ///< I/O port D reset
        constexpr uint32_t IOPCRST = (1U << 2);  ///< I/O port A reset
        constexpr uint32_t IOPBRST = (1U << 1);  ///< I/O port B reset
        constexpr uint32_t IOPARST = (1U << 0);  ///< I/O port A reset
        constexpr uint32_t IOPERST = (1U << 4);  ///< I/O port E reset
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t CRYPRST = (1U << 24);  ///< Crypto module reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< Test integration module reset
        constexpr uint32_t MIFRST = (1U << 8);  ///< Memory interface reset
        constexpr uint32_t DMARST = (1U << 0);  ///< DMA reset
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t DBGRST = (1U << 22);  ///< DBG reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI 1 reset
        constexpr uint32_t ADCRST = (1U << 9);  ///< ADC interface reset
        constexpr uint32_t TIM22RST = (1U << 5);  ///< TIM22 timer reset
        constexpr uint32_t TIM21RST = (1U << 2);  ///< TIM21 timer reset
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< System configuration controller reset
    }

    /// APB1RSTR Register bits
    namespace apb1rstr_bits {
        constexpr uint32_t LPTIM1RST = (1U << 31);  ///< Low power timer reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t LPUART1RST = (1U << 18);  ///< LPUART1 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset
        constexpr uint32_t WWDGRST = (1U << 11);  ///< Window watchdog reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< Timer 6 reset
        constexpr uint32_t TIM2RST = (1U << 0);  ///< Timer 2 reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< Timer 3 reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< Timer 7 reset
        constexpr uint32_t USART4RST = (1U << 19);  ///< USART4 reset
        constexpr uint32_t USART5RST = (1U << 20);  ///< USART5 reset
        constexpr uint32_t CRCRST = (1U << 27);  ///< CRC reset
        constexpr uint32_t I2C3 = (1U << 30);  ///< I2C3 reset
    }

    /// IOPENR Register bits
    namespace iopenr_bits {
        constexpr uint32_t IOPHEN = (1U << 7);  ///< I/O port H clock enable bit
        constexpr uint32_t IOPDEN = (1U << 3);  ///< I/O port D clock enable bit
        constexpr uint32_t IOPCEN = (1U << 2);  ///< IO port A clock enable bit
        constexpr uint32_t IOPBEN = (1U << 1);  ///< IO port B clock enable bit
        constexpr uint32_t IOPAEN = (1U << 0);  ///< IO port A clock enable bit
        constexpr uint32_t IOPEEN = (1U << 4);  ///< IO port E clock enable bit
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t CRYPEN = (1U << 24);  ///< Crypto clock enable bit
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable bit
        constexpr uint32_t MIFEN = (1U << 8);  ///< NVM interface clock enable bit
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA clock enable bit
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t DBGEN = (1U << 22);  ///< DBG clock enable bit
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable bit
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable bit
        constexpr uint32_t ADCEN = (1U << 9);  ///< ADC clock enable bit
        constexpr uint32_t FWEN = (1U << 7);  ///< Firewall clock enable bit
        constexpr uint32_t TIM22EN = (1U << 5);  ///< TIM22 timer clock enable bit
        constexpr uint32_t TIM21EN = (1U << 2);  ///< TIM21 timer clock enable bit
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< System configuration controller clock enable bit
    }

    /// APB1ENR Register bits
    namespace apb1enr_bits {
        constexpr uint32_t LPTIM1EN = (1U << 31);  ///< Low power timer clock enable bit
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable bit
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable bit
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable bit
        constexpr uint32_t LPUART1EN = (1U << 18);  ///< LPUART1 clock enable bit
        constexpr uint32_t USART2EN = (1U << 17);  ///< UART2 clock enable bit
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable bit
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable bit
        constexpr uint32_t TIM6EN = (1U << 4);  ///< Timer 6 clock enable bit
        constexpr uint32_t TIM2EN = (1U << 0);  ///< Timer2 clock enable bit
        constexpr uint32_t TIM3EN = (1U << 2);  ///< Timer 3 clock enbale bit
        constexpr uint32_t TIM7EN = (1U << 5);  ///< Timer 7 clock enable bit
        constexpr uint32_t USART4EN = (1U << 19);  ///< USART4 clock enable bit
        constexpr uint32_t USART5EN = (1U << 20);  ///< USART5 clock enable bit
        constexpr uint32_t I2C3EN = (1U << 30);  ///< I2C3 clock enable bit
    }

    /// IOPSMEN Register bits
    namespace iopsmen_bits {
        constexpr uint32_t IOPHSMEN = (1U << 7);  ///< Port H clock enable during Sleep mode bit
        constexpr uint32_t IOPDSMEN = (1U << 3);  ///< Port D clock enable during Sleep mode bit
        constexpr uint32_t IOPCSMEN = (1U << 2);  ///< Port C clock enable during Sleep mode bit
        constexpr uint32_t IOPBSMEN = (1U << 1);  ///< Port B clock enable during Sleep mode bit
        constexpr uint32_t IOPASMEN = (1U << 0);  ///< Port A clock enable during Sleep mode bit
        constexpr uint32_t IOPESMEN = (1U << 4);  ///< Port E clock enable during Sleep mode bit
    }

    /// AHBSMENR Register bits
    namespace ahbsmenr_bits {
        constexpr uint32_t CRYPTSMEN = (1U << 24);  ///< Crypto clock enable during sleep mode bit
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clock enable during sleep mode bit
        constexpr uint32_t SRAMSMEN = (1U << 9);  ///< SRAM interface clock enable during sleep mode bit
        constexpr uint32_t MIFSMEN = (1U << 8);  ///< NVM interface clock enable during sleep mode bit
        constexpr uint32_t DMASMEN = (1U << 0);  ///< DMA clock enable during sleep mode bit
    }

    /// APB2SMENR Register bits
    namespace apb2smenr_bits {
        constexpr uint32_t DBGSMEN = (1U << 22);  ///< DBG clock enable during sleep mode bit
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during sleep mode bit
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during sleep mode bit
        constexpr uint32_t ADCSMEN = (1U << 9);  ///< ADC clock enable during sleep mode bit
        constexpr uint32_t TIM22SMEN = (1U << 5);  ///< TIM22 timer clock enable during sleep mode bit
        constexpr uint32_t TIM21SMEN = (1U << 2);  ///< TIM21 timer clock enable during sleep mode bit
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< System configuration controller clock enable during sleep mode bit
    }

    /// APB1SMENR Register bits
    namespace apb1smenr_bits {
        constexpr uint32_t LPTIM1SMEN = (1U << 31);  ///< Low power timer clock enable during sleep mode bit
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clock enable during sleep mode bit
        constexpr uint32_t CRSSMEN = (1U << 27);  ///< Clock recovery system clock enable during sleep mode bit
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during sleep mode bit
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during sleep mode bit
        constexpr uint32_t LPUART1SMEN = (1U << 18);  ///< LPUART1 clock enable during sleep mode bit
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< UART2 clock enable during sleep mode bit
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during sleep mode bit
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< Window watchdog clock enable during sleep mode bit
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< Timer 6 clock enable during sleep mode bit
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< Timer2 clock enable during sleep mode bit
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< Timer 3 clock enable during sleep mode bit
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< Timer 7 clock enable during sleep mode bit
        constexpr uint32_t USART4SMEN = (1U << 19);  ///< USART4 clock enabe during sleep mode bit
        constexpr uint32_t USART5SMEN = (1U << 20);  ///< USART5 clock enable during sleep mode bit
        constexpr uint32_t I2C3SMEN = (1U << 30);  ///< I2C3 clock enable during sleep mode bit
    }

    /// CCIPR Register bits
    namespace ccipr_bits {
        constexpr uint32_t LPTIM1SEL1 = (1U << 19);  ///< Low Power Timer clock source selection bits
        constexpr uint32_t LPTIM1SEL0 = (1U << 18);  ///< LPTIM1SEL0
        constexpr uint32_t I2C1SEL1 = (1U << 13);  ///< I2C1 clock source selection bits
        constexpr uint32_t I2C1SEL0 = (1U << 12);  ///< I2C1SEL0
        constexpr uint32_t LPUART1SEL1 = (1U << 11);  ///< LPUART1 clock source selection bits
        constexpr uint32_t LPUART1SEL0 = (1U << 10);  ///< LPUART1SEL0
        constexpr uint32_t USART2SEL1 = (1U << 3);  ///< USART2 clock source selection bits
        constexpr uint32_t USART2SEL0 = (1U << 2);  ///< USART2SEL0
        constexpr uint32_t USART1SEL1 = (1U << 1);  ///< USART1 clock source selection bits
        constexpr uint32_t USART1SEL0 = (1U << 0);  ///< USART1SEL0
        constexpr uint32_t I2C3SEL0 = (1U << 16);  ///< I2C3 clock source selection bits
        constexpr uint32_t I2C3SEL1 = (1U << 17);  ///< I2C3 clock source selection bits
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LPWRSTF = (1U << 31);  ///< Low-power reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent watchdog reset flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t PORRSTF = (1U << 27);  ///< POR/PDR reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< PIN reset flag
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< OBLRSTF
        constexpr uint32_t FWRSTF = (1U << 24);  ///< Firewall reset flag
        constexpr uint32_t RTCRST = (1U << 19);  ///< RTC software reset bit
        constexpr uint32_t RTCEN = (1U << 18);  ///< RTC clock enable bit
        constexpr uint32_t RTCSEL = (2 << 16);  ///< RTC and LCD clock source selection bits
        constexpr uint32_t CSSLSED = (1U << 14);  ///< CSS on LSE failure detection flag
        constexpr uint32_t CSSLSEON = (1U << 13);  ///< CSSLSEON
        constexpr uint32_t LSEDRV = (2 << 11);  ///< LSEDRV
        constexpr uint32_t LSEBYP = (1U << 10);  ///< External low-speed oscillator bypass bit
        constexpr uint32_t LSERDY = (1U << 9);  ///< External low-speed oscillator ready bit
        constexpr uint32_t LSEON = (1U << 8);  ///< External low-speed oscillator enable bit
        constexpr uint32_t LSIRDY = (1U << 1);  ///< Internal low-speed oscillator ready bit
        constexpr uint32_t LSION = (1U << 0);  ///< Internal low-speed oscillator enable
        constexpr uint32_t LSIIWDGLP = (1U << 2);  ///< LSI clock input to IWDG in Ultra-low-power mode (Stop and Standby) enable bit
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flag
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t SYSCFG_COMP_BASE = 0x40010000;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - SYSCFG configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x04 - SYSCFG configuration register 2
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
        volatile uint32_t CFGR3;  ///< Offset: 0x20 - SYSCFG configuration register 3
        volatile uint32_t COMP1_CTRL;  ///< Offset: 0x18 - Comparator 1 control and status register
        volatile uint32_t COMP2_CTRL;  ///< Offset: 0x1C - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* SYSCFG_COMP = reinterpret_cast<Registers*>(SYSCFG_COMP_BASE);

    // Bit definitions
    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t BOOT_MODE = (2 << 8);  ///< Boot mode selected by the boot pins status bits
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t I2C2_FMP = (1U << 13);  ///< I2C2 Fm+ drive capability enable bit
        constexpr uint32_t I2C1_FMP = (1U << 12);  ///< I2C1 Fm+ drive capability enable bit
        constexpr uint32_t I2C_PB9_FMP = (1U << 11);  ///< Fm+ drive capability on PB9 enable bit
        constexpr uint32_t I2C_PB8_FMP = (1U << 10);  ///< Fm+ drive capability on PB8 enable bit
        constexpr uint32_t I2C_PB7_FMP = (1U << 9);  ///< Fm+ drive capability on PB7 enable bit
        constexpr uint32_t I2C_PB6_FMP = (1U << 8);  ///< Fm+ drive capability on PB6 enable bit
        constexpr uint32_t CAPA = (3 << 1);  ///< Configuration of internal VLCD rail connection to optional external capacitor
        constexpr uint32_t FWDISEN = (1U << 0);  ///< Firewall disable bit
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI x configuration (x = 0 to 3)
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI x configuration (x = 4 to 7)
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI10
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI x configuration (x = 8 to 11)
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI14
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI13
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI12
    }

    /// CFGR3 Register bits
    namespace cfgr3_bits {
        constexpr uint32_t REF_LOCK = (1U << 31);  ///< REF_CTRL lock bit
        constexpr uint32_t VREFINT_RDYF = (1U << 30);  ///< VREFINT ready flag
        constexpr uint32_t VREFINT_COMP_RDYF = (1U << 29);  ///< VREFINT for comparator ready flag
        constexpr uint32_t VREFINT_ADC_RDYF = (1U << 28);  ///< VREFINT for ADC ready flag
        constexpr uint32_t SENSOR_ADC_RDYF = (1U << 27);  ///< Sensor for ADC ready flag
        constexpr uint32_t REF_RC48MHz_RDYF = (1U << 26);  ///< VREFINT for 48 MHz RC oscillator ready flag
        constexpr uint32_t ENREF_RC48MHz = (1U << 13);  ///< VREFINT reference for 48 MHz RC oscillator enable bit
        constexpr uint32_t ENBUF_VREFINT_COMP = (1U << 12);  ///< VREFINT reference for comparator 2 enable bit
        constexpr uint32_t ENBUF_SENSOR_ADC = (1U << 9);  ///< Sensor reference for ADC enable bit
        constexpr uint32_t ENBUF_BGAP_ADC = (1U << 8);  ///< VREFINT reference for ADC enable bit
        constexpr uint32_t SEL_VREF_OUT = (2 << 4);  ///< BGAP_ADC connection bit
        constexpr uint32_t EN_BGAP = (1U << 0);  ///< Vref Enable bit
    }

    /// COMP1_CTRL Register bits
    namespace comp1_ctrl_bits {
        constexpr uint32_t COMP1EN = (1U << 0);  ///< Comparator 1 enable bit
        constexpr uint32_t COMP1INNSEL = (2 << 4);  ///< Comparator 1 Input Minus connection configuration bit
        constexpr uint32_t COMP1WM = (1U << 8);  ///< Comparator 1 window mode selection bit
        constexpr uint32_t COMP1LPTIMIN1 = (1U << 12);  ///< Comparator 1 LPTIM input propagation bit
        constexpr uint32_t COMP1POLARITY = (1U << 15);  ///< Comparator 1 polarity selection bit
        constexpr uint32_t COMP1VALUE = (1U << 30);  ///< Comparator 1 output status bit
        constexpr uint32_t COMP1LOCK = (1U << 31);  ///< COMP1_CSR register lock bit
    }

    /// COMP2_CTRL Register bits
    namespace comp2_ctrl_bits {
        constexpr uint32_t COMP2EN = (1U << 0);  ///< Comparator 2 enable bit
        constexpr uint32_t COMP2SPEED = (1U << 3);  ///< Comparator 2 power mode selection bit
        constexpr uint32_t COMP2INNSEL = (3 << 4);  ///< Comparator 2 Input Minus connection configuration bit
        constexpr uint32_t COMP2INPSEL = (3 << 8);  ///< Comparator 2 Input Plus connection configuration bit
        constexpr uint32_t COMP2LPTIMIN2 = (1U << 12);  ///< Comparator 2 LPTIM input 2 propagation bit
        constexpr uint32_t COMP2LPTIMIN1 = (1U << 13);  ///< Comparator 2 LPTIM input 1 propagation bit
        constexpr uint32_t COMP2POLARITY = (1U << 15);  ///< Comparator 2 polarity selection bit
        constexpr uint32_t COMP2VALUE = (1U << 30);  ///< Comparator 2 output status bit
        constexpr uint32_t COMP2LOCK = (1U << 31);  ///< COMP2_CSR register lock bit
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - I2S configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - I2S prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
        constexpr uint32_t I2SE = (1U << 10);  ///< I2S Enable
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2S standard selection
        constexpr uint32_t CKPOL = (1U << 3);  ///< Steady state clock polarity
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2S Linear prescaler
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C3_BASE = 0x40007800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - power control register
        volatile uint32_t CSR;  ///< Offset: 0x04 - power control/status register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t LPDS = (1U << 0);  ///< Low-power deep sleep
        constexpr uint32_t PDDS = (1U << 1);  ///< Power down deepsleep
        constexpr uint32_t CWUF = (1U << 2);  ///< Clear wakeup flag
        constexpr uint32_t CSBF = (1U << 3);  ///< Clear standby flag
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t PLS = (3 << 5);  ///< PVD level selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t ULP = (1U << 9);  ///< Ultra-low-power mode
        constexpr uint32_t FWU = (1U << 10);  ///< Fast wakeup
        constexpr uint32_t VOS = (2 << 11);  ///< Voltage scaling range selection
        constexpr uint32_t DS_EE_KOFF = (1U << 13);  ///< Deep sleep mode with Flash memory kept off
        constexpr uint32_t LPRUN = (1U << 14);  ///< Low power run mode
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t BRE = (1U << 9);  ///< Backup regulator enable
        constexpr uint32_t EWUP = (1U << 8);  ///< Enable WKUP pin
        constexpr uint32_t BRR = (1U << 3);  ///< Backup regulator ready
        constexpr uint32_t PVDO = (1U << 2);  ///< PVD output
        constexpr uint32_t SBF = (1U << 1);  ///< Standby flag
        constexpr uint32_t WUF = (1U << 0);  ///< Wakeup flag
        constexpr uint32_t VOSF = (1U << 4);  ///< Voltage Scaling select flag
        constexpr uint32_t REGLPF = (1U << 5);  ///< Regulator LP flag
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t Flash_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t PECR;  ///< Offset: 0x04 - Program/erase control register
        volatile uint32_t PDKEYR;  ///< Offset: 0x08 - Power down key register
        volatile uint32_t PEKEYR;  ///< Offset: 0x0C - Program/erase key register
        volatile uint32_t PRGKEYR;  ///< Offset: 0x10 - Program memory key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x14 - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x18 - Status register
        volatile uint32_t OBR;  ///< Offset: 0x1C - Option byte register
        volatile uint32_t WRPR;  ///< Offset: 0x20 - Write protection register
    };

    /// Peripheral instances
    inline Registers* Flash = reinterpret_cast<Registers*>(Flash_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (1U << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 1);  ///< Prefetch enable
        constexpr uint32_t SLEEP_PD = (1U << 3);  ///< Flash mode during Sleep
        constexpr uint32_t RUN_PD = (1U << 4);  ///< Flash mode during Run
        constexpr uint32_t DESAB_BUF = (1U << 5);  ///< Disable Buffer
        constexpr uint32_t PRE_READ = (1U << 6);  ///< Pre-read data address
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PELOCK = (1U << 0);  ///< FLASH_PECR and data EEPROM lock
        constexpr uint32_t PRGLOCK = (1U << 1);  ///< Program memory lock
        constexpr uint32_t OPTLOCK = (1U << 2);  ///< Option bytes block lock
        constexpr uint32_t PROG = (1U << 3);  ///< Program memory selection
        constexpr uint32_t DATA = (1U << 4);  ///< Data EEPROM selection
        constexpr uint32_t FTDW = (1U << 8);  ///< Fixed time data write for Byte, Half Word and Word programming
        constexpr uint32_t ERASE = (1U << 9);  ///< Page or Double Word erase mode
        constexpr uint32_t FPRG = (1U << 10);  ///< Half Page/Double Word programming mode
        constexpr uint32_t PARALLELBANK = (1U << 15);  ///< Parallel bank mode
        constexpr uint32_t EOPIE = (1U << 16);  ///< End of programming interrupt enable
        constexpr uint32_t ERRIE = (1U << 17);  ///< Error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 18);  ///< Launch the option byte loading
    }

    /// PDKEYR Register bits
    namespace pdkeyr_bits {
        constexpr uint32_t PDKEYR = (32 << 0);  ///< RUN_PD in FLASH_ACR key
    }

    /// PEKEYR Register bits
    namespace pekeyr_bits {
        constexpr uint32_t PEKEYR = (32 << 0);  ///< FLASH_PEC and data EEPROM key
    }

    /// PRGKEYR Register bits
    namespace prgkeyr_bits {
        constexpr uint32_t PRGKEYR = (32 << 0);  ///< Program memory key
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Write/erase operations in progress
        constexpr uint32_t EOP = (1U << 1);  ///< End of operation
        constexpr uint32_t ENDHV = (1U << 2);  ///< End of high voltage
        constexpr uint32_t READY = (1U << 3);  ///< Flash memory module ready after low power mode
        constexpr uint32_t WRPERR = (1U << 8);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 9);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 10);  ///< Size error
        constexpr uint32_t OPTVERR = (1U << 11);  ///< Option validity error
        constexpr uint32_t RDERR = (1U << 14);  ///< RDERR
        constexpr uint32_t NOTZEROERR = (1U << 16);  ///< NOTZEROERR
        constexpr uint32_t FWWERR = (1U << 17);  ///< FWWERR
    }

    /// OBR Register bits
    namespace obr_bits {
        constexpr uint32_t RDPRT = (8 << 0);  ///< Read protection
        constexpr uint32_t BOR_LEV = (4 << 16);  ///< BOR_LEV
        constexpr uint32_t SPRMOD = (1U << 8);  ///< Selection of protection mode of WPR bits
    }

    /// WRPR Register bits
    namespace wrpr_bits {
        constexpr uint32_t WRP = (16 << 0);  ///< Write protection
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40010400;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t IMR;  ///< Offset: 0x00 - Interrupt mask register (EXTI_IMR)
        volatile uint32_t EMR;  ///< Offset: 0x04 - Event mask register (EXTI_EMR)
        volatile uint32_t RTSR;  ///< Offset: 0x08 - Rising Trigger selection register (EXTI_RTSR)
        volatile uint32_t FTSR;  ///< Offset: 0x0C - Falling Trigger selection register (EXTI_FTSR)
        volatile uint32_t SWIER;  ///< Offset: 0x10 - Software interrupt event register (EXTI_SWIER)
        volatile uint32_t PR;  ///< Offset: 0x14 - Pending register (EXTI_PR)
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< Interrupt Mask on line 0
        constexpr uint32_t IM1 = (1U << 1);  ///< Interrupt Mask on line 1
        constexpr uint32_t IM2 = (1U << 2);  ///< Interrupt Mask on line 2
        constexpr uint32_t IM3 = (1U << 3);  ///< Interrupt Mask on line 3
        constexpr uint32_t IM4 = (1U << 4);  ///< Interrupt Mask on line 4
        constexpr uint32_t IM5 = (1U << 5);  ///< Interrupt Mask on line 5
        constexpr uint32_t IM6 = (1U << 6);  ///< Interrupt Mask on line 6
        constexpr uint32_t IM7 = (1U << 7);  ///< Interrupt Mask on line 7
        constexpr uint32_t IM8 = (1U << 8);  ///< Interrupt Mask on line 8
        constexpr uint32_t IM9 = (1U << 9);  ///< Interrupt Mask on line 9
        constexpr uint32_t IM10 = (1U << 10);  ///< Interrupt Mask on line 10
        constexpr uint32_t IM11 = (1U << 11);  ///< Interrupt Mask on line 11
        constexpr uint32_t IM12 = (1U << 12);  ///< Interrupt Mask on line 12
        constexpr uint32_t IM13 = (1U << 13);  ///< Interrupt Mask on line 13
        constexpr uint32_t IM14 = (1U << 14);  ///< Interrupt Mask on line 14
        constexpr uint32_t IM15 = (1U << 15);  ///< Interrupt Mask on line 15
        constexpr uint32_t IM16 = (1U << 16);  ///< Interrupt Mask on line 16
        constexpr uint32_t IM17 = (1U << 17);  ///< Interrupt Mask on line 17
        constexpr uint32_t IM18 = (1U << 18);  ///< Interrupt Mask on line 18
        constexpr uint32_t IM19 = (1U << 19);  ///< Interrupt Mask on line 19
        constexpr uint32_t IM20 = (1U << 20);  ///< Interrupt Mask on line 20
        constexpr uint32_t IM21 = (1U << 21);  ///< Interrupt Mask on line 21
        constexpr uint32_t IM22 = (1U << 22);  ///< Interrupt Mask on line 22
        constexpr uint32_t IM23 = (1U << 23);  ///< Interrupt Mask on line 23
        constexpr uint32_t IM24 = (1U << 24);  ///< Interrupt Mask on line 24
        constexpr uint32_t IM25 = (1U << 25);  ///< Interrupt Mask on line 25
        constexpr uint32_t IM26 = (1U << 26);  ///< Interrupt Mask on line 27
        constexpr uint32_t IM28 = (1U << 28);  ///< Interrupt Mask on line 27
        constexpr uint32_t IM29 = (1U << 29);  ///< Interrupt Mask on line 27
    }

    /// EMR Register bits
    namespace emr_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< Event Mask on line 0
        constexpr uint32_t EM1 = (1U << 1);  ///< Event Mask on line 1
        constexpr uint32_t EM2 = (1U << 2);  ///< Event Mask on line 2
        constexpr uint32_t EM3 = (1U << 3);  ///< Event Mask on line 3
        constexpr uint32_t EM4 = (1U << 4);  ///< Event Mask on line 4
        constexpr uint32_t EM5 = (1U << 5);  ///< Event Mask on line 5
        constexpr uint32_t EM6 = (1U << 6);  ///< Event Mask on line 6
        constexpr uint32_t EM7 = (1U << 7);  ///< Event Mask on line 7
        constexpr uint32_t EM8 = (1U << 8);  ///< Event Mask on line 8
        constexpr uint32_t EM9 = (1U << 9);  ///< Event Mask on line 9
        constexpr uint32_t EM10 = (1U << 10);  ///< Event Mask on line 10
        constexpr uint32_t EM11 = (1U << 11);  ///< Event Mask on line 11
        constexpr uint32_t EM12 = (1U << 12);  ///< Event Mask on line 12
        constexpr uint32_t EM13 = (1U << 13);  ///< Event Mask on line 13
        constexpr uint32_t EM14 = (1U << 14);  ///< Event Mask on line 14
        constexpr uint32_t EM15 = (1U << 15);  ///< Event Mask on line 15
        constexpr uint32_t EM16 = (1U << 16);  ///< Event Mask on line 16
        constexpr uint32_t EM17 = (1U << 17);  ///< Event Mask on line 17
        constexpr uint32_t EM18 = (1U << 18);  ///< Event Mask on line 18
        constexpr uint32_t EM19 = (1U << 19);  ///< Event Mask on line 19
        constexpr uint32_t EM20 = (1U << 20);  ///< Event Mask on line 20
        constexpr uint32_t EM21 = (1U << 21);  ///< Event Mask on line 21
        constexpr uint32_t EM22 = (1U << 22);  ///< Event Mask on line 22
        constexpr uint32_t EM23 = (1U << 23);  ///< Event Mask on line 23
        constexpr uint32_t EM24 = (1U << 24);  ///< Event Mask on line 24
        constexpr uint32_t EM25 = (1U << 25);  ///< Event Mask on line 25
        constexpr uint32_t EM26 = (1U << 26);  ///< Event Mask on line 26
        constexpr uint32_t EM28 = (1U << 28);  ///< Event Mask on line 28
        constexpr uint32_t EM29 = (1U << 29);  ///< Event Mask on line 29
    }

    /// RTSR Register bits
    namespace rtsr_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration of line 0
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration of line 1
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration of line 2
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration of line 3
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration of line 4
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration of line 5
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration of line 6
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration of line 7
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration of line 8
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration of line 9
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration of line 10
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration of line 11
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration of line 12
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration of line 13
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration of line 14
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration of line 15
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration of line 16
        constexpr uint32_t RT17 = (1U << 17);  ///< Rising trigger event configuration of line 17
        constexpr uint32_t RT19 = (1U << 19);  ///< Rising trigger event configuration of line 19
        constexpr uint32_t RT20 = (1U << 20);  ///< Rising trigger event configuration of line 20
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration of line 21
        constexpr uint32_t RT22 = (1U << 22);  ///< Rising trigger event configuration of line 22
    }

    /// FTSR Register bits
    namespace ftsr_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration of line 0
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration of line 1
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration of line 2
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration of line 3
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration of line 4
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration of line 5
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration of line 6
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration of line 7
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration of line 8
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration of line 9
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration of line 10
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration of line 11
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration of line 12
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration of line 13
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration of line 14
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration of line 15
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration of line 16
        constexpr uint32_t FT17 = (1U << 17);  ///< Falling trigger event configuration of line 17
        constexpr uint32_t FT19 = (1U << 19);  ///< Falling trigger event configuration of line 19
        constexpr uint32_t FT20 = (1U << 20);  ///< Falling trigger event configuration of line 20
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration of line 21
        constexpr uint32_t FT22 = (1U << 22);  ///< Falling trigger event configuration of line 22
    }

    /// SWIER Register bits
    namespace swier_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software Interrupt on line 0
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software Interrupt on line 1
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software Interrupt on line 2
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software Interrupt on line 3
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software Interrupt on line 4
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software Interrupt on line 5
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software Interrupt on line 6
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software Interrupt on line 7
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software Interrupt on line 8
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software Interrupt on line 9
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software Interrupt on line 10
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software Interrupt on line 11
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software Interrupt on line 12
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software Interrupt on line 13
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software Interrupt on line 14
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software Interrupt on line 15
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software Interrupt on line 16
        constexpr uint32_t SWI17 = (1U << 17);  ///< Software Interrupt on line 17
        constexpr uint32_t SWI19 = (1U << 19);  ///< Software Interrupt on line 19
        constexpr uint32_t SWI20 = (1U << 20);  ///< Software Interrupt on line 20
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software Interrupt on line 21
        constexpr uint32_t SWI22 = (1U << 22);  ///< Software Interrupt on line 22
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PIF0 = (1U << 0);  ///< Pending bit 0
        constexpr uint32_t PIF1 = (1U << 1);  ///< Pending bit 1
        constexpr uint32_t PIF2 = (1U << 2);  ///< Pending bit 2
        constexpr uint32_t PIF3 = (1U << 3);  ///< Pending bit 3
        constexpr uint32_t PIF4 = (1U << 4);  ///< Pending bit 4
        constexpr uint32_t PIF5 = (1U << 5);  ///< Pending bit 5
        constexpr uint32_t PIF6 = (1U << 6);  ///< Pending bit 6
        constexpr uint32_t PIF7 = (1U << 7);  ///< Pending bit 7
        constexpr uint32_t PIF8 = (1U << 8);  ///< Pending bit 8
        constexpr uint32_t PIF9 = (1U << 9);  ///< Pending bit 9
        constexpr uint32_t PIF10 = (1U << 10);  ///< Pending bit 10
        constexpr uint32_t PIF11 = (1U << 11);  ///< Pending bit 11
        constexpr uint32_t PIF12 = (1U << 12);  ///< Pending bit 12
        constexpr uint32_t PIF13 = (1U << 13);  ///< Pending bit 13
        constexpr uint32_t PIF14 = (1U << 14);  ///< Pending bit 14
        constexpr uint32_t PIF15 = (1U << 15);  ///< Pending bit 15
        constexpr uint32_t PIF16 = (1U << 16);  ///< Pending bit 16
        constexpr uint32_t PIF17 = (1U << 17);  ///< Pending bit 17
        constexpr uint32_t PIF19 = (1U << 19);  ///< Pending bit 19
        constexpr uint32_t PIF20 = (1U << 20);  ///< Pending bit 20
        constexpr uint32_t PIF21 = (1U << 21);  ///< Pending bit 21
        constexpr uint32_t PIF22 = (1U << 22);  ///< Pending bit 22
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - interrupt and status register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t CFGR1;  ///< Offset: 0x0C - configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x10 - configuration register 2
        volatile uint32_t SMPR;  ///< Offset: 0x14 - sampling time register
        volatile uint32_t TR;  ///< Offset: 0x20 - watchdog threshold register
        volatile uint32_t CHSELR;  ///< Offset: 0x28 - channel selection register
        volatile uint32_t DR;  ///< Offset: 0x40 - data register
        volatile uint32_t CALFACT;  ///< Offset: 0xB4 - ADC Calibration factor
        volatile uint32_t CCR;  ///< Offset: 0x308 - ADC common configuration register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag
        constexpr uint32_t EOS = (1U << 3);  ///< End of sequence flag
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun
        constexpr uint32_t AWD = (1U << 7);  ///< Analog watchdog flag
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of conversion interrupt enable
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of conversion sequence interrupt enable
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable
        constexpr uint32_t AWDIE = (1U << 7);  ///< Analog watchdog interrupt enable
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable command
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start conversion command
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop conversion command
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC Voltage Regulator Enable
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t AWDCH = (5 << 26);  ///< Analog watchdog channel selection
        constexpr uint32_t AWDEN = (1U << 23);  ///< Analog watchdog enable
        constexpr uint32_t AWDSGL = (1U << 22);  ///< Enable the watchdog on a single channel or on all channels
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode
        constexpr uint32_t AUTDLY = (1U << 14);  ///< Auto-delayed conversion mode
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun management mode
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection
        constexpr uint32_t EXTSEL = (3 << 6);  ///< External trigger selection
        constexpr uint32_t ALIGN = (1U << 5);  ///< Data alignment
        constexpr uint32_t RES = (2 << 3);  ///< Data resolution
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction
        constexpr uint32_t DMACFG = (1U << 1);  ///< Direct memery access configuration
        constexpr uint32_t DMAEN = (1U << 0);  ///< Direct memory access enable
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t OVSE = (1U << 0);  ///< Oversampler Enable
        constexpr uint32_t OVSR = (3 << 2);  ///< Oversampling ratio
        constexpr uint32_t OVSS = (4 << 5);  ///< Oversampling shift
        constexpr uint32_t TOVS = (1U << 9);  ///< Triggered Oversampling
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode
    }

    /// SMPR Register bits
    namespace smpr_bits {
        constexpr uint32_t SMPR = (3 << 0);  ///< Sampling time selection
    }

    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t HT = (12 << 16);  ///< Analog watchdog higher threshold
        constexpr uint32_t LT = (12 << 0);  ///< Analog watchdog lower threshold
    }

    /// CHSELR Register bits
    namespace chselr_bits {
        constexpr uint32_t CHSEL18 = (1U << 18);  ///< Channel-x selection
        constexpr uint32_t CHSEL17 = (1U << 17);  ///< Channel-x selection
        constexpr uint32_t CHSEL16 = (1U << 16);  ///< Channel-x selection
        constexpr uint32_t CHSEL15 = (1U << 15);  ///< Channel-x selection
        constexpr uint32_t CHSEL14 = (1U << 14);  ///< Channel-x selection
        constexpr uint32_t CHSEL13 = (1U << 13);  ///< Channel-x selection
        constexpr uint32_t CHSEL12 = (1U << 12);  ///< Channel-x selection
        constexpr uint32_t CHSEL11 = (1U << 11);  ///< Channel-x selection
        constexpr uint32_t CHSEL10 = (1U << 10);  ///< Channel-x selection
        constexpr uint32_t CHSEL9 = (1U << 9);  ///< Channel-x selection
        constexpr uint32_t CHSEL8 = (1U << 8);  ///< Channel-x selection
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel-x selection
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel-x selection
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel-x selection
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel-x selection
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel-x selection
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel-x selection
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel-x selection
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel-x selection
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Converted data
    }

    /// CALFACT Register bits
    namespace calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< Calibration factor
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable
        constexpr uint32_t VLCDEN = (1U << 24);  ///< VLCD enable
        constexpr uint32_t LFMEN = (1U << 25);  ///< Low Frequency Mode enable
    }

}

// ============================================================================
// DBG Peripheral
// ============================================================================

namespace dbg {
    /// Base addresses
    constexpr uint32_t DBG_BASE = 0x40015800;

    /// DBG Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - MCU Device ID Code Register
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU Configuration Register
        volatile uint32_t APB1_FZ;  ///< Offset: 0x08 - APB Low Freeze Register
        volatile uint32_t APB2_FZ;  ///< Offset: 0x0C - APB High Freeze Register
    };

    /// Peripheral instances
    inline Registers* DBG = reinterpret_cast<Registers*>(DBG_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device Identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision Identifier
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop Mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby Mode
        constexpr uint32_t DBG_SLEEP = (1U << 0);  ///< Debug Sleep Mode
    }

    /// APB1_FZ Register bits
    namespace apb1_fz_bits {
        constexpr uint32_t DBG_TIMER2_STOP = (1U << 0);  ///< Debug Timer 2 stopped when Core is halted
        constexpr uint32_t DBG_TIMER6_STOP = (1U << 4);  ///< Debug Timer 6 stopped when Core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< Debug RTC stopped when Core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Debug Window Wachdog stopped when Core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Debug Independent Wachdog stopped when Core is halted
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout mode stopped when core is halted
        constexpr uint32_t DBG_I2C2_STOP = (1U << 22);  ///< I2C2 SMBUS timeout mode stopped when core is halted
        constexpr uint32_t DBG_LPTIMER_STOP = (1U << 31);  ///< LPTIM1 counter stopped when core is halted
    }

    /// APB2_FZ Register bits
    namespace apb2_fz_bits {
        constexpr uint32_t DBG_TIMER21_STOP = (1U << 2);  ///< Debug Timer 21 stopped when Core is halted
        constexpr uint32_t DBG_TIMER22_STO = (1U << 6);  ///< Debug Timer 22 stopped when Core is halted
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER;  ///< Offset: 0x00 - Interrupt Set Enable Register
        volatile uint32_t ICER;  ///< Offset: 0x80 - Interrupt Clear Enable Register
        volatile uint32_t ISPR;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ICPR;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register 0
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register 1
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register 2
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register 3
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register 4
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register 5
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register 6
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register 7
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// ISER Register bits
    namespace iser_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER Register bits
    namespace icer_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR Register bits
    namespace ispr_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR Register bits
    namespace icpr_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t PRI_0 = (8 << 0);  ///< priority for interrupt 0
        constexpr uint32_t PRI_1 = (8 << 8);  ///< priority for interrupt 1
        constexpr uint32_t PRI_2 = (8 << 16);  ///< priority for interrupt 2
        constexpr uint32_t PRI_3 = (8 << 24);  ///< priority for interrupt 3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_5 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_6 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_7 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t PRI_8 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_9 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_10 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_11 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t PRI_12 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_13 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_14 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_15 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t PRI_16 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_17 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_18 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_19 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t PRI_20 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_21 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_22 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_23 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t PRI_24 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_25 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_26 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_27 = (8 << 24);  ///< priority for interrupt n
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t PRI_28 = (8 << 0);  ///< priority for interrupt n
        constexpr uint32_t PRI_29 = (8 << 8);  ///< priority for interrupt n
        constexpr uint32_t PRI_30 = (8 << 16);  ///< priority for interrupt n
        constexpr uint32_t PRI_31 = (8 << 24);  ///< priority for interrupt n
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0xE000ED90;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t MPU_TYPER;  ///< Offset: 0x00 - MPU type register
        volatile uint32_t MPU_CTRL;  ///< Offset: 0x04 - MPU control register
        volatile uint32_t MPU_RNR;  ///< Offset: 0x08 - MPU region number register
        volatile uint32_t MPU_RBAR;  ///< Offset: 0x0C - MPU region base address register
        volatile uint32_t MPU_RASR;  ///< Offset: 0x10 - MPU region attribute and size register
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// MPU_TYPER Register bits
    namespace mpu_typer_bits {
        constexpr uint32_t SEPARATE = (1U << 0);  ///< Separate flag
        constexpr uint32_t DREGION = (8 << 8);  ///< Number of MPU data regions
        constexpr uint32_t IREGION = (8 << 16);  ///< Number of MPU instruction regions
    }

    /// MPU_CTRL Register bits
    namespace mpu_ctrl_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enables the MPU
        constexpr uint32_t HFNMIENA = (1U << 1);  ///< Enables the operation of MPU during hard fault
        constexpr uint32_t PRIVDEFENA = (1U << 2);  ///< Enable priviliged software access to default memory map
    }

    /// MPU_RNR Register bits
    namespace mpu_rnr_bits {
        constexpr uint32_t REGION = (8 << 0);  ///< MPU region
    }

    /// MPU_RBAR Register bits
    namespace mpu_rbar_bits {
        constexpr uint32_t REGION = (4 << 0);  ///< MPU region field
        constexpr uint32_t VALID = (1U << 4);  ///< MPU region number valid
        constexpr uint32_t ADDR = (27 << 5);  ///< Region base address field
    }

    /// MPU_RASR Register bits
    namespace mpu_rasr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Region enable bit.
        constexpr uint32_t SIZE = (5 << 1);  ///< Size of the MPU protection region
        constexpr uint32_t SRD = (8 << 8);  ///< Subregion disable bits
        constexpr uint32_t B = (1U << 16);  ///< memory attribute
        constexpr uint32_t C = (1U << 17);  ///< memory attribute
        constexpr uint32_t S = (1U << 18);  ///< Shareable memory attribute
        constexpr uint32_t TEX = (3 << 19);  ///< memory attribute
        constexpr uint32_t AP = (3 << 24);  ///< Access permission
        constexpr uint32_t XN = (1U << 28);  ///< Instruction access disable bit
    }

}

// ============================================================================
// STK Peripheral
// ============================================================================

namespace stk {
    /// Base addresses
    constexpr uint32_t STK_BASE = 0xE000E010;

    /// STK Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick control and status register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick reload value register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick current value register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick calibration value register
    };

    /// Peripheral instances
    inline Registers* STK = reinterpret_cast<Registers*>(STK_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Counter enable
        constexpr uint32_t TICKINT = (1U << 1);  ///< SysTick exception request enable
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< Clock source selection
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< COUNTFLAG
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< RELOAD value
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current counter value
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Calibration value
        constexpr uint32_t SKEW = (1U << 30);  ///< SKEW flag: Indicates whether the TENMS value is exact
        constexpr uint32_t NOREF = (1U << 31);  ///< NOREF flag. Reads as zero
    }

}

// ============================================================================
// SCB Peripheral
// ============================================================================

namespace scb {
    /// Base addresses
    constexpr uint32_t SCB_BASE = 0xE000ED00;

    /// SCB Register structure
    struct Registers {
        volatile uint32_t CPUID;  ///< Offset: 0x00 - CPUID base register
        volatile uint32_t ICSR;  ///< Offset: 0x04 - Interrupt control and state register
        volatile uint32_t VTOR;  ///< Offset: 0x08 - Vector table offset register
        volatile uint32_t AIRCR;  ///< Offset: 0x0C - Application interrupt and reset control register
        volatile uint32_t SCR;  ///< Offset: 0x10 - System control register
        volatile uint32_t CCR;  ///< Offset: 0x14 - Configuration and control register
        volatile uint32_t SHPR2;  ///< Offset: 0x1C - System handler priority registers
        volatile uint32_t SHPR3;  ///< Offset: 0x20 - System handler priority registers
    };

    /// Peripheral instances
    inline Registers* SCB = reinterpret_cast<Registers*>(SCB_BASE);

    // Bit definitions
    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t Revision = (4 << 0);  ///< Revision number
        constexpr uint32_t PartNo = (12 << 4);  ///< Part number of the processor
        constexpr uint32_t Architecture = (4 << 16);  ///< Reads as 0xF
        constexpr uint32_t Variant = (4 << 20);  ///< Variant number
        constexpr uint32_t Implementer = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active vector
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< Return to base level
        constexpr uint32_t VECTPENDING = (7 << 12);  ///< Pending vector
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< Interrupt pending flag
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< SysTick exception clear-pending bit
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< SysTick exception set-pending bit
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< PendSV clear-pending bit
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< PendSV set-pending bit
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< NMI set-pending bit.
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset field
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< VECTCLRACTIVE
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< SYSRESETREQ
        constexpr uint32_t ENDIANESS = (1U << 15);  ///< ENDIANESS
        constexpr uint32_t VECTKEYSTAT = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< SLEEPONEXIT
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< SLEEPDEEP
        constexpr uint32_t SEVEONPEND = (1U << 4);  ///< Send Event on Pending bit
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< Configures how the processor enters Thread mode
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< USERSETMPEND
        constexpr uint32_t UNALIGN__TRP = (1U << 3);  ///< UNALIGN_ TRP
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< DIV_0_TRP
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< BFHFNMIGN
        constexpr uint32_t STKALIGN = (1U << 9);  ///< STKALIGN
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15
    }

}


} // namespace alloy::generated::stm32l0x1

#endif // ALLOY_GENERATED_STM32L0X1_PERIPHERALS_HPP