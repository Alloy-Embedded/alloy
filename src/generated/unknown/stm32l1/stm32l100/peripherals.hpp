/// Auto-generated code for STM32L100
/// Generated by Alloy Code Generator
/// Source: st_stm32l100.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:22:11
#ifndef ALLOY_GENERATED_STM32L100_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32L100_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32l100 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t C_ADC_BASE = 0x40012700;
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - ADC Common status register
        volatile uint32_t CCR;  ///< Offset: 0x04 - ADC common control register
    };

    /// Peripheral instances
    inline Registers* C_ADC = reinterpret_cast<Registers*>(C_ADC_BASE);
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ADONS1 = (1U << 6);  ///< ADON Status of ADC
        constexpr uint32_t OVR1 = (1U << 5);  ///< Overrun flag of ADC 1
        constexpr uint32_t STRT1 = (1U << 4);  ///< Regular channel Start flag of ADC 1
        constexpr uint32_t JSTRT1 = (1U << 3);  ///< Injected channel Start flag of ADC 1
        constexpr uint32_t JEOC1 = (1U << 2);  ///< Injected channel end of conversion of ADC 1
        constexpr uint32_t EOC1 = (1U << 1);  ///< End of conversion of ADC 1
        constexpr uint32_t AWD1 = (1U << 0);  ///< Analog watchdog flag of ADC 1
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t TSVREFE = (1U << 23);  ///< Temperature sensor and VREFINT enable
        constexpr uint32_t ADCPRE = (2 << 16);  ///< ADC prescaler
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x40007C00;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - comparator control and status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t TSUSP = (1U << 31);  ///< Suspend Timer Mode
        constexpr uint32_t CAIF = (1U << 30);  ///< Channel acquisition interrupt flag
        constexpr uint32_t CAIE = (1U << 29);  ///< Channel Acquisition Interrupt Enable / Clear
        constexpr uint32_t RCH13 = (1U << 28);  ///< Select GPIO port PC3 as re-routed ADC input channel CH13.
        constexpr uint32_t FCH8 = (1U << 27);  ///< Select GPIO port PB0 as fast ADC input channel CH8.
        constexpr uint32_t FCH3 = (1U << 26);  ///< Select GPIO port PA3 as fast ADC input channel CH3.
        constexpr uint32_t OUTSEL = (3 << 21);  ///< Comparator 2 output selection
        constexpr uint32_t INSEL = (3 << 18);  ///< Inverted input selection
        constexpr uint32_t WNDWE = (1U << 17);  ///< Window mode enable
        constexpr uint32_t VREFOUTEN = (1U << 16);  ///< VREFINT output enable
        constexpr uint32_t CMP2OUT = (1U << 13);  ///< Comparator 2 output
        constexpr uint32_t SPEED = (1U << 12);  ///< Comparator 2 speed mode
        constexpr uint32_t CMP1OUT = (1U << 7);  ///< Comparator 1 output
        constexpr uint32_t SW1 = (1U << 5);  ///< SW1 analog switch enable
        constexpr uint32_t CMP1EN = (1U << 4);  ///< Comparator 1 enable
        constexpr uint32_t PD400K = (1U << 3);  ///< 400 kO pull-down resistor
        constexpr uint32_t PD10K = (1U << 2);  ///< 10 kO pull-down resistor
        constexpr uint32_t PU400K = (1U << 1);  ///< 400 kO pull-up resistor
        constexpr uint32_t PU10K = (1U << 0);  ///< 10 kO pull-up resistor
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t Data_register = (32 << 0);  ///< Data Register
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t Independent_data_register = (7 << 0);  ///< Independent data register
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< RESET
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SWTRIGR;  ///< Offset: 0x04 - software trigger register
        volatile uint32_t DHR12R1;  ///< Offset: 0x08 - channel1 12-bit right-aligned data holding register
        volatile uint32_t DHR12L1;  ///< Offset: 0x0C - channel1 12-bit left aligned data holding register
        volatile uint32_t DHR8R1;  ///< Offset: 0x10 - channel1 8-bit right aligned data holding register
        volatile uint32_t DHR12R2;  ///< Offset: 0x14 - channel2 12-bit right aligned data holding register
        volatile uint32_t DHR12L2;  ///< Offset: 0x18 - channel2 12-bit left aligned data holding register
        volatile uint32_t DHR8R2;  ///< Offset: 0x1C - channel2 8-bit right-aligned data holding register
        volatile uint32_t DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DOR1;  ///< Offset: 0x2C - channel1 data output register
        volatile uint32_t DOR2;  ///< Offset: 0x30 - channel2 data output register
        volatile uint32_t SR;  ///< Offset: 0x34 - status register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable
        constexpr uint32_t TSEL2 = (3 << 19);  ///< DAC channel2 trigger selection
        constexpr uint32_t TEN2 = (1U << 18);  ///< DAC channel2 trigger enable
        constexpr uint32_t BOFF2 = (1U << 17);  ///< DAC channel2 output buffer disable
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable
        constexpr uint32_t TSEL1 = (3 << 3);  ///< DAC channel1 trigger selection
        constexpr uint32_t TEN1 = (1U << 2);  ///< DAC channel1 trigger enable
        constexpr uint32_t BOFF1 = (1U << 1);  ///< DAC channel1 output buffer disable
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable
    }

    /// SWTRIGR Register bits
    namespace swtrigr_bits {
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger
    }

    /// DHR12R1 Register bits
    namespace dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
    }

    /// DHR12L1 Register bits
    namespace dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
    }

    /// DHR8R1 Register bits
    namespace dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DHR12R2 Register bits
    namespace dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DHR12L2 Register bits
    namespace dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data
    }

    /// DHR8R2 Register bits
    namespace dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DHR12RD Register bits
    namespace dhr12rd_bits {
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
    }

    /// DHR12LD Register bits
    namespace dhr12ld_bits {
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
    }

    /// DHR8RD Register bits
    namespace dhr8rd_bits {
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
    }

    /// DOR1 Register bits
    namespace dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output
    }

    /// DOR2 Register bits
    namespace dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40026000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - interrupt status register
        volatile uint32_t IFCR;  ///< Offset: 0x04 - interrupt flag clear register
        volatile uint32_t CCR1;  ///< Offset: 0x08 - channel x configuration register
        volatile uint32_t CNDTR1;  ///< Offset: 0x0C - channel x number of data register
        volatile uint32_t CPAR1;  ///< Offset: 0x10 - channel x peripheral address register
        volatile uint32_t CMAR1;  ///< Offset: 0x14 - channel x memory address register
        volatile uint32_t CCR2;  ///< Offset: 0x1C - channel x configuration register
        volatile uint32_t CNDTR2;  ///< Offset: 0x20 - channel x number of data register
        volatile uint32_t CPAR2;  ///< Offset: 0x24 - channel x peripheral address register
        volatile uint32_t CMAR2;  ///< Offset: 0x28 - channel x memory address register
        volatile uint32_t CCR3;  ///< Offset: 0x30 - channel x configuration register
        volatile uint32_t CNDTR3;  ///< Offset: 0x34 - channel x number of data register
        volatile uint32_t CPAR3;  ///< Offset: 0x38 - channel x peripheral address register
        volatile uint32_t CMAR3;  ///< Offset: 0x3C - channel x memory address register
        volatile uint32_t CCR4;  ///< Offset: 0x44 - channel x configuration register
        volatile uint32_t CNDTR4;  ///< Offset: 0x48 - channel x number of data register
        volatile uint32_t CPAR4;  ///< Offset: 0x4C - channel x peripheral address register
        volatile uint32_t CMAR4;  ///< Offset: 0x50 - channel x memory address register
        volatile uint32_t CCR5;  ///< Offset: 0x58 - channel x configuration register
        volatile uint32_t CNDTR5;  ///< Offset: 0x5C - channel x number of data register
        volatile uint32_t CPAR5;  ///< Offset: 0x60 - channel x peripheral address register
        volatile uint32_t CMAR5;  ///< Offset: 0x64 - channel x memory address register
        volatile uint32_t CCR6;  ///< Offset: 0x6C - channel x configuration register
        volatile uint32_t CNDTR6;  ///< Offset: 0x70 - channel x number of data register
        volatile uint32_t CPAR6;  ///< Offset: 0x74 - channel x peripheral address register
        volatile uint32_t CMAR6;  ///< Offset: 0x78 - channel x memory address register
        volatile uint32_t CCR7;  ///< Offset: 0x80 - channel x configuration register
        volatile uint32_t CNDTR7;  ///< Offset: 0x84 - channel x number of data register
        volatile uint32_t CPAR7;  ///< Offset: 0x88 - channel x peripheral address register
        volatile uint32_t CMAR7;  ///< Offset: 0x8C - channel x memory address register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TEIF7 = (1U << 27);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF7 = (1U << 26);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF7 = (1U << 25);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF7 = (1U << 24);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF6 = (1U << 23);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF6 = (1U << 22);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF6 = (1U << 21);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF6 = (1U << 20);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF5 = (1U << 19);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF5 = (1U << 18);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF5 = (1U << 17);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF5 = (1U << 16);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF4 = (1U << 15);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF4 = (1U << 14);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF4 = (1U << 13);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF4 = (1U << 12);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF3 = (1U << 11);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF3 = (1U << 10);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF3 = (1U << 9);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF3 = (1U << 8);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF2 = (1U << 7);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF2 = (1U << 6);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF2 = (1U << 5);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF2 = (1U << 4);  ///< Channel x global interrupt flag (x = 1 ..7)
        constexpr uint32_t TEIF1 = (1U << 3);  ///< Channel x transfer error flag (x = 1 ..7)
        constexpr uint32_t HTIF1 = (1U << 2);  ///< Channel x half transfer flag (x = 1 ..7)
        constexpr uint32_t TCIF1 = (1U << 1);  ///< Channel x transfer complete flag (x = 1 ..7)
        constexpr uint32_t GIF1 = (1U << 0);  ///< Channel x global interrupt flag (x = 1 ..7)
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CTEIF7 = (1U << 27);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF7 = (1U << 26);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF7 = (1U << 25);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF7 = (1U << 24);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF6 = (1U << 23);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF6 = (1U << 22);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF6 = (1U << 21);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF6 = (1U << 20);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF5 = (1U << 19);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF5 = (1U << 18);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF5 = (1U << 17);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF5 = (1U << 16);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF4 = (1U << 15);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF4 = (1U << 14);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF4 = (1U << 13);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF4 = (1U << 12);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF3 = (1U << 11);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF3 = (1U << 10);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF3 = (1U << 9);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF3 = (1U << 8);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF2 = (1U << 7);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF2 = (1U << 6);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF2 = (1U << 5);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF2 = (1U << 4);  ///< Channel x global interrupt clear (x = 1 ..7)
        constexpr uint32_t CTEIF1 = (1U << 3);  ///< Channel x transfer error clear (x = 1 ..7)
        constexpr uint32_t CHTIF1 = (1U << 2);  ///< Channel x half transfer clear (x = 1 ..7)
        constexpr uint32_t CTCIF1 = (1U << 1);  ///< Channel x transfer complete clear (x = 1 ..7)
        constexpr uint32_t CGIF1 = (1U << 0);  ///< Channel x global interrupt clear (x = 1 ..7)
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR1 Register bits
    namespace cndtr1_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR1 Register bits
    namespace cpar1_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR1 Register bits
    namespace cmar1_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR2 Register bits
    namespace cndtr2_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR2 Register bits
    namespace cpar2_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR2 Register bits
    namespace cmar2_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR3 Register bits
    namespace ccr3_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR3 Register bits
    namespace cndtr3_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR3 Register bits
    namespace cpar3_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR3 Register bits
    namespace cmar3_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR4 Register bits
    namespace ccr4_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR4 Register bits
    namespace cndtr4_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR4 Register bits
    namespace cpar4_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR4 Register bits
    namespace cmar4_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR5 Register bits
    namespace ccr5_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR5 Register bits
    namespace cndtr5_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR5 Register bits
    namespace cpar5_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR5 Register bits
    namespace cmar5_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR6 Register bits
    namespace ccr6_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR6 Register bits
    namespace cndtr6_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR6 Register bits
    namespace cpar6_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR6 Register bits
    namespace cmar6_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// CCR7 Register bits
    namespace ccr7_bits {
        constexpr uint32_t MEM2MEM = (1U << 14);  ///< Memory to memory mode
        constexpr uint32_t PL = (2 << 12);  ///< Channel priority level
        constexpr uint32_t MSIZE = (2 << 10);  ///< Memory size
        constexpr uint32_t PSIZE = (2 << 8);  ///< Peripheral size
        constexpr uint32_t MINC = (1U << 7);  ///< Memory increment mode
        constexpr uint32_t PINC = (1U << 6);  ///< Peripheral increment mode
        constexpr uint32_t CIRC = (1U << 5);  ///< Circular mode
        constexpr uint32_t DIR = (1U << 4);  ///< Data transfer direction
        constexpr uint32_t TEIE = (1U << 3);  ///< Transfer error interrupt enable
        constexpr uint32_t HTIE = (1U << 2);  ///< Half transfer interrupt enable
        constexpr uint32_t TCIE = (1U << 1);  ///< Transfer complete interrupt enable
        constexpr uint32_t EN = (1U << 0);  ///< Channel enable
    }

    /// CNDTR7 Register bits
    namespace cndtr7_bits {
        constexpr uint32_t NDT = (16 << 0);  ///< Number of data to transfer
    }

    /// CPAR7 Register bits
    namespace cpar7_bits {
        constexpr uint32_t PA = (32 << 0);  ///< Peripheral address
    }

    /// CMAR7 Register bits
    namespace cmar7_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40010400;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t IMR;  ///< Offset: 0x00 - IMR
        volatile uint32_t EMR;  ///< Offset: 0x04 - EMR
        volatile uint32_t RTSR;  ///< Offset: 0x08 - RTSR
        volatile uint32_t FTSR;  ///< Offset: 0x0C - FTSR
        volatile uint32_t SWIER;  ///< Offset: 0x10 - SWIER
        volatile uint32_t PR;  ///< Offset: 0x14 - PR
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t MR = (23 << 0);  ///< Interrupt mask on line x
    }

    /// EMR Register bits
    namespace emr_bits {
        constexpr uint32_t MR = (23 << 0);  ///< Event mask on line x
    }

    /// RTSR Register bits
    namespace rtsr_bits {
        constexpr uint32_t TR = (23 << 0);  ///< Rising edge trigger event configuration bit of line x
    }

    /// FTSR Register bits
    namespace ftsr_bits {
        constexpr uint32_t TR = (23 << 0);  ///< Falling edge trigger event configuration bit of line x
    }

    /// SWIER Register bits
    namespace swier_bits {
        constexpr uint32_t SWIER = (23 << 0);  ///< Software interrupt on line x
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (23 << 0);  ///< Pending bit
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t Flash_BASE = 0x40023C00;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t PECR;  ///< Offset: 0x04 - Program/erase control register
        volatile uint32_t PDKEYR;  ///< Offset: 0x08 - Power down key register
        volatile uint32_t PEKEYR;  ///< Offset: 0x0C - Program/erase key register
        volatile uint32_t PRGKEYR;  ///< Offset: 0x10 - Program memory key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x14 - Option byte key register
        volatile uint32_t SR;  ///< Offset: 0x18 - Status register
        volatile uint32_t OBR;  ///< Offset: 0x1C - Option byte register
        volatile uint32_t WRPR1;  ///< Offset: 0x20 - Write protection register
        volatile uint32_t WRPR2;  ///< Offset: 0x80 - Write protection register
        volatile uint32_t WRPR3;  ///< Offset: 0x84 - Write protection register
    };

    /// Peripheral instances
    inline Registers* Flash = reinterpret_cast<Registers*>(Flash_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (1U << 0);  ///< Latency
        constexpr uint32_t PRFTEN = (1U << 1);  ///< Prefetch enable
        constexpr uint32_t ACC64 = (1U << 2);  ///< 64-bit access
        constexpr uint32_t SLEEP_PD = (1U << 3);  ///< Flash mode during Sleep
        constexpr uint32_t RUN_PD = (1U << 4);  ///< Flash mode during Run
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PELOCK = (1U << 0);  ///< FLASH_PECR and data EEPROM lock
        constexpr uint32_t PRGLOCK = (1U << 1);  ///< Program memory lock
        constexpr uint32_t OPTLOCK = (1U << 2);  ///< Option bytes block lock
        constexpr uint32_t PROG = (1U << 3);  ///< Program memory selection
        constexpr uint32_t DATA = (1U << 4);  ///< Data EEPROM selection
        constexpr uint32_t FTDW = (1U << 8);  ///< Fixed time data write for Byte, Half Word and Word programming
        constexpr uint32_t ERASE = (1U << 9);  ///< Page or Double Word erase mode
        constexpr uint32_t FPRG = (1U << 10);  ///< Half Page/Double Word programming mode
        constexpr uint32_t PARALLELBANK = (1U << 15);  ///< Parallel bank mode
        constexpr uint32_t EOPIE = (1U << 16);  ///< End of programming interrupt enable
        constexpr uint32_t ERRIE = (1U << 17);  ///< Error interrupt enable
        constexpr uint32_t OBL_LAUNCH = (1U << 18);  ///< Launch the option byte loading
    }

    /// PDKEYR Register bits
    namespace pdkeyr_bits {
        constexpr uint32_t PDKEYR = (32 << 0);  ///< RUN_PD in FLASH_ACR key
    }

    /// PEKEYR Register bits
    namespace pekeyr_bits {
        constexpr uint32_t PEKEYR = (32 << 0);  ///< FLASH_PEC and data EEPROM key
    }

    /// PRGKEYR Register bits
    namespace prgkeyr_bits {
        constexpr uint32_t PRGKEYR = (32 << 0);  ///< Program memory key
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< Option byte key
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BSY = (1U << 0);  ///< Write/erase operations in progress
        constexpr uint32_t EOP = (1U << 1);  ///< End of operation
        constexpr uint32_t ENDHV = (1U << 2);  ///< End of high voltage
        constexpr uint32_t READY = (1U << 3);  ///< Flash memory module ready after low power mode
        constexpr uint32_t WRPERR = (1U << 8);  ///< Write protected error
        constexpr uint32_t PGAERR = (1U << 9);  ///< Programming alignment error
        constexpr uint32_t SIZERR = (1U << 10);  ///< Size error
        constexpr uint32_t OPTVERR = (1U << 11);  ///< Option validity error
        constexpr uint32_t OPTVERRUSR = (1U << 12);  ///< Option UserValidity Error
    }

    /// OBR Register bits
    namespace obr_bits {
        constexpr uint32_t RDPRT = (8 << 0);  ///< Read protection
        constexpr uint32_t BOR_LEV = (4 << 16);  ///< BOR_LEV
        constexpr uint32_t IWDG_SW = (1U << 20);  ///< IWDG_SW
        constexpr uint32_t nRTS_STOP = (1U << 21);  ///< nRTS_STOP
        constexpr uint32_t nRST_STDBY = (1U << 22);  ///< nRST_STDBY
        constexpr uint32_t BFB2 = (1U << 23);  ///< Boot From Bank 2
    }

    /// WRPR1 Register bits
    namespace wrpr1_bits {
        constexpr uint32_t WRP1 = (32 << 0);  ///< Write protection
    }

    /// WRPR2 Register bits
    namespace wrpr2_bits {
        constexpr uint32_t WRP2 = (32 << 0);  ///< WRP2
    }

    /// WRPR3 Register bits
    namespace wrpr3_bits {
        constexpr uint32_t WRP3 = (32 << 0);  ///< WRP3
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x40020000;
    constexpr uint32_t GPIOB_BASE = 0x40020400;
    constexpr uint32_t GPIOC_BASE = 0x40020800;
    constexpr uint32_t GPIOD_BASE = 0x40020C00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDER;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - AFRL
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDER Register bits
    namespace ospeeder_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< OSPEEDR15
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< OSPEEDR14
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< OSPEEDR13
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< OSPEEDR12
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< OSPEEDR11
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< OSPEEDR10
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< OSPEEDR9
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< OSPEEDR8
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< OSPEEDR7
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< OSPEEDR6
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< OSPEEDR5
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< OSPEEDR4
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< OSPEEDR3
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< OSPEEDR2
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< OSPEEDR1
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< OSPEEDR0
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFRL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFRL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFRH15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFRH8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - CR1
        volatile uint32_t CR2;  ///< Offset: 0x04 - CR2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - OAR1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - OAR2
        volatile uint32_t DR;  ///< Offset: 0x10 - DR
        volatile uint32_t SR1;  ///< Offset: 0x14 - SR1
        volatile uint32_t SR2;  ///< Offset: 0x18 - SR2
        volatile uint32_t CCR;  ///< Offset: 0x1C - CCR
        volatile uint32_t TRISE;  ///< Offset: 0x20 - TRISE
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t SWRST = (1U << 15);  ///< Software reset
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t PEC = (1U << 12);  ///< Packet error checking
        constexpr uint32_t POS = (1U << 11);  ///< Acknowledge/PEC Position (for data reception)
        constexpr uint32_t ACK = (1U << 10);  ///< Acknowledge enable
        constexpr uint32_t STOP = (1U << 9);  ///< Stop generation
        constexpr uint32_t START = (1U << 8);  ///< Start generation
        constexpr uint32_t NOSTRETCH = (1U << 7);  ///< Clock stretching disable (Slave mode)
        constexpr uint32_t ENGC = (1U << 6);  ///< General call enable
        constexpr uint32_t ENPEC = (1U << 5);  ///< PEC enable
        constexpr uint32_t ENARP = (1U << 4);  ///< ARP enable
        constexpr uint32_t SMBTYPE = (1U << 3);  ///< SMBus type
        constexpr uint32_t SMBUS = (1U << 1);  ///< SMBus mode
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LAST = (1U << 12);  ///< DMA last transfer
        constexpr uint32_t DMAEN = (1U << 11);  ///< DMA requests enable
        constexpr uint32_t ITBUFEN = (1U << 10);  ///< Buffer interrupt enable
        constexpr uint32_t ITEVTEN = (1U << 9);  ///< Event interrupt enable
        constexpr uint32_t ITERREN = (1U << 8);  ///< Error interrupt enable
        constexpr uint32_t FREQ = (6 << 0);  ///< Peripheral clock frequency
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t ADDMODE = (1U << 15);  ///< ADDMODE
        constexpr uint32_t ADD_8_9 = (2 << 8);  ///< Interface address
        constexpr uint32_t ADD_1_7 = (7 << 1);  ///< Interface address
        constexpr uint32_t ADD_0 = (1U << 0);  ///< Interface address
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t ADD2 = (7 << 1);  ///< Interface address
        constexpr uint32_t ENDUAL = (1U << 0);  ///< Dual addressing mode enable
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (8 << 0);  ///< -bit data register
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t SMBALERT = (1U << 15);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 14);  ///< Timeout or Tlow error
        constexpr uint32_t PECERR = (1U << 12);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 11);  ///< Overrun/Underrun
        constexpr uint32_t AF = (1U << 10);  ///< Acknowledge failure
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost (master mode)
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TxE = (1U << 7);  ///< Data register empty (transmitters)
        constexpr uint32_t RxNE = (1U << 6);  ///< Data register not empty (receivers)
        constexpr uint32_t STOPF = (1U << 4);  ///< Stop detection (slave mode)
        constexpr uint32_t ADD10 = (1U << 3);  ///< 10-bit header sent (Master mode)
        constexpr uint32_t BTF = (1U << 2);  ///< Byte transfer finished
        constexpr uint32_t ADDR = (1U << 1);  ///< Address sent (master mode)/matched (slave mode)
        constexpr uint32_t SB = (1U << 0);  ///< Start bit (Master mode)
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PEC = (8 << 8);  ///< acket error checking register
        constexpr uint32_t DUALF = (1U << 7);  ///< Dual flag (Slave mode)
        constexpr uint32_t SMBHOST = (1U << 6);  ///< SMBus host header (Slave mode)
        constexpr uint32_t SMBDEFAULT = (1U << 5);  ///< SMBus device default address (Slave mode)
        constexpr uint32_t GENCALL = (1U << 4);  ///< General call address (Slave mode)
        constexpr uint32_t TRA = (1U << 2);  ///< Transmitter/receiver
        constexpr uint32_t BUSY = (1U << 1);  ///< Bus busy
        constexpr uint32_t MSL = (1U << 0);  ///< Master/slave
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t F_S = (1U << 15);  ///< I2C master mode selection
        constexpr uint32_t DUTY = (1U << 14);  ///< Fast mode duty cycle
        constexpr uint32_t CCR = (12 << 0);  ///< Clock control register in Fast/Standard mode (Master mode)
    }

    /// TRISE Register bits
    namespace trise_bits {
        constexpr uint32_t TRISE = (6 << 0);  ///< Maximum rise time in Fast/Standard mode (Master mode)
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0000h)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x40002400;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t FCR;  ///< Offset: 0x04 - frame control register
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t CLR;  ///< Offset: 0x0C - clear register
        volatile uint32_t RAM_COM0;  ///< Offset: 0x14 - display memory
        volatile uint32_t RAM_COM1;  ///< Offset: 0x1C - display memory
        volatile uint32_t RAM_COM2;  ///< Offset: 0x24 - display memory
        volatile uint32_t RAM_COM3;  ///< Offset: 0x2C - display memory
        volatile uint32_t RAM_COM4;  ///< Offset: 0x34 - display memory
        volatile uint32_t RAM_COM5;  ///< Offset: 0x3C - display memory
        volatile uint32_t RAM_COM6;  ///< Offset: 0x44 - display memory
        volatile uint32_t RAM_COM7;  ///< Offset: 0x4C - display memory
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t MUX_SEG = (1U << 7);  ///< Mux segment enable
        constexpr uint32_t BIAS = (2 << 5);  ///< Bias selector
        constexpr uint32_t DUTY = (3 << 2);  ///< Duty selection
        constexpr uint32_t VSEL = (1U << 1);  ///< Voltage source selection
        constexpr uint32_t LCDEN = (1U << 0);  ///< LCD controller enable
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t PS = (4 << 22);  ///< PS 16-bit prescaler
        constexpr uint32_t DIV = (4 << 18);  ///< DIV clock divider
        constexpr uint32_t BLINK = (2 << 16);  ///< Blink mode selection
        constexpr uint32_t BLINKF = (3 << 13);  ///< Blink frequency selection
        constexpr uint32_t CC = (3 << 10);  ///< Contrast control
        constexpr uint32_t DEAD = (3 << 7);  ///< Dead time duration
        constexpr uint32_t PON = (3 << 4);  ///< Pulse ON duration
        constexpr uint32_t UDDIE = (1U << 3);  ///< Update display done interrupt enable
        constexpr uint32_t SOFIE = (1U << 1);  ///< Start of frame interrupt enable
        constexpr uint32_t HD = (1U << 0);  ///< High drive enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t FCRSF = (1U << 5);  ///< LCD Frame Control Register Synchronization flag
        constexpr uint32_t RDY = (1U << 4);  ///< Ready flag
        constexpr uint32_t UDD = (1U << 3);  ///< Update Display Done
        constexpr uint32_t UDR = (1U << 2);  ///< Update display request
        constexpr uint32_t SOF = (1U << 1);  ///< Start of frame flag
        constexpr uint32_t ENS = (1U << 0);  ///< LCD enabled status
    }

    /// CLR Register bits
    namespace clr_bits {
        constexpr uint32_t UDDC = (1U << 3);  ///< Update display done clear
        constexpr uint32_t SOFC = (1U << 1);  ///< Start of frame flag clear
    }

    /// RAM_COM0 Register bits
    namespace ram_com0_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM1 Register bits
    namespace ram_com1_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM2 Register bits
    namespace ram_com2_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM3 Register bits
    namespace ram_com3_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM4 Register bits
    namespace ram_com4_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM5 Register bits
    namespace ram_com5_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM6 Register bits
    namespace ram_com6_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

    /// RAM_COM7 Register bits
    namespace ram_com7_bits {
        constexpr uint32_t S31 = (1U << 31);  ///< S31
        constexpr uint32_t S30 = (1U << 30);  ///< S30
        constexpr uint32_t S29 = (1U << 29);  ///< S29
        constexpr uint32_t S28 = (1U << 28);  ///< S28
        constexpr uint32_t S27 = (1U << 27);  ///< S27
        constexpr uint32_t S26 = (1U << 26);  ///< S26
        constexpr uint32_t S25 = (1U << 25);  ///< S25
        constexpr uint32_t S24 = (1U << 24);  ///< S24
        constexpr uint32_t S23 = (1U << 23);  ///< S23
        constexpr uint32_t S22 = (1U << 22);  ///< S22
        constexpr uint32_t S21 = (1U << 21);  ///< S21
        constexpr uint32_t S20 = (1U << 20);  ///< S20
        constexpr uint32_t S19 = (1U << 19);  ///< S19
        constexpr uint32_t S18 = (1U << 18);  ///< S18
        constexpr uint32_t S17 = (1U << 17);  ///< S17
        constexpr uint32_t S16 = (1U << 16);  ///< S16
        constexpr uint32_t S15 = (1U << 15);  ///< S15
        constexpr uint32_t S14 = (1U << 14);  ///< S14
        constexpr uint32_t S13 = (1U << 13);  ///< S13
        constexpr uint32_t S12 = (1U << 12);  ///< S12
        constexpr uint32_t S11 = (1U << 11);  ///< S11
        constexpr uint32_t S10 = (1U << 10);  ///< S10
        constexpr uint32_t S09 = (1U << 9);  ///< S09
        constexpr uint32_t S08 = (1U << 8);  ///< S08
        constexpr uint32_t S07 = (1U << 7);  ///< S07
        constexpr uint32_t S06 = (1U << 6);  ///< S06
        constexpr uint32_t S05 = (1U << 5);  ///< S05
        constexpr uint32_t S04 = (1U << 4);  ///< S04
        constexpr uint32_t S03 = (1U << 3);  ///< S03
        constexpr uint32_t S02 = (1U << 2);  ///< S02
        constexpr uint32_t S01 = (1U << 1);  ///< S01
        constexpr uint32_t S00 = (1U << 0);  ///< S00
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - power control register
        volatile uint32_t CSR;  ///< Offset: 0x04 - power control/status register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t LPRUN = (1U << 14);  ///< Low power run mode
        constexpr uint32_t VOS = (2 << 11);  ///< Voltage scaling range selection
        constexpr uint32_t FWU = (1U << 10);  ///< Fast wakeup
        constexpr uint32_t ULP = (1U << 9);  ///< Ultralow power mode
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t PLS = (3 << 5);  ///< PVD level selection
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t CSBF = (1U << 3);  ///< Clear standby flag
        constexpr uint32_t CWUF = (1U << 2);  ///< Clear wakeup flag
        constexpr uint32_t PDDS = (1U << 1);  ///< Power down deepsleep
        constexpr uint32_t LPSDSR = (1U << 0);  ///< Low-power deep sleep
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t EWUP3 = (1U << 10);  ///< Enable WKUP pin 3
        constexpr uint32_t EWUP2 = (1U << 9);  ///< Enable WKUP pin 2
        constexpr uint32_t EWUP1 = (1U << 8);  ///< Enable WKUP pin 1
        constexpr uint32_t REGLPF = (1U << 5);  ///< Regulator LP flag
        constexpr uint32_t VOSF = (1U << 4);  ///< Voltage Scaling select flag
        constexpr uint32_t VREFINTRDYF = (1U << 3);  ///< Internal voltage reference (VREFINT) ready flag
        constexpr uint32_t PVDO = (1U << 2);  ///< PVD output
        constexpr uint32_t SBF = (1U << 1);  ///< Standby flag
        constexpr uint32_t WUF = (1U << 0);  ///< Wakeup flag
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40023800;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t CIR;  ///< Offset: 0x0C - Clock interrupt register
        volatile uint32_t AHBRSTR;  ///< Offset: 0x10 - AHB peripheral reset register
        volatile uint32_t APB2RSTR;  ///< Offset: 0x14 - APB2 peripheral reset register
        volatile uint32_t APB1RSTR;  ///< Offset: 0x18 - APB1 peripheral reset register
        volatile uint32_t AHBENR;  ///< Offset: 0x1C - AHB peripheral clock enable register
        volatile uint32_t APB2ENR;  ///< Offset: 0x20 - APB2 peripheral clock enable register
        volatile uint32_t APB1ENR;  ///< Offset: 0x24 - APB1 peripheral clock enable register
        volatile uint32_t AHBLPENR;  ///< Offset: 0x28 - AHB peripheral clock enable in low power mode register
        volatile uint32_t APB2LPENR;  ///< Offset: 0x2C - APB2 peripheral clock enable in low power mode register
        volatile uint32_t APB1LPENR;  ///< Offset: 0x30 - APB1 peripheral clock enable in low power mode register
        volatile uint32_t CSR;  ///< Offset: 0x34 - Control/status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RTCPRE1 = (1U << 30);  ///< TC/LCD prescaler
        constexpr uint32_t RTCPRE0 = (1U << 29);  ///< RTCPRE0
        constexpr uint32_t CSSON = (1U << 28);  ///< Clock security system enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE clock bypass
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t MSIRDY = (1U << 9);  ///< MSI clock ready flag
        constexpr uint32_t MSION = (1U << 8);  ///< MSI clock enable
        constexpr uint32_t HSIRDY = (1U << 1);  ///< Internal high-speed clock ready flag
        constexpr uint32_t HSION = (1U << 0);  ///< Internal high-speed clock enable
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t MSITRIM = (8 << 24);  ///< MSI clock trimming
        constexpr uint32_t MSICAL = (8 << 16);  ///< MSI clock calibration
        constexpr uint32_t MSIRANGE = (3 << 13);  ///< MSI clock ranges
        constexpr uint32_t HSITRIM = (5 << 8);  ///< High speed internal clock trimming
        constexpr uint32_t HSICAL = (8 << 0);  ///< nternal high speed clock calibration
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (3 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (3 << 24);  ///< Microcontroller clock output selection
        constexpr uint32_t PLLDIV = (2 << 22);  ///< PLL output division
        constexpr uint32_t PLLMUL = (4 << 18);  ///< PLL multiplication factor
        constexpr uint32_t PLLSRC = (1U << 16);  ///< PLL entry clock source
        constexpr uint32_t PPRE2 = (3 << 11);  ///< APB high-speed prescaler (APB2)
        constexpr uint32_t PPRE1 = (3 << 8);  ///< APB low-speed prescaler (APB1)
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler
        constexpr uint32_t SWS = (2 << 2);  ///< System clock switch status
        constexpr uint32_t SW = (2 << 0);  ///< System clock switch
    }

    /// CIR Register bits
    namespace cir_bits {
        constexpr uint32_t CSSC = (1U << 23);  ///< Clock security system interrupt clear
        constexpr uint32_t MSIRDYC = (1U << 21);  ///< MSI ready interrupt clear
        constexpr uint32_t PLLRDYC = (1U << 20);  ///< PLL ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 19);  ///< HSE ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 18);  ///< HSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 17);  ///< LSE ready interrupt clear
        constexpr uint32_t LSIRDYC = (1U << 16);  ///< LSI ready interrupt clear
        constexpr uint32_t MSIRDYIE = (1U << 13);  ///< MSI ready interrupt enable
        constexpr uint32_t PLLRDYIE = (1U << 12);  ///< PLL ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 11);  ///< HSE ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 10);  ///< HSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 9);  ///< LSE ready interrupt enable
        constexpr uint32_t LSIRDYIE = (1U << 8);  ///< LSI ready interrupt enable
        constexpr uint32_t CSSF = (1U << 7);  ///< Clock security system interrupt flag
        constexpr uint32_t MSIRDYF = (1U << 5);  ///< MSI ready interrupt flag
        constexpr uint32_t PLLRDYF = (1U << 4);  ///< PLL ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 3);  ///< HSE ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 2);  ///< HSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
    }

    /// AHBRSTR Register bits
    namespace ahbrstr_bits {
        constexpr uint32_t DMARST = (1U << 24);  ///< DMA1 reset
        constexpr uint32_t FLITFRST = (1U << 15);  ///< FLITF reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
        constexpr uint32_t GPIODRST = (1U << 3);  ///< IO port D reset
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< IO port C reset
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< IO port B reset
        constexpr uint32_t GPIOARST = (1U << 0);  ///< IO port A reset
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1RST
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1RST
        constexpr uint32_t ADC1RST = (1U << 9);  ///< ADC1RST
        constexpr uint32_t TM11RST = (1U << 4);  ///< TM11RST
        constexpr uint32_t TM10RST = (1U << 3);  ///< TM10RST
        constexpr uint32_t TIM9RST = (1U << 2);  ///< TIM9RST
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFGRST
    }

    /// APB1RSTR Register bits
    namespace apb1rstr_bits {
        constexpr uint32_t COMPRST = (1U << 31);  ///< COMP interface reset
        constexpr uint32_t DACRST = (1U << 29);  ///< DAC interface reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t USBRST = (1U << 23);  ///< USB reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C 2 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C 1 reset
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART 3 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART 2 reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI 2 reset
        constexpr uint32_t WWDRST = (1U << 11);  ///< Window watchdog reset
        constexpr uint32_t LCDRST = (1U << 9);  ///< LCD reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< Timer 7 reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< Timer 6reset
        constexpr uint32_t TIM4RST = (1U << 2);  ///< Timer 4 reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< Timer 3 reset
        constexpr uint32_t TIM2RST = (1U << 0);  ///< Timer 2 reset
    }

    /// AHBENR Register bits
    namespace ahbenr_bits {
        constexpr uint32_t DMAEN = (1U << 24);  ///< DMA1 clock enable
        constexpr uint32_t FLITFEN = (1U << 15);  ///< FLITF clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
        constexpr uint32_t GPIOPDEN = (1U << 3);  ///< IO port D clock enable
        constexpr uint32_t GPIOPCEN = (1U << 2);  ///< IO port C clock enable
        constexpr uint32_t GPIOPBEN = (1U << 1);  ///< IO port B clock enable
        constexpr uint32_t GPIOPAEN = (1U << 0);  ///< IO port A clock enable
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI 1 clock enable
        constexpr uint32_t ADC1EN = (1U << 9);  ///< ADC1 interface clock enable
        constexpr uint32_t TIM11EN = (1U << 4);  ///< TIM11 timer clock enable
        constexpr uint32_t TIM10EN = (1U << 3);  ///< TIM10 timer clock enable
        constexpr uint32_t TIM9EN = (1U << 2);  ///< TIM9 timer clock enable
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< System configuration controller clock enable
    }

    /// APB1ENR Register bits
    namespace apb1enr_bits {
        constexpr uint32_t COMPEN = (1U << 31);  ///< COMP interface clock enable
        constexpr uint32_t DACEN = (1U << 29);  ///< DAC interface clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t USBEN = (1U << 23);  ///< USB clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C 2 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C 1 clock enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART 3 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART 2 clock enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI 2 clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable
        constexpr uint32_t LCDEN = (1U << 9);  ///< LCD clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< Timer 7 clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< Timer 6 clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< Timer 4 clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< Timer 3 clock enable
        constexpr uint32_t TIM2EN = (1U << 0);  ///< Timer 2 clock enable
    }

    /// AHBLPENR Register bits
    namespace ahblpenr_bits {
        constexpr uint32_t DMALPEN = (1U << 24);  ///< DMA1 clock enable during Sleep mode
        constexpr uint32_t SRAMLPEN = (1U << 16);  ///< SRAM clock enable during Sleep mode
        constexpr uint32_t FLITFLPEN = (1U << 15);  ///< FLITF clock enable during Sleep mode
        constexpr uint32_t CRCLPEN = (1U << 12);  ///< CRC clock enable during Sleep mode
        constexpr uint32_t GPIODLPEN = (1U << 3);  ///< IO port D clock enable during Sleep mode
        constexpr uint32_t GPIOCLPEN = (1U << 2);  ///< IO port C clock enable during Sleep mode
        constexpr uint32_t GPIOBLPEN = (1U << 1);  ///< IO port B clock enable during Sleep mode
        constexpr uint32_t GPIOALPEN = (1U << 0);  ///< IO port A clock enable during Sleep mode
    }

    /// APB2LPENR Register bits
    namespace apb2lpenr_bits {
        constexpr uint32_t USART1LPEN = (1U << 14);  ///< USART1 clock enable during Sleep mode
        constexpr uint32_t SPI1LPEN = (1U << 12);  ///< SPI 1 clock enable during Sleep mode
        constexpr uint32_t ADC1LPEN = (1U << 9);  ///< ADC1 interface clock enable during Sleep mode
        constexpr uint32_t TIM11LPEN = (1U << 4);  ///< TIM11 timer clock enable during Sleep mode
        constexpr uint32_t TIM10LPEN = (1U << 3);  ///< TIM10 timer clock enable during Sleep mode
        constexpr uint32_t TIM9LPEN = (1U << 2);  ///< TIM9 timer clock enable during Sleep mode
        constexpr uint32_t SYSCFGLPEN = (1U << 0);  ///< System configuration controller clock enable during Sleep mode
    }

    /// APB1LPENR Register bits
    namespace apb1lpenr_bits {
        constexpr uint32_t COMPLPEN = (1U << 31);  ///< COMP interface clock enable during Sleep mode
        constexpr uint32_t DACLPEN = (1U << 29);  ///< DAC interface clock enable during Sleep mode
        constexpr uint32_t PWRLPEN = (1U << 28);  ///< Power interface clock enable during Sleep mode
        constexpr uint32_t USBLPEN = (1U << 23);  ///< USB clock enable during Sleep mode
        constexpr uint32_t I2C2LPEN = (1U << 22);  ///< I2C 2 clock enable during Sleep mode
        constexpr uint32_t I2C1LPEN = (1U << 21);  ///< I2C 1 clock enable during Sleep mode
        constexpr uint32_t USART3LPEN = (1U << 18);  ///< USART 3 clock enable during Sleep mode
        constexpr uint32_t USART2LPEN = (1U << 17);  ///< USART 2 clock enable during Sleep mode
        constexpr uint32_t SPI2LPEN = (1U << 14);  ///< SPI 2 clock enable during Sleep mode
        constexpr uint32_t WWDGLPEN = (1U << 11);  ///< Window watchdog clock enable during Sleep mode
        constexpr uint32_t LCDLPEN = (1U << 9);  ///< LCD clock enable during Sleep mode
        constexpr uint32_t TIM7LPEN = (1U << 5);  ///< Timer 7 clock enable during Sleep mode
        constexpr uint32_t TIM6LPEN = (1U << 4);  ///< Timer 6 clock enable during Sleep mode
        constexpr uint32_t TIM4LPEN = (1U << 2);  ///< Timer 4 clock enable during Sleep mode
        constexpr uint32_t TIM3LPEN = (1U << 1);  ///< Timer 3 clock enable during Sleep mode
        constexpr uint32_t TIM2LPEN = (1U << 0);  ///< Timer 2 clock enable during Sleep mode
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LPWRSTF = (1U << 31);  ///< Low-power reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent watchdog reset flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t PORRSTF = (1U << 27);  ///< POR/PDR reset flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< PIN reset flag
        constexpr uint32_t RMVF = (1U << 24);  ///< Remove reset flag
        constexpr uint32_t RTCRST = (1U << 23);  ///< RTC software reset
        constexpr uint32_t RTCEN = (1U << 22);  ///< RTC clock enable
        constexpr uint32_t RTCSEL = (2 << 16);  ///< RTC and LCD clock source selection
        constexpr uint32_t LSEBYP = (1U << 10);  ///< External low-speed oscillator bypass
        constexpr uint32_t LSERDY = (1U << 9);  ///< External low-speed oscillator ready
        constexpr uint32_t LSEON = (1U << 8);  ///< External low-speed oscillator enable
        constexpr uint32_t LSIRDY = (1U << 1);  ///< Internal low-speed oscillator ready
        constexpr uint32_t LSION = (1U << 0);  ///< Internal low-speed oscillator enable
    }

}

// ============================================================================
// RI Peripheral
// ============================================================================

namespace ri {
    /// Base addresses
    constexpr uint32_t RI_BASE = 0x40007C04;

    /// RI Register structure
    struct Registers {
        volatile uint32_t ICR;  ///< Offset: 0x04 - RI input capture register
        volatile uint32_t ASCR1;  ///< Offset: 0x08 - RI analog switches control register 1
        volatile uint32_t ASCR2;  ///< Offset: 0x0C - RI analog switches control register 2
        volatile uint32_t HYSCR1;  ///< Offset: 0x10 - RI hysteresis control register 1
        volatile uint32_t HYSCR2;  ///< Offset: 0x14 - RI hysteresis control register 2
        volatile uint32_t HYSCR3;  ///< Offset: 0x18 - RI hysteresis control register 3
        volatile uint32_t HYSCR4;  ///< Offset: 0x1C - Hysteresis control register
    };

    /// Peripheral instances
    inline Registers* RI = reinterpret_cast<Registers*>(RI_BASE);

    // Bit definitions
    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t IC4 = (1U << 21);  ///< IC4
        constexpr uint32_t IC3 = (1U << 20);  ///< IC3
        constexpr uint32_t IC2 = (1U << 19);  ///< IC2
        constexpr uint32_t IC1 = (1U << 18);  ///< IC1
        constexpr uint32_t TIM = (2 << 16);  ///< Timer select bits
        constexpr uint32_t IC4IOS = (4 << 12);  ///< Input capture 4 select bits
        constexpr uint32_t IC3IOS = (4 << 8);  ///< Input capture 3 select bits
        constexpr uint32_t IC2IOS = (4 << 4);  ///< Input capture 2 select bits
        constexpr uint32_t IC1IOS = (4 << 0);  ///< Input capture 1 select bits
    }

    /// ASCR1 Register bits
    namespace ascr1_bits {
        constexpr uint32_t SCM = (1U << 31);  ///< Switch control mode
        constexpr uint32_t CH30GR11_4 = (1U << 30);  ///< Analog switch control
        constexpr uint32_t CH29GR11_3 = (1U << 29);  ///< Analog switch control
        constexpr uint32_t CH28GR11_2 = (1U << 28);  ///< Analog switch control
        constexpr uint32_t CH27GR11_1 = (1U << 27);  ///< Analog switch control
        constexpr uint32_t VCOMP = (1U << 26);  ///< ADC analog switch selection for internal node to comparator 1
        constexpr uint32_t CH25 = (1U << 25);  ///< Analog I/O switch control of channel CH25
        constexpr uint32_t CH24 = (1U << 24);  ///< Analog I/O switch control of channel CH24
        constexpr uint32_t CH23 = (1U << 23);  ///< Analog I/O switch control of channel CH23
        constexpr uint32_t CH22 = (1U << 22);  ///< Analog I/O switch control of channel CH22
        constexpr uint32_t CH21GR7_4 = (1U << 21);  ///< Analog switch control
        constexpr uint32_t CH20GR7_3 = (1U << 20);  ///< Analog switch control
        constexpr uint32_t CH19GR7_2 = (1U << 19);  ///< Analog switch control
        constexpr uint32_t CH18GR7_1 = (1U << 18);  ///< Analog switch control
        constexpr uint32_t CH31GR7_1 = (1U << 16);  ///< Analog switch control
        constexpr uint32_t CH15GR9_2 = (1U << 15);  ///< Analog switch control
        constexpr uint32_t CH14GR9_1 = (1U << 14);  ///< Analog switch control
        constexpr uint32_t CH13GR8_4 = (1U << 13);  ///< Analog switch control
        constexpr uint32_t CH12GR8_3 = (1U << 12);  ///< Analog switch control
        constexpr uint32_t CH11GR8_2 = (1U << 11);  ///< Analog switch control
        constexpr uint32_t CH10GR8_1 = (1U << 10);  ///< Analog switch control
        constexpr uint32_t CH9GR3_2 = (1U << 9);  ///< Analog switch control
        constexpr uint32_t CH8GR3_1 = (1U << 8);  ///< Analog switch control
        constexpr uint32_t CH7GR2_2 = (1U << 7);  ///< Analog switch control
        constexpr uint32_t CH6GR2_1 = (1U << 6);  ///< Analog switch control
        constexpr uint32_t COMP1_SW1 = (1U << 5);  ///< Comparator 1 analog switch
        constexpr uint32_t CH31GR11_5 = (1U << 4);  ///< Analog switch control
        constexpr uint32_t CH3GR1_4 = (1U << 3);  ///< Analog switch control
        constexpr uint32_t CH2GR1_3 = (1U << 2);  ///< Analog switch control
        constexpr uint32_t CH1GR1_2 = (1U << 1);  ///< Analog switch control
        constexpr uint32_t CH0GR1_1 = (1U << 0);  ///< Analog switch control
    }

    /// ASCR2 Register bits
    namespace ascr2_bits {
        constexpr uint32_t GR5_4 = (1U << 29);  ///< GR5_4 analog switch control
        constexpr uint32_t GR6_4 = (1U << 28);  ///< GR6_4 analog switch control
        constexpr uint32_t GR6_3 = (1U << 27);  ///< GR6_3 analog switch control
        constexpr uint32_t GR7_7 = (1U << 26);  ///< GR7_7 analog switch control
        constexpr uint32_t GR7_6 = (1U << 25);  ///< GR7_6 analog switch control
        constexpr uint32_t GR7_5 = (1U << 24);  ///< GR7_5 analog switch control
        constexpr uint32_t GR2_5 = (1U << 23);  ///< GR2_5 analog switch control
        constexpr uint32_t GR2_4 = (1U << 22);  ///< GR2_4 analog switch control
        constexpr uint32_t GR2_3 = (1U << 21);  ///< GR2_3 analog switch control
        constexpr uint32_t GR9_4 = (1U << 20);  ///< GR9_4 analog switch control
        constexpr uint32_t GR9_3 = (1U << 19);  ///< GR9_3 analog switch control
        constexpr uint32_t GR3_5 = (1U << 18);  ///< GR3_5 analog switch control
        constexpr uint32_t GR3_4 = (1U << 17);  ///< GR3_4 analog switch control
        constexpr uint32_t GR3_3 = (1U << 16);  ///< GR3_3 analog switch control
        constexpr uint32_t GR4_3 = (1U << 11);  ///< GR4_3 analog switch control
        constexpr uint32_t GR4_2 = (1U << 10);  ///< GR4_2 analog switch control
        constexpr uint32_t GR4_1 = (1U << 9);  ///< GR4_1 analog switch control
        constexpr uint32_t GR5_3 = (1U << 8);  ///< GR5_3 analog switch control
        constexpr uint32_t GR5_2 = (1U << 7);  ///< GR5_2 analog switch control
        constexpr uint32_t GR5_1 = (1U << 6);  ///< GR5_1 analog switch control
        constexpr uint32_t GR6_2 = (1U << 5);  ///< GR6_2 analog switch control
        constexpr uint32_t GR6_1 = (1U << 4);  ///< GR6_1 analog switch control
        constexpr uint32_t GR10_4 = (1U << 3);  ///< GR10_4 analog switch control
        constexpr uint32_t GR10_3 = (1U << 2);  ///< GR10_3 analog switch control
        constexpr uint32_t GR10_2 = (1U << 1);  ///< GR10_2 analog switch control
        constexpr uint32_t GR10_1 = (1U << 0);  ///< GR10_1 analog switch control
    }

    /// HYSCR1 Register bits
    namespace hyscr1_bits {
        constexpr uint32_t PB = (16 << 16);  ///< Port B hysteresis control on/off
        constexpr uint32_t PA = (16 << 0);  ///< Port A hysteresis control on/off
    }

    /// HYSCR2 Register bits
    namespace hyscr2_bits {
        constexpr uint32_t PD = (16 << 16);  ///< Port D hysteresis control on/off
        constexpr uint32_t PC = (16 << 0);  ///< Port C hysteresis control on/off
    }

    /// HYSCR3 Register bits
    namespace hyscr3_bits {
        constexpr uint32_t PF = (16 << 16);  ///< Port F hysteresis control on/off
        constexpr uint32_t PE = (16 << 0);  ///< Port E hysteresis control on/off
    }

    /// HYSCR4 Register bits
    namespace hyscr4_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Port G hysteresis control on/off
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t CR;  ///< Offset: 0x08 - control register
        volatile uint32_t ISR;  ///< Offset: 0x0C - initialization and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CALIBR;  ///< Offset: 0x18 - calibration register
        volatile uint32_t ALRMAR;  ///< Offset: 0x1C - alarm A register
        volatile uint32_t ALRMBR;  ///< Offset: 0x20 - alarm B register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t SSR;  ///< Offset: 0x28 - sub second register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - TSTR
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t CALR;  ///< Offset: 0x3C - calibration register
        volatile uint32_t TAFCR;  ///< Offset: 0x40 - tamper and alternate function configuration register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x48 - alarm B sub second register
        volatile uint32_t BK0R;  ///< Offset: 0x9C - BK0R
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection
        constexpr uint32_t BKP = (1U << 18);  ///< Backup
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour
        constexpr uint32_t TSIE = (1U << 15);  ///< Time-stamp interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wakeup timer interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t TSE = (1U << 11);  ///< Time stamp enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wakeup timer enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t DCE = (1U << 7);  ///< Coarse digital calibration enable
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers
        constexpr uint32_t REFCKON = (1U << 4);  ///< Reference clock detection enable
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Time-stamp event active edge
        constexpr uint32_t WCKSEL = (3 << 0);  ///< WCKSEL
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
        constexpr uint32_t TAMP3F = (1U << 15);  ///< TAMPER3 detection flag
        constexpr uint32_t TAMP2F = (1U << 14);  ///< TAMPER2 detection flag
        constexpr uint32_t TAMP1F = (1U << 13);  ///< Tamper detection flag
        constexpr uint32_t TSOVF = (1U << 12);  ///< Timestamp overflow flag
        constexpr uint32_t TSF = (1U << 11);  ///< Timestamp flag
        constexpr uint32_t WUTF = (1U << 10);  ///< Wakeup timer flag
        constexpr uint32_t ALRBF = (1U << 9);  ///< Alarm B flag
        constexpr uint32_t ALRAF = (1U << 8);  ///< Alarm A flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
    }

    /// CALIBR Register bits
    namespace calibr_bits {
        constexpr uint32_t DCS = (1U << 7);  ///< Digital calibration sign
        constexpr uint32_t DC = (5 << 0);  ///< Digital calibration
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format.
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format.
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< ADD1S
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< CALW16
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t ALARMOUTTYPE = (1U << 18);  ///< AFO_ALARM output type
        constexpr uint32_t TAMPPUDIS = (1U << 15);  ///< TAMPER pull-up disable
        constexpr uint32_t TAMPPRCH = (2 << 13);  ///< Tamper precharge duration
        constexpr uint32_t TAMPFLT = (2 << 11);  ///< Tamper filter count
        constexpr uint32_t TAMPFREQ = (3 << 8);  ///< Tamper sampling frequency
        constexpr uint32_t TAMPTS = (1U << 7);  ///< Activate timestamp on tamper detection event
        constexpr uint32_t TAMP3TRG = (1U << 6);  ///< TAMPER1 mapping
        constexpr uint32_t TAMP3E = (1U << 5);  ///< TIMESTAMP mapping
        constexpr uint32_t TAMP2TRG = (1U << 4);  ///< Active level for tamper 2
        constexpr uint32_t TAMP2E = (1U << 3);  ///< Tamper 2 detection enable
        constexpr uint32_t TAMPIE = (1U << 2);  ///< Tamper interrupt enable
        constexpr uint32_t TAMP1ETRG = (1U << 1);  ///< Active level for tamper 1
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper 1 detection enable
    }

    /// TAFCR Register bits
    namespace tafcr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
        volatile uint32_t I2SCFGR;  ///< Offset: 0x1C - I2S configuration register
        volatile uint32_t I2SPR;  ///< Offset: 0x20 - I2S prescaler register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t UDR = (1U << 3);  ///< Underrun flag
        constexpr uint32_t CHSIDE = (1U << 2);  ///< Channel side
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

    /// I2SCFGR Register bits
    namespace i2scfgr_bits {
        constexpr uint32_t I2SMOD = (1U << 11);  ///< I2S mode selection
        constexpr uint32_t I2SE = (1U << 10);  ///< I2S Enable
        constexpr uint32_t I2SCFG = (2 << 8);  ///< I2S configuration mode
        constexpr uint32_t PCMSYNC = (1U << 7);  ///< PCM frame synchronization
        constexpr uint32_t I2SSTD = (2 << 4);  ///< I2S standard selection
        constexpr uint32_t CKPOL = (1U << 3);  ///< Steady state clock polarity
        constexpr uint32_t DATLEN = (2 << 1);  ///< Data length to be transferred
        constexpr uint32_t CHLEN = (1U << 0);  ///< Channel length (number of bits per audio channel)
    }

    /// I2SPR Register bits
    namespace i2spr_bits {
        constexpr uint32_t MCKOE = (1U << 9);  ///< Master clock output enable
        constexpr uint32_t ODD = (1U << 8);  ///< Odd factor for the prescaler
        constexpr uint32_t I2SDIV = (8 << 0);  ///< I2S Linear prescaler
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t MEMRMP;  ///< Offset: 0x00 - memory remap register
        volatile uint32_t PMC;  ///< Offset: 0x04 - peripheral mode configuration register
        volatile uint32_t EXTICR1;  ///< Offset: 0x08 - external interrupt configuration register 1
        volatile uint32_t EXTICR2;  ///< Offset: 0x0C - external interrupt configuration register 2
        volatile uint32_t EXTICR3;  ///< Offset: 0x10 - external interrupt configuration register 3
        volatile uint32_t EXTICR4;  ///< Offset: 0x14 - external interrupt configuration register 4
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// MEMRMP Register bits
    namespace memrmp_bits {
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< MEM_MODE
        constexpr uint32_t BOOT_MODE = (2 << 8);  ///< BOOT_MODE
    }

    /// PMC Register bits
    namespace pmc_bits {
        constexpr uint32_t USB_PU = (1U << 0);  ///< USB pull-up
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI3 = (4 << 12);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI2 = (4 << 8);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI1 = (4 << 4);  ///< EXTI x configuration (x = 0 to 3)
        constexpr uint32_t EXTI0 = (4 << 0);  ///< EXTI x configuration (x = 0 to 3)
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI7 = (4 << 12);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI6 = (4 << 8);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI5 = (4 << 4);  ///< EXTI x configuration (x = 4 to 7)
        constexpr uint32_t EXTI4 = (4 << 0);  ///< EXTI x configuration (x = 4 to 7)
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI11 = (4 << 12);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI10 = (4 << 8);  ///< EXTI10
        constexpr uint32_t EXTI9 = (4 << 4);  ///< EXTI x configuration (x = 8 to 11)
        constexpr uint32_t EXTI8 = (4 << 0);  ///< EXTI x configuration (x = 8 to 11)
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI15 = (4 << 12);  ///< EXTI x configuration (x = 12 to 15)
        constexpr uint32_t EXTI14 = (4 << 8);  ///< EXTI14
        constexpr uint32_t EXTI13 = (4 << 4);  ///< EXTI13
        constexpr uint32_t EXTI12 = (4 << 0);  ///< EXTI12
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM10_BASE = 0x40010C00;
    constexpr uint32_t TIM11_BASE = 0x40011000;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t TIM9_BASE = 0x40010800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t DIER;  ///< Offset: 0x0C - Interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x10 - status register
        volatile uint32_t EGR;  ///< Offset: 0x14 - event generation register
        volatile uint32_t CCMR1_Output;  ///< Offset: 0x18 - capture/compare mode register
        volatile uint32_t CCMR1_Input;  ///< Offset: 0x18 - capture/compare mode register 1 (input mode)
        volatile uint32_t CCER;  ///< Offset: 0x20 - capture/compare enable register
        volatile uint32_t CNT;  ///< Offset: 0x24 - counter
        volatile uint32_t PSC;  ///< Offset: 0x28 - prescaler
        volatile uint32_t ARR;  ///< Offset: 0x2C - auto-reload register
        volatile uint32_t CCR1;  ///< Offset: 0x34 - capture/compare register 1
        volatile uint32_t OR;  ///< Offset: 0x50 - option register
    };

    /// Peripheral instances
    inline Registers* TIM10 = reinterpret_cast<Registers*>(TIM10_BASE);
    inline Registers* TIM11 = reinterpret_cast<Registers*>(TIM11_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* TIM9 = reinterpret_cast<Registers*>(TIM9_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t CKD = (2 << 8);  ///< Clock division
        constexpr uint32_t ARPE = (1U << 7);  ///< Auto-reload preload enable
        constexpr uint32_t URS = (1U << 2);  ///< Update request source
        constexpr uint32_t UDIS = (1U << 1);  ///< Update disable
        constexpr uint32_t CEN = (1U << 0);  ///< Counter enable
    }

    /// DIER Register bits
    namespace dier_bits {
        constexpr uint32_t CC1IE = (1U << 1);  ///< Capture/Compare 1 interrupt enable
        constexpr uint32_t UIE = (1U << 0);  ///< Update interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CC1OF = (1U << 9);  ///< Capture/compare 1 overcapture flag
        constexpr uint32_t CC1IF = (1U << 1);  ///< Capture/Compare 1 interrupt flag
        constexpr uint32_t UIF = (1U << 0);  ///< Update interrupt flag
    }

    /// EGR Register bits
    namespace egr_bits {
        constexpr uint32_t CC1G = (1U << 1);  ///< Capture/Compare 1 generation
        constexpr uint32_t UG = (1U << 0);  ///< Update generation
    }

    /// CCMR1_Output Register bits
    namespace ccmr1_output_bits {
        constexpr uint32_t OC1M = (3 << 4);  ///< Output compare 1 mode
        constexpr uint32_t OC1PE = (1U << 3);  ///< Output compare 1 preload enable
        constexpr uint32_t OC1FE = (1U << 2);  ///< Output compare 1 fast enable
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCMR1_Input Register bits
    namespace ccmr1_input_bits {
        constexpr uint32_t IC1F = (4 << 4);  ///< Input capture 1 filter
        constexpr uint32_t ICPCS = (2 << 2);  ///< Input capture 1 prescaler
        constexpr uint32_t CC1S = (2 << 0);  ///< Capture/Compare 1 selection
    }

    /// CCER Register bits
    namespace ccer_bits {
        constexpr uint32_t CC1NP = (1U << 3);  ///< Capture/Compare 1 complementary output Polarity
        constexpr uint32_t CC1P = (1U << 1);  ///< Capture/Compare 1 output Polarity
        constexpr uint32_t CC1E = (1U << 0);  ///< Capture/Compare 1 output enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< TIM10 counter
    }

    /// PSC Register bits
    namespace psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< TIM9 prescaler
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto-reload value
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/Compare 1 value
    }

    /// OR Register bits
    namespace or_bits {
        constexpr uint32_t TI1_RMP = (2 << 0);  ///< TIM11 Input 1 remapping capability
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Status register
        volatile uint32_t DR;  ///< Offset: 0x04 - Data register
        volatile uint32_t BRR;  ///< Offset: 0x08 - Baud rate register
        volatile uint32_t CR1;  ///< Offset: 0x0C - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x10 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x14 - Control register 3
        volatile uint32_t GTPR;  ///< Offset: 0x18 - Guard time and prescaler register
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);

    // Bit definitions
    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t CTS = (1U << 9);  ///< CTS flag
        constexpr uint32_t LBD = (1U << 8);  ///< LIN break detection flag
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE line detected
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error
        constexpr uint32_t NF = (1U << 2);  ///< Noise detected flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing error
        constexpr uint32_t PE = (1U << 0);  ///< Parity error
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (9 << 0);  ///< Data value
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t DIV_Mantissa = (12 << 4);  ///< mantissa of USARTDIV
        constexpr uint32_t DIV_Fraction = (4 << 0);  ///< fraction of USARTDIV
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t OVER8 = (1U << 15);  ///< Oversampling mode
        constexpr uint32_t UE = (1U << 13);  ///< USART enable
        constexpr uint32_t M = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< TXE interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver wakeup
        constexpr uint32_t SBK = (1U << 0);  ///< Send break
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t LINEN = (1U << 14);  ///< LIN mode enable
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t CLKEN = (1U << 11);  ///< Clock enable
        constexpr uint32_t CPOL = (1U << 10);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 9);  ///< Clock phase
        constexpr uint32_t LBCL = (1U << 8);  ///< Last bit clock pulse
        constexpr uint32_t LBDIE = (1U << 6);  ///< LIN break detection interrupt enable
        constexpr uint32_t LBDL = (1U << 5);  ///< lin break detection length
        constexpr uint32_t ADD = (4 << 0);  ///< Address of the USART node
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t ONEBIT = (1U << 11);  ///< One sample bit method enable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t SCEN = (1U << 5);  ///< Smartcard mode enable
        constexpr uint32_t NACK = (1U << 4);  ///< Smartcard NACK enable
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t IRLP = (1U << 2);  ///< IrDA low-power
        constexpr uint32_t IREN = (1U << 1);  ///< IrDA mode enable
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// GTPR Register bits
    namespace gtpr_bits {
        constexpr uint32_t GT = (8 << 8);  ///< Guard time value
        constexpr uint32_t PSC = (8 << 0);  ///< Prescaler value
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x40005C00;
    constexpr uint32_t USB_SRAM_BASE = 0x40006000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t USB_EP0R;  ///< Offset: 0x00 - endpoint 0 register
        volatile uint32_t USB_EP1R;  ///< Offset: 0x04 - endpoint 1 register
        volatile uint32_t USB_EP2R;  ///< Offset: 0x08 - endpoint 2 register
        volatile uint32_t USB_EP3R;  ///< Offset: 0x0C - endpoint 3 register
        volatile uint32_t USB_EP4R;  ///< Offset: 0x10 - endpoint 4 register
        volatile uint32_t USB_EP5R;  ///< Offset: 0x14 - endpoint 5 register
        volatile uint32_t USB_EP6R;  ///< Offset: 0x18 - endpoint 6 register
        volatile uint32_t USB_EP7R;  ///< Offset: 0x1C - endpoint 7 register
        volatile uint32_t USB_CNTR;  ///< Offset: 0x40 - control register
        volatile uint32_t ISTR;  ///< Offset: 0x44 - interrupt status register
        volatile uint32_t FNR;  ///< Offset: 0x48 - frame number register
        volatile uint32_t DADDR;  ///< Offset: 0x4C - device address
        volatile uint32_t BTABLE;  ///< Offset: 0x50 - Buffer table address
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);
    inline Registers* USB_SRAM = reinterpret_cast<Registers*>(USB_SRAM_BASE);

    // Bit definitions
    /// USB_EP0R Register bits
    namespace usb_ep0r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP1R Register bits
    namespace usb_ep1r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP2R Register bits
    namespace usb_ep2r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP3R Register bits
    namespace usb_ep3r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP4R Register bits
    namespace usb_ep4r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP5R Register bits
    namespace usb_ep5r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP6R Register bits
    namespace usb_ep6r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_EP7R Register bits
    namespace usb_ep7r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// USB_CNTR Register bits
    namespace usb_cntr_bits {
        constexpr uint32_t FRES = (1U << 0);  ///< Force USB Reset
        constexpr uint32_t PDWN = (1U << 1);  ///< Power down
        constexpr uint32_t LPMODE = (1U << 2);  ///< Low-power mode
        constexpr uint32_t FSUSP = (1U << 3);  ///< Force suspend
        constexpr uint32_t RESUME = (1U << 4);  ///< Resume request
        constexpr uint32_t ESOFM = (1U << 8);  ///< Expected start of frame interrupt mask
        constexpr uint32_t SOFM = (1U << 9);  ///< Start of frame interrupt mask
        constexpr uint32_t RESETM = (1U << 10);  ///< USB reset interrupt mask
        constexpr uint32_t SUSPM = (1U << 11);  ///< Suspend mode interrupt mask
        constexpr uint32_t WKUPM = (1U << 12);  ///< Wakeup interrupt mask
        constexpr uint32_t ERRM = (1U << 13);  ///< Error interrupt mask
        constexpr uint32_t PMAOVRM = (1U << 14);  ///< Packet memory area over / underrun interrupt mask
        constexpr uint32_t CTRM = (1U << 15);  ///< Correct transfer interrupt mask
    }

    /// ISTR Register bits
    namespace istr_bits {
        constexpr uint32_t EP_ID = (4 << 0);  ///< Endpoint Identifier
        constexpr uint32_t DIR = (1U << 4);  ///< Direction of transaction
        constexpr uint32_t ESOF = (1U << 8);  ///< Expected start frame
        constexpr uint32_t SOF = (1U << 9);  ///< start of frame
        constexpr uint32_t RESET = (1U << 10);  ///< reset request
        constexpr uint32_t SUSP = (1U << 11);  ///< Suspend mode request
        constexpr uint32_t WKUP = (1U << 12);  ///< Wakeup
        constexpr uint32_t ERR = (1U << 13);  ///< Error
        constexpr uint32_t PMAOVR = (1U << 14);  ///< Packet memory area over / underrun
        constexpr uint32_t CTR = (1U << 15);  ///< Correct transfer
    }

    /// FNR Register bits
    namespace fnr_bits {
        constexpr uint32_t FN = (11 << 0);  ///< Frame number
        constexpr uint32_t LSOF = (2 << 11);  ///< Lost SOF
        constexpr uint32_t LCK = (1U << 13);  ///< Locked
        constexpr uint32_t RXDM = (1U << 14);  ///< Receive data - line status
        constexpr uint32_t RXDP = (1U << 15);  ///< Receive data + line status
    }

    /// DADDR Register bits
    namespace daddr_bits {
        constexpr uint32_t ADD = (7 << 0);  ///< Device address
        constexpr uint32_t EF = (1U << 7);  ///< Enable function
    }

    /// BTABLE Register bits
    namespace btable_bits {
        constexpr uint32_t BTABLE = (13 << 3);  ///< Buffer table
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E000;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ICTR;  ///< Offset: 0x04 - Interrupt Controller Type Register
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Software Triggered Interrupt Register
        volatile uint32_t ISER0;  ///< Offset: 0x100 - Interrupt Set-Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x104 - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x180 - Interrupt Clear-Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x184 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x200 - Interrupt Set-Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x204 - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x280 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x284 - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x300 - Interrupt Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x304 - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x400 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x404 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x408 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x40C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x410 - Interrupt Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x414 - Interrupt Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x418 - Interrupt Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x41C - Interrupt Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x420 - Interrupt Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x424 - Interrupt Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x428 - Interrupt Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x42C - Interrupt Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x430 - Interrupt Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x434 - Interrupt Priority Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// ICTR Register bits
    namespace ictr_bits {
        constexpr uint32_t INTLINESNUM = (4 << 0);  ///< Total number of interrupt lines in groups
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< interrupt to be triggered
    }

    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}


} // namespace alloy::generated::stm32l100

#endif // ALLOY_GENERATED_STM32L100_PERIPHERALS_HPP