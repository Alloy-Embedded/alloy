/// Auto-generated code for STM32L562
/// Generated by Alloy Code Generator
/// Source: st_stm32l562.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:47
#ifndef ALLOY_GENERATED_STM32L562_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32L562_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32l562 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_dcb = true;
    constexpr uint32_t num_dcb_instances = 1;
    constexpr bool has_dfsdm1 = true;
    constexpr uint32_t num_dfsdm1_instances = 1;
    constexpr bool has_sec = true;
    constexpr uint32_t num_sec_instances = 20;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 6;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 16;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 8;
    constexpr bool has_icache = true;
    constexpr uint32_t num_icache_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 4;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 28;
    constexpr bool has_gtzc = true;
    constexpr uint32_t num_gtzc_instances = 4;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 2;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai2 = true;
    constexpr uint32_t num_sai2_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 8;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 2;
    constexpr bool has_pka = true;
    constexpr uint32_t num_pka_instances = 1;
    constexpr bool has_otfdec1 = true;
    constexpr uint32_t num_otfdec1_instances = 1;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_dbgmcu = true;
    constexpr uint32_t num_dbgmcu_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 12;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 2;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_tsc = true;
    constexpr uint32_t num_tsc_instances = 1;
    constexpr bool has_ucpd1 = true;
    constexpr uint32_t num_ucpd1_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_crs = true;
    constexpr uint32_t num_crs_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 4;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 2;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 2;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct dcb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dfsdm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sec_tag> {
        static constexpr uint32_t value = 20;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 16;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct icache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 28;
    };
    template<>
    struct peripheral_count<struct gtzc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pka_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otfdec1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbgmcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 12;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ucpd1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 16;
    constexpr uint32_t max_gpio_pins = 256;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_sec_lpuart1 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_sec_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_sec_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_sec_usart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_sec_uart4 = true;
    constexpr bool has_sec_uart5 = true;
}

// ============================================================================
// DCB Peripheral
// ============================================================================

namespace dcb {
    /// Base addresses
    constexpr uint32_t DCB_BASE = 0xE000EE08;

    /// DCB Register structure
    struct Registers {
        volatile uint32_t DSCSR;  ///< Offset: 0x00 - Debug Security Control and Status Register
    };

    /// Peripheral instances
    inline Registers* DCB = reinterpret_cast<Registers*>(DCB_BASE);

    // Bit definitions
    /// DSCSR Register bits
    namespace dscsr_bits {
        constexpr uint32_t CDS = (1U << 16);  ///< Current domain Secure
    }

}

// ============================================================================
// DFSDM1 Peripheral
// ============================================================================

namespace dfsdm1 {
    /// Base addresses
    constexpr uint32_t DFSDM1_BASE = 0x40016000;

    /// DFSDM1 Register structure
    struct Registers {
        volatile uint32_t CH0CFGR1;  ///< Offset: 0x00 - channel configuration y register
        volatile uint32_t CH0CFGR2;  ///< Offset: 0x04 - channel configuration y register
        volatile uint32_t CH0AWSCDR;  ///< Offset: 0x08 - analog watchdog and short-circuit detector register
        volatile uint32_t CH0WDATR;  ///< Offset: 0x0C - channel watchdog filter data register
        volatile uint32_t CH0DATINR;  ///< Offset: 0x10 - channel data input register
        volatile uint32_t CH1CFGR1;  ///< Offset: 0x20 - CHCFG1R1
        volatile uint32_t CH1CFGR2;  ///< Offset: 0x24 - CHCFG1R2
        volatile uint32_t CH1AWSCDR;  ///< Offset: 0x28 - AWSCD1R
        volatile uint32_t CH1WDATR;  ///< Offset: 0x2C - CHWDAT1R
        volatile uint32_t CH1DATINR;  ///< Offset: 0x30 - CHDATIN1R
        volatile uint32_t CH2CFGR1;  ///< Offset: 0x40 - CHCFG2R1
        volatile uint32_t CH2CFGR2;  ///< Offset: 0x44 - CHCFG2R2
        volatile uint32_t CH2AWSCDR;  ///< Offset: 0x48 - AWSCD2R
        volatile uint32_t CH2WDATR;  ///< Offset: 0x4C - CHWDAT2R
        volatile uint32_t CH2DATINR;  ///< Offset: 0x50 - CHDATIN2R
        volatile uint32_t CH3CFGR1;  ///< Offset: 0x60 - CHCFG3R1
        volatile uint32_t CH3CFGR2;  ///< Offset: 0x64 - CHCFG3R2
        volatile uint32_t CH3AWSCDR;  ///< Offset: 0x68 - AWSCD3R
        volatile uint32_t CH3WDATR;  ///< Offset: 0x6C - CHWDAT3R
        volatile uint32_t CH3DATINR;  ///< Offset: 0x70 - CHDATIN3R
        volatile uint32_t CH4CFGR1;  ///< Offset: 0x80 - CHCFG4R1
        volatile uint32_t CH4CFGR2;  ///< Offset: 0x84 - CHCFG4R2
        volatile uint32_t CH4AWSCDR;  ///< Offset: 0x88 - AWSCD4R
        volatile uint32_t CH4WDATR;  ///< Offset: 0x8C - CHWDAT4R
        volatile uint32_t CH4DATINR;  ///< Offset: 0x90 - CHDATIN4R
        volatile uint32_t CH5CFGR1;  ///< Offset: 0xA0 - CHCFG5R1
        volatile uint32_t CH5CFGR2;  ///< Offset: 0xA4 - CHCFG5R2
        volatile uint32_t CH5AWSCDR;  ///< Offset: 0xA8 - AWSCD5R
        volatile uint32_t CH5WDATR;  ///< Offset: 0xAC - CHWDAT5R
        volatile uint32_t CH5DATINR;  ///< Offset: 0xB0 - CHDATIN5R
        volatile uint32_t CH6CFGR1;  ///< Offset: 0xC0 - CHCFG6R1
        volatile uint32_t CH6CFGR2;  ///< Offset: 0xC4 - CH6CFGR2
        volatile uint32_t CH6AWSCDR;  ///< Offset: 0xC8 - AWSCD6R
        volatile uint32_t CH6WDATR;  ///< Offset: 0xCC - CHWDAT6R
        volatile uint32_t CH6DATINR;  ///< Offset: 0xD0 - CHDATIN6R
        volatile uint32_t CH7CFGR1;  ///< Offset: 0xE0 - CHCFG7R1
        volatile uint32_t CH7CFGR2;  ///< Offset: 0xE4 - CHCFG7R2
        volatile uint32_t CH7AWSCDR;  ///< Offset: 0xE8 - AWSCD7R
        volatile uint32_t CH7WDATR;  ///< Offset: 0xEC - CHWDAT7R
        volatile uint32_t CH7DATINR;  ///< Offset: 0xF0 - CHDATIN7R
        volatile uint32_t FLT0CR1;  ///< Offset: 0x100 - control register 1
        volatile uint32_t FLT0CR2;  ///< Offset: 0x104 - control register 2
        volatile uint32_t FLT0ISR;  ///< Offset: 0x108 - interrupt and status register
        volatile uint32_t FLT0ICR;  ///< Offset: 0x10C - interrupt flag clear register
        volatile uint32_t FLT0JCHGR;  ///< Offset: 0x110 - injected channel group selection register
        volatile uint32_t FLT0FCR;  ///< Offset: 0x114 - filter control register
        volatile uint32_t FLT0JDATAR;  ///< Offset: 0x118 - data register for injected group
        volatile uint32_t FLT0RDATAR;  ///< Offset: 0x11C - data register for the regular channel
        volatile uint32_t FLT0AWHTR;  ///< Offset: 0x120 - analog watchdog high threshold register
        volatile uint32_t FLT0AWLTR;  ///< Offset: 0x124 - analog watchdog low threshold register
        volatile uint32_t FLT0AWSR;  ///< Offset: 0x128 - analog watchdog status register
        volatile uint32_t FLT0AWCFR;  ///< Offset: 0x12C - analog watchdog clear flag register
        volatile uint32_t FLT0EXMAX;  ///< Offset: 0x130 - Extremes detector maximum register
        volatile uint32_t FLT0EXMIN;  ///< Offset: 0x134 - Extremes detector minimum register
        volatile uint32_t FLT0CNVTIMR;  ///< Offset: 0x138 - conversion timer register
        volatile uint32_t FLT1CR1;  ///< Offset: 0x180 - control register 1
        volatile uint32_t FLT1CR2;  ///< Offset: 0x184 - control register 2
        volatile uint32_t FLT1ISR;  ///< Offset: 0x188 - interrupt and status register
        volatile uint32_t FLT1ICR;  ///< Offset: 0x18C - interrupt flag clear register
        volatile uint32_t FLT1JCHGR;  ///< Offset: 0x190 - injected channel group selection register
        volatile uint32_t FLT1FCR;  ///< Offset: 0x194 - filter control register
        volatile uint32_t FLT1JDATAR;  ///< Offset: 0x198 - data register for injected group
        volatile uint32_t FLT1RDATAR;  ///< Offset: 0x19C - data register for the regular channel
        volatile uint32_t FLT1AWHTR;  ///< Offset: 0x1AC - analog watchdog high threshold register
        volatile uint32_t FLT1AWLTR;  ///< Offset: 0x1A4 - analog watchdog low threshold register
        volatile uint32_t FLT1AWSR;  ///< Offset: 0x1A8 - analog watchdog status register
        volatile uint32_t FLT1AWCFR;  ///< Offset: 0x1AC - analog watchdog clear flag register
        volatile uint32_t FLT1EXMAX;  ///< Offset: 0x1B0 - Extremes detector maximum register
        volatile uint32_t FLT1EXMIN;  ///< Offset: 0x1B4 - Extremes detector minimum register
        volatile uint32_t FLT1CNVTIMR;  ///< Offset: 0x1B8 - conversion timer register
        volatile uint32_t FLT2CR1;  ///< Offset: 0x200 - control register 1
        volatile uint32_t FLT2CR2;  ///< Offset: 0x204 - control register 2
        volatile uint32_t FLT2ISR;  ///< Offset: 0x208 - interrupt and status register
        volatile uint32_t FLT2ICR;  ///< Offset: 0x20C - interrupt flag clear register
        volatile uint32_t FLT2JCHGR;  ///< Offset: 0x210 - injected channel group selection register
        volatile uint32_t FLT2FCR;  ///< Offset: 0x214 - filter control register
        volatile uint32_t FLT2JDATAR;  ///< Offset: 0x218 - data register for injected group
        volatile uint32_t FLT2RDATAR;  ///< Offset: 0x21C - data register for the regular channel
        volatile uint32_t FLT2AWHTR;  ///< Offset: 0x220 - analog watchdog high threshold register
        volatile uint32_t FLT2AWLTR;  ///< Offset: 0x224 - analog watchdog low threshold register
        volatile uint32_t FLT2AWSR;  ///< Offset: 0x228 - analog watchdog status register
        volatile uint32_t FLT2AWCFR;  ///< Offset: 0x22C - analog watchdog clear flag register
        volatile uint32_t FLT2EXMAX;  ///< Offset: 0x230 - Extremes detector maximum register
        volatile uint32_t FLT2EXMIN;  ///< Offset: 0x234 - Extremes detector minimum register
        volatile uint32_t FLT2CNVTIMR;  ///< Offset: 0x238 - conversion timer register
        volatile uint32_t FLT3CR1;  ///< Offset: 0x280 - control register 1
        volatile uint32_t FLT3CR2;  ///< Offset: 0x284 - control register 2
        volatile uint32_t FLT3ISR;  ///< Offset: 0x288 - interrupt and status register
        volatile uint32_t FLT3ICR;  ///< Offset: 0x28C - interrupt flag clear register
        volatile uint32_t FLT3JCHGR;  ///< Offset: 0x290 - injected channel group selection register
        volatile uint32_t FLT3FCR;  ///< Offset: 0x294 - filter control register
        volatile uint32_t FLT3JDATAR;  ///< Offset: 0x298 - data register for injected group
        volatile uint32_t FLT3RDATAR;  ///< Offset: 0x29C - data register for the regular channel
        volatile uint32_t FLT3AWHTR;  ///< Offset: 0x2A0 - analog watchdog high threshold register
        volatile uint32_t FLT3AWLTR;  ///< Offset: 0x2A4 - analog watchdog low threshold register
        volatile uint32_t FLT3AWSR;  ///< Offset: 0x2A8 - analog watchdog status register
        volatile uint32_t FLT3AWCFR;  ///< Offset: 0x2AC - analog watchdog clear flag register
        volatile uint32_t FLT3EXMAX;  ///< Offset: 0x2B0 - Extremes detector maximum register
        volatile uint32_t FLT3EXMIN;  ///< Offset: 0x2B4 - Extremes detector minimum register
        volatile uint32_t FLT3CNVTIMR;  ///< Offset: 0x2B8 - conversion timer register
        volatile uint32_t CH0DLYR;  ///< Offset: 0x14 - DFSDM channel y delay register
        volatile uint32_t CH1DLYR;  ///< Offset: 0x34 - DFSDM channel y delay register
        volatile uint32_t CH2DLYR;  ///< Offset: 0x54 - DFSDM channel y delay register
        volatile uint32_t CH3DLYR;  ///< Offset: 0x74 - DFSDM channel y delay register
        volatile uint32_t CH4DLYR;  ///< Offset: 0x94 - DFSDM channel y delay register
        volatile uint32_t CH5DLYR;  ///< Offset: 0xB4 - DFSDM channel y delay register
        volatile uint32_t CH6DLYR;  ///< Offset: 0xD4 - DFSDM channel y delay register
        volatile uint32_t CH7DLYR;  ///< Offset: 0xF4 - DFSDM channel y delay register
    };

    /// Peripheral instances
    inline Registers* DFSDM1 = reinterpret_cast<Registers*>(DFSDM1_BASE);

    // Bit definitions
    /// CH0CFGR1 Register bits
    namespace ch0cfgr1_bits {
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< DFSDMEN
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< CKOUTSRC
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< CKOUTDIV
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
    }

    /// CH0CFGR2 Register bits
    namespace ch0cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH0AWSCDR Register bits
    namespace ch0awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH0WDATR Register bits
    namespace ch0wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH0DATINR Register bits
    namespace ch0datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH1CFGR1 Register bits
    namespace ch1cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH1CFGR2 Register bits
    namespace ch1cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH1AWSCDR Register bits
    namespace ch1awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH1WDATR Register bits
    namespace ch1wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH1DATINR Register bits
    namespace ch1datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH2CFGR1 Register bits
    namespace ch2cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH2CFGR2 Register bits
    namespace ch2cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH2AWSCDR Register bits
    namespace ch2awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH2WDATR Register bits
    namespace ch2wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH2DATINR Register bits
    namespace ch2datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH3CFGR1 Register bits
    namespace ch3cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH3CFGR2 Register bits
    namespace ch3cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH3AWSCDR Register bits
    namespace ch3awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH3WDATR Register bits
    namespace ch3wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH3DATINR Register bits
    namespace ch3datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH4CFGR1 Register bits
    namespace ch4cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH4CFGR2 Register bits
    namespace ch4cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH4AWSCDR Register bits
    namespace ch4awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH4WDATR Register bits
    namespace ch4wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH4DATINR Register bits
    namespace ch4datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH5CFGR1 Register bits
    namespace ch5cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH5CFGR2 Register bits
    namespace ch5cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH5AWSCDR Register bits
    namespace ch5awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH5WDATR Register bits
    namespace ch5wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH5DATINR Register bits
    namespace ch5datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH6CFGR1 Register bits
    namespace ch6cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH6CFGR2 Register bits
    namespace ch6cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH6AWSCDR Register bits
    namespace ch6awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH6WDATR Register bits
    namespace ch6wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH6DATINR Register bits
    namespace ch6datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// CH7CFGR1 Register bits
    namespace ch7cfgr1_bits {
        constexpr uint32_t DATPACK = (2 << 14);  ///< DATPACK
        constexpr uint32_t DATMPX = (2 << 12);  ///< DATMPX
        constexpr uint32_t CHINSEL = (1U << 8);  ///< CHINSEL
        constexpr uint32_t CHEN = (1U << 7);  ///< CHEN
        constexpr uint32_t CKABEN = (1U << 6);  ///< CKABEN
        constexpr uint32_t SCDEN = (1U << 5);  ///< SCDEN
        constexpr uint32_t SPICKSEL = (2 << 2);  ///< SPICKSEL
        constexpr uint32_t SITP = (2 << 0);  ///< SITP
        constexpr uint32_t CKOUTDIV = (8 << 16);  ///< Output serial clock divider
        constexpr uint32_t CKOUTSRC = (1U << 30);  ///< Output serial clock source selection
        constexpr uint32_t DFSDMEN = (1U << 31);  ///< Global enable for DFSDM interface
    }

    /// CH7CFGR2 Register bits
    namespace ch7cfgr2_bits {
        constexpr uint32_t OFFSET = (24 << 8);  ///< OFFSET
        constexpr uint32_t DTRBS = (5 << 3);  ///< DTRBS
    }

    /// CH7AWSCDR Register bits
    namespace ch7awscdr_bits {
        constexpr uint32_t AWFORD = (2 << 22);  ///< AWFORD
        constexpr uint32_t AWFOSR = (5 << 16);  ///< AWFOSR
        constexpr uint32_t BKSCD = (4 << 12);  ///< BKSCD
        constexpr uint32_t SCDT = (8 << 0);  ///< SCDT
    }

    /// CH7WDATR Register bits
    namespace ch7wdatr_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< WDATA
    }

    /// CH7DATINR Register bits
    namespace ch7datinr_bits {
        constexpr uint32_t INDAT1 = (16 << 16);  ///< INDAT1
        constexpr uint32_t INDAT0 = (16 << 0);  ///< INDAT0
    }

    /// FLT0CR1 Register bits
    namespace flt0cr1_bits {
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t JEXTSEL = (3 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
    }

    /// FLT0CR2 Register bits
    namespace flt0cr2_bits {
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
    }

    /// FLT0ISR Register bits
    namespace flt0isr_bits {
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
    }

    /// FLT0ICR Register bits
    namespace flt0icr_bits {
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
    }

    /// FLT0JCHGR Register bits
    namespace flt0jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// FLT0FCR Register bits
    namespace flt0fcr_bits {
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
    }

    /// FLT0JDATAR Register bits
    namespace flt0jdatar_bits {
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
    }

    /// FLT0RDATAR Register bits
    namespace flt0rdatar_bits {
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
    }

    /// FLT0AWHTR Register bits
    namespace flt0awhtr_bits {
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
    }

    /// FLT0AWLTR Register bits
    namespace flt0awltr_bits {
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
    }

    /// FLT0AWSR Register bits
    namespace flt0awsr_bits {
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
    }

    /// FLT0AWCFR Register bits
    namespace flt0awcfr_bits {
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
    }

    /// FLT0EXMAX Register bits
    namespace flt0exmax_bits {
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
    }

    /// FLT0EXMIN Register bits
    namespace flt0exmin_bits {
        constexpr uint32_t EXMIN = (24 << 8);  ///< EXMIN
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
    }

    /// FLT0CNVTIMR Register bits
    namespace flt0cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    }

    /// FLT1CR1 Register bits
    namespace flt1cr1_bits {
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t JEXTSEL = (3 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
    }

    /// FLT1CR2 Register bits
    namespace flt1cr2_bits {
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
    }

    /// FLT1ISR Register bits
    namespace flt1isr_bits {
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
    }

    /// FLT1ICR Register bits
    namespace flt1icr_bits {
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
    }

    /// FLT1JCHGR Register bits
    namespace flt1jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// FLT1FCR Register bits
    namespace flt1fcr_bits {
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
    }

    /// FLT1JDATAR Register bits
    namespace flt1jdatar_bits {
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
    }

    /// FLT1RDATAR Register bits
    namespace flt1rdatar_bits {
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
    }

    /// FLT1AWHTR Register bits
    namespace flt1awhtr_bits {
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
    }

    /// FLT1AWLTR Register bits
    namespace flt1awltr_bits {
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
    }

    /// FLT1AWSR Register bits
    namespace flt1awsr_bits {
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
    }

    /// FLT1AWCFR Register bits
    namespace flt1awcfr_bits {
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
    }

    /// FLT1EXMAX Register bits
    namespace flt1exmax_bits {
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
    }

    /// FLT1EXMIN Register bits
    namespace flt1exmin_bits {
        constexpr uint32_t EXMIN = (24 << 8);  ///< EXMIN
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
    }

    /// FLT1CNVTIMR Register bits
    namespace flt1cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    }

    /// FLT2CR1 Register bits
    namespace flt2cr1_bits {
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t JEXTSEL = (3 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
    }

    /// FLT2CR2 Register bits
    namespace flt2cr2_bits {
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
    }

    /// FLT2ISR Register bits
    namespace flt2isr_bits {
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
    }

    /// FLT2ICR Register bits
    namespace flt2icr_bits {
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
    }

    /// FLT2JCHGR Register bits
    namespace flt2jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// FLT2FCR Register bits
    namespace flt2fcr_bits {
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
    }

    /// FLT2JDATAR Register bits
    namespace flt2jdatar_bits {
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
    }

    /// FLT2RDATAR Register bits
    namespace flt2rdatar_bits {
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
    }

    /// FLT2AWHTR Register bits
    namespace flt2awhtr_bits {
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
    }

    /// FLT2AWLTR Register bits
    namespace flt2awltr_bits {
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
    }

    /// FLT2AWSR Register bits
    namespace flt2awsr_bits {
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
    }

    /// FLT2AWCFR Register bits
    namespace flt2awcfr_bits {
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
    }

    /// FLT2EXMAX Register bits
    namespace flt2exmax_bits {
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
    }

    /// FLT2EXMIN Register bits
    namespace flt2exmin_bits {
        constexpr uint32_t EXMIN = (24 << 8);  ///< EXMIN
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
    }

    /// FLT2CNVTIMR Register bits
    namespace flt2cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    }

    /// FLT3CR1 Register bits
    namespace flt3cr1_bits {
        constexpr uint32_t AWFSEL = (1U << 30);  ///< Analog watchdog fast mode select
        constexpr uint32_t FAST = (1U << 29);  ///< Fast conversion mode selection for regular conversions
        constexpr uint32_t RCH = (3 << 24);  ///< Regular channel selection
        constexpr uint32_t RDMAEN = (1U << 21);  ///< DMA channel enabled to read data for the regular conversion
        constexpr uint32_t RSYNC = (1U << 19);  ///< Launch regular conversion synchronously with DFSDM0
        constexpr uint32_t RCONT = (1U << 18);  ///< Continuous mode selection for regular conversions
        constexpr uint32_t RSWSTART = (1U << 17);  ///< Software start of a conversion on the regular channel
        constexpr uint32_t JEXTEN = (2 << 13);  ///< Trigger enable and trigger edge selection for injected conversions
        constexpr uint32_t JEXTSEL = (3 << 8);  ///< Trigger signal selection for launching injected conversions
        constexpr uint32_t JDMAEN = (1U << 5);  ///< DMA channel enabled to read data for the injected channel group
        constexpr uint32_t JSCAN = (1U << 4);  ///< Scanning conversion mode for injected conversions
        constexpr uint32_t JSYNC = (1U << 3);  ///< Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        constexpr uint32_t JSWSTART = (1U << 1);  ///< Start a conversion of the injected group of channels
        constexpr uint32_t DFEN = (1U << 0);  ///< DFSDM enable
    }

    /// FLT3CR2 Register bits
    namespace flt3cr2_bits {
        constexpr uint32_t AWDCH = (8 << 16);  ///< Analog watchdog channel selection
        constexpr uint32_t EXCH = (8 << 8);  ///< Extremes detector channel selection
        constexpr uint32_t CKABIE = (1U << 6);  ///< Clock absence interrupt enable
        constexpr uint32_t SCDIE = (1U << 5);  ///< Short-circuit detector interrupt enable
        constexpr uint32_t AWDIE = (1U << 4);  ///< Analog watchdog interrupt enable
        constexpr uint32_t ROVRIE = (1U << 3);  ///< Regular data overrun interrupt enable
        constexpr uint32_t JOVRIE = (1U << 2);  ///< Injected data overrun interrupt enable
        constexpr uint32_t REOCIE = (1U << 1);  ///< Regular end of conversion interrupt enable
        constexpr uint32_t JEOCIE = (1U << 0);  ///< Injected end of conversion interrupt enable
    }

    /// FLT3ISR Register bits
    namespace flt3isr_bits {
        constexpr uint32_t SCDF = (8 << 24);  ///< short-circuit detector flag
        constexpr uint32_t CKABF = (8 << 16);  ///< Clock absence flag
        constexpr uint32_t RCIP = (1U << 14);  ///< Regular conversion in progress status
        constexpr uint32_t JCIP = (1U << 13);  ///< Injected conversion in progress status
        constexpr uint32_t AWDF = (1U << 4);  ///< Analog watchdog
        constexpr uint32_t ROVRF = (1U << 3);  ///< Regular conversion overrun flag
        constexpr uint32_t JOVRF = (1U << 2);  ///< Injected conversion overrun flag
        constexpr uint32_t REOCF = (1U << 1);  ///< End of regular conversion flag
        constexpr uint32_t JEOCF = (1U << 0);  ///< End of injected conversion flag
    }

    /// FLT3ICR Register bits
    namespace flt3icr_bits {
        constexpr uint32_t CLRSCDF = (8 << 24);  ///< Clear the short-circuit detector flag
        constexpr uint32_t CLRCKABF = (8 << 16);  ///< Clear the clock absence flag
        constexpr uint32_t CLRROVRF = (1U << 3);  ///< Clear the regular conversion overrun flag
        constexpr uint32_t CLRJOVRF = (1U << 2);  ///< Clear the injected conversion overrun flag
    }

    /// FLT3JCHGR Register bits
    namespace flt3jchgr_bits {
        constexpr uint32_t JCHG = (8 << 0);  ///< Injected channel group selection
    }

    /// FLT3FCR Register bits
    namespace flt3fcr_bits {
        constexpr uint32_t FORD = (3 << 29);  ///< Sinc filter order
        constexpr uint32_t FOSR = (10 << 16);  ///< Sinc filter oversampling ratio (decimation rate)
        constexpr uint32_t IOSR = (8 << 0);  ///< Integrator oversampling ratio (averaging length)
    }

    /// FLT3JDATAR Register bits
    namespace flt3jdatar_bits {
        constexpr uint32_t JDATA = (24 << 8);  ///< Injected group conversion data
        constexpr uint32_t JDATACH = (3 << 0);  ///< Injected channel most recently converted
    }

    /// FLT3RDATAR Register bits
    namespace flt3rdatar_bits {
        constexpr uint32_t RDATA = (24 << 8);  ///< Regular channel conversion data
        constexpr uint32_t RPEND = (1U << 4);  ///< Regular channel pending data
        constexpr uint32_t RDATACH = (3 << 0);  ///< Regular channel most recently converted
    }

    /// FLT3AWHTR Register bits
    namespace flt3awhtr_bits {
        constexpr uint32_t AWHT = (24 << 8);  ///< Analog watchdog high threshold
        constexpr uint32_t BKAWH = (4 << 0);  ///< Break signal assignment to analog watchdog high threshold event
    }

    /// FLT3AWLTR Register bits
    namespace flt3awltr_bits {
        constexpr uint32_t AWLT = (24 << 8);  ///< Analog watchdog low threshold
        constexpr uint32_t BKAWL = (4 << 0);  ///< Break signal assignment to analog watchdog low threshold event
    }

    /// FLT3AWSR Register bits
    namespace flt3awsr_bits {
        constexpr uint32_t AWHTF = (8 << 8);  ///< Analog watchdog high threshold flag
        constexpr uint32_t AWLTF = (8 << 0);  ///< Analog watchdog low threshold flag
    }

    /// FLT3AWCFR Register bits
    namespace flt3awcfr_bits {
        constexpr uint32_t CLRAWHTF = (8 << 8);  ///< Clear the analog watchdog high threshold flag
        constexpr uint32_t CLRAWLTF = (8 << 0);  ///< Clear the analog watchdog low threshold flag
    }

    /// FLT3EXMAX Register bits
    namespace flt3exmax_bits {
        constexpr uint32_t EXMAX = (24 << 8);  ///< Extremes detector maximum value
        constexpr uint32_t EXMAXCH = (3 << 0);  ///< Extremes detector maximum data channel
    }

    /// FLT3EXMIN Register bits
    namespace flt3exmin_bits {
        constexpr uint32_t EXMIN = (24 << 8);  ///< EXMIN
        constexpr uint32_t EXMINCH = (3 << 0);  ///< Extremes detector minimum data channel
    }

    /// FLT3CNVTIMR Register bits
    namespace flt3cnvtimr_bits {
        constexpr uint32_t CNVCNT = (28 << 4);  ///< 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    }

    /// CH0DLYR Register bits
    namespace ch0dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< Pulses to skip for input data skipping function
    }

    /// CH1DLYR Register bits
    namespace ch1dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< PLSSKP
    }

    /// CH2DLYR Register bits
    namespace ch2dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< PLSSKP
    }

    /// CH3DLYR Register bits
    namespace ch3dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< PLSSKP
    }

    /// CH4DLYR Register bits
    namespace ch4dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< PLSSKP
    }

    /// CH5DLYR Register bits
    namespace ch5dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< read-only
    }

    /// CH6DLYR Register bits
    namespace ch6dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< PLSSKP
    }

    /// CH7DLYR Register bits
    namespace ch7dlyr_bits {
        constexpr uint32_t PLSSKP = (6 << 0);  ///< PLSSKP
    }

}

// ============================================================================
// SEC Peripheral
// ============================================================================

namespace sec {
    /// Base addresses
    constexpr uint32_t SEC_DFSDM1_BASE = 0x50016000;
    constexpr uint32_t SEC_EXTI_BASE = 0x5002F400;
    constexpr uint32_t SEC_TAMP_BASE = 0x50003400;
    constexpr uint32_t SEC_ICache_BASE = 0x50030400;
    constexpr uint32_t SEC_SAI1_BASE = 0x50015400;
    constexpr uint32_t SEC_SAI2_BASE = 0x50015800;
    constexpr uint32_t SEC_GTZC_MPCBB1_BASE = 0x50032C00;
    constexpr uint32_t SEC_GTZC_MPCBB2_BASE = 0x50033000;
    constexpr uint32_t SEC_OPAMP_BASE = 0x50007800;
    constexpr uint32_t SEC_PKA_BASE = 0x520C2000;
    constexpr uint32_t SEC_OTFDEC1_BASE = 0x520C5000;
    constexpr uint32_t SEC_GTZC_TZIC_BASE = 0x50032800;
    constexpr uint32_t SEC_GTZC_TZSC_BASE = 0x50032400;
    constexpr uint32_t SEC_SYSCFG_BASE = 0x50010000;
    constexpr uint32_t SEC_VREFBUF_BASE = 0x50010030;
    constexpr uint32_t SEC_TSC_BASE = 0x50024000;
    constexpr uint32_t SEC_UCPD1_BASE = 0x5000DC00;
    constexpr uint32_t SEC_CRC_BASE = 0x50023000;
    constexpr uint32_t SEC_CRS_BASE = 0x50006000;
    constexpr uint32_t SEC_FMC_BASE = 0x54020000;

    /// SEC Register structure
    struct Registers {
        volatile uint32_t MPCBB1_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB1_LCKVTR1;  ///< Offset: 0x10 - MPCBB control register
        volatile uint32_t MPCBB1_LCKVTR2;  ///< Offset: 0x14 - MPCBB control register
        volatile uint32_t MPCBB1_VCTR0;  ///< Offset: 0x100 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR1;  ///< Offset: 0x104 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR2;  ///< Offset: 0x108 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR3;  ///< Offset: 0x10C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR4;  ///< Offset: 0x110 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR5;  ///< Offset: 0x114 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR6;  ///< Offset: 0x118 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR7;  ///< Offset: 0x11C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR8;  ///< Offset: 0x120 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR9;  ///< Offset: 0x124 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR10;  ///< Offset: 0x128 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR11;  ///< Offset: 0x12C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR12;  ///< Offset: 0x130 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR13;  ///< Offset: 0x134 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR14;  ///< Offset: 0x138 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR15;  ///< Offset: 0x13C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR16;  ///< Offset: 0x140 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR17;  ///< Offset: 0x144 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR18;  ///< Offset: 0x148 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR19;  ///< Offset: 0x14C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR20;  ///< Offset: 0x150 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR21;  ///< Offset: 0x154 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR22;  ///< Offset: 0x158 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR23;  ///< Offset: 0x15C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR24;  ///< Offset: 0x160 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR25;  ///< Offset: 0x164 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR26;  ///< Offset: 0x168 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR27;  ///< Offset: 0x16C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR28;  ///< Offset: 0x170 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR29;  ///< Offset: 0x174 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR30;  ///< Offset: 0x178 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR31;  ///< Offset: 0x17C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR32;  ///< Offset: 0x180 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR33;  ///< Offset: 0x184 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR34;  ///< Offset: 0x188 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR35;  ///< Offset: 0x18C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR36;  ///< Offset: 0x190 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR37;  ///< Offset: 0x194 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR38;  ///< Offset: 0x198 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR39;  ///< Offset: 0x19C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR40;  ///< Offset: 0x1A0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR41;  ///< Offset: 0x1A4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR42;  ///< Offset: 0x1A8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR43;  ///< Offset: 0x1AC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR44;  ///< Offset: 0x1B0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR45;  ///< Offset: 0x1B4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR46;  ///< Offset: 0x1B8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR47;  ///< Offset: 0x1BC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR48;  ///< Offset: 0x1C0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR49;  ///< Offset: 0x1C4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR50;  ///< Offset: 0x1C8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR51;  ///< Offset: 0x1CC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR52;  ///< Offset: 0x1D0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR53;  ///< Offset: 0x1D4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR54;  ///< Offset: 0x1D8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR55;  ///< Offset: 0x1DC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR56;  ///< Offset: 0x1E0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR57;  ///< Offset: 0x1E4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR58;  ///< Offset: 0x1E8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR59;  ///< Offset: 0x1EC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR60;  ///< Offset: 0x1F0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR61;  ///< Offset: 0x1F4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR62;  ///< Offset: 0x1F8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR63;  ///< Offset: 0x1FC - MPCBBx vector register
    };

    /// Peripheral instances
    inline Registers* SEC_DFSDM1 = reinterpret_cast<Registers*>(SEC_DFSDM1_BASE);
    inline Registers* SEC_EXTI = reinterpret_cast<Registers*>(SEC_EXTI_BASE);
    inline Registers* SEC_TAMP = reinterpret_cast<Registers*>(SEC_TAMP_BASE);
    inline Registers* SEC_ICache = reinterpret_cast<Registers*>(SEC_ICache_BASE);
    inline Registers* SEC_SAI1 = reinterpret_cast<Registers*>(SEC_SAI1_BASE);
    inline Registers* SEC_SAI2 = reinterpret_cast<Registers*>(SEC_SAI2_BASE);
    inline Registers* SEC_GTZC_MPCBB1 = reinterpret_cast<Registers*>(SEC_GTZC_MPCBB1_BASE);
    inline Registers* SEC_GTZC_MPCBB2 = reinterpret_cast<Registers*>(SEC_GTZC_MPCBB2_BASE);
    inline Registers* SEC_OPAMP = reinterpret_cast<Registers*>(SEC_OPAMP_BASE);
    inline Registers* SEC_PKA = reinterpret_cast<Registers*>(SEC_PKA_BASE);
    inline Registers* SEC_OTFDEC1 = reinterpret_cast<Registers*>(SEC_OTFDEC1_BASE);
    inline Registers* SEC_GTZC_TZIC = reinterpret_cast<Registers*>(SEC_GTZC_TZIC_BASE);
    inline Registers* SEC_GTZC_TZSC = reinterpret_cast<Registers*>(SEC_GTZC_TZSC_BASE);
    inline Registers* SEC_SYSCFG = reinterpret_cast<Registers*>(SEC_SYSCFG_BASE);
    inline Registers* SEC_VREFBUF = reinterpret_cast<Registers*>(SEC_VREFBUF_BASE);
    inline Registers* SEC_TSC = reinterpret_cast<Registers*>(SEC_TSC_BASE);
    inline Registers* SEC_UCPD1 = reinterpret_cast<Registers*>(SEC_UCPD1_BASE);
    inline Registers* SEC_CRC = reinterpret_cast<Registers*>(SEC_CRC_BASE);
    inline Registers* SEC_CRS = reinterpret_cast<Registers*>(SEC_CRS_BASE);
    inline Registers* SEC_FMC = reinterpret_cast<Registers*>(SEC_FMC_BASE);

    // Bit definitions
    /// MPCBB1_CR Register bits
    namespace mpcbb1_cr_bits {
        constexpr uint32_t LCK = (1U << 0);  ///< LCK
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< INVSECSTATE
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< SRWILADIS
    }

    /// MPCBB1_LCKVTR1 Register bits
    namespace mpcbb1_lckvtr1_bits {
        constexpr uint32_t LCKSB0 = (1U << 0);  ///< LCKSB0
        constexpr uint32_t LCKSB1 = (1U << 1);  ///< LCKSB1
        constexpr uint32_t LCKSB2 = (1U << 2);  ///< LCKSB2
        constexpr uint32_t LCKSB3 = (1U << 3);  ///< LCKSB3
        constexpr uint32_t LCKSB4 = (1U << 4);  ///< LCKSB4
        constexpr uint32_t LCKSB5 = (1U << 5);  ///< LCKSB5
        constexpr uint32_t LCKSB6 = (1U << 6);  ///< LCKSB6
        constexpr uint32_t LCKSB7 = (1U << 7);  ///< LCKSB7
        constexpr uint32_t LCKSB8 = (1U << 8);  ///< LCKSB8
        constexpr uint32_t LCKSB9 = (1U << 9);  ///< LCKSB9
        constexpr uint32_t LCKSB10 = (1U << 10);  ///< LCKSB10
        constexpr uint32_t LCKSB11 = (1U << 11);  ///< LCKSB11
        constexpr uint32_t LCKSB12 = (1U << 12);  ///< LCKSB12
        constexpr uint32_t LCKSB13 = (1U << 13);  ///< LCKSB13
        constexpr uint32_t LCKSB14 = (1U << 14);  ///< LCKSB14
        constexpr uint32_t LCKSB15 = (1U << 15);  ///< LCKSB15
        constexpr uint32_t LCKSB16 = (1U << 16);  ///< LCKSB16
        constexpr uint32_t LCKSB17 = (1U << 17);  ///< LCKSB17
        constexpr uint32_t LCKSB18 = (1U << 18);  ///< LCKSB18
        constexpr uint32_t LCKSB19 = (1U << 19);  ///< LCKSB19
        constexpr uint32_t LCKSB20 = (1U << 20);  ///< LCKSB20
        constexpr uint32_t LCKSB21 = (1U << 21);  ///< LCKSB21
        constexpr uint32_t LCKSB22 = (1U << 22);  ///< LCKSB22
        constexpr uint32_t LCKSB23 = (1U << 23);  ///< LCKSB23
        constexpr uint32_t LCKSB24 = (1U << 24);  ///< LCKSB24
        constexpr uint32_t LCKSB25 = (1U << 25);  ///< LCKSB25
        constexpr uint32_t LCKSB26 = (1U << 26);  ///< LCKSB26
        constexpr uint32_t LCKSB27 = (1U << 27);  ///< LCKSB27
        constexpr uint32_t LCKSB28 = (1U << 28);  ///< LCKSB28
        constexpr uint32_t LCKSB29 = (1U << 29);  ///< LCKSB29
        constexpr uint32_t LCKSB30 = (1U << 30);  ///< LCKSB30
        constexpr uint32_t LCKSB31 = (1U << 31);  ///< LCKSB31
    }

    /// MPCBB1_LCKVTR2 Register bits
    namespace mpcbb1_lckvtr2_bits {
        constexpr uint32_t LCKSB32 = (1U << 0);  ///< LCKSB32
        constexpr uint32_t LCKSB33 = (1U << 1);  ///< LCKSB33
        constexpr uint32_t LCKSB34 = (1U << 2);  ///< LCKSB34
        constexpr uint32_t LCKSB35 = (1U << 3);  ///< LCKSB35
        constexpr uint32_t LCKSB36 = (1U << 4);  ///< LCKSB36
        constexpr uint32_t LCKSB37 = (1U << 5);  ///< LCKSB37
        constexpr uint32_t LCKSB38 = (1U << 6);  ///< LCKSB38
        constexpr uint32_t LCKSB39 = (1U << 7);  ///< LCKSB39
        constexpr uint32_t LCKSB40 = (1U << 8);  ///< LCKSB40
        constexpr uint32_t LCKSB41 = (1U << 9);  ///< LCKSB41
        constexpr uint32_t LCKSB42 = (1U << 10);  ///< LCKSB42
        constexpr uint32_t LCKSB43 = (1U << 11);  ///< LCKSB43
        constexpr uint32_t LCKSB44 = (1U << 12);  ///< LCKSB44
        constexpr uint32_t LCKSB45 = (1U << 13);  ///< LCKSB45
        constexpr uint32_t LCKSB46 = (1U << 14);  ///< LCKSB46
        constexpr uint32_t LCKSB47 = (1U << 15);  ///< LCKSB47
        constexpr uint32_t LCKSB48 = (1U << 16);  ///< LCKSB48
        constexpr uint32_t LCKSB49 = (1U << 17);  ///< LCKSB49
        constexpr uint32_t LCKSB50 = (1U << 18);  ///< LCKSB50
        constexpr uint32_t LCKSB51 = (1U << 19);  ///< LCKSB51
        constexpr uint32_t LCKSB52 = (1U << 20);  ///< LCKSB52
        constexpr uint32_t LCKSB53 = (1U << 21);  ///< LCKSB53
        constexpr uint32_t LCKSB54 = (1U << 22);  ///< LCKSB54
        constexpr uint32_t LCKSB55 = (1U << 23);  ///< LCKSB55
        constexpr uint32_t LCKSB56 = (1U << 24);  ///< LCKSB56
        constexpr uint32_t LCKSB57 = (1U << 25);  ///< LCKSB57
        constexpr uint32_t LCKSB58 = (1U << 26);  ///< LCKSB58
        constexpr uint32_t LCKSB59 = (1U << 27);  ///< LCKSB59
        constexpr uint32_t LCKSB60 = (1U << 28);  ///< LCKSB60
        constexpr uint32_t LCKSB61 = (1U << 29);  ///< LCKSB61
        constexpr uint32_t LCKSB62 = (1U << 30);  ///< LCKSB62
        constexpr uint32_t LCKSB63 = (1U << 31);  ///< LCKSB63
    }

    /// MPCBB1_VCTR0 Register bits
    namespace mpcbb1_vctr0_bits {
        constexpr uint32_t B0 = (1U << 0);  ///< B0
        constexpr uint32_t B1 = (1U << 1);  ///< B1
        constexpr uint32_t B2 = (1U << 2);  ///< B2
        constexpr uint32_t B3 = (1U << 3);  ///< B3
        constexpr uint32_t B4 = (1U << 4);  ///< B4
        constexpr uint32_t B5 = (1U << 5);  ///< B5
        constexpr uint32_t B6 = (1U << 6);  ///< B6
        constexpr uint32_t B7 = (1U << 7);  ///< B7
        constexpr uint32_t B8 = (1U << 8);  ///< B8
        constexpr uint32_t B9 = (1U << 9);  ///< B9
        constexpr uint32_t B10 = (1U << 10);  ///< B10
        constexpr uint32_t B11 = (1U << 11);  ///< B11
        constexpr uint32_t B12 = (1U << 12);  ///< B12
        constexpr uint32_t B13 = (1U << 13);  ///< B13
        constexpr uint32_t B14 = (1U << 14);  ///< B14
        constexpr uint32_t B15 = (1U << 15);  ///< B15
        constexpr uint32_t B16 = (1U << 16);  ///< B16
        constexpr uint32_t B17 = (1U << 17);  ///< B17
        constexpr uint32_t B18 = (1U << 18);  ///< B18
        constexpr uint32_t B19 = (1U << 19);  ///< B19
        constexpr uint32_t B20 = (1U << 20);  ///< B20
        constexpr uint32_t B21 = (1U << 21);  ///< B21
        constexpr uint32_t B22 = (1U << 22);  ///< B22
        constexpr uint32_t B23 = (1U << 23);  ///< B23
        constexpr uint32_t B24 = (1U << 24);  ///< B24
        constexpr uint32_t B25 = (1U << 25);  ///< B25
        constexpr uint32_t B26 = (1U << 26);  ///< B26
        constexpr uint32_t B27 = (1U << 27);  ///< B27
        constexpr uint32_t B28 = (1U << 28);  ///< B28
        constexpr uint32_t B29 = (1U << 29);  ///< B29
        constexpr uint32_t B30 = (1U << 30);  ///< B30
        constexpr uint32_t B31 = (1U << 31);  ///< B31
    }

    /// MPCBB1_VCTR1 Register bits
    namespace mpcbb1_vctr1_bits {
        constexpr uint32_t B32 = (1U << 0);  ///< B32
        constexpr uint32_t B33 = (1U << 1);  ///< B33
        constexpr uint32_t B34 = (1U << 2);  ///< B34
        constexpr uint32_t B35 = (1U << 3);  ///< B35
        constexpr uint32_t B36 = (1U << 4);  ///< B36
        constexpr uint32_t B37 = (1U << 5);  ///< B37
        constexpr uint32_t B38 = (1U << 6);  ///< B38
        constexpr uint32_t B39 = (1U << 7);  ///< B39
        constexpr uint32_t B40 = (1U << 8);  ///< B40
        constexpr uint32_t B41 = (1U << 9);  ///< B41
        constexpr uint32_t B42 = (1U << 10);  ///< B42
        constexpr uint32_t B43 = (1U << 11);  ///< B43
        constexpr uint32_t B44 = (1U << 12);  ///< B44
        constexpr uint32_t B45 = (1U << 13);  ///< B45
        constexpr uint32_t B46 = (1U << 14);  ///< B46
        constexpr uint32_t B47 = (1U << 15);  ///< B47
        constexpr uint32_t B48 = (1U << 16);  ///< B48
        constexpr uint32_t B49 = (1U << 17);  ///< B49
        constexpr uint32_t B50 = (1U << 18);  ///< B50
        constexpr uint32_t B51 = (1U << 19);  ///< B51
        constexpr uint32_t B52 = (1U << 20);  ///< B52
        constexpr uint32_t B53 = (1U << 21);  ///< B53
        constexpr uint32_t B54 = (1U << 22);  ///< B54
        constexpr uint32_t B55 = (1U << 23);  ///< B55
        constexpr uint32_t B56 = (1U << 24);  ///< B56
        constexpr uint32_t B57 = (1U << 25);  ///< B57
        constexpr uint32_t B58 = (1U << 26);  ///< B58
        constexpr uint32_t B59 = (1U << 27);  ///< B59
        constexpr uint32_t B60 = (1U << 28);  ///< B60
        constexpr uint32_t B61 = (1U << 29);  ///< B61
        constexpr uint32_t B62 = (1U << 30);  ///< B62
        constexpr uint32_t B63 = (1U << 31);  ///< B63
    }

    /// MPCBB1_VCTR2 Register bits
    namespace mpcbb1_vctr2_bits {
        constexpr uint32_t B64 = (1U << 0);  ///< B64
        constexpr uint32_t B65 = (1U << 1);  ///< B65
        constexpr uint32_t B66 = (1U << 2);  ///< B66
        constexpr uint32_t B67 = (1U << 3);  ///< B67
        constexpr uint32_t B68 = (1U << 4);  ///< B68
        constexpr uint32_t B69 = (1U << 5);  ///< B69
        constexpr uint32_t B70 = (1U << 6);  ///< B70
        constexpr uint32_t B71 = (1U << 7);  ///< B71
        constexpr uint32_t B72 = (1U << 8);  ///< B72
        constexpr uint32_t B73 = (1U << 9);  ///< B73
        constexpr uint32_t B74 = (1U << 10);  ///< B74
        constexpr uint32_t B75 = (1U << 11);  ///< B75
        constexpr uint32_t B76 = (1U << 12);  ///< B76
        constexpr uint32_t B77 = (1U << 13);  ///< B77
        constexpr uint32_t B78 = (1U << 14);  ///< B78
        constexpr uint32_t B79 = (1U << 15);  ///< B79
        constexpr uint32_t B80 = (1U << 16);  ///< B80
        constexpr uint32_t B81 = (1U << 17);  ///< B81
        constexpr uint32_t B82 = (1U << 18);  ///< B82
        constexpr uint32_t B83 = (1U << 19);  ///< B83
        constexpr uint32_t B84 = (1U << 20);  ///< B84
        constexpr uint32_t B85 = (1U << 21);  ///< B85
        constexpr uint32_t B86 = (1U << 22);  ///< B86
        constexpr uint32_t B87 = (1U << 23);  ///< B87
        constexpr uint32_t B88 = (1U << 24);  ///< B88
        constexpr uint32_t B89 = (1U << 25);  ///< B89
        constexpr uint32_t B90 = (1U << 26);  ///< B90
        constexpr uint32_t B91 = (1U << 27);  ///< B91
        constexpr uint32_t B92 = (1U << 28);  ///< B92
        constexpr uint32_t B93 = (1U << 29);  ///< B93
        constexpr uint32_t B94 = (1U << 30);  ///< B94
        constexpr uint32_t B95 = (1U << 31);  ///< B95
    }

    /// MPCBB1_VCTR3 Register bits
    namespace mpcbb1_vctr3_bits {
        constexpr uint32_t B96 = (1U << 0);  ///< B96
        constexpr uint32_t B97 = (1U << 1);  ///< B97
        constexpr uint32_t B98 = (1U << 2);  ///< B98
        constexpr uint32_t B99 = (1U << 3);  ///< B99
        constexpr uint32_t B100 = (1U << 4);  ///< B100
        constexpr uint32_t B101 = (1U << 5);  ///< B101
        constexpr uint32_t B102 = (1U << 6);  ///< B102
        constexpr uint32_t B103 = (1U << 7);  ///< B103
        constexpr uint32_t B104 = (1U << 8);  ///< B104
        constexpr uint32_t B105 = (1U << 9);  ///< B105
        constexpr uint32_t B106 = (1U << 10);  ///< B106
        constexpr uint32_t B107 = (1U << 11);  ///< B107
        constexpr uint32_t B108 = (1U << 12);  ///< B108
        constexpr uint32_t B109 = (1U << 13);  ///< B109
        constexpr uint32_t B110 = (1U << 14);  ///< B110
        constexpr uint32_t B111 = (1U << 15);  ///< B111
        constexpr uint32_t B112 = (1U << 16);  ///< B112
        constexpr uint32_t B113 = (1U << 17);  ///< B113
        constexpr uint32_t B114 = (1U << 18);  ///< B114
        constexpr uint32_t B115 = (1U << 19);  ///< B115
        constexpr uint32_t B116 = (1U << 20);  ///< B116
        constexpr uint32_t B117 = (1U << 21);  ///< B117
        constexpr uint32_t B118 = (1U << 22);  ///< B118
        constexpr uint32_t B119 = (1U << 23);  ///< B119
        constexpr uint32_t B120 = (1U << 24);  ///< B120
        constexpr uint32_t B121 = (1U << 25);  ///< B121
        constexpr uint32_t B122 = (1U << 26);  ///< B122
        constexpr uint32_t B123 = (1U << 27);  ///< B123
        constexpr uint32_t B124 = (1U << 28);  ///< B124
        constexpr uint32_t B125 = (1U << 29);  ///< B125
        constexpr uint32_t B126 = (1U << 30);  ///< B126
        constexpr uint32_t B127 = (1U << 31);  ///< B127
    }

    /// MPCBB1_VCTR4 Register bits
    namespace mpcbb1_vctr4_bits {
        constexpr uint32_t B128 = (1U << 0);  ///< B128
        constexpr uint32_t B129 = (1U << 1);  ///< B129
        constexpr uint32_t B130 = (1U << 2);  ///< B130
        constexpr uint32_t B131 = (1U << 3);  ///< B131
        constexpr uint32_t B132 = (1U << 4);  ///< B132
        constexpr uint32_t B133 = (1U << 5);  ///< B133
        constexpr uint32_t B134 = (1U << 6);  ///< B134
        constexpr uint32_t B135 = (1U << 7);  ///< B135
        constexpr uint32_t B136 = (1U << 8);  ///< B136
        constexpr uint32_t B137 = (1U << 9);  ///< B137
        constexpr uint32_t B138 = (1U << 10);  ///< B138
        constexpr uint32_t B139 = (1U << 11);  ///< B139
        constexpr uint32_t B140 = (1U << 12);  ///< B140
        constexpr uint32_t B141 = (1U << 13);  ///< B141
        constexpr uint32_t B142 = (1U << 14);  ///< B142
        constexpr uint32_t B143 = (1U << 15);  ///< B143
        constexpr uint32_t B144 = (1U << 16);  ///< B144
        constexpr uint32_t B145 = (1U << 17);  ///< B145
        constexpr uint32_t B146 = (1U << 18);  ///< B146
        constexpr uint32_t B147 = (1U << 19);  ///< B147
        constexpr uint32_t B148 = (1U << 20);  ///< B148
        constexpr uint32_t B149 = (1U << 21);  ///< B149
        constexpr uint32_t B150 = (1U << 22);  ///< B150
        constexpr uint32_t B151 = (1U << 23);  ///< B151
        constexpr uint32_t B152 = (1U << 24);  ///< B152
        constexpr uint32_t B153 = (1U << 25);  ///< B153
        constexpr uint32_t B154 = (1U << 26);  ///< B154
        constexpr uint32_t B155 = (1U << 27);  ///< B155
        constexpr uint32_t B156 = (1U << 28);  ///< B156
        constexpr uint32_t B157 = (1U << 29);  ///< B157
        constexpr uint32_t B158 = (1U << 30);  ///< B158
        constexpr uint32_t B159 = (1U << 31);  ///< B159
    }

    /// MPCBB1_VCTR5 Register bits
    namespace mpcbb1_vctr5_bits {
        constexpr uint32_t B160 = (1U << 0);  ///< B160
        constexpr uint32_t B161 = (1U << 1);  ///< B161
        constexpr uint32_t B162 = (1U << 2);  ///< B162
        constexpr uint32_t B163 = (1U << 3);  ///< B163
        constexpr uint32_t B164 = (1U << 4);  ///< B164
        constexpr uint32_t B165 = (1U << 5);  ///< B165
        constexpr uint32_t B166 = (1U << 6);  ///< B166
        constexpr uint32_t B167 = (1U << 7);  ///< B167
        constexpr uint32_t B168 = (1U << 8);  ///< B168
        constexpr uint32_t B169 = (1U << 9);  ///< B169
        constexpr uint32_t B170 = (1U << 10);  ///< B170
        constexpr uint32_t B171 = (1U << 11);  ///< B171
        constexpr uint32_t B172 = (1U << 12);  ///< B172
        constexpr uint32_t B173 = (1U << 13);  ///< B173
        constexpr uint32_t B174 = (1U << 14);  ///< B174
        constexpr uint32_t B175 = (1U << 15);  ///< B175
        constexpr uint32_t B176 = (1U << 16);  ///< B176
        constexpr uint32_t B177 = (1U << 17);  ///< B177
        constexpr uint32_t B178 = (1U << 18);  ///< B178
        constexpr uint32_t B179 = (1U << 19);  ///< B179
        constexpr uint32_t B180 = (1U << 20);  ///< B180
        constexpr uint32_t B181 = (1U << 21);  ///< B181
        constexpr uint32_t B182 = (1U << 22);  ///< B182
        constexpr uint32_t B183 = (1U << 23);  ///< B183
        constexpr uint32_t B184 = (1U << 24);  ///< B184
        constexpr uint32_t B185 = (1U << 25);  ///< B185
        constexpr uint32_t B186 = (1U << 26);  ///< B186
        constexpr uint32_t B187 = (1U << 27);  ///< B187
        constexpr uint32_t B188 = (1U << 28);  ///< B188
        constexpr uint32_t B189 = (1U << 29);  ///< B189
        constexpr uint32_t B190 = (1U << 30);  ///< B190
        constexpr uint32_t B191 = (1U << 31);  ///< B191
    }

    /// MPCBB1_VCTR6 Register bits
    namespace mpcbb1_vctr6_bits {
        constexpr uint32_t B192 = (1U << 0);  ///< B192
        constexpr uint32_t B193 = (1U << 1);  ///< B193
        constexpr uint32_t B194 = (1U << 2);  ///< B194
        constexpr uint32_t B195 = (1U << 3);  ///< B195
        constexpr uint32_t B196 = (1U << 4);  ///< B196
        constexpr uint32_t B197 = (1U << 5);  ///< B197
        constexpr uint32_t B198 = (1U << 6);  ///< B198
        constexpr uint32_t B199 = (1U << 7);  ///< B199
        constexpr uint32_t B200 = (1U << 8);  ///< B200
        constexpr uint32_t B201 = (1U << 9);  ///< B201
        constexpr uint32_t B202 = (1U << 10);  ///< B202
        constexpr uint32_t B203 = (1U << 11);  ///< B203
        constexpr uint32_t B204 = (1U << 12);  ///< B204
        constexpr uint32_t B205 = (1U << 13);  ///< B205
        constexpr uint32_t B206 = (1U << 14);  ///< B206
        constexpr uint32_t B207 = (1U << 15);  ///< B207
        constexpr uint32_t B208 = (1U << 16);  ///< B208
        constexpr uint32_t B209 = (1U << 17);  ///< B209
        constexpr uint32_t B210 = (1U << 18);  ///< B210
        constexpr uint32_t B211 = (1U << 19);  ///< B211
        constexpr uint32_t B212 = (1U << 20);  ///< B212
        constexpr uint32_t B213 = (1U << 21);  ///< B213
        constexpr uint32_t B214 = (1U << 22);  ///< B214
        constexpr uint32_t B215 = (1U << 23);  ///< B215
        constexpr uint32_t B216 = (1U << 24);  ///< B216
        constexpr uint32_t B217 = (1U << 25);  ///< B217
        constexpr uint32_t B218 = (1U << 26);  ///< B218
        constexpr uint32_t B219 = (1U << 27);  ///< B219
        constexpr uint32_t B220 = (1U << 28);  ///< B220
        constexpr uint32_t B221 = (1U << 29);  ///< B221
        constexpr uint32_t B222 = (1U << 30);  ///< B222
        constexpr uint32_t B223 = (1U << 31);  ///< B223
    }

    /// MPCBB1_VCTR7 Register bits
    namespace mpcbb1_vctr7_bits {
        constexpr uint32_t B224 = (1U << 0);  ///< B224
        constexpr uint32_t B225 = (1U << 1);  ///< B225
        constexpr uint32_t B226 = (1U << 2);  ///< B226
        constexpr uint32_t B227 = (1U << 3);  ///< B227
        constexpr uint32_t B228 = (1U << 4);  ///< B228
        constexpr uint32_t B229 = (1U << 5);  ///< B229
        constexpr uint32_t B230 = (1U << 6);  ///< B230
        constexpr uint32_t B231 = (1U << 7);  ///< B231
        constexpr uint32_t B232 = (1U << 8);  ///< B232
        constexpr uint32_t B233 = (1U << 9);  ///< B233
        constexpr uint32_t B234 = (1U << 10);  ///< B234
        constexpr uint32_t B235 = (1U << 11);  ///< B235
        constexpr uint32_t B236 = (1U << 12);  ///< B236
        constexpr uint32_t B237 = (1U << 13);  ///< B237
        constexpr uint32_t B238 = (1U << 14);  ///< B238
        constexpr uint32_t B239 = (1U << 15);  ///< B239
        constexpr uint32_t B240 = (1U << 16);  ///< B240
        constexpr uint32_t B241 = (1U << 17);  ///< B241
        constexpr uint32_t B242 = (1U << 18);  ///< B242
        constexpr uint32_t B243 = (1U << 19);  ///< B243
        constexpr uint32_t B244 = (1U << 20);  ///< B244
        constexpr uint32_t B245 = (1U << 21);  ///< B245
        constexpr uint32_t B246 = (1U << 22);  ///< B246
        constexpr uint32_t B247 = (1U << 23);  ///< B247
        constexpr uint32_t B248 = (1U << 24);  ///< B248
        constexpr uint32_t B249 = (1U << 25);  ///< B249
        constexpr uint32_t B250 = (1U << 26);  ///< B250
        constexpr uint32_t B251 = (1U << 27);  ///< B251
        constexpr uint32_t B252 = (1U << 28);  ///< B252
        constexpr uint32_t B253 = (1U << 29);  ///< B253
        constexpr uint32_t B254 = (1U << 30);  ///< B254
        constexpr uint32_t B255 = (1U << 31);  ///< B255
    }

    /// MPCBB1_VCTR8 Register bits
    namespace mpcbb1_vctr8_bits {
        constexpr uint32_t B256 = (1U << 0);  ///< B256
        constexpr uint32_t B257 = (1U << 1);  ///< B257
        constexpr uint32_t B258 = (1U << 2);  ///< B258
        constexpr uint32_t B259 = (1U << 3);  ///< B259
        constexpr uint32_t B260 = (1U << 4);  ///< B260
        constexpr uint32_t B261 = (1U << 5);  ///< B261
        constexpr uint32_t B262 = (1U << 6);  ///< B262
        constexpr uint32_t B263 = (1U << 7);  ///< B263
        constexpr uint32_t B264 = (1U << 8);  ///< B264
        constexpr uint32_t B265 = (1U << 9);  ///< B265
        constexpr uint32_t B266 = (1U << 10);  ///< B266
        constexpr uint32_t B267 = (1U << 11);  ///< B267
        constexpr uint32_t B268 = (1U << 12);  ///< B268
        constexpr uint32_t B269 = (1U << 13);  ///< B269
        constexpr uint32_t B270 = (1U << 14);  ///< B270
        constexpr uint32_t B271 = (1U << 15);  ///< B271
        constexpr uint32_t B272 = (1U << 16);  ///< B272
        constexpr uint32_t B273 = (1U << 17);  ///< B273
        constexpr uint32_t B274 = (1U << 18);  ///< B274
        constexpr uint32_t B275 = (1U << 19);  ///< B275
        constexpr uint32_t B276 = (1U << 20);  ///< B276
        constexpr uint32_t B277 = (1U << 21);  ///< B277
        constexpr uint32_t B278 = (1U << 22);  ///< B278
        constexpr uint32_t B279 = (1U << 23);  ///< B279
        constexpr uint32_t B280 = (1U << 24);  ///< B280
        constexpr uint32_t B281 = (1U << 25);  ///< B281
        constexpr uint32_t B282 = (1U << 26);  ///< B282
        constexpr uint32_t B283 = (1U << 27);  ///< B283
        constexpr uint32_t B284 = (1U << 28);  ///< B284
        constexpr uint32_t B285 = (1U << 29);  ///< B285
        constexpr uint32_t B286 = (1U << 30);  ///< B286
        constexpr uint32_t B287 = (1U << 31);  ///< B287
    }

    /// MPCBB1_VCTR9 Register bits
    namespace mpcbb1_vctr9_bits {
        constexpr uint32_t B288 = (1U << 0);  ///< B288
        constexpr uint32_t B289 = (1U << 1);  ///< B289
        constexpr uint32_t B290 = (1U << 2);  ///< B290
        constexpr uint32_t B291 = (1U << 3);  ///< B291
        constexpr uint32_t B292 = (1U << 4);  ///< B292
        constexpr uint32_t B293 = (1U << 5);  ///< B293
        constexpr uint32_t B294 = (1U << 6);  ///< B294
        constexpr uint32_t B295 = (1U << 7);  ///< B295
        constexpr uint32_t B296 = (1U << 8);  ///< B296
        constexpr uint32_t B297 = (1U << 9);  ///< B297
        constexpr uint32_t B298 = (1U << 10);  ///< B298
        constexpr uint32_t B299 = (1U << 11);  ///< B299
        constexpr uint32_t B300 = (1U << 12);  ///< B300
        constexpr uint32_t B301 = (1U << 13);  ///< B301
        constexpr uint32_t B302 = (1U << 14);  ///< B302
        constexpr uint32_t B303 = (1U << 15);  ///< B303
        constexpr uint32_t B304 = (1U << 16);  ///< B304
        constexpr uint32_t B305 = (1U << 17);  ///< B305
        constexpr uint32_t B306 = (1U << 18);  ///< B306
        constexpr uint32_t B307 = (1U << 19);  ///< B307
        constexpr uint32_t B308 = (1U << 20);  ///< B308
        constexpr uint32_t B309 = (1U << 21);  ///< B309
        constexpr uint32_t B310 = (1U << 22);  ///< B310
        constexpr uint32_t B311 = (1U << 23);  ///< B311
        constexpr uint32_t B312 = (1U << 24);  ///< B312
        constexpr uint32_t B313 = (1U << 25);  ///< B313
        constexpr uint32_t B314 = (1U << 26);  ///< B314
        constexpr uint32_t B315 = (1U << 27);  ///< B315
        constexpr uint32_t B316 = (1U << 28);  ///< B316
        constexpr uint32_t B317 = (1U << 29);  ///< B317
        constexpr uint32_t B318 = (1U << 30);  ///< B318
        constexpr uint32_t B319 = (1U << 31);  ///< B319
    }

    /// MPCBB1_VCTR10 Register bits
    namespace mpcbb1_vctr10_bits {
        constexpr uint32_t B320 = (1U << 0);  ///< B320
        constexpr uint32_t B321 = (1U << 1);  ///< B321
        constexpr uint32_t B322 = (1U << 2);  ///< B322
        constexpr uint32_t B323 = (1U << 3);  ///< B323
        constexpr uint32_t B324 = (1U << 4);  ///< B324
        constexpr uint32_t B325 = (1U << 5);  ///< B325
        constexpr uint32_t B326 = (1U << 6);  ///< B326
        constexpr uint32_t B327 = (1U << 7);  ///< B327
        constexpr uint32_t B328 = (1U << 8);  ///< B328
        constexpr uint32_t B329 = (1U << 9);  ///< B329
        constexpr uint32_t B330 = (1U << 10);  ///< B330
        constexpr uint32_t B331 = (1U << 11);  ///< B331
        constexpr uint32_t B332 = (1U << 12);  ///< B332
        constexpr uint32_t B333 = (1U << 13);  ///< B333
        constexpr uint32_t B334 = (1U << 14);  ///< B334
        constexpr uint32_t B335 = (1U << 15);  ///< B335
        constexpr uint32_t B336 = (1U << 16);  ///< B336
        constexpr uint32_t B337 = (1U << 17);  ///< B337
        constexpr uint32_t B338 = (1U << 18);  ///< B338
        constexpr uint32_t B339 = (1U << 19);  ///< B339
        constexpr uint32_t B340 = (1U << 20);  ///< B340
        constexpr uint32_t B341 = (1U << 21);  ///< B341
        constexpr uint32_t B342 = (1U << 22);  ///< B342
        constexpr uint32_t B343 = (1U << 23);  ///< B343
        constexpr uint32_t B344 = (1U << 24);  ///< B344
        constexpr uint32_t B345 = (1U << 25);  ///< B345
        constexpr uint32_t B346 = (1U << 26);  ///< B346
        constexpr uint32_t B347 = (1U << 27);  ///< B347
        constexpr uint32_t B348 = (1U << 28);  ///< B348
        constexpr uint32_t B349 = (1U << 29);  ///< B349
        constexpr uint32_t B350 = (1U << 30);  ///< B350
        constexpr uint32_t B351 = (1U << 31);  ///< B351
    }

    /// MPCBB1_VCTR11 Register bits
    namespace mpcbb1_vctr11_bits {
        constexpr uint32_t B352 = (1U << 0);  ///< B352
        constexpr uint32_t B353 = (1U << 1);  ///< B353
        constexpr uint32_t B354 = (1U << 2);  ///< B354
        constexpr uint32_t B355 = (1U << 3);  ///< B355
        constexpr uint32_t B356 = (1U << 4);  ///< B356
        constexpr uint32_t B357 = (1U << 5);  ///< B357
        constexpr uint32_t B358 = (1U << 6);  ///< B358
        constexpr uint32_t B359 = (1U << 7);  ///< B359
        constexpr uint32_t B360 = (1U << 8);  ///< B360
        constexpr uint32_t B361 = (1U << 9);  ///< B361
        constexpr uint32_t B362 = (1U << 10);  ///< B362
        constexpr uint32_t B363 = (1U << 11);  ///< B363
        constexpr uint32_t B364 = (1U << 12);  ///< B364
        constexpr uint32_t B365 = (1U << 13);  ///< B365
        constexpr uint32_t B366 = (1U << 14);  ///< B366
        constexpr uint32_t B367 = (1U << 15);  ///< B367
        constexpr uint32_t B368 = (1U << 16);  ///< B368
        constexpr uint32_t B369 = (1U << 17);  ///< B369
        constexpr uint32_t B370 = (1U << 18);  ///< B370
        constexpr uint32_t B371 = (1U << 19);  ///< B371
        constexpr uint32_t B372 = (1U << 20);  ///< B372
        constexpr uint32_t B373 = (1U << 21);  ///< B373
        constexpr uint32_t B374 = (1U << 22);  ///< B374
        constexpr uint32_t B375 = (1U << 23);  ///< B375
        constexpr uint32_t B376 = (1U << 24);  ///< B376
        constexpr uint32_t B377 = (1U << 25);  ///< B377
        constexpr uint32_t B378 = (1U << 26);  ///< B378
        constexpr uint32_t B379 = (1U << 27);  ///< B379
        constexpr uint32_t B380 = (1U << 28);  ///< B380
        constexpr uint32_t B381 = (1U << 29);  ///< B381
        constexpr uint32_t B382 = (1U << 30);  ///< B382
        constexpr uint32_t B383 = (1U << 31);  ///< B383
    }

    /// MPCBB1_VCTR12 Register bits
    namespace mpcbb1_vctr12_bits {
        constexpr uint32_t B384 = (1U << 0);  ///< B384
        constexpr uint32_t B385 = (1U << 1);  ///< B385
        constexpr uint32_t B386 = (1U << 2);  ///< B386
        constexpr uint32_t B387 = (1U << 3);  ///< B387
        constexpr uint32_t B388 = (1U << 4);  ///< B388
        constexpr uint32_t B389 = (1U << 5);  ///< B389
        constexpr uint32_t B390 = (1U << 6);  ///< B390
        constexpr uint32_t B391 = (1U << 7);  ///< B391
        constexpr uint32_t B392 = (1U << 8);  ///< B392
        constexpr uint32_t B393 = (1U << 9);  ///< B393
        constexpr uint32_t B394 = (1U << 10);  ///< B394
        constexpr uint32_t B395 = (1U << 11);  ///< B395
        constexpr uint32_t B396 = (1U << 12);  ///< B396
        constexpr uint32_t B397 = (1U << 13);  ///< B397
        constexpr uint32_t B398 = (1U << 14);  ///< B398
        constexpr uint32_t B399 = (1U << 15);  ///< B399
        constexpr uint32_t B400 = (1U << 16);  ///< B400
        constexpr uint32_t B401 = (1U << 17);  ///< B401
        constexpr uint32_t B402 = (1U << 18);  ///< B402
        constexpr uint32_t B403 = (1U << 19);  ///< B403
        constexpr uint32_t B404 = (1U << 20);  ///< B404
        constexpr uint32_t B405 = (1U << 21);  ///< B405
        constexpr uint32_t B406 = (1U << 22);  ///< B406
        constexpr uint32_t B407 = (1U << 23);  ///< B407
        constexpr uint32_t B408 = (1U << 24);  ///< B408
        constexpr uint32_t B409 = (1U << 25);  ///< B409
        constexpr uint32_t B410 = (1U << 26);  ///< B410
        constexpr uint32_t B411 = (1U << 27);  ///< B411
        constexpr uint32_t B412 = (1U << 28);  ///< B412
        constexpr uint32_t B413 = (1U << 29);  ///< B413
        constexpr uint32_t B414 = (1U << 30);  ///< B414
        constexpr uint32_t B415 = (1U << 31);  ///< B415
    }

    /// MPCBB1_VCTR13 Register bits
    namespace mpcbb1_vctr13_bits {
        constexpr uint32_t B416 = (1U << 0);  ///< B416
        constexpr uint32_t B417 = (1U << 1);  ///< B417
        constexpr uint32_t B418 = (1U << 2);  ///< B418
        constexpr uint32_t B419 = (1U << 3);  ///< B419
        constexpr uint32_t B420 = (1U << 4);  ///< B420
        constexpr uint32_t B421 = (1U << 5);  ///< B421
        constexpr uint32_t B422 = (1U << 6);  ///< B422
        constexpr uint32_t B423 = (1U << 7);  ///< B423
        constexpr uint32_t B424 = (1U << 8);  ///< B424
        constexpr uint32_t B425 = (1U << 9);  ///< B425
        constexpr uint32_t B426 = (1U << 10);  ///< B426
        constexpr uint32_t B427 = (1U << 11);  ///< B427
        constexpr uint32_t B428 = (1U << 12);  ///< B428
        constexpr uint32_t B429 = (1U << 13);  ///< B429
        constexpr uint32_t B430 = (1U << 14);  ///< B430
        constexpr uint32_t B431 = (1U << 15);  ///< B431
        constexpr uint32_t B432 = (1U << 16);  ///< B432
        constexpr uint32_t B433 = (1U << 17);  ///< B433
        constexpr uint32_t B434 = (1U << 18);  ///< B434
        constexpr uint32_t B435 = (1U << 19);  ///< B435
        constexpr uint32_t B436 = (1U << 20);  ///< B436
        constexpr uint32_t B437 = (1U << 21);  ///< B437
        constexpr uint32_t B438 = (1U << 22);  ///< B438
        constexpr uint32_t B439 = (1U << 23);  ///< B439
        constexpr uint32_t B440 = (1U << 24);  ///< B440
        constexpr uint32_t B441 = (1U << 25);  ///< B441
        constexpr uint32_t B442 = (1U << 26);  ///< B442
        constexpr uint32_t B443 = (1U << 27);  ///< B443
        constexpr uint32_t B444 = (1U << 28);  ///< B444
        constexpr uint32_t B445 = (1U << 29);  ///< B445
        constexpr uint32_t B446 = (1U << 30);  ///< B446
        constexpr uint32_t B447 = (1U << 31);  ///< B447
    }

    /// MPCBB1_VCTR14 Register bits
    namespace mpcbb1_vctr14_bits {
        constexpr uint32_t B448 = (1U << 0);  ///< B448
        constexpr uint32_t B449 = (1U << 1);  ///< B449
        constexpr uint32_t B450 = (1U << 2);  ///< B450
        constexpr uint32_t B451 = (1U << 3);  ///< B451
        constexpr uint32_t B452 = (1U << 4);  ///< B452
        constexpr uint32_t B453 = (1U << 5);  ///< B453
        constexpr uint32_t B454 = (1U << 6);  ///< B454
        constexpr uint32_t B455 = (1U << 7);  ///< B455
        constexpr uint32_t B456 = (1U << 8);  ///< B456
        constexpr uint32_t B457 = (1U << 9);  ///< B457
        constexpr uint32_t B458 = (1U << 10);  ///< B458
        constexpr uint32_t B459 = (1U << 11);  ///< B459
        constexpr uint32_t B460 = (1U << 12);  ///< B460
        constexpr uint32_t B461 = (1U << 13);  ///< B461
        constexpr uint32_t B462 = (1U << 14);  ///< B462
        constexpr uint32_t B463 = (1U << 15);  ///< B463
        constexpr uint32_t B464 = (1U << 16);  ///< B464
        constexpr uint32_t B465 = (1U << 17);  ///< B465
        constexpr uint32_t B466 = (1U << 18);  ///< B466
        constexpr uint32_t B467 = (1U << 19);  ///< B467
        constexpr uint32_t B468 = (1U << 20);  ///< B468
        constexpr uint32_t B469 = (1U << 21);  ///< B469
        constexpr uint32_t B470 = (1U << 22);  ///< B470
        constexpr uint32_t B471 = (1U << 23);  ///< B471
        constexpr uint32_t B472 = (1U << 24);  ///< B472
        constexpr uint32_t B473 = (1U << 25);  ///< B473
        constexpr uint32_t B474 = (1U << 26);  ///< B474
        constexpr uint32_t B475 = (1U << 27);  ///< B475
        constexpr uint32_t B476 = (1U << 28);  ///< B476
        constexpr uint32_t B477 = (1U << 29);  ///< B477
        constexpr uint32_t B478 = (1U << 30);  ///< B478
        constexpr uint32_t B479 = (1U << 31);  ///< B479
    }

    /// MPCBB1_VCTR15 Register bits
    namespace mpcbb1_vctr15_bits {
        constexpr uint32_t B480 = (1U << 0);  ///< B480
        constexpr uint32_t B481 = (1U << 1);  ///< B481
        constexpr uint32_t B482 = (1U << 2);  ///< B482
        constexpr uint32_t B483 = (1U << 3);  ///< B483
        constexpr uint32_t B484 = (1U << 4);  ///< B484
        constexpr uint32_t B485 = (1U << 5);  ///< B485
        constexpr uint32_t B486 = (1U << 6);  ///< B486
        constexpr uint32_t B487 = (1U << 7);  ///< B487
        constexpr uint32_t B488 = (1U << 8);  ///< B488
        constexpr uint32_t B489 = (1U << 9);  ///< B489
        constexpr uint32_t B490 = (1U << 10);  ///< B490
        constexpr uint32_t B491 = (1U << 11);  ///< B491
        constexpr uint32_t B492 = (1U << 12);  ///< B492
        constexpr uint32_t B493 = (1U << 13);  ///< B493
        constexpr uint32_t B494 = (1U << 14);  ///< B494
        constexpr uint32_t B495 = (1U << 15);  ///< B495
        constexpr uint32_t B496 = (1U << 16);  ///< B496
        constexpr uint32_t B497 = (1U << 17);  ///< B497
        constexpr uint32_t B498 = (1U << 18);  ///< B498
        constexpr uint32_t B499 = (1U << 19);  ///< B499
        constexpr uint32_t B500 = (1U << 20);  ///< B500
        constexpr uint32_t B501 = (1U << 21);  ///< B501
        constexpr uint32_t B502 = (1U << 22);  ///< B502
        constexpr uint32_t B503 = (1U << 23);  ///< B503
        constexpr uint32_t B504 = (1U << 24);  ///< B504
        constexpr uint32_t B505 = (1U << 25);  ///< B505
        constexpr uint32_t B506 = (1U << 26);  ///< B506
        constexpr uint32_t B507 = (1U << 27);  ///< B507
        constexpr uint32_t B508 = (1U << 28);  ///< B508
        constexpr uint32_t B509 = (1U << 29);  ///< B509
        constexpr uint32_t B510 = (1U << 30);  ///< B510
        constexpr uint32_t B511 = (1U << 31);  ///< B511
    }

    /// MPCBB1_VCTR16 Register bits
    namespace mpcbb1_vctr16_bits {
        constexpr uint32_t B512 = (1U << 0);  ///< B512
        constexpr uint32_t B513 = (1U << 1);  ///< B513
        constexpr uint32_t B514 = (1U << 2);  ///< B514
        constexpr uint32_t B515 = (1U << 3);  ///< B515
        constexpr uint32_t B516 = (1U << 4);  ///< B516
        constexpr uint32_t B517 = (1U << 5);  ///< B517
        constexpr uint32_t B518 = (1U << 6);  ///< B518
        constexpr uint32_t B519 = (1U << 7);  ///< B519
        constexpr uint32_t B520 = (1U << 8);  ///< B520
        constexpr uint32_t B521 = (1U << 9);  ///< B521
        constexpr uint32_t B522 = (1U << 10);  ///< B522
        constexpr uint32_t B523 = (1U << 11);  ///< B523
        constexpr uint32_t B524 = (1U << 12);  ///< B524
        constexpr uint32_t B525 = (1U << 13);  ///< B525
        constexpr uint32_t B526 = (1U << 14);  ///< B526
        constexpr uint32_t B527 = (1U << 15);  ///< B527
        constexpr uint32_t B528 = (1U << 16);  ///< B528
        constexpr uint32_t B529 = (1U << 17);  ///< B529
        constexpr uint32_t B530 = (1U << 18);  ///< B530
        constexpr uint32_t B531 = (1U << 19);  ///< B531
        constexpr uint32_t B532 = (1U << 20);  ///< B532
        constexpr uint32_t B533 = (1U << 21);  ///< B533
        constexpr uint32_t B534 = (1U << 22);  ///< B534
        constexpr uint32_t B535 = (1U << 23);  ///< B535
        constexpr uint32_t B536 = (1U << 24);  ///< B536
        constexpr uint32_t B537 = (1U << 25);  ///< B537
        constexpr uint32_t B538 = (1U << 26);  ///< B538
        constexpr uint32_t B539 = (1U << 27);  ///< B539
        constexpr uint32_t B540 = (1U << 28);  ///< B540
        constexpr uint32_t B541 = (1U << 29);  ///< B541
        constexpr uint32_t B542 = (1U << 30);  ///< B542
        constexpr uint32_t B543 = (1U << 31);  ///< B543
    }

    /// MPCBB1_VCTR17 Register bits
    namespace mpcbb1_vctr17_bits {
        constexpr uint32_t B544 = (1U << 0);  ///< B544
        constexpr uint32_t B545 = (1U << 1);  ///< B545
        constexpr uint32_t B546 = (1U << 2);  ///< B546
        constexpr uint32_t B547 = (1U << 3);  ///< B547
        constexpr uint32_t B548 = (1U << 4);  ///< B548
        constexpr uint32_t B549 = (1U << 5);  ///< B549
        constexpr uint32_t B550 = (1U << 6);  ///< B550
        constexpr uint32_t B551 = (1U << 7);  ///< B551
        constexpr uint32_t B552 = (1U << 8);  ///< B552
        constexpr uint32_t B553 = (1U << 9);  ///< B553
        constexpr uint32_t B554 = (1U << 10);  ///< B554
        constexpr uint32_t B555 = (1U << 11);  ///< B555
        constexpr uint32_t B556 = (1U << 12);  ///< B556
        constexpr uint32_t B557 = (1U << 13);  ///< B557
        constexpr uint32_t B558 = (1U << 14);  ///< B558
        constexpr uint32_t B559 = (1U << 15);  ///< B559
        constexpr uint32_t B560 = (1U << 16);  ///< B560
        constexpr uint32_t B561 = (1U << 17);  ///< B561
        constexpr uint32_t B562 = (1U << 18);  ///< B562
        constexpr uint32_t B563 = (1U << 19);  ///< B563
        constexpr uint32_t B564 = (1U << 20);  ///< B564
        constexpr uint32_t B565 = (1U << 21);  ///< B565
        constexpr uint32_t B566 = (1U << 22);  ///< B566
        constexpr uint32_t B567 = (1U << 23);  ///< B567
        constexpr uint32_t B568 = (1U << 24);  ///< B568
        constexpr uint32_t B569 = (1U << 25);  ///< B569
        constexpr uint32_t B570 = (1U << 26);  ///< B570
        constexpr uint32_t B571 = (1U << 27);  ///< B571
        constexpr uint32_t B572 = (1U << 28);  ///< B572
        constexpr uint32_t B573 = (1U << 29);  ///< B573
        constexpr uint32_t B574 = (1U << 30);  ///< B574
        constexpr uint32_t B575 = (1U << 31);  ///< B575
    }

    /// MPCBB1_VCTR18 Register bits
    namespace mpcbb1_vctr18_bits {
        constexpr uint32_t B576 = (1U << 0);  ///< B576
        constexpr uint32_t B577 = (1U << 1);  ///< B577
        constexpr uint32_t B578 = (1U << 2);  ///< B578
        constexpr uint32_t B579 = (1U << 3);  ///< B579
        constexpr uint32_t B580 = (1U << 4);  ///< B580
        constexpr uint32_t B581 = (1U << 5);  ///< B581
        constexpr uint32_t B582 = (1U << 6);  ///< B582
        constexpr uint32_t B583 = (1U << 7);  ///< B583
        constexpr uint32_t B584 = (1U << 8);  ///< B584
        constexpr uint32_t B585 = (1U << 9);  ///< B585
        constexpr uint32_t B586 = (1U << 10);  ///< B586
        constexpr uint32_t B587 = (1U << 11);  ///< B587
        constexpr uint32_t B588 = (1U << 12);  ///< B588
        constexpr uint32_t B589 = (1U << 13);  ///< B589
        constexpr uint32_t B590 = (1U << 14);  ///< B590
        constexpr uint32_t B591 = (1U << 15);  ///< B591
        constexpr uint32_t B592 = (1U << 16);  ///< B592
        constexpr uint32_t B593 = (1U << 17);  ///< B593
        constexpr uint32_t B594 = (1U << 18);  ///< B594
        constexpr uint32_t B595 = (1U << 19);  ///< B595
        constexpr uint32_t B596 = (1U << 20);  ///< B596
        constexpr uint32_t B597 = (1U << 21);  ///< B597
        constexpr uint32_t B598 = (1U << 22);  ///< B598
        constexpr uint32_t B599 = (1U << 23);  ///< B599
        constexpr uint32_t B600 = (1U << 24);  ///< B600
        constexpr uint32_t B601 = (1U << 25);  ///< B601
        constexpr uint32_t B602 = (1U << 26);  ///< B602
        constexpr uint32_t B603 = (1U << 27);  ///< B603
        constexpr uint32_t B604 = (1U << 28);  ///< B604
        constexpr uint32_t B605 = (1U << 29);  ///< B605
        constexpr uint32_t B606 = (1U << 30);  ///< B606
        constexpr uint32_t B607 = (1U << 31);  ///< B607
    }

    /// MPCBB1_VCTR19 Register bits
    namespace mpcbb1_vctr19_bits {
        constexpr uint32_t B608 = (1U << 0);  ///< B608
        constexpr uint32_t B609 = (1U << 1);  ///< B609
        constexpr uint32_t B610 = (1U << 2);  ///< B610
        constexpr uint32_t B611 = (1U << 3);  ///< B611
        constexpr uint32_t B612 = (1U << 4);  ///< B612
        constexpr uint32_t B613 = (1U << 5);  ///< B613
        constexpr uint32_t B614 = (1U << 6);  ///< B614
        constexpr uint32_t B615 = (1U << 7);  ///< B615
        constexpr uint32_t B616 = (1U << 8);  ///< B616
        constexpr uint32_t B617 = (1U << 9);  ///< B617
        constexpr uint32_t B618 = (1U << 10);  ///< B618
        constexpr uint32_t B619 = (1U << 11);  ///< B619
        constexpr uint32_t B620 = (1U << 12);  ///< B620
        constexpr uint32_t B621 = (1U << 13);  ///< B621
        constexpr uint32_t B622 = (1U << 14);  ///< B622
        constexpr uint32_t B623 = (1U << 15);  ///< B623
        constexpr uint32_t B624 = (1U << 16);  ///< B624
        constexpr uint32_t B625 = (1U << 17);  ///< B625
        constexpr uint32_t B626 = (1U << 18);  ///< B626
        constexpr uint32_t B627 = (1U << 19);  ///< B627
        constexpr uint32_t B628 = (1U << 20);  ///< B628
        constexpr uint32_t B629 = (1U << 21);  ///< B629
        constexpr uint32_t B630 = (1U << 22);  ///< B630
        constexpr uint32_t B631 = (1U << 23);  ///< B631
        constexpr uint32_t B632 = (1U << 24);  ///< B632
        constexpr uint32_t B633 = (1U << 25);  ///< B633
        constexpr uint32_t B634 = (1U << 26);  ///< B634
        constexpr uint32_t B635 = (1U << 27);  ///< B635
        constexpr uint32_t B636 = (1U << 28);  ///< B636
        constexpr uint32_t B637 = (1U << 29);  ///< B637
        constexpr uint32_t B638 = (1U << 30);  ///< B638
        constexpr uint32_t B639 = (1U << 31);  ///< B639
    }

    /// MPCBB1_VCTR20 Register bits
    namespace mpcbb1_vctr20_bits {
        constexpr uint32_t B640 = (1U << 0);  ///< B640
        constexpr uint32_t B641 = (1U << 1);  ///< B641
        constexpr uint32_t B642 = (1U << 2);  ///< B642
        constexpr uint32_t B643 = (1U << 3);  ///< B643
        constexpr uint32_t B644 = (1U << 4);  ///< B644
        constexpr uint32_t B645 = (1U << 5);  ///< B645
        constexpr uint32_t B646 = (1U << 6);  ///< B646
        constexpr uint32_t B647 = (1U << 7);  ///< B647
        constexpr uint32_t B648 = (1U << 8);  ///< B648
        constexpr uint32_t B649 = (1U << 9);  ///< B649
        constexpr uint32_t B650 = (1U << 10);  ///< B650
        constexpr uint32_t B651 = (1U << 11);  ///< B651
        constexpr uint32_t B652 = (1U << 12);  ///< B652
        constexpr uint32_t B653 = (1U << 13);  ///< B653
        constexpr uint32_t B654 = (1U << 14);  ///< B654
        constexpr uint32_t B655 = (1U << 15);  ///< B655
        constexpr uint32_t B656 = (1U << 16);  ///< B656
        constexpr uint32_t B657 = (1U << 17);  ///< B657
        constexpr uint32_t B658 = (1U << 18);  ///< B658
        constexpr uint32_t B659 = (1U << 19);  ///< B659
        constexpr uint32_t B660 = (1U << 20);  ///< B660
        constexpr uint32_t B661 = (1U << 21);  ///< B661
        constexpr uint32_t B662 = (1U << 22);  ///< B662
        constexpr uint32_t B663 = (1U << 23);  ///< B663
        constexpr uint32_t B664 = (1U << 24);  ///< B664
        constexpr uint32_t B665 = (1U << 25);  ///< B665
        constexpr uint32_t B666 = (1U << 26);  ///< B666
        constexpr uint32_t B667 = (1U << 27);  ///< B667
        constexpr uint32_t B668 = (1U << 28);  ///< B668
        constexpr uint32_t B669 = (1U << 29);  ///< B669
        constexpr uint32_t B670 = (1U << 30);  ///< B670
        constexpr uint32_t B671 = (1U << 31);  ///< B671
    }

    /// MPCBB1_VCTR21 Register bits
    namespace mpcbb1_vctr21_bits {
        constexpr uint32_t B672 = (1U << 0);  ///< B672
        constexpr uint32_t B673 = (1U << 1);  ///< B673
        constexpr uint32_t B674 = (1U << 2);  ///< B674
        constexpr uint32_t B675 = (1U << 3);  ///< B675
        constexpr uint32_t B676 = (1U << 4);  ///< B676
        constexpr uint32_t B677 = (1U << 5);  ///< B677
        constexpr uint32_t B678 = (1U << 6);  ///< B678
        constexpr uint32_t B679 = (1U << 7);  ///< B679
        constexpr uint32_t B680 = (1U << 8);  ///< B680
        constexpr uint32_t B681 = (1U << 9);  ///< B681
        constexpr uint32_t B682 = (1U << 10);  ///< B682
        constexpr uint32_t B683 = (1U << 11);  ///< B683
        constexpr uint32_t B684 = (1U << 12);  ///< B684
        constexpr uint32_t B685 = (1U << 13);  ///< B685
        constexpr uint32_t B686 = (1U << 14);  ///< B686
        constexpr uint32_t B687 = (1U << 15);  ///< B687
        constexpr uint32_t B688 = (1U << 16);  ///< B688
        constexpr uint32_t B689 = (1U << 17);  ///< B689
        constexpr uint32_t B690 = (1U << 18);  ///< B690
        constexpr uint32_t B691 = (1U << 19);  ///< B691
        constexpr uint32_t B692 = (1U << 20);  ///< B692
        constexpr uint32_t B693 = (1U << 21);  ///< B693
        constexpr uint32_t B694 = (1U << 22);  ///< B694
        constexpr uint32_t B695 = (1U << 23);  ///< B695
        constexpr uint32_t B696 = (1U << 24);  ///< B696
        constexpr uint32_t B697 = (1U << 25);  ///< B697
        constexpr uint32_t B698 = (1U << 26);  ///< B698
        constexpr uint32_t B699 = (1U << 27);  ///< B699
        constexpr uint32_t B700 = (1U << 28);  ///< B700
        constexpr uint32_t B701 = (1U << 29);  ///< B701
        constexpr uint32_t B702 = (1U << 30);  ///< B702
        constexpr uint32_t B703 = (1U << 31);  ///< B703
    }

    /// MPCBB1_VCTR22 Register bits
    namespace mpcbb1_vctr22_bits {
        constexpr uint32_t B704 = (1U << 0);  ///< B704
        constexpr uint32_t B705 = (1U << 1);  ///< B705
        constexpr uint32_t B706 = (1U << 2);  ///< B706
        constexpr uint32_t B707 = (1U << 3);  ///< B707
        constexpr uint32_t B708 = (1U << 4);  ///< B708
        constexpr uint32_t B709 = (1U << 5);  ///< B709
        constexpr uint32_t B710 = (1U << 6);  ///< B710
        constexpr uint32_t B711 = (1U << 7);  ///< B711
        constexpr uint32_t B712 = (1U << 8);  ///< B712
        constexpr uint32_t B713 = (1U << 9);  ///< B713
        constexpr uint32_t B714 = (1U << 10);  ///< B714
        constexpr uint32_t B715 = (1U << 11);  ///< B715
        constexpr uint32_t B716 = (1U << 12);  ///< B716
        constexpr uint32_t B717 = (1U << 13);  ///< B717
        constexpr uint32_t B718 = (1U << 14);  ///< B718
        constexpr uint32_t B719 = (1U << 15);  ///< B719
        constexpr uint32_t B720 = (1U << 16);  ///< B720
        constexpr uint32_t B721 = (1U << 17);  ///< B721
        constexpr uint32_t B722 = (1U << 18);  ///< B722
        constexpr uint32_t B723 = (1U << 19);  ///< B723
        constexpr uint32_t B724 = (1U << 20);  ///< B724
        constexpr uint32_t B725 = (1U << 21);  ///< B725
        constexpr uint32_t B726 = (1U << 22);  ///< B726
        constexpr uint32_t B727 = (1U << 23);  ///< B727
        constexpr uint32_t B728 = (1U << 24);  ///< B728
        constexpr uint32_t B729 = (1U << 25);  ///< B729
        constexpr uint32_t B730 = (1U << 26);  ///< B730
        constexpr uint32_t B731 = (1U << 27);  ///< B731
        constexpr uint32_t B732 = (1U << 28);  ///< B732
        constexpr uint32_t B733 = (1U << 29);  ///< B733
        constexpr uint32_t B734 = (1U << 30);  ///< B734
        constexpr uint32_t B735 = (1U << 31);  ///< B735
    }

    /// MPCBB1_VCTR23 Register bits
    namespace mpcbb1_vctr23_bits {
        constexpr uint32_t B736 = (1U << 0);  ///< B736
        constexpr uint32_t B737 = (1U << 1);  ///< B737
        constexpr uint32_t B738 = (1U << 2);  ///< B738
        constexpr uint32_t B739 = (1U << 3);  ///< B739
        constexpr uint32_t B740 = (1U << 4);  ///< B740
        constexpr uint32_t B741 = (1U << 5);  ///< B741
        constexpr uint32_t B742 = (1U << 6);  ///< B742
        constexpr uint32_t B743 = (1U << 7);  ///< B743
        constexpr uint32_t B744 = (1U << 8);  ///< B744
        constexpr uint32_t B745 = (1U << 9);  ///< B745
        constexpr uint32_t B746 = (1U << 10);  ///< B746
        constexpr uint32_t B747 = (1U << 11);  ///< B747
        constexpr uint32_t B748 = (1U << 12);  ///< B748
        constexpr uint32_t B749 = (1U << 13);  ///< B749
        constexpr uint32_t B750 = (1U << 14);  ///< B750
        constexpr uint32_t B751 = (1U << 15);  ///< B751
        constexpr uint32_t B752 = (1U << 16);  ///< B752
        constexpr uint32_t B753 = (1U << 17);  ///< B753
        constexpr uint32_t B754 = (1U << 18);  ///< B754
        constexpr uint32_t B755 = (1U << 19);  ///< B755
        constexpr uint32_t B756 = (1U << 20);  ///< B756
        constexpr uint32_t B757 = (1U << 21);  ///< B757
        constexpr uint32_t B758 = (1U << 22);  ///< B758
        constexpr uint32_t B759 = (1U << 23);  ///< B759
        constexpr uint32_t B760 = (1U << 24);  ///< B760
        constexpr uint32_t B761 = (1U << 25);  ///< B761
        constexpr uint32_t B762 = (1U << 26);  ///< B762
        constexpr uint32_t B763 = (1U << 27);  ///< B763
        constexpr uint32_t B764 = (1U << 28);  ///< B764
        constexpr uint32_t B765 = (1U << 29);  ///< B765
        constexpr uint32_t B766 = (1U << 30);  ///< B766
        constexpr uint32_t B767 = (1U << 31);  ///< B767
    }

    /// MPCBB1_VCTR24 Register bits
    namespace mpcbb1_vctr24_bits {
        constexpr uint32_t B768 = (1U << 0);  ///< B768
        constexpr uint32_t B769 = (1U << 1);  ///< B769
        constexpr uint32_t B770 = (1U << 2);  ///< B770
        constexpr uint32_t B771 = (1U << 3);  ///< B771
        constexpr uint32_t B772 = (1U << 4);  ///< B772
        constexpr uint32_t B773 = (1U << 5);  ///< B773
        constexpr uint32_t B774 = (1U << 6);  ///< B774
        constexpr uint32_t B775 = (1U << 7);  ///< B775
        constexpr uint32_t B776 = (1U << 8);  ///< B776
        constexpr uint32_t B777 = (1U << 9);  ///< B777
        constexpr uint32_t B778 = (1U << 10);  ///< B778
        constexpr uint32_t B779 = (1U << 11);  ///< B779
        constexpr uint32_t B780 = (1U << 12);  ///< B780
        constexpr uint32_t B781 = (1U << 13);  ///< B781
        constexpr uint32_t B782 = (1U << 14);  ///< B782
        constexpr uint32_t B783 = (1U << 15);  ///< B783
        constexpr uint32_t B784 = (1U << 16);  ///< B784
        constexpr uint32_t B785 = (1U << 17);  ///< B785
        constexpr uint32_t B786 = (1U << 18);  ///< B786
        constexpr uint32_t B787 = (1U << 19);  ///< B787
        constexpr uint32_t B788 = (1U << 20);  ///< B788
        constexpr uint32_t B789 = (1U << 21);  ///< B789
        constexpr uint32_t B790 = (1U << 22);  ///< B790
        constexpr uint32_t B791 = (1U << 23);  ///< B791
        constexpr uint32_t B792 = (1U << 24);  ///< B792
        constexpr uint32_t B793 = (1U << 25);  ///< B793
        constexpr uint32_t B794 = (1U << 26);  ///< B794
        constexpr uint32_t B795 = (1U << 27);  ///< B795
        constexpr uint32_t B796 = (1U << 28);  ///< B796
        constexpr uint32_t B797 = (1U << 29);  ///< B797
        constexpr uint32_t B798 = (1U << 30);  ///< B798
        constexpr uint32_t B799 = (1U << 31);  ///< B799
    }

    /// MPCBB1_VCTR25 Register bits
    namespace mpcbb1_vctr25_bits {
        constexpr uint32_t B800 = (1U << 0);  ///< B800
        constexpr uint32_t B801 = (1U << 1);  ///< B801
        constexpr uint32_t B802 = (1U << 2);  ///< B802
        constexpr uint32_t B803 = (1U << 3);  ///< B803
        constexpr uint32_t B804 = (1U << 4);  ///< B804
        constexpr uint32_t B805 = (1U << 5);  ///< B805
        constexpr uint32_t B806 = (1U << 6);  ///< B806
        constexpr uint32_t B807 = (1U << 7);  ///< B807
        constexpr uint32_t B808 = (1U << 8);  ///< B808
        constexpr uint32_t B809 = (1U << 9);  ///< B809
        constexpr uint32_t B810 = (1U << 10);  ///< B810
        constexpr uint32_t B811 = (1U << 11);  ///< B811
        constexpr uint32_t B812 = (1U << 12);  ///< B812
        constexpr uint32_t B813 = (1U << 13);  ///< B813
        constexpr uint32_t B814 = (1U << 14);  ///< B814
        constexpr uint32_t B815 = (1U << 15);  ///< B815
        constexpr uint32_t B816 = (1U << 16);  ///< B816
        constexpr uint32_t B817 = (1U << 17);  ///< B817
        constexpr uint32_t B818 = (1U << 18);  ///< B818
        constexpr uint32_t B819 = (1U << 19);  ///< B819
        constexpr uint32_t B820 = (1U << 20);  ///< B820
        constexpr uint32_t B821 = (1U << 21);  ///< B821
        constexpr uint32_t B822 = (1U << 22);  ///< B822
        constexpr uint32_t B823 = (1U << 23);  ///< B823
        constexpr uint32_t B824 = (1U << 24);  ///< B824
        constexpr uint32_t B825 = (1U << 25);  ///< B825
        constexpr uint32_t B826 = (1U << 26);  ///< B826
        constexpr uint32_t B827 = (1U << 27);  ///< B827
        constexpr uint32_t B828 = (1U << 28);  ///< B828
        constexpr uint32_t B829 = (1U << 29);  ///< B829
        constexpr uint32_t B830 = (1U << 30);  ///< B830
        constexpr uint32_t B831 = (1U << 31);  ///< B831
    }

    /// MPCBB1_VCTR26 Register bits
    namespace mpcbb1_vctr26_bits {
        constexpr uint32_t B832 = (1U << 0);  ///< B832
        constexpr uint32_t B833 = (1U << 1);  ///< B833
        constexpr uint32_t B834 = (1U << 2);  ///< B834
        constexpr uint32_t B835 = (1U << 3);  ///< B835
        constexpr uint32_t B836 = (1U << 4);  ///< B836
        constexpr uint32_t B837 = (1U << 5);  ///< B837
        constexpr uint32_t B838 = (1U << 6);  ///< B838
        constexpr uint32_t B839 = (1U << 7);  ///< B839
        constexpr uint32_t B840 = (1U << 8);  ///< B840
        constexpr uint32_t B841 = (1U << 9);  ///< B841
        constexpr uint32_t B842 = (1U << 10);  ///< B842
        constexpr uint32_t B843 = (1U << 11);  ///< B843
        constexpr uint32_t B844 = (1U << 12);  ///< B844
        constexpr uint32_t B845 = (1U << 13);  ///< B845
        constexpr uint32_t B846 = (1U << 14);  ///< B846
        constexpr uint32_t B847 = (1U << 15);  ///< B847
        constexpr uint32_t B848 = (1U << 16);  ///< B848
        constexpr uint32_t B849 = (1U << 17);  ///< B849
        constexpr uint32_t B850 = (1U << 18);  ///< B850
        constexpr uint32_t B851 = (1U << 19);  ///< B851
        constexpr uint32_t B852 = (1U << 20);  ///< B852
        constexpr uint32_t B853 = (1U << 21);  ///< B853
        constexpr uint32_t B854 = (1U << 22);  ///< B854
        constexpr uint32_t B855 = (1U << 23);  ///< B855
        constexpr uint32_t B856 = (1U << 24);  ///< B856
        constexpr uint32_t B857 = (1U << 25);  ///< B857
        constexpr uint32_t B858 = (1U << 26);  ///< B858
        constexpr uint32_t B859 = (1U << 27);  ///< B859
        constexpr uint32_t B860 = (1U << 28);  ///< B860
        constexpr uint32_t B861 = (1U << 29);  ///< B861
        constexpr uint32_t B862 = (1U << 30);  ///< B862
        constexpr uint32_t B863 = (1U << 31);  ///< B863
    }

    /// MPCBB1_VCTR27 Register bits
    namespace mpcbb1_vctr27_bits {
        constexpr uint32_t B864 = (1U << 0);  ///< B864
        constexpr uint32_t B865 = (1U << 1);  ///< B865
        constexpr uint32_t B866 = (1U << 2);  ///< B866
        constexpr uint32_t B867 = (1U << 3);  ///< B867
        constexpr uint32_t B868 = (1U << 4);  ///< B868
        constexpr uint32_t B869 = (1U << 5);  ///< B869
        constexpr uint32_t B870 = (1U << 6);  ///< B870
        constexpr uint32_t B871 = (1U << 7);  ///< B871
        constexpr uint32_t B872 = (1U << 8);  ///< B872
        constexpr uint32_t B873 = (1U << 9);  ///< B873
        constexpr uint32_t B874 = (1U << 10);  ///< B874
        constexpr uint32_t B875 = (1U << 11);  ///< B875
        constexpr uint32_t B876 = (1U << 12);  ///< B876
        constexpr uint32_t B877 = (1U << 13);  ///< B877
        constexpr uint32_t B878 = (1U << 14);  ///< B878
        constexpr uint32_t B879 = (1U << 15);  ///< B879
        constexpr uint32_t B880 = (1U << 16);  ///< B880
        constexpr uint32_t B881 = (1U << 17);  ///< B881
        constexpr uint32_t B882 = (1U << 18);  ///< B882
        constexpr uint32_t B883 = (1U << 19);  ///< B883
        constexpr uint32_t B884 = (1U << 20);  ///< B884
        constexpr uint32_t B885 = (1U << 21);  ///< B885
        constexpr uint32_t B886 = (1U << 22);  ///< B886
        constexpr uint32_t B887 = (1U << 23);  ///< B887
        constexpr uint32_t B888 = (1U << 24);  ///< B888
        constexpr uint32_t B889 = (1U << 25);  ///< B889
        constexpr uint32_t B890 = (1U << 26);  ///< B890
        constexpr uint32_t B891 = (1U << 27);  ///< B891
        constexpr uint32_t B892 = (1U << 28);  ///< B892
        constexpr uint32_t B893 = (1U << 29);  ///< B893
        constexpr uint32_t B894 = (1U << 30);  ///< B894
        constexpr uint32_t B895 = (1U << 31);  ///< B895
    }

    /// MPCBB1_VCTR28 Register bits
    namespace mpcbb1_vctr28_bits {
        constexpr uint32_t B896 = (1U << 0);  ///< B896
        constexpr uint32_t B897 = (1U << 1);  ///< B897
        constexpr uint32_t B898 = (1U << 2);  ///< B898
        constexpr uint32_t B899 = (1U << 3);  ///< B899
        constexpr uint32_t B900 = (1U << 4);  ///< B900
        constexpr uint32_t B901 = (1U << 5);  ///< B901
        constexpr uint32_t B902 = (1U << 6);  ///< B902
        constexpr uint32_t B903 = (1U << 7);  ///< B903
        constexpr uint32_t B904 = (1U << 8);  ///< B904
        constexpr uint32_t B905 = (1U << 9);  ///< B905
        constexpr uint32_t B906 = (1U << 10);  ///< B906
        constexpr uint32_t B907 = (1U << 11);  ///< B907
        constexpr uint32_t B908 = (1U << 12);  ///< B908
        constexpr uint32_t B909 = (1U << 13);  ///< B909
        constexpr uint32_t B910 = (1U << 14);  ///< B910
        constexpr uint32_t B911 = (1U << 15);  ///< B911
        constexpr uint32_t B912 = (1U << 16);  ///< B912
        constexpr uint32_t B913 = (1U << 17);  ///< B913
        constexpr uint32_t B914 = (1U << 18);  ///< B914
        constexpr uint32_t B915 = (1U << 19);  ///< B915
        constexpr uint32_t B916 = (1U << 20);  ///< B916
        constexpr uint32_t B917 = (1U << 21);  ///< B917
        constexpr uint32_t B918 = (1U << 22);  ///< B918
        constexpr uint32_t B919 = (1U << 23);  ///< B919
        constexpr uint32_t B920 = (1U << 24);  ///< B920
        constexpr uint32_t B921 = (1U << 25);  ///< B921
        constexpr uint32_t B922 = (1U << 26);  ///< B922
        constexpr uint32_t B923 = (1U << 27);  ///< B923
        constexpr uint32_t B924 = (1U << 28);  ///< B924
        constexpr uint32_t B925 = (1U << 29);  ///< B925
        constexpr uint32_t B926 = (1U << 30);  ///< B926
        constexpr uint32_t B927 = (1U << 31);  ///< B927
    }

    /// MPCBB1_VCTR29 Register bits
    namespace mpcbb1_vctr29_bits {
        constexpr uint32_t B928 = (1U << 0);  ///< B928
        constexpr uint32_t B929 = (1U << 1);  ///< B929
        constexpr uint32_t B930 = (1U << 2);  ///< B930
        constexpr uint32_t B931 = (1U << 3);  ///< B931
        constexpr uint32_t B932 = (1U << 4);  ///< B932
        constexpr uint32_t B933 = (1U << 5);  ///< B933
        constexpr uint32_t B934 = (1U << 6);  ///< B934
        constexpr uint32_t B935 = (1U << 7);  ///< B935
        constexpr uint32_t B936 = (1U << 8);  ///< B936
        constexpr uint32_t B937 = (1U << 9);  ///< B937
        constexpr uint32_t B938 = (1U << 10);  ///< B938
        constexpr uint32_t B939 = (1U << 11);  ///< B939
        constexpr uint32_t B940 = (1U << 12);  ///< B940
        constexpr uint32_t B941 = (1U << 13);  ///< B941
        constexpr uint32_t B942 = (1U << 14);  ///< B942
        constexpr uint32_t B943 = (1U << 15);  ///< B943
        constexpr uint32_t B944 = (1U << 16);  ///< B944
        constexpr uint32_t B945 = (1U << 17);  ///< B945
        constexpr uint32_t B946 = (1U << 18);  ///< B946
        constexpr uint32_t B947 = (1U << 19);  ///< B947
        constexpr uint32_t B948 = (1U << 20);  ///< B948
        constexpr uint32_t B949 = (1U << 21);  ///< B949
        constexpr uint32_t B950 = (1U << 22);  ///< B950
        constexpr uint32_t B951 = (1U << 23);  ///< B951
        constexpr uint32_t B952 = (1U << 24);  ///< B952
        constexpr uint32_t B953 = (1U << 25);  ///< B953
        constexpr uint32_t B954 = (1U << 26);  ///< B954
        constexpr uint32_t B955 = (1U << 27);  ///< B955
        constexpr uint32_t B956 = (1U << 28);  ///< B956
        constexpr uint32_t B957 = (1U << 29);  ///< B957
        constexpr uint32_t B958 = (1U << 30);  ///< B958
        constexpr uint32_t B959 = (1U << 31);  ///< B959
    }

    /// MPCBB1_VCTR30 Register bits
    namespace mpcbb1_vctr30_bits {
        constexpr uint32_t B960 = (1U << 0);  ///< B960
        constexpr uint32_t B961 = (1U << 1);  ///< B961
        constexpr uint32_t B962 = (1U << 2);  ///< B962
        constexpr uint32_t B963 = (1U << 3);  ///< B963
        constexpr uint32_t B964 = (1U << 4);  ///< B964
        constexpr uint32_t B965 = (1U << 5);  ///< B965
        constexpr uint32_t B966 = (1U << 6);  ///< B966
        constexpr uint32_t B967 = (1U << 7);  ///< B967
        constexpr uint32_t B968 = (1U << 8);  ///< B968
        constexpr uint32_t B969 = (1U << 9);  ///< B969
        constexpr uint32_t B970 = (1U << 10);  ///< B970
        constexpr uint32_t B971 = (1U << 11);  ///< B971
        constexpr uint32_t B972 = (1U << 12);  ///< B972
        constexpr uint32_t B973 = (1U << 13);  ///< B973
        constexpr uint32_t B974 = (1U << 14);  ///< B974
        constexpr uint32_t B975 = (1U << 15);  ///< B975
        constexpr uint32_t B976 = (1U << 16);  ///< B976
        constexpr uint32_t B977 = (1U << 17);  ///< B977
        constexpr uint32_t B978 = (1U << 18);  ///< B978
        constexpr uint32_t B979 = (1U << 19);  ///< B979
        constexpr uint32_t B980 = (1U << 20);  ///< B980
        constexpr uint32_t B981 = (1U << 21);  ///< B981
        constexpr uint32_t B982 = (1U << 22);  ///< B982
        constexpr uint32_t B983 = (1U << 23);  ///< B983
        constexpr uint32_t B984 = (1U << 24);  ///< B984
        constexpr uint32_t B985 = (1U << 25);  ///< B985
        constexpr uint32_t B986 = (1U << 26);  ///< B986
        constexpr uint32_t B987 = (1U << 27);  ///< B987
        constexpr uint32_t B988 = (1U << 28);  ///< B988
        constexpr uint32_t B989 = (1U << 29);  ///< B989
        constexpr uint32_t B990 = (1U << 30);  ///< B990
        constexpr uint32_t B991 = (1U << 31);  ///< B991
    }

    /// MPCBB1_VCTR31 Register bits
    namespace mpcbb1_vctr31_bits {
        constexpr uint32_t B992 = (1U << 0);  ///< B992
        constexpr uint32_t B993 = (1U << 1);  ///< B993
        constexpr uint32_t B994 = (1U << 2);  ///< B994
        constexpr uint32_t B995 = (1U << 3);  ///< B995
        constexpr uint32_t B996 = (1U << 4);  ///< B996
        constexpr uint32_t B997 = (1U << 5);  ///< B997
        constexpr uint32_t B998 = (1U << 6);  ///< B998
        constexpr uint32_t B999 = (1U << 7);  ///< B999
        constexpr uint32_t B1000 = (1U << 8);  ///< B1000
        constexpr uint32_t B1001 = (1U << 9);  ///< B1001
        constexpr uint32_t B1002 = (1U << 10);  ///< B1002
        constexpr uint32_t B1003 = (1U << 11);  ///< B1003
        constexpr uint32_t B1004 = (1U << 12);  ///< B1004
        constexpr uint32_t B1005 = (1U << 13);  ///< B1005
        constexpr uint32_t B1006 = (1U << 14);  ///< B1006
        constexpr uint32_t B1007 = (1U << 15);  ///< B1007
        constexpr uint32_t B1008 = (1U << 16);  ///< B1008
        constexpr uint32_t B1009 = (1U << 17);  ///< B1009
        constexpr uint32_t B1010 = (1U << 18);  ///< B1010
        constexpr uint32_t B1011 = (1U << 19);  ///< B1011
        constexpr uint32_t B1012 = (1U << 20);  ///< B1012
        constexpr uint32_t B1013 = (1U << 21);  ///< B1013
        constexpr uint32_t B1014 = (1U << 22);  ///< B1014
        constexpr uint32_t B1015 = (1U << 23);  ///< B1015
        constexpr uint32_t B1016 = (1U << 24);  ///< B1016
        constexpr uint32_t B1017 = (1U << 25);  ///< B1017
        constexpr uint32_t B1018 = (1U << 26);  ///< B1018
        constexpr uint32_t B1019 = (1U << 27);  ///< B1019
        constexpr uint32_t B1020 = (1U << 28);  ///< B1020
        constexpr uint32_t B1021 = (1U << 29);  ///< B1021
        constexpr uint32_t B1022 = (1U << 30);  ///< B1022
        constexpr uint32_t B1023 = (1U << 31);  ///< B1023
    }

    /// MPCBB1_VCTR32 Register bits
    namespace mpcbb1_vctr32_bits {
        constexpr uint32_t B1024 = (1U << 0);  ///< B1024
        constexpr uint32_t B1025 = (1U << 1);  ///< B1025
        constexpr uint32_t B1026 = (1U << 2);  ///< B1026
        constexpr uint32_t B1027 = (1U << 3);  ///< B1027
        constexpr uint32_t B1028 = (1U << 4);  ///< B1028
        constexpr uint32_t B1029 = (1U << 5);  ///< B1029
        constexpr uint32_t B1030 = (1U << 6);  ///< B1030
        constexpr uint32_t B1031 = (1U << 7);  ///< B1031
        constexpr uint32_t B1032 = (1U << 8);  ///< B1032
        constexpr uint32_t B1033 = (1U << 9);  ///< B1033
        constexpr uint32_t B1034 = (1U << 10);  ///< B1034
        constexpr uint32_t B1035 = (1U << 11);  ///< B1035
        constexpr uint32_t B1036 = (1U << 12);  ///< B1036
        constexpr uint32_t B1037 = (1U << 13);  ///< B1037
        constexpr uint32_t B1038 = (1U << 14);  ///< B1038
        constexpr uint32_t B1039 = (1U << 15);  ///< B1039
        constexpr uint32_t B1040 = (1U << 16);  ///< B1040
        constexpr uint32_t B1041 = (1U << 17);  ///< B1041
        constexpr uint32_t B1042 = (1U << 18);  ///< B1042
        constexpr uint32_t B1043 = (1U << 19);  ///< B1043
        constexpr uint32_t B1044 = (1U << 20);  ///< B1044
        constexpr uint32_t B1045 = (1U << 21);  ///< B1045
        constexpr uint32_t B1046 = (1U << 22);  ///< B1046
        constexpr uint32_t B1047 = (1U << 23);  ///< B1047
        constexpr uint32_t B1048 = (1U << 24);  ///< B1048
        constexpr uint32_t B1049 = (1U << 25);  ///< B1049
        constexpr uint32_t B1050 = (1U << 26);  ///< B1050
        constexpr uint32_t B1051 = (1U << 27);  ///< B1051
        constexpr uint32_t B1052 = (1U << 28);  ///< B1052
        constexpr uint32_t B1053 = (1U << 29);  ///< B1053
        constexpr uint32_t B1054 = (1U << 30);  ///< B1054
        constexpr uint32_t B1055 = (1U << 31);  ///< B1055
    }

    /// MPCBB1_VCTR33 Register bits
    namespace mpcbb1_vctr33_bits {
        constexpr uint32_t B1056 = (1U << 0);  ///< B1056
        constexpr uint32_t B1057 = (1U << 1);  ///< B1057
        constexpr uint32_t B1058 = (1U << 2);  ///< B1058
        constexpr uint32_t B1059 = (1U << 3);  ///< B1059
        constexpr uint32_t B1060 = (1U << 4);  ///< B1060
        constexpr uint32_t B1061 = (1U << 5);  ///< B1061
        constexpr uint32_t B1062 = (1U << 6);  ///< B1062
        constexpr uint32_t B1063 = (1U << 7);  ///< B1063
        constexpr uint32_t B1064 = (1U << 8);  ///< B1064
        constexpr uint32_t B1065 = (1U << 9);  ///< B1065
        constexpr uint32_t B1066 = (1U << 10);  ///< B1066
        constexpr uint32_t B1067 = (1U << 11);  ///< B1067
        constexpr uint32_t B1068 = (1U << 12);  ///< B1068
        constexpr uint32_t B1069 = (1U << 13);  ///< B1069
        constexpr uint32_t B1070 = (1U << 14);  ///< B1070
        constexpr uint32_t B1071 = (1U << 15);  ///< B1071
        constexpr uint32_t B1072 = (1U << 16);  ///< B1072
        constexpr uint32_t B1073 = (1U << 17);  ///< B1073
        constexpr uint32_t B1074 = (1U << 18);  ///< B1074
        constexpr uint32_t B1075 = (1U << 19);  ///< B1075
        constexpr uint32_t B1076 = (1U << 20);  ///< B1076
        constexpr uint32_t B1077 = (1U << 21);  ///< B1077
        constexpr uint32_t B1078 = (1U << 22);  ///< B1078
        constexpr uint32_t B1079 = (1U << 23);  ///< B1079
        constexpr uint32_t B1080 = (1U << 24);  ///< B1080
        constexpr uint32_t B1081 = (1U << 25);  ///< B1081
        constexpr uint32_t B1082 = (1U << 26);  ///< B1082
        constexpr uint32_t B1083 = (1U << 27);  ///< B1083
        constexpr uint32_t B1084 = (1U << 28);  ///< B1084
        constexpr uint32_t B1085 = (1U << 29);  ///< B1085
        constexpr uint32_t B1086 = (1U << 30);  ///< B1086
        constexpr uint32_t B1087 = (1U << 31);  ///< B1087
    }

    /// MPCBB1_VCTR34 Register bits
    namespace mpcbb1_vctr34_bits {
        constexpr uint32_t B1088 = (1U << 0);  ///< B1088
        constexpr uint32_t B1089 = (1U << 1);  ///< B1089
        constexpr uint32_t B1090 = (1U << 2);  ///< B1090
        constexpr uint32_t B1091 = (1U << 3);  ///< B1091
        constexpr uint32_t B1092 = (1U << 4);  ///< B1092
        constexpr uint32_t B1093 = (1U << 5);  ///< B1093
        constexpr uint32_t B1094 = (1U << 6);  ///< B1094
        constexpr uint32_t B1095 = (1U << 7);  ///< B1095
        constexpr uint32_t B1096 = (1U << 8);  ///< B1096
        constexpr uint32_t B1097 = (1U << 9);  ///< B1097
        constexpr uint32_t B1098 = (1U << 10);  ///< B1098
        constexpr uint32_t B1099 = (1U << 11);  ///< B1099
        constexpr uint32_t B1100 = (1U << 12);  ///< B1100
        constexpr uint32_t B1101 = (1U << 13);  ///< B1101
        constexpr uint32_t B1102 = (1U << 14);  ///< B1102
        constexpr uint32_t B1103 = (1U << 15);  ///< B1103
        constexpr uint32_t B1104 = (1U << 16);  ///< B1104
        constexpr uint32_t B1105 = (1U << 17);  ///< B1105
        constexpr uint32_t B1106 = (1U << 18);  ///< B1106
        constexpr uint32_t B1107 = (1U << 19);  ///< B1107
        constexpr uint32_t B1108 = (1U << 20);  ///< B1108
        constexpr uint32_t B1109 = (1U << 21);  ///< B1109
        constexpr uint32_t B1110 = (1U << 22);  ///< B1110
        constexpr uint32_t B1111 = (1U << 23);  ///< B1111
        constexpr uint32_t B1112 = (1U << 24);  ///< B1112
        constexpr uint32_t B1113 = (1U << 25);  ///< B1113
        constexpr uint32_t B1114 = (1U << 26);  ///< B1114
        constexpr uint32_t B1115 = (1U << 27);  ///< B1115
        constexpr uint32_t B1116 = (1U << 28);  ///< B1116
        constexpr uint32_t B1117 = (1U << 29);  ///< B1117
        constexpr uint32_t B1118 = (1U << 30);  ///< B1118
        constexpr uint32_t B1119 = (1U << 31);  ///< B1119
    }

    /// MPCBB1_VCTR35 Register bits
    namespace mpcbb1_vctr35_bits {
        constexpr uint32_t B1120 = (1U << 0);  ///< B1120
        constexpr uint32_t B1121 = (1U << 1);  ///< B1121
        constexpr uint32_t B1122 = (1U << 2);  ///< B1122
        constexpr uint32_t B1123 = (1U << 3);  ///< B1123
        constexpr uint32_t B1124 = (1U << 4);  ///< B1124
        constexpr uint32_t B1125 = (1U << 5);  ///< B1125
        constexpr uint32_t B1126 = (1U << 6);  ///< B1126
        constexpr uint32_t B1127 = (1U << 7);  ///< B1127
        constexpr uint32_t B1128 = (1U << 8);  ///< B1128
        constexpr uint32_t B1129 = (1U << 9);  ///< B1129
        constexpr uint32_t B1130 = (1U << 10);  ///< B1130
        constexpr uint32_t B1131 = (1U << 11);  ///< B1131
        constexpr uint32_t B1132 = (1U << 12);  ///< B1132
        constexpr uint32_t B1133 = (1U << 13);  ///< B1133
        constexpr uint32_t B1134 = (1U << 14);  ///< B1134
        constexpr uint32_t B1135 = (1U << 15);  ///< B1135
        constexpr uint32_t B1136 = (1U << 16);  ///< B1136
        constexpr uint32_t B1137 = (1U << 17);  ///< B1137
        constexpr uint32_t B1138 = (1U << 18);  ///< B1138
        constexpr uint32_t B1139 = (1U << 19);  ///< B1139
        constexpr uint32_t B1140 = (1U << 20);  ///< B1140
        constexpr uint32_t B1141 = (1U << 21);  ///< B1141
        constexpr uint32_t B1142 = (1U << 22);  ///< B1142
        constexpr uint32_t B1143 = (1U << 23);  ///< B1143
        constexpr uint32_t B1144 = (1U << 24);  ///< B1144
        constexpr uint32_t B1145 = (1U << 25);  ///< B1145
        constexpr uint32_t B1146 = (1U << 26);  ///< B1146
        constexpr uint32_t B1147 = (1U << 27);  ///< B1147
        constexpr uint32_t B1148 = (1U << 28);  ///< B1148
        constexpr uint32_t B1149 = (1U << 29);  ///< B1149
        constexpr uint32_t B1150 = (1U << 30);  ///< B1150
        constexpr uint32_t B1151 = (1U << 31);  ///< B1151
    }

    /// MPCBB1_VCTR36 Register bits
    namespace mpcbb1_vctr36_bits {
        constexpr uint32_t B1152 = (1U << 0);  ///< B1152
        constexpr uint32_t B1153 = (1U << 1);  ///< B1153
        constexpr uint32_t B1154 = (1U << 2);  ///< B1154
        constexpr uint32_t B1155 = (1U << 3);  ///< B1155
        constexpr uint32_t B1156 = (1U << 4);  ///< B1156
        constexpr uint32_t B1157 = (1U << 5);  ///< B1157
        constexpr uint32_t B1158 = (1U << 6);  ///< B1158
        constexpr uint32_t B1159 = (1U << 7);  ///< B1159
        constexpr uint32_t B1160 = (1U << 8);  ///< B1160
        constexpr uint32_t B1161 = (1U << 9);  ///< B1161
        constexpr uint32_t B1162 = (1U << 10);  ///< B1162
        constexpr uint32_t B1163 = (1U << 11);  ///< B1163
        constexpr uint32_t B1164 = (1U << 12);  ///< B1164
        constexpr uint32_t B1165 = (1U << 13);  ///< B1165
        constexpr uint32_t B1166 = (1U << 14);  ///< B1166
        constexpr uint32_t B1167 = (1U << 15);  ///< B1167
        constexpr uint32_t B1168 = (1U << 16);  ///< B1168
        constexpr uint32_t B1169 = (1U << 17);  ///< B1169
        constexpr uint32_t B1170 = (1U << 18);  ///< B1170
        constexpr uint32_t B1171 = (1U << 19);  ///< B1171
        constexpr uint32_t B1172 = (1U << 20);  ///< B1172
        constexpr uint32_t B1173 = (1U << 21);  ///< B1173
        constexpr uint32_t B1174 = (1U << 22);  ///< B1174
        constexpr uint32_t B1175 = (1U << 23);  ///< B1175
        constexpr uint32_t B1176 = (1U << 24);  ///< B1176
        constexpr uint32_t B1177 = (1U << 25);  ///< B1177
        constexpr uint32_t B1178 = (1U << 26);  ///< B1178
        constexpr uint32_t B1179 = (1U << 27);  ///< B1179
        constexpr uint32_t B1180 = (1U << 28);  ///< B1180
        constexpr uint32_t B1181 = (1U << 29);  ///< B1181
        constexpr uint32_t B1182 = (1U << 30);  ///< B1182
        constexpr uint32_t B1183 = (1U << 31);  ///< B1183
    }

    /// MPCBB1_VCTR37 Register bits
    namespace mpcbb1_vctr37_bits {
        constexpr uint32_t B1184 = (1U << 0);  ///< B1184
        constexpr uint32_t B1185 = (1U << 1);  ///< B1185
        constexpr uint32_t B1186 = (1U << 2);  ///< B1186
        constexpr uint32_t B1187 = (1U << 3);  ///< B1187
        constexpr uint32_t B1188 = (1U << 4);  ///< B1188
        constexpr uint32_t B1189 = (1U << 5);  ///< B1189
        constexpr uint32_t B1190 = (1U << 6);  ///< B1190
        constexpr uint32_t B1191 = (1U << 7);  ///< B1191
        constexpr uint32_t B1192 = (1U << 8);  ///< B1192
        constexpr uint32_t B1193 = (1U << 9);  ///< B1193
        constexpr uint32_t B1194 = (1U << 10);  ///< B1194
        constexpr uint32_t B1195 = (1U << 11);  ///< B1195
        constexpr uint32_t B1196 = (1U << 12);  ///< B1196
        constexpr uint32_t B1197 = (1U << 13);  ///< B1197
        constexpr uint32_t B1198 = (1U << 14);  ///< B1198
        constexpr uint32_t B1199 = (1U << 15);  ///< B1199
        constexpr uint32_t B1200 = (1U << 16);  ///< B1200
        constexpr uint32_t B1201 = (1U << 17);  ///< B1201
        constexpr uint32_t B1202 = (1U << 18);  ///< B1202
        constexpr uint32_t B1203 = (1U << 19);  ///< B1203
        constexpr uint32_t B1204 = (1U << 20);  ///< B1204
        constexpr uint32_t B1205 = (1U << 21);  ///< B1205
        constexpr uint32_t B1206 = (1U << 22);  ///< B1206
        constexpr uint32_t B1207 = (1U << 23);  ///< B1207
        constexpr uint32_t B1208 = (1U << 24);  ///< B1208
        constexpr uint32_t B1209 = (1U << 25);  ///< B1209
        constexpr uint32_t B1210 = (1U << 26);  ///< B1210
        constexpr uint32_t B1211 = (1U << 27);  ///< B1211
        constexpr uint32_t B1212 = (1U << 28);  ///< B1212
        constexpr uint32_t B1213 = (1U << 29);  ///< B1213
        constexpr uint32_t B1214 = (1U << 30);  ///< B1214
        constexpr uint32_t B1215 = (1U << 31);  ///< B1215
    }

    /// MPCBB1_VCTR38 Register bits
    namespace mpcbb1_vctr38_bits {
        constexpr uint32_t B1216 = (1U << 0);  ///< B1216
        constexpr uint32_t B1217 = (1U << 1);  ///< B1217
        constexpr uint32_t B1218 = (1U << 2);  ///< B1218
        constexpr uint32_t B1219 = (1U << 3);  ///< B1219
        constexpr uint32_t B1220 = (1U << 4);  ///< B1220
        constexpr uint32_t B1221 = (1U << 5);  ///< B1221
        constexpr uint32_t B1222 = (1U << 6);  ///< B1222
        constexpr uint32_t B1223 = (1U << 7);  ///< B1223
        constexpr uint32_t B1224 = (1U << 8);  ///< B1224
        constexpr uint32_t B1225 = (1U << 9);  ///< B1225
        constexpr uint32_t B1226 = (1U << 10);  ///< B1226
        constexpr uint32_t B1227 = (1U << 11);  ///< B1227
        constexpr uint32_t B1228 = (1U << 12);  ///< B1228
        constexpr uint32_t B1229 = (1U << 13);  ///< B1229
        constexpr uint32_t B1230 = (1U << 14);  ///< B1230
        constexpr uint32_t B1231 = (1U << 15);  ///< B1231
        constexpr uint32_t B1232 = (1U << 16);  ///< B1232
        constexpr uint32_t B1233 = (1U << 17);  ///< B1233
        constexpr uint32_t B1234 = (1U << 18);  ///< B1234
        constexpr uint32_t B1235 = (1U << 19);  ///< B1235
        constexpr uint32_t B1236 = (1U << 20);  ///< B1236
        constexpr uint32_t B1237 = (1U << 21);  ///< B1237
        constexpr uint32_t B1238 = (1U << 22);  ///< B1238
        constexpr uint32_t B1239 = (1U << 23);  ///< B1239
        constexpr uint32_t B1240 = (1U << 24);  ///< B1240
        constexpr uint32_t B1241 = (1U << 25);  ///< B1241
        constexpr uint32_t B1242 = (1U << 26);  ///< B1242
        constexpr uint32_t B1243 = (1U << 27);  ///< B1243
        constexpr uint32_t B1244 = (1U << 28);  ///< B1244
        constexpr uint32_t B1245 = (1U << 29);  ///< B1245
        constexpr uint32_t B1246 = (1U << 30);  ///< B1246
        constexpr uint32_t B1247 = (1U << 31);  ///< B1247
    }

    /// MPCBB1_VCTR39 Register bits
    namespace mpcbb1_vctr39_bits {
        constexpr uint32_t B1248 = (1U << 0);  ///< B1248
        constexpr uint32_t B1249 = (1U << 1);  ///< B1249
        constexpr uint32_t B1250 = (1U << 2);  ///< B1250
        constexpr uint32_t B1251 = (1U << 3);  ///< B1251
        constexpr uint32_t B1252 = (1U << 4);  ///< B1252
        constexpr uint32_t B1253 = (1U << 5);  ///< B1253
        constexpr uint32_t B1254 = (1U << 6);  ///< B1254
        constexpr uint32_t B1255 = (1U << 7);  ///< B1255
        constexpr uint32_t B1256 = (1U << 8);  ///< B1256
        constexpr uint32_t B1257 = (1U << 9);  ///< B1257
        constexpr uint32_t B1258 = (1U << 10);  ///< B1258
        constexpr uint32_t B1259 = (1U << 11);  ///< B1259
        constexpr uint32_t B1260 = (1U << 12);  ///< B1260
        constexpr uint32_t B1261 = (1U << 13);  ///< B1261
        constexpr uint32_t B1262 = (1U << 14);  ///< B1262
        constexpr uint32_t B1263 = (1U << 15);  ///< B1263
        constexpr uint32_t B1264 = (1U << 16);  ///< B1264
        constexpr uint32_t B1265 = (1U << 17);  ///< B1265
        constexpr uint32_t B1266 = (1U << 18);  ///< B1266
        constexpr uint32_t B1267 = (1U << 19);  ///< B1267
        constexpr uint32_t B1268 = (1U << 20);  ///< B1268
        constexpr uint32_t B1269 = (1U << 21);  ///< B1269
        constexpr uint32_t B1270 = (1U << 22);  ///< B1270
        constexpr uint32_t B1271 = (1U << 23);  ///< B1271
        constexpr uint32_t B1272 = (1U << 24);  ///< B1272
        constexpr uint32_t B1273 = (1U << 25);  ///< B1273
        constexpr uint32_t B1274 = (1U << 26);  ///< B1274
        constexpr uint32_t B1275 = (1U << 27);  ///< B1275
        constexpr uint32_t B1276 = (1U << 28);  ///< B1276
        constexpr uint32_t B1277 = (1U << 29);  ///< B1277
        constexpr uint32_t B1278 = (1U << 30);  ///< B1278
        constexpr uint32_t B1279 = (1U << 31);  ///< B1279
    }

    /// MPCBB1_VCTR40 Register bits
    namespace mpcbb1_vctr40_bits {
        constexpr uint32_t B1280 = (1U << 0);  ///< B1280
        constexpr uint32_t B1281 = (1U << 1);  ///< B1281
        constexpr uint32_t B1282 = (1U << 2);  ///< B1282
        constexpr uint32_t B1283 = (1U << 3);  ///< B1283
        constexpr uint32_t B1284 = (1U << 4);  ///< B1284
        constexpr uint32_t B1285 = (1U << 5);  ///< B1285
        constexpr uint32_t B1286 = (1U << 6);  ///< B1286
        constexpr uint32_t B1287 = (1U << 7);  ///< B1287
        constexpr uint32_t B1288 = (1U << 8);  ///< B1288
        constexpr uint32_t B1289 = (1U << 9);  ///< B1289
        constexpr uint32_t B1290 = (1U << 10);  ///< B1290
        constexpr uint32_t B1291 = (1U << 11);  ///< B1291
        constexpr uint32_t B1292 = (1U << 12);  ///< B1292
        constexpr uint32_t B1293 = (1U << 13);  ///< B1293
        constexpr uint32_t B1294 = (1U << 14);  ///< B1294
        constexpr uint32_t B1295 = (1U << 15);  ///< B1295
        constexpr uint32_t B1296 = (1U << 16);  ///< B1296
        constexpr uint32_t B1297 = (1U << 17);  ///< B1297
        constexpr uint32_t B1298 = (1U << 18);  ///< B1298
        constexpr uint32_t B1299 = (1U << 19);  ///< B1299
        constexpr uint32_t B1300 = (1U << 20);  ///< B1300
        constexpr uint32_t B1301 = (1U << 21);  ///< B1301
        constexpr uint32_t B1302 = (1U << 22);  ///< B1302
        constexpr uint32_t B1303 = (1U << 23);  ///< B1303
        constexpr uint32_t B1304 = (1U << 24);  ///< B1304
        constexpr uint32_t B1305 = (1U << 25);  ///< B1305
        constexpr uint32_t B1306 = (1U << 26);  ///< B1306
        constexpr uint32_t B1307 = (1U << 27);  ///< B1307
        constexpr uint32_t B1308 = (1U << 28);  ///< B1308
        constexpr uint32_t B1309 = (1U << 29);  ///< B1309
        constexpr uint32_t B1310 = (1U << 30);  ///< B1310
        constexpr uint32_t B1311 = (1U << 31);  ///< B1311
    }

    /// MPCBB1_VCTR41 Register bits
    namespace mpcbb1_vctr41_bits {
        constexpr uint32_t B1312 = (1U << 0);  ///< B1312
        constexpr uint32_t B1313 = (1U << 1);  ///< B1313
        constexpr uint32_t B1314 = (1U << 2);  ///< B1314
        constexpr uint32_t B1315 = (1U << 3);  ///< B1315
        constexpr uint32_t B1316 = (1U << 4);  ///< B1316
        constexpr uint32_t B1317 = (1U << 5);  ///< B1317
        constexpr uint32_t B1318 = (1U << 6);  ///< B1318
        constexpr uint32_t B1319 = (1U << 7);  ///< B1319
        constexpr uint32_t B1320 = (1U << 8);  ///< B1320
        constexpr uint32_t B1321 = (1U << 9);  ///< B1321
        constexpr uint32_t B1322 = (1U << 10);  ///< B1322
        constexpr uint32_t B1323 = (1U << 11);  ///< B1323
        constexpr uint32_t B1324 = (1U << 12);  ///< B1324
        constexpr uint32_t B1325 = (1U << 13);  ///< B1325
        constexpr uint32_t B1326 = (1U << 14);  ///< B1326
        constexpr uint32_t B1327 = (1U << 15);  ///< B1327
        constexpr uint32_t B1328 = (1U << 16);  ///< B1328
        constexpr uint32_t B1329 = (1U << 17);  ///< B1329
        constexpr uint32_t B1330 = (1U << 18);  ///< B1330
        constexpr uint32_t B1331 = (1U << 19);  ///< B1331
        constexpr uint32_t B1332 = (1U << 20);  ///< B1332
        constexpr uint32_t B1333 = (1U << 21);  ///< B1333
        constexpr uint32_t B1334 = (1U << 22);  ///< B1334
        constexpr uint32_t B1335 = (1U << 23);  ///< B1335
        constexpr uint32_t B1336 = (1U << 24);  ///< B1336
        constexpr uint32_t B1337 = (1U << 25);  ///< B1337
        constexpr uint32_t B1338 = (1U << 26);  ///< B1338
        constexpr uint32_t B1339 = (1U << 27);  ///< B1339
        constexpr uint32_t B1340 = (1U << 28);  ///< B1340
        constexpr uint32_t B1341 = (1U << 29);  ///< B1341
        constexpr uint32_t B1342 = (1U << 30);  ///< B1342
        constexpr uint32_t B1343 = (1U << 31);  ///< B1343
    }

    /// MPCBB1_VCTR42 Register bits
    namespace mpcbb1_vctr42_bits {
        constexpr uint32_t B1344 = (1U << 0);  ///< B1344
        constexpr uint32_t B1345 = (1U << 1);  ///< B1345
        constexpr uint32_t B1346 = (1U << 2);  ///< B1346
        constexpr uint32_t B1347 = (1U << 3);  ///< B1347
        constexpr uint32_t B1348 = (1U << 4);  ///< B1348
        constexpr uint32_t B1349 = (1U << 5);  ///< B1349
        constexpr uint32_t B1350 = (1U << 6);  ///< B1350
        constexpr uint32_t B1351 = (1U << 7);  ///< B1351
        constexpr uint32_t B1352 = (1U << 8);  ///< B1352
        constexpr uint32_t B1353 = (1U << 9);  ///< B1353
        constexpr uint32_t B1354 = (1U << 10);  ///< B1354
        constexpr uint32_t B1355 = (1U << 11);  ///< B1355
        constexpr uint32_t B1356 = (1U << 12);  ///< B1356
        constexpr uint32_t B1357 = (1U << 13);  ///< B1357
        constexpr uint32_t B1358 = (1U << 14);  ///< B1358
        constexpr uint32_t B1359 = (1U << 15);  ///< B1359
        constexpr uint32_t B1360 = (1U << 16);  ///< B1360
        constexpr uint32_t B1361 = (1U << 17);  ///< B1361
        constexpr uint32_t B1362 = (1U << 18);  ///< B1362
        constexpr uint32_t B1363 = (1U << 19);  ///< B1363
        constexpr uint32_t B1364 = (1U << 20);  ///< B1364
        constexpr uint32_t B1365 = (1U << 21);  ///< B1365
        constexpr uint32_t B1366 = (1U << 22);  ///< B1366
        constexpr uint32_t B1367 = (1U << 23);  ///< B1367
        constexpr uint32_t B1368 = (1U << 24);  ///< B1368
        constexpr uint32_t B1369 = (1U << 25);  ///< B1369
        constexpr uint32_t B1370 = (1U << 26);  ///< B1370
        constexpr uint32_t B1371 = (1U << 27);  ///< B1371
        constexpr uint32_t B1372 = (1U << 28);  ///< B1372
        constexpr uint32_t B1373 = (1U << 29);  ///< B1373
        constexpr uint32_t B1374 = (1U << 30);  ///< B1374
        constexpr uint32_t B1375 = (1U << 31);  ///< B1375
    }

    /// MPCBB1_VCTR43 Register bits
    namespace mpcbb1_vctr43_bits {
        constexpr uint32_t B1376 = (1U << 0);  ///< B1376
        constexpr uint32_t B1377 = (1U << 1);  ///< B1377
        constexpr uint32_t B1378 = (1U << 2);  ///< B1378
        constexpr uint32_t B1379 = (1U << 3);  ///< B1379
        constexpr uint32_t B1380 = (1U << 4);  ///< B1380
        constexpr uint32_t B1381 = (1U << 5);  ///< B1381
        constexpr uint32_t B1382 = (1U << 6);  ///< B1382
        constexpr uint32_t B1383 = (1U << 7);  ///< B1383
        constexpr uint32_t B1384 = (1U << 8);  ///< B1384
        constexpr uint32_t B1385 = (1U << 9);  ///< B1385
        constexpr uint32_t B1386 = (1U << 10);  ///< B1386
        constexpr uint32_t B1387 = (1U << 11);  ///< B1387
        constexpr uint32_t B1388 = (1U << 12);  ///< B1388
        constexpr uint32_t B1389 = (1U << 13);  ///< B1389
        constexpr uint32_t B1390 = (1U << 14);  ///< B1390
        constexpr uint32_t B1391 = (1U << 15);  ///< B1391
        constexpr uint32_t B1392 = (1U << 16);  ///< B1392
        constexpr uint32_t B1393 = (1U << 17);  ///< B1393
        constexpr uint32_t B1394 = (1U << 18);  ///< B1394
        constexpr uint32_t B1395 = (1U << 19);  ///< B1395
        constexpr uint32_t B1396 = (1U << 20);  ///< B1396
        constexpr uint32_t B1397 = (1U << 21);  ///< B1397
        constexpr uint32_t B1398 = (1U << 22);  ///< B1398
        constexpr uint32_t B1399 = (1U << 23);  ///< B1399
        constexpr uint32_t B1400 = (1U << 24);  ///< B1400
        constexpr uint32_t B1401 = (1U << 25);  ///< B1401
        constexpr uint32_t B1402 = (1U << 26);  ///< B1402
        constexpr uint32_t B1403 = (1U << 27);  ///< B1403
        constexpr uint32_t B1404 = (1U << 28);  ///< B1404
        constexpr uint32_t B1405 = (1U << 29);  ///< B1405
        constexpr uint32_t B1406 = (1U << 30);  ///< B1406
        constexpr uint32_t B1407 = (1U << 31);  ///< B1407
    }

    /// MPCBB1_VCTR44 Register bits
    namespace mpcbb1_vctr44_bits {
        constexpr uint32_t B1408 = (1U << 0);  ///< B1408
        constexpr uint32_t B1409 = (1U << 1);  ///< B1409
        constexpr uint32_t B1410 = (1U << 2);  ///< B1410
        constexpr uint32_t B1411 = (1U << 3);  ///< B1411
        constexpr uint32_t B1412 = (1U << 4);  ///< B1412
        constexpr uint32_t B1413 = (1U << 5);  ///< B1413
        constexpr uint32_t B1414 = (1U << 6);  ///< B1414
        constexpr uint32_t B1415 = (1U << 7);  ///< B1415
        constexpr uint32_t B1416 = (1U << 8);  ///< B1416
        constexpr uint32_t B1417 = (1U << 9);  ///< B1417
        constexpr uint32_t B1418 = (1U << 10);  ///< B1418
        constexpr uint32_t B1419 = (1U << 11);  ///< B1419
        constexpr uint32_t B1420 = (1U << 12);  ///< B1420
        constexpr uint32_t B1421 = (1U << 13);  ///< B1421
        constexpr uint32_t B1422 = (1U << 14);  ///< B1422
        constexpr uint32_t B1423 = (1U << 15);  ///< B1423
        constexpr uint32_t B1424 = (1U << 16);  ///< B1424
        constexpr uint32_t B1425 = (1U << 17);  ///< B1425
        constexpr uint32_t B1426 = (1U << 18);  ///< B1426
        constexpr uint32_t B1427 = (1U << 19);  ///< B1427
        constexpr uint32_t B1428 = (1U << 20);  ///< B1428
        constexpr uint32_t B1429 = (1U << 21);  ///< B1429
        constexpr uint32_t B1430 = (1U << 22);  ///< B1430
        constexpr uint32_t B1431 = (1U << 23);  ///< B1431
        constexpr uint32_t B1432 = (1U << 24);  ///< B1432
        constexpr uint32_t B1433 = (1U << 25);  ///< B1433
        constexpr uint32_t B1434 = (1U << 26);  ///< B1434
        constexpr uint32_t B1435 = (1U << 27);  ///< B1435
        constexpr uint32_t B1436 = (1U << 28);  ///< B1436
        constexpr uint32_t B1437 = (1U << 29);  ///< B1437
        constexpr uint32_t B1438 = (1U << 30);  ///< B1438
        constexpr uint32_t B1439 = (1U << 31);  ///< B1439
    }

    /// MPCBB1_VCTR45 Register bits
    namespace mpcbb1_vctr45_bits {
        constexpr uint32_t B1440 = (1U << 0);  ///< B1440
        constexpr uint32_t B1441 = (1U << 1);  ///< B1441
        constexpr uint32_t B1442 = (1U << 2);  ///< B1442
        constexpr uint32_t B1443 = (1U << 3);  ///< B1443
        constexpr uint32_t B1444 = (1U << 4);  ///< B1444
        constexpr uint32_t B1445 = (1U << 5);  ///< B1445
        constexpr uint32_t B1446 = (1U << 6);  ///< B1446
        constexpr uint32_t B1447 = (1U << 7);  ///< B1447
        constexpr uint32_t B1448 = (1U << 8);  ///< B1448
        constexpr uint32_t B1449 = (1U << 9);  ///< B1449
        constexpr uint32_t B1450 = (1U << 10);  ///< B1450
        constexpr uint32_t B1451 = (1U << 11);  ///< B1451
        constexpr uint32_t B1452 = (1U << 12);  ///< B1452
        constexpr uint32_t B1453 = (1U << 13);  ///< B1453
        constexpr uint32_t B1454 = (1U << 14);  ///< B1454
        constexpr uint32_t B1455 = (1U << 15);  ///< B1455
        constexpr uint32_t B1456 = (1U << 16);  ///< B1456
        constexpr uint32_t B1457 = (1U << 17);  ///< B1457
        constexpr uint32_t B1458 = (1U << 18);  ///< B1458
        constexpr uint32_t B1459 = (1U << 19);  ///< B1459
        constexpr uint32_t B1460 = (1U << 20);  ///< B1460
        constexpr uint32_t B1461 = (1U << 21);  ///< B1461
        constexpr uint32_t B1462 = (1U << 22);  ///< B1462
        constexpr uint32_t B1463 = (1U << 23);  ///< B1463
        constexpr uint32_t B1464 = (1U << 24);  ///< B1464
        constexpr uint32_t B1465 = (1U << 25);  ///< B1465
        constexpr uint32_t B1466 = (1U << 26);  ///< B1466
        constexpr uint32_t B1467 = (1U << 27);  ///< B1467
        constexpr uint32_t B1468 = (1U << 28);  ///< B1468
        constexpr uint32_t B1469 = (1U << 29);  ///< B1469
        constexpr uint32_t B1470 = (1U << 30);  ///< B1470
        constexpr uint32_t B1471 = (1U << 31);  ///< B1471
    }

    /// MPCBB1_VCTR46 Register bits
    namespace mpcbb1_vctr46_bits {
        constexpr uint32_t B1472 = (1U << 0);  ///< B1472
        constexpr uint32_t B1473 = (1U << 1);  ///< B1473
        constexpr uint32_t B1474 = (1U << 2);  ///< B1474
        constexpr uint32_t B1475 = (1U << 3);  ///< B1475
        constexpr uint32_t B1476 = (1U << 4);  ///< B1476
        constexpr uint32_t B1477 = (1U << 5);  ///< B1477
        constexpr uint32_t B1478 = (1U << 6);  ///< B1478
        constexpr uint32_t B1479 = (1U << 7);  ///< B1479
        constexpr uint32_t B1480 = (1U << 8);  ///< B1480
        constexpr uint32_t B1481 = (1U << 9);  ///< B1481
        constexpr uint32_t B1482 = (1U << 10);  ///< B1482
        constexpr uint32_t B1483 = (1U << 11);  ///< B1483
        constexpr uint32_t B1484 = (1U << 12);  ///< B1484
        constexpr uint32_t B1485 = (1U << 13);  ///< B1485
        constexpr uint32_t B1486 = (1U << 14);  ///< B1486
        constexpr uint32_t B1487 = (1U << 15);  ///< B1487
        constexpr uint32_t B1488 = (1U << 16);  ///< B1488
        constexpr uint32_t B1489 = (1U << 17);  ///< B1489
        constexpr uint32_t B1490 = (1U << 18);  ///< B1490
        constexpr uint32_t B1491 = (1U << 19);  ///< B1491
        constexpr uint32_t B1492 = (1U << 20);  ///< B1492
        constexpr uint32_t B1493 = (1U << 21);  ///< B1493
        constexpr uint32_t B1494 = (1U << 22);  ///< B1494
        constexpr uint32_t B1495 = (1U << 23);  ///< B1495
        constexpr uint32_t B1496 = (1U << 24);  ///< B1496
        constexpr uint32_t B1497 = (1U << 25);  ///< B1497
        constexpr uint32_t B1498 = (1U << 26);  ///< B1498
        constexpr uint32_t B1499 = (1U << 27);  ///< B1499
        constexpr uint32_t B1500 = (1U << 28);  ///< B1500
        constexpr uint32_t B1501 = (1U << 29);  ///< B1501
        constexpr uint32_t B1502 = (1U << 30);  ///< B1502
        constexpr uint32_t B1503 = (1U << 31);  ///< B1503
    }

    /// MPCBB1_VCTR47 Register bits
    namespace mpcbb1_vctr47_bits {
        constexpr uint32_t B1504 = (1U << 0);  ///< B1504
        constexpr uint32_t B1505 = (1U << 1);  ///< B1505
        constexpr uint32_t B1506 = (1U << 2);  ///< B1506
        constexpr uint32_t B1507 = (1U << 3);  ///< B1507
        constexpr uint32_t B1508 = (1U << 4);  ///< B1508
        constexpr uint32_t B1509 = (1U << 5);  ///< B1509
        constexpr uint32_t B1510 = (1U << 6);  ///< B1510
        constexpr uint32_t B1511 = (1U << 7);  ///< B1511
        constexpr uint32_t B1512 = (1U << 8);  ///< B1512
        constexpr uint32_t B1513 = (1U << 9);  ///< B1513
        constexpr uint32_t B1514 = (1U << 10);  ///< B1514
        constexpr uint32_t B1515 = (1U << 11);  ///< B1515
        constexpr uint32_t B1516 = (1U << 12);  ///< B1516
        constexpr uint32_t B1517 = (1U << 13);  ///< B1517
        constexpr uint32_t B1518 = (1U << 14);  ///< B1518
        constexpr uint32_t B1519 = (1U << 15);  ///< B1519
        constexpr uint32_t B1520 = (1U << 16);  ///< B1520
        constexpr uint32_t B1521 = (1U << 17);  ///< B1521
        constexpr uint32_t B1522 = (1U << 18);  ///< B1522
        constexpr uint32_t B1523 = (1U << 19);  ///< B1523
        constexpr uint32_t B1524 = (1U << 20);  ///< B1524
        constexpr uint32_t B1525 = (1U << 21);  ///< B1525
        constexpr uint32_t B1526 = (1U << 22);  ///< B1526
        constexpr uint32_t B1527 = (1U << 23);  ///< B1527
        constexpr uint32_t B1528 = (1U << 24);  ///< B1528
        constexpr uint32_t B1529 = (1U << 25);  ///< B1529
        constexpr uint32_t B1530 = (1U << 26);  ///< B1530
        constexpr uint32_t B1531 = (1U << 27);  ///< B1531
        constexpr uint32_t B1532 = (1U << 28);  ///< B1532
        constexpr uint32_t B1533 = (1U << 29);  ///< B1533
        constexpr uint32_t B1534 = (1U << 30);  ///< B1534
        constexpr uint32_t B1535 = (1U << 31);  ///< B1535
    }

    /// MPCBB1_VCTR48 Register bits
    namespace mpcbb1_vctr48_bits {
        constexpr uint32_t B1536 = (1U << 0);  ///< B1536
        constexpr uint32_t B1537 = (1U << 1);  ///< B1537
        constexpr uint32_t B1538 = (1U << 2);  ///< B1538
        constexpr uint32_t B1539 = (1U << 3);  ///< B1539
        constexpr uint32_t B1540 = (1U << 4);  ///< B1540
        constexpr uint32_t B1541 = (1U << 5);  ///< B1541
        constexpr uint32_t B1542 = (1U << 6);  ///< B1542
        constexpr uint32_t B1543 = (1U << 7);  ///< B1543
        constexpr uint32_t B1544 = (1U << 8);  ///< B1544
        constexpr uint32_t B1545 = (1U << 9);  ///< B1545
        constexpr uint32_t B1546 = (1U << 10);  ///< B1546
        constexpr uint32_t B1547 = (1U << 11);  ///< B1547
        constexpr uint32_t B1548 = (1U << 12);  ///< B1548
        constexpr uint32_t B1549 = (1U << 13);  ///< B1549
        constexpr uint32_t B1550 = (1U << 14);  ///< B1550
        constexpr uint32_t B1551 = (1U << 15);  ///< B1551
        constexpr uint32_t B1552 = (1U << 16);  ///< B1552
        constexpr uint32_t B1553 = (1U << 17);  ///< B1553
        constexpr uint32_t B1554 = (1U << 18);  ///< B1554
        constexpr uint32_t B1555 = (1U << 19);  ///< B1555
        constexpr uint32_t B1556 = (1U << 20);  ///< B1556
        constexpr uint32_t B1557 = (1U << 21);  ///< B1557
        constexpr uint32_t B1558 = (1U << 22);  ///< B1558
        constexpr uint32_t B1559 = (1U << 23);  ///< B1559
        constexpr uint32_t B1560 = (1U << 24);  ///< B1560
        constexpr uint32_t B1561 = (1U << 25);  ///< B1561
        constexpr uint32_t B1562 = (1U << 26);  ///< B1562
        constexpr uint32_t B1563 = (1U << 27);  ///< B1563
        constexpr uint32_t B1564 = (1U << 28);  ///< B1564
        constexpr uint32_t B1565 = (1U << 29);  ///< B1565
        constexpr uint32_t B1566 = (1U << 30);  ///< B1566
        constexpr uint32_t B1567 = (1U << 31);  ///< B1567
    }

    /// MPCBB1_VCTR49 Register bits
    namespace mpcbb1_vctr49_bits {
        constexpr uint32_t B1568 = (1U << 0);  ///< B1568
        constexpr uint32_t B1569 = (1U << 1);  ///< B1569
        constexpr uint32_t B1570 = (1U << 2);  ///< B1570
        constexpr uint32_t B1571 = (1U << 3);  ///< B1571
        constexpr uint32_t B1572 = (1U << 4);  ///< B1572
        constexpr uint32_t B1573 = (1U << 5);  ///< B1573
        constexpr uint32_t B1574 = (1U << 6);  ///< B1574
        constexpr uint32_t B1575 = (1U << 7);  ///< B1575
        constexpr uint32_t B1576 = (1U << 8);  ///< B1576
        constexpr uint32_t B1577 = (1U << 9);  ///< B1577
        constexpr uint32_t B1578 = (1U << 10);  ///< B1578
        constexpr uint32_t B1579 = (1U << 11);  ///< B1579
        constexpr uint32_t B1580 = (1U << 12);  ///< B1580
        constexpr uint32_t B1581 = (1U << 13);  ///< B1581
        constexpr uint32_t B1582 = (1U << 14);  ///< B1582
        constexpr uint32_t B1583 = (1U << 15);  ///< B1583
        constexpr uint32_t B1584 = (1U << 16);  ///< B1584
        constexpr uint32_t B1585 = (1U << 17);  ///< B1585
        constexpr uint32_t B1586 = (1U << 18);  ///< B1586
        constexpr uint32_t B1587 = (1U << 19);  ///< B1587
        constexpr uint32_t B1588 = (1U << 20);  ///< B1588
        constexpr uint32_t B1589 = (1U << 21);  ///< B1589
        constexpr uint32_t B1590 = (1U << 22);  ///< B1590
        constexpr uint32_t B1591 = (1U << 23);  ///< B1591
        constexpr uint32_t B1592 = (1U << 24);  ///< B1592
        constexpr uint32_t B1593 = (1U << 25);  ///< B1593
        constexpr uint32_t B1594 = (1U << 26);  ///< B1594
        constexpr uint32_t B1595 = (1U << 27);  ///< B1595
        constexpr uint32_t B1596 = (1U << 28);  ///< B1596
        constexpr uint32_t B1597 = (1U << 29);  ///< B1597
        constexpr uint32_t B1598 = (1U << 30);  ///< B1598
        constexpr uint32_t B1599 = (1U << 31);  ///< B1599
    }

    /// MPCBB1_VCTR50 Register bits
    namespace mpcbb1_vctr50_bits {
        constexpr uint32_t B1600 = (1U << 0);  ///< B1600
        constexpr uint32_t B1601 = (1U << 1);  ///< B1601
        constexpr uint32_t B1602 = (1U << 2);  ///< B1602
        constexpr uint32_t B1603 = (1U << 3);  ///< B1603
        constexpr uint32_t B1604 = (1U << 4);  ///< B1604
        constexpr uint32_t B1605 = (1U << 5);  ///< B1605
        constexpr uint32_t B1606 = (1U << 6);  ///< B1606
        constexpr uint32_t B1607 = (1U << 7);  ///< B1607
        constexpr uint32_t B1608 = (1U << 8);  ///< B1608
        constexpr uint32_t B1609 = (1U << 9);  ///< B1609
        constexpr uint32_t B1610 = (1U << 10);  ///< B1610
        constexpr uint32_t B1611 = (1U << 11);  ///< B1611
        constexpr uint32_t B1612 = (1U << 12);  ///< B1612
        constexpr uint32_t B1613 = (1U << 13);  ///< B1613
        constexpr uint32_t B1614 = (1U << 14);  ///< B1614
        constexpr uint32_t B1615 = (1U << 15);  ///< B1615
        constexpr uint32_t B1616 = (1U << 16);  ///< B1616
        constexpr uint32_t B1617 = (1U << 17);  ///< B1617
        constexpr uint32_t B1618 = (1U << 18);  ///< B1618
        constexpr uint32_t B1619 = (1U << 19);  ///< B1619
        constexpr uint32_t B1620 = (1U << 20);  ///< B1620
        constexpr uint32_t B1621 = (1U << 21);  ///< B1621
        constexpr uint32_t B1622 = (1U << 22);  ///< B1622
        constexpr uint32_t B1623 = (1U << 23);  ///< B1623
        constexpr uint32_t B1624 = (1U << 24);  ///< B1624
        constexpr uint32_t B1625 = (1U << 25);  ///< B1625
        constexpr uint32_t B1626 = (1U << 26);  ///< B1626
        constexpr uint32_t B1627 = (1U << 27);  ///< B1627
        constexpr uint32_t B1628 = (1U << 28);  ///< B1628
        constexpr uint32_t B1629 = (1U << 29);  ///< B1629
        constexpr uint32_t B1630 = (1U << 30);  ///< B1630
        constexpr uint32_t B1631 = (1U << 31);  ///< B1631
    }

    /// MPCBB1_VCTR51 Register bits
    namespace mpcbb1_vctr51_bits {
        constexpr uint32_t B1632 = (1U << 0);  ///< B1632
        constexpr uint32_t B1633 = (1U << 1);  ///< B1633
        constexpr uint32_t B1634 = (1U << 2);  ///< B1634
        constexpr uint32_t B1635 = (1U << 3);  ///< B1635
        constexpr uint32_t B1636 = (1U << 4);  ///< B1636
        constexpr uint32_t B1637 = (1U << 5);  ///< B1637
        constexpr uint32_t B1638 = (1U << 6);  ///< B1638
        constexpr uint32_t B1639 = (1U << 7);  ///< B1639
        constexpr uint32_t B1640 = (1U << 8);  ///< B1640
        constexpr uint32_t B1641 = (1U << 9);  ///< B1641
        constexpr uint32_t B1642 = (1U << 10);  ///< B1642
        constexpr uint32_t B1643 = (1U << 11);  ///< B1643
        constexpr uint32_t B1644 = (1U << 12);  ///< B1644
        constexpr uint32_t B1645 = (1U << 13);  ///< B1645
        constexpr uint32_t B1646 = (1U << 14);  ///< B1646
        constexpr uint32_t B1647 = (1U << 15);  ///< B1647
        constexpr uint32_t B1648 = (1U << 16);  ///< B1648
        constexpr uint32_t B1649 = (1U << 17);  ///< B1649
        constexpr uint32_t B1650 = (1U << 18);  ///< B1650
        constexpr uint32_t B1651 = (1U << 19);  ///< B1651
        constexpr uint32_t B1652 = (1U << 20);  ///< B1652
        constexpr uint32_t B1653 = (1U << 21);  ///< B1653
        constexpr uint32_t B1654 = (1U << 22);  ///< B1654
        constexpr uint32_t B1655 = (1U << 23);  ///< B1655
        constexpr uint32_t B1656 = (1U << 24);  ///< B1656
        constexpr uint32_t B1657 = (1U << 25);  ///< B1657
        constexpr uint32_t B1658 = (1U << 26);  ///< B1658
        constexpr uint32_t B1659 = (1U << 27);  ///< B1659
        constexpr uint32_t B1660 = (1U << 28);  ///< B1660
        constexpr uint32_t B1661 = (1U << 29);  ///< B1661
        constexpr uint32_t B1662 = (1U << 30);  ///< B1662
        constexpr uint32_t B1663 = (1U << 31);  ///< B1663
    }

    /// MPCBB1_VCTR52 Register bits
    namespace mpcbb1_vctr52_bits {
        constexpr uint32_t B1664 = (1U << 0);  ///< B1664
        constexpr uint32_t B1665 = (1U << 1);  ///< B1665
        constexpr uint32_t B1666 = (1U << 2);  ///< B1666
        constexpr uint32_t B1667 = (1U << 3);  ///< B1667
        constexpr uint32_t B1668 = (1U << 4);  ///< B1668
        constexpr uint32_t B1669 = (1U << 5);  ///< B1669
        constexpr uint32_t B1670 = (1U << 6);  ///< B1670
        constexpr uint32_t B1671 = (1U << 7);  ///< B1671
        constexpr uint32_t B1672 = (1U << 8);  ///< B1672
        constexpr uint32_t B1673 = (1U << 9);  ///< B1673
        constexpr uint32_t B1674 = (1U << 10);  ///< B1674
        constexpr uint32_t B1675 = (1U << 11);  ///< B1675
        constexpr uint32_t B1676 = (1U << 12);  ///< B1676
        constexpr uint32_t B1677 = (1U << 13);  ///< B1677
        constexpr uint32_t B1678 = (1U << 14);  ///< B1678
        constexpr uint32_t B1679 = (1U << 15);  ///< B1679
        constexpr uint32_t B1680 = (1U << 16);  ///< B1680
        constexpr uint32_t B1681 = (1U << 17);  ///< B1681
        constexpr uint32_t B1682 = (1U << 18);  ///< B1682
        constexpr uint32_t B1683 = (1U << 19);  ///< B1683
        constexpr uint32_t B1684 = (1U << 20);  ///< B1684
        constexpr uint32_t B1685 = (1U << 21);  ///< B1685
        constexpr uint32_t B1686 = (1U << 22);  ///< B1686
        constexpr uint32_t B1687 = (1U << 23);  ///< B1687
        constexpr uint32_t B1688 = (1U << 24);  ///< B1688
        constexpr uint32_t B1689 = (1U << 25);  ///< B1689
        constexpr uint32_t B1690 = (1U << 26);  ///< B1690
        constexpr uint32_t B1691 = (1U << 27);  ///< B1691
        constexpr uint32_t B1692 = (1U << 28);  ///< B1692
        constexpr uint32_t B1693 = (1U << 29);  ///< B1693
        constexpr uint32_t B1694 = (1U << 30);  ///< B1694
        constexpr uint32_t B1695 = (1U << 31);  ///< B1695
    }

    /// MPCBB1_VCTR53 Register bits
    namespace mpcbb1_vctr53_bits {
        constexpr uint32_t B1696 = (1U << 0);  ///< B1696
        constexpr uint32_t B1697 = (1U << 1);  ///< B1697
        constexpr uint32_t B1698 = (1U << 2);  ///< B1698
        constexpr uint32_t B1699 = (1U << 3);  ///< B1699
        constexpr uint32_t B1700 = (1U << 4);  ///< B1700
        constexpr uint32_t B1701 = (1U << 5);  ///< B1701
        constexpr uint32_t B1702 = (1U << 6);  ///< B1702
        constexpr uint32_t B1703 = (1U << 7);  ///< B1703
        constexpr uint32_t B1704 = (1U << 8);  ///< B1704
        constexpr uint32_t B1705 = (1U << 9);  ///< B1705
        constexpr uint32_t B1706 = (1U << 10);  ///< B1706
        constexpr uint32_t B1707 = (1U << 11);  ///< B1707
        constexpr uint32_t B1708 = (1U << 12);  ///< B1708
        constexpr uint32_t B1709 = (1U << 13);  ///< B1709
        constexpr uint32_t B1710 = (1U << 14);  ///< B1710
        constexpr uint32_t B1711 = (1U << 15);  ///< B1711
        constexpr uint32_t B1712 = (1U << 16);  ///< B1712
        constexpr uint32_t B1713 = (1U << 17);  ///< B1713
        constexpr uint32_t B1714 = (1U << 18);  ///< B1714
        constexpr uint32_t B1715 = (1U << 19);  ///< B1715
        constexpr uint32_t B1716 = (1U << 20);  ///< B1716
        constexpr uint32_t B1717 = (1U << 21);  ///< B1717
        constexpr uint32_t B1718 = (1U << 22);  ///< B1718
        constexpr uint32_t B1719 = (1U << 23);  ///< B1719
        constexpr uint32_t B1720 = (1U << 24);  ///< B1720
        constexpr uint32_t B1721 = (1U << 25);  ///< B1721
        constexpr uint32_t B1722 = (1U << 26);  ///< B1722
        constexpr uint32_t B1723 = (1U << 27);  ///< B1723
        constexpr uint32_t B1724 = (1U << 28);  ///< B1724
        constexpr uint32_t B1725 = (1U << 29);  ///< B1725
        constexpr uint32_t B1726 = (1U << 30);  ///< B1726
        constexpr uint32_t B1727 = (1U << 31);  ///< B1727
    }

    /// MPCBB1_VCTR54 Register bits
    namespace mpcbb1_vctr54_bits {
        constexpr uint32_t B1728 = (1U << 0);  ///< B1728
        constexpr uint32_t B1729 = (1U << 1);  ///< B1729
        constexpr uint32_t B1730 = (1U << 2);  ///< B1730
        constexpr uint32_t B1731 = (1U << 3);  ///< B1731
        constexpr uint32_t B1732 = (1U << 4);  ///< B1732
        constexpr uint32_t B1733 = (1U << 5);  ///< B1733
        constexpr uint32_t B1734 = (1U << 6);  ///< B1734
        constexpr uint32_t B1735 = (1U << 7);  ///< B1735
        constexpr uint32_t B1736 = (1U << 8);  ///< B1736
        constexpr uint32_t B1737 = (1U << 9);  ///< B1737
        constexpr uint32_t B1738 = (1U << 10);  ///< B1738
        constexpr uint32_t B1739 = (1U << 11);  ///< B1739
        constexpr uint32_t B1740 = (1U << 12);  ///< B1740
        constexpr uint32_t B1741 = (1U << 13);  ///< B1741
        constexpr uint32_t B1742 = (1U << 14);  ///< B1742
        constexpr uint32_t B1743 = (1U << 15);  ///< B1743
        constexpr uint32_t B1744 = (1U << 16);  ///< B1744
        constexpr uint32_t B1745 = (1U << 17);  ///< B1745
        constexpr uint32_t B1746 = (1U << 18);  ///< B1746
        constexpr uint32_t B1747 = (1U << 19);  ///< B1747
        constexpr uint32_t B1748 = (1U << 20);  ///< B1748
        constexpr uint32_t B1749 = (1U << 21);  ///< B1749
        constexpr uint32_t B1750 = (1U << 22);  ///< B1750
        constexpr uint32_t B1751 = (1U << 23);  ///< B1751
        constexpr uint32_t B1752 = (1U << 24);  ///< B1752
        constexpr uint32_t B1753 = (1U << 25);  ///< B1753
        constexpr uint32_t B1754 = (1U << 26);  ///< B1754
        constexpr uint32_t B1755 = (1U << 27);  ///< B1755
        constexpr uint32_t B1756 = (1U << 28);  ///< B1756
        constexpr uint32_t B1757 = (1U << 29);  ///< B1757
        constexpr uint32_t B1758 = (1U << 30);  ///< B1758
        constexpr uint32_t B1759 = (1U << 31);  ///< B1759
    }

    /// MPCBB1_VCTR55 Register bits
    namespace mpcbb1_vctr55_bits {
        constexpr uint32_t B1760 = (1U << 0);  ///< B1760
        constexpr uint32_t B1761 = (1U << 1);  ///< B1761
        constexpr uint32_t B1762 = (1U << 2);  ///< B1762
        constexpr uint32_t B1763 = (1U << 3);  ///< B1763
        constexpr uint32_t B1764 = (1U << 4);  ///< B1764
        constexpr uint32_t B1765 = (1U << 5);  ///< B1765
        constexpr uint32_t B1766 = (1U << 6);  ///< B1766
        constexpr uint32_t B1767 = (1U << 7);  ///< B1767
        constexpr uint32_t B1768 = (1U << 8);  ///< B1768
        constexpr uint32_t B1769 = (1U << 9);  ///< B1769
        constexpr uint32_t B1770 = (1U << 10);  ///< B1770
        constexpr uint32_t B1771 = (1U << 11);  ///< B1771
        constexpr uint32_t B1772 = (1U << 12);  ///< B1772
        constexpr uint32_t B1773 = (1U << 13);  ///< B1773
        constexpr uint32_t B1774 = (1U << 14);  ///< B1774
        constexpr uint32_t B1775 = (1U << 15);  ///< B1775
        constexpr uint32_t B1776 = (1U << 16);  ///< B1776
        constexpr uint32_t B1777 = (1U << 17);  ///< B1777
        constexpr uint32_t B1778 = (1U << 18);  ///< B1778
        constexpr uint32_t B1779 = (1U << 19);  ///< B1779
        constexpr uint32_t B1780 = (1U << 20);  ///< B1780
        constexpr uint32_t B1781 = (1U << 21);  ///< B1781
        constexpr uint32_t B1782 = (1U << 22);  ///< B1782
        constexpr uint32_t B1783 = (1U << 23);  ///< B1783
        constexpr uint32_t B1784 = (1U << 24);  ///< B1784
        constexpr uint32_t B1785 = (1U << 25);  ///< B1785
        constexpr uint32_t B1786 = (1U << 26);  ///< B1786
        constexpr uint32_t B1787 = (1U << 27);  ///< B1787
        constexpr uint32_t B1788 = (1U << 28);  ///< B1788
        constexpr uint32_t B1789 = (1U << 29);  ///< B1789
        constexpr uint32_t B1790 = (1U << 30);  ///< B1790
        constexpr uint32_t B1791 = (1U << 31);  ///< B1791
    }

    /// MPCBB1_VCTR56 Register bits
    namespace mpcbb1_vctr56_bits {
        constexpr uint32_t B1792 = (1U << 0);  ///< B1792
        constexpr uint32_t B1793 = (1U << 1);  ///< B1793
        constexpr uint32_t B1794 = (1U << 2);  ///< B1794
        constexpr uint32_t B1795 = (1U << 3);  ///< B1795
        constexpr uint32_t B1796 = (1U << 4);  ///< B1796
        constexpr uint32_t B1797 = (1U << 5);  ///< B1797
        constexpr uint32_t B1798 = (1U << 6);  ///< B1798
        constexpr uint32_t B1799 = (1U << 7);  ///< B1799
        constexpr uint32_t B1800 = (1U << 8);  ///< B1800
        constexpr uint32_t B1801 = (1U << 9);  ///< B1801
        constexpr uint32_t B1802 = (1U << 10);  ///< B1802
        constexpr uint32_t B1803 = (1U << 11);  ///< B1803
        constexpr uint32_t B1804 = (1U << 12);  ///< B1804
        constexpr uint32_t B1805 = (1U << 13);  ///< B1805
        constexpr uint32_t B1806 = (1U << 14);  ///< B1806
        constexpr uint32_t B1807 = (1U << 15);  ///< B1807
        constexpr uint32_t B1808 = (1U << 16);  ///< B1808
        constexpr uint32_t B1809 = (1U << 17);  ///< B1809
        constexpr uint32_t B1810 = (1U << 18);  ///< B1810
        constexpr uint32_t B1811 = (1U << 19);  ///< B1811
        constexpr uint32_t B1812 = (1U << 20);  ///< B1812
        constexpr uint32_t B1813 = (1U << 21);  ///< B1813
        constexpr uint32_t B1814 = (1U << 22);  ///< B1814
        constexpr uint32_t B1815 = (1U << 23);  ///< B1815
        constexpr uint32_t B1816 = (1U << 24);  ///< B1816
        constexpr uint32_t B1817 = (1U << 25);  ///< B1817
        constexpr uint32_t B1818 = (1U << 26);  ///< B1818
        constexpr uint32_t B1819 = (1U << 27);  ///< B1819
        constexpr uint32_t B1820 = (1U << 28);  ///< B1820
        constexpr uint32_t B1821 = (1U << 29);  ///< B1821
        constexpr uint32_t B1822 = (1U << 30);  ///< B1822
        constexpr uint32_t B1823 = (1U << 31);  ///< B1823
    }

    /// MPCBB1_VCTR57 Register bits
    namespace mpcbb1_vctr57_bits {
        constexpr uint32_t B1824 = (1U << 0);  ///< B1824
        constexpr uint32_t B1825 = (1U << 1);  ///< B1825
        constexpr uint32_t B1826 = (1U << 2);  ///< B1826
        constexpr uint32_t B1827 = (1U << 3);  ///< B1827
        constexpr uint32_t B1828 = (1U << 4);  ///< B1828
        constexpr uint32_t B1829 = (1U << 5);  ///< B1829
        constexpr uint32_t B1830 = (1U << 6);  ///< B1830
        constexpr uint32_t B1831 = (1U << 7);  ///< B1831
        constexpr uint32_t B1832 = (1U << 8);  ///< B1832
        constexpr uint32_t B1833 = (1U << 9);  ///< B1833
        constexpr uint32_t B1834 = (1U << 10);  ///< B1834
        constexpr uint32_t B1835 = (1U << 11);  ///< B1835
        constexpr uint32_t B1836 = (1U << 12);  ///< B1836
        constexpr uint32_t B1837 = (1U << 13);  ///< B1837
        constexpr uint32_t B1838 = (1U << 14);  ///< B1838
        constexpr uint32_t B1839 = (1U << 15);  ///< B1839
        constexpr uint32_t B1840 = (1U << 16);  ///< B1840
        constexpr uint32_t B1841 = (1U << 17);  ///< B1841
        constexpr uint32_t B1842 = (1U << 18);  ///< B1842
        constexpr uint32_t B1843 = (1U << 19);  ///< B1843
        constexpr uint32_t B1844 = (1U << 20);  ///< B1844
        constexpr uint32_t B1845 = (1U << 21);  ///< B1845
        constexpr uint32_t B1846 = (1U << 22);  ///< B1846
        constexpr uint32_t B1847 = (1U << 23);  ///< B1847
        constexpr uint32_t B1848 = (1U << 24);  ///< B1848
        constexpr uint32_t B1849 = (1U << 25);  ///< B1849
        constexpr uint32_t B1850 = (1U << 26);  ///< B1850
        constexpr uint32_t B1851 = (1U << 27);  ///< B1851
        constexpr uint32_t B1852 = (1U << 28);  ///< B1852
        constexpr uint32_t B1853 = (1U << 29);  ///< B1853
        constexpr uint32_t B1854 = (1U << 30);  ///< B1854
        constexpr uint32_t B1855 = (1U << 31);  ///< B1855
    }

    /// MPCBB1_VCTR58 Register bits
    namespace mpcbb1_vctr58_bits {
        constexpr uint32_t B1856 = (1U << 0);  ///< B1856
        constexpr uint32_t B1857 = (1U << 1);  ///< B1857
        constexpr uint32_t B1858 = (1U << 2);  ///< B1858
        constexpr uint32_t B1859 = (1U << 3);  ///< B1859
        constexpr uint32_t B1860 = (1U << 4);  ///< B1860
        constexpr uint32_t B1861 = (1U << 5);  ///< B1861
        constexpr uint32_t B1862 = (1U << 6);  ///< B1862
        constexpr uint32_t B1863 = (1U << 7);  ///< B1863
        constexpr uint32_t B1864 = (1U << 8);  ///< B1864
        constexpr uint32_t B1865 = (1U << 9);  ///< B1865
        constexpr uint32_t B1866 = (1U << 10);  ///< B1866
        constexpr uint32_t B1867 = (1U << 11);  ///< B1867
        constexpr uint32_t B1868 = (1U << 12);  ///< B1868
        constexpr uint32_t B1869 = (1U << 13);  ///< B1869
        constexpr uint32_t B1870 = (1U << 14);  ///< B1870
        constexpr uint32_t B1871 = (1U << 15);  ///< B1871
        constexpr uint32_t B1872 = (1U << 16);  ///< B1872
        constexpr uint32_t B1873 = (1U << 17);  ///< B1873
        constexpr uint32_t B1874 = (1U << 18);  ///< B1874
        constexpr uint32_t B1875 = (1U << 19);  ///< B1875
        constexpr uint32_t B1876 = (1U << 20);  ///< B1876
        constexpr uint32_t B1877 = (1U << 21);  ///< B1877
        constexpr uint32_t B1878 = (1U << 22);  ///< B1878
        constexpr uint32_t B1879 = (1U << 23);  ///< B1879
        constexpr uint32_t B1880 = (1U << 24);  ///< B1880
        constexpr uint32_t B1881 = (1U << 25);  ///< B1881
        constexpr uint32_t B1882 = (1U << 26);  ///< B1882
        constexpr uint32_t B1883 = (1U << 27);  ///< B1883
        constexpr uint32_t B1884 = (1U << 28);  ///< B1884
        constexpr uint32_t B1885 = (1U << 29);  ///< B1885
        constexpr uint32_t B1886 = (1U << 30);  ///< B1886
        constexpr uint32_t B1887 = (1U << 31);  ///< B1887
    }

    /// MPCBB1_VCTR59 Register bits
    namespace mpcbb1_vctr59_bits {
        constexpr uint32_t B1888 = (1U << 0);  ///< B1888
        constexpr uint32_t B1889 = (1U << 1);  ///< B1889
        constexpr uint32_t B1890 = (1U << 2);  ///< B1890
        constexpr uint32_t B1891 = (1U << 3);  ///< B1891
        constexpr uint32_t B1892 = (1U << 4);  ///< B1892
        constexpr uint32_t B1893 = (1U << 5);  ///< B1893
        constexpr uint32_t B1894 = (1U << 6);  ///< B1894
        constexpr uint32_t B1895 = (1U << 7);  ///< B1895
        constexpr uint32_t B1896 = (1U << 8);  ///< B1896
        constexpr uint32_t B1897 = (1U << 9);  ///< B1897
        constexpr uint32_t B1898 = (1U << 10);  ///< B1898
        constexpr uint32_t B1899 = (1U << 11);  ///< B1899
        constexpr uint32_t B1900 = (1U << 12);  ///< B1900
        constexpr uint32_t B1901 = (1U << 13);  ///< B1901
        constexpr uint32_t B1902 = (1U << 14);  ///< B1902
        constexpr uint32_t B1903 = (1U << 15);  ///< B1903
        constexpr uint32_t B1904 = (1U << 16);  ///< B1904
        constexpr uint32_t B1905 = (1U << 17);  ///< B1905
        constexpr uint32_t B1906 = (1U << 18);  ///< B1906
        constexpr uint32_t B1907 = (1U << 19);  ///< B1907
        constexpr uint32_t B1908 = (1U << 20);  ///< B1908
        constexpr uint32_t B1909 = (1U << 21);  ///< B1909
        constexpr uint32_t B1910 = (1U << 22);  ///< B1910
        constexpr uint32_t B1911 = (1U << 23);  ///< B1911
        constexpr uint32_t B1912 = (1U << 24);  ///< B1912
        constexpr uint32_t B1913 = (1U << 25);  ///< B1913
        constexpr uint32_t B1914 = (1U << 26);  ///< B1914
        constexpr uint32_t B1915 = (1U << 27);  ///< B1915
        constexpr uint32_t B1916 = (1U << 28);  ///< B1916
        constexpr uint32_t B1917 = (1U << 29);  ///< B1917
        constexpr uint32_t B1918 = (1U << 30);  ///< B1918
        constexpr uint32_t B1919 = (1U << 31);  ///< B1919
    }

    /// MPCBB1_VCTR60 Register bits
    namespace mpcbb1_vctr60_bits {
        constexpr uint32_t B1920 = (1U << 0);  ///< B1920
        constexpr uint32_t B1921 = (1U << 1);  ///< B1921
        constexpr uint32_t B1922 = (1U << 2);  ///< B1922
        constexpr uint32_t B1923 = (1U << 3);  ///< B1923
        constexpr uint32_t B1924 = (1U << 4);  ///< B1924
        constexpr uint32_t B1925 = (1U << 5);  ///< B1925
        constexpr uint32_t B1926 = (1U << 6);  ///< B1926
        constexpr uint32_t B1927 = (1U << 7);  ///< B1927
        constexpr uint32_t B1928 = (1U << 8);  ///< B1928
        constexpr uint32_t B1929 = (1U << 9);  ///< B1929
        constexpr uint32_t B1930 = (1U << 10);  ///< B1930
        constexpr uint32_t B1931 = (1U << 11);  ///< B1931
        constexpr uint32_t B1932 = (1U << 12);  ///< B1932
        constexpr uint32_t B1933 = (1U << 13);  ///< B1933
        constexpr uint32_t B1934 = (1U << 14);  ///< B1934
        constexpr uint32_t B1935 = (1U << 15);  ///< B1935
        constexpr uint32_t B1936 = (1U << 16);  ///< B1936
        constexpr uint32_t B1937 = (1U << 17);  ///< B1937
        constexpr uint32_t B1938 = (1U << 18);  ///< B1938
        constexpr uint32_t B1939 = (1U << 19);  ///< B1939
        constexpr uint32_t B1940 = (1U << 20);  ///< B1940
        constexpr uint32_t B1941 = (1U << 21);  ///< B1941
        constexpr uint32_t B1942 = (1U << 22);  ///< B1942
        constexpr uint32_t B1943 = (1U << 23);  ///< B1943
        constexpr uint32_t B1944 = (1U << 24);  ///< B1944
        constexpr uint32_t B1945 = (1U << 25);  ///< B1945
        constexpr uint32_t B1946 = (1U << 26);  ///< B1946
        constexpr uint32_t B1947 = (1U << 27);  ///< B1947
        constexpr uint32_t B1948 = (1U << 28);  ///< B1948
        constexpr uint32_t B1949 = (1U << 29);  ///< B1949
        constexpr uint32_t B1950 = (1U << 30);  ///< B1950
        constexpr uint32_t B1951 = (1U << 31);  ///< B1951
    }

    /// MPCBB1_VCTR61 Register bits
    namespace mpcbb1_vctr61_bits {
        constexpr uint32_t B1952 = (1U << 0);  ///< B1952
        constexpr uint32_t B1953 = (1U << 1);  ///< B1953
        constexpr uint32_t B1954 = (1U << 2);  ///< B1954
        constexpr uint32_t B1955 = (1U << 3);  ///< B1955
        constexpr uint32_t B1956 = (1U << 4);  ///< B1956
        constexpr uint32_t B1957 = (1U << 5);  ///< B1957
        constexpr uint32_t B1958 = (1U << 6);  ///< B1958
        constexpr uint32_t B1959 = (1U << 7);  ///< B1959
        constexpr uint32_t B1960 = (1U << 8);  ///< B1960
        constexpr uint32_t B1961 = (1U << 9);  ///< B1961
        constexpr uint32_t B1962 = (1U << 10);  ///< B1962
        constexpr uint32_t B1963 = (1U << 11);  ///< B1963
        constexpr uint32_t B1964 = (1U << 12);  ///< B1964
        constexpr uint32_t B1965 = (1U << 13);  ///< B1965
        constexpr uint32_t B1966 = (1U << 14);  ///< B1966
        constexpr uint32_t B1967 = (1U << 15);  ///< B1967
        constexpr uint32_t B1968 = (1U << 16);  ///< B1968
        constexpr uint32_t B1969 = (1U << 17);  ///< B1969
        constexpr uint32_t B1970 = (1U << 18);  ///< B1970
        constexpr uint32_t B1971 = (1U << 19);  ///< B1971
        constexpr uint32_t B1972 = (1U << 20);  ///< B1972
        constexpr uint32_t B1973 = (1U << 21);  ///< B1973
        constexpr uint32_t B1974 = (1U << 22);  ///< B1974
        constexpr uint32_t B1975 = (1U << 23);  ///< B1975
        constexpr uint32_t B1976 = (1U << 24);  ///< B1976
        constexpr uint32_t B1977 = (1U << 25);  ///< B1977
        constexpr uint32_t B1978 = (1U << 26);  ///< B1978
        constexpr uint32_t B1979 = (1U << 27);  ///< B1979
        constexpr uint32_t B1980 = (1U << 28);  ///< B1980
        constexpr uint32_t B1981 = (1U << 29);  ///< B1981
        constexpr uint32_t B1982 = (1U << 30);  ///< B1982
        constexpr uint32_t B1983 = (1U << 31);  ///< B1983
    }

    /// MPCBB1_VCTR62 Register bits
    namespace mpcbb1_vctr62_bits {
        constexpr uint32_t B1984 = (1U << 0);  ///< B1984
        constexpr uint32_t B1985 = (1U << 1);  ///< B1985
        constexpr uint32_t B1986 = (1U << 2);  ///< B1986
        constexpr uint32_t B1987 = (1U << 3);  ///< B1987
        constexpr uint32_t B1988 = (1U << 4);  ///< B1988
        constexpr uint32_t B1989 = (1U << 5);  ///< B1989
        constexpr uint32_t B1990 = (1U << 6);  ///< B1990
        constexpr uint32_t B1991 = (1U << 7);  ///< B1991
        constexpr uint32_t B1992 = (1U << 8);  ///< B1992
        constexpr uint32_t B1993 = (1U << 9);  ///< B1993
        constexpr uint32_t B1994 = (1U << 10);  ///< B1994
        constexpr uint32_t B1995 = (1U << 11);  ///< B1995
        constexpr uint32_t B1996 = (1U << 12);  ///< B1996
        constexpr uint32_t B1997 = (1U << 13);  ///< B1997
        constexpr uint32_t B1998 = (1U << 14);  ///< B1998
        constexpr uint32_t B1999 = (1U << 15);  ///< B1999
        constexpr uint32_t B2000 = (1U << 16);  ///< B2000
        constexpr uint32_t B2001 = (1U << 17);  ///< B2001
        constexpr uint32_t B2002 = (1U << 18);  ///< B2002
        constexpr uint32_t B2003 = (1U << 19);  ///< B2003
        constexpr uint32_t B2004 = (1U << 20);  ///< B2004
        constexpr uint32_t B2005 = (1U << 21);  ///< B2005
        constexpr uint32_t B2006 = (1U << 22);  ///< B2006
        constexpr uint32_t B2007 = (1U << 23);  ///< B2007
        constexpr uint32_t B2008 = (1U << 24);  ///< B2008
        constexpr uint32_t B2009 = (1U << 25);  ///< B2009
        constexpr uint32_t B2010 = (1U << 26);  ///< B2010
        constexpr uint32_t B2011 = (1U << 27);  ///< B2011
        constexpr uint32_t B2012 = (1U << 28);  ///< B2012
        constexpr uint32_t B2013 = (1U << 29);  ///< B2013
        constexpr uint32_t B2014 = (1U << 30);  ///< B2014
        constexpr uint32_t B2015 = (1U << 31);  ///< B2015
    }

    /// MPCBB1_VCTR63 Register bits
    namespace mpcbb1_vctr63_bits {
        constexpr uint32_t B2016 = (1U << 0);  ///< B2016
        constexpr uint32_t B2017 = (1U << 1);  ///< B2017
        constexpr uint32_t B2018 = (1U << 2);  ///< B2018
        constexpr uint32_t B2019 = (1U << 3);  ///< B2019
        constexpr uint32_t B2020 = (1U << 4);  ///< B2020
        constexpr uint32_t B2021 = (1U << 5);  ///< B2021
        constexpr uint32_t B2022 = (1U << 6);  ///< B2022
        constexpr uint32_t B2023 = (1U << 7);  ///< B2023
        constexpr uint32_t B2024 = (1U << 8);  ///< B2024
        constexpr uint32_t B2025 = (1U << 9);  ///< B2025
        constexpr uint32_t B2026 = (1U << 10);  ///< B2026
        constexpr uint32_t B2027 = (1U << 11);  ///< B2027
        constexpr uint32_t B2028 = (1U << 12);  ///< B2028
        constexpr uint32_t B2029 = (1U << 13);  ///< B2029
        constexpr uint32_t B2030 = (1U << 14);  ///< B2030
        constexpr uint32_t B2031 = (1U << 15);  ///< B2031
        constexpr uint32_t B2032 = (1U << 16);  ///< B2032
        constexpr uint32_t B2033 = (1U << 17);  ///< B2033
        constexpr uint32_t B2034 = (1U << 18);  ///< B2034
        constexpr uint32_t B2035 = (1U << 19);  ///< B2035
        constexpr uint32_t B2036 = (1U << 20);  ///< B2036
        constexpr uint32_t B2037 = (1U << 21);  ///< B2037
        constexpr uint32_t B2038 = (1U << 22);  ///< B2038
        constexpr uint32_t B2039 = (1U << 23);  ///< B2039
        constexpr uint32_t B2040 = (1U << 24);  ///< B2040
        constexpr uint32_t B2041 = (1U << 25);  ///< B2041
        constexpr uint32_t B2042 = (1U << 26);  ///< B2042
        constexpr uint32_t B2043 = (1U << 27);  ///< B2043
        constexpr uint32_t B2044 = (1U << 28);  ///< B2044
        constexpr uint32_t B2045 = (1U << 29);  ///< B2045
        constexpr uint32_t B2046 = (1U << 30);  ///< B2046
        constexpr uint32_t B2047 = (1U << 31);  ///< B2047
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAMUX1_BASE = 0x40020800;
    constexpr uint32_t SEC_DMAMUX1_BASE = 0x50020800;
    constexpr uint32_t DMA1_BASE = 0x40020000;
    constexpr uint32_t SEC_DMA1_BASE = 0x50020000;
    constexpr uint32_t DMA2_BASE = 0x40020400;
    constexpr uint32_t SEC_DMA2_BASE = 0x50020400;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t C0CR;  ///< Offset: 0x00 - DMA Multiplexer Channel 0 Control register
        volatile uint32_t C1CR;  ///< Offset: 0x04 - DMA Multiplexer Channel 1 Control register
        volatile uint32_t C2CR;  ///< Offset: 0x08 - DMA Multiplexer Channel 2 Control register
        volatile uint32_t C3CR;  ///< Offset: 0x0C - DMA Multiplexer Channel 3 Control register
        volatile uint32_t C4CR;  ///< Offset: 0x10 - DMA Multiplexer Channel 4 Control register
        volatile uint32_t C5CR;  ///< Offset: 0x14 - DMA Multiplexer Channel 5 Control register
        volatile uint32_t C6CR;  ///< Offset: 0x18 - DMA Multiplexer Channel 6 Control register
        volatile uint32_t C7CR;  ///< Offset: 0x1C - DMA Multiplexer Channel 7 Control register
        volatile uint32_t C8CR;  ///< Offset: 0x20 - DMA Multiplexer Channel 8 Control register
        volatile uint32_t C9CR;  ///< Offset: 0x24 - DMA Multiplexer Channel 9 Control register
        volatile uint32_t C10CR;  ///< Offset: 0x28 - DMA Multiplexer Channel 10 Control register
        volatile uint32_t C11CR;  ///< Offset: 0x2C - DMA Multiplexer Channel 11 Control register
        volatile uint32_t C12CR;  ///< Offset: 0x30 - DMA Multiplexer Channel 12 Control register
        volatile uint32_t C13CR;  ///< Offset: 0x34 - DMA Multiplexer Channel 13 Control register
        volatile uint32_t CSR;  ///< Offset: 0x80 - DMA Multiplexer Channel Status register
        volatile uint32_t CCFR;  ///< Offset: 0x84 - DMA Channel Clear Flag Register
        volatile uint32_t RG0CR;  ///< Offset: 0x100 - DMA Request Generator 0 Control Register
        volatile uint32_t RG1CR;  ///< Offset: 0x104 - DMA Request Generator 1 Control Register
        volatile uint32_t RG2CR;  ///< Offset: 0x108 - DMA Request Generator 2 Control Register
        volatile uint32_t RG3CR;  ///< Offset: 0x10C - DMA Request Generator 3 Control Register
        volatile uint32_t RGSR;  ///< Offset: 0x140 - DMA Request Generator Status Register
        volatile uint32_t RGCFR;  ///< Offset: 0x144 - DMA Request Generator Clear Flag Register
        volatile uint32_t C14CR;  ///< Offset: 0x138 - DMA Multiplexer Channel 10 Control register
        volatile uint32_t C15CR;  ///< Offset: 0x13C - DMA Multiplexer Channel 10 Control register
    };

    /// Peripheral instances
    inline Registers* DMAMUX1 = reinterpret_cast<Registers*>(DMAMUX1_BASE);
    inline Registers* SEC_DMAMUX1 = reinterpret_cast<Registers*>(SEC_DMAMUX1_BASE);
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);
    inline Registers* SEC_DMA1 = reinterpret_cast<Registers*>(SEC_DMA1_BASE);
    inline Registers* DMA2 = reinterpret_cast<Registers*>(DMA2_BASE);
    inline Registers* SEC_DMA2 = reinterpret_cast<Registers*>(SEC_DMA2_BASE);

    // Bit definitions
    /// C0CR Register bits
    namespace c0cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C1CR Register bits
    namespace c1cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C2CR Register bits
    namespace c2cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C3CR Register bits
    namespace c3cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C4CR Register bits
    namespace c4cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C5CR Register bits
    namespace c5cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t OIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C6CR Register bits
    namespace c6cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C7CR Register bits
    namespace c7cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C8CR Register bits
    namespace c8cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C9CR Register bits
    namespace c9cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C10CR Register bits
    namespace c10cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C11CR Register bits
    namespace c11cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C12CR Register bits
    namespace c12cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// C13CR Register bits
    namespace c13cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< SYNC_ID
        constexpr uint32_t NBREQ = (5 << 19);  ///< Nb request
        constexpr uint32_t SPOL = (2 << 17);  ///< Sync polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event Generation Enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization Overrun Interrupt Enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA Request ID
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t SOF0 = (1U << 0);  ///< Synchronization Overrun Flag 0
        constexpr uint32_t SOF1 = (1U << 1);  ///< Synchronization Overrun Flag 1
        constexpr uint32_t SOF2 = (1U << 2);  ///< Synchronization Overrun Flag 2
        constexpr uint32_t SOF3 = (1U << 3);  ///< Synchronization Overrun Flag 3
        constexpr uint32_t SOF4 = (1U << 4);  ///< Synchronization Overrun Flag 4
        constexpr uint32_t SOF5 = (1U << 5);  ///< Synchronization Overrun Flag 5
        constexpr uint32_t SOF6 = (1U << 6);  ///< Synchronization Overrun Flag 6
        constexpr uint32_t SOF7 = (1U << 7);  ///< Synchronization Overrun Flag 7
        constexpr uint32_t SOF8 = (1U << 8);  ///< Synchronization Overrun Flag 8
        constexpr uint32_t SOF9 = (1U << 9);  ///< Synchronization Overrun Flag 9
        constexpr uint32_t SOF10 = (1U << 10);  ///< Synchronization Overrun Flag 10
        constexpr uint32_t SOF11 = (1U << 11);  ///< Synchronization Overrun Flag 11
        constexpr uint32_t SOF12 = (1U << 12);  ///< Synchronization Overrun Flag 12
        constexpr uint32_t SOF13 = (1U << 13);  ///< Synchronization Overrun Flag 13
        constexpr uint32_t SOF14 = (1U << 14);  ///< Synchronization Overrun Flag 13
        constexpr uint32_t SOF15 = (1U << 15);  ///< Synchronization Overrun Flag 13
    }

    /// CCFR Register bits
    namespace ccfr_bits {
        constexpr uint32_t CSOF0 = (1U << 0);  ///< Synchronization Clear Overrun Flag 0
        constexpr uint32_t CSOF1 = (1U << 1);  ///< Synchronization Clear Overrun Flag 1
        constexpr uint32_t CSOF2 = (1U << 2);  ///< Synchronization Clear Overrun Flag 2
        constexpr uint32_t CSOF3 = (1U << 3);  ///< Synchronization Clear Overrun Flag 3
        constexpr uint32_t CSOF4 = (1U << 4);  ///< Synchronization Clear Overrun Flag 4
        constexpr uint32_t CSOF5 = (1U << 5);  ///< Synchronization Clear Overrun Flag 5
        constexpr uint32_t CSOF6 = (1U << 6);  ///< Synchronization Clear Overrun Flag 6
        constexpr uint32_t CSOF7 = (1U << 7);  ///< Synchronization Clear Overrun Flag 7
        constexpr uint32_t CSOF8 = (1U << 8);  ///< Synchronization Clear Overrun Flag 8
        constexpr uint32_t CSOF9 = (1U << 9);  ///< Synchronization Clear Overrun Flag 9
        constexpr uint32_t CSOF10 = (1U << 10);  ///< Synchronization Clear Overrun Flag 10
        constexpr uint32_t CSOF11 = (1U << 11);  ///< Synchronization Clear Overrun Flag 11
        constexpr uint32_t CSOF12 = (1U << 12);  ///< Synchronization Clear Overrun Flag 12
        constexpr uint32_t CSOF13 = (1U << 13);  ///< Synchronization Clear Overrun Flag 13
        constexpr uint32_t CSOF14 = (1U << 14);  ///< Synchronization Clear Overrun Flag 13
        constexpr uint32_t CSOF15 = (1U << 15);  ///< Synchronization Clear Overrun Flag 13
    }

    /// RG0CR Register bits
    namespace rg0cr_bits {
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of Request
        constexpr uint32_t GPOL = (2 << 17);  ///< Generation Polarity
        constexpr uint32_t GE = (1U << 16);  ///< Generation Enable
        constexpr uint32_t OIE = (1U << 8);  ///< Overrun Interrupt Enable
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal ID
    }

    /// RG1CR Register bits
    namespace rg1cr_bits {
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of Request
        constexpr uint32_t GPOL = (2 << 17);  ///< Generation Polarity
        constexpr uint32_t GE = (1U << 16);  ///< Generation Enable
        constexpr uint32_t OIE = (1U << 8);  ///< Overrun Interrupt Enable
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal ID
    }

    /// RG2CR Register bits
    namespace rg2cr_bits {
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of Request
        constexpr uint32_t GPOL = (2 << 17);  ///< Generation Polarity
        constexpr uint32_t GE = (1U << 16);  ///< Generation Enable
        constexpr uint32_t OIE = (1U << 8);  ///< Overrun Interrupt Enable
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal ID
    }

    /// RG3CR Register bits
    namespace rg3cr_bits {
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of Request
        constexpr uint32_t GPOL = (2 << 17);  ///< Generation Polarity
        constexpr uint32_t GE = (1U << 16);  ///< Generation Enable
        constexpr uint32_t OIE = (1U << 8);  ///< Overrun Interrupt Enable
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal ID
    }

    /// RGSR Register bits
    namespace rgsr_bits {
        constexpr uint32_t OF0 = (1U << 0);  ///< Generator Overrun Flag 0
        constexpr uint32_t OF1 = (1U << 1);  ///< Generator Overrun Flag 1
        constexpr uint32_t OF2 = (1U << 2);  ///< Generator Overrun Flag 2
        constexpr uint32_t OF3 = (1U << 3);  ///< Generator Overrun Flag 3
    }

    /// RGCFR Register bits
    namespace rgcfr_bits {
        constexpr uint32_t CSOF0 = (1U << 0);  ///< Generator Clear Overrun Flag 0
        constexpr uint32_t CSOF1 = (1U << 1);  ///< Generator Clear Overrun Flag 1
        constexpr uint32_t CSOF2 = (1U << 2);  ///< Generator Clear Overrun Flag 2
        constexpr uint32_t CSOF3 = (1U << 3);  ///< Generator Clear Overrun Flag 3
    }

    /// C14CR Register bits
    namespace c14cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification
    }

    /// C15CR Register bits
    namespace c15cr_bits {
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x4002F400;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t SECCFGR1;  ///< Offset: 0x14 - EXTI security configuration register
        volatile uint32_t PRIVCFGR1;  ///< Offset: 0x18 - EXTI privilege configuration register
        volatile uint32_t RTSR2;  ///< Offset: 0x20 - EXTI rising trigger selection register
        volatile uint32_t FTSR2;  ///< Offset: 0x24 - EXTI falling trigger selection register
        volatile uint32_t SWIER2;  ///< Offset: 0x28 - EXTI software interrupt event register
        volatile uint32_t RPR2;  ///< Offset: 0x2C - EXTI rising edge pending register
        volatile uint32_t FPR2;  ///< Offset: 0x30 - EXTI falling edge pending register
        volatile uint32_t SECCFGR2;  ///< Offset: 0x38 - EXTI security enable register
        volatile uint32_t PRIVCFGR2;  ///< Offset: 0x34 - EXTI security enable register
        volatile uint32_t EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t LOCKRG;  ///< Offset: 0x70 - EXTI lock register
        volatile uint32_t IMR1;  ///< Offset: 0x80 - EXTI CPU wakeup with interrupt mask register
        volatile uint32_t EMR1;  ///< Offset: 0x84 - EXTI CPU wakeup with event mask register
        volatile uint32_t IMR2;  ///< Offset: 0x90 - EXTI CPUm wakeup with interrupt mask register
        volatile uint32_t EMR2;  ///< Offset: 0x94 - EXTI CPU wakeup with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// RTSR1 Register bits
    namespace rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT22 = (1U << 22);  ///< Rising trigger event configuration bit of configurable event input x
    }

    /// FTSR1 Register bits
    namespace ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration bit of configurable event input x
        constexpr uint32_t FT22 = (1U << 22);  ///< Falling trigger event configuration bit of configurable event input x
    }

    /// SWIER1 Register bits
    namespace swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software interrupt on event x
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software interrupt on event x
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software interrupt on event x
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software interrupt on event x
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software interrupt on event x
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software interrupt on event x
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software interrupt on event x
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software interrupt on event x
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software interrupt on event x
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software interrupt on event x
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software interrupt on event x
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software interrupt on event x
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software interrupt on event x
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software interrupt on event x
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software interrupt on event x
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software interrupt on event x
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software interrupt on event x
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software interrupt on event x
        constexpr uint32_t SWI22 = (1U << 22);  ///< Software interrupt on event x
    }

    /// RPR1 Register bits
    namespace rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF1 = (1U << 1);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF2 = (1U << 2);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF3 = (1U << 3);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF4 = (1U << 4);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF6 = (1U << 6);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF7 = (1U << 7);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF8 = (1U << 8);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF9 = (1U << 9);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF10 = (1U << 10);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF11 = (1U << 11);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF12 = (1U << 12);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF13 = (1U << 13);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF14 = (1U << 14);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF15 = (1U << 15);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF16 = (1U << 16);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF21 = (1U << 21);  ///< configurable event inputs x rising edge pending bit
        constexpr uint32_t RPIF22 = (1U << 22);  ///< configurable event inputs x rising edge pending bit
    }

    /// FPR1 Register bits
    namespace fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF21 = (1U << 21);  ///< configurable event inputs x falling edge pending bit.
        constexpr uint32_t FPIF22 = (1U << 22);  ///< configurable event inputs x falling edge pending bit.
    }

    /// SECCFGR1 Register bits
    namespace seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< Security enable on event input x
        constexpr uint32_t SEC1 = (1U << 1);  ///< Security enable on event input x
        constexpr uint32_t SEC2 = (1U << 2);  ///< Security enable on event input x
        constexpr uint32_t SEC3 = (1U << 3);  ///< Security enable on event input x
        constexpr uint32_t SEC4 = (1U << 4);  ///< Security enable on event input x
        constexpr uint32_t SEC5 = (1U << 5);  ///< Security enable on event input x
        constexpr uint32_t SEC6 = (1U << 6);  ///< Security enable on event input x
        constexpr uint32_t SEC7 = (1U << 7);  ///< Security enable on event input x
        constexpr uint32_t SEC8 = (1U << 8);  ///< Security enable on event input x
        constexpr uint32_t SEC9 = (1U << 9);  ///< Security enable on event input x
        constexpr uint32_t SEC10 = (1U << 10);  ///< Security enable on event input x
        constexpr uint32_t SEC11 = (1U << 11);  ///< Security enable on event input x
        constexpr uint32_t SEC12 = (1U << 12);  ///< Security enable on event input x
        constexpr uint32_t SEC13 = (1U << 13);  ///< Security enable on event input x
        constexpr uint32_t SEC14 = (1U << 14);  ///< Security enable on event input x
        constexpr uint32_t SEC15 = (1U << 15);  ///< Security enable on event input x
        constexpr uint32_t SEC16 = (1U << 16);  ///< Security enable on event input x
        constexpr uint32_t SEC17 = (1U << 17);  ///< Security enable on event input x
        constexpr uint32_t SEC18 = (1U << 18);  ///< Security enable on event input x
        constexpr uint32_t SEC19 = (1U << 19);  ///< Security enable on event input x
        constexpr uint32_t SEC20 = (1U << 20);  ///< Security enable on event input x
        constexpr uint32_t SEC21 = (1U << 21);  ///< Security enable on event input x
        constexpr uint32_t SEC22 = (1U << 22);  ///< Security enable on event input x
        constexpr uint32_t SEC23 = (1U << 23);  ///< Security enable on event input x
        constexpr uint32_t SEC24 = (1U << 24);  ///< Security enable on event input x
        constexpr uint32_t SEC25 = (1U << 25);  ///< Security enable on event input x
        constexpr uint32_t SEC26 = (1U << 26);  ///< Security enable on event input x
        constexpr uint32_t SEC27 = (1U << 27);  ///< Security enable on event input x
        constexpr uint32_t SEC28 = (1U << 28);  ///< Security enable on event input x
        constexpr uint32_t SEC29 = (1U << 29);  ///< Security enable on event input x
        constexpr uint32_t SEC30 = (1U << 30);  ///< Security enable on event input x
        constexpr uint32_t SEC31 = (1U << 31);  ///< Security enable on event input x
    }

    /// PRIVCFGR1 Register bits
    namespace privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< Security enable on event input x
        constexpr uint32_t PRIV1 = (1U << 1);  ///< Security enable on event input x
        constexpr uint32_t PRIV2 = (1U << 2);  ///< Security enable on event input x
        constexpr uint32_t PRIV3 = (1U << 3);  ///< Security enable on event input x
        constexpr uint32_t PRIV4 = (1U << 4);  ///< Security enable on event input x
        constexpr uint32_t PRIV5 = (1U << 5);  ///< Security enable on event input x
        constexpr uint32_t PRIV6 = (1U << 6);  ///< Security enable on event input x
        constexpr uint32_t PRIV7 = (1U << 7);  ///< Security enable on event input x
        constexpr uint32_t PRIV8 = (1U << 8);  ///< Security enable on event input x
        constexpr uint32_t PRIV9 = (1U << 9);  ///< Security enable on event input x
        constexpr uint32_t PRIV10 = (1U << 10);  ///< Security enable on event input x
        constexpr uint32_t PRIV11 = (1U << 11);  ///< Security enable on event input x
        constexpr uint32_t PRIV12 = (1U << 12);  ///< Security enable on event input x
        constexpr uint32_t PRIV13 = (1U << 13);  ///< Security enable on event input x
        constexpr uint32_t PRIV14 = (1U << 14);  ///< Security enable on event input x
        constexpr uint32_t PRIV15 = (1U << 15);  ///< Security enable on event input x
        constexpr uint32_t PRIV16 = (1U << 16);  ///< Security enable on event input x
        constexpr uint32_t PRIV17 = (1U << 17);  ///< Security enable on event input x
        constexpr uint32_t PRIV18 = (1U << 18);  ///< Security enable on event input x
        constexpr uint32_t PRIV19 = (1U << 19);  ///< Security enable on event input x
        constexpr uint32_t PRIV20 = (1U << 20);  ///< Security enable on event input x
        constexpr uint32_t PRIV21 = (1U << 21);  ///< Security enable on event input x
        constexpr uint32_t PRIV22 = (1U << 22);  ///< Security enable on event input x
        constexpr uint32_t PRIV23 = (1U << 23);  ///< Security enable on event input x
        constexpr uint32_t PRIV24 = (1U << 24);  ///< Security enable on event input x
        constexpr uint32_t PRIV25 = (1U << 25);  ///< Security enable on event input x
        constexpr uint32_t PRIV26 = (1U << 26);  ///< Security enable on event input x
        constexpr uint32_t PRIV27 = (1U << 27);  ///< Security enable on event input x
        constexpr uint32_t PRIV28 = (1U << 28);  ///< Security enable on event input x
        constexpr uint32_t PRIV29 = (1U << 29);  ///< Security enable on event input x
        constexpr uint32_t PRIV30 = (1U << 30);  ///< Security enable on event input x
        constexpr uint32_t PRIV31 = (1U << 31);  ///< Security enable on event input x
    }

    /// RTSR2 Register bits
    namespace rtsr2_bits {
        constexpr uint32_t RT35 = (1U << 3);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT36 = (1U << 4);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT37 = (1U << 5);  ///< Rising trigger event configuration bit of configurable event input x
        constexpr uint32_t RT38 = (1U << 6);  ///< Rising trigger event configuration bit of configurable event input x
    }

    /// FTSR2 Register bits
    namespace ftsr2_bits {
        constexpr uint32_t FT35 = (1U << 3);  ///< FT35
        constexpr uint32_t FT36 = (1U << 4);  ///< FT36
        constexpr uint32_t FT37 = (1U << 5);  ///< FT37
        constexpr uint32_t FT38 = (1U << 6);  ///< FT38
    }

    /// SWIER2 Register bits
    namespace swier2_bits {
        constexpr uint32_t SWI35 = (1U << 3);  ///< SWI35
        constexpr uint32_t SWI36 = (1U << 4);  ///< SWI36
        constexpr uint32_t SWI37 = (1U << 5);  ///< SWI37
        constexpr uint32_t SWI38 = (1U << 6);  ///< SWI38
    }

    /// RPR2 Register bits
    namespace rpr2_bits {
        constexpr uint32_t RPIF35 = (1U << 3);  ///< RPIF35
        constexpr uint32_t RPIF36 = (1U << 4);  ///< RPIF36
        constexpr uint32_t RPIF37 = (1U << 5);  ///< RPIF37
        constexpr uint32_t RPIF38 = (1U << 6);  ///< RPIF38
    }

    /// FPR2 Register bits
    namespace fpr2_bits {
        constexpr uint32_t FPIF35 = (1U << 3);  ///< FPIF35
        constexpr uint32_t FPIF36 = (1U << 4);  ///< FPIF36
        constexpr uint32_t FPIF37 = (1U << 5);  ///< FPIF37
        constexpr uint32_t FPIF38 = (1U << 6);  ///< FPIF38
    }

    /// SECCFGR2 Register bits
    namespace seccfgr2_bits {
        constexpr uint32_t SEC32 = (1U << 0);  ///< SEC32
        constexpr uint32_t SEC33 = (1U << 1);  ///< SEC33
        constexpr uint32_t SEC34 = (1U << 2);  ///< SEC34
        constexpr uint32_t SEC35 = (1U << 3);  ///< SEC35
        constexpr uint32_t SEC36 = (1U << 4);  ///< SEC36
        constexpr uint32_t SEC37 = (1U << 5);  ///< SEC37
        constexpr uint32_t SEC38 = (1U << 6);  ///< SEC38
        constexpr uint32_t SEC39 = (1U << 7);  ///< SEC39
        constexpr uint32_t SEC40 = (1U << 8);  ///< SEC40
        constexpr uint32_t SEC41 = (1U << 9);  ///< SEC41
        constexpr uint32_t SEC42 = (1U << 10);  ///< SEC42
    }

    /// PRIVCFGR2 Register bits
    namespace privcfgr2_bits {
        constexpr uint32_t PRIV32 = (1U << 0);  ///< PRIV32
        constexpr uint32_t PRIV33 = (1U << 1);  ///< PRIV33
        constexpr uint32_t PRIV34 = (1U << 2);  ///< PRIV34
        constexpr uint32_t PRIV35 = (1U << 3);  ///< PRIV35
        constexpr uint32_t PRIV36 = (1U << 4);  ///< PRIV36
        constexpr uint32_t PRIV37 = (1U << 5);  ///< PRIV37
        constexpr uint32_t PRIV38 = (1U << 6);  ///< PRIV38
        constexpr uint32_t PRIV39 = (1U << 7);  ///< PRIV39
        constexpr uint32_t PRIV40 = (1U << 8);  ///< PRIV40
        constexpr uint32_t PRIV41 = (1U << 9);  ///< PRIV41
        constexpr uint32_t PRIV42 = (1U << 10);  ///< PRIV42
    }

    /// EXTICR1 Register bits
    namespace exticr1_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTICR2 Register bits
    namespace exticr2_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTICR3 Register bits
    namespace exticr3_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTICR4 Register bits
    namespace exticr4_bits {
        constexpr uint32_t EXTI0_7 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI8_15 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI16_23 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI24_31 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// LOCKRG Register bits
    namespace lockrg_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< LOCK
    }

    /// IMR1 Register bits
    namespace imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM17 = (1U << 17);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM18 = (1U << 18);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM26 = (1U << 26);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM27 = (1U << 27);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM28 = (1U << 28);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM29 = (1U << 29);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM30 = (1U << 30);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM31 = (1U << 31);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR1 Register bits
    namespace emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM17 = (1U << 17);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM18 = (1U << 18);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM20 = (1U << 20);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM22 = (1U << 22);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM24 = (1U << 24);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM26 = (1U << 26);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM27 = (1U << 27);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM28 = (1U << 28);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM29 = (1U << 29);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM30 = (1U << 30);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM31 = (1U << 31);  ///< CPU wakeup with interrupt mask on event input
    }

    /// IMR2 Register bits
    namespace imr2_bits {
        constexpr uint32_t IM32 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM33 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM34 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM35 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM36 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM37 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM38 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM40 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM41 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t IM42 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
    }

    /// EMR2 Register bits
    namespace emr2_bits {
        constexpr uint32_t EM32 = (1U << 0);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM33 = (1U << 1);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM34 = (1U << 2);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM35 = (1U << 3);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM36 = (1U << 4);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM37 = (1U << 5);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM38 = (1U << 6);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM40 = (1U << 8);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM41 = (1U << 9);  ///< CPU wakeup with interrupt mask on event input
        constexpr uint32_t EM42 = (1U << 10);  ///< CPU wakeup with interrupt mask on event input
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;
    constexpr uint32_t SEC_FLASH_BASE = 0x50022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t ACR;  ///< Offset: 0x00 - Access control register
        volatile uint32_t PDKEYR;  ///< Offset: 0x04 - Power down key register
        volatile uint32_t NSKEYR;  ///< Offset: 0x08 - Flash non-secure key register
        volatile uint32_t SECKEYR;  ///< Offset: 0x0C - Flash secure key register
        volatile uint32_t OPTKEYR;  ///< Offset: 0x10 - Flash option key register
        volatile uint32_t LVEKEYR;  ///< Offset: 0x14 - Flash low voltage key register
        volatile uint32_t NSSR;  ///< Offset: 0x20 - Flash status register
        volatile uint32_t SECSR;  ///< Offset: 0x24 - Flash status register
        volatile uint32_t NSCR;  ///< Offset: 0x28 - Flash non-secure control register
        volatile uint32_t SECCR;  ///< Offset: 0x2C - Flash secure control register
        volatile uint32_t ECCR;  ///< Offset: 0x30 - Flash ECC register
        volatile uint32_t OPTR;  ///< Offset: 0x40 - Flash option register
        volatile uint32_t NSBOOTADD0R;  ///< Offset: 0x44 - Flash non-secure boot address 0 register
        volatile uint32_t NSBOOTADD1R;  ///< Offset: 0x48 - Flash non-secure boot address 1 register
        volatile uint32_t SECBOOTADD0R;  ///< Offset: 0x4C - FFlash secure boot address 0 register
        volatile uint32_t SECWM1R1;  ///< Offset: 0x50 - Flash bank 1 secure watermak1 register
        volatile uint32_t SECWM1R2;  ///< Offset: 0x54 - Flash secure watermak1 register 2
        volatile uint32_t WRP1AR;  ///< Offset: 0x58 - Flash Bank 1 WRP area A address register
        volatile uint32_t WRP1BR;  ///< Offset: 0x5C - Flash Bank 1 WRP area B address register
        volatile uint32_t SECWM2R1;  ///< Offset: 0x60 - Flash secure watermak2 register
        volatile uint32_t SECWM2R2;  ///< Offset: 0x64 - Flash secure watermak2 register2
        volatile uint32_t WRP2AR;  ///< Offset: 0x68 - Flash WPR2 area A address register
        volatile uint32_t WRP2BR;  ///< Offset: 0x6C - Flash WPR2 area B address register
        volatile uint32_t SECBB1R1;  ///< Offset: 0x80 - FLASH secure block based bank 1 register
        volatile uint32_t SECBB1R2;  ///< Offset: 0x84 - FLASH secure block based bank 1 register
        volatile uint32_t SECBB1R3;  ///< Offset: 0x88 - FLASH secure block based bank 1 register
        volatile uint32_t SECBB1R4;  ///< Offset: 0x8C - FLASH secure block based bank 1 register
        volatile uint32_t SECBB2R1;  ///< Offset: 0xA0 - FLASH secure block based bank 2 register
        volatile uint32_t SECBB2R2;  ///< Offset: 0xA4 - FLASH secure block based bank 2 register
        volatile uint32_t SECBB2R3;  ///< Offset: 0xA8 - FLASH secure block based bank 2 register
        volatile uint32_t SECBB2R4;  ///< Offset: 0xAC - FLASH secure block based bank 2 register
        volatile uint32_t SECHDPCR;  ///< Offset: 0xC0 - FLASH secure HDP control register
        volatile uint32_t PRIVCFGR;  ///< Offset: 0xC4 - Power privilege configuration register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);
    inline Registers* SEC_FLASH = reinterpret_cast<Registers*>(SEC_FLASH_BASE);

    // Bit definitions
    /// ACR Register bits
    namespace acr_bits {
        constexpr uint32_t LATENCY = (4 << 0);  ///< Latency
        constexpr uint32_t RUN_PD = (1U << 13);  ///< Flash Power-down mode during Low-power run mode
        constexpr uint32_t SLEEP_PD = (1U << 14);  ///< Flash Power-down mode during Low-power sleep mode
        constexpr uint32_t LVEN = (1U << 15);  ///< LVEN
    }

    /// PDKEYR Register bits
    namespace pdkeyr_bits {
        constexpr uint32_t PDKEYR = (32 << 0);  ///< RUN_PD in FLASH_ACR key
    }

    /// NSKEYR Register bits
    namespace nskeyr_bits {
        constexpr uint32_t NSKEYR = (32 << 0);  ///< NSKEYR
    }

    /// SECKEYR Register bits
    namespace seckeyr_bits {
        constexpr uint32_t SECKEYR = (32 << 0);  ///< SECKEYR
    }

    /// OPTKEYR Register bits
    namespace optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< OPTKEYR
    }

    /// LVEKEYR Register bits
    namespace lvekeyr_bits {
        constexpr uint32_t LVEKEYR = (32 << 0);  ///< LVEKEYR
    }

    /// NSSR Register bits
    namespace nssr_bits {
        constexpr uint32_t NSEOP = (1U << 0);  ///< NSEOP
        constexpr uint32_t NSOPERR = (1U << 1);  ///< NSOPERR
        constexpr uint32_t NSPROGERR = (1U << 3);  ///< NSPROGERR
        constexpr uint32_t NSWRPERR = (1U << 4);  ///< NSWRPERR
        constexpr uint32_t NSPGAERR = (1U << 5);  ///< NSPGAERR
        constexpr uint32_t NSSIZERR = (1U << 6);  ///< NSSIZERR
        constexpr uint32_t NSPGSERR = (1U << 7);  ///< NSPGSERR
        constexpr uint32_t OPTWERR = (1U << 13);  ///< OPTWERR
        constexpr uint32_t OPTVERR = (1U << 15);  ///< OPTVERR
        constexpr uint32_t NSBSY = (1U << 16);  ///< NSBusy
    }

    /// SECSR Register bits
    namespace secsr_bits {
        constexpr uint32_t SECEOP = (1U << 0);  ///< SECEOP
        constexpr uint32_t SECOPERR = (1U << 1);  ///< SECOPERR
        constexpr uint32_t SECPROGERR = (1U << 3);  ///< SECPROGERR
        constexpr uint32_t SECWRPERR = (1U << 4);  ///< SECWRPERR
        constexpr uint32_t SECPGAERR = (1U << 5);  ///< SECPGAERR
        constexpr uint32_t SECSIZERR = (1U << 6);  ///< SECSIZERR
        constexpr uint32_t SECPGSERR = (1U << 7);  ///< SECPGSERR
        constexpr uint32_t SECRDERR = (1U << 14);  ///< Secure read protection error
        constexpr uint32_t SECBSY = (1U << 16);  ///< SECBusy
    }

    /// NSCR Register bits
    namespace nscr_bits {
        constexpr uint32_t NSPG = (1U << 0);  ///< NSPG
        constexpr uint32_t NSPER = (1U << 1);  ///< NSPER
        constexpr uint32_t NSMER1 = (1U << 2);  ///< NSMER1
        constexpr uint32_t NSPNB = (7 << 3);  ///< NSPNB
        constexpr uint32_t NSBKER = (1U << 11);  ///< NSBKER
        constexpr uint32_t NSMER2 = (1U << 15);  ///< NSMER2
        constexpr uint32_t NSSTRT = (1U << 16);  ///< Options modification start
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start
        constexpr uint32_t NSEOPIE = (1U << 24);  ///< NSEOPIE
        constexpr uint32_t NSERRIE = (1U << 25);  ///< NSERRIE
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock
        constexpr uint32_t NSLOCK = (1U << 31);  ///< NSLOCK
    }

    /// SECCR Register bits
    namespace seccr_bits {
        constexpr uint32_t SECPG = (1U << 0);  ///< SECPG
        constexpr uint32_t SECPER = (1U << 1);  ///< SECPER
        constexpr uint32_t SECMER1 = (1U << 2);  ///< SECMER1
        constexpr uint32_t SECPNB = (7 << 3);  ///< SECPNB
        constexpr uint32_t SECBKER = (1U << 11);  ///< SECBKER
        constexpr uint32_t SECMER2 = (1U << 15);  ///< SECMER2
        constexpr uint32_t SECSTRT = (1U << 16);  ///< SECSTRT
        constexpr uint32_t SECEOPIE = (1U << 24);  ///< SECEOPIE
        constexpr uint32_t SECERRIE = (1U << 25);  ///< SECERRIE
        constexpr uint32_t SECRDERRIE = (1U << 26);  ///< SECRDERRIE
        constexpr uint32_t SECINV = (1U << 29);  ///< SECINV
        constexpr uint32_t SECLOCK = (1U << 31);  ///< SECLOCK
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ADDR_ECC = (19 << 0);  ///< ECC fail address
        constexpr uint32_t BK_ECC = (1U << 21);  ///< BK_ECC
        constexpr uint32_t SYSF_ECC = (1U << 22);  ///< SYSF_ECC
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC2 = (1U << 28);  ///< ECCC2
        constexpr uint32_t ECCD2 = (1U << 29);  ///< ECCD2
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection
    }

    /// OPTR Register bits
    namespace optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level
        constexpr uint32_t BOR_LEV = (3 << 8);  ///< BOR reset Level
        constexpr uint32_t nRST_STOP = (1U << 12);  ///< nRST_STOP
        constexpr uint32_t nRST_STDBY = (1U << 13);  ///< nRST_STDBY
        constexpr uint32_t nRST_SHDW = (1U << 14);  ///< nRST_SHDW
        constexpr uint32_t IWDG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t SWAP_BANK = (1U << 20);  ///< SWAP_BANK
        constexpr uint32_t DB256K = (1U << 21);  ///< DB256K
        constexpr uint32_t DBANK = (1U << 22);  ///< DBANK
        constexpr uint32_t SRAM2_PE = (1U << 24);  ///< SRAM2 parity check enable
        constexpr uint32_t SRAM2_RST = (1U << 25);  ///< SRAM2 Erase when system reset
        constexpr uint32_t nSWBOOT0 = (1U << 26);  ///< nSWBOOT0
        constexpr uint32_t nBOOT0 = (1U << 27);  ///< nBOOT0
        constexpr uint32_t PA15_PUPEN = (1U << 28);  ///< PA15_PUPEN
        constexpr uint32_t TZEN = (1U << 31);  ///< TZEN
    }

    /// NSBOOTADD0R Register bits
    namespace nsbootadd0r_bits {
        constexpr uint32_t NSBOOTADD0 = (25 << 7);  ///< NSBOOTADD0
    }

    /// NSBOOTADD1R Register bits
    namespace nsbootadd1r_bits {
        constexpr uint32_t NSBOOTADD1 = (25 << 7);  ///< NSBOOTADD1
    }

    /// SECBOOTADD0R Register bits
    namespace secbootadd0r_bits {
        constexpr uint32_t BOOT_LOCK = (1U << 0);  ///< BOOT_LOCK
        constexpr uint32_t SECBOOTADD0 = (25 << 7);  ///< SECBOOTADD0
    }

    /// SECWM1R1 Register bits
    namespace secwm1r1_bits {
        constexpr uint32_t SECWM1_PSTRT = (7 << 0);  ///< SECWM1_PSTRT
        constexpr uint32_t SECWM1_PEND = (7 << 16);  ///< SECWM1_PEND
    }

    /// SECWM1R2 Register bits
    namespace secwm1r2_bits {
        constexpr uint32_t PCROP1_PSTRT = (7 << 0);  ///< PCROP1_PSTRT
        constexpr uint32_t PCROP1EN = (1U << 15);  ///< PCROP1EN
        constexpr uint32_t HDP1_PEND = (7 << 16);  ///< HDP1_PEND
        constexpr uint32_t HDP1EN = (1U << 31);  ///< HDP1EN
    }

    /// WRP1AR Register bits
    namespace wrp1ar_bits {
        constexpr uint32_t WRP1A_PSTRT = (7 << 0);  ///< WRP1A_PSTRT
        constexpr uint32_t WRP1A_PEND = (7 << 16);  ///< WRP1A_PEND
    }

    /// WRP1BR Register bits
    namespace wrp1br_bits {
        constexpr uint32_t WRP1B_PSTRT = (7 << 0);  ///< WRP1B_PSTRT
        constexpr uint32_t WRP1B_PEND = (7 << 16);  ///< WRP1B_PEND
    }

    /// SECWM2R1 Register bits
    namespace secwm2r1_bits {
        constexpr uint32_t SECWM2_PSTRT = (7 << 0);  ///< SECWM2_PSTRT
        constexpr uint32_t SECWM2_PEND = (7 << 16);  ///< SECWM2_PEND
    }

    /// SECWM2R2 Register bits
    namespace secwm2r2_bits {
        constexpr uint32_t PCROP2_PSTRT = (7 << 0);  ///< PCROP2_PSTRT
        constexpr uint32_t PCROP2EN = (1U << 15);  ///< PCROP2EN
        constexpr uint32_t HDP2_PEND = (7 << 16);  ///< HDP2_PEND
        constexpr uint32_t HDP2EN = (1U << 31);  ///< HDP2EN
    }

    /// WRP2AR Register bits
    namespace wrp2ar_bits {
        constexpr uint32_t WRP2A_PSTRT = (7 << 0);  ///< WRP2A_PSTRT
        constexpr uint32_t WRP2A_PEND = (7 << 16);  ///< WRP2A_PEND
    }

    /// WRP2BR Register bits
    namespace wrp2br_bits {
        constexpr uint32_t WRP2B_PSTRT = (7 << 0);  ///< WRP2B_PSTRT
        constexpr uint32_t WRP2B_PEND = (7 << 16);  ///< WRP2B_PEND
    }

    /// SECBB1R1 Register bits
    namespace secbb1r1_bits {
        constexpr uint32_t SECBB1 = (32 << 0);  ///< SECBB1
    }

    /// SECBB1R2 Register bits
    namespace secbb1r2_bits {
        constexpr uint32_t SECBB1 = (32 << 0);  ///< SECBB1
    }

    /// SECBB1R3 Register bits
    namespace secbb1r3_bits {
        constexpr uint32_t SECBB1 = (32 << 0);  ///< SECBB1
    }

    /// SECBB1R4 Register bits
    namespace secbb1r4_bits {
        constexpr uint32_t SECBB1 = (32 << 0);  ///< SECBB1
    }

    /// SECBB2R1 Register bits
    namespace secbb2r1_bits {
        constexpr uint32_t SECBB2 = (32 << 0);  ///< SECBB2
    }

    /// SECBB2R2 Register bits
    namespace secbb2r2_bits {
        constexpr uint32_t SECBB2 = (32 << 0);  ///< SECBB2
    }

    /// SECBB2R3 Register bits
    namespace secbb2r3_bits {
        constexpr uint32_t SECBB2 = (32 << 0);  ///< SECBB2
    }

    /// SECBB2R4 Register bits
    namespace secbb2r4_bits {
        constexpr uint32_t SECBB2 = (32 << 0);  ///< SECBB2
    }

    /// SECHDPCR Register bits
    namespace sechdpcr_bits {
        constexpr uint32_t HDP1_ACCDIS = (1U << 0);  ///< HDP1_ACCDIS
        constexpr uint32_t HDP2_ACCDIS = (1U << 1);  ///< HDP2_ACCDIS
    }

    /// PRIVCFGR Register bits
    namespace privcfgr_bits {
        constexpr uint32_t PRIV = (1U << 0);  ///< PRIV
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x42020000;
    constexpr uint32_t SEC_GPIOA_BASE = 0x52020000;
    constexpr uint32_t GPIOB_BASE = 0x42020400;
    constexpr uint32_t SEC_GPIOB_BASE = 0x52020400;
    constexpr uint32_t GPIOC_BASE = 0x42020800;
    constexpr uint32_t GPIOD_BASE = 0x42020C00;
    constexpr uint32_t GPIOE_BASE = 0x42021000;
    constexpr uint32_t GPIOF_BASE = 0x42021400;
    constexpr uint32_t GPIOG_BASE = 0x42021800;
    constexpr uint32_t SEC_GPIOC_BASE = 0x52020800;
    constexpr uint32_t SEC_GPIOD_BASE = 0x52020C00;
    constexpr uint32_t SEC_GPIOE_BASE = 0x52021000;
    constexpr uint32_t SEC_GPIOF_BASE = 0x52021400;
    constexpr uint32_t SEC_GPIOG_BASE = 0x52021800;
    constexpr uint32_t GPIOH_BASE = 0x42021C00;
    constexpr uint32_t SEC_GPIOH_BASE = 0x52021C00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t BRR;  ///< Offset: 0x28 - GPIO port bit reset register
        volatile uint32_t SECCFGR;  ///< Offset: 0x30 - GPIO secure configuration register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* SEC_GPIOA = reinterpret_cast<Registers*>(SEC_GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* SEC_GPIOB = reinterpret_cast<Registers*>(SEC_GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* SEC_GPIOC = reinterpret_cast<Registers*>(SEC_GPIOC_BASE);
    inline Registers* SEC_GPIOD = reinterpret_cast<Registers*>(SEC_GPIOD_BASE);
    inline Registers* SEC_GPIOE = reinterpret_cast<Registers*>(SEC_GPIOE_BASE);
    inline Registers* SEC_GPIOF = reinterpret_cast<Registers*>(SEC_GPIOF_BASE);
    inline Registers* SEC_GPIOG = reinterpret_cast<Registers*>(SEC_GPIOG_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* SEC_GPIOH = reinterpret_cast<Registers*>(SEC_GPIOH_BASE);

    // Bit definitions
    /// MODER Register bits
    namespace moder_bits {
        constexpr uint32_t MODER15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t MODER0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OTYPER Register bits
    namespace otyper_bits {
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// OSPEEDR Register bits
    namespace ospeedr_bits {
        constexpr uint32_t OSPEEDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t OSPEEDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// PUPDR Register bits
    namespace pupdr_bits {
        constexpr uint32_t PUPDR15 = (2 << 30);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR14 = (2 << 28);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR13 = (2 << 26);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR12 = (2 << 24);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR11 = (2 << 22);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR10 = (2 << 20);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR9 = (2 << 18);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR8 = (2 << 16);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR7 = (2 << 14);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR6 = (2 << 12);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR5 = (2 << 10);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR4 = (2 << 8);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR3 = (2 << 6);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR2 = (2 << 4);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR1 = (2 << 2);  ///< Port x configuration bits (y = 0..15)
        constexpr uint32_t PUPDR0 = (2 << 0);  ///< Port x configuration bits (y = 0..15)
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR15 = (1U << 15);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR14 = (1U << 14);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR13 = (1U << 13);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR12 = (1U << 12);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR11 = (1U << 11);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR10 = (1U << 10);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR9 = (1U << 9);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR8 = (1U << 8);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR7 = (1U << 7);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR6 = (1U << 6);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR5 = (1U << 5);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR4 = (1U << 4);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR3 = (1U << 3);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR2 = (1U << 2);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR1 = (1U << 1);  ///< Port input data (y = 0..15)
        constexpr uint32_t IDR0 = (1U << 0);  ///< Port input data (y = 0..15)
    }

    /// ODR Register bits
    namespace odr_bits {
        constexpr uint32_t ODR15 = (1U << 15);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR14 = (1U << 14);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR13 = (1U << 13);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR12 = (1U << 12);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR11 = (1U << 11);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR10 = (1U << 10);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR9 = (1U << 9);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR8 = (1U << 8);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR7 = (1U << 7);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR6 = (1U << 6);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR5 = (1U << 5);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR4 = (1U << 4);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR3 = (1U << 3);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR2 = (1U << 2);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR1 = (1U << 1);  ///< Port output data (y = 0..15)
        constexpr uint32_t ODR0 = (1U << 0);  ///< Port output data (y = 0..15)
    }

    /// BSRR Register bits
    namespace bsrr_bits {
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset bit y (y = 0..15)
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set bit y (y= 0..15)
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set bit y (y= 0..15)
    }

    /// LCKR Register bits
    namespace lckr_bits {
        constexpr uint32_t LCKK = (1U << 16);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock bit y (y= 0..15)
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock bit y (y= 0..15)
    }

    /// AFRL Register bits
    namespace afrl_bits {
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 0..7)
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 0..7)
    }

    /// AFRH Register bits
    namespace afrh_bits {
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x bit y (y = 8..15)
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x bit y (y = 8..15)
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x reset IO pin y
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x reset IO pin y
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x reset IO pin y
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x reset IO pin y
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x reset IO pin y
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x reset IO pin y
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x reset IO pin y
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x reset IO pin y
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x reset IO pin y
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x reset IO pin y
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x reset IO pin y
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x reset IO pin y
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x reset IO pin y
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x reset IO pin y
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x reset IO pin y
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x reset IO pin y
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC1 = (1U << 1);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC2 = (1U << 2);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC3 = (1U << 3);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC4 = (1U << 4);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC5 = (1U << 5);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC6 = (1U << 6);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC7 = (1U << 7);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC8 = (1U << 8);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC9 = (1U << 9);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC10 = (1U << 10);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC11 = (1U << 11);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC12 = (1U << 12);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC13 = (1U << 13);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC14 = (1U << 14);  ///< I/O pin of Port x secure bit enable
        constexpr uint32_t SEC15 = (1U << 15);  ///< I/O pin of Port x secure bit enable
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x40003400;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - control register 3
        volatile uint32_t FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t ATCR1;  ///< Offset: 0x10 - TAMP active tamper control register 1
        volatile uint32_t ATSEEDR;  ///< Offset: 0x14 - TAMP active tamper seed register
        volatile uint32_t ATOR;  ///< Offset: 0x18 - TAMP active tamper output register
        volatile uint32_t ATCR2;  ///< Offset: 0x1C - TAMP active tamper control register 2
        volatile uint32_t SMCR;  ///< Offset: 0x20 - TAMP secure mode register
        volatile uint32_t PRIVCR;  ///< Offset: 0x24 - TAMP privilege mode control register
        volatile uint32_t IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x38 - TAMP secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t COUNTR;  ///< Offset: 0x40 - TAMP monotonic counter register
        volatile uint32_t CFGR;  ///< Offset: 0x50 - TAMP configuration register
        volatile uint32_t BKP0R;  ///< Offset: 0x100 - TAMP backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x104 - TAMP backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x108 - TAMP backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x10C - TAMP backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x110 - TAMP backup register
        volatile uint32_t BKP5R;  ///< Offset: 0x114 - TAMP backup register
        volatile uint32_t BKP6R;  ///< Offset: 0x118 - TAMP backup register
        volatile uint32_t BKP7R;  ///< Offset: 0x11C - TAMP backup register
        volatile uint32_t BKP8R;  ///< Offset: 0x120 - TAMP backup register
        volatile uint32_t BKP9R;  ///< Offset: 0x124 - TAMP backup register
        volatile uint32_t BKP10R;  ///< Offset: 0x128 - TAMP backup register
        volatile uint32_t BKP11R;  ///< Offset: 0x12C - TAMP backup register
        volatile uint32_t BKP12R;  ///< Offset: 0x130 - TAMP backup register
        volatile uint32_t BKP13R;  ///< Offset: 0x134 - TAMP backup register
        volatile uint32_t BKP14R;  ///< Offset: 0x138 - TAMP backup register
        volatile uint32_t BKP15R;  ///< Offset: 0x13C - TAMP backup register
        volatile uint32_t BKP16R;  ///< Offset: 0x140 - TAMP backup register
        volatile uint32_t BKP17R;  ///< Offset: 0x144 - TAMP backup register
        volatile uint32_t BKP18R;  ///< Offset: 0x148 - TAMP backup register
        volatile uint32_t BKP19R;  ///< Offset: 0x14C - TAMP backup register
        volatile uint32_t BKP20R;  ///< Offset: 0x150 - TAMP backup register
        volatile uint32_t BKP21R;  ///< Offset: 0x154 - TAMP backup register
        volatile uint32_t BKP22R;  ///< Offset: 0x158 - TAMP backup register
        volatile uint32_t BKP23R;  ///< Offset: 0x15C - TAMP backup register
        volatile uint32_t BKP24R;  ///< Offset: 0x160 - TAMP backup register
        volatile uint32_t BKP25R;  ///< Offset: 0x164 - TAMP backup register
        volatile uint32_t BKP26R;  ///< Offset: 0x168 - TAMP backup register
        volatile uint32_t BKP27R;  ///< Offset: 0x16C - TAMP backup register
        volatile uint32_t BKP28R;  ///< Offset: 0x170 - TAMP backup register
        volatile uint32_t BKP29R;  ///< Offset: 0x174 - TAMP backup register
        volatile uint32_t BKP30R;  ///< Offset: 0x178 - TAMP backup register
        volatile uint32_t BKP31R;  ///< Offset: 0x17C - TAMP backup register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< TAMP1E
        constexpr uint32_t TAMP2E = (1U << 1);  ///< TAMP2E
        constexpr uint32_t TAMP3E = (1U << 2);  ///< TAMP3E
        constexpr uint32_t TAMP4E = (1U << 3);  ///< TAMP4E
        constexpr uint32_t TAMP5E = (1U << 4);  ///< TAMP5E
        constexpr uint32_t TAMP6E = (1U << 5);  ///< TAMP6E
        constexpr uint32_t TAMP7E = (1U << 6);  ///< TAMP7E
        constexpr uint32_t TAMP8E = (1U << 7);  ///< TAMP8E
        constexpr uint32_t ITAMP1E = (1U << 16);  ///< ITAMP1E
        constexpr uint32_t ITAMP2E = (1U << 17);  ///< ITAMP2E
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< ITAMP3E
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< ITAMP5E
        constexpr uint32_t ITAMP8E = (1U << 23);  ///< ITAMP5E
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< TAMP1NOER
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< TAMP2NOER
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< TAMP3NOER
        constexpr uint32_t TAMP4NOER = (1U << 3);  ///< TAMP4NOER
        constexpr uint32_t TAMP5NOER = (1U << 4);  ///< TAMP5NOER
        constexpr uint32_t TAMP6NOER = (1U << 5);  ///< TAMP6NOER
        constexpr uint32_t TAMP7NOER = (1U << 6);  ///< TAMP7NOER
        constexpr uint32_t TAMP8NOER = (1U << 7);  ///< TAMP8NOER
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< TAMP1MSK
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< TAMP2MSK
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< TAMP3MSK
        constexpr uint32_t BKERASE = (1U << 23);  ///< BKERASE
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< TAMP1TRG
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< TAMP2TRG
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< TAMP3TRG
        constexpr uint32_t TAMP4TRG = (1U << 27);  ///< TAMP4TRG
        constexpr uint32_t TAMP5TRG = (1U << 28);  ///< TAMP5TRG
        constexpr uint32_t TAMP6TRG = (1U << 29);  ///< TAMP6TRG
        constexpr uint32_t TAMP7TRG = (1U << 30);  ///< TAMP7TRG
        constexpr uint32_t TAMP8TRG = (1U << 31);  ///< TAMP8TRG
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t ITAMP1NOER = (1U << 0);  ///< ITAMP1NOER
        constexpr uint32_t ITAMP2NOER = (1U << 1);  ///< ITAMP2NOER
        constexpr uint32_t ITAMP3NOER = (1U << 2);  ///< ITAMP3NOER
        constexpr uint32_t ITAMP5NOER = (1U << 4);  ///< ITAMP5NOER
        constexpr uint32_t ITAMP8NOER = (1U << 7);  ///< ITAMP8NOER
    }

    /// FLTCR Register bits
    namespace fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< TAMPFREQ
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMPFLT
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMPPRCH
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMPPUDIS
    }

    /// ATCR1 Register bits
    namespace atcr1_bits {
        constexpr uint32_t TAMP1AM = (1U << 0);  ///< TAMP1AM
        constexpr uint32_t TAMP2AM = (1U << 1);  ///< TAMP2AM
        constexpr uint32_t TAMP3AM = (1U << 2);  ///< TAMP3AM
        constexpr uint32_t TAMP4AM = (1U << 3);  ///< TAMP4AM
        constexpr uint32_t TAMP5AM = (1U << 4);  ///< TAMP5AM
        constexpr uint32_t TAMP6AM = (1U << 5);  ///< TAMP6AM
        constexpr uint32_t TAMP7AM = (1U << 6);  ///< TAMP7AM
        constexpr uint32_t TAMP8AM = (1U << 7);  ///< TAMP8AM
        constexpr uint32_t ATOSEL1 = (2 << 8);  ///< ATOSEL1
        constexpr uint32_t ATOSEL2 = (2 << 10);  ///< ATOSEL2
        constexpr uint32_t ATOSEL3 = (2 << 12);  ///< ATOSEL3
        constexpr uint32_t ATOSEL4 = (2 << 14);  ///< ATOSEL4
        constexpr uint32_t ATCKSEL = (2 << 16);  ///< ATCKSEL
        constexpr uint32_t ATPER = (2 << 24);  ///< ATPER
        constexpr uint32_t ATOSHARE = (1U << 30);  ///< ATOSHARE
        constexpr uint32_t FLTEN = (1U << 31);  ///< FLTEN
    }

    /// ATSEEDR Register bits
    namespace atseedr_bits {
        constexpr uint32_t SEED = (32 << 0);  ///< Pseudo-random generator seed value
    }

    /// ATOR Register bits
    namespace ator_bits {
        constexpr uint32_t PRNG = (8 << 0);  ///< Pseudo-random generator value
        constexpr uint32_t SEEDF = (1U << 14);  ///< Seed running flag
        constexpr uint32_t INITS = (1U << 15);  ///< Active tamper initialization status
    }

    /// ATCR2 Register bits
    namespace atcr2_bits {
        constexpr uint32_t ATOSEL1 = (3 << 8);  ///< ATOSEL1
        constexpr uint32_t ATOSEL2 = (3 << 11);  ///< ATOSEL2
        constexpr uint32_t ATOSEL3 = (3 << 14);  ///< ATOSEL3
        constexpr uint32_t ATOSEL4 = (3 << 17);  ///< ATOSEL4
        constexpr uint32_t ATOSEL5 = (3 << 20);  ///< ATOSEL5
        constexpr uint32_t ATOSEL6 = (3 << 23);  ///< ATOSEL6
        constexpr uint32_t ATOSEL7 = (3 << 26);  ///< ATOSEL7
        constexpr uint32_t ATOSEL8 = (3 << 29);  ///< ATOSEL8
    }

    /// SMCR Register bits
    namespace smcr_bits {
        constexpr uint32_t BKPRWDPROT = (8 << 0);  ///< Backup registers read/write protection offset
        constexpr uint32_t BKPWDPROT = (8 << 16);  ///< Backup registers write protection offset
        constexpr uint32_t TAMPDPROT = (1U << 31);  ///< Tamper protection
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t BKPRWPRIV = (1U << 29);  ///< Backup registers zone 1 privilege protection
        constexpr uint32_t BKPWPRIV = (1U << 30);  ///< Backup registers zone 2 privilege protection
        constexpr uint32_t TAMPPRIV = (1U << 31);  ///< Tamper privilege protection
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< TAMP1IE
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< TAMP2IE
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< TAMP3IE
        constexpr uint32_t TAMP4IE = (1U << 3);  ///< TAMP4IE
        constexpr uint32_t TAMP5IE = (1U << 4);  ///< TAMP5IE
        constexpr uint32_t TAMP6IE = (1U << 5);  ///< TAMP6IE
        constexpr uint32_t TAMP7IE = (1U << 6);  ///< TAMP7IE
        constexpr uint32_t TAMP8IE = (1U << 7);  ///< TAMP8IE
        constexpr uint32_t ITAMP1IE = (1U << 16);  ///< ITAMP1IE
        constexpr uint32_t ITAMP2IE = (1U << 17);  ///< ITAMP2IE
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< ITAMP3IE
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< ITAMP5IE
        constexpr uint32_t ITAMP8IE = (1U << 23);  ///< ITAMP8IE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1F
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2F
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3F
        constexpr uint32_t TAMP4F = (1U << 3);  ///< TAMP4F
        constexpr uint32_t TAMP5F = (1U << 4);  ///< TAMP5F
        constexpr uint32_t TAMP6F = (1U << 5);  ///< TAMP6F
        constexpr uint32_t TAMP7F = (1U << 6);  ///< TAMP7F
        constexpr uint32_t TAMP8F = (1U << 7);  ///< TAMP8F
        constexpr uint32_t ITAMP1F = (1U << 16);  ///< ITAMP1F
        constexpr uint32_t ITAMP2F = (1U << 17);  ///< ITAMP2F
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< ITAMP3F
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< ITAMP5F
        constexpr uint32_t ITAMP8F = (1U << 23);  ///< ITAMP8F
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF:
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4MF
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5MF
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6MF
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7MF:
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< ITAMP2MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< ITAMP8MF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF:
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4MF
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5MF
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6MF
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7MF:
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< ITAMP2MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< ITAMP8MF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< CTAMP1F
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< CTAMP2F
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< CTAMP3F
        constexpr uint32_t CTAMP4F = (1U << 3);  ///< CTAMP4F
        constexpr uint32_t CTAMP5F = (1U << 4);  ///< CTAMP5F
        constexpr uint32_t CTAMP6F = (1U << 5);  ///< CTAMP6F
        constexpr uint32_t CTAMP7F = (1U << 6);  ///< CTAMP7F
        constexpr uint32_t CTAMP8F = (1U << 7);  ///< CTAMP8F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP2F = (1U << 17);  ///< CITAMP2F
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< CITAMP3F
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< CITAMP5F
        constexpr uint32_t CITAMP8F = (1U << 23);  ///< CITAMP8F
    }

    /// COUNTR Register bits
    namespace countr_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< COUNT
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t TMONEN = (1U << 1);  ///< TMONEN
        constexpr uint32_t VMONEN = (1U << 2);  ///< VMONEN
        constexpr uint32_t WUTMONEN = (1U << 3);  ///< WUTMONEN
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP5R Register bits
    namespace bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP6R Register bits
    namespace bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP7R Register bits
    namespace bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP8R Register bits
    namespace bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP9R Register bits
    namespace bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP10R Register bits
    namespace bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP11R Register bits
    namespace bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP12R Register bits
    namespace bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP13R Register bits
    namespace bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP14R Register bits
    namespace bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP15R Register bits
    namespace bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP16R Register bits
    namespace bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP17R Register bits
    namespace bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP18R Register bits
    namespace bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP19R Register bits
    namespace bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP20R Register bits
    namespace bkp20r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP21R Register bits
    namespace bkp21r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP22R Register bits
    namespace bkp22r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP23R Register bits
    namespace bkp23r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP24R Register bits
    namespace bkp24r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP25R Register bits
    namespace bkp25r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP26R Register bits
    namespace bkp26r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP27R Register bits
    namespace bkp27r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP28R Register bits
    namespace bkp28r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP29R Register bits
    namespace bkp29r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP30R Register bits
    namespace bkp30r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP31R Register bits
    namespace bkp31r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C3_BASE = 0x40005C00;
    constexpr uint32_t I2C4_BASE = 0x40008400;
    constexpr uint32_t SEC_I2C1_BASE = 0x50005400;
    constexpr uint32_t SEC_I2C2_BASE = 0x50005800;
    constexpr uint32_t SEC_I2C3_BASE = 0x50005C00;
    constexpr uint32_t SEC_I2C4_BASE = 0x50008400;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);
    inline Registers* SEC_I2C1 = reinterpret_cast<Registers*>(SEC_I2C1_BASE);
    inline Registers* SEC_I2C2 = reinterpret_cast<Registers*>(SEC_I2C2_BASE);
    inline Registers* SEC_I2C3 = reinterpret_cast<Registers*>(SEC_I2C3_BASE);
    inline Registers* SEC_I2C4 = reinterpret_cast<Registers*>(SEC_I2C4_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

}

// ============================================================================
// ICache Peripheral
// ============================================================================

namespace icache {
    /// Base addresses
    constexpr uint32_t ICache_BASE = 0x40030400;

    /// ICache Register structure
    struct Registers {
        volatile uint32_t ICACHE_CR;  ///< Offset: 0x00 - ICACHE control register
        volatile uint32_t ICACHE_SR;  ///< Offset: 0x04 - ICACHE status register
        volatile uint32_t ICACHE_IER;  ///< Offset: 0x08 - ICACHE interrupt enable register
        volatile uint32_t ICACHE_FCR;  ///< Offset: 0x0C - ICACHE flag clear register
        volatile uint32_t ICACHE_HMONR;  ///< Offset: 0x10 - ICACHE hit monitor register
        volatile uint32_t ICACHE_MMONR;  ///< Offset: 0x14 - ICACHE miss monitor register
        volatile uint32_t ICACHE_CRR0;  ///< Offset: 0x20 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR1;  ///< Offset: 0x24 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR2;  ///< Offset: 0x28 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR3;  ///< Offset: 0x2C - ICACHE region configuration register
    };

    /// Peripheral instances
    inline Registers* ICache = reinterpret_cast<Registers*>(ICache_BASE);

    // Bit definitions
    /// ICACHE_CR Register bits
    namespace icache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t WAYSEL = (1U << 2);  ///< WAYSEL
        constexpr uint32_t HITMEN = (1U << 16);  ///< HITMEN
        constexpr uint32_t MISSMEN = (1U << 17);  ///< MISSMEN
        constexpr uint32_t HITMRST = (1U << 18);  ///< HITMRST
        constexpr uint32_t MISSMRST = (1U << 19);  ///< MISSMRST
    }

    /// ICACHE_SR Register bits
    namespace icache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
    }

    /// ICACHE_IER Register bits
    namespace icache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
    }

    /// ICACHE_FCR Register bits
    namespace icache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
    }

    /// ICACHE_HMONR Register bits
    namespace icache_hmonr_bits {
        constexpr uint32_t HITMON = (32 << 0);  ///< HITMON
    }

    /// ICACHE_MMONR Register bits
    namespace icache_mmonr_bits {
        constexpr uint32_t MISSMON = (16 << 0);  ///< MISSMON
    }

    /// ICACHE_CRR0 Register bits
    namespace icache_crr0_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR1 Register bits
    namespace icache_crr1_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR2 Register bits
    namespace icache_crr2_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR3 Register bits
    namespace icache_crr3_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t SEC_IWDG_BASE = 0x50003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;
    constexpr uint32_t SEC_WWDG_BASE = 0x50002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* SEC_IWDG = reinterpret_cast<Registers*>(SEC_IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);
    inline Registers* SEC_WWDG = reinterpret_cast<Registers*>(SEC_WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (3 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM1_BASE = 0x40007C00;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t LPTIM3_BASE = 0x40009800;
    constexpr uint32_t SEC_LPTIM1_BASE = 0x50007C00;
    constexpr uint32_t SEC_LPTIM2_BASE = 0x50009400;
    constexpr uint32_t SEC_LPTIM3_BASE = 0x50009800;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t SEC_TIM1_BASE = 0x50012C00;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t SEC_TIM15_BASE = 0x50014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t SEC_TIM16_BASE = 0x50014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t SEC_TIM17_BASE = 0x50014800;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t SEC_TIM2_BASE = 0x50000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t SEC_TIM3_BASE = 0x50000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t SEC_TIM4_BASE = 0x50000800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t SEC_TIM5_BASE = 0x50000C00;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t SEC_TIM6_BASE = 0x50001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t SEC_TIM7_BASE = 0x50001400;
    constexpr uint32_t TIM8_BASE = 0x40013400;
    constexpr uint32_t SEC_TIM8_BASE = 0x50013400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t ISR;  ///< Offset: 0x00 - Interrupt and Status Register
        volatile uint32_t ICR;  ///< Offset: 0x04 - Interrupt Clear Register
        volatile uint32_t IER;  ///< Offset: 0x08 - Interrupt Enable Register
        volatile uint32_t CFGR;  ///< Offset: 0x0C - Configuration Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t CMP;  ///< Offset: 0x14 - Compare Register
        volatile uint32_t ARR;  ///< Offset: 0x18 - Autoreload Register
        volatile uint32_t CNT;  ///< Offset: 0x1C - Counter Register
        volatile uint32_t OR;  ///< Offset: 0x20 - LPTIM option register
        volatile uint32_t RCR;  ///< Offset: 0x28 - LPTIM repetition register
    };

    /// Peripheral instances
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* LPTIM3 = reinterpret_cast<Registers*>(LPTIM3_BASE);
    inline Registers* SEC_LPTIM1 = reinterpret_cast<Registers*>(SEC_LPTIM1_BASE);
    inline Registers* SEC_LPTIM2 = reinterpret_cast<Registers*>(SEC_LPTIM2_BASE);
    inline Registers* SEC_LPTIM3 = reinterpret_cast<Registers*>(SEC_LPTIM3_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* SEC_TIM1 = reinterpret_cast<Registers*>(SEC_TIM1_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* SEC_TIM15 = reinterpret_cast<Registers*>(SEC_TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* SEC_TIM16 = reinterpret_cast<Registers*>(SEC_TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* SEC_TIM17 = reinterpret_cast<Registers*>(SEC_TIM17_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* SEC_TIM2 = reinterpret_cast<Registers*>(SEC_TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* SEC_TIM3 = reinterpret_cast<Registers*>(SEC_TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* SEC_TIM4 = reinterpret_cast<Registers*>(SEC_TIM4_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* SEC_TIM5 = reinterpret_cast<Registers*>(SEC_TIM5_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* SEC_TIM6 = reinterpret_cast<Registers*>(SEC_TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* SEC_TIM7 = reinterpret_cast<Registers*>(SEC_TIM7_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* SEC_TIM8 = reinterpret_cast<Registers*>(SEC_TIM8_BASE);

    // Bit definitions
    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t CMPOK = (1U << 3);  ///< Compare register update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CMPM = (1U << 0);  ///< Compare match
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update Ok
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t CMPOKCF = (1U << 3);  ///< Compare register update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CMPMCF = (1U << 0);  ///< compare match Clear Flag
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t CMPOKIE = (1U << 3);  ///< Compare register update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CMPMIE = (1U << 0);  ///< Compare match Interrupt Enable
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< REPOKIE
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode
        constexpr uint32_t WAVPOL = (1U << 21);  ///< Waveform shape polarity
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in continuous mode
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in single mode
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM Enable
        constexpr uint32_t COUNTRST = (1U << 4);  ///< Counter reset
        constexpr uint32_t RSTARE = (1U << 3);  ///< Reset after read enable
    }

    /// CMP Register bits
    namespace cmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Compare value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value
    }

    /// OR Register bits
    namespace or_bits {
        constexpr uint32_t OR_0 = (1U << 0);  ///< Option register bit 0
        constexpr uint32_t OR_1 = (1U << 1);  ///< Option register bit 1
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition register value
    }

}

// ============================================================================
// GTZC Peripheral
// ============================================================================

namespace gtzc {
    /// Base addresses
    constexpr uint32_t GTZC_MPCBB1_BASE = 0x40032C00;
    constexpr uint32_t GTZC_MPCBB2_BASE = 0x40033000;
    constexpr uint32_t GTZC_TZIC_BASE = 0x40032800;
    constexpr uint32_t GTZC_TZSC_BASE = 0x40032400;

    /// GTZC Register structure
    struct Registers {
        volatile uint32_t MPCBB1_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB1_LCKVTR1;  ///< Offset: 0x10 - MPCBB control register
        volatile uint32_t MPCBB1_LCKVTR2;  ///< Offset: 0x14 - MPCBB control register
        volatile uint32_t MPCBB1_VCTR0;  ///< Offset: 0x100 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR1;  ///< Offset: 0x104 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR2;  ///< Offset: 0x108 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR3;  ///< Offset: 0x10C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR4;  ///< Offset: 0x110 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR5;  ///< Offset: 0x114 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR6;  ///< Offset: 0x118 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR7;  ///< Offset: 0x11C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR8;  ///< Offset: 0x120 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR9;  ///< Offset: 0x124 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR10;  ///< Offset: 0x128 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR11;  ///< Offset: 0x12C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR12;  ///< Offset: 0x130 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR13;  ///< Offset: 0x134 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR14;  ///< Offset: 0x138 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR15;  ///< Offset: 0x13C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR16;  ///< Offset: 0x140 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR17;  ///< Offset: 0x144 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR18;  ///< Offset: 0x148 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR19;  ///< Offset: 0x14C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR20;  ///< Offset: 0x150 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR21;  ///< Offset: 0x154 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR22;  ///< Offset: 0x158 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR23;  ///< Offset: 0x15C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR24;  ///< Offset: 0x160 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR25;  ///< Offset: 0x164 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR26;  ///< Offset: 0x168 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR27;  ///< Offset: 0x16C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR28;  ///< Offset: 0x170 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR29;  ///< Offset: 0x174 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR30;  ///< Offset: 0x178 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR31;  ///< Offset: 0x17C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR32;  ///< Offset: 0x180 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR33;  ///< Offset: 0x184 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR34;  ///< Offset: 0x188 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR35;  ///< Offset: 0x18C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR36;  ///< Offset: 0x190 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR37;  ///< Offset: 0x194 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR38;  ///< Offset: 0x198 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR39;  ///< Offset: 0x19C - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR40;  ///< Offset: 0x1A0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR41;  ///< Offset: 0x1A4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR42;  ///< Offset: 0x1A8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR43;  ///< Offset: 0x1AC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR44;  ///< Offset: 0x1B0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR45;  ///< Offset: 0x1B4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR46;  ///< Offset: 0x1B8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR47;  ///< Offset: 0x1BC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR48;  ///< Offset: 0x1C0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR49;  ///< Offset: 0x1C4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR50;  ///< Offset: 0x1C8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR51;  ///< Offset: 0x1CC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR52;  ///< Offset: 0x1D0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR53;  ///< Offset: 0x1D4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR54;  ///< Offset: 0x1D8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR55;  ///< Offset: 0x1DC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR56;  ///< Offset: 0x1E0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR57;  ///< Offset: 0x1E4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR58;  ///< Offset: 0x1E8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR59;  ///< Offset: 0x1EC - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR60;  ///< Offset: 0x1F0 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR61;  ///< Offset: 0x1F4 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR62;  ///< Offset: 0x1F8 - MPCBBx vector register
        volatile uint32_t MPCBB1_VCTR63;  ///< Offset: 0x1FC - MPCBBx vector register
    };

    /// Peripheral instances
    inline Registers* GTZC_MPCBB1 = reinterpret_cast<Registers*>(GTZC_MPCBB1_BASE);
    inline Registers* GTZC_MPCBB2 = reinterpret_cast<Registers*>(GTZC_MPCBB2_BASE);
    inline Registers* GTZC_TZIC = reinterpret_cast<Registers*>(GTZC_TZIC_BASE);
    inline Registers* GTZC_TZSC = reinterpret_cast<Registers*>(GTZC_TZSC_BASE);

    // Bit definitions
    /// MPCBB1_CR Register bits
    namespace mpcbb1_cr_bits {
        constexpr uint32_t LCK = (1U << 0);  ///< LCK
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< INVSECSTATE
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< SRWILADIS
    }

    /// MPCBB1_LCKVTR1 Register bits
    namespace mpcbb1_lckvtr1_bits {
        constexpr uint32_t LCKSB0 = (1U << 0);  ///< LCKSB0
        constexpr uint32_t LCKSB1 = (1U << 1);  ///< LCKSB1
        constexpr uint32_t LCKSB2 = (1U << 2);  ///< LCKSB2
        constexpr uint32_t LCKSB3 = (1U << 3);  ///< LCKSB3
        constexpr uint32_t LCKSB4 = (1U << 4);  ///< LCKSB4
        constexpr uint32_t LCKSB5 = (1U << 5);  ///< LCKSB5
        constexpr uint32_t LCKSB6 = (1U << 6);  ///< LCKSB6
        constexpr uint32_t LCKSB7 = (1U << 7);  ///< LCKSB7
        constexpr uint32_t LCKSB8 = (1U << 8);  ///< LCKSB8
        constexpr uint32_t LCKSB9 = (1U << 9);  ///< LCKSB9
        constexpr uint32_t LCKSB10 = (1U << 10);  ///< LCKSB10
        constexpr uint32_t LCKSB11 = (1U << 11);  ///< LCKSB11
        constexpr uint32_t LCKSB12 = (1U << 12);  ///< LCKSB12
        constexpr uint32_t LCKSB13 = (1U << 13);  ///< LCKSB13
        constexpr uint32_t LCKSB14 = (1U << 14);  ///< LCKSB14
        constexpr uint32_t LCKSB15 = (1U << 15);  ///< LCKSB15
        constexpr uint32_t LCKSB16 = (1U << 16);  ///< LCKSB16
        constexpr uint32_t LCKSB17 = (1U << 17);  ///< LCKSB17
        constexpr uint32_t LCKSB18 = (1U << 18);  ///< LCKSB18
        constexpr uint32_t LCKSB19 = (1U << 19);  ///< LCKSB19
        constexpr uint32_t LCKSB20 = (1U << 20);  ///< LCKSB20
        constexpr uint32_t LCKSB21 = (1U << 21);  ///< LCKSB21
        constexpr uint32_t LCKSB22 = (1U << 22);  ///< LCKSB22
        constexpr uint32_t LCKSB23 = (1U << 23);  ///< LCKSB23
        constexpr uint32_t LCKSB24 = (1U << 24);  ///< LCKSB24
        constexpr uint32_t LCKSB25 = (1U << 25);  ///< LCKSB25
        constexpr uint32_t LCKSB26 = (1U << 26);  ///< LCKSB26
        constexpr uint32_t LCKSB27 = (1U << 27);  ///< LCKSB27
        constexpr uint32_t LCKSB28 = (1U << 28);  ///< LCKSB28
        constexpr uint32_t LCKSB29 = (1U << 29);  ///< LCKSB29
        constexpr uint32_t LCKSB30 = (1U << 30);  ///< LCKSB30
        constexpr uint32_t LCKSB31 = (1U << 31);  ///< LCKSB31
    }

    /// MPCBB1_LCKVTR2 Register bits
    namespace mpcbb1_lckvtr2_bits {
        constexpr uint32_t LCKSB32 = (1U << 0);  ///< LCKSB32
        constexpr uint32_t LCKSB33 = (1U << 1);  ///< LCKSB33
        constexpr uint32_t LCKSB34 = (1U << 2);  ///< LCKSB34
        constexpr uint32_t LCKSB35 = (1U << 3);  ///< LCKSB35
        constexpr uint32_t LCKSB36 = (1U << 4);  ///< LCKSB36
        constexpr uint32_t LCKSB37 = (1U << 5);  ///< LCKSB37
        constexpr uint32_t LCKSB38 = (1U << 6);  ///< LCKSB38
        constexpr uint32_t LCKSB39 = (1U << 7);  ///< LCKSB39
        constexpr uint32_t LCKSB40 = (1U << 8);  ///< LCKSB40
        constexpr uint32_t LCKSB41 = (1U << 9);  ///< LCKSB41
        constexpr uint32_t LCKSB42 = (1U << 10);  ///< LCKSB42
        constexpr uint32_t LCKSB43 = (1U << 11);  ///< LCKSB43
        constexpr uint32_t LCKSB44 = (1U << 12);  ///< LCKSB44
        constexpr uint32_t LCKSB45 = (1U << 13);  ///< LCKSB45
        constexpr uint32_t LCKSB46 = (1U << 14);  ///< LCKSB46
        constexpr uint32_t LCKSB47 = (1U << 15);  ///< LCKSB47
        constexpr uint32_t LCKSB48 = (1U << 16);  ///< LCKSB48
        constexpr uint32_t LCKSB49 = (1U << 17);  ///< LCKSB49
        constexpr uint32_t LCKSB50 = (1U << 18);  ///< LCKSB50
        constexpr uint32_t LCKSB51 = (1U << 19);  ///< LCKSB51
        constexpr uint32_t LCKSB52 = (1U << 20);  ///< LCKSB52
        constexpr uint32_t LCKSB53 = (1U << 21);  ///< LCKSB53
        constexpr uint32_t LCKSB54 = (1U << 22);  ///< LCKSB54
        constexpr uint32_t LCKSB55 = (1U << 23);  ///< LCKSB55
        constexpr uint32_t LCKSB56 = (1U << 24);  ///< LCKSB56
        constexpr uint32_t LCKSB57 = (1U << 25);  ///< LCKSB57
        constexpr uint32_t LCKSB58 = (1U << 26);  ///< LCKSB58
        constexpr uint32_t LCKSB59 = (1U << 27);  ///< LCKSB59
        constexpr uint32_t LCKSB60 = (1U << 28);  ///< LCKSB60
        constexpr uint32_t LCKSB61 = (1U << 29);  ///< LCKSB61
        constexpr uint32_t LCKSB62 = (1U << 30);  ///< LCKSB62
        constexpr uint32_t LCKSB63 = (1U << 31);  ///< LCKSB63
    }

    /// MPCBB1_VCTR0 Register bits
    namespace mpcbb1_vctr0_bits {
        constexpr uint32_t B0 = (1U << 0);  ///< B0
        constexpr uint32_t B1 = (1U << 1);  ///< B1
        constexpr uint32_t B2 = (1U << 2);  ///< B2
        constexpr uint32_t B3 = (1U << 3);  ///< B3
        constexpr uint32_t B4 = (1U << 4);  ///< B4
        constexpr uint32_t B5 = (1U << 5);  ///< B5
        constexpr uint32_t B6 = (1U << 6);  ///< B6
        constexpr uint32_t B7 = (1U << 7);  ///< B7
        constexpr uint32_t B8 = (1U << 8);  ///< B8
        constexpr uint32_t B9 = (1U << 9);  ///< B9
        constexpr uint32_t B10 = (1U << 10);  ///< B10
        constexpr uint32_t B11 = (1U << 11);  ///< B11
        constexpr uint32_t B12 = (1U << 12);  ///< B12
        constexpr uint32_t B13 = (1U << 13);  ///< B13
        constexpr uint32_t B14 = (1U << 14);  ///< B14
        constexpr uint32_t B15 = (1U << 15);  ///< B15
        constexpr uint32_t B16 = (1U << 16);  ///< B16
        constexpr uint32_t B17 = (1U << 17);  ///< B17
        constexpr uint32_t B18 = (1U << 18);  ///< B18
        constexpr uint32_t B19 = (1U << 19);  ///< B19
        constexpr uint32_t B20 = (1U << 20);  ///< B20
        constexpr uint32_t B21 = (1U << 21);  ///< B21
        constexpr uint32_t B22 = (1U << 22);  ///< B22
        constexpr uint32_t B23 = (1U << 23);  ///< B23
        constexpr uint32_t B24 = (1U << 24);  ///< B24
        constexpr uint32_t B25 = (1U << 25);  ///< B25
        constexpr uint32_t B26 = (1U << 26);  ///< B26
        constexpr uint32_t B27 = (1U << 27);  ///< B27
        constexpr uint32_t B28 = (1U << 28);  ///< B28
        constexpr uint32_t B29 = (1U << 29);  ///< B29
        constexpr uint32_t B30 = (1U << 30);  ///< B30
        constexpr uint32_t B31 = (1U << 31);  ///< B31
    }

    /// MPCBB1_VCTR1 Register bits
    namespace mpcbb1_vctr1_bits {
        constexpr uint32_t B32 = (1U << 0);  ///< B32
        constexpr uint32_t B33 = (1U << 1);  ///< B33
        constexpr uint32_t B34 = (1U << 2);  ///< B34
        constexpr uint32_t B35 = (1U << 3);  ///< B35
        constexpr uint32_t B36 = (1U << 4);  ///< B36
        constexpr uint32_t B37 = (1U << 5);  ///< B37
        constexpr uint32_t B38 = (1U << 6);  ///< B38
        constexpr uint32_t B39 = (1U << 7);  ///< B39
        constexpr uint32_t B40 = (1U << 8);  ///< B40
        constexpr uint32_t B41 = (1U << 9);  ///< B41
        constexpr uint32_t B42 = (1U << 10);  ///< B42
        constexpr uint32_t B43 = (1U << 11);  ///< B43
        constexpr uint32_t B44 = (1U << 12);  ///< B44
        constexpr uint32_t B45 = (1U << 13);  ///< B45
        constexpr uint32_t B46 = (1U << 14);  ///< B46
        constexpr uint32_t B47 = (1U << 15);  ///< B47
        constexpr uint32_t B48 = (1U << 16);  ///< B48
        constexpr uint32_t B49 = (1U << 17);  ///< B49
        constexpr uint32_t B50 = (1U << 18);  ///< B50
        constexpr uint32_t B51 = (1U << 19);  ///< B51
        constexpr uint32_t B52 = (1U << 20);  ///< B52
        constexpr uint32_t B53 = (1U << 21);  ///< B53
        constexpr uint32_t B54 = (1U << 22);  ///< B54
        constexpr uint32_t B55 = (1U << 23);  ///< B55
        constexpr uint32_t B56 = (1U << 24);  ///< B56
        constexpr uint32_t B57 = (1U << 25);  ///< B57
        constexpr uint32_t B58 = (1U << 26);  ///< B58
        constexpr uint32_t B59 = (1U << 27);  ///< B59
        constexpr uint32_t B60 = (1U << 28);  ///< B60
        constexpr uint32_t B61 = (1U << 29);  ///< B61
        constexpr uint32_t B62 = (1U << 30);  ///< B62
        constexpr uint32_t B63 = (1U << 31);  ///< B63
    }

    /// MPCBB1_VCTR2 Register bits
    namespace mpcbb1_vctr2_bits {
        constexpr uint32_t B64 = (1U << 0);  ///< B64
        constexpr uint32_t B65 = (1U << 1);  ///< B65
        constexpr uint32_t B66 = (1U << 2);  ///< B66
        constexpr uint32_t B67 = (1U << 3);  ///< B67
        constexpr uint32_t B68 = (1U << 4);  ///< B68
        constexpr uint32_t B69 = (1U << 5);  ///< B69
        constexpr uint32_t B70 = (1U << 6);  ///< B70
        constexpr uint32_t B71 = (1U << 7);  ///< B71
        constexpr uint32_t B72 = (1U << 8);  ///< B72
        constexpr uint32_t B73 = (1U << 9);  ///< B73
        constexpr uint32_t B74 = (1U << 10);  ///< B74
        constexpr uint32_t B75 = (1U << 11);  ///< B75
        constexpr uint32_t B76 = (1U << 12);  ///< B76
        constexpr uint32_t B77 = (1U << 13);  ///< B77
        constexpr uint32_t B78 = (1U << 14);  ///< B78
        constexpr uint32_t B79 = (1U << 15);  ///< B79
        constexpr uint32_t B80 = (1U << 16);  ///< B80
        constexpr uint32_t B81 = (1U << 17);  ///< B81
        constexpr uint32_t B82 = (1U << 18);  ///< B82
        constexpr uint32_t B83 = (1U << 19);  ///< B83
        constexpr uint32_t B84 = (1U << 20);  ///< B84
        constexpr uint32_t B85 = (1U << 21);  ///< B85
        constexpr uint32_t B86 = (1U << 22);  ///< B86
        constexpr uint32_t B87 = (1U << 23);  ///< B87
        constexpr uint32_t B88 = (1U << 24);  ///< B88
        constexpr uint32_t B89 = (1U << 25);  ///< B89
        constexpr uint32_t B90 = (1U << 26);  ///< B90
        constexpr uint32_t B91 = (1U << 27);  ///< B91
        constexpr uint32_t B92 = (1U << 28);  ///< B92
        constexpr uint32_t B93 = (1U << 29);  ///< B93
        constexpr uint32_t B94 = (1U << 30);  ///< B94
        constexpr uint32_t B95 = (1U << 31);  ///< B95
    }

    /// MPCBB1_VCTR3 Register bits
    namespace mpcbb1_vctr3_bits {
        constexpr uint32_t B96 = (1U << 0);  ///< B96
        constexpr uint32_t B97 = (1U << 1);  ///< B97
        constexpr uint32_t B98 = (1U << 2);  ///< B98
        constexpr uint32_t B99 = (1U << 3);  ///< B99
        constexpr uint32_t B100 = (1U << 4);  ///< B100
        constexpr uint32_t B101 = (1U << 5);  ///< B101
        constexpr uint32_t B102 = (1U << 6);  ///< B102
        constexpr uint32_t B103 = (1U << 7);  ///< B103
        constexpr uint32_t B104 = (1U << 8);  ///< B104
        constexpr uint32_t B105 = (1U << 9);  ///< B105
        constexpr uint32_t B106 = (1U << 10);  ///< B106
        constexpr uint32_t B107 = (1U << 11);  ///< B107
        constexpr uint32_t B108 = (1U << 12);  ///< B108
        constexpr uint32_t B109 = (1U << 13);  ///< B109
        constexpr uint32_t B110 = (1U << 14);  ///< B110
        constexpr uint32_t B111 = (1U << 15);  ///< B111
        constexpr uint32_t B112 = (1U << 16);  ///< B112
        constexpr uint32_t B113 = (1U << 17);  ///< B113
        constexpr uint32_t B114 = (1U << 18);  ///< B114
        constexpr uint32_t B115 = (1U << 19);  ///< B115
        constexpr uint32_t B116 = (1U << 20);  ///< B116
        constexpr uint32_t B117 = (1U << 21);  ///< B117
        constexpr uint32_t B118 = (1U << 22);  ///< B118
        constexpr uint32_t B119 = (1U << 23);  ///< B119
        constexpr uint32_t B120 = (1U << 24);  ///< B120
        constexpr uint32_t B121 = (1U << 25);  ///< B121
        constexpr uint32_t B122 = (1U << 26);  ///< B122
        constexpr uint32_t B123 = (1U << 27);  ///< B123
        constexpr uint32_t B124 = (1U << 28);  ///< B124
        constexpr uint32_t B125 = (1U << 29);  ///< B125
        constexpr uint32_t B126 = (1U << 30);  ///< B126
        constexpr uint32_t B127 = (1U << 31);  ///< B127
    }

    /// MPCBB1_VCTR4 Register bits
    namespace mpcbb1_vctr4_bits {
        constexpr uint32_t B128 = (1U << 0);  ///< B128
        constexpr uint32_t B129 = (1U << 1);  ///< B129
        constexpr uint32_t B130 = (1U << 2);  ///< B130
        constexpr uint32_t B131 = (1U << 3);  ///< B131
        constexpr uint32_t B132 = (1U << 4);  ///< B132
        constexpr uint32_t B133 = (1U << 5);  ///< B133
        constexpr uint32_t B134 = (1U << 6);  ///< B134
        constexpr uint32_t B135 = (1U << 7);  ///< B135
        constexpr uint32_t B136 = (1U << 8);  ///< B136
        constexpr uint32_t B137 = (1U << 9);  ///< B137
        constexpr uint32_t B138 = (1U << 10);  ///< B138
        constexpr uint32_t B139 = (1U << 11);  ///< B139
        constexpr uint32_t B140 = (1U << 12);  ///< B140
        constexpr uint32_t B141 = (1U << 13);  ///< B141
        constexpr uint32_t B142 = (1U << 14);  ///< B142
        constexpr uint32_t B143 = (1U << 15);  ///< B143
        constexpr uint32_t B144 = (1U << 16);  ///< B144
        constexpr uint32_t B145 = (1U << 17);  ///< B145
        constexpr uint32_t B146 = (1U << 18);  ///< B146
        constexpr uint32_t B147 = (1U << 19);  ///< B147
        constexpr uint32_t B148 = (1U << 20);  ///< B148
        constexpr uint32_t B149 = (1U << 21);  ///< B149
        constexpr uint32_t B150 = (1U << 22);  ///< B150
        constexpr uint32_t B151 = (1U << 23);  ///< B151
        constexpr uint32_t B152 = (1U << 24);  ///< B152
        constexpr uint32_t B153 = (1U << 25);  ///< B153
        constexpr uint32_t B154 = (1U << 26);  ///< B154
        constexpr uint32_t B155 = (1U << 27);  ///< B155
        constexpr uint32_t B156 = (1U << 28);  ///< B156
        constexpr uint32_t B157 = (1U << 29);  ///< B157
        constexpr uint32_t B158 = (1U << 30);  ///< B158
        constexpr uint32_t B159 = (1U << 31);  ///< B159
    }

    /// MPCBB1_VCTR5 Register bits
    namespace mpcbb1_vctr5_bits {
        constexpr uint32_t B160 = (1U << 0);  ///< B160
        constexpr uint32_t B161 = (1U << 1);  ///< B161
        constexpr uint32_t B162 = (1U << 2);  ///< B162
        constexpr uint32_t B163 = (1U << 3);  ///< B163
        constexpr uint32_t B164 = (1U << 4);  ///< B164
        constexpr uint32_t B165 = (1U << 5);  ///< B165
        constexpr uint32_t B166 = (1U << 6);  ///< B166
        constexpr uint32_t B167 = (1U << 7);  ///< B167
        constexpr uint32_t B168 = (1U << 8);  ///< B168
        constexpr uint32_t B169 = (1U << 9);  ///< B169
        constexpr uint32_t B170 = (1U << 10);  ///< B170
        constexpr uint32_t B171 = (1U << 11);  ///< B171
        constexpr uint32_t B172 = (1U << 12);  ///< B172
        constexpr uint32_t B173 = (1U << 13);  ///< B173
        constexpr uint32_t B174 = (1U << 14);  ///< B174
        constexpr uint32_t B175 = (1U << 15);  ///< B175
        constexpr uint32_t B176 = (1U << 16);  ///< B176
        constexpr uint32_t B177 = (1U << 17);  ///< B177
        constexpr uint32_t B178 = (1U << 18);  ///< B178
        constexpr uint32_t B179 = (1U << 19);  ///< B179
        constexpr uint32_t B180 = (1U << 20);  ///< B180
        constexpr uint32_t B181 = (1U << 21);  ///< B181
        constexpr uint32_t B182 = (1U << 22);  ///< B182
        constexpr uint32_t B183 = (1U << 23);  ///< B183
        constexpr uint32_t B184 = (1U << 24);  ///< B184
        constexpr uint32_t B185 = (1U << 25);  ///< B185
        constexpr uint32_t B186 = (1U << 26);  ///< B186
        constexpr uint32_t B187 = (1U << 27);  ///< B187
        constexpr uint32_t B188 = (1U << 28);  ///< B188
        constexpr uint32_t B189 = (1U << 29);  ///< B189
        constexpr uint32_t B190 = (1U << 30);  ///< B190
        constexpr uint32_t B191 = (1U << 31);  ///< B191
    }

    /// MPCBB1_VCTR6 Register bits
    namespace mpcbb1_vctr6_bits {
        constexpr uint32_t B192 = (1U << 0);  ///< B192
        constexpr uint32_t B193 = (1U << 1);  ///< B193
        constexpr uint32_t B194 = (1U << 2);  ///< B194
        constexpr uint32_t B195 = (1U << 3);  ///< B195
        constexpr uint32_t B196 = (1U << 4);  ///< B196
        constexpr uint32_t B197 = (1U << 5);  ///< B197
        constexpr uint32_t B198 = (1U << 6);  ///< B198
        constexpr uint32_t B199 = (1U << 7);  ///< B199
        constexpr uint32_t B200 = (1U << 8);  ///< B200
        constexpr uint32_t B201 = (1U << 9);  ///< B201
        constexpr uint32_t B202 = (1U << 10);  ///< B202
        constexpr uint32_t B203 = (1U << 11);  ///< B203
        constexpr uint32_t B204 = (1U << 12);  ///< B204
        constexpr uint32_t B205 = (1U << 13);  ///< B205
        constexpr uint32_t B206 = (1U << 14);  ///< B206
        constexpr uint32_t B207 = (1U << 15);  ///< B207
        constexpr uint32_t B208 = (1U << 16);  ///< B208
        constexpr uint32_t B209 = (1U << 17);  ///< B209
        constexpr uint32_t B210 = (1U << 18);  ///< B210
        constexpr uint32_t B211 = (1U << 19);  ///< B211
        constexpr uint32_t B212 = (1U << 20);  ///< B212
        constexpr uint32_t B213 = (1U << 21);  ///< B213
        constexpr uint32_t B214 = (1U << 22);  ///< B214
        constexpr uint32_t B215 = (1U << 23);  ///< B215
        constexpr uint32_t B216 = (1U << 24);  ///< B216
        constexpr uint32_t B217 = (1U << 25);  ///< B217
        constexpr uint32_t B218 = (1U << 26);  ///< B218
        constexpr uint32_t B219 = (1U << 27);  ///< B219
        constexpr uint32_t B220 = (1U << 28);  ///< B220
        constexpr uint32_t B221 = (1U << 29);  ///< B221
        constexpr uint32_t B222 = (1U << 30);  ///< B222
        constexpr uint32_t B223 = (1U << 31);  ///< B223
    }

    /// MPCBB1_VCTR7 Register bits
    namespace mpcbb1_vctr7_bits {
        constexpr uint32_t B224 = (1U << 0);  ///< B224
        constexpr uint32_t B225 = (1U << 1);  ///< B225
        constexpr uint32_t B226 = (1U << 2);  ///< B226
        constexpr uint32_t B227 = (1U << 3);  ///< B227
        constexpr uint32_t B228 = (1U << 4);  ///< B228
        constexpr uint32_t B229 = (1U << 5);  ///< B229
        constexpr uint32_t B230 = (1U << 6);  ///< B230
        constexpr uint32_t B231 = (1U << 7);  ///< B231
        constexpr uint32_t B232 = (1U << 8);  ///< B232
        constexpr uint32_t B233 = (1U << 9);  ///< B233
        constexpr uint32_t B234 = (1U << 10);  ///< B234
        constexpr uint32_t B235 = (1U << 11);  ///< B235
        constexpr uint32_t B236 = (1U << 12);  ///< B236
        constexpr uint32_t B237 = (1U << 13);  ///< B237
        constexpr uint32_t B238 = (1U << 14);  ///< B238
        constexpr uint32_t B239 = (1U << 15);  ///< B239
        constexpr uint32_t B240 = (1U << 16);  ///< B240
        constexpr uint32_t B241 = (1U << 17);  ///< B241
        constexpr uint32_t B242 = (1U << 18);  ///< B242
        constexpr uint32_t B243 = (1U << 19);  ///< B243
        constexpr uint32_t B244 = (1U << 20);  ///< B244
        constexpr uint32_t B245 = (1U << 21);  ///< B245
        constexpr uint32_t B246 = (1U << 22);  ///< B246
        constexpr uint32_t B247 = (1U << 23);  ///< B247
        constexpr uint32_t B248 = (1U << 24);  ///< B248
        constexpr uint32_t B249 = (1U << 25);  ///< B249
        constexpr uint32_t B250 = (1U << 26);  ///< B250
        constexpr uint32_t B251 = (1U << 27);  ///< B251
        constexpr uint32_t B252 = (1U << 28);  ///< B252
        constexpr uint32_t B253 = (1U << 29);  ///< B253
        constexpr uint32_t B254 = (1U << 30);  ///< B254
        constexpr uint32_t B255 = (1U << 31);  ///< B255
    }

    /// MPCBB1_VCTR8 Register bits
    namespace mpcbb1_vctr8_bits {
        constexpr uint32_t B256 = (1U << 0);  ///< B256
        constexpr uint32_t B257 = (1U << 1);  ///< B257
        constexpr uint32_t B258 = (1U << 2);  ///< B258
        constexpr uint32_t B259 = (1U << 3);  ///< B259
        constexpr uint32_t B260 = (1U << 4);  ///< B260
        constexpr uint32_t B261 = (1U << 5);  ///< B261
        constexpr uint32_t B262 = (1U << 6);  ///< B262
        constexpr uint32_t B263 = (1U << 7);  ///< B263
        constexpr uint32_t B264 = (1U << 8);  ///< B264
        constexpr uint32_t B265 = (1U << 9);  ///< B265
        constexpr uint32_t B266 = (1U << 10);  ///< B266
        constexpr uint32_t B267 = (1U << 11);  ///< B267
        constexpr uint32_t B268 = (1U << 12);  ///< B268
        constexpr uint32_t B269 = (1U << 13);  ///< B269
        constexpr uint32_t B270 = (1U << 14);  ///< B270
        constexpr uint32_t B271 = (1U << 15);  ///< B271
        constexpr uint32_t B272 = (1U << 16);  ///< B272
        constexpr uint32_t B273 = (1U << 17);  ///< B273
        constexpr uint32_t B274 = (1U << 18);  ///< B274
        constexpr uint32_t B275 = (1U << 19);  ///< B275
        constexpr uint32_t B276 = (1U << 20);  ///< B276
        constexpr uint32_t B277 = (1U << 21);  ///< B277
        constexpr uint32_t B278 = (1U << 22);  ///< B278
        constexpr uint32_t B279 = (1U << 23);  ///< B279
        constexpr uint32_t B280 = (1U << 24);  ///< B280
        constexpr uint32_t B281 = (1U << 25);  ///< B281
        constexpr uint32_t B282 = (1U << 26);  ///< B282
        constexpr uint32_t B283 = (1U << 27);  ///< B283
        constexpr uint32_t B284 = (1U << 28);  ///< B284
        constexpr uint32_t B285 = (1U << 29);  ///< B285
        constexpr uint32_t B286 = (1U << 30);  ///< B286
        constexpr uint32_t B287 = (1U << 31);  ///< B287
    }

    /// MPCBB1_VCTR9 Register bits
    namespace mpcbb1_vctr9_bits {
        constexpr uint32_t B288 = (1U << 0);  ///< B288
        constexpr uint32_t B289 = (1U << 1);  ///< B289
        constexpr uint32_t B290 = (1U << 2);  ///< B290
        constexpr uint32_t B291 = (1U << 3);  ///< B291
        constexpr uint32_t B292 = (1U << 4);  ///< B292
        constexpr uint32_t B293 = (1U << 5);  ///< B293
        constexpr uint32_t B294 = (1U << 6);  ///< B294
        constexpr uint32_t B295 = (1U << 7);  ///< B295
        constexpr uint32_t B296 = (1U << 8);  ///< B296
        constexpr uint32_t B297 = (1U << 9);  ///< B297
        constexpr uint32_t B298 = (1U << 10);  ///< B298
        constexpr uint32_t B299 = (1U << 11);  ///< B299
        constexpr uint32_t B300 = (1U << 12);  ///< B300
        constexpr uint32_t B301 = (1U << 13);  ///< B301
        constexpr uint32_t B302 = (1U << 14);  ///< B302
        constexpr uint32_t B303 = (1U << 15);  ///< B303
        constexpr uint32_t B304 = (1U << 16);  ///< B304
        constexpr uint32_t B305 = (1U << 17);  ///< B305
        constexpr uint32_t B306 = (1U << 18);  ///< B306
        constexpr uint32_t B307 = (1U << 19);  ///< B307
        constexpr uint32_t B308 = (1U << 20);  ///< B308
        constexpr uint32_t B309 = (1U << 21);  ///< B309
        constexpr uint32_t B310 = (1U << 22);  ///< B310
        constexpr uint32_t B311 = (1U << 23);  ///< B311
        constexpr uint32_t B312 = (1U << 24);  ///< B312
        constexpr uint32_t B313 = (1U << 25);  ///< B313
        constexpr uint32_t B314 = (1U << 26);  ///< B314
        constexpr uint32_t B315 = (1U << 27);  ///< B315
        constexpr uint32_t B316 = (1U << 28);  ///< B316
        constexpr uint32_t B317 = (1U << 29);  ///< B317
        constexpr uint32_t B318 = (1U << 30);  ///< B318
        constexpr uint32_t B319 = (1U << 31);  ///< B319
    }

    /// MPCBB1_VCTR10 Register bits
    namespace mpcbb1_vctr10_bits {
        constexpr uint32_t B320 = (1U << 0);  ///< B320
        constexpr uint32_t B321 = (1U << 1);  ///< B321
        constexpr uint32_t B322 = (1U << 2);  ///< B322
        constexpr uint32_t B323 = (1U << 3);  ///< B323
        constexpr uint32_t B324 = (1U << 4);  ///< B324
        constexpr uint32_t B325 = (1U << 5);  ///< B325
        constexpr uint32_t B326 = (1U << 6);  ///< B326
        constexpr uint32_t B327 = (1U << 7);  ///< B327
        constexpr uint32_t B328 = (1U << 8);  ///< B328
        constexpr uint32_t B329 = (1U << 9);  ///< B329
        constexpr uint32_t B330 = (1U << 10);  ///< B330
        constexpr uint32_t B331 = (1U << 11);  ///< B331
        constexpr uint32_t B332 = (1U << 12);  ///< B332
        constexpr uint32_t B333 = (1U << 13);  ///< B333
        constexpr uint32_t B334 = (1U << 14);  ///< B334
        constexpr uint32_t B335 = (1U << 15);  ///< B335
        constexpr uint32_t B336 = (1U << 16);  ///< B336
        constexpr uint32_t B337 = (1U << 17);  ///< B337
        constexpr uint32_t B338 = (1U << 18);  ///< B338
        constexpr uint32_t B339 = (1U << 19);  ///< B339
        constexpr uint32_t B340 = (1U << 20);  ///< B340
        constexpr uint32_t B341 = (1U << 21);  ///< B341
        constexpr uint32_t B342 = (1U << 22);  ///< B342
        constexpr uint32_t B343 = (1U << 23);  ///< B343
        constexpr uint32_t B344 = (1U << 24);  ///< B344
        constexpr uint32_t B345 = (1U << 25);  ///< B345
        constexpr uint32_t B346 = (1U << 26);  ///< B346
        constexpr uint32_t B347 = (1U << 27);  ///< B347
        constexpr uint32_t B348 = (1U << 28);  ///< B348
        constexpr uint32_t B349 = (1U << 29);  ///< B349
        constexpr uint32_t B350 = (1U << 30);  ///< B350
        constexpr uint32_t B351 = (1U << 31);  ///< B351
    }

    /// MPCBB1_VCTR11 Register bits
    namespace mpcbb1_vctr11_bits {
        constexpr uint32_t B352 = (1U << 0);  ///< B352
        constexpr uint32_t B353 = (1U << 1);  ///< B353
        constexpr uint32_t B354 = (1U << 2);  ///< B354
        constexpr uint32_t B355 = (1U << 3);  ///< B355
        constexpr uint32_t B356 = (1U << 4);  ///< B356
        constexpr uint32_t B357 = (1U << 5);  ///< B357
        constexpr uint32_t B358 = (1U << 6);  ///< B358
        constexpr uint32_t B359 = (1U << 7);  ///< B359
        constexpr uint32_t B360 = (1U << 8);  ///< B360
        constexpr uint32_t B361 = (1U << 9);  ///< B361
        constexpr uint32_t B362 = (1U << 10);  ///< B362
        constexpr uint32_t B363 = (1U << 11);  ///< B363
        constexpr uint32_t B364 = (1U << 12);  ///< B364
        constexpr uint32_t B365 = (1U << 13);  ///< B365
        constexpr uint32_t B366 = (1U << 14);  ///< B366
        constexpr uint32_t B367 = (1U << 15);  ///< B367
        constexpr uint32_t B368 = (1U << 16);  ///< B368
        constexpr uint32_t B369 = (1U << 17);  ///< B369
        constexpr uint32_t B370 = (1U << 18);  ///< B370
        constexpr uint32_t B371 = (1U << 19);  ///< B371
        constexpr uint32_t B372 = (1U << 20);  ///< B372
        constexpr uint32_t B373 = (1U << 21);  ///< B373
        constexpr uint32_t B374 = (1U << 22);  ///< B374
        constexpr uint32_t B375 = (1U << 23);  ///< B375
        constexpr uint32_t B376 = (1U << 24);  ///< B376
        constexpr uint32_t B377 = (1U << 25);  ///< B377
        constexpr uint32_t B378 = (1U << 26);  ///< B378
        constexpr uint32_t B379 = (1U << 27);  ///< B379
        constexpr uint32_t B380 = (1U << 28);  ///< B380
        constexpr uint32_t B381 = (1U << 29);  ///< B381
        constexpr uint32_t B382 = (1U << 30);  ///< B382
        constexpr uint32_t B383 = (1U << 31);  ///< B383
    }

    /// MPCBB1_VCTR12 Register bits
    namespace mpcbb1_vctr12_bits {
        constexpr uint32_t B384 = (1U << 0);  ///< B384
        constexpr uint32_t B385 = (1U << 1);  ///< B385
        constexpr uint32_t B386 = (1U << 2);  ///< B386
        constexpr uint32_t B387 = (1U << 3);  ///< B387
        constexpr uint32_t B388 = (1U << 4);  ///< B388
        constexpr uint32_t B389 = (1U << 5);  ///< B389
        constexpr uint32_t B390 = (1U << 6);  ///< B390
        constexpr uint32_t B391 = (1U << 7);  ///< B391
        constexpr uint32_t B392 = (1U << 8);  ///< B392
        constexpr uint32_t B393 = (1U << 9);  ///< B393
        constexpr uint32_t B394 = (1U << 10);  ///< B394
        constexpr uint32_t B395 = (1U << 11);  ///< B395
        constexpr uint32_t B396 = (1U << 12);  ///< B396
        constexpr uint32_t B397 = (1U << 13);  ///< B397
        constexpr uint32_t B398 = (1U << 14);  ///< B398
        constexpr uint32_t B399 = (1U << 15);  ///< B399
        constexpr uint32_t B400 = (1U << 16);  ///< B400
        constexpr uint32_t B401 = (1U << 17);  ///< B401
        constexpr uint32_t B402 = (1U << 18);  ///< B402
        constexpr uint32_t B403 = (1U << 19);  ///< B403
        constexpr uint32_t B404 = (1U << 20);  ///< B404
        constexpr uint32_t B405 = (1U << 21);  ///< B405
        constexpr uint32_t B406 = (1U << 22);  ///< B406
        constexpr uint32_t B407 = (1U << 23);  ///< B407
        constexpr uint32_t B408 = (1U << 24);  ///< B408
        constexpr uint32_t B409 = (1U << 25);  ///< B409
        constexpr uint32_t B410 = (1U << 26);  ///< B410
        constexpr uint32_t B411 = (1U << 27);  ///< B411
        constexpr uint32_t B412 = (1U << 28);  ///< B412
        constexpr uint32_t B413 = (1U << 29);  ///< B413
        constexpr uint32_t B414 = (1U << 30);  ///< B414
        constexpr uint32_t B415 = (1U << 31);  ///< B415
    }

    /// MPCBB1_VCTR13 Register bits
    namespace mpcbb1_vctr13_bits {
        constexpr uint32_t B416 = (1U << 0);  ///< B416
        constexpr uint32_t B417 = (1U << 1);  ///< B417
        constexpr uint32_t B418 = (1U << 2);  ///< B418
        constexpr uint32_t B419 = (1U << 3);  ///< B419
        constexpr uint32_t B420 = (1U << 4);  ///< B420
        constexpr uint32_t B421 = (1U << 5);  ///< B421
        constexpr uint32_t B422 = (1U << 6);  ///< B422
        constexpr uint32_t B423 = (1U << 7);  ///< B423
        constexpr uint32_t B424 = (1U << 8);  ///< B424
        constexpr uint32_t B425 = (1U << 9);  ///< B425
        constexpr uint32_t B426 = (1U << 10);  ///< B426
        constexpr uint32_t B427 = (1U << 11);  ///< B427
        constexpr uint32_t B428 = (1U << 12);  ///< B428
        constexpr uint32_t B429 = (1U << 13);  ///< B429
        constexpr uint32_t B430 = (1U << 14);  ///< B430
        constexpr uint32_t B431 = (1U << 15);  ///< B431
        constexpr uint32_t B432 = (1U << 16);  ///< B432
        constexpr uint32_t B433 = (1U << 17);  ///< B433
        constexpr uint32_t B434 = (1U << 18);  ///< B434
        constexpr uint32_t B435 = (1U << 19);  ///< B435
        constexpr uint32_t B436 = (1U << 20);  ///< B436
        constexpr uint32_t B437 = (1U << 21);  ///< B437
        constexpr uint32_t B438 = (1U << 22);  ///< B438
        constexpr uint32_t B439 = (1U << 23);  ///< B439
        constexpr uint32_t B440 = (1U << 24);  ///< B440
        constexpr uint32_t B441 = (1U << 25);  ///< B441
        constexpr uint32_t B442 = (1U << 26);  ///< B442
        constexpr uint32_t B443 = (1U << 27);  ///< B443
        constexpr uint32_t B444 = (1U << 28);  ///< B444
        constexpr uint32_t B445 = (1U << 29);  ///< B445
        constexpr uint32_t B446 = (1U << 30);  ///< B446
        constexpr uint32_t B447 = (1U << 31);  ///< B447
    }

    /// MPCBB1_VCTR14 Register bits
    namespace mpcbb1_vctr14_bits {
        constexpr uint32_t B448 = (1U << 0);  ///< B448
        constexpr uint32_t B449 = (1U << 1);  ///< B449
        constexpr uint32_t B450 = (1U << 2);  ///< B450
        constexpr uint32_t B451 = (1U << 3);  ///< B451
        constexpr uint32_t B452 = (1U << 4);  ///< B452
        constexpr uint32_t B453 = (1U << 5);  ///< B453
        constexpr uint32_t B454 = (1U << 6);  ///< B454
        constexpr uint32_t B455 = (1U << 7);  ///< B455
        constexpr uint32_t B456 = (1U << 8);  ///< B456
        constexpr uint32_t B457 = (1U << 9);  ///< B457
        constexpr uint32_t B458 = (1U << 10);  ///< B458
        constexpr uint32_t B459 = (1U << 11);  ///< B459
        constexpr uint32_t B460 = (1U << 12);  ///< B460
        constexpr uint32_t B461 = (1U << 13);  ///< B461
        constexpr uint32_t B462 = (1U << 14);  ///< B462
        constexpr uint32_t B463 = (1U << 15);  ///< B463
        constexpr uint32_t B464 = (1U << 16);  ///< B464
        constexpr uint32_t B465 = (1U << 17);  ///< B465
        constexpr uint32_t B466 = (1U << 18);  ///< B466
        constexpr uint32_t B467 = (1U << 19);  ///< B467
        constexpr uint32_t B468 = (1U << 20);  ///< B468
        constexpr uint32_t B469 = (1U << 21);  ///< B469
        constexpr uint32_t B470 = (1U << 22);  ///< B470
        constexpr uint32_t B471 = (1U << 23);  ///< B471
        constexpr uint32_t B472 = (1U << 24);  ///< B472
        constexpr uint32_t B473 = (1U << 25);  ///< B473
        constexpr uint32_t B474 = (1U << 26);  ///< B474
        constexpr uint32_t B475 = (1U << 27);  ///< B475
        constexpr uint32_t B476 = (1U << 28);  ///< B476
        constexpr uint32_t B477 = (1U << 29);  ///< B477
        constexpr uint32_t B478 = (1U << 30);  ///< B478
        constexpr uint32_t B479 = (1U << 31);  ///< B479
    }

    /// MPCBB1_VCTR15 Register bits
    namespace mpcbb1_vctr15_bits {
        constexpr uint32_t B480 = (1U << 0);  ///< B480
        constexpr uint32_t B481 = (1U << 1);  ///< B481
        constexpr uint32_t B482 = (1U << 2);  ///< B482
        constexpr uint32_t B483 = (1U << 3);  ///< B483
        constexpr uint32_t B484 = (1U << 4);  ///< B484
        constexpr uint32_t B485 = (1U << 5);  ///< B485
        constexpr uint32_t B486 = (1U << 6);  ///< B486
        constexpr uint32_t B487 = (1U << 7);  ///< B487
        constexpr uint32_t B488 = (1U << 8);  ///< B488
        constexpr uint32_t B489 = (1U << 9);  ///< B489
        constexpr uint32_t B490 = (1U << 10);  ///< B490
        constexpr uint32_t B491 = (1U << 11);  ///< B491
        constexpr uint32_t B492 = (1U << 12);  ///< B492
        constexpr uint32_t B493 = (1U << 13);  ///< B493
        constexpr uint32_t B494 = (1U << 14);  ///< B494
        constexpr uint32_t B495 = (1U << 15);  ///< B495
        constexpr uint32_t B496 = (1U << 16);  ///< B496
        constexpr uint32_t B497 = (1U << 17);  ///< B497
        constexpr uint32_t B498 = (1U << 18);  ///< B498
        constexpr uint32_t B499 = (1U << 19);  ///< B499
        constexpr uint32_t B500 = (1U << 20);  ///< B500
        constexpr uint32_t B501 = (1U << 21);  ///< B501
        constexpr uint32_t B502 = (1U << 22);  ///< B502
        constexpr uint32_t B503 = (1U << 23);  ///< B503
        constexpr uint32_t B504 = (1U << 24);  ///< B504
        constexpr uint32_t B505 = (1U << 25);  ///< B505
        constexpr uint32_t B506 = (1U << 26);  ///< B506
        constexpr uint32_t B507 = (1U << 27);  ///< B507
        constexpr uint32_t B508 = (1U << 28);  ///< B508
        constexpr uint32_t B509 = (1U << 29);  ///< B509
        constexpr uint32_t B510 = (1U << 30);  ///< B510
        constexpr uint32_t B511 = (1U << 31);  ///< B511
    }

    /// MPCBB1_VCTR16 Register bits
    namespace mpcbb1_vctr16_bits {
        constexpr uint32_t B512 = (1U << 0);  ///< B512
        constexpr uint32_t B513 = (1U << 1);  ///< B513
        constexpr uint32_t B514 = (1U << 2);  ///< B514
        constexpr uint32_t B515 = (1U << 3);  ///< B515
        constexpr uint32_t B516 = (1U << 4);  ///< B516
        constexpr uint32_t B517 = (1U << 5);  ///< B517
        constexpr uint32_t B518 = (1U << 6);  ///< B518
        constexpr uint32_t B519 = (1U << 7);  ///< B519
        constexpr uint32_t B520 = (1U << 8);  ///< B520
        constexpr uint32_t B521 = (1U << 9);  ///< B521
        constexpr uint32_t B522 = (1U << 10);  ///< B522
        constexpr uint32_t B523 = (1U << 11);  ///< B523
        constexpr uint32_t B524 = (1U << 12);  ///< B524
        constexpr uint32_t B525 = (1U << 13);  ///< B525
        constexpr uint32_t B526 = (1U << 14);  ///< B526
        constexpr uint32_t B527 = (1U << 15);  ///< B527
        constexpr uint32_t B528 = (1U << 16);  ///< B528
        constexpr uint32_t B529 = (1U << 17);  ///< B529
        constexpr uint32_t B530 = (1U << 18);  ///< B530
        constexpr uint32_t B531 = (1U << 19);  ///< B531
        constexpr uint32_t B532 = (1U << 20);  ///< B532
        constexpr uint32_t B533 = (1U << 21);  ///< B533
        constexpr uint32_t B534 = (1U << 22);  ///< B534
        constexpr uint32_t B535 = (1U << 23);  ///< B535
        constexpr uint32_t B536 = (1U << 24);  ///< B536
        constexpr uint32_t B537 = (1U << 25);  ///< B537
        constexpr uint32_t B538 = (1U << 26);  ///< B538
        constexpr uint32_t B539 = (1U << 27);  ///< B539
        constexpr uint32_t B540 = (1U << 28);  ///< B540
        constexpr uint32_t B541 = (1U << 29);  ///< B541
        constexpr uint32_t B542 = (1U << 30);  ///< B542
        constexpr uint32_t B543 = (1U << 31);  ///< B543
    }

    /// MPCBB1_VCTR17 Register bits
    namespace mpcbb1_vctr17_bits {
        constexpr uint32_t B544 = (1U << 0);  ///< B544
        constexpr uint32_t B545 = (1U << 1);  ///< B545
        constexpr uint32_t B546 = (1U << 2);  ///< B546
        constexpr uint32_t B547 = (1U << 3);  ///< B547
        constexpr uint32_t B548 = (1U << 4);  ///< B548
        constexpr uint32_t B549 = (1U << 5);  ///< B549
        constexpr uint32_t B550 = (1U << 6);  ///< B550
        constexpr uint32_t B551 = (1U << 7);  ///< B551
        constexpr uint32_t B552 = (1U << 8);  ///< B552
        constexpr uint32_t B553 = (1U << 9);  ///< B553
        constexpr uint32_t B554 = (1U << 10);  ///< B554
        constexpr uint32_t B555 = (1U << 11);  ///< B555
        constexpr uint32_t B556 = (1U << 12);  ///< B556
        constexpr uint32_t B557 = (1U << 13);  ///< B557
        constexpr uint32_t B558 = (1U << 14);  ///< B558
        constexpr uint32_t B559 = (1U << 15);  ///< B559
        constexpr uint32_t B560 = (1U << 16);  ///< B560
        constexpr uint32_t B561 = (1U << 17);  ///< B561
        constexpr uint32_t B562 = (1U << 18);  ///< B562
        constexpr uint32_t B563 = (1U << 19);  ///< B563
        constexpr uint32_t B564 = (1U << 20);  ///< B564
        constexpr uint32_t B565 = (1U << 21);  ///< B565
        constexpr uint32_t B566 = (1U << 22);  ///< B566
        constexpr uint32_t B567 = (1U << 23);  ///< B567
        constexpr uint32_t B568 = (1U << 24);  ///< B568
        constexpr uint32_t B569 = (1U << 25);  ///< B569
        constexpr uint32_t B570 = (1U << 26);  ///< B570
        constexpr uint32_t B571 = (1U << 27);  ///< B571
        constexpr uint32_t B572 = (1U << 28);  ///< B572
        constexpr uint32_t B573 = (1U << 29);  ///< B573
        constexpr uint32_t B574 = (1U << 30);  ///< B574
        constexpr uint32_t B575 = (1U << 31);  ///< B575
    }

    /// MPCBB1_VCTR18 Register bits
    namespace mpcbb1_vctr18_bits {
        constexpr uint32_t B576 = (1U << 0);  ///< B576
        constexpr uint32_t B577 = (1U << 1);  ///< B577
        constexpr uint32_t B578 = (1U << 2);  ///< B578
        constexpr uint32_t B579 = (1U << 3);  ///< B579
        constexpr uint32_t B580 = (1U << 4);  ///< B580
        constexpr uint32_t B581 = (1U << 5);  ///< B581
        constexpr uint32_t B582 = (1U << 6);  ///< B582
        constexpr uint32_t B583 = (1U << 7);  ///< B583
        constexpr uint32_t B584 = (1U << 8);  ///< B584
        constexpr uint32_t B585 = (1U << 9);  ///< B585
        constexpr uint32_t B586 = (1U << 10);  ///< B586
        constexpr uint32_t B587 = (1U << 11);  ///< B587
        constexpr uint32_t B588 = (1U << 12);  ///< B588
        constexpr uint32_t B589 = (1U << 13);  ///< B589
        constexpr uint32_t B590 = (1U << 14);  ///< B590
        constexpr uint32_t B591 = (1U << 15);  ///< B591
        constexpr uint32_t B592 = (1U << 16);  ///< B592
        constexpr uint32_t B593 = (1U << 17);  ///< B593
        constexpr uint32_t B594 = (1U << 18);  ///< B594
        constexpr uint32_t B595 = (1U << 19);  ///< B595
        constexpr uint32_t B596 = (1U << 20);  ///< B596
        constexpr uint32_t B597 = (1U << 21);  ///< B597
        constexpr uint32_t B598 = (1U << 22);  ///< B598
        constexpr uint32_t B599 = (1U << 23);  ///< B599
        constexpr uint32_t B600 = (1U << 24);  ///< B600
        constexpr uint32_t B601 = (1U << 25);  ///< B601
        constexpr uint32_t B602 = (1U << 26);  ///< B602
        constexpr uint32_t B603 = (1U << 27);  ///< B603
        constexpr uint32_t B604 = (1U << 28);  ///< B604
        constexpr uint32_t B605 = (1U << 29);  ///< B605
        constexpr uint32_t B606 = (1U << 30);  ///< B606
        constexpr uint32_t B607 = (1U << 31);  ///< B607
    }

    /// MPCBB1_VCTR19 Register bits
    namespace mpcbb1_vctr19_bits {
        constexpr uint32_t B608 = (1U << 0);  ///< B608
        constexpr uint32_t B609 = (1U << 1);  ///< B609
        constexpr uint32_t B610 = (1U << 2);  ///< B610
        constexpr uint32_t B611 = (1U << 3);  ///< B611
        constexpr uint32_t B612 = (1U << 4);  ///< B612
        constexpr uint32_t B613 = (1U << 5);  ///< B613
        constexpr uint32_t B614 = (1U << 6);  ///< B614
        constexpr uint32_t B615 = (1U << 7);  ///< B615
        constexpr uint32_t B616 = (1U << 8);  ///< B616
        constexpr uint32_t B617 = (1U << 9);  ///< B617
        constexpr uint32_t B618 = (1U << 10);  ///< B618
        constexpr uint32_t B619 = (1U << 11);  ///< B619
        constexpr uint32_t B620 = (1U << 12);  ///< B620
        constexpr uint32_t B621 = (1U << 13);  ///< B621
        constexpr uint32_t B622 = (1U << 14);  ///< B622
        constexpr uint32_t B623 = (1U << 15);  ///< B623
        constexpr uint32_t B624 = (1U << 16);  ///< B624
        constexpr uint32_t B625 = (1U << 17);  ///< B625
        constexpr uint32_t B626 = (1U << 18);  ///< B626
        constexpr uint32_t B627 = (1U << 19);  ///< B627
        constexpr uint32_t B628 = (1U << 20);  ///< B628
        constexpr uint32_t B629 = (1U << 21);  ///< B629
        constexpr uint32_t B630 = (1U << 22);  ///< B630
        constexpr uint32_t B631 = (1U << 23);  ///< B631
        constexpr uint32_t B632 = (1U << 24);  ///< B632
        constexpr uint32_t B633 = (1U << 25);  ///< B633
        constexpr uint32_t B634 = (1U << 26);  ///< B634
        constexpr uint32_t B635 = (1U << 27);  ///< B635
        constexpr uint32_t B636 = (1U << 28);  ///< B636
        constexpr uint32_t B637 = (1U << 29);  ///< B637
        constexpr uint32_t B638 = (1U << 30);  ///< B638
        constexpr uint32_t B639 = (1U << 31);  ///< B639
    }

    /// MPCBB1_VCTR20 Register bits
    namespace mpcbb1_vctr20_bits {
        constexpr uint32_t B640 = (1U << 0);  ///< B640
        constexpr uint32_t B641 = (1U << 1);  ///< B641
        constexpr uint32_t B642 = (1U << 2);  ///< B642
        constexpr uint32_t B643 = (1U << 3);  ///< B643
        constexpr uint32_t B644 = (1U << 4);  ///< B644
        constexpr uint32_t B645 = (1U << 5);  ///< B645
        constexpr uint32_t B646 = (1U << 6);  ///< B646
        constexpr uint32_t B647 = (1U << 7);  ///< B647
        constexpr uint32_t B648 = (1U << 8);  ///< B648
        constexpr uint32_t B649 = (1U << 9);  ///< B649
        constexpr uint32_t B650 = (1U << 10);  ///< B650
        constexpr uint32_t B651 = (1U << 11);  ///< B651
        constexpr uint32_t B652 = (1U << 12);  ///< B652
        constexpr uint32_t B653 = (1U << 13);  ///< B653
        constexpr uint32_t B654 = (1U << 14);  ///< B654
        constexpr uint32_t B655 = (1U << 15);  ///< B655
        constexpr uint32_t B656 = (1U << 16);  ///< B656
        constexpr uint32_t B657 = (1U << 17);  ///< B657
        constexpr uint32_t B658 = (1U << 18);  ///< B658
        constexpr uint32_t B659 = (1U << 19);  ///< B659
        constexpr uint32_t B660 = (1U << 20);  ///< B660
        constexpr uint32_t B661 = (1U << 21);  ///< B661
        constexpr uint32_t B662 = (1U << 22);  ///< B662
        constexpr uint32_t B663 = (1U << 23);  ///< B663
        constexpr uint32_t B664 = (1U << 24);  ///< B664
        constexpr uint32_t B665 = (1U << 25);  ///< B665
        constexpr uint32_t B666 = (1U << 26);  ///< B666
        constexpr uint32_t B667 = (1U << 27);  ///< B667
        constexpr uint32_t B668 = (1U << 28);  ///< B668
        constexpr uint32_t B669 = (1U << 29);  ///< B669
        constexpr uint32_t B670 = (1U << 30);  ///< B670
        constexpr uint32_t B671 = (1U << 31);  ///< B671
    }

    /// MPCBB1_VCTR21 Register bits
    namespace mpcbb1_vctr21_bits {
        constexpr uint32_t B672 = (1U << 0);  ///< B672
        constexpr uint32_t B673 = (1U << 1);  ///< B673
        constexpr uint32_t B674 = (1U << 2);  ///< B674
        constexpr uint32_t B675 = (1U << 3);  ///< B675
        constexpr uint32_t B676 = (1U << 4);  ///< B676
        constexpr uint32_t B677 = (1U << 5);  ///< B677
        constexpr uint32_t B678 = (1U << 6);  ///< B678
        constexpr uint32_t B679 = (1U << 7);  ///< B679
        constexpr uint32_t B680 = (1U << 8);  ///< B680
        constexpr uint32_t B681 = (1U << 9);  ///< B681
        constexpr uint32_t B682 = (1U << 10);  ///< B682
        constexpr uint32_t B683 = (1U << 11);  ///< B683
        constexpr uint32_t B684 = (1U << 12);  ///< B684
        constexpr uint32_t B685 = (1U << 13);  ///< B685
        constexpr uint32_t B686 = (1U << 14);  ///< B686
        constexpr uint32_t B687 = (1U << 15);  ///< B687
        constexpr uint32_t B688 = (1U << 16);  ///< B688
        constexpr uint32_t B689 = (1U << 17);  ///< B689
        constexpr uint32_t B690 = (1U << 18);  ///< B690
        constexpr uint32_t B691 = (1U << 19);  ///< B691
        constexpr uint32_t B692 = (1U << 20);  ///< B692
        constexpr uint32_t B693 = (1U << 21);  ///< B693
        constexpr uint32_t B694 = (1U << 22);  ///< B694
        constexpr uint32_t B695 = (1U << 23);  ///< B695
        constexpr uint32_t B696 = (1U << 24);  ///< B696
        constexpr uint32_t B697 = (1U << 25);  ///< B697
        constexpr uint32_t B698 = (1U << 26);  ///< B698
        constexpr uint32_t B699 = (1U << 27);  ///< B699
        constexpr uint32_t B700 = (1U << 28);  ///< B700
        constexpr uint32_t B701 = (1U << 29);  ///< B701
        constexpr uint32_t B702 = (1U << 30);  ///< B702
        constexpr uint32_t B703 = (1U << 31);  ///< B703
    }

    /// MPCBB1_VCTR22 Register bits
    namespace mpcbb1_vctr22_bits {
        constexpr uint32_t B704 = (1U << 0);  ///< B704
        constexpr uint32_t B705 = (1U << 1);  ///< B705
        constexpr uint32_t B706 = (1U << 2);  ///< B706
        constexpr uint32_t B707 = (1U << 3);  ///< B707
        constexpr uint32_t B708 = (1U << 4);  ///< B708
        constexpr uint32_t B709 = (1U << 5);  ///< B709
        constexpr uint32_t B710 = (1U << 6);  ///< B710
        constexpr uint32_t B711 = (1U << 7);  ///< B711
        constexpr uint32_t B712 = (1U << 8);  ///< B712
        constexpr uint32_t B713 = (1U << 9);  ///< B713
        constexpr uint32_t B714 = (1U << 10);  ///< B714
        constexpr uint32_t B715 = (1U << 11);  ///< B715
        constexpr uint32_t B716 = (1U << 12);  ///< B716
        constexpr uint32_t B717 = (1U << 13);  ///< B717
        constexpr uint32_t B718 = (1U << 14);  ///< B718
        constexpr uint32_t B719 = (1U << 15);  ///< B719
        constexpr uint32_t B720 = (1U << 16);  ///< B720
        constexpr uint32_t B721 = (1U << 17);  ///< B721
        constexpr uint32_t B722 = (1U << 18);  ///< B722
        constexpr uint32_t B723 = (1U << 19);  ///< B723
        constexpr uint32_t B724 = (1U << 20);  ///< B724
        constexpr uint32_t B725 = (1U << 21);  ///< B725
        constexpr uint32_t B726 = (1U << 22);  ///< B726
        constexpr uint32_t B727 = (1U << 23);  ///< B727
        constexpr uint32_t B728 = (1U << 24);  ///< B728
        constexpr uint32_t B729 = (1U << 25);  ///< B729
        constexpr uint32_t B730 = (1U << 26);  ///< B730
        constexpr uint32_t B731 = (1U << 27);  ///< B731
        constexpr uint32_t B732 = (1U << 28);  ///< B732
        constexpr uint32_t B733 = (1U << 29);  ///< B733
        constexpr uint32_t B734 = (1U << 30);  ///< B734
        constexpr uint32_t B735 = (1U << 31);  ///< B735
    }

    /// MPCBB1_VCTR23 Register bits
    namespace mpcbb1_vctr23_bits {
        constexpr uint32_t B736 = (1U << 0);  ///< B736
        constexpr uint32_t B737 = (1U << 1);  ///< B737
        constexpr uint32_t B738 = (1U << 2);  ///< B738
        constexpr uint32_t B739 = (1U << 3);  ///< B739
        constexpr uint32_t B740 = (1U << 4);  ///< B740
        constexpr uint32_t B741 = (1U << 5);  ///< B741
        constexpr uint32_t B742 = (1U << 6);  ///< B742
        constexpr uint32_t B743 = (1U << 7);  ///< B743
        constexpr uint32_t B744 = (1U << 8);  ///< B744
        constexpr uint32_t B745 = (1U << 9);  ///< B745
        constexpr uint32_t B746 = (1U << 10);  ///< B746
        constexpr uint32_t B747 = (1U << 11);  ///< B747
        constexpr uint32_t B748 = (1U << 12);  ///< B748
        constexpr uint32_t B749 = (1U << 13);  ///< B749
        constexpr uint32_t B750 = (1U << 14);  ///< B750
        constexpr uint32_t B751 = (1U << 15);  ///< B751
        constexpr uint32_t B752 = (1U << 16);  ///< B752
        constexpr uint32_t B753 = (1U << 17);  ///< B753
        constexpr uint32_t B754 = (1U << 18);  ///< B754
        constexpr uint32_t B755 = (1U << 19);  ///< B755
        constexpr uint32_t B756 = (1U << 20);  ///< B756
        constexpr uint32_t B757 = (1U << 21);  ///< B757
        constexpr uint32_t B758 = (1U << 22);  ///< B758
        constexpr uint32_t B759 = (1U << 23);  ///< B759
        constexpr uint32_t B760 = (1U << 24);  ///< B760
        constexpr uint32_t B761 = (1U << 25);  ///< B761
        constexpr uint32_t B762 = (1U << 26);  ///< B762
        constexpr uint32_t B763 = (1U << 27);  ///< B763
        constexpr uint32_t B764 = (1U << 28);  ///< B764
        constexpr uint32_t B765 = (1U << 29);  ///< B765
        constexpr uint32_t B766 = (1U << 30);  ///< B766
        constexpr uint32_t B767 = (1U << 31);  ///< B767
    }

    /// MPCBB1_VCTR24 Register bits
    namespace mpcbb1_vctr24_bits {
        constexpr uint32_t B768 = (1U << 0);  ///< B768
        constexpr uint32_t B769 = (1U << 1);  ///< B769
        constexpr uint32_t B770 = (1U << 2);  ///< B770
        constexpr uint32_t B771 = (1U << 3);  ///< B771
        constexpr uint32_t B772 = (1U << 4);  ///< B772
        constexpr uint32_t B773 = (1U << 5);  ///< B773
        constexpr uint32_t B774 = (1U << 6);  ///< B774
        constexpr uint32_t B775 = (1U << 7);  ///< B775
        constexpr uint32_t B776 = (1U << 8);  ///< B776
        constexpr uint32_t B777 = (1U << 9);  ///< B777
        constexpr uint32_t B778 = (1U << 10);  ///< B778
        constexpr uint32_t B779 = (1U << 11);  ///< B779
        constexpr uint32_t B780 = (1U << 12);  ///< B780
        constexpr uint32_t B781 = (1U << 13);  ///< B781
        constexpr uint32_t B782 = (1U << 14);  ///< B782
        constexpr uint32_t B783 = (1U << 15);  ///< B783
        constexpr uint32_t B784 = (1U << 16);  ///< B784
        constexpr uint32_t B785 = (1U << 17);  ///< B785
        constexpr uint32_t B786 = (1U << 18);  ///< B786
        constexpr uint32_t B787 = (1U << 19);  ///< B787
        constexpr uint32_t B788 = (1U << 20);  ///< B788
        constexpr uint32_t B789 = (1U << 21);  ///< B789
        constexpr uint32_t B790 = (1U << 22);  ///< B790
        constexpr uint32_t B791 = (1U << 23);  ///< B791
        constexpr uint32_t B792 = (1U << 24);  ///< B792
        constexpr uint32_t B793 = (1U << 25);  ///< B793
        constexpr uint32_t B794 = (1U << 26);  ///< B794
        constexpr uint32_t B795 = (1U << 27);  ///< B795
        constexpr uint32_t B796 = (1U << 28);  ///< B796
        constexpr uint32_t B797 = (1U << 29);  ///< B797
        constexpr uint32_t B798 = (1U << 30);  ///< B798
        constexpr uint32_t B799 = (1U << 31);  ///< B799
    }

    /// MPCBB1_VCTR25 Register bits
    namespace mpcbb1_vctr25_bits {
        constexpr uint32_t B800 = (1U << 0);  ///< B800
        constexpr uint32_t B801 = (1U << 1);  ///< B801
        constexpr uint32_t B802 = (1U << 2);  ///< B802
        constexpr uint32_t B803 = (1U << 3);  ///< B803
        constexpr uint32_t B804 = (1U << 4);  ///< B804
        constexpr uint32_t B805 = (1U << 5);  ///< B805
        constexpr uint32_t B806 = (1U << 6);  ///< B806
        constexpr uint32_t B807 = (1U << 7);  ///< B807
        constexpr uint32_t B808 = (1U << 8);  ///< B808
        constexpr uint32_t B809 = (1U << 9);  ///< B809
        constexpr uint32_t B810 = (1U << 10);  ///< B810
        constexpr uint32_t B811 = (1U << 11);  ///< B811
        constexpr uint32_t B812 = (1U << 12);  ///< B812
        constexpr uint32_t B813 = (1U << 13);  ///< B813
        constexpr uint32_t B814 = (1U << 14);  ///< B814
        constexpr uint32_t B815 = (1U << 15);  ///< B815
        constexpr uint32_t B816 = (1U << 16);  ///< B816
        constexpr uint32_t B817 = (1U << 17);  ///< B817
        constexpr uint32_t B818 = (1U << 18);  ///< B818
        constexpr uint32_t B819 = (1U << 19);  ///< B819
        constexpr uint32_t B820 = (1U << 20);  ///< B820
        constexpr uint32_t B821 = (1U << 21);  ///< B821
        constexpr uint32_t B822 = (1U << 22);  ///< B822
        constexpr uint32_t B823 = (1U << 23);  ///< B823
        constexpr uint32_t B824 = (1U << 24);  ///< B824
        constexpr uint32_t B825 = (1U << 25);  ///< B825
        constexpr uint32_t B826 = (1U << 26);  ///< B826
        constexpr uint32_t B827 = (1U << 27);  ///< B827
        constexpr uint32_t B828 = (1U << 28);  ///< B828
        constexpr uint32_t B829 = (1U << 29);  ///< B829
        constexpr uint32_t B830 = (1U << 30);  ///< B830
        constexpr uint32_t B831 = (1U << 31);  ///< B831
    }

    /// MPCBB1_VCTR26 Register bits
    namespace mpcbb1_vctr26_bits {
        constexpr uint32_t B832 = (1U << 0);  ///< B832
        constexpr uint32_t B833 = (1U << 1);  ///< B833
        constexpr uint32_t B834 = (1U << 2);  ///< B834
        constexpr uint32_t B835 = (1U << 3);  ///< B835
        constexpr uint32_t B836 = (1U << 4);  ///< B836
        constexpr uint32_t B837 = (1U << 5);  ///< B837
        constexpr uint32_t B838 = (1U << 6);  ///< B838
        constexpr uint32_t B839 = (1U << 7);  ///< B839
        constexpr uint32_t B840 = (1U << 8);  ///< B840
        constexpr uint32_t B841 = (1U << 9);  ///< B841
        constexpr uint32_t B842 = (1U << 10);  ///< B842
        constexpr uint32_t B843 = (1U << 11);  ///< B843
        constexpr uint32_t B844 = (1U << 12);  ///< B844
        constexpr uint32_t B845 = (1U << 13);  ///< B845
        constexpr uint32_t B846 = (1U << 14);  ///< B846
        constexpr uint32_t B847 = (1U << 15);  ///< B847
        constexpr uint32_t B848 = (1U << 16);  ///< B848
        constexpr uint32_t B849 = (1U << 17);  ///< B849
        constexpr uint32_t B850 = (1U << 18);  ///< B850
        constexpr uint32_t B851 = (1U << 19);  ///< B851
        constexpr uint32_t B852 = (1U << 20);  ///< B852
        constexpr uint32_t B853 = (1U << 21);  ///< B853
        constexpr uint32_t B854 = (1U << 22);  ///< B854
        constexpr uint32_t B855 = (1U << 23);  ///< B855
        constexpr uint32_t B856 = (1U << 24);  ///< B856
        constexpr uint32_t B857 = (1U << 25);  ///< B857
        constexpr uint32_t B858 = (1U << 26);  ///< B858
        constexpr uint32_t B859 = (1U << 27);  ///< B859
        constexpr uint32_t B860 = (1U << 28);  ///< B860
        constexpr uint32_t B861 = (1U << 29);  ///< B861
        constexpr uint32_t B862 = (1U << 30);  ///< B862
        constexpr uint32_t B863 = (1U << 31);  ///< B863
    }

    /// MPCBB1_VCTR27 Register bits
    namespace mpcbb1_vctr27_bits {
        constexpr uint32_t B864 = (1U << 0);  ///< B864
        constexpr uint32_t B865 = (1U << 1);  ///< B865
        constexpr uint32_t B866 = (1U << 2);  ///< B866
        constexpr uint32_t B867 = (1U << 3);  ///< B867
        constexpr uint32_t B868 = (1U << 4);  ///< B868
        constexpr uint32_t B869 = (1U << 5);  ///< B869
        constexpr uint32_t B870 = (1U << 6);  ///< B870
        constexpr uint32_t B871 = (1U << 7);  ///< B871
        constexpr uint32_t B872 = (1U << 8);  ///< B872
        constexpr uint32_t B873 = (1U << 9);  ///< B873
        constexpr uint32_t B874 = (1U << 10);  ///< B874
        constexpr uint32_t B875 = (1U << 11);  ///< B875
        constexpr uint32_t B876 = (1U << 12);  ///< B876
        constexpr uint32_t B877 = (1U << 13);  ///< B877
        constexpr uint32_t B878 = (1U << 14);  ///< B878
        constexpr uint32_t B879 = (1U << 15);  ///< B879
        constexpr uint32_t B880 = (1U << 16);  ///< B880
        constexpr uint32_t B881 = (1U << 17);  ///< B881
        constexpr uint32_t B882 = (1U << 18);  ///< B882
        constexpr uint32_t B883 = (1U << 19);  ///< B883
        constexpr uint32_t B884 = (1U << 20);  ///< B884
        constexpr uint32_t B885 = (1U << 21);  ///< B885
        constexpr uint32_t B886 = (1U << 22);  ///< B886
        constexpr uint32_t B887 = (1U << 23);  ///< B887
        constexpr uint32_t B888 = (1U << 24);  ///< B888
        constexpr uint32_t B889 = (1U << 25);  ///< B889
        constexpr uint32_t B890 = (1U << 26);  ///< B890
        constexpr uint32_t B891 = (1U << 27);  ///< B891
        constexpr uint32_t B892 = (1U << 28);  ///< B892
        constexpr uint32_t B893 = (1U << 29);  ///< B893
        constexpr uint32_t B894 = (1U << 30);  ///< B894
        constexpr uint32_t B895 = (1U << 31);  ///< B895
    }

    /// MPCBB1_VCTR28 Register bits
    namespace mpcbb1_vctr28_bits {
        constexpr uint32_t B896 = (1U << 0);  ///< B896
        constexpr uint32_t B897 = (1U << 1);  ///< B897
        constexpr uint32_t B898 = (1U << 2);  ///< B898
        constexpr uint32_t B899 = (1U << 3);  ///< B899
        constexpr uint32_t B900 = (1U << 4);  ///< B900
        constexpr uint32_t B901 = (1U << 5);  ///< B901
        constexpr uint32_t B902 = (1U << 6);  ///< B902
        constexpr uint32_t B903 = (1U << 7);  ///< B903
        constexpr uint32_t B904 = (1U << 8);  ///< B904
        constexpr uint32_t B905 = (1U << 9);  ///< B905
        constexpr uint32_t B906 = (1U << 10);  ///< B906
        constexpr uint32_t B907 = (1U << 11);  ///< B907
        constexpr uint32_t B908 = (1U << 12);  ///< B908
        constexpr uint32_t B909 = (1U << 13);  ///< B909
        constexpr uint32_t B910 = (1U << 14);  ///< B910
        constexpr uint32_t B911 = (1U << 15);  ///< B911
        constexpr uint32_t B912 = (1U << 16);  ///< B912
        constexpr uint32_t B913 = (1U << 17);  ///< B913
        constexpr uint32_t B914 = (1U << 18);  ///< B914
        constexpr uint32_t B915 = (1U << 19);  ///< B915
        constexpr uint32_t B916 = (1U << 20);  ///< B916
        constexpr uint32_t B917 = (1U << 21);  ///< B917
        constexpr uint32_t B918 = (1U << 22);  ///< B918
        constexpr uint32_t B919 = (1U << 23);  ///< B919
        constexpr uint32_t B920 = (1U << 24);  ///< B920
        constexpr uint32_t B921 = (1U << 25);  ///< B921
        constexpr uint32_t B922 = (1U << 26);  ///< B922
        constexpr uint32_t B923 = (1U << 27);  ///< B923
        constexpr uint32_t B924 = (1U << 28);  ///< B924
        constexpr uint32_t B925 = (1U << 29);  ///< B925
        constexpr uint32_t B926 = (1U << 30);  ///< B926
        constexpr uint32_t B927 = (1U << 31);  ///< B927
    }

    /// MPCBB1_VCTR29 Register bits
    namespace mpcbb1_vctr29_bits {
        constexpr uint32_t B928 = (1U << 0);  ///< B928
        constexpr uint32_t B929 = (1U << 1);  ///< B929
        constexpr uint32_t B930 = (1U << 2);  ///< B930
        constexpr uint32_t B931 = (1U << 3);  ///< B931
        constexpr uint32_t B932 = (1U << 4);  ///< B932
        constexpr uint32_t B933 = (1U << 5);  ///< B933
        constexpr uint32_t B934 = (1U << 6);  ///< B934
        constexpr uint32_t B935 = (1U << 7);  ///< B935
        constexpr uint32_t B936 = (1U << 8);  ///< B936
        constexpr uint32_t B937 = (1U << 9);  ///< B937
        constexpr uint32_t B938 = (1U << 10);  ///< B938
        constexpr uint32_t B939 = (1U << 11);  ///< B939
        constexpr uint32_t B940 = (1U << 12);  ///< B940
        constexpr uint32_t B941 = (1U << 13);  ///< B941
        constexpr uint32_t B942 = (1U << 14);  ///< B942
        constexpr uint32_t B943 = (1U << 15);  ///< B943
        constexpr uint32_t B944 = (1U << 16);  ///< B944
        constexpr uint32_t B945 = (1U << 17);  ///< B945
        constexpr uint32_t B946 = (1U << 18);  ///< B946
        constexpr uint32_t B947 = (1U << 19);  ///< B947
        constexpr uint32_t B948 = (1U << 20);  ///< B948
        constexpr uint32_t B949 = (1U << 21);  ///< B949
        constexpr uint32_t B950 = (1U << 22);  ///< B950
        constexpr uint32_t B951 = (1U << 23);  ///< B951
        constexpr uint32_t B952 = (1U << 24);  ///< B952
        constexpr uint32_t B953 = (1U << 25);  ///< B953
        constexpr uint32_t B954 = (1U << 26);  ///< B954
        constexpr uint32_t B955 = (1U << 27);  ///< B955
        constexpr uint32_t B956 = (1U << 28);  ///< B956
        constexpr uint32_t B957 = (1U << 29);  ///< B957
        constexpr uint32_t B958 = (1U << 30);  ///< B958
        constexpr uint32_t B959 = (1U << 31);  ///< B959
    }

    /// MPCBB1_VCTR30 Register bits
    namespace mpcbb1_vctr30_bits {
        constexpr uint32_t B960 = (1U << 0);  ///< B960
        constexpr uint32_t B961 = (1U << 1);  ///< B961
        constexpr uint32_t B962 = (1U << 2);  ///< B962
        constexpr uint32_t B963 = (1U << 3);  ///< B963
        constexpr uint32_t B964 = (1U << 4);  ///< B964
        constexpr uint32_t B965 = (1U << 5);  ///< B965
        constexpr uint32_t B966 = (1U << 6);  ///< B966
        constexpr uint32_t B967 = (1U << 7);  ///< B967
        constexpr uint32_t B968 = (1U << 8);  ///< B968
        constexpr uint32_t B969 = (1U << 9);  ///< B969
        constexpr uint32_t B970 = (1U << 10);  ///< B970
        constexpr uint32_t B971 = (1U << 11);  ///< B971
        constexpr uint32_t B972 = (1U << 12);  ///< B972
        constexpr uint32_t B973 = (1U << 13);  ///< B973
        constexpr uint32_t B974 = (1U << 14);  ///< B974
        constexpr uint32_t B975 = (1U << 15);  ///< B975
        constexpr uint32_t B976 = (1U << 16);  ///< B976
        constexpr uint32_t B977 = (1U << 17);  ///< B977
        constexpr uint32_t B978 = (1U << 18);  ///< B978
        constexpr uint32_t B979 = (1U << 19);  ///< B979
        constexpr uint32_t B980 = (1U << 20);  ///< B980
        constexpr uint32_t B981 = (1U << 21);  ///< B981
        constexpr uint32_t B982 = (1U << 22);  ///< B982
        constexpr uint32_t B983 = (1U << 23);  ///< B983
        constexpr uint32_t B984 = (1U << 24);  ///< B984
        constexpr uint32_t B985 = (1U << 25);  ///< B985
        constexpr uint32_t B986 = (1U << 26);  ///< B986
        constexpr uint32_t B987 = (1U << 27);  ///< B987
        constexpr uint32_t B988 = (1U << 28);  ///< B988
        constexpr uint32_t B989 = (1U << 29);  ///< B989
        constexpr uint32_t B990 = (1U << 30);  ///< B990
        constexpr uint32_t B991 = (1U << 31);  ///< B991
    }

    /// MPCBB1_VCTR31 Register bits
    namespace mpcbb1_vctr31_bits {
        constexpr uint32_t B992 = (1U << 0);  ///< B992
        constexpr uint32_t B993 = (1U << 1);  ///< B993
        constexpr uint32_t B994 = (1U << 2);  ///< B994
        constexpr uint32_t B995 = (1U << 3);  ///< B995
        constexpr uint32_t B996 = (1U << 4);  ///< B996
        constexpr uint32_t B997 = (1U << 5);  ///< B997
        constexpr uint32_t B998 = (1U << 6);  ///< B998
        constexpr uint32_t B999 = (1U << 7);  ///< B999
        constexpr uint32_t B1000 = (1U << 8);  ///< B1000
        constexpr uint32_t B1001 = (1U << 9);  ///< B1001
        constexpr uint32_t B1002 = (1U << 10);  ///< B1002
        constexpr uint32_t B1003 = (1U << 11);  ///< B1003
        constexpr uint32_t B1004 = (1U << 12);  ///< B1004
        constexpr uint32_t B1005 = (1U << 13);  ///< B1005
        constexpr uint32_t B1006 = (1U << 14);  ///< B1006
        constexpr uint32_t B1007 = (1U << 15);  ///< B1007
        constexpr uint32_t B1008 = (1U << 16);  ///< B1008
        constexpr uint32_t B1009 = (1U << 17);  ///< B1009
        constexpr uint32_t B1010 = (1U << 18);  ///< B1010
        constexpr uint32_t B1011 = (1U << 19);  ///< B1011
        constexpr uint32_t B1012 = (1U << 20);  ///< B1012
        constexpr uint32_t B1013 = (1U << 21);  ///< B1013
        constexpr uint32_t B1014 = (1U << 22);  ///< B1014
        constexpr uint32_t B1015 = (1U << 23);  ///< B1015
        constexpr uint32_t B1016 = (1U << 24);  ///< B1016
        constexpr uint32_t B1017 = (1U << 25);  ///< B1017
        constexpr uint32_t B1018 = (1U << 26);  ///< B1018
        constexpr uint32_t B1019 = (1U << 27);  ///< B1019
        constexpr uint32_t B1020 = (1U << 28);  ///< B1020
        constexpr uint32_t B1021 = (1U << 29);  ///< B1021
        constexpr uint32_t B1022 = (1U << 30);  ///< B1022
        constexpr uint32_t B1023 = (1U << 31);  ///< B1023
    }

    /// MPCBB1_VCTR32 Register bits
    namespace mpcbb1_vctr32_bits {
        constexpr uint32_t B1024 = (1U << 0);  ///< B1024
        constexpr uint32_t B1025 = (1U << 1);  ///< B1025
        constexpr uint32_t B1026 = (1U << 2);  ///< B1026
        constexpr uint32_t B1027 = (1U << 3);  ///< B1027
        constexpr uint32_t B1028 = (1U << 4);  ///< B1028
        constexpr uint32_t B1029 = (1U << 5);  ///< B1029
        constexpr uint32_t B1030 = (1U << 6);  ///< B1030
        constexpr uint32_t B1031 = (1U << 7);  ///< B1031
        constexpr uint32_t B1032 = (1U << 8);  ///< B1032
        constexpr uint32_t B1033 = (1U << 9);  ///< B1033
        constexpr uint32_t B1034 = (1U << 10);  ///< B1034
        constexpr uint32_t B1035 = (1U << 11);  ///< B1035
        constexpr uint32_t B1036 = (1U << 12);  ///< B1036
        constexpr uint32_t B1037 = (1U << 13);  ///< B1037
        constexpr uint32_t B1038 = (1U << 14);  ///< B1038
        constexpr uint32_t B1039 = (1U << 15);  ///< B1039
        constexpr uint32_t B1040 = (1U << 16);  ///< B1040
        constexpr uint32_t B1041 = (1U << 17);  ///< B1041
        constexpr uint32_t B1042 = (1U << 18);  ///< B1042
        constexpr uint32_t B1043 = (1U << 19);  ///< B1043
        constexpr uint32_t B1044 = (1U << 20);  ///< B1044
        constexpr uint32_t B1045 = (1U << 21);  ///< B1045
        constexpr uint32_t B1046 = (1U << 22);  ///< B1046
        constexpr uint32_t B1047 = (1U << 23);  ///< B1047
        constexpr uint32_t B1048 = (1U << 24);  ///< B1048
        constexpr uint32_t B1049 = (1U << 25);  ///< B1049
        constexpr uint32_t B1050 = (1U << 26);  ///< B1050
        constexpr uint32_t B1051 = (1U << 27);  ///< B1051
        constexpr uint32_t B1052 = (1U << 28);  ///< B1052
        constexpr uint32_t B1053 = (1U << 29);  ///< B1053
        constexpr uint32_t B1054 = (1U << 30);  ///< B1054
        constexpr uint32_t B1055 = (1U << 31);  ///< B1055
    }

    /// MPCBB1_VCTR33 Register bits
    namespace mpcbb1_vctr33_bits {
        constexpr uint32_t B1056 = (1U << 0);  ///< B1056
        constexpr uint32_t B1057 = (1U << 1);  ///< B1057
        constexpr uint32_t B1058 = (1U << 2);  ///< B1058
        constexpr uint32_t B1059 = (1U << 3);  ///< B1059
        constexpr uint32_t B1060 = (1U << 4);  ///< B1060
        constexpr uint32_t B1061 = (1U << 5);  ///< B1061
        constexpr uint32_t B1062 = (1U << 6);  ///< B1062
        constexpr uint32_t B1063 = (1U << 7);  ///< B1063
        constexpr uint32_t B1064 = (1U << 8);  ///< B1064
        constexpr uint32_t B1065 = (1U << 9);  ///< B1065
        constexpr uint32_t B1066 = (1U << 10);  ///< B1066
        constexpr uint32_t B1067 = (1U << 11);  ///< B1067
        constexpr uint32_t B1068 = (1U << 12);  ///< B1068
        constexpr uint32_t B1069 = (1U << 13);  ///< B1069
        constexpr uint32_t B1070 = (1U << 14);  ///< B1070
        constexpr uint32_t B1071 = (1U << 15);  ///< B1071
        constexpr uint32_t B1072 = (1U << 16);  ///< B1072
        constexpr uint32_t B1073 = (1U << 17);  ///< B1073
        constexpr uint32_t B1074 = (1U << 18);  ///< B1074
        constexpr uint32_t B1075 = (1U << 19);  ///< B1075
        constexpr uint32_t B1076 = (1U << 20);  ///< B1076
        constexpr uint32_t B1077 = (1U << 21);  ///< B1077
        constexpr uint32_t B1078 = (1U << 22);  ///< B1078
        constexpr uint32_t B1079 = (1U << 23);  ///< B1079
        constexpr uint32_t B1080 = (1U << 24);  ///< B1080
        constexpr uint32_t B1081 = (1U << 25);  ///< B1081
        constexpr uint32_t B1082 = (1U << 26);  ///< B1082
        constexpr uint32_t B1083 = (1U << 27);  ///< B1083
        constexpr uint32_t B1084 = (1U << 28);  ///< B1084
        constexpr uint32_t B1085 = (1U << 29);  ///< B1085
        constexpr uint32_t B1086 = (1U << 30);  ///< B1086
        constexpr uint32_t B1087 = (1U << 31);  ///< B1087
    }

    /// MPCBB1_VCTR34 Register bits
    namespace mpcbb1_vctr34_bits {
        constexpr uint32_t B1088 = (1U << 0);  ///< B1088
        constexpr uint32_t B1089 = (1U << 1);  ///< B1089
        constexpr uint32_t B1090 = (1U << 2);  ///< B1090
        constexpr uint32_t B1091 = (1U << 3);  ///< B1091
        constexpr uint32_t B1092 = (1U << 4);  ///< B1092
        constexpr uint32_t B1093 = (1U << 5);  ///< B1093
        constexpr uint32_t B1094 = (1U << 6);  ///< B1094
        constexpr uint32_t B1095 = (1U << 7);  ///< B1095
        constexpr uint32_t B1096 = (1U << 8);  ///< B1096
        constexpr uint32_t B1097 = (1U << 9);  ///< B1097
        constexpr uint32_t B1098 = (1U << 10);  ///< B1098
        constexpr uint32_t B1099 = (1U << 11);  ///< B1099
        constexpr uint32_t B1100 = (1U << 12);  ///< B1100
        constexpr uint32_t B1101 = (1U << 13);  ///< B1101
        constexpr uint32_t B1102 = (1U << 14);  ///< B1102
        constexpr uint32_t B1103 = (1U << 15);  ///< B1103
        constexpr uint32_t B1104 = (1U << 16);  ///< B1104
        constexpr uint32_t B1105 = (1U << 17);  ///< B1105
        constexpr uint32_t B1106 = (1U << 18);  ///< B1106
        constexpr uint32_t B1107 = (1U << 19);  ///< B1107
        constexpr uint32_t B1108 = (1U << 20);  ///< B1108
        constexpr uint32_t B1109 = (1U << 21);  ///< B1109
        constexpr uint32_t B1110 = (1U << 22);  ///< B1110
        constexpr uint32_t B1111 = (1U << 23);  ///< B1111
        constexpr uint32_t B1112 = (1U << 24);  ///< B1112
        constexpr uint32_t B1113 = (1U << 25);  ///< B1113
        constexpr uint32_t B1114 = (1U << 26);  ///< B1114
        constexpr uint32_t B1115 = (1U << 27);  ///< B1115
        constexpr uint32_t B1116 = (1U << 28);  ///< B1116
        constexpr uint32_t B1117 = (1U << 29);  ///< B1117
        constexpr uint32_t B1118 = (1U << 30);  ///< B1118
        constexpr uint32_t B1119 = (1U << 31);  ///< B1119
    }

    /// MPCBB1_VCTR35 Register bits
    namespace mpcbb1_vctr35_bits {
        constexpr uint32_t B1120 = (1U << 0);  ///< B1120
        constexpr uint32_t B1121 = (1U << 1);  ///< B1121
        constexpr uint32_t B1122 = (1U << 2);  ///< B1122
        constexpr uint32_t B1123 = (1U << 3);  ///< B1123
        constexpr uint32_t B1124 = (1U << 4);  ///< B1124
        constexpr uint32_t B1125 = (1U << 5);  ///< B1125
        constexpr uint32_t B1126 = (1U << 6);  ///< B1126
        constexpr uint32_t B1127 = (1U << 7);  ///< B1127
        constexpr uint32_t B1128 = (1U << 8);  ///< B1128
        constexpr uint32_t B1129 = (1U << 9);  ///< B1129
        constexpr uint32_t B1130 = (1U << 10);  ///< B1130
        constexpr uint32_t B1131 = (1U << 11);  ///< B1131
        constexpr uint32_t B1132 = (1U << 12);  ///< B1132
        constexpr uint32_t B1133 = (1U << 13);  ///< B1133
        constexpr uint32_t B1134 = (1U << 14);  ///< B1134
        constexpr uint32_t B1135 = (1U << 15);  ///< B1135
        constexpr uint32_t B1136 = (1U << 16);  ///< B1136
        constexpr uint32_t B1137 = (1U << 17);  ///< B1137
        constexpr uint32_t B1138 = (1U << 18);  ///< B1138
        constexpr uint32_t B1139 = (1U << 19);  ///< B1139
        constexpr uint32_t B1140 = (1U << 20);  ///< B1140
        constexpr uint32_t B1141 = (1U << 21);  ///< B1141
        constexpr uint32_t B1142 = (1U << 22);  ///< B1142
        constexpr uint32_t B1143 = (1U << 23);  ///< B1143
        constexpr uint32_t B1144 = (1U << 24);  ///< B1144
        constexpr uint32_t B1145 = (1U << 25);  ///< B1145
        constexpr uint32_t B1146 = (1U << 26);  ///< B1146
        constexpr uint32_t B1147 = (1U << 27);  ///< B1147
        constexpr uint32_t B1148 = (1U << 28);  ///< B1148
        constexpr uint32_t B1149 = (1U << 29);  ///< B1149
        constexpr uint32_t B1150 = (1U << 30);  ///< B1150
        constexpr uint32_t B1151 = (1U << 31);  ///< B1151
    }

    /// MPCBB1_VCTR36 Register bits
    namespace mpcbb1_vctr36_bits {
        constexpr uint32_t B1152 = (1U << 0);  ///< B1152
        constexpr uint32_t B1153 = (1U << 1);  ///< B1153
        constexpr uint32_t B1154 = (1U << 2);  ///< B1154
        constexpr uint32_t B1155 = (1U << 3);  ///< B1155
        constexpr uint32_t B1156 = (1U << 4);  ///< B1156
        constexpr uint32_t B1157 = (1U << 5);  ///< B1157
        constexpr uint32_t B1158 = (1U << 6);  ///< B1158
        constexpr uint32_t B1159 = (1U << 7);  ///< B1159
        constexpr uint32_t B1160 = (1U << 8);  ///< B1160
        constexpr uint32_t B1161 = (1U << 9);  ///< B1161
        constexpr uint32_t B1162 = (1U << 10);  ///< B1162
        constexpr uint32_t B1163 = (1U << 11);  ///< B1163
        constexpr uint32_t B1164 = (1U << 12);  ///< B1164
        constexpr uint32_t B1165 = (1U << 13);  ///< B1165
        constexpr uint32_t B1166 = (1U << 14);  ///< B1166
        constexpr uint32_t B1167 = (1U << 15);  ///< B1167
        constexpr uint32_t B1168 = (1U << 16);  ///< B1168
        constexpr uint32_t B1169 = (1U << 17);  ///< B1169
        constexpr uint32_t B1170 = (1U << 18);  ///< B1170
        constexpr uint32_t B1171 = (1U << 19);  ///< B1171
        constexpr uint32_t B1172 = (1U << 20);  ///< B1172
        constexpr uint32_t B1173 = (1U << 21);  ///< B1173
        constexpr uint32_t B1174 = (1U << 22);  ///< B1174
        constexpr uint32_t B1175 = (1U << 23);  ///< B1175
        constexpr uint32_t B1176 = (1U << 24);  ///< B1176
        constexpr uint32_t B1177 = (1U << 25);  ///< B1177
        constexpr uint32_t B1178 = (1U << 26);  ///< B1178
        constexpr uint32_t B1179 = (1U << 27);  ///< B1179
        constexpr uint32_t B1180 = (1U << 28);  ///< B1180
        constexpr uint32_t B1181 = (1U << 29);  ///< B1181
        constexpr uint32_t B1182 = (1U << 30);  ///< B1182
        constexpr uint32_t B1183 = (1U << 31);  ///< B1183
    }

    /// MPCBB1_VCTR37 Register bits
    namespace mpcbb1_vctr37_bits {
        constexpr uint32_t B1184 = (1U << 0);  ///< B1184
        constexpr uint32_t B1185 = (1U << 1);  ///< B1185
        constexpr uint32_t B1186 = (1U << 2);  ///< B1186
        constexpr uint32_t B1187 = (1U << 3);  ///< B1187
        constexpr uint32_t B1188 = (1U << 4);  ///< B1188
        constexpr uint32_t B1189 = (1U << 5);  ///< B1189
        constexpr uint32_t B1190 = (1U << 6);  ///< B1190
        constexpr uint32_t B1191 = (1U << 7);  ///< B1191
        constexpr uint32_t B1192 = (1U << 8);  ///< B1192
        constexpr uint32_t B1193 = (1U << 9);  ///< B1193
        constexpr uint32_t B1194 = (1U << 10);  ///< B1194
        constexpr uint32_t B1195 = (1U << 11);  ///< B1195
        constexpr uint32_t B1196 = (1U << 12);  ///< B1196
        constexpr uint32_t B1197 = (1U << 13);  ///< B1197
        constexpr uint32_t B1198 = (1U << 14);  ///< B1198
        constexpr uint32_t B1199 = (1U << 15);  ///< B1199
        constexpr uint32_t B1200 = (1U << 16);  ///< B1200
        constexpr uint32_t B1201 = (1U << 17);  ///< B1201
        constexpr uint32_t B1202 = (1U << 18);  ///< B1202
        constexpr uint32_t B1203 = (1U << 19);  ///< B1203
        constexpr uint32_t B1204 = (1U << 20);  ///< B1204
        constexpr uint32_t B1205 = (1U << 21);  ///< B1205
        constexpr uint32_t B1206 = (1U << 22);  ///< B1206
        constexpr uint32_t B1207 = (1U << 23);  ///< B1207
        constexpr uint32_t B1208 = (1U << 24);  ///< B1208
        constexpr uint32_t B1209 = (1U << 25);  ///< B1209
        constexpr uint32_t B1210 = (1U << 26);  ///< B1210
        constexpr uint32_t B1211 = (1U << 27);  ///< B1211
        constexpr uint32_t B1212 = (1U << 28);  ///< B1212
        constexpr uint32_t B1213 = (1U << 29);  ///< B1213
        constexpr uint32_t B1214 = (1U << 30);  ///< B1214
        constexpr uint32_t B1215 = (1U << 31);  ///< B1215
    }

    /// MPCBB1_VCTR38 Register bits
    namespace mpcbb1_vctr38_bits {
        constexpr uint32_t B1216 = (1U << 0);  ///< B1216
        constexpr uint32_t B1217 = (1U << 1);  ///< B1217
        constexpr uint32_t B1218 = (1U << 2);  ///< B1218
        constexpr uint32_t B1219 = (1U << 3);  ///< B1219
        constexpr uint32_t B1220 = (1U << 4);  ///< B1220
        constexpr uint32_t B1221 = (1U << 5);  ///< B1221
        constexpr uint32_t B1222 = (1U << 6);  ///< B1222
        constexpr uint32_t B1223 = (1U << 7);  ///< B1223
        constexpr uint32_t B1224 = (1U << 8);  ///< B1224
        constexpr uint32_t B1225 = (1U << 9);  ///< B1225
        constexpr uint32_t B1226 = (1U << 10);  ///< B1226
        constexpr uint32_t B1227 = (1U << 11);  ///< B1227
        constexpr uint32_t B1228 = (1U << 12);  ///< B1228
        constexpr uint32_t B1229 = (1U << 13);  ///< B1229
        constexpr uint32_t B1230 = (1U << 14);  ///< B1230
        constexpr uint32_t B1231 = (1U << 15);  ///< B1231
        constexpr uint32_t B1232 = (1U << 16);  ///< B1232
        constexpr uint32_t B1233 = (1U << 17);  ///< B1233
        constexpr uint32_t B1234 = (1U << 18);  ///< B1234
        constexpr uint32_t B1235 = (1U << 19);  ///< B1235
        constexpr uint32_t B1236 = (1U << 20);  ///< B1236
        constexpr uint32_t B1237 = (1U << 21);  ///< B1237
        constexpr uint32_t B1238 = (1U << 22);  ///< B1238
        constexpr uint32_t B1239 = (1U << 23);  ///< B1239
        constexpr uint32_t B1240 = (1U << 24);  ///< B1240
        constexpr uint32_t B1241 = (1U << 25);  ///< B1241
        constexpr uint32_t B1242 = (1U << 26);  ///< B1242
        constexpr uint32_t B1243 = (1U << 27);  ///< B1243
        constexpr uint32_t B1244 = (1U << 28);  ///< B1244
        constexpr uint32_t B1245 = (1U << 29);  ///< B1245
        constexpr uint32_t B1246 = (1U << 30);  ///< B1246
        constexpr uint32_t B1247 = (1U << 31);  ///< B1247
    }

    /// MPCBB1_VCTR39 Register bits
    namespace mpcbb1_vctr39_bits {
        constexpr uint32_t B1248 = (1U << 0);  ///< B1248
        constexpr uint32_t B1249 = (1U << 1);  ///< B1249
        constexpr uint32_t B1250 = (1U << 2);  ///< B1250
        constexpr uint32_t B1251 = (1U << 3);  ///< B1251
        constexpr uint32_t B1252 = (1U << 4);  ///< B1252
        constexpr uint32_t B1253 = (1U << 5);  ///< B1253
        constexpr uint32_t B1254 = (1U << 6);  ///< B1254
        constexpr uint32_t B1255 = (1U << 7);  ///< B1255
        constexpr uint32_t B1256 = (1U << 8);  ///< B1256
        constexpr uint32_t B1257 = (1U << 9);  ///< B1257
        constexpr uint32_t B1258 = (1U << 10);  ///< B1258
        constexpr uint32_t B1259 = (1U << 11);  ///< B1259
        constexpr uint32_t B1260 = (1U << 12);  ///< B1260
        constexpr uint32_t B1261 = (1U << 13);  ///< B1261
        constexpr uint32_t B1262 = (1U << 14);  ///< B1262
        constexpr uint32_t B1263 = (1U << 15);  ///< B1263
        constexpr uint32_t B1264 = (1U << 16);  ///< B1264
        constexpr uint32_t B1265 = (1U << 17);  ///< B1265
        constexpr uint32_t B1266 = (1U << 18);  ///< B1266
        constexpr uint32_t B1267 = (1U << 19);  ///< B1267
        constexpr uint32_t B1268 = (1U << 20);  ///< B1268
        constexpr uint32_t B1269 = (1U << 21);  ///< B1269
        constexpr uint32_t B1270 = (1U << 22);  ///< B1270
        constexpr uint32_t B1271 = (1U << 23);  ///< B1271
        constexpr uint32_t B1272 = (1U << 24);  ///< B1272
        constexpr uint32_t B1273 = (1U << 25);  ///< B1273
        constexpr uint32_t B1274 = (1U << 26);  ///< B1274
        constexpr uint32_t B1275 = (1U << 27);  ///< B1275
        constexpr uint32_t B1276 = (1U << 28);  ///< B1276
        constexpr uint32_t B1277 = (1U << 29);  ///< B1277
        constexpr uint32_t B1278 = (1U << 30);  ///< B1278
        constexpr uint32_t B1279 = (1U << 31);  ///< B1279
    }

    /// MPCBB1_VCTR40 Register bits
    namespace mpcbb1_vctr40_bits {
        constexpr uint32_t B1280 = (1U << 0);  ///< B1280
        constexpr uint32_t B1281 = (1U << 1);  ///< B1281
        constexpr uint32_t B1282 = (1U << 2);  ///< B1282
        constexpr uint32_t B1283 = (1U << 3);  ///< B1283
        constexpr uint32_t B1284 = (1U << 4);  ///< B1284
        constexpr uint32_t B1285 = (1U << 5);  ///< B1285
        constexpr uint32_t B1286 = (1U << 6);  ///< B1286
        constexpr uint32_t B1287 = (1U << 7);  ///< B1287
        constexpr uint32_t B1288 = (1U << 8);  ///< B1288
        constexpr uint32_t B1289 = (1U << 9);  ///< B1289
        constexpr uint32_t B1290 = (1U << 10);  ///< B1290
        constexpr uint32_t B1291 = (1U << 11);  ///< B1291
        constexpr uint32_t B1292 = (1U << 12);  ///< B1292
        constexpr uint32_t B1293 = (1U << 13);  ///< B1293
        constexpr uint32_t B1294 = (1U << 14);  ///< B1294
        constexpr uint32_t B1295 = (1U << 15);  ///< B1295
        constexpr uint32_t B1296 = (1U << 16);  ///< B1296
        constexpr uint32_t B1297 = (1U << 17);  ///< B1297
        constexpr uint32_t B1298 = (1U << 18);  ///< B1298
        constexpr uint32_t B1299 = (1U << 19);  ///< B1299
        constexpr uint32_t B1300 = (1U << 20);  ///< B1300
        constexpr uint32_t B1301 = (1U << 21);  ///< B1301
        constexpr uint32_t B1302 = (1U << 22);  ///< B1302
        constexpr uint32_t B1303 = (1U << 23);  ///< B1303
        constexpr uint32_t B1304 = (1U << 24);  ///< B1304
        constexpr uint32_t B1305 = (1U << 25);  ///< B1305
        constexpr uint32_t B1306 = (1U << 26);  ///< B1306
        constexpr uint32_t B1307 = (1U << 27);  ///< B1307
        constexpr uint32_t B1308 = (1U << 28);  ///< B1308
        constexpr uint32_t B1309 = (1U << 29);  ///< B1309
        constexpr uint32_t B1310 = (1U << 30);  ///< B1310
        constexpr uint32_t B1311 = (1U << 31);  ///< B1311
    }

    /// MPCBB1_VCTR41 Register bits
    namespace mpcbb1_vctr41_bits {
        constexpr uint32_t B1312 = (1U << 0);  ///< B1312
        constexpr uint32_t B1313 = (1U << 1);  ///< B1313
        constexpr uint32_t B1314 = (1U << 2);  ///< B1314
        constexpr uint32_t B1315 = (1U << 3);  ///< B1315
        constexpr uint32_t B1316 = (1U << 4);  ///< B1316
        constexpr uint32_t B1317 = (1U << 5);  ///< B1317
        constexpr uint32_t B1318 = (1U << 6);  ///< B1318
        constexpr uint32_t B1319 = (1U << 7);  ///< B1319
        constexpr uint32_t B1320 = (1U << 8);  ///< B1320
        constexpr uint32_t B1321 = (1U << 9);  ///< B1321
        constexpr uint32_t B1322 = (1U << 10);  ///< B1322
        constexpr uint32_t B1323 = (1U << 11);  ///< B1323
        constexpr uint32_t B1324 = (1U << 12);  ///< B1324
        constexpr uint32_t B1325 = (1U << 13);  ///< B1325
        constexpr uint32_t B1326 = (1U << 14);  ///< B1326
        constexpr uint32_t B1327 = (1U << 15);  ///< B1327
        constexpr uint32_t B1328 = (1U << 16);  ///< B1328
        constexpr uint32_t B1329 = (1U << 17);  ///< B1329
        constexpr uint32_t B1330 = (1U << 18);  ///< B1330
        constexpr uint32_t B1331 = (1U << 19);  ///< B1331
        constexpr uint32_t B1332 = (1U << 20);  ///< B1332
        constexpr uint32_t B1333 = (1U << 21);  ///< B1333
        constexpr uint32_t B1334 = (1U << 22);  ///< B1334
        constexpr uint32_t B1335 = (1U << 23);  ///< B1335
        constexpr uint32_t B1336 = (1U << 24);  ///< B1336
        constexpr uint32_t B1337 = (1U << 25);  ///< B1337
        constexpr uint32_t B1338 = (1U << 26);  ///< B1338
        constexpr uint32_t B1339 = (1U << 27);  ///< B1339
        constexpr uint32_t B1340 = (1U << 28);  ///< B1340
        constexpr uint32_t B1341 = (1U << 29);  ///< B1341
        constexpr uint32_t B1342 = (1U << 30);  ///< B1342
        constexpr uint32_t B1343 = (1U << 31);  ///< B1343
    }

    /// MPCBB1_VCTR42 Register bits
    namespace mpcbb1_vctr42_bits {
        constexpr uint32_t B1344 = (1U << 0);  ///< B1344
        constexpr uint32_t B1345 = (1U << 1);  ///< B1345
        constexpr uint32_t B1346 = (1U << 2);  ///< B1346
        constexpr uint32_t B1347 = (1U << 3);  ///< B1347
        constexpr uint32_t B1348 = (1U << 4);  ///< B1348
        constexpr uint32_t B1349 = (1U << 5);  ///< B1349
        constexpr uint32_t B1350 = (1U << 6);  ///< B1350
        constexpr uint32_t B1351 = (1U << 7);  ///< B1351
        constexpr uint32_t B1352 = (1U << 8);  ///< B1352
        constexpr uint32_t B1353 = (1U << 9);  ///< B1353
        constexpr uint32_t B1354 = (1U << 10);  ///< B1354
        constexpr uint32_t B1355 = (1U << 11);  ///< B1355
        constexpr uint32_t B1356 = (1U << 12);  ///< B1356
        constexpr uint32_t B1357 = (1U << 13);  ///< B1357
        constexpr uint32_t B1358 = (1U << 14);  ///< B1358
        constexpr uint32_t B1359 = (1U << 15);  ///< B1359
        constexpr uint32_t B1360 = (1U << 16);  ///< B1360
        constexpr uint32_t B1361 = (1U << 17);  ///< B1361
        constexpr uint32_t B1362 = (1U << 18);  ///< B1362
        constexpr uint32_t B1363 = (1U << 19);  ///< B1363
        constexpr uint32_t B1364 = (1U << 20);  ///< B1364
        constexpr uint32_t B1365 = (1U << 21);  ///< B1365
        constexpr uint32_t B1366 = (1U << 22);  ///< B1366
        constexpr uint32_t B1367 = (1U << 23);  ///< B1367
        constexpr uint32_t B1368 = (1U << 24);  ///< B1368
        constexpr uint32_t B1369 = (1U << 25);  ///< B1369
        constexpr uint32_t B1370 = (1U << 26);  ///< B1370
        constexpr uint32_t B1371 = (1U << 27);  ///< B1371
        constexpr uint32_t B1372 = (1U << 28);  ///< B1372
        constexpr uint32_t B1373 = (1U << 29);  ///< B1373
        constexpr uint32_t B1374 = (1U << 30);  ///< B1374
        constexpr uint32_t B1375 = (1U << 31);  ///< B1375
    }

    /// MPCBB1_VCTR43 Register bits
    namespace mpcbb1_vctr43_bits {
        constexpr uint32_t B1376 = (1U << 0);  ///< B1376
        constexpr uint32_t B1377 = (1U << 1);  ///< B1377
        constexpr uint32_t B1378 = (1U << 2);  ///< B1378
        constexpr uint32_t B1379 = (1U << 3);  ///< B1379
        constexpr uint32_t B1380 = (1U << 4);  ///< B1380
        constexpr uint32_t B1381 = (1U << 5);  ///< B1381
        constexpr uint32_t B1382 = (1U << 6);  ///< B1382
        constexpr uint32_t B1383 = (1U << 7);  ///< B1383
        constexpr uint32_t B1384 = (1U << 8);  ///< B1384
        constexpr uint32_t B1385 = (1U << 9);  ///< B1385
        constexpr uint32_t B1386 = (1U << 10);  ///< B1386
        constexpr uint32_t B1387 = (1U << 11);  ///< B1387
        constexpr uint32_t B1388 = (1U << 12);  ///< B1388
        constexpr uint32_t B1389 = (1U << 13);  ///< B1389
        constexpr uint32_t B1390 = (1U << 14);  ///< B1390
        constexpr uint32_t B1391 = (1U << 15);  ///< B1391
        constexpr uint32_t B1392 = (1U << 16);  ///< B1392
        constexpr uint32_t B1393 = (1U << 17);  ///< B1393
        constexpr uint32_t B1394 = (1U << 18);  ///< B1394
        constexpr uint32_t B1395 = (1U << 19);  ///< B1395
        constexpr uint32_t B1396 = (1U << 20);  ///< B1396
        constexpr uint32_t B1397 = (1U << 21);  ///< B1397
        constexpr uint32_t B1398 = (1U << 22);  ///< B1398
        constexpr uint32_t B1399 = (1U << 23);  ///< B1399
        constexpr uint32_t B1400 = (1U << 24);  ///< B1400
        constexpr uint32_t B1401 = (1U << 25);  ///< B1401
        constexpr uint32_t B1402 = (1U << 26);  ///< B1402
        constexpr uint32_t B1403 = (1U << 27);  ///< B1403
        constexpr uint32_t B1404 = (1U << 28);  ///< B1404
        constexpr uint32_t B1405 = (1U << 29);  ///< B1405
        constexpr uint32_t B1406 = (1U << 30);  ///< B1406
        constexpr uint32_t B1407 = (1U << 31);  ///< B1407
    }

    /// MPCBB1_VCTR44 Register bits
    namespace mpcbb1_vctr44_bits {
        constexpr uint32_t B1408 = (1U << 0);  ///< B1408
        constexpr uint32_t B1409 = (1U << 1);  ///< B1409
        constexpr uint32_t B1410 = (1U << 2);  ///< B1410
        constexpr uint32_t B1411 = (1U << 3);  ///< B1411
        constexpr uint32_t B1412 = (1U << 4);  ///< B1412
        constexpr uint32_t B1413 = (1U << 5);  ///< B1413
        constexpr uint32_t B1414 = (1U << 6);  ///< B1414
        constexpr uint32_t B1415 = (1U << 7);  ///< B1415
        constexpr uint32_t B1416 = (1U << 8);  ///< B1416
        constexpr uint32_t B1417 = (1U << 9);  ///< B1417
        constexpr uint32_t B1418 = (1U << 10);  ///< B1418
        constexpr uint32_t B1419 = (1U << 11);  ///< B1419
        constexpr uint32_t B1420 = (1U << 12);  ///< B1420
        constexpr uint32_t B1421 = (1U << 13);  ///< B1421
        constexpr uint32_t B1422 = (1U << 14);  ///< B1422
        constexpr uint32_t B1423 = (1U << 15);  ///< B1423
        constexpr uint32_t B1424 = (1U << 16);  ///< B1424
        constexpr uint32_t B1425 = (1U << 17);  ///< B1425
        constexpr uint32_t B1426 = (1U << 18);  ///< B1426
        constexpr uint32_t B1427 = (1U << 19);  ///< B1427
        constexpr uint32_t B1428 = (1U << 20);  ///< B1428
        constexpr uint32_t B1429 = (1U << 21);  ///< B1429
        constexpr uint32_t B1430 = (1U << 22);  ///< B1430
        constexpr uint32_t B1431 = (1U << 23);  ///< B1431
        constexpr uint32_t B1432 = (1U << 24);  ///< B1432
        constexpr uint32_t B1433 = (1U << 25);  ///< B1433
        constexpr uint32_t B1434 = (1U << 26);  ///< B1434
        constexpr uint32_t B1435 = (1U << 27);  ///< B1435
        constexpr uint32_t B1436 = (1U << 28);  ///< B1436
        constexpr uint32_t B1437 = (1U << 29);  ///< B1437
        constexpr uint32_t B1438 = (1U << 30);  ///< B1438
        constexpr uint32_t B1439 = (1U << 31);  ///< B1439
    }

    /// MPCBB1_VCTR45 Register bits
    namespace mpcbb1_vctr45_bits {
        constexpr uint32_t B1440 = (1U << 0);  ///< B1440
        constexpr uint32_t B1441 = (1U << 1);  ///< B1441
        constexpr uint32_t B1442 = (1U << 2);  ///< B1442
        constexpr uint32_t B1443 = (1U << 3);  ///< B1443
        constexpr uint32_t B1444 = (1U << 4);  ///< B1444
        constexpr uint32_t B1445 = (1U << 5);  ///< B1445
        constexpr uint32_t B1446 = (1U << 6);  ///< B1446
        constexpr uint32_t B1447 = (1U << 7);  ///< B1447
        constexpr uint32_t B1448 = (1U << 8);  ///< B1448
        constexpr uint32_t B1449 = (1U << 9);  ///< B1449
        constexpr uint32_t B1450 = (1U << 10);  ///< B1450
        constexpr uint32_t B1451 = (1U << 11);  ///< B1451
        constexpr uint32_t B1452 = (1U << 12);  ///< B1452
        constexpr uint32_t B1453 = (1U << 13);  ///< B1453
        constexpr uint32_t B1454 = (1U << 14);  ///< B1454
        constexpr uint32_t B1455 = (1U << 15);  ///< B1455
        constexpr uint32_t B1456 = (1U << 16);  ///< B1456
        constexpr uint32_t B1457 = (1U << 17);  ///< B1457
        constexpr uint32_t B1458 = (1U << 18);  ///< B1458
        constexpr uint32_t B1459 = (1U << 19);  ///< B1459
        constexpr uint32_t B1460 = (1U << 20);  ///< B1460
        constexpr uint32_t B1461 = (1U << 21);  ///< B1461
        constexpr uint32_t B1462 = (1U << 22);  ///< B1462
        constexpr uint32_t B1463 = (1U << 23);  ///< B1463
        constexpr uint32_t B1464 = (1U << 24);  ///< B1464
        constexpr uint32_t B1465 = (1U << 25);  ///< B1465
        constexpr uint32_t B1466 = (1U << 26);  ///< B1466
        constexpr uint32_t B1467 = (1U << 27);  ///< B1467
        constexpr uint32_t B1468 = (1U << 28);  ///< B1468
        constexpr uint32_t B1469 = (1U << 29);  ///< B1469
        constexpr uint32_t B1470 = (1U << 30);  ///< B1470
        constexpr uint32_t B1471 = (1U << 31);  ///< B1471
    }

    /// MPCBB1_VCTR46 Register bits
    namespace mpcbb1_vctr46_bits {
        constexpr uint32_t B1472 = (1U << 0);  ///< B1472
        constexpr uint32_t B1473 = (1U << 1);  ///< B1473
        constexpr uint32_t B1474 = (1U << 2);  ///< B1474
        constexpr uint32_t B1475 = (1U << 3);  ///< B1475
        constexpr uint32_t B1476 = (1U << 4);  ///< B1476
        constexpr uint32_t B1477 = (1U << 5);  ///< B1477
        constexpr uint32_t B1478 = (1U << 6);  ///< B1478
        constexpr uint32_t B1479 = (1U << 7);  ///< B1479
        constexpr uint32_t B1480 = (1U << 8);  ///< B1480
        constexpr uint32_t B1481 = (1U << 9);  ///< B1481
        constexpr uint32_t B1482 = (1U << 10);  ///< B1482
        constexpr uint32_t B1483 = (1U << 11);  ///< B1483
        constexpr uint32_t B1484 = (1U << 12);  ///< B1484
        constexpr uint32_t B1485 = (1U << 13);  ///< B1485
        constexpr uint32_t B1486 = (1U << 14);  ///< B1486
        constexpr uint32_t B1487 = (1U << 15);  ///< B1487
        constexpr uint32_t B1488 = (1U << 16);  ///< B1488
        constexpr uint32_t B1489 = (1U << 17);  ///< B1489
        constexpr uint32_t B1490 = (1U << 18);  ///< B1490
        constexpr uint32_t B1491 = (1U << 19);  ///< B1491
        constexpr uint32_t B1492 = (1U << 20);  ///< B1492
        constexpr uint32_t B1493 = (1U << 21);  ///< B1493
        constexpr uint32_t B1494 = (1U << 22);  ///< B1494
        constexpr uint32_t B1495 = (1U << 23);  ///< B1495
        constexpr uint32_t B1496 = (1U << 24);  ///< B1496
        constexpr uint32_t B1497 = (1U << 25);  ///< B1497
        constexpr uint32_t B1498 = (1U << 26);  ///< B1498
        constexpr uint32_t B1499 = (1U << 27);  ///< B1499
        constexpr uint32_t B1500 = (1U << 28);  ///< B1500
        constexpr uint32_t B1501 = (1U << 29);  ///< B1501
        constexpr uint32_t B1502 = (1U << 30);  ///< B1502
        constexpr uint32_t B1503 = (1U << 31);  ///< B1503
    }

    /// MPCBB1_VCTR47 Register bits
    namespace mpcbb1_vctr47_bits {
        constexpr uint32_t B1504 = (1U << 0);  ///< B1504
        constexpr uint32_t B1505 = (1U << 1);  ///< B1505
        constexpr uint32_t B1506 = (1U << 2);  ///< B1506
        constexpr uint32_t B1507 = (1U << 3);  ///< B1507
        constexpr uint32_t B1508 = (1U << 4);  ///< B1508
        constexpr uint32_t B1509 = (1U << 5);  ///< B1509
        constexpr uint32_t B1510 = (1U << 6);  ///< B1510
        constexpr uint32_t B1511 = (1U << 7);  ///< B1511
        constexpr uint32_t B1512 = (1U << 8);  ///< B1512
        constexpr uint32_t B1513 = (1U << 9);  ///< B1513
        constexpr uint32_t B1514 = (1U << 10);  ///< B1514
        constexpr uint32_t B1515 = (1U << 11);  ///< B1515
        constexpr uint32_t B1516 = (1U << 12);  ///< B1516
        constexpr uint32_t B1517 = (1U << 13);  ///< B1517
        constexpr uint32_t B1518 = (1U << 14);  ///< B1518
        constexpr uint32_t B1519 = (1U << 15);  ///< B1519
        constexpr uint32_t B1520 = (1U << 16);  ///< B1520
        constexpr uint32_t B1521 = (1U << 17);  ///< B1521
        constexpr uint32_t B1522 = (1U << 18);  ///< B1522
        constexpr uint32_t B1523 = (1U << 19);  ///< B1523
        constexpr uint32_t B1524 = (1U << 20);  ///< B1524
        constexpr uint32_t B1525 = (1U << 21);  ///< B1525
        constexpr uint32_t B1526 = (1U << 22);  ///< B1526
        constexpr uint32_t B1527 = (1U << 23);  ///< B1527
        constexpr uint32_t B1528 = (1U << 24);  ///< B1528
        constexpr uint32_t B1529 = (1U << 25);  ///< B1529
        constexpr uint32_t B1530 = (1U << 26);  ///< B1530
        constexpr uint32_t B1531 = (1U << 27);  ///< B1531
        constexpr uint32_t B1532 = (1U << 28);  ///< B1532
        constexpr uint32_t B1533 = (1U << 29);  ///< B1533
        constexpr uint32_t B1534 = (1U << 30);  ///< B1534
        constexpr uint32_t B1535 = (1U << 31);  ///< B1535
    }

    /// MPCBB1_VCTR48 Register bits
    namespace mpcbb1_vctr48_bits {
        constexpr uint32_t B1536 = (1U << 0);  ///< B1536
        constexpr uint32_t B1537 = (1U << 1);  ///< B1537
        constexpr uint32_t B1538 = (1U << 2);  ///< B1538
        constexpr uint32_t B1539 = (1U << 3);  ///< B1539
        constexpr uint32_t B1540 = (1U << 4);  ///< B1540
        constexpr uint32_t B1541 = (1U << 5);  ///< B1541
        constexpr uint32_t B1542 = (1U << 6);  ///< B1542
        constexpr uint32_t B1543 = (1U << 7);  ///< B1543
        constexpr uint32_t B1544 = (1U << 8);  ///< B1544
        constexpr uint32_t B1545 = (1U << 9);  ///< B1545
        constexpr uint32_t B1546 = (1U << 10);  ///< B1546
        constexpr uint32_t B1547 = (1U << 11);  ///< B1547
        constexpr uint32_t B1548 = (1U << 12);  ///< B1548
        constexpr uint32_t B1549 = (1U << 13);  ///< B1549
        constexpr uint32_t B1550 = (1U << 14);  ///< B1550
        constexpr uint32_t B1551 = (1U << 15);  ///< B1551
        constexpr uint32_t B1552 = (1U << 16);  ///< B1552
        constexpr uint32_t B1553 = (1U << 17);  ///< B1553
        constexpr uint32_t B1554 = (1U << 18);  ///< B1554
        constexpr uint32_t B1555 = (1U << 19);  ///< B1555
        constexpr uint32_t B1556 = (1U << 20);  ///< B1556
        constexpr uint32_t B1557 = (1U << 21);  ///< B1557
        constexpr uint32_t B1558 = (1U << 22);  ///< B1558
        constexpr uint32_t B1559 = (1U << 23);  ///< B1559
        constexpr uint32_t B1560 = (1U << 24);  ///< B1560
        constexpr uint32_t B1561 = (1U << 25);  ///< B1561
        constexpr uint32_t B1562 = (1U << 26);  ///< B1562
        constexpr uint32_t B1563 = (1U << 27);  ///< B1563
        constexpr uint32_t B1564 = (1U << 28);  ///< B1564
        constexpr uint32_t B1565 = (1U << 29);  ///< B1565
        constexpr uint32_t B1566 = (1U << 30);  ///< B1566
        constexpr uint32_t B1567 = (1U << 31);  ///< B1567
    }

    /// MPCBB1_VCTR49 Register bits
    namespace mpcbb1_vctr49_bits {
        constexpr uint32_t B1568 = (1U << 0);  ///< B1568
        constexpr uint32_t B1569 = (1U << 1);  ///< B1569
        constexpr uint32_t B1570 = (1U << 2);  ///< B1570
        constexpr uint32_t B1571 = (1U << 3);  ///< B1571
        constexpr uint32_t B1572 = (1U << 4);  ///< B1572
        constexpr uint32_t B1573 = (1U << 5);  ///< B1573
        constexpr uint32_t B1574 = (1U << 6);  ///< B1574
        constexpr uint32_t B1575 = (1U << 7);  ///< B1575
        constexpr uint32_t B1576 = (1U << 8);  ///< B1576
        constexpr uint32_t B1577 = (1U << 9);  ///< B1577
        constexpr uint32_t B1578 = (1U << 10);  ///< B1578
        constexpr uint32_t B1579 = (1U << 11);  ///< B1579
        constexpr uint32_t B1580 = (1U << 12);  ///< B1580
        constexpr uint32_t B1581 = (1U << 13);  ///< B1581
        constexpr uint32_t B1582 = (1U << 14);  ///< B1582
        constexpr uint32_t B1583 = (1U << 15);  ///< B1583
        constexpr uint32_t B1584 = (1U << 16);  ///< B1584
        constexpr uint32_t B1585 = (1U << 17);  ///< B1585
        constexpr uint32_t B1586 = (1U << 18);  ///< B1586
        constexpr uint32_t B1587 = (1U << 19);  ///< B1587
        constexpr uint32_t B1588 = (1U << 20);  ///< B1588
        constexpr uint32_t B1589 = (1U << 21);  ///< B1589
        constexpr uint32_t B1590 = (1U << 22);  ///< B1590
        constexpr uint32_t B1591 = (1U << 23);  ///< B1591
        constexpr uint32_t B1592 = (1U << 24);  ///< B1592
        constexpr uint32_t B1593 = (1U << 25);  ///< B1593
        constexpr uint32_t B1594 = (1U << 26);  ///< B1594
        constexpr uint32_t B1595 = (1U << 27);  ///< B1595
        constexpr uint32_t B1596 = (1U << 28);  ///< B1596
        constexpr uint32_t B1597 = (1U << 29);  ///< B1597
        constexpr uint32_t B1598 = (1U << 30);  ///< B1598
        constexpr uint32_t B1599 = (1U << 31);  ///< B1599
    }

    /// MPCBB1_VCTR50 Register bits
    namespace mpcbb1_vctr50_bits {
        constexpr uint32_t B1600 = (1U << 0);  ///< B1600
        constexpr uint32_t B1601 = (1U << 1);  ///< B1601
        constexpr uint32_t B1602 = (1U << 2);  ///< B1602
        constexpr uint32_t B1603 = (1U << 3);  ///< B1603
        constexpr uint32_t B1604 = (1U << 4);  ///< B1604
        constexpr uint32_t B1605 = (1U << 5);  ///< B1605
        constexpr uint32_t B1606 = (1U << 6);  ///< B1606
        constexpr uint32_t B1607 = (1U << 7);  ///< B1607
        constexpr uint32_t B1608 = (1U << 8);  ///< B1608
        constexpr uint32_t B1609 = (1U << 9);  ///< B1609
        constexpr uint32_t B1610 = (1U << 10);  ///< B1610
        constexpr uint32_t B1611 = (1U << 11);  ///< B1611
        constexpr uint32_t B1612 = (1U << 12);  ///< B1612
        constexpr uint32_t B1613 = (1U << 13);  ///< B1613
        constexpr uint32_t B1614 = (1U << 14);  ///< B1614
        constexpr uint32_t B1615 = (1U << 15);  ///< B1615
        constexpr uint32_t B1616 = (1U << 16);  ///< B1616
        constexpr uint32_t B1617 = (1U << 17);  ///< B1617
        constexpr uint32_t B1618 = (1U << 18);  ///< B1618
        constexpr uint32_t B1619 = (1U << 19);  ///< B1619
        constexpr uint32_t B1620 = (1U << 20);  ///< B1620
        constexpr uint32_t B1621 = (1U << 21);  ///< B1621
        constexpr uint32_t B1622 = (1U << 22);  ///< B1622
        constexpr uint32_t B1623 = (1U << 23);  ///< B1623
        constexpr uint32_t B1624 = (1U << 24);  ///< B1624
        constexpr uint32_t B1625 = (1U << 25);  ///< B1625
        constexpr uint32_t B1626 = (1U << 26);  ///< B1626
        constexpr uint32_t B1627 = (1U << 27);  ///< B1627
        constexpr uint32_t B1628 = (1U << 28);  ///< B1628
        constexpr uint32_t B1629 = (1U << 29);  ///< B1629
        constexpr uint32_t B1630 = (1U << 30);  ///< B1630
        constexpr uint32_t B1631 = (1U << 31);  ///< B1631
    }

    /// MPCBB1_VCTR51 Register bits
    namespace mpcbb1_vctr51_bits {
        constexpr uint32_t B1632 = (1U << 0);  ///< B1632
        constexpr uint32_t B1633 = (1U << 1);  ///< B1633
        constexpr uint32_t B1634 = (1U << 2);  ///< B1634
        constexpr uint32_t B1635 = (1U << 3);  ///< B1635
        constexpr uint32_t B1636 = (1U << 4);  ///< B1636
        constexpr uint32_t B1637 = (1U << 5);  ///< B1637
        constexpr uint32_t B1638 = (1U << 6);  ///< B1638
        constexpr uint32_t B1639 = (1U << 7);  ///< B1639
        constexpr uint32_t B1640 = (1U << 8);  ///< B1640
        constexpr uint32_t B1641 = (1U << 9);  ///< B1641
        constexpr uint32_t B1642 = (1U << 10);  ///< B1642
        constexpr uint32_t B1643 = (1U << 11);  ///< B1643
        constexpr uint32_t B1644 = (1U << 12);  ///< B1644
        constexpr uint32_t B1645 = (1U << 13);  ///< B1645
        constexpr uint32_t B1646 = (1U << 14);  ///< B1646
        constexpr uint32_t B1647 = (1U << 15);  ///< B1647
        constexpr uint32_t B1648 = (1U << 16);  ///< B1648
        constexpr uint32_t B1649 = (1U << 17);  ///< B1649
        constexpr uint32_t B1650 = (1U << 18);  ///< B1650
        constexpr uint32_t B1651 = (1U << 19);  ///< B1651
        constexpr uint32_t B1652 = (1U << 20);  ///< B1652
        constexpr uint32_t B1653 = (1U << 21);  ///< B1653
        constexpr uint32_t B1654 = (1U << 22);  ///< B1654
        constexpr uint32_t B1655 = (1U << 23);  ///< B1655
        constexpr uint32_t B1656 = (1U << 24);  ///< B1656
        constexpr uint32_t B1657 = (1U << 25);  ///< B1657
        constexpr uint32_t B1658 = (1U << 26);  ///< B1658
        constexpr uint32_t B1659 = (1U << 27);  ///< B1659
        constexpr uint32_t B1660 = (1U << 28);  ///< B1660
        constexpr uint32_t B1661 = (1U << 29);  ///< B1661
        constexpr uint32_t B1662 = (1U << 30);  ///< B1662
        constexpr uint32_t B1663 = (1U << 31);  ///< B1663
    }

    /// MPCBB1_VCTR52 Register bits
    namespace mpcbb1_vctr52_bits {
        constexpr uint32_t B1664 = (1U << 0);  ///< B1664
        constexpr uint32_t B1665 = (1U << 1);  ///< B1665
        constexpr uint32_t B1666 = (1U << 2);  ///< B1666
        constexpr uint32_t B1667 = (1U << 3);  ///< B1667
        constexpr uint32_t B1668 = (1U << 4);  ///< B1668
        constexpr uint32_t B1669 = (1U << 5);  ///< B1669
        constexpr uint32_t B1670 = (1U << 6);  ///< B1670
        constexpr uint32_t B1671 = (1U << 7);  ///< B1671
        constexpr uint32_t B1672 = (1U << 8);  ///< B1672
        constexpr uint32_t B1673 = (1U << 9);  ///< B1673
        constexpr uint32_t B1674 = (1U << 10);  ///< B1674
        constexpr uint32_t B1675 = (1U << 11);  ///< B1675
        constexpr uint32_t B1676 = (1U << 12);  ///< B1676
        constexpr uint32_t B1677 = (1U << 13);  ///< B1677
        constexpr uint32_t B1678 = (1U << 14);  ///< B1678
        constexpr uint32_t B1679 = (1U << 15);  ///< B1679
        constexpr uint32_t B1680 = (1U << 16);  ///< B1680
        constexpr uint32_t B1681 = (1U << 17);  ///< B1681
        constexpr uint32_t B1682 = (1U << 18);  ///< B1682
        constexpr uint32_t B1683 = (1U << 19);  ///< B1683
        constexpr uint32_t B1684 = (1U << 20);  ///< B1684
        constexpr uint32_t B1685 = (1U << 21);  ///< B1685
        constexpr uint32_t B1686 = (1U << 22);  ///< B1686
        constexpr uint32_t B1687 = (1U << 23);  ///< B1687
        constexpr uint32_t B1688 = (1U << 24);  ///< B1688
        constexpr uint32_t B1689 = (1U << 25);  ///< B1689
        constexpr uint32_t B1690 = (1U << 26);  ///< B1690
        constexpr uint32_t B1691 = (1U << 27);  ///< B1691
        constexpr uint32_t B1692 = (1U << 28);  ///< B1692
        constexpr uint32_t B1693 = (1U << 29);  ///< B1693
        constexpr uint32_t B1694 = (1U << 30);  ///< B1694
        constexpr uint32_t B1695 = (1U << 31);  ///< B1695
    }

    /// MPCBB1_VCTR53 Register bits
    namespace mpcbb1_vctr53_bits {
        constexpr uint32_t B1696 = (1U << 0);  ///< B1696
        constexpr uint32_t B1697 = (1U << 1);  ///< B1697
        constexpr uint32_t B1698 = (1U << 2);  ///< B1698
        constexpr uint32_t B1699 = (1U << 3);  ///< B1699
        constexpr uint32_t B1700 = (1U << 4);  ///< B1700
        constexpr uint32_t B1701 = (1U << 5);  ///< B1701
        constexpr uint32_t B1702 = (1U << 6);  ///< B1702
        constexpr uint32_t B1703 = (1U << 7);  ///< B1703
        constexpr uint32_t B1704 = (1U << 8);  ///< B1704
        constexpr uint32_t B1705 = (1U << 9);  ///< B1705
        constexpr uint32_t B1706 = (1U << 10);  ///< B1706
        constexpr uint32_t B1707 = (1U << 11);  ///< B1707
        constexpr uint32_t B1708 = (1U << 12);  ///< B1708
        constexpr uint32_t B1709 = (1U << 13);  ///< B1709
        constexpr uint32_t B1710 = (1U << 14);  ///< B1710
        constexpr uint32_t B1711 = (1U << 15);  ///< B1711
        constexpr uint32_t B1712 = (1U << 16);  ///< B1712
        constexpr uint32_t B1713 = (1U << 17);  ///< B1713
        constexpr uint32_t B1714 = (1U << 18);  ///< B1714
        constexpr uint32_t B1715 = (1U << 19);  ///< B1715
        constexpr uint32_t B1716 = (1U << 20);  ///< B1716
        constexpr uint32_t B1717 = (1U << 21);  ///< B1717
        constexpr uint32_t B1718 = (1U << 22);  ///< B1718
        constexpr uint32_t B1719 = (1U << 23);  ///< B1719
        constexpr uint32_t B1720 = (1U << 24);  ///< B1720
        constexpr uint32_t B1721 = (1U << 25);  ///< B1721
        constexpr uint32_t B1722 = (1U << 26);  ///< B1722
        constexpr uint32_t B1723 = (1U << 27);  ///< B1723
        constexpr uint32_t B1724 = (1U << 28);  ///< B1724
        constexpr uint32_t B1725 = (1U << 29);  ///< B1725
        constexpr uint32_t B1726 = (1U << 30);  ///< B1726
        constexpr uint32_t B1727 = (1U << 31);  ///< B1727
    }

    /// MPCBB1_VCTR54 Register bits
    namespace mpcbb1_vctr54_bits {
        constexpr uint32_t B1728 = (1U << 0);  ///< B1728
        constexpr uint32_t B1729 = (1U << 1);  ///< B1729
        constexpr uint32_t B1730 = (1U << 2);  ///< B1730
        constexpr uint32_t B1731 = (1U << 3);  ///< B1731
        constexpr uint32_t B1732 = (1U << 4);  ///< B1732
        constexpr uint32_t B1733 = (1U << 5);  ///< B1733
        constexpr uint32_t B1734 = (1U << 6);  ///< B1734
        constexpr uint32_t B1735 = (1U << 7);  ///< B1735
        constexpr uint32_t B1736 = (1U << 8);  ///< B1736
        constexpr uint32_t B1737 = (1U << 9);  ///< B1737
        constexpr uint32_t B1738 = (1U << 10);  ///< B1738
        constexpr uint32_t B1739 = (1U << 11);  ///< B1739
        constexpr uint32_t B1740 = (1U << 12);  ///< B1740
        constexpr uint32_t B1741 = (1U << 13);  ///< B1741
        constexpr uint32_t B1742 = (1U << 14);  ///< B1742
        constexpr uint32_t B1743 = (1U << 15);  ///< B1743
        constexpr uint32_t B1744 = (1U << 16);  ///< B1744
        constexpr uint32_t B1745 = (1U << 17);  ///< B1745
        constexpr uint32_t B1746 = (1U << 18);  ///< B1746
        constexpr uint32_t B1747 = (1U << 19);  ///< B1747
        constexpr uint32_t B1748 = (1U << 20);  ///< B1748
        constexpr uint32_t B1749 = (1U << 21);  ///< B1749
        constexpr uint32_t B1750 = (1U << 22);  ///< B1750
        constexpr uint32_t B1751 = (1U << 23);  ///< B1751
        constexpr uint32_t B1752 = (1U << 24);  ///< B1752
        constexpr uint32_t B1753 = (1U << 25);  ///< B1753
        constexpr uint32_t B1754 = (1U << 26);  ///< B1754
        constexpr uint32_t B1755 = (1U << 27);  ///< B1755
        constexpr uint32_t B1756 = (1U << 28);  ///< B1756
        constexpr uint32_t B1757 = (1U << 29);  ///< B1757
        constexpr uint32_t B1758 = (1U << 30);  ///< B1758
        constexpr uint32_t B1759 = (1U << 31);  ///< B1759
    }

    /// MPCBB1_VCTR55 Register bits
    namespace mpcbb1_vctr55_bits {
        constexpr uint32_t B1760 = (1U << 0);  ///< B1760
        constexpr uint32_t B1761 = (1U << 1);  ///< B1761
        constexpr uint32_t B1762 = (1U << 2);  ///< B1762
        constexpr uint32_t B1763 = (1U << 3);  ///< B1763
        constexpr uint32_t B1764 = (1U << 4);  ///< B1764
        constexpr uint32_t B1765 = (1U << 5);  ///< B1765
        constexpr uint32_t B1766 = (1U << 6);  ///< B1766
        constexpr uint32_t B1767 = (1U << 7);  ///< B1767
        constexpr uint32_t B1768 = (1U << 8);  ///< B1768
        constexpr uint32_t B1769 = (1U << 9);  ///< B1769
        constexpr uint32_t B1770 = (1U << 10);  ///< B1770
        constexpr uint32_t B1771 = (1U << 11);  ///< B1771
        constexpr uint32_t B1772 = (1U << 12);  ///< B1772
        constexpr uint32_t B1773 = (1U << 13);  ///< B1773
        constexpr uint32_t B1774 = (1U << 14);  ///< B1774
        constexpr uint32_t B1775 = (1U << 15);  ///< B1775
        constexpr uint32_t B1776 = (1U << 16);  ///< B1776
        constexpr uint32_t B1777 = (1U << 17);  ///< B1777
        constexpr uint32_t B1778 = (1U << 18);  ///< B1778
        constexpr uint32_t B1779 = (1U << 19);  ///< B1779
        constexpr uint32_t B1780 = (1U << 20);  ///< B1780
        constexpr uint32_t B1781 = (1U << 21);  ///< B1781
        constexpr uint32_t B1782 = (1U << 22);  ///< B1782
        constexpr uint32_t B1783 = (1U << 23);  ///< B1783
        constexpr uint32_t B1784 = (1U << 24);  ///< B1784
        constexpr uint32_t B1785 = (1U << 25);  ///< B1785
        constexpr uint32_t B1786 = (1U << 26);  ///< B1786
        constexpr uint32_t B1787 = (1U << 27);  ///< B1787
        constexpr uint32_t B1788 = (1U << 28);  ///< B1788
        constexpr uint32_t B1789 = (1U << 29);  ///< B1789
        constexpr uint32_t B1790 = (1U << 30);  ///< B1790
        constexpr uint32_t B1791 = (1U << 31);  ///< B1791
    }

    /// MPCBB1_VCTR56 Register bits
    namespace mpcbb1_vctr56_bits {
        constexpr uint32_t B1792 = (1U << 0);  ///< B1792
        constexpr uint32_t B1793 = (1U << 1);  ///< B1793
        constexpr uint32_t B1794 = (1U << 2);  ///< B1794
        constexpr uint32_t B1795 = (1U << 3);  ///< B1795
        constexpr uint32_t B1796 = (1U << 4);  ///< B1796
        constexpr uint32_t B1797 = (1U << 5);  ///< B1797
        constexpr uint32_t B1798 = (1U << 6);  ///< B1798
        constexpr uint32_t B1799 = (1U << 7);  ///< B1799
        constexpr uint32_t B1800 = (1U << 8);  ///< B1800
        constexpr uint32_t B1801 = (1U << 9);  ///< B1801
        constexpr uint32_t B1802 = (1U << 10);  ///< B1802
        constexpr uint32_t B1803 = (1U << 11);  ///< B1803
        constexpr uint32_t B1804 = (1U << 12);  ///< B1804
        constexpr uint32_t B1805 = (1U << 13);  ///< B1805
        constexpr uint32_t B1806 = (1U << 14);  ///< B1806
        constexpr uint32_t B1807 = (1U << 15);  ///< B1807
        constexpr uint32_t B1808 = (1U << 16);  ///< B1808
        constexpr uint32_t B1809 = (1U << 17);  ///< B1809
        constexpr uint32_t B1810 = (1U << 18);  ///< B1810
        constexpr uint32_t B1811 = (1U << 19);  ///< B1811
        constexpr uint32_t B1812 = (1U << 20);  ///< B1812
        constexpr uint32_t B1813 = (1U << 21);  ///< B1813
        constexpr uint32_t B1814 = (1U << 22);  ///< B1814
        constexpr uint32_t B1815 = (1U << 23);  ///< B1815
        constexpr uint32_t B1816 = (1U << 24);  ///< B1816
        constexpr uint32_t B1817 = (1U << 25);  ///< B1817
        constexpr uint32_t B1818 = (1U << 26);  ///< B1818
        constexpr uint32_t B1819 = (1U << 27);  ///< B1819
        constexpr uint32_t B1820 = (1U << 28);  ///< B1820
        constexpr uint32_t B1821 = (1U << 29);  ///< B1821
        constexpr uint32_t B1822 = (1U << 30);  ///< B1822
        constexpr uint32_t B1823 = (1U << 31);  ///< B1823
    }

    /// MPCBB1_VCTR57 Register bits
    namespace mpcbb1_vctr57_bits {
        constexpr uint32_t B1824 = (1U << 0);  ///< B1824
        constexpr uint32_t B1825 = (1U << 1);  ///< B1825
        constexpr uint32_t B1826 = (1U << 2);  ///< B1826
        constexpr uint32_t B1827 = (1U << 3);  ///< B1827
        constexpr uint32_t B1828 = (1U << 4);  ///< B1828
        constexpr uint32_t B1829 = (1U << 5);  ///< B1829
        constexpr uint32_t B1830 = (1U << 6);  ///< B1830
        constexpr uint32_t B1831 = (1U << 7);  ///< B1831
        constexpr uint32_t B1832 = (1U << 8);  ///< B1832
        constexpr uint32_t B1833 = (1U << 9);  ///< B1833
        constexpr uint32_t B1834 = (1U << 10);  ///< B1834
        constexpr uint32_t B1835 = (1U << 11);  ///< B1835
        constexpr uint32_t B1836 = (1U << 12);  ///< B1836
        constexpr uint32_t B1837 = (1U << 13);  ///< B1837
        constexpr uint32_t B1838 = (1U << 14);  ///< B1838
        constexpr uint32_t B1839 = (1U << 15);  ///< B1839
        constexpr uint32_t B1840 = (1U << 16);  ///< B1840
        constexpr uint32_t B1841 = (1U << 17);  ///< B1841
        constexpr uint32_t B1842 = (1U << 18);  ///< B1842
        constexpr uint32_t B1843 = (1U << 19);  ///< B1843
        constexpr uint32_t B1844 = (1U << 20);  ///< B1844
        constexpr uint32_t B1845 = (1U << 21);  ///< B1845
        constexpr uint32_t B1846 = (1U << 22);  ///< B1846
        constexpr uint32_t B1847 = (1U << 23);  ///< B1847
        constexpr uint32_t B1848 = (1U << 24);  ///< B1848
        constexpr uint32_t B1849 = (1U << 25);  ///< B1849
        constexpr uint32_t B1850 = (1U << 26);  ///< B1850
        constexpr uint32_t B1851 = (1U << 27);  ///< B1851
        constexpr uint32_t B1852 = (1U << 28);  ///< B1852
        constexpr uint32_t B1853 = (1U << 29);  ///< B1853
        constexpr uint32_t B1854 = (1U << 30);  ///< B1854
        constexpr uint32_t B1855 = (1U << 31);  ///< B1855
    }

    /// MPCBB1_VCTR58 Register bits
    namespace mpcbb1_vctr58_bits {
        constexpr uint32_t B1856 = (1U << 0);  ///< B1856
        constexpr uint32_t B1857 = (1U << 1);  ///< B1857
        constexpr uint32_t B1858 = (1U << 2);  ///< B1858
        constexpr uint32_t B1859 = (1U << 3);  ///< B1859
        constexpr uint32_t B1860 = (1U << 4);  ///< B1860
        constexpr uint32_t B1861 = (1U << 5);  ///< B1861
        constexpr uint32_t B1862 = (1U << 6);  ///< B1862
        constexpr uint32_t B1863 = (1U << 7);  ///< B1863
        constexpr uint32_t B1864 = (1U << 8);  ///< B1864
        constexpr uint32_t B1865 = (1U << 9);  ///< B1865
        constexpr uint32_t B1866 = (1U << 10);  ///< B1866
        constexpr uint32_t B1867 = (1U << 11);  ///< B1867
        constexpr uint32_t B1868 = (1U << 12);  ///< B1868
        constexpr uint32_t B1869 = (1U << 13);  ///< B1869
        constexpr uint32_t B1870 = (1U << 14);  ///< B1870
        constexpr uint32_t B1871 = (1U << 15);  ///< B1871
        constexpr uint32_t B1872 = (1U << 16);  ///< B1872
        constexpr uint32_t B1873 = (1U << 17);  ///< B1873
        constexpr uint32_t B1874 = (1U << 18);  ///< B1874
        constexpr uint32_t B1875 = (1U << 19);  ///< B1875
        constexpr uint32_t B1876 = (1U << 20);  ///< B1876
        constexpr uint32_t B1877 = (1U << 21);  ///< B1877
        constexpr uint32_t B1878 = (1U << 22);  ///< B1878
        constexpr uint32_t B1879 = (1U << 23);  ///< B1879
        constexpr uint32_t B1880 = (1U << 24);  ///< B1880
        constexpr uint32_t B1881 = (1U << 25);  ///< B1881
        constexpr uint32_t B1882 = (1U << 26);  ///< B1882
        constexpr uint32_t B1883 = (1U << 27);  ///< B1883
        constexpr uint32_t B1884 = (1U << 28);  ///< B1884
        constexpr uint32_t B1885 = (1U << 29);  ///< B1885
        constexpr uint32_t B1886 = (1U << 30);  ///< B1886
        constexpr uint32_t B1887 = (1U << 31);  ///< B1887
    }

    /// MPCBB1_VCTR59 Register bits
    namespace mpcbb1_vctr59_bits {
        constexpr uint32_t B1888 = (1U << 0);  ///< B1888
        constexpr uint32_t B1889 = (1U << 1);  ///< B1889
        constexpr uint32_t B1890 = (1U << 2);  ///< B1890
        constexpr uint32_t B1891 = (1U << 3);  ///< B1891
        constexpr uint32_t B1892 = (1U << 4);  ///< B1892
        constexpr uint32_t B1893 = (1U << 5);  ///< B1893
        constexpr uint32_t B1894 = (1U << 6);  ///< B1894
        constexpr uint32_t B1895 = (1U << 7);  ///< B1895
        constexpr uint32_t B1896 = (1U << 8);  ///< B1896
        constexpr uint32_t B1897 = (1U << 9);  ///< B1897
        constexpr uint32_t B1898 = (1U << 10);  ///< B1898
        constexpr uint32_t B1899 = (1U << 11);  ///< B1899
        constexpr uint32_t B1900 = (1U << 12);  ///< B1900
        constexpr uint32_t B1901 = (1U << 13);  ///< B1901
        constexpr uint32_t B1902 = (1U << 14);  ///< B1902
        constexpr uint32_t B1903 = (1U << 15);  ///< B1903
        constexpr uint32_t B1904 = (1U << 16);  ///< B1904
        constexpr uint32_t B1905 = (1U << 17);  ///< B1905
        constexpr uint32_t B1906 = (1U << 18);  ///< B1906
        constexpr uint32_t B1907 = (1U << 19);  ///< B1907
        constexpr uint32_t B1908 = (1U << 20);  ///< B1908
        constexpr uint32_t B1909 = (1U << 21);  ///< B1909
        constexpr uint32_t B1910 = (1U << 22);  ///< B1910
        constexpr uint32_t B1911 = (1U << 23);  ///< B1911
        constexpr uint32_t B1912 = (1U << 24);  ///< B1912
        constexpr uint32_t B1913 = (1U << 25);  ///< B1913
        constexpr uint32_t B1914 = (1U << 26);  ///< B1914
        constexpr uint32_t B1915 = (1U << 27);  ///< B1915
        constexpr uint32_t B1916 = (1U << 28);  ///< B1916
        constexpr uint32_t B1917 = (1U << 29);  ///< B1917
        constexpr uint32_t B1918 = (1U << 30);  ///< B1918
        constexpr uint32_t B1919 = (1U << 31);  ///< B1919
    }

    /// MPCBB1_VCTR60 Register bits
    namespace mpcbb1_vctr60_bits {
        constexpr uint32_t B1920 = (1U << 0);  ///< B1920
        constexpr uint32_t B1921 = (1U << 1);  ///< B1921
        constexpr uint32_t B1922 = (1U << 2);  ///< B1922
        constexpr uint32_t B1923 = (1U << 3);  ///< B1923
        constexpr uint32_t B1924 = (1U << 4);  ///< B1924
        constexpr uint32_t B1925 = (1U << 5);  ///< B1925
        constexpr uint32_t B1926 = (1U << 6);  ///< B1926
        constexpr uint32_t B1927 = (1U << 7);  ///< B1927
        constexpr uint32_t B1928 = (1U << 8);  ///< B1928
        constexpr uint32_t B1929 = (1U << 9);  ///< B1929
        constexpr uint32_t B1930 = (1U << 10);  ///< B1930
        constexpr uint32_t B1931 = (1U << 11);  ///< B1931
        constexpr uint32_t B1932 = (1U << 12);  ///< B1932
        constexpr uint32_t B1933 = (1U << 13);  ///< B1933
        constexpr uint32_t B1934 = (1U << 14);  ///< B1934
        constexpr uint32_t B1935 = (1U << 15);  ///< B1935
        constexpr uint32_t B1936 = (1U << 16);  ///< B1936
        constexpr uint32_t B1937 = (1U << 17);  ///< B1937
        constexpr uint32_t B1938 = (1U << 18);  ///< B1938
        constexpr uint32_t B1939 = (1U << 19);  ///< B1939
        constexpr uint32_t B1940 = (1U << 20);  ///< B1940
        constexpr uint32_t B1941 = (1U << 21);  ///< B1941
        constexpr uint32_t B1942 = (1U << 22);  ///< B1942
        constexpr uint32_t B1943 = (1U << 23);  ///< B1943
        constexpr uint32_t B1944 = (1U << 24);  ///< B1944
        constexpr uint32_t B1945 = (1U << 25);  ///< B1945
        constexpr uint32_t B1946 = (1U << 26);  ///< B1946
        constexpr uint32_t B1947 = (1U << 27);  ///< B1947
        constexpr uint32_t B1948 = (1U << 28);  ///< B1948
        constexpr uint32_t B1949 = (1U << 29);  ///< B1949
        constexpr uint32_t B1950 = (1U << 30);  ///< B1950
        constexpr uint32_t B1951 = (1U << 31);  ///< B1951
    }

    /// MPCBB1_VCTR61 Register bits
    namespace mpcbb1_vctr61_bits {
        constexpr uint32_t B1952 = (1U << 0);  ///< B1952
        constexpr uint32_t B1953 = (1U << 1);  ///< B1953
        constexpr uint32_t B1954 = (1U << 2);  ///< B1954
        constexpr uint32_t B1955 = (1U << 3);  ///< B1955
        constexpr uint32_t B1956 = (1U << 4);  ///< B1956
        constexpr uint32_t B1957 = (1U << 5);  ///< B1957
        constexpr uint32_t B1958 = (1U << 6);  ///< B1958
        constexpr uint32_t B1959 = (1U << 7);  ///< B1959
        constexpr uint32_t B1960 = (1U << 8);  ///< B1960
        constexpr uint32_t B1961 = (1U << 9);  ///< B1961
        constexpr uint32_t B1962 = (1U << 10);  ///< B1962
        constexpr uint32_t B1963 = (1U << 11);  ///< B1963
        constexpr uint32_t B1964 = (1U << 12);  ///< B1964
        constexpr uint32_t B1965 = (1U << 13);  ///< B1965
        constexpr uint32_t B1966 = (1U << 14);  ///< B1966
        constexpr uint32_t B1967 = (1U << 15);  ///< B1967
        constexpr uint32_t B1968 = (1U << 16);  ///< B1968
        constexpr uint32_t B1969 = (1U << 17);  ///< B1969
        constexpr uint32_t B1970 = (1U << 18);  ///< B1970
        constexpr uint32_t B1971 = (1U << 19);  ///< B1971
        constexpr uint32_t B1972 = (1U << 20);  ///< B1972
        constexpr uint32_t B1973 = (1U << 21);  ///< B1973
        constexpr uint32_t B1974 = (1U << 22);  ///< B1974
        constexpr uint32_t B1975 = (1U << 23);  ///< B1975
        constexpr uint32_t B1976 = (1U << 24);  ///< B1976
        constexpr uint32_t B1977 = (1U << 25);  ///< B1977
        constexpr uint32_t B1978 = (1U << 26);  ///< B1978
        constexpr uint32_t B1979 = (1U << 27);  ///< B1979
        constexpr uint32_t B1980 = (1U << 28);  ///< B1980
        constexpr uint32_t B1981 = (1U << 29);  ///< B1981
        constexpr uint32_t B1982 = (1U << 30);  ///< B1982
        constexpr uint32_t B1983 = (1U << 31);  ///< B1983
    }

    /// MPCBB1_VCTR62 Register bits
    namespace mpcbb1_vctr62_bits {
        constexpr uint32_t B1984 = (1U << 0);  ///< B1984
        constexpr uint32_t B1985 = (1U << 1);  ///< B1985
        constexpr uint32_t B1986 = (1U << 2);  ///< B1986
        constexpr uint32_t B1987 = (1U << 3);  ///< B1987
        constexpr uint32_t B1988 = (1U << 4);  ///< B1988
        constexpr uint32_t B1989 = (1U << 5);  ///< B1989
        constexpr uint32_t B1990 = (1U << 6);  ///< B1990
        constexpr uint32_t B1991 = (1U << 7);  ///< B1991
        constexpr uint32_t B1992 = (1U << 8);  ///< B1992
        constexpr uint32_t B1993 = (1U << 9);  ///< B1993
        constexpr uint32_t B1994 = (1U << 10);  ///< B1994
        constexpr uint32_t B1995 = (1U << 11);  ///< B1995
        constexpr uint32_t B1996 = (1U << 12);  ///< B1996
        constexpr uint32_t B1997 = (1U << 13);  ///< B1997
        constexpr uint32_t B1998 = (1U << 14);  ///< B1998
        constexpr uint32_t B1999 = (1U << 15);  ///< B1999
        constexpr uint32_t B2000 = (1U << 16);  ///< B2000
        constexpr uint32_t B2001 = (1U << 17);  ///< B2001
        constexpr uint32_t B2002 = (1U << 18);  ///< B2002
        constexpr uint32_t B2003 = (1U << 19);  ///< B2003
        constexpr uint32_t B2004 = (1U << 20);  ///< B2004
        constexpr uint32_t B2005 = (1U << 21);  ///< B2005
        constexpr uint32_t B2006 = (1U << 22);  ///< B2006
        constexpr uint32_t B2007 = (1U << 23);  ///< B2007
        constexpr uint32_t B2008 = (1U << 24);  ///< B2008
        constexpr uint32_t B2009 = (1U << 25);  ///< B2009
        constexpr uint32_t B2010 = (1U << 26);  ///< B2010
        constexpr uint32_t B2011 = (1U << 27);  ///< B2011
        constexpr uint32_t B2012 = (1U << 28);  ///< B2012
        constexpr uint32_t B2013 = (1U << 29);  ///< B2013
        constexpr uint32_t B2014 = (1U << 30);  ///< B2014
        constexpr uint32_t B2015 = (1U << 31);  ///< B2015
    }

    /// MPCBB1_VCTR63 Register bits
    namespace mpcbb1_vctr63_bits {
        constexpr uint32_t B2016 = (1U << 0);  ///< B2016
        constexpr uint32_t B2017 = (1U << 1);  ///< B2017
        constexpr uint32_t B2018 = (1U << 2);  ///< B2018
        constexpr uint32_t B2019 = (1U << 3);  ///< B2019
        constexpr uint32_t B2020 = (1U << 4);  ///< B2020
        constexpr uint32_t B2021 = (1U << 5);  ///< B2021
        constexpr uint32_t B2022 = (1U << 6);  ///< B2022
        constexpr uint32_t B2023 = (1U << 7);  ///< B2023
        constexpr uint32_t B2024 = (1U << 8);  ///< B2024
        constexpr uint32_t B2025 = (1U << 9);  ///< B2025
        constexpr uint32_t B2026 = (1U << 10);  ///< B2026
        constexpr uint32_t B2027 = (1U << 11);  ///< B2027
        constexpr uint32_t B2028 = (1U << 12);  ///< B2028
        constexpr uint32_t B2029 = (1U << 13);  ///< B2029
        constexpr uint32_t B2030 = (1U << 14);  ///< B2030
        constexpr uint32_t B2031 = (1U << 15);  ///< B2031
        constexpr uint32_t B2032 = (1U << 16);  ///< B2032
        constexpr uint32_t B2033 = (1U << 17);  ///< B2033
        constexpr uint32_t B2034 = (1U << 18);  ///< B2034
        constexpr uint32_t B2035 = (1U << 19);  ///< B2035
        constexpr uint32_t B2036 = (1U << 20);  ///< B2036
        constexpr uint32_t B2037 = (1U << 21);  ///< B2037
        constexpr uint32_t B2038 = (1U << 22);  ///< B2038
        constexpr uint32_t B2039 = (1U << 23);  ///< B2039
        constexpr uint32_t B2040 = (1U << 24);  ///< B2040
        constexpr uint32_t B2041 = (1U << 25);  ///< B2041
        constexpr uint32_t B2042 = (1U << 26);  ///< B2042
        constexpr uint32_t B2043 = (1U << 27);  ///< B2043
        constexpr uint32_t B2044 = (1U << 28);  ///< B2044
        constexpr uint32_t B2045 = (1U << 29);  ///< B2045
        constexpr uint32_t B2046 = (1U << 30);  ///< B2046
        constexpr uint32_t B2047 = (1U << 31);  ///< B2047
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;
    constexpr uint32_t SEC_PWR_BASE = 0x50007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PUCRE;  ///< Offset: 0x40 - Power Port E pull-up control register
        volatile uint32_t PDCRE;  ///< Offset: 0x44 - Power Port E pull-down control register
        volatile uint32_t PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
        volatile uint32_t PUCRG;  ///< Offset: 0x50 - Power Port G pull-up control register
        volatile uint32_t PDCRG;  ///< Offset: 0x54 - Power Port G pull-down control register
        volatile uint32_t PUCRH;  ///< Offset: 0x58 - Power Port H pull-up control register
        volatile uint32_t PDCRH;  ///< Offset: 0x5C - Power Port H pull-down control register
        volatile uint32_t SECCFGR;  ///< Offset: 0x78 - Power secure configuration register
        volatile uint32_t PRIVCFGR;  ///< Offset: 0x80 - Power privilege configuration register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);
    inline Registers* SEC_PWR = reinterpret_cast<Registers*>(SEC_PWR_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t USV = (1U << 10);  ///< VDDUSB USB supply valid
        constexpr uint32_t IOSV = (1U << 9);  ///< VDDIO2 Independent I/Os supply valid
        constexpr uint32_t PVME4 = (1U << 7);  ///< Peripheral voltage monitoring 4 enable: VDDA vs. 2.2V
        constexpr uint32_t PVME3 = (1U << 6);  ///< Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V
        constexpr uint32_t PVME2 = (1U << 5);  ///< Peripheral voltage monitoring 2 enable: VDDIO2 vs. 0.9V
        constexpr uint32_t PVME1 = (1U << 4);  ///< Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V
        constexpr uint32_t PLS = (3 << 1);  ///< Power voltage detector level selection
        constexpr uint32_t PVDE = (1U << 0);  ///< Power voltage detector enable
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t UCPD_DBDIS = (1U << 14);  ///< UCPD_DBDIS
        constexpr uint32_t UCPD_STDBY = (1U << 13);  ///< UCPD_STDBY
        constexpr uint32_t ULPMEN = (1U << 11);  ///< ULPMEN
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration
        constexpr uint32_t RRS = (2 << 8);  ///< SRAM2 retention in Standby mode
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable Wakeup pin WKUP5
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wakeup pin WKUP4
        constexpr uint32_t EWUP3 = (1U << 2);  ///< Enable Wakeup pin WKUP3
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wakeup pin WKUP2
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wakeup pin WKUP1
    }

    /// CR4 Register bits
    namespace cr4_bits {
        constexpr uint32_t SMPSLPEN = (1U << 15);  ///< SMPSLPEN
        constexpr uint32_t SMPSFSTEN = (1U << 14);  ///< SMPSFSTEN
        constexpr uint32_t EXTSMPSEN = (1U << 13);  ///< EXTSMPSEN
        constexpr uint32_t SMPSBYP = (1U << 12);  ///< SMPSBYP
        constexpr uint32_t VBRS = (1U << 9);  ///< VBAT battery charging resistor selection
        constexpr uint32_t VBE = (1U << 8);  ///< VBAT battery charging enable
        constexpr uint32_t WUPP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity
        constexpr uint32_t WUPP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity
        constexpr uint32_t WUPP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity
        constexpr uint32_t WUPP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity
        constexpr uint32_t WUPP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity
    }

    /// SR1 Register bits
    namespace sr1_bits {
        constexpr uint32_t SMPSHPRDY = (1U << 15);  ///< SMPSHPRDY
        constexpr uint32_t EXTSMPSRDY = (1U << 13);  ///< EXTSMPSRDY
        constexpr uint32_t SMPSBYPRDY = (1U << 12);  ///< SMPSBYPRDY
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1
    }

    /// SR2 Register bits
    namespace sr2_bits {
        constexpr uint32_t PVMO4 = (1U << 15);  ///< Peripheral voltage monitoring output: VDDA vs. 2.2 V
        constexpr uint32_t PVMO3 = (1U << 14);  ///< Peripheral voltage monitoring output: VDDA vs. 1.62 V
        constexpr uint32_t PVMO2 = (1U << 13);  ///< Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
        constexpr uint32_t PVMO1 = (1U << 12);  ///< Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
        constexpr uint32_t PVDO = (1U << 11);  ///< Power voltage detector output
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wakeup flag 5
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wakeup flag 4
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Clear wakeup flag 3
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wakeup flag 2
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wakeup flag 1
    }

    /// PUCRA Register bits
    namespace pucra_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y=0..15)
    }

    /// PDCRA Register bits
    namespace pdcra_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y (y=0..15)
    }

    /// PUCRB Register bits
    namespace pucrb_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y (y=0..15)
    }

    /// PDCRB Register bits
    namespace pdcrb_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y (y=0..15)
    }

    /// PUCRC Register bits
    namespace pucrc_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y (y=0..15)
    }

    /// PDCRC Register bits
    namespace pdcrc_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y (y=0..15)
    }

    /// PUCRD Register bits
    namespace pucrd_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y (y=0..15)
    }

    /// PDCRD Register bits
    namespace pdcrd_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y (y=0..15)
    }

    /// PUCRE Register bits
    namespace pucre_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port E pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port E pull-up bit y (y=0..15)
    }

    /// PDCRE Register bits
    namespace pdcre_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port E pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port E pull-down bit y (y=0..15)
    }

    /// PUCRF Register bits
    namespace pucrf_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y (y=0..15)
    }

    /// PDCRF Register bits
    namespace pdcrf_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y (y=0..15)
    }

    /// PUCRG Register bits
    namespace pucrg_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port G pull-up bit y (y=0..15)
    }

    /// PDCRG Register bits
    namespace pdcrg_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port G pull-down bit y (y=0..15)
    }

    /// PUCRH Register bits
    namespace pucrh_bits {
        constexpr uint32_t PU15 = (1U << 15);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU14 = (1U << 14);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU13 = (1U << 13);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU12 = (1U << 12);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU11 = (1U << 11);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU10 = (1U << 10);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU9 = (1U << 9);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU8 = (1U << 8);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU7 = (1U << 7);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU6 = (1U << 6);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU5 = (1U << 5);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU4 = (1U << 4);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU3 = (1U << 3);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU2 = (1U << 2);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU1 = (1U << 1);  ///< Port G pull-up bit y (y=0..15)
        constexpr uint32_t PU0 = (1U << 0);  ///< Port G pull-up bit y (y=0..15)
    }

    /// PDCRH Register bits
    namespace pdcrh_bits {
        constexpr uint32_t PD15 = (1U << 15);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD14 = (1U << 14);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD13 = (1U << 13);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD12 = (1U << 12);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD11 = (1U << 11);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD10 = (1U << 10);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD9 = (1U << 9);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD8 = (1U << 8);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD7 = (1U << 7);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD6 = (1U << 6);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD5 = (1U << 5);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD4 = (1U << 4);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD3 = (1U << 3);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD2 = (1U << 2);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD1 = (1U << 1);  ///< Port G pull-down bit y (y=0..15)
        constexpr uint32_t PD0 = (1U << 0);  ///< Port G pull-down bit y (y=0..15)
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t APCSEC = (1U << 11);  ///< APCSEC
        constexpr uint32_t VBSEC = (1U << 10);  ///< VBSEC
        constexpr uint32_t VDMSEC = (1U << 9);  ///< VDMSEC
        constexpr uint32_t LPMSEC = (1U << 8);  ///< LPMSEC
        constexpr uint32_t WUP5SEC = (1U << 4);  ///< WKUP5 pin security
        constexpr uint32_t WUP4SEC = (1U << 3);  ///< WKUP4 pin security
        constexpr uint32_t WUP3SEC = (1U << 2);  ///< WKUP3 pin security
        constexpr uint32_t WUP2SEC = (1U << 1);  ///< WKUP2 pin security
        constexpr uint32_t WUP1SEC = (1U << 0);  ///< WKUP1 pin security
    }

    /// PRIVCFGR Register bits
    namespace privcfgr_bits {
        constexpr uint32_t PRIV = (1U << 0);  ///< PRIV
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;
    constexpr uint32_t SEC_RCC_BASE = 0x50021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t PLLCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t PLLSAI1CFGR;  ///< Offset: 0x10 - PLLSAI1 configuration register
        volatile uint32_t PLLSAI2CFGR;  ///< Offset: 0x14 - PLLSAI2 configuration register
        volatile uint32_t CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t AHB1RSTR;  ///< Offset: 0x28 - AHB1 peripheral reset register
        volatile uint32_t AHB2RSTR;  ///< Offset: 0x2C - AHB2 peripheral reset register
        volatile uint32_t AHB3RSTR;  ///< Offset: 0x30 - AHB3 peripheral reset register
        volatile uint32_t APB1RSTR1;  ///< Offset: 0x38 - APB1 peripheral reset register 1
        volatile uint32_t APB1RSTR2;  ///< Offset: 0x3C - APB1 peripheral reset register 2
        volatile uint32_t APB2RSTR;  ///< Offset: 0x40 - APB2 peripheral reset register
        volatile uint32_t AHB1ENR;  ///< Offset: 0x48 - AHB1 peripheral clock enable register
        volatile uint32_t AHB2ENR;  ///< Offset: 0x4C - AHB2 peripheral clock enable register
        volatile uint32_t AHB3ENR;  ///< Offset: 0x50 - AHB3 peripheral clock enable register
        volatile uint32_t APB1ENR1;  ///< Offset: 0x58 - APB1ENR1
        volatile uint32_t APB1ENR2;  ///< Offset: 0x5C - APB1 peripheral clock enable register 2
        volatile uint32_t APB2ENR;  ///< Offset: 0x60 - APB2ENR
        volatile uint32_t AHB1SMENR;  ///< Offset: 0x68 - AHB1 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t AHB2SMENR;  ///< Offset: 0x6C - AHB2 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t AHB3SMENR;  ///< Offset: 0x70 - AHB3 peripheral clocks enable in Sleep and Stop modes register
        volatile uint32_t APB1SMENR1;  ///< Offset: 0x78 - APB1SMENR1
        volatile uint32_t APB1SMENR2;  ///< Offset: 0x7C - APB1 peripheral clocks enable in Sleep and Stop modes register 2
        volatile uint32_t APB2SMENR;  ///< Offset: 0x80 - APB2SMENR
        volatile uint32_t CCIPR1;  ///< Offset: 0x88 - CCIPR1
        volatile uint32_t BDCR;  ///< Offset: 0x90 - BDCR
        volatile uint32_t CSR;  ///< Offset: 0x94 - CSR
        volatile uint32_t CRRCR;  ///< Offset: 0x98 - Clock recovery RC register
        volatile uint32_t CCIPR2;  ///< Offset: 0x9C - Peripherals independent clock configuration register
        volatile uint32_t SECCFGR;  ///< Offset: 0xB8 - RCC secure configuration register
        volatile uint32_t SECSR;  ///< Offset: 0xBC - RCC secure status register
        volatile uint32_t AHB1SECSR;  ///< Offset: 0xE8 - RCC AHB1 security status register
        volatile uint32_t AHB2SECSR;  ///< Offset: 0xEC - RCC AHB2 security status register
        volatile uint32_t AHB3SECSR;  ///< Offset: 0xF0 - RCC AHB3 security status register
        volatile uint32_t APB1SECSR1;  ///< Offset: 0xF8 - RCC APB1 security status register 1
        volatile uint32_t APB1SECSR2;  ///< Offset: 0xFC - RCC APB1 security status register 2
        volatile uint32_t APB2SECSR;  ///< Offset: 0x100 - RCC APB2 security status register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);
    inline Registers* SEC_RCC = reinterpret_cast<Registers*>(SEC_RCC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PRIV = (1U << 31);  ///< PRIV
        constexpr uint32_t PLLSAI2RDY = (1U << 29);  ///< SAI2 PLL clock ready flag
        constexpr uint32_t PLLSAI2ON = (1U << 28);  ///< SAI2 PLL enable
        constexpr uint32_t PLLSAI1RDY = (1U << 27);  ///< SAI1 PLL clock ready flag
        constexpr uint32_t PLLSAI1ON = (1U << 26);  ///< SAI1 PLL enable
        constexpr uint32_t PLLRDY = (1U << 25);  ///< Main PLL clock ready flag
        constexpr uint32_t PLLON = (1U << 24);  ///< Main PLL enable
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable
        constexpr uint32_t HSIASFS = (1U << 11);  ///< HSI automatic start from Stop
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI clock ready flag
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI always enable for peripheral kernels
        constexpr uint32_t HSION = (1U << 8);  ///< HSI clock enable
        constexpr uint32_t MSIRANGE = (4 << 4);  ///< MSI clock ranges
        constexpr uint32_t MSIRGSEL = (1U << 3);  ///< MSI clock range selection
        constexpr uint32_t MSIPLLEN = (1U << 2);  ///< MSI clock PLL enable
        constexpr uint32_t MSIRDY = (1U << 1);  ///< MSI clock ready flag
        constexpr uint32_t MSION = (1U << 0);  ///< MSI clock enable
    }

    /// ICSCR Register bits
    namespace icscr_bits {
        constexpr uint32_t HSITRIM = (7 << 24);  ///< HSI clock trimming
        constexpr uint32_t HSICAL = (8 << 16);  ///< HSI clock calibration
        constexpr uint32_t MSITRIM = (8 << 8);  ///< MSI clock trimming
        constexpr uint32_t MSICAL = (8 << 0);  ///< MSI clock calibration
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t MCOPRE = (3 << 28);  ///< Microcontroller clock output prescaler
        constexpr uint32_t MCOSEL = (4 << 24);  ///< Microcontroller clock output
        constexpr uint32_t STOPWUCK = (1U << 15);  ///< Wakeup from Stop and CSS backup clock selection
        constexpr uint32_t PPRE2 = (3 << 11);  ///< APB high-speed prescaler (APB2)
        constexpr uint32_t PPRE1 = (3 << 8);  ///< PB low-speed prescaler (APB1)
        constexpr uint32_t HPRE = (4 << 4);  ///< AHB prescaler
        constexpr uint32_t SWS = (2 << 2);  ///< System clock switch status
        constexpr uint32_t SW = (2 << 0);  ///< System clock switch
    }

    /// PLLCFGR Register bits
    namespace pllcfgr_bits {
        constexpr uint32_t PLLPDIV = (5 << 27);  ///< Main PLL division factor for PLLSAI2CLK
        constexpr uint32_t PLLR = (2 << 25);  ///< Main PLL division factor for PLLCLK (system clock)
        constexpr uint32_t PLLREN = (1U << 24);  ///< Main PLL PLLCLK output enable
        constexpr uint32_t PLLQ = (2 << 21);  ///< Main PLL division factor for PLLUSB1CLK(48 MHz clock)
        constexpr uint32_t PLLQEN = (1U << 20);  ///< Main PLL PLLUSB1CLK output enable
        constexpr uint32_t PLLP = (1U << 17);  ///< Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
        constexpr uint32_t PLLPEN = (1U << 16);  ///< Main PLL PLLSAI3CLK output enable
        constexpr uint32_t PLLN = (7 << 8);  ///< Main PLL multiplication factor for VCO
        constexpr uint32_t PLLM = (4 << 4);  ///< Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
        constexpr uint32_t PLLSRC = (2 << 0);  ///< Main PLL, PLLSAI1 and PLLSAI2 entry clock source
    }

    /// PLLSAI1CFGR Register bits
    namespace pllsai1cfgr_bits {
        constexpr uint32_t PLLSAI1PDIV = (5 << 27);  ///< PLLSAI1 division factor for PLLSAI1CLK
        constexpr uint32_t PLLSAI1R = (2 << 25);  ///< PLLSAI1 division factor for PLLADC1CLK (ADC clock)
        constexpr uint32_t PLLSAI1REN = (1U << 24);  ///< PLLSAI1 PLLADC1CLK output enable
        constexpr uint32_t PLLSAI1Q = (2 << 21);  ///< SAI1PLL division factor for PLLUSB2CLK (48 MHz clock)
        constexpr uint32_t PLLSAI1QEN = (1U << 20);  ///< SAI1PLL PLLUSB2CLK output enable
        constexpr uint32_t PLLSAI1P = (1U << 17);  ///< SAI1PLL division factor for PLLSAI1CLK (SAI1 or SAI2 clock)
        constexpr uint32_t PLLSAI1PEN = (1U << 16);  ///< SAI1PLL PLLSAI1CLK output enable
        constexpr uint32_t PLLSAI1N = (7 << 8);  ///< SAI1PLL multiplication factor for VCO
        constexpr uint32_t PLLSAI1M = (4 << 4);  ///< Division factor for PLLSAI1 input clock
        constexpr uint32_t PLLSAI1SRC = (2 << 0);  ///< PLLSAI1SRC
    }

    /// PLLSAI2CFGR Register bits
    namespace pllsai2cfgr_bits {
        constexpr uint32_t PLLSAI2PDIV = (5 << 27);  ///< PLLSAI2 division factor for PLLSAI2CLK
        constexpr uint32_t PLLSAI2P = (1U << 17);  ///< SAI1PLL division factor for PLLSAI2CLK (SAI1 or SAI2 clock)
        constexpr uint32_t PLLSAI2PEN = (1U << 16);  ///< SAI2PLL PLLSAI2CLK output enable
        constexpr uint32_t PLLSAI2N = (7 << 8);  ///< SAI2PLL multiplication factor for VCO
        constexpr uint32_t PLLSAI2M = (4 << 4);  ///< Division factor for PLLSAI2 input clock
        constexpr uint32_t PLLSAI2SRC = (2 << 0);  ///< PLLSAI2SRC
    }

    /// CIER Register bits
    namespace cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable
        constexpr uint32_t MSIRDYIE = (1U << 2);  ///< MSI ready interrupt enable
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI ready interrupt enable
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable
        constexpr uint32_t PLLRDYIE = (1U << 5);  ///< PLL ready interrupt enable
        constexpr uint32_t PLLSAI1RDYIE = (1U << 6);  ///< PLLSAI1 ready interrupt enable
        constexpr uint32_t PLLSAI2RDYIE = (1U << 7);  ///< PLLSAI2 ready interrupt enable
        constexpr uint32_t LSECSSIE = (1U << 9);  ///< LSE clock security system interrupt enable
        constexpr uint32_t HSI48RDYIE = (1U << 10);  ///< HSI48 ready interrupt enable
    }

    /// CIFR Register bits
    namespace cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag
        constexpr uint32_t MSIRDYF = (1U << 2);  ///< MSI ready interrupt flag
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI ready interrupt flag
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag
        constexpr uint32_t PLLRDYF = (1U << 5);  ///< PLL ready interrupt flag
        constexpr uint32_t PLLSAI1RDYF = (1U << 6);  ///< PLLSAI1 ready interrupt flag
        constexpr uint32_t PLLSAI2RDYF = (1U << 7);  ///< PLLSAI2 ready interrupt flag
        constexpr uint32_t CSSF = (1U << 8);  ///< Clock security system interrupt flag
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE Clock security system interrupt flag
        constexpr uint32_t HSI48RDYF = (1U << 10);  ///< HSI48 ready interrupt flag
    }

    /// CICR Register bits
    namespace cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear
        constexpr uint32_t MSIRDYC = (1U << 2);  ///< MSI ready interrupt clear
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI ready interrupt clear
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear
        constexpr uint32_t PLLRDYC = (1U << 5);  ///< PLL ready interrupt clear
        constexpr uint32_t PLLSAI1RDYC = (1U << 6);  ///< PLLSAI1 ready interrupt clear
        constexpr uint32_t PLLSAI2RDYC = (1U << 7);  ///< PLLSAI2 ready interrupt clear
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear
        constexpr uint32_t HSI48RDYC = (1U << 10);  ///< HSI48 oscillator ready interrupt clear
    }

    /// AHB1RSTR Register bits
    namespace ahb1rstr_bits {
        constexpr uint32_t DMA1RST = (1U << 0);  ///< DMA1 reset
        constexpr uint32_t DMA2RST = (1U << 1);  ///< DMA2 reset
        constexpr uint32_t DMAMUX1RST = (1U << 2);  ///< DMAMUXRST
        constexpr uint32_t FLASHRST = (1U << 8);  ///< Flash memory interface reset
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset
        constexpr uint32_t TSCRST = (1U << 16);  ///< Touch Sensing Controller reset
        constexpr uint32_t GTZCRST = (1U << 22);  ///< GTZC reset
    }

    /// AHB2RSTR Register bits
    namespace ahb2rstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< IO port A reset
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< IO port B reset
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< IO port C reset
        constexpr uint32_t GPIODRST = (1U << 3);  ///< IO port D reset
        constexpr uint32_t GPIOERST = (1U << 4);  ///< IO port E reset
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< IO port F reset
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< IO port G reset
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< IO port H reset
        constexpr uint32_t ADCRST = (1U << 13);  ///< ADC reset
        constexpr uint32_t AESRST = (1U << 16);  ///< AES hardware accelerator reset
        constexpr uint32_t HASHRST = (1U << 17);  ///< Hash reset
        constexpr uint32_t RNGRST = (1U << 18);  ///< Random number generator reset
        constexpr uint32_t PKARST = (1U << 19);  ///< PKARST
        constexpr uint32_t OTFDEC1RST = (1U << 21);  ///< OTFDEC1RST
        constexpr uint32_t SDMMC1RST = (1U << 22);  ///< SDMMC1 reset
    }

    /// AHB3RSTR Register bits
    namespace ahb3rstr_bits {
        constexpr uint32_t FMCRST = (1U << 0);  ///< Flexible memory controller reset
        constexpr uint32_t OSPI1RST = (1U << 8);  ///< OSPI1RST
    }

    /// APB1RSTR1 Register bits
    namespace apb1rstr1_bits {
        constexpr uint32_t LPTIM1RST = (1U << 31);  ///< Low Power Timer 1 reset
        constexpr uint32_t OPAMPRST = (1U << 30);  ///< OPAMP interface reset
        constexpr uint32_t DAC1RST = (1U << 29);  ///< DAC1 interface reset
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset
        constexpr uint32_t CRSRST = (1U << 24);  ///< CRS reset
        constexpr uint32_t I2C3RST = (1U << 23);  ///< I2C3 reset
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset
        constexpr uint32_t UART5RST = (1U << 20);  ///< UART5 reset
        constexpr uint32_t UART4RST = (1U << 19);  ///< UART4 reset
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset
        constexpr uint32_t SPI3RST = (1U << 15);  ///< SPI3 reset
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 timer reset
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 timer reset
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 timer reset
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM3 timer reset
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 timer reset
    }

    /// APB1RSTR2 Register bits
    namespace apb1rstr2_bits {
        constexpr uint32_t LPUART1RST = (1U << 0);  ///< Low-power UART 1 reset
        constexpr uint32_t I2C4RST = (1U << 1);  ///< I2C4 reset
        constexpr uint32_t LPTIM2RST = (1U << 5);  ///< Low-power timer 2 reset
        constexpr uint32_t LPTIM3RST = (1U << 6);  ///< LPTIM3RST
        constexpr uint32_t FDCAN1RST = (1U << 9);  ///< FDCAN1RST
        constexpr uint32_t USBFSRST = (1U << 21);  ///< USBFSRST
        constexpr uint32_t UCPD1RST = (1U << 23);  ///< UCPD1RST
    }

    /// APB2RSTR Register bits
    namespace apb2rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< System configuration (SYSCFG) reset
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset
        constexpr uint32_t TIM8RST = (1U << 13);  ///< TIM8 timer reset
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 timer reset
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 timer reset
        constexpr uint32_t SAI1RST = (1U << 21);  ///< Serial audio interface 1 (SAI1) reset
        constexpr uint32_t SAI2RST = (1U << 22);  ///< Serial audio interface 2 (SAI2) reset
        constexpr uint32_t DFSDM1RST = (1U << 24);  ///< Digital filters for sigma-delata modulators (DFSDM) reset
    }

    /// AHB1ENR Register bits
    namespace ahb1enr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 clock enable
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 clock enable
        constexpr uint32_t DMAMUX1EN = (1U << 2);  ///< DMAMUX clock enable
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable
        constexpr uint32_t TSCEN = (1U << 16);  ///< Touch Sensing Controller clock enable
        constexpr uint32_t GTZCEN = (1U << 22);  ///< GTZCEN
    }

    /// AHB2ENR Register bits
    namespace ahb2enr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< IO port A clock enable
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< IO port B clock enable
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< IO port C clock enable
        constexpr uint32_t GPIODEN = (1U << 3);  ///< IO port D clock enable
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< IO port E clock enable
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< IO port F clock enable
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< IO port G clock enable
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< IO port H clock enable
        constexpr uint32_t ADCEN = (1U << 13);  ///< ADC clock enable
        constexpr uint32_t AESEN = (1U << 16);  ///< AES accelerator clock enable
        constexpr uint32_t HASHEN = (1U << 17);  ///< HASH clock enable
        constexpr uint32_t RNGEN = (1U << 18);  ///< Random Number Generator clock enable
        constexpr uint32_t PKAEN = (1U << 19);  ///< PKAEN
        constexpr uint32_t OTFDEC1EN = (1U << 21);  ///< OTFDEC1EN
        constexpr uint32_t SDMMC1EN = (1U << 22);  ///< SDMMC1 clock enable
    }

    /// AHB3ENR Register bits
    namespace ahb3enr_bits {
        constexpr uint32_t FMCEN = (1U << 0);  ///< Flexible memory controller clock enable
        constexpr uint32_t OSPI1EN = (1U << 8);  ///< OSPI1EN
    }

    /// APB1ENR1 Register bits
    namespace apb1enr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 timer clock enable
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 timer clock enable
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 timer clock enable
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 timer clock enable
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 timer clock enable
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable
        constexpr uint32_t WWDGEN = (1U << 11);  ///< Window watchdog clock enable
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable
        constexpr uint32_t SP3EN = (1U << 15);  ///< SPI3 clock enable
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 clock enable
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 clock enable
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 clock enable
        constexpr uint32_t CRSEN = (1U << 24);  ///< Clock Recovery System clock enable
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable
        constexpr uint32_t DAC1EN = (1U << 29);  ///< DAC1 interface clock enable
        constexpr uint32_t OPAMPEN = (1U << 30);  ///< OPAMP interface clock enable
        constexpr uint32_t LPTIM1EN = (1U << 31);  ///< Low power timer 1 clock enable
    }

    /// APB1ENR2 Register bits
    namespace apb1enr2_bits {
        constexpr uint32_t LPUART1EN = (1U << 0);  ///< Low power UART 1 clock enable
        constexpr uint32_t I2C4EN = (1U << 1);  ///< I2C4 clock enable
        constexpr uint32_t LPTIM2EN = (1U << 5);  ///< LPTIM2EN
        constexpr uint32_t LPTIM3EN = (1U << 6);  ///< LPTIM3EN
        constexpr uint32_t FDCAN1EN = (1U << 9);  ///< FDCAN1EN
        constexpr uint32_t USBFSEN = (1U << 21);  ///< USBFSEN
        constexpr uint32_t UCPD1EN = (1U << 23);  ///< UCPD1EN
    }

    /// APB2ENR Register bits
    namespace apb2enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG clock enable
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable
        constexpr uint32_t TIM8EN = (1U << 13);  ///< TIM8 timer clock enable
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1clock enable
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 timer clock enable
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 timer clock enable
        constexpr uint32_t SAI1EN = (1U << 21);  ///< SAI1 clock enable
        constexpr uint32_t SAI2EN = (1U << 22);  ///< SAI2 clock enable
        constexpr uint32_t DFSDM1EN = (1U << 24);  ///< DFSDM timer clock enable
    }

    /// AHB1SMENR Register bits
    namespace ahb1smenr_bits {
        constexpr uint32_t DMA1SMEN = (1U << 0);  ///< DMA1 clocks enable during Sleep and Stop modes
        constexpr uint32_t DMA2SMEN = (1U << 1);  ///< DMA2 clocks enable during Sleep and Stop modes
        constexpr uint32_t DMAMUX1SMEN = (1U << 2);  ///< DMAMUX clock enable during Sleep and Stop modes
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clocks enable during Sleep and Stop modes
        constexpr uint32_t SRAM1SMEN = (1U << 9);  ///< SRAM1 interface clocks enable during Sleep and Stop modes
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRCSMEN
        constexpr uint32_t TSCSMEN = (1U << 16);  ///< Touch Sensing Controller clocks enable during Sleep and Stop modes
        constexpr uint32_t GTZCSMEN = (1U << 22);  ///< GTZCSMEN
        constexpr uint32_t ICACHESMEN = (1U << 23);  ///< ICACHESMEN
    }

    /// AHB2SMENR Register bits
    namespace ahb2smenr_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< IO port A clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< IO port B clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< IO port C clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< IO port D clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< IO port E clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< IO port F clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIOGSMEN = (1U << 6);  ///< IO port G clocks enable during Sleep and Stop modes
        constexpr uint32_t GPIOHSMEN = (1U << 7);  ///< IO port H clocks enable during Sleep and Stop modes
        constexpr uint32_t SRAM2SMEN = (1U << 9);  ///< SRAM2 interface clocks enable during Sleep and Stop modes
        constexpr uint32_t ADCFSSMEN = (1U << 13);  ///< ADC clocks enable during Sleep and Stop modes
        constexpr uint32_t AESSMEN = (1U << 16);  ///< AES accelerator clocks enable during Sleep and Stop modes
        constexpr uint32_t HASHSMEN = (1U << 17);  ///< HASH clock enable during Sleep and Stop modes
        constexpr uint32_t RNGSMEN = (1U << 18);  ///< Random Number Generator clocks enable during Sleep and Stop modes
        constexpr uint32_t PKASMEN = (1U << 19);  ///< PKASMEN
        constexpr uint32_t OTFDEC1SMEN = (1U << 21);  ///< OTFDEC1SMEN
        constexpr uint32_t SDMMC1SMEN = (1U << 22);  ///< SDMMC1 clocks enable during Sleep and Stop modes
    }

    /// AHB3SMENR Register bits
    namespace ahb3smenr_bits {
        constexpr uint32_t FMCSMEN = (1U << 0);  ///< Flexible memory controller clocks enable during Sleep and Stop modes
        constexpr uint32_t OSPI1SMEN = (1U << 8);  ///< OSPI1SMEN
    }

    /// APB1SMENR1 Register bits
    namespace apb1smenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM5SMEN = (1U << 3);  ///< TIM5 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep and Stop modes
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< Window watchdog clocks enable during Sleep and Stop modes
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clocks enable during Sleep and Stop modes
        constexpr uint32_t SP3SMEN = (1U << 15);  ///< SPI3 clocks enable during Sleep and Stop modes
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clocks enable during Sleep and Stop modes
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clocks enable during Sleep and Stop modes
        constexpr uint32_t UART4SMEN = (1U << 19);  ///< UART4 clocks enable during Sleep and Stop modes
        constexpr uint32_t UART5SMEN = (1U << 20);  ///< UART5 clocks enable during Sleep and Stop modes
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clocks enable during Sleep and Stop modes
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clocks enable during Sleep and Stop modes
        constexpr uint32_t I2C3SMEN = (1U << 23);  ///< I2C3 clocks enable during Sleep and Stop modes
        constexpr uint32_t CRSSMEN = (1U << 24);  ///< CRS clock enable during Sleep and Stop modes
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clocks enable during Sleep and Stop modes
        constexpr uint32_t DAC1SMEN = (1U << 29);  ///< DAC1 interface clocks enable during Sleep and Stop modes
        constexpr uint32_t OPAMPSMEN = (1U << 30);  ///< OPAMP interface clocks enable during Sleep and Stop modes
        constexpr uint32_t LPTIM1SMEN = (1U << 31);  ///< Low power timer 1 clocks enable during Sleep and Stop modes
    }

    /// APB1SMENR2 Register bits
    namespace apb1smenr2_bits {
        constexpr uint32_t LPUART1SMEN = (1U << 0);  ///< Low power UART 1 clocks enable during Sleep and Stop modes
        constexpr uint32_t I2C4SMEN = (1U << 1);  ///< I2C4 clocks enable during Sleep and Stop modes
        constexpr uint32_t LPTIM2SMEN = (1U << 5);  ///< LPTIM2SMEN
        constexpr uint32_t LPTIM3SMEN = (1U << 6);  ///< LPTIM3SMEN
        constexpr uint32_t FDCAN1SMEN = (1U << 9);  ///< FDCAN1SMEN
        constexpr uint32_t USBFSSMEN = (1U << 21);  ///< USBFSSMEN
        constexpr uint32_t UCPD1SMEN = (1U << 23);  ///< UCPD1SMEN
    }

    /// APB2SMENR Register bits
    namespace apb2smenr_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM8SMEN = (1U << 13);  ///< TIM8 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM17 timer clocks enable during Sleep and Stop modes
        constexpr uint32_t SAI1SMEN = (1U << 21);  ///< SAI1 clocks enable during Sleep and Stop modes
        constexpr uint32_t SAI2SMEN = (1U << 22);  ///< SAI2 clocks enable during Sleep and Stop modes
        constexpr uint32_t DFSDM1SMEN = (1U << 24);  ///< DFSDM timer clocks enable during Sleep and Stop modes
    }

    /// CCIPR1 Register bits
    namespace ccipr1_bits {
        constexpr uint32_t ADCSEL = (2 << 28);  ///< ADCs clock source selection
        constexpr uint32_t CLK48MSEL = (2 << 26);  ///< 48 MHz clock source selection
        constexpr uint32_t FDCANSEL = (2 << 24);  ///< FDCAN clock source selection
        constexpr uint32_t LPTIM3SEL = (2 << 22);  ///< Low-power timer 3 clock source selection
        constexpr uint32_t LPTIM2SEL = (2 << 20);  ///< Low power timer 2 clock source selection
        constexpr uint32_t LPTIM1SEL = (2 << 18);  ///< Low power timer 1 clock source selection
        constexpr uint32_t I2C3SEL = (2 << 16);  ///< I2C3 clock source selection
        constexpr uint32_t I2C2SEL = (2 << 14);  ///< I2C2 clock source selection
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection
        constexpr uint32_t LPUART1SEL = (2 << 10);  ///< LPUART1 clock source selection
        constexpr uint32_t UART5SEL = (2 << 8);  ///< UART5 clock source selection
        constexpr uint32_t UART4SEL = (2 << 6);  ///< UART4 clock source selection
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 clock source selection
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 clock source selection
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection
    }

    /// BDCR Register bits
    namespace bdcr_bits {
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low speed clock output selection
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low speed clock output enable
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable
        constexpr uint32_t LSESYSRDY = (1U << 11);  ///< LSESYSRDY
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection
        constexpr uint32_t LSESYSEN = (1U << 7);  ///< LSESYSEN
        constexpr uint32_t LSECSSD = (1U << 6);  ///< LSECSSD
        constexpr uint32_t LSECSSON = (1U << 5);  ///< LSECSSON
        constexpr uint32_t LSEDRV = (2 << 3);  ///< SE oscillator drive capability
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t LPWRSTF = (1U << 31);  ///< Low-power reset flag
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag
        constexpr uint32_t IWWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag
        constexpr uint32_t BORRSTF = (1U << 27);  ///< BOR flag
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flag
        constexpr uint32_t MSISRANGE = (4 << 8);  ///< SI range after Standby mode
        constexpr uint32_t LSIPREDIV = (1U << 4);  ///< LSIPREDIV
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable
    }

    /// CRRCR Register bits
    namespace crrcr_bits {
        constexpr uint32_t HSI48ON = (1U << 0);  ///< HSI48 clock enable
        constexpr uint32_t HSI48RDY = (1U << 1);  ///< HSI48 clock ready flag
        constexpr uint32_t HSI48CAL = (9 << 7);  ///< HSI48 clock calibration
    }

    /// CCIPR2 Register bits
    namespace ccipr2_bits {
        constexpr uint32_t I2C4SEL = (2 << 0);  ///< I2C4 clock source selection
        constexpr uint32_t DFSDMSEL = (1U << 2);  ///< Digital filter for sigma delta modulator kernel clock source selection
        constexpr uint32_t ADFSDMSEL = (2 << 3);  ///< Digital filter for sigma delta modulator audio clock source selection
        constexpr uint32_t SAI1SEL = (3 << 5);  ///< SAI1 clock source selection
        constexpr uint32_t SAI2SEL = (3 << 8);  ///< SAI2 clock source selection
        constexpr uint32_t SDMMCSEL = (1U << 14);  ///< SDMMC clock selection
        constexpr uint32_t OSPISEL = (2 << 20);  ///< Octospi clock source selection
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t HSISEC = (1U << 0);  ///< HSISEC
        constexpr uint32_t HSESEC = (1U << 1);  ///< HSESEC
        constexpr uint32_t MSISEC = (1U << 2);  ///< MSISEC
        constexpr uint32_t LSISEC = (1U << 3);  ///< LSISEC
        constexpr uint32_t LSESEC = (1U << 4);  ///< LSESEC
        constexpr uint32_t SYSCLKSEC = (1U << 5);  ///< SYSCLKSEC
        constexpr uint32_t PRESCSEC = (1U << 6);  ///< PRESCSEC
        constexpr uint32_t PLLSEC = (1U << 7);  ///< PLLSEC
        constexpr uint32_t PLLSAI1SEC = (1U << 8);  ///< PLLSAI1SEC
        constexpr uint32_t PLLSAI2SEC = (1U << 9);  ///< PLLSAI2SEC
        constexpr uint32_t CLK48MSEC = (1U << 10);  ///< CLK48MSEC
        constexpr uint32_t HSI48SEC = (1U << 11);  ///< HSI48SEC
        constexpr uint32_t RMVFSEC = (1U << 12);  ///< RMVFSEC
    }

    /// SECSR Register bits
    namespace secsr_bits {
        constexpr uint32_t RMVFSECF = (1U << 12);  ///< RMVFSECF
        constexpr uint32_t HSI48SECF = (1U << 11);  ///< HSI48SECF
        constexpr uint32_t CLK48MSECF = (1U << 10);  ///< CLK48MSECF
        constexpr uint32_t PLLSAI2SECF = (1U << 9);  ///< PLLSAI2SECF
        constexpr uint32_t PLLSAI1SECF = (1U << 8);  ///< PLLSAI1SECF
        constexpr uint32_t PLLSECF = (1U << 7);  ///< PLLSECF
        constexpr uint32_t PRESCSECF = (1U << 6);  ///< PRESCSECF
        constexpr uint32_t SYSCLKSECF = (1U << 5);  ///< SYSCLKSECF
        constexpr uint32_t LSESECF = (1U << 4);  ///< LSESECF
        constexpr uint32_t LSISECF = (1U << 3);  ///< LSISECF
        constexpr uint32_t MSISECF = (1U << 2);  ///< MSISECF
        constexpr uint32_t HSESECF = (1U << 1);  ///< HSESECF
        constexpr uint32_t HSISECF = (1U << 0);  ///< HSISECF
    }

    /// AHB1SECSR Register bits
    namespace ahb1secsr_bits {
        constexpr uint32_t ICACHESECF = (1U << 23);  ///< ICACHESECF
        constexpr uint32_t GTZCSECF = (1U << 22);  ///< GTZCSECF
        constexpr uint32_t TSCSECF = (1U << 16);  ///< TSCSECF
        constexpr uint32_t CRCSECF = (1U << 12);  ///< CRCSECF
        constexpr uint32_t SRAM1SECF = (1U << 9);  ///< SRAM1SECF
        constexpr uint32_t FLASHSECF = (1U << 8);  ///< FLASHSECF
        constexpr uint32_t DMAMUX1SECF = (1U << 2);  ///< DMAMUX1SECF
        constexpr uint32_t DMA2SECF = (1U << 1);  ///< DMA2SECF
        constexpr uint32_t DMA1SECF = (1U << 0);  ///< DMA1SECF
    }

    /// AHB2SECSR Register bits
    namespace ahb2secsr_bits {
        constexpr uint32_t SDMMC1SECF = (1U << 22);  ///< SDMMC1SECF
        constexpr uint32_t OTFDEC1SECF = (1U << 21);  ///< OTFDEC1SECF
        constexpr uint32_t SRAM2SECF = (1U << 9);  ///< SRAM2SECF
        constexpr uint32_t GPIOHSECF = (1U << 7);  ///< GPIOHSECF
        constexpr uint32_t GPIOGSECF = (1U << 6);  ///< GPIOGSECF
        constexpr uint32_t GPIOFSECF = (1U << 5);  ///< GPIOFSECF
        constexpr uint32_t GPIOESECF = (1U << 4);  ///< GPIOESECF
        constexpr uint32_t GPIODSECF = (1U << 3);  ///< GPIODSECF
        constexpr uint32_t GPIOCSECF = (1U << 2);  ///< GPIOCSECF
        constexpr uint32_t GPIOBSECF = (1U << 1);  ///< GPIOBSECF
        constexpr uint32_t GPIOASECF = (1U << 0);  ///< GPIOASECF
    }

    /// AHB3SECSR Register bits
    namespace ahb3secsr_bits {
        constexpr uint32_t OSPI1SECF = (1U << 8);  ///< OSPI1SECF
        constexpr uint32_t FSMCSECF = (1U << 0);  ///< FSMCSECF
    }

    /// APB1SECSR1 Register bits
    namespace apb1secsr1_bits {
        constexpr uint32_t LPTIM1SECF = (1U << 31);  ///< LPTIM1SECF
        constexpr uint32_t OPAMPSECF = (1U << 30);  ///< OPAMPSECF
        constexpr uint32_t DACSECF = (1U << 29);  ///< DACSECF
        constexpr uint32_t PWRSECF = (1U << 28);  ///< PWRSECF
        constexpr uint32_t CRSSECF = (1U << 24);  ///< CRSSECF
        constexpr uint32_t I2C3SECF = (1U << 23);  ///< I2C3SECF
        constexpr uint32_t I2C2SECF = (1U << 22);  ///< I2C2SECF
        constexpr uint32_t I2C1SECF = (1U << 21);  ///< I2C1SECF
        constexpr uint32_t UART5SECF = (1U << 20);  ///< UART5SECF
        constexpr uint32_t UART4SECF = (1U << 19);  ///< UART4SECF
        constexpr uint32_t UART3SECF = (1U << 18);  ///< UART3SECF
        constexpr uint32_t UART2SECF = (1U << 17);  ///< UART2SECF
        constexpr uint32_t SPI3SECF = (1U << 15);  ///< SPI3SECF
        constexpr uint32_t SPI2SECF = (1U << 14);  ///< SPI2SECF
        constexpr uint32_t WWDGSECF = (1U << 11);  ///< WWDGSECF
        constexpr uint32_t RTCAPBSECF = (1U << 10);  ///< RTCAPBSECF
        constexpr uint32_t TIM7SECF = (1U << 5);  ///< TIM7SECF
        constexpr uint32_t TIM6SECF = (1U << 4);  ///< TIM6SECF
        constexpr uint32_t TIM5SECF = (1U << 3);  ///< TIM5SECF
        constexpr uint32_t TIM4SECF = (1U << 2);  ///< TIM4SECF
        constexpr uint32_t TIM3SECF = (1U << 1);  ///< TIM3SECF
        constexpr uint32_t TIM2SECF = (1U << 0);  ///< TIM2SECF
    }

    /// APB1SECSR2 Register bits
    namespace apb1secsr2_bits {
        constexpr uint32_t UCPD1SECF = (1U << 23);  ///< UCPD1SECF
        constexpr uint32_t USBFSSECF = (1U << 21);  ///< USBFSSECF
        constexpr uint32_t FDCAN1SECF = (1U << 9);  ///< FDCAN1SECF
        constexpr uint32_t LPTIM3SECF = (1U << 6);  ///< LPTIM3SECF
        constexpr uint32_t LPTIM2SECF = (1U << 5);  ///< LPTIM2SECF
        constexpr uint32_t I2C4SECF = (1U << 1);  ///< I2C4SECF
        constexpr uint32_t LPUART1SECF = (1U << 0);  ///< LPUART1SECF
    }

    /// APB2SECSR Register bits
    namespace apb2secsr_bits {
        constexpr uint32_t DFSDM1SECF = (1U << 24);  ///< DFSDM1SECF
        constexpr uint32_t SAI2SECF = (1U << 22);  ///< SAI2SECF
        constexpr uint32_t SAI1SECF = (1U << 21);  ///< SAI1SECF
        constexpr uint32_t TIM17SECF = (1U << 18);  ///< TIM17SECF
        constexpr uint32_t TIM16SECF = (1U << 17);  ///< TIM16SECF
        constexpr uint32_t TIM15SECF = (1U << 16);  ///< TIM15SECF
        constexpr uint32_t USART1SECF = (1U << 14);  ///< USART1SECF
        constexpr uint32_t TIM8SECF = (1U << 13);  ///< TIM8SECF
        constexpr uint32_t SPI1SECF = (1U << 12);  ///< SPI1SECF
        constexpr uint32_t TIM1SECF = (1U << 11);  ///< TIM1SECF
        constexpr uint32_t SYSCFGSECF = (1U << 0);  ///< SYSCFGSECF
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;
    constexpr uint32_t SEC_RTC_BASE = 0x50002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - RTC control register
        volatile uint32_t PRIVCR;  ///< Offset: 0x1C - RTC privilege mode control register
        volatile uint32_t SMCR;  ///< Offset: 0x20 - RTC secure mode control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - RTC non-secure masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x58 - RTC secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - RTC status clear register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);
    inline Registers* SEC_RTC = reinterpret_cast<Registers*>(SEC_RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< SS
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t ALRAWF = (1U << 0);  ///< Alarm A write flag
        constexpr uint32_t ALRBWF = (1U << 1);  ///< Alarm B write flag
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
        constexpr uint32_t WUTOCLR = (16 << 16);  ///< WUTOCLR
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< WUCKSEL
        constexpr uint32_t TSEDGE = (1U << 3);  ///< TSEDGE
        constexpr uint32_t REFCKON = (1U << 4);  ///< REFCKON
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< BYPSHAD
        constexpr uint32_t FMT = (1U << 6);  ///< FMT
        constexpr uint32_t ALRAE = (1U << 8);  ///< ALRAE
        constexpr uint32_t ALRBE = (1U << 9);  ///< ALRBE
        constexpr uint32_t WUTE = (1U << 10);  ///< WUTE
        constexpr uint32_t TSE = (1U << 11);  ///< TSE
        constexpr uint32_t ALRAIE = (1U << 12);  ///< ALRAIE
        constexpr uint32_t ALRBIE = (1U << 13);  ///< ALRBIE
        constexpr uint32_t WUTIE = (1U << 14);  ///< WUTIE
        constexpr uint32_t TSIE = (1U << 15);  ///< TSIE
        constexpr uint32_t ADD1H = (1U << 16);  ///< ADD1H
        constexpr uint32_t SUB1H = (1U << 17);  ///< SUB1H
        constexpr uint32_t BKP = (1U << 18);  ///< BKP
        constexpr uint32_t COSEL = (1U << 19);  ///< COSEL
        constexpr uint32_t POL = (1U << 20);  ///< POL
        constexpr uint32_t OSEL = (2 << 21);  ///< OSEL
        constexpr uint32_t COE = (1U << 23);  ///< COE
        constexpr uint32_t ITSE = (1U << 24);  ///< ITSE
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t PRIV = (1U << 15);  ///< PRIV
        constexpr uint32_t INITPRIV = (1U << 14);  ///< INITPRIV
        constexpr uint32_t CALPRIV = (1U << 13);  ///< CALPRIV
        constexpr uint32_t TSPRIV = (1U << 3);  ///< TSPRIV
        constexpr uint32_t WUTPRIV = (1U << 2);  ///< WUTPRIV
        constexpr uint32_t ALRBPRIV = (1U << 1);  ///< ALRBPRIV
        constexpr uint32_t ALRAPRIV = (1U << 0);  ///< ALRAPRIV
    }

    /// SMCR Register bits
    namespace smcr_bits {
        constexpr uint32_t DECPROT = (1U << 15);  ///< DECPROT
        constexpr uint32_t INITDPROT = (1U << 14);  ///< INITDPROT
        constexpr uint32_t CALDPROT = (1U << 13);  ///< CALDPROT
        constexpr uint32_t TSDPROT = (1U << 3);  ///< TSDPROT
        constexpr uint32_t WUTDPROT = (1U << 2);  ///< WUTDPROT
        constexpr uint32_t ALRBDPROT = (1U << 1);  ///< ALRBDPROT
        constexpr uint32_t ALRADPROT = (1U << 0);  ///< ALRADPROT
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t LPCAL = (1U << 12);  ///< LPCAL
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (16 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t MASKSS = (4 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40015400;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x24 - BConfiguration register 1
        volatile uint32_t BCR2;  ///< Offset: 0x28 - BConfiguration register 2
        volatile uint32_t BFRCR;  ///< Offset: 0x2C - BFRCR
        volatile uint32_t BSLOTR;  ///< Offset: 0x30 - BSlot register
        volatile uint32_t BIM;  ///< Offset: 0x34 - BInterrupt mask register2
        volatile uint32_t BSR;  ///< Offset: 0x38 - BStatus register
        volatile uint32_t BCLRFR;  ///< Offset: 0x3C - BClear flag register
        volatile uint32_t BDR;  ///< Offset: 0x40 - BData register
        volatile uint32_t ACR1;  ///< Offset: 0x04 - AConfiguration register 1
        volatile uint32_t ACR2;  ///< Offset: 0x08 - AConfiguration register 2
        volatile uint32_t AFRCR;  ///< Offset: 0x0C - AFRCR
        volatile uint32_t ASLOTR;  ///< Offset: 0x10 - ASlot register
        volatile uint32_t AIM;  ///< Offset: 0x14 - AInterrupt mask register2
        volatile uint32_t ASR;  ///< Offset: 0x18 - AStatus register
        volatile uint32_t ACLRFR;  ///< Offset: 0x1C - AClear flag register
        volatile uint32_t ADR;  ///< Offset: 0x20 - AData register
        volatile uint32_t GCR;  ///< Offset: 0x00 - Global configuration register
        volatile uint32_t PDMCR;  ///< Offset: 0x44 - PDM control register
        volatile uint32_t PDMDLY;  ///< Offset: 0x48 - PDM delay register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MCJDIV = (4 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIBEN = (1U << 16);  ///< Audio block B enable
        constexpr uint32_t OutDri = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
        constexpr uint32_t OSR = (1U << 26);  ///< Oversampling ratio for master clock
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUS = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// BFRCR Register bits
    namespace bfrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// BSLOTR Register bits
    namespace bslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// BIM Register bits
    namespace bim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// BCLRFR Register bits
    namespace bclrfr_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// BDR Register bits
    namespace bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// ACR1 Register bits
    namespace acr1_bits {
        constexpr uint32_t MCJDIV = (4 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OutDri = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
    }

    /// ACR2 Register bits
    namespace acr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUS = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// AFRCR Register bits
    namespace afrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// ASLOTR Register bits
    namespace aslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// AIM Register bits
    namespace aim_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// ASR Register bits
    namespace asr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// ACLRFR Register bits
    namespace aclrfr_bits {
        constexpr uint32_t LFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// ADR Register bits
    namespace adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t SYNCIN = (2 << 0);  ///< Synchronization inputs
        constexpr uint32_t SYNCOUT = (2 << 4);  ///< Synchronization outputs
    }

    /// PDMCR Register bits
    namespace pdmcr_bits {
        constexpr uint32_t PDMEN = (1U << 0);  ///< PDM enable
        constexpr uint32_t MICNBR = (2 << 4);  ///< MICNBR
        constexpr uint32_t CKEN1 = (1U << 8);  ///< Clock enable of bitstream clock number 1
        constexpr uint32_t CKEN2 = (1U << 9);  ///< CKEN2
    }

    /// PDMDLY Register bits
    namespace pdmdly_bits {
        constexpr uint32_t DLYM1L = (3 << 0);  ///< Delay line adjust for first microphone of pair 1
        constexpr uint32_t DLYM1R = (3 << 4);  ///< Delay line adjust for second microphone of pair 1
        constexpr uint32_t DLYM2L = (3 << 8);  ///< Delay line for first microphone of pair 2
        constexpr uint32_t DLYM2R = (3 << 12);  ///< Delay line for second microphone of pair 2
        constexpr uint32_t DLYM3L = (3 << 16);  ///< DLYM3L
        constexpr uint32_t DLYM3R = (3 << 20);  ///< DLYM3R
        constexpr uint32_t DLYM4L = (3 << 24);  ///< DLYM4L
        constexpr uint32_t DLYM4R = (3 << 28);  ///< DLYM4R
    }

}

// ============================================================================
// SAI2 Peripheral
// ============================================================================

namespace sai2 {
    /// Base addresses
    constexpr uint32_t SAI2_BASE = 0x40015800;

    /// SAI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI2 = reinterpret_cast<Registers*>(SAI2_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SPI3_BASE = 0x40003C00;
    constexpr uint32_t SEC_SPI1_BASE = 0x50013000;
    constexpr uint32_t SEC_SPI2_BASE = 0x50003800;
    constexpr uint32_t SEC_SPI3_BASE = 0x50003C00;
    constexpr uint32_t OCTOSPI1_BASE = 0x44021000;
    constexpr uint32_t SEC_OCTOSPI1_BASE = 0x54021000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t SR;  ///< Offset: 0x08 - status register
        volatile uint32_t DR;  ///< Offset: 0x0C - data register
        volatile uint32_t CRCPR;  ///< Offset: 0x10 - CRC polynomial register
        volatile uint32_t RXCRCR;  ///< Offset: 0x14 - RX CRC register
        volatile uint32_t TXCRCR;  ///< Offset: 0x18 - TX CRC register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SEC_SPI1 = reinterpret_cast<Registers*>(SEC_SPI1_BASE);
    inline Registers* SEC_SPI2 = reinterpret_cast<Registers*>(SEC_SPI2_BASE);
    inline Registers* SEC_SPI3 = reinterpret_cast<Registers*>(SEC_SPI3_BASE);
    inline Registers* OCTOSPI1 = reinterpret_cast<Registers*>(OCTOSPI1_BASE);
    inline Registers* SEC_OCTOSPI1 = reinterpret_cast<Registers*>(SEC_OCTOSPI1_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< CRC transfer next
        constexpr uint32_t DFF = (1U << 11);  ///< Data frame format
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag
        constexpr uint32_t TIFRFE = (1U << 8);  ///< TI frame format error
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register
    }

    /// CRCPR Register bits
    namespace crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register
    }

    /// RXCRCR Register bits
    namespace rxcrcr_bits {
        constexpr uint32_t RxCRC = (16 << 0);  ///< Rx CRC register
    }

    /// TXCRCR Register bits
    namespace txcrcr_bits {
        constexpr uint32_t TxCRC = (16 << 0);  ///< Tx CRC register
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;
    constexpr uint32_t SEC_DAC_BASE = 0x50007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC Sample and Hold sample time register 2
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);
    inline Registers* SEC_DAC = reinterpret_cast<Registers*>(SEC_DAC_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL10 = (1U << 2);  ///< TSEL10
        constexpr uint32_t TSEL11 = (1U << 3);  ///< TSEL11
        constexpr uint32_t TSEL12 = (1U << 4);  ///< TSEL12
        constexpr uint32_t TSEL13 = (1U << 5);  ///< TSEL13
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
        constexpr uint32_t HFSEL = (1U << 15);  ///< HFSEL
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL20 = (1U << 18);  ///< TSEL20
        constexpr uint32_t TSEL21 = (1U << 19);  ///< TSEL21
        constexpr uint32_t TSEL22 = (1U << 20);  ///< TSEL22
        constexpr uint32_t TSEL23 = (1U << 21);  ///< TSEL23
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x40007800;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP1_CSR;  ///< Offset: 0x00 - OPAMP1 control/status register
        volatile uint32_t OPAMP1_OTR;  ///< Offset: 0x04 - OPAMP1 offset trimming register in normal mode
        volatile uint32_t OPAMP1_LPOTR;  ///< Offset: 0x08 - OPAMP1 offset trimming register in low-powe mode
        volatile uint32_t OPAMP2_CRS;  ///< Offset: 0x10 - OPAMP2 control/status register
        volatile uint32_t OPAMP2_OTR;  ///< Offset: 0x14 - OPAMP2 offset trimming register in normal mode
        volatile uint32_t OPAMP2_LPOTR;  ///< Offset: 0x18 - OPAMP2 offset trimming register in low-power mode
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP1_CSR Register bits
    namespace opamp1_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< Operational amplifier Low Power Mode
        constexpr uint32_t OPAMODE = (2 << 2);  ///< Operational amplifier PGA mode
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< Operational amplifier Programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< inverting input selection
        constexpr uint32_t VP_SEL = (1U << 10);  ///< non inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< User trimming enable
        constexpr uint32_t CALOUT = (1U << 15);  ///< Operational amplifier calibration output
        constexpr uint32_t OPA_RANGE = (1U << 31);  ///< Operational amplifier power supply range for stability
    }

    /// OPAMP1_OTR Register bits
    namespace opamp1_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP1_LPOTR Register bits
    namespace opamp1_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_CRS Register bits
    namespace opamp2_crs_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< Operational amplifier Low Power Mode
        constexpr uint32_t OPAMODE = (2 << 2);  ///< Operational amplifier PGA mode
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< Operational amplifier Programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< inverting input selection
        constexpr uint32_t VP_SEL = (1U << 10);  ///< non inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< User trimming enable
        constexpr uint32_t CALOUT = (1U << 15);  ///< Operational amplifier calibration output
    }

    /// OPAMP2_OTR Register bits
    namespace opamp2_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_LPOTR Register bits
    namespace opamp2_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x420C0000;
    constexpr uint32_t SEC_AES_BASE = 0x520C0000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DINR;  ///< Offset: 0x08 - data input register
        volatile uint32_t DOUTR;  ///< Offset: 0x0C - data output register
        volatile uint32_t KEYR0;  ///< Offset: 0x10 - key register 0
        volatile uint32_t KEYR1;  ///< Offset: 0x14 - key register 1
        volatile uint32_t KEYR2;  ///< Offset: 0x18 - key register 2
        volatile uint32_t KEYR3;  ///< Offset: 0x1C - key register 3
        volatile uint32_t IVR0;  ///< Offset: 0x20 - initialization vector register 0
        volatile uint32_t IVR1;  ///< Offset: 0x24 - initialization vector register 1
        volatile uint32_t IVR2;  ///< Offset: 0x28 - initialization vector register 2
        volatile uint32_t IVR3;  ///< Offset: 0x2C - initialization vector register 3
        volatile uint32_t KEYR4;  ///< Offset: 0x30 - key register 4
        volatile uint32_t KEYR5;  ///< Offset: 0x34 - key register 5
        volatile uint32_t KEYR6;  ///< Offset: 0x38 - key register 6
        volatile uint32_t KEYR7;  ///< Offset: 0x3C - key register 7
        volatile uint32_t SUSP0R;  ///< Offset: 0x40 - AES suspend register 0
        volatile uint32_t SUSP1R;  ///< Offset: 0x44 - AES suspend register 1
        volatile uint32_t SUSP2R;  ///< Offset: 0x48 - AES suspend register 2
        volatile uint32_t SUSP3R;  ///< Offset: 0x4C - AES suspend register 3
        volatile uint32_t SUSP4R;  ///< Offset: 0x50 - AES suspend register 4
        volatile uint32_t SUSP5R;  ///< Offset: 0x54 - AES suspend register 5
        volatile uint32_t SUSP6R;  ///< Offset: 0x58 - AES suspend register 6
        volatile uint32_t SUSP7R;  ///< Offset: 0x5C - AES suspend register 7
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* SEC_AES = reinterpret_cast<Registers*>(SEC_AES_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t NPBLB = (4 << 20);  ///< Number of padding bytes in last block of payload
        constexpr uint32_t KEYSIZE = (1U << 18);  ///< Key size selection
        constexpr uint32_t CHMOD2 = (1U << 16);  ///< AES chaining mode Bit2
        constexpr uint32_t GCMPH = (2 << 13);  ///< Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected
        constexpr uint32_t DMAOUTEN = (1U << 12);  ///< Enable DMA management of data output phase
        constexpr uint32_t DMAINEN = (1U << 11);  ///< Enable DMA management of data input phase
        constexpr uint32_t ERRIE = (1U << 10);  ///< Error interrupt enable
        constexpr uint32_t CCFIE = (1U << 9);  ///< CCF flag interrupt enable
        constexpr uint32_t ERRC = (1U << 8);  ///< Error clear
        constexpr uint32_t CCFC = (1U << 7);  ///< Computation Complete Flag Clear
        constexpr uint32_t CHMOD = (2 << 5);  ///< AES chaining mode selection Bit1 Bit0
        constexpr uint32_t MODE = (2 << 3);  ///< AES operating mode
        constexpr uint32_t DATATYPE = (2 << 1);  ///< Data type selection (for data in and data out to/from the cryptographic block)
        constexpr uint32_t EN = (1U << 0);  ///< AES enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy flag
        constexpr uint32_t WRERR = (1U << 2);  ///< Write error flag
        constexpr uint32_t RDERR = (1U << 1);  ///< Read error flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// DINR Register bits
    namespace dinr_bits {
        constexpr uint32_t DIN = (32 << 0);  ///< Data Input Register
    }

    /// DOUTR Register bits
    namespace doutr_bits {
        constexpr uint32_t DOUT = (32 << 0);  ///< Data output register
    }

    /// KEYR0 Register bits
    namespace keyr0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits[31:0]
    }

    /// KEYR1 Register bits
    namespace keyr1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [63:32])
    }

    /// KEYR2 Register bits
    namespace keyr2_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [95:64])
    }

    /// KEYR3 Register bits
    namespace keyr3_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [127:96])
    }

    /// IVR0 Register bits
    namespace ivr0_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< initialization vector register (LSB IVR [31:0])
    }

    /// IVR1 Register bits
    namespace ivr1_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization Vector Register (IVR [63:32])
    }

    /// IVR2 Register bits
    namespace ivr2_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization Vector Register (IVR [95:64])
    }

    /// IVR3 Register bits
    namespace ivr3_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization Vector Register (MSB IVR [127:96])
    }

    /// KEYR4 Register bits
    namespace keyr4_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [159:128])
    }

    /// KEYR5 Register bits
    namespace keyr5_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [191:160])
    }

    /// KEYR6 Register bits
    namespace keyr6_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [223:192])
    }

    /// KEYR7 Register bits
    namespace keyr7_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [255:224])
    }

    /// SUSP0R Register bits
    namespace susp0r_bits {
        constexpr uint32_t AES_SUSP0R = (32 << 0);  ///< AES suspend register 0
    }

    /// SUSP1R Register bits
    namespace susp1r_bits {
        constexpr uint32_t AES_SUSP1R = (32 << 0);  ///< AES suspend register 1
    }

    /// SUSP2R Register bits
    namespace susp2r_bits {
        constexpr uint32_t AES_SUSP2R = (32 << 0);  ///< AES suspend register 2
    }

    /// SUSP3R Register bits
    namespace susp3r_bits {
        constexpr uint32_t AES_SUSP3R = (32 << 0);  ///< AES suspend register 3
    }

    /// SUSP4R Register bits
    namespace susp4r_bits {
        constexpr uint32_t AES_SUSP4R = (32 << 0);  ///< AES suspend register 4
    }

    /// SUSP5R Register bits
    namespace susp5r_bits {
        constexpr uint32_t AES_SUSP5R = (32 << 0);  ///< AES suspend register 5
    }

    /// SUSP6R Register bits
    namespace susp6r_bits {
        constexpr uint32_t AES_SUSP6R = (32 << 0);  ///< AES suspend register 6
    }

    /// SUSP7R Register bits
    namespace susp7r_bits {
        constexpr uint32_t AES_SUSP7R = (32 << 0);  ///< AES suspend register 7
    }

}

// ============================================================================
// PKA Peripheral
// ============================================================================

namespace pka {
    /// Base addresses
    constexpr uint32_t PKA_BASE = 0x420C2000;

    /// PKA Register structure
    struct Registers {
        volatile uint32_t PKA_CR;  ///< Offset: 0x00 - PKA control register
        volatile uint32_t PKA_SR;  ///< Offset: 0x04 - PKA status register
        volatile uint32_t PKA_CLRFR;  ///< Offset: 0x08 - PKA clear flag register
    };

    /// Peripheral instances
    inline Registers* PKA = reinterpret_cast<Registers*>(PKA_BASE);

    // Bit definitions
    /// PKA_CR Register bits
    namespace pka_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< PKA Enable
        constexpr uint32_t START = (1U << 1);  ///< Start the operation
        constexpr uint32_t MODE = (6 << 8);  ///< PKA operation code
        constexpr uint32_t PROCENDIE = (1U << 17);  ///< End of operation interrupt enable
        constexpr uint32_t RAMERRIE = (1U << 19);  ///< RAM error interrupt enable
        constexpr uint32_t ADDRERRIE = (1U << 20);  ///< Address error interrupt enable
    }

    /// PKA_SR Register bits
    namespace pka_sr_bits {
        constexpr uint32_t BUSY = (1U << 16);  ///< PKA operation in progress
        constexpr uint32_t PROCENDF = (1U << 17);  ///< PKA end of operation flag
        constexpr uint32_t RAMERRF = (1U << 19);  ///< PKA ram error flag
        constexpr uint32_t ADDRERRF = (1U << 20);  ///< address er flag
    }

    /// PKA_CLRFR Register bits
    namespace pka_clrfr_bits {
        constexpr uint32_t PROCENDFC = (1U << 17);  ///< clear PKA end of operation flag
        constexpr uint32_t RAMERRFC = (1U << 19);  ///< CLEAR PKA RAM ERROR FLAG
        constexpr uint32_t ADDRERRFC = (1U << 20);  ///< clear address error flag
    }

}

// ============================================================================
// OTFDEC1 Peripheral
// ============================================================================

namespace otfdec1 {
    /// Base addresses
    constexpr uint32_t OTFDEC1_BASE = 0x420C5000;

    /// OTFDEC1 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OTFDEC control register
        volatile uint32_t R1CFGR;  ///< Offset: 0x20 - OTFDEC region x configuration register
        volatile uint32_t R2CFGR;  ///< Offset: 0x50 - OTFDEC region x configuration register
        volatile uint32_t R3CFGR;  ///< Offset: 0x80 - OTFDEC region x configuration register
        volatile uint32_t R4CFGR;  ///< Offset: 0xB0 - OTFDEC region x configuration register
        volatile uint32_t R1STARTADDR;  ///< Offset: 0x24 - OTFDEC region x start address register
        volatile uint32_t R2STARTADDR;  ///< Offset: 0x54 - OTFDEC region x start address register
        volatile uint32_t R3STARTADDR;  ///< Offset: 0x84 - OTFDEC region x start address register
        volatile uint32_t R4STARTADDR;  ///< Offset: 0xB4 - OTFDEC region x start address register
        volatile uint32_t R1ENDADDR;  ///< Offset: 0x28 - OTFDEC region x end address register
        volatile uint32_t R2ENDADDR;  ///< Offset: 0x58 - OTFDEC region x end address register
        volatile uint32_t R3ENDADDR;  ///< Offset: 0x88 - OTFDEC region x end address register
        volatile uint32_t R4ENDADDR;  ///< Offset: 0xB8 - OTFDEC region x end address register
        volatile uint32_t R1NONCER0;  ///< Offset: 0x2C - OTFDEC region x nonce register 0
        volatile uint32_t R2NONCER0;  ///< Offset: 0x5C - OTFDEC region x nonce register 0
        volatile uint32_t R3NONCER0;  ///< Offset: 0x8C - OTFDEC region x nonce register 0
        volatile uint32_t R4NONCER0;  ///< Offset: 0xBC - OTFDEC region x nonce register 0
        volatile uint32_t R1NONCER1;  ///< Offset: 0x30 - OTFDEC region x nonce register 1
        volatile uint32_t R2NONCER1;  ///< Offset: 0x60 - OTFDEC region x nonce register 1
        volatile uint32_t R3NONCER1;  ///< Offset: 0x90 - OTFDEC region x nonce register 1
        volatile uint32_t R4NONCER1;  ///< Offset: 0xC0 - OTFDEC region x nonce register 1
        volatile uint32_t R1KEYR0;  ///< Offset: 0x34 - OTFDEC region x key register 0
        volatile uint32_t R2KEYR0;  ///< Offset: 0x64 - OTFDEC region x key register 0
        volatile uint32_t R3KEYR0;  ///< Offset: 0x94 - OTFDEC region x key register 0
        volatile uint32_t R4KEYR0;  ///< Offset: 0xC4 - OTFDEC region x key register 0
        volatile uint32_t R1KEYR1;  ///< Offset: 0x38 - OTFDEC region x key register 1
        volatile uint32_t R2KEYR1;  ///< Offset: 0x68 - OTFDEC region x key register 1
        volatile uint32_t R3KEYR1;  ///< Offset: 0x98 - OTFDEC region x key register 1
        volatile uint32_t R4KEYR1;  ///< Offset: 0xC8 - OTFDEC region x key register 1
        volatile uint32_t R1KEYR2;  ///< Offset: 0x3C - OTFDEC region x key register 2
        volatile uint32_t R2KEYR2;  ///< Offset: 0x6C - OTFDEC region x key register 2
        volatile uint32_t R3KEYR2;  ///< Offset: 0x9C - OTFDEC region x key register 2
        volatile uint32_t R4KEYR2;  ///< Offset: 0xCC - OTFDEC region x key register 2
        volatile uint32_t R1KEYR3;  ///< Offset: 0x40 - OTFDEC region x key register 3
        volatile uint32_t R2KEYR3;  ///< Offset: 0x70 - OTFDEC region x key register 3
        volatile uint32_t R3KEYR3;  ///< Offset: 0xA0 - OTFDEC region x key register 3
        volatile uint32_t R4KEYR3;  ///< Offset: 0xD0 - OTFDEC region x key register 3
        volatile uint32_t ISR;  ///< Offset: 0x300 - OTFDEC interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x304 - OTFDEC interrupt clear register
        volatile uint32_t IER;  ///< Offset: 0x308 - OTFDEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* OTFDEC1 = reinterpret_cast<Registers*>(OTFDEC1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encryption mode bit
    }

    /// R1CFGR Register bits
    namespace r1cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R2CFGR Register bits
    namespace r2cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R3CFGR Register bits
    namespace r3cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R4CFGR Register bits
    namespace r4cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R1STARTADDR Register bits
    namespace r1startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R2STARTADDR Register bits
    namespace r2startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R3STARTADDR Register bits
    namespace r3startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R4STARTADDR Register bits
    namespace r4startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R1ENDADDR Register bits
    namespace r1endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R2ENDADDR Register bits
    namespace r2endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R3ENDADDR Register bits
    namespace r3endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R4ENDADDR Register bits
    namespace r4endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R1NONCER0 Register bits
    namespace r1noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R2NONCER0 Register bits
    namespace r2noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R3NONCER0 Register bits
    namespace r3noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R4NONCER0 Register bits
    namespace r4noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R1NONCER1 Register bits
    namespace r1noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< Region nonce
    }

    /// R2NONCER1 Register bits
    namespace r2noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< Region nonce, bits [63:32]REGx_NONCE[63:32]
    }

    /// R3NONCER1 Register bits
    namespace r3noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R4NONCER1 Register bits
    namespace r4noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R1KEYR0 Register bits
    namespace r1keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR0 Register bits
    namespace r2keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR0 Register bits
    namespace r3keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR0 Register bits
    namespace r4keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R1KEYR1 Register bits
    namespace r1keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR1 Register bits
    namespace r2keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR1 Register bits
    namespace r3keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR1 Register bits
    namespace r4keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R1KEYR2 Register bits
    namespace r1keyr2_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR2 Register bits
    namespace r2keyr2_bits {
        constexpr uint32_t REGx_KEY_ = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR2 Register bits
    namespace r3keyr2_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR2 Register bits
    namespace r4keyr2_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R1KEYR3 Register bits
    namespace r1keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR3 Register bits
    namespace r2keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR3 Register bits
    namespace r3keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR3 Register bits
    namespace r4keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t SEIF = (1U << 0);  ///< Security Error Interrupt Flag status
        constexpr uint32_t XONEIF = (1U << 1);  ///< Execute-only execute-Never Error Interrupt Flag status
        constexpr uint32_t KEIF = (1U << 2);  ///< Key Error Interrupt Flag status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t SEIF = (1U << 0);  ///< SEIF
        constexpr uint32_t XONEIF = (1U << 1);  ///< Execute-only execute-Never Error Interrupt Flag clear
        constexpr uint32_t KEIF = (1U << 2);  ///< KEIF
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< Security Error Interrupt Enable
        constexpr uint32_t XONEIE = (1U << 1);  ///< XONEIE
        constexpr uint32_t KEIE = (1U << 2);  ///< KEIE
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t SECCFGR;  ///< Offset: 0x00 - SYSCFG secure configuration register
        volatile uint32_t CFGR1;  ///< Offset: 0x04 - configuration register 1
        volatile uint32_t FPUIMR;  ///< Offset: 0x08 - FPU interrupt mask register
        volatile uint32_t CNSLCKR;  ///< Offset: 0x0C - SYSCFG CPU non-secure lock register
        volatile uint32_t CSLOCKR;  ///< Offset: 0x10 - SYSCFG CPU secure lock register
        volatile uint32_t SCSR;  ///< Offset: 0x18 - SCSR
        volatile uint32_t CFGR2;  ///< Offset: 0x14 - CFGR2
        volatile uint32_t SWPR;  ///< Offset: 0x20 - SWPR
        volatile uint32_t SKR;  ///< Offset: 0x1C - SKR
        volatile uint32_t SWPR2;  ///< Offset: 0x24 - SWPR2
        volatile uint32_t RSSCMDR;  ///< Offset: 0x2C - RSSCMDR
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SRAM2SEC = (1U << 2);  ///< SRAM2 security
        constexpr uint32_t CLASSBSEC = (1U << 1);  ///< ClassB security
        constexpr uint32_t SYSCFGSEC = (1U << 0);  ///< SYSCFG clock control security
        constexpr uint32_t FPUSEC = (1U << 3);  ///< FPUSEC
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t I2C4_FMP = (1U << 23);  ///< I2C4_FMP
        constexpr uint32_t I2C3_FMP = (1U << 22);  ///< I2C3 Fast-mode Plus driving capability activation
        constexpr uint32_t I2C2_FMP = (1U << 21);  ///< I2C2 Fast-mode Plus driving capability activation
        constexpr uint32_t I2C1_FMP = (1U << 20);  ///< I2C1 Fast-mode Plus driving capability activation
        constexpr uint32_t I2C_PB9_FMP = (1U << 19);  ///< Fast-mode Plus (Fm+) driving capability activation on PB9
        constexpr uint32_t I2C_PB8_FMP = (1U << 18);  ///< Fast-mode Plus (Fm+) driving capability activation on PB8
        constexpr uint32_t I2C_PB7_FMP = (1U << 17);  ///< Fast-mode Plus (Fm+) driving capability activation on PB7
        constexpr uint32_t I2C_PB6_FMP = (1U << 16);  ///< Fast-mode Plus (Fm+) driving capability activation on PB6
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
        constexpr uint32_t ANASWVDD = (1U << 9);  ///< GPIO analog switch control voltage selection
    }

    /// FPUIMR Register bits
    namespace fpuimr_bits {
        constexpr uint32_t FPU_IE = (6 << 0);  ///< Floating point unit interrupts enable bits
    }

    /// CNSLCKR Register bits
    namespace cnslckr_bits {
        constexpr uint32_t LOCKNSVTOR = (1U << 0);  ///< VTOR_NS register lock
        constexpr uint32_t LOCKNSMPU = (1U << 1);  ///< Non-secure MPU registers lock
    }

    /// CSLOCKR Register bits
    namespace cslockr_bits {
        constexpr uint32_t LOCKSVTAIRCR = (1U << 0);  ///< LOCKSVTAIRCR
        constexpr uint32_t LOCKSMPU = (1U << 1);  ///< LOCKSMPU
        constexpr uint32_t LOCKSAU = (1U << 2);  ///< LOCKSAU
    }

    /// SCSR Register bits
    namespace scsr_bits {
        constexpr uint32_t SRAM2BSY = (1U << 1);  ///< SRAM2 busy by erase operation
        constexpr uint32_t SRAM2ER = (1U << 0);  ///< SRAM2 Erase
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t SPF = (1U << 8);  ///< SRAM2 parity error flag
        constexpr uint32_t ECCL = (1U << 3);  ///< ECC Lock
        constexpr uint32_t PVDL = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t SPL = (1U << 1);  ///< SRAM2 parity lock bit
        constexpr uint32_t CLL = (1U << 0);  ///< LOCKUP (hardfault) output enable bit
    }

    /// SWPR Register bits
    namespace swpr_bits {
        constexpr uint32_t P31WP = (1U << 31);  ///< SRAM2 page 31 write protection
        constexpr uint32_t P30WP = (1U << 30);  ///< P30WP
        constexpr uint32_t P29WP = (1U << 29);  ///< P29WP
        constexpr uint32_t P28WP = (1U << 28);  ///< P28WP
        constexpr uint32_t P27WP = (1U << 27);  ///< P27WP
        constexpr uint32_t P26WP = (1U << 26);  ///< P26WP
        constexpr uint32_t P25WP = (1U << 25);  ///< P25WP
        constexpr uint32_t P24WP = (1U << 24);  ///< P24WP
        constexpr uint32_t P23WP = (1U << 23);  ///< P23WP
        constexpr uint32_t P22WP = (1U << 22);  ///< P22WP
        constexpr uint32_t P21WP = (1U << 21);  ///< P21WP
        constexpr uint32_t P20WP = (1U << 20);  ///< P20WP
        constexpr uint32_t P19WP = (1U << 19);  ///< P19WP
        constexpr uint32_t P18WP = (1U << 18);  ///< P18WP
        constexpr uint32_t P17WP = (1U << 17);  ///< P17WP
        constexpr uint32_t P16WP = (1U << 16);  ///< P16WP
        constexpr uint32_t P15WP = (1U << 15);  ///< P15WP
        constexpr uint32_t P14WP = (1U << 14);  ///< P14WP
        constexpr uint32_t P13WP = (1U << 13);  ///< P13WP
        constexpr uint32_t P12WP = (1U << 12);  ///< P12WP
        constexpr uint32_t P11WP = (1U << 11);  ///< P11WP
        constexpr uint32_t P10WP = (1U << 10);  ///< P10WP
        constexpr uint32_t P9WP = (1U << 9);  ///< P9WP
        constexpr uint32_t P8WP = (1U << 8);  ///< P8WP
        constexpr uint32_t P7WP = (1U << 7);  ///< P7WP
        constexpr uint32_t P6WP = (1U << 6);  ///< P6WP
        constexpr uint32_t P5WP = (1U << 5);  ///< P5WP
        constexpr uint32_t P4WP = (1U << 4);  ///< P4WP
        constexpr uint32_t P3WP = (1U << 3);  ///< P3WP
        constexpr uint32_t P2WP = (1U << 2);  ///< P2WP
        constexpr uint32_t P1WP = (1U << 1);  ///< P1WP
        constexpr uint32_t P0WP = (1U << 0);  ///< P0WP
    }

    /// SKR Register bits
    namespace skr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< SRAM2 write protection key for software erase
    }

    /// SWPR2 Register bits
    namespace swpr2_bits {
        constexpr uint32_t P32WP = (1U << 0);  ///< P32WP
        constexpr uint32_t P33WP = (1U << 1);  ///< P33WP
        constexpr uint32_t P34WP = (1U << 2);  ///< P34WP
        constexpr uint32_t P35WP = (1U << 3);  ///< P35WP
        constexpr uint32_t P36WP = (1U << 4);  ///< P36WP
        constexpr uint32_t P37WP = (1U << 5);  ///< P37WP
        constexpr uint32_t P38WP = (1U << 6);  ///< P38WP
        constexpr uint32_t P39WP = (1U << 7);  ///< P39WP
        constexpr uint32_t P40WP = (1U << 8);  ///< P40WP
        constexpr uint32_t P41WP = (1U << 9);  ///< P41WP
        constexpr uint32_t P42WP = (1U << 10);  ///< P42WP
        constexpr uint32_t P43WP = (1U << 11);  ///< P43WP
        constexpr uint32_t P44WP = (1U << 12);  ///< P44WP
        constexpr uint32_t P45WP = (1U << 13);  ///< P45WP
        constexpr uint32_t P46WP = (1U << 14);  ///< P46WP
        constexpr uint32_t P47WP = (1U << 15);  ///< P47WP
        constexpr uint32_t P48WP = (1U << 16);  ///< P48WP
        constexpr uint32_t P49WP = (1U << 17);  ///< P49WP
        constexpr uint32_t P50WP = (1U << 18);  ///< P50WP
        constexpr uint32_t P51WP = (1U << 19);  ///< P51WP
        constexpr uint32_t P52WP = (1U << 20);  ///< P52WP
        constexpr uint32_t P53WP = (1U << 21);  ///< P53WP
        constexpr uint32_t P54WP = (1U << 22);  ///< P54WP
        constexpr uint32_t P55WP = (1U << 23);  ///< P55WP
        constexpr uint32_t P56WP = (1U << 24);  ///< P56WP
        constexpr uint32_t P57WP = (1U << 25);  ///< P57WP
        constexpr uint32_t P58WP = (1U << 26);  ///< P58WP
        constexpr uint32_t P59WP = (1U << 27);  ///< P59WP
        constexpr uint32_t P60WP = (1U << 28);  ///< P60WP
        constexpr uint32_t P61WP = (1U << 29);  ///< P61WP
        constexpr uint32_t P62WP = (1U << 30);  ///< P62WP
        constexpr uint32_t P63WP = (1U << 31);  ///< P63WP
    }

    /// RSSCMDR Register bits
    namespace rsscmdr_bits {
        constexpr uint32_t RSSCMD = (8 << 0);  ///< RSS commands
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0xE0044000;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - DBGMCU_IDCODE
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU configuration register
        volatile uint32_t APB1LFZR;  ///< Offset: 0x08 - Debug MCU APB1 freeze register1
        volatile uint32_t APB1HFZR;  ///< Offset: 0x0C - Debug MCU APB1 freeze register 2
        volatile uint32_t APB2FZR;  ///< Offset: 0x10 - Debug MCU APB2 freeze register
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device identifier
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision identifie
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby mode
        constexpr uint32_t TRACE_IOEN = (1U << 4);  ///< Trace pin assignment control
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< Trace pin assignment control
        constexpr uint32_t TRACE_EN = (1U << 5);  ///< trace port and clock enable
    }

    /// APB1LFZR Register bits
    namespace apb1lfzr_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 counter stopped when core is halted
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< TIM6 counter stopped when core is halted
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 counter stopped when core is halted
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< RTC counter stopped when core is halted
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Window watchdog counter stopped when core is halted
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Independent watchdog counter stopped when core is halted
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout counter stopped when core is halted
        constexpr uint32_t DBG_I2C2_STOP = (1U << 22);  ///< I2C2 SMBUS timeout counter stopped when core is halted
        constexpr uint32_t DBG_I2C3_STOP = (1U << 23);  ///< I2C3 SMBUS timeout counter stopped when core is halted
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 31);  ///< LPTIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 stop in debug
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< TIM4 stop in debug
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< TIM5 stop in debug
    }

    /// APB1HFZR Register bits
    namespace apb1hfzr_bits {
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 5);  ///< LPTIM2 counter stopped when core is halted
        constexpr uint32_t DBG_I2C4_STOP = (1U << 1);  ///< I2C4 stop in debug
        constexpr uint32_t DBG_LPTIM3_STOP = (1U << 6);  ///< LPTIM3 stop in debug
    }

    /// APB2FZR Register bits
    namespace apb2fzr_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< TIM15 counter stopped when core is halted
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< TIM16 counter stopped when core is halted
        constexpr uint32_t DBG_TIM8_STOP = (1U << 13);  ///< TIM8 stop in debug
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x4000D400;
    constexpr uint32_t SEC_USB_BASE = 0x5000D400;

    /// USB Register structure
    struct Registers {
        volatile uint32_t EP0R;  ///< Offset: 0x00 - endpoint 0 register
        volatile uint32_t EP1R;  ///< Offset: 0x04 - endpoint 1 register
        volatile uint32_t EP2R;  ///< Offset: 0x08 - endpoint 2 register
        volatile uint32_t EP3R;  ///< Offset: 0x0C - endpoint 3 register
        volatile uint32_t EP4R;  ///< Offset: 0x10 - endpoint 4 register
        volatile uint32_t EP5R;  ///< Offset: 0x14 - endpoint 5 register
        volatile uint32_t EP6R;  ///< Offset: 0x18 - endpoint 6 register
        volatile uint32_t EP7R;  ///< Offset: 0x1C - endpoint 7 register
        volatile uint32_t CNTR;  ///< Offset: 0x40 - control register
        volatile uint32_t ISTR;  ///< Offset: 0x44 - interrupt status register
        volatile uint32_t FNR;  ///< Offset: 0x48 - frame number register
        volatile uint32_t DADDR;  ///< Offset: 0x4C - device address
        volatile uint32_t BTABLE;  ///< Offset: 0x50 - Buffer table address
        volatile uint32_t LPMCSR;  ///< Offset: 0x54 - LPM control and status register
        volatile uint32_t BCDR;  ///< Offset: 0x58 - Battery charging detector
        volatile uint32_t COUNT0_TX;  ///< Offset: 0x52 - Transmission byte count 0
        volatile uint32_t COUNT1_TX;  ///< Offset: 0x5A - Transmission byte count 0
        volatile uint32_t COUNT2_TX;  ///< Offset: 0x62 - Transmission byte count 0
        volatile uint32_t COUNT3_TX;  ///< Offset: 0x6A - Transmission byte count 0
        volatile uint32_t COUNT4_TX;  ///< Offset: 0x72 - Transmission byte count 0
        volatile uint32_t COUNT5_TX;  ///< Offset: 0x7A - Transmission byte count 0
        volatile uint32_t COUNT6_TX;  ///< Offset: 0x82 - Transmission byte count 0
        volatile uint32_t COUNT7_TX;  ///< Offset: 0x8A - Transmission byte count 0
        volatile uint32_t ADDR0_RX;  ///< Offset: 0x5C - Reception buffer address 0
        volatile uint32_t ADDR1_RX;  ///< Offset: 0x64 - Reception buffer address 0
        volatile uint32_t ADDR2_RX;  ///< Offset: 0x6C - Reception buffer address 0
        volatile uint32_t ADDR3_RX;  ///< Offset: 0x74 - Reception buffer address 0
        volatile uint32_t ADDR4_RX;  ///< Offset: 0x7C - Reception buffer address 0
        volatile uint32_t ADDR5_RX;  ///< Offset: 0x84 - Reception buffer address 0
        volatile uint32_t ADDR6_RX;  ///< Offset: 0x8C - Reception buffer address 0
        volatile uint32_t ADDR7_RX;  ///< Offset: 0x94 - Reception buffer address 0
        volatile uint32_t COUNT0_RX;  ///< Offset: 0x56 - Reception byte count 0
        volatile uint32_t COUNT1_RX;  ///< Offset: 0x5E - Reception byte count 0
        volatile uint32_t COUNT2_RX;  ///< Offset: 0x66 - Reception byte count 0
        volatile uint32_t COUNT3_RX;  ///< Offset: 0x6E - Reception byte count 0
        volatile uint32_t COUNT4_RX;  ///< Offset: 0x76 - Reception byte count 0
        volatile uint32_t COUNT5_RX;  ///< Offset: 0x7E - Reception byte count 0
        volatile uint32_t COUNT6_RX;  ///< Offset: 0x86 - Reception byte count 0
        volatile uint32_t COUNT7_RX;  ///< Offset: 0x8E - Reception byte count 0
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);
    inline Registers* SEC_USB = reinterpret_cast<Registers*>(SEC_USB_BASE);

    // Bit definitions
    /// EP0R Register bits
    namespace ep0r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP1R Register bits
    namespace ep1r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP2R Register bits
    namespace ep2r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP3R Register bits
    namespace ep3r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP4R Register bits
    namespace ep4r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP5R Register bits
    namespace ep5r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP6R Register bits
    namespace ep6r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// EP7R Register bits
    namespace ep7r_bits {
        constexpr uint32_t EA = (4 << 0);  ///< Endpoint address
        constexpr uint32_t STAT_TX = (2 << 4);  ///< Status bits, for transmission transfers
        constexpr uint32_t DTOG_TX = (1U << 6);  ///< Data Toggle, for transmission transfers
        constexpr uint32_t CTR_TX = (1U << 7);  ///< Correct Transfer for transmission
        constexpr uint32_t EP_KIND = (1U << 8);  ///< Endpoint kind
        constexpr uint32_t EP_TYPE = (2 << 9);  ///< Endpoint type
        constexpr uint32_t SETUP = (1U << 11);  ///< Setup transaction completed
        constexpr uint32_t STAT_RX = (2 << 12);  ///< Status bits, for reception transfers
        constexpr uint32_t DTOG_RX = (1U << 14);  ///< Data Toggle, for reception transfers
        constexpr uint32_t CTR_RX = (1U << 15);  ///< Correct transfer for reception
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t FRES = (1U << 0);  ///< Force USB Reset
        constexpr uint32_t PDWN = (1U << 1);  ///< Power down
        constexpr uint32_t LPMODE = (1U << 2);  ///< Low-power mode
        constexpr uint32_t FSUSP = (1U << 3);  ///< Force suspend
        constexpr uint32_t RESUME = (1U << 4);  ///< Resume request
        constexpr uint32_t L1RESUME = (1U << 5);  ///< LPM L1 Resume request
        constexpr uint32_t L1REQM = (1U << 7);  ///< LPM L1 state request interrupt mask
        constexpr uint32_t ESOFM = (1U << 8);  ///< Expected start of frame interrupt mask
        constexpr uint32_t SOFM = (1U << 9);  ///< Start of frame interrupt mask
        constexpr uint32_t RESETM = (1U << 10);  ///< USB reset interrupt mask
        constexpr uint32_t SUSPM = (1U << 11);  ///< Suspend mode interrupt mask
        constexpr uint32_t WKUPM = (1U << 12);  ///< Wakeup interrupt mask
        constexpr uint32_t ERRM = (1U << 13);  ///< Error interrupt mask
        constexpr uint32_t PMAOVRM = (1U << 14);  ///< Packet memory area over / underrun interrupt mask
        constexpr uint32_t CTRM = (1U << 15);  ///< Correct transfer interrupt mask
    }

    /// ISTR Register bits
    namespace istr_bits {
        constexpr uint32_t EP_ID = (4 << 0);  ///< Endpoint Identifier
        constexpr uint32_t DIR = (1U << 4);  ///< Direction of transaction
        constexpr uint32_t L1REQ = (1U << 7);  ///< LPM L1 state request
        constexpr uint32_t ESOF = (1U << 8);  ///< Expected start frame
        constexpr uint32_t SOF = (1U << 9);  ///< start of frame
        constexpr uint32_t RESET = (1U << 10);  ///< reset request
        constexpr uint32_t SUSP = (1U << 11);  ///< Suspend mode request
        constexpr uint32_t WKUP = (1U << 12);  ///< Wakeup
        constexpr uint32_t ERR = (1U << 13);  ///< Error
        constexpr uint32_t PMAOVR = (1U << 14);  ///< Packet memory area over / underrun
        constexpr uint32_t CTR = (1U << 15);  ///< Correct transfer
    }

    /// FNR Register bits
    namespace fnr_bits {
        constexpr uint32_t FN = (11 << 0);  ///< Frame number
        constexpr uint32_t LSOF = (2 << 11);  ///< Lost SOF
        constexpr uint32_t LCK = (1U << 13);  ///< Locked
        constexpr uint32_t RXDM = (1U << 14);  ///< Receive data - line status
        constexpr uint32_t RXDP = (1U << 15);  ///< Receive data + line status
    }

    /// DADDR Register bits
    namespace daddr_bits {
        constexpr uint32_t ADD = (7 << 0);  ///< Device address
        constexpr uint32_t EF = (1U << 7);  ///< Enable function
    }

    /// BTABLE Register bits
    namespace btable_bits {
        constexpr uint32_t BTABLE = (13 << 3);  ///< Buffer table
    }

    /// LPMCSR Register bits
    namespace lpmcsr_bits {
        constexpr uint32_t LPMEN = (1U << 0);  ///< LPM support enable
        constexpr uint32_t LPMACK = (1U << 1);  ///< LPM Token acknowledge enable
        constexpr uint32_t REMWAKE = (1U << 3);  ///< RemoteWake value
        constexpr uint32_t BESL = (4 << 4);  ///< BESL value
    }

    /// BCDR Register bits
    namespace bcdr_bits {
        constexpr uint32_t BCDEN = (1U << 0);  ///< Battery charging detector (BCD) enable
        constexpr uint32_t DCDEN = (1U << 1);  ///< Data contact detection (DCD) mode enable
        constexpr uint32_t PDEN = (1U << 2);  ///< Primary detection (PD) mode enable
        constexpr uint32_t SDEN = (1U << 3);  ///< Secondary detection (SD) mode enable
        constexpr uint32_t DCDET = (1U << 4);  ///< Data contact detection (DCD) status
        constexpr uint32_t PDET = (1U << 5);  ///< Primary detection (PD) status
        constexpr uint32_t SDET = (1U << 6);  ///< Secondary detection (SD) status
        constexpr uint32_t PS2DET = (1U << 7);  ///< DM pull-up detection status
        constexpr uint32_t DPPU = (1U << 15);  ///< DP pull-up control
    }

    /// COUNT0_TX Register bits
    namespace count0_tx_bits {
        constexpr uint32_t COUNT0_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT1_TX Register bits
    namespace count1_tx_bits {
        constexpr uint32_t COUNT1_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT2_TX Register bits
    namespace count2_tx_bits {
        constexpr uint32_t COUNT2_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT3_TX Register bits
    namespace count3_tx_bits {
        constexpr uint32_t COUNT3_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT4_TX Register bits
    namespace count4_tx_bits {
        constexpr uint32_t COUNT4_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT5_TX Register bits
    namespace count5_tx_bits {
        constexpr uint32_t COUNT5_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT6_TX Register bits
    namespace count6_tx_bits {
        constexpr uint32_t COUNT6_TX = (10 << 0);  ///< Transmission byte count
    }

    /// COUNT7_TX Register bits
    namespace count7_tx_bits {
        constexpr uint32_t COUNT7_TX = (10 << 0);  ///< Transmission byte count
    }

    /// ADDR0_RX Register bits
    namespace addr0_rx_bits {
        constexpr uint32_t ADDR0_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR1_RX Register bits
    namespace addr1_rx_bits {
        constexpr uint32_t ADDR1_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR2_RX Register bits
    namespace addr2_rx_bits {
        constexpr uint32_t ADDR2_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR3_RX Register bits
    namespace addr3_rx_bits {
        constexpr uint32_t ADDR3_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR4_RX Register bits
    namespace addr4_rx_bits {
        constexpr uint32_t ADDR4_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR5_RX Register bits
    namespace addr5_rx_bits {
        constexpr uint32_t ADDR5_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR6_RX Register bits
    namespace addr6_rx_bits {
        constexpr uint32_t ADDR6_RX = (15 << 1);  ///< Reception buffer address
    }

    /// ADDR7_RX Register bits
    namespace addr7_rx_bits {
        constexpr uint32_t ADDR7_RX = (15 << 1);  ///< Reception buffer address
    }

    /// COUNT0_RX Register bits
    namespace count0_rx_bits {
        constexpr uint32_t COUNT0_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT1_RX Register bits
    namespace count1_rx_bits {
        constexpr uint32_t COUNT1_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT2_RX Register bits
    namespace count2_rx_bits {
        constexpr uint32_t COUNT2_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT3_RX Register bits
    namespace count3_rx_bits {
        constexpr uint32_t COUNT3_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT4_RX Register bits
    namespace count4_rx_bits {
        constexpr uint32_t COUNT4_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT5_RX Register bits
    namespace count5_rx_bits {
        constexpr uint32_t COUNT5_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT6_RX Register bits
    namespace count6_rx_bits {
        constexpr uint32_t COUNT6_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

    /// COUNT7_RX Register bits
    namespace count7_rx_bits {
        constexpr uint32_t COUNT7_RX = (10 << 0);  ///< Reception byte count
        constexpr uint32_t NUM_BLOCK = (5 << 10);  ///< Number of blocks
        constexpr uint32_t BL_SIZE = (1U << 15);  ///< Block size
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x40008000;
    constexpr uint32_t SEC_LPUART1_BASE = 0x50008000;
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t SEC_USART1_BASE = 0x50013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t SEC_USART2_BASE = 0x50004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t SEC_USART3_BASE = 0x50004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;
    constexpr uint32_t SEC_UART4_BASE = 0x50004C00;
    constexpr uint32_t SEC_UART5_BASE = 0x50005000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt & status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - PRESC
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* SEC_LPUART1 = reinterpret_cast<Registers*>(SEC_LPUART1_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* SEC_USART1 = reinterpret_cast<Registers*>(SEC_USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* SEC_USART2 = reinterpret_cast<Registers*>(SEC_USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* SEC_USART3 = reinterpret_cast<Registers*>(SEC_USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* SEC_UART4 = reinterpret_cast<Registers*>(SEC_UART4_BASE);
    inline Registers* SEC_UART5 = reinterpret_cast<Registers*>(SEC_UART5_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXNEIE = (1U << 5);  ///< RXNE interrupt enable
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFEIE
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFFIE
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD4_7 = (4 << 28);  ///< Address of the USART node
        constexpr uint32_t ADD0_3 = (4 << 24);  ///< Address of the USART node
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t TAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wakeup from Stop mode interrupt enable
        constexpr uint32_t WUS = (2 << 20);  ///< Wakeup from Stop mode interrupt flag selection
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFTIE
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< RXFTCFG
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFTIE
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFTCFG
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< BRR
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
        constexpr uint32_t TXFRQ = (1U << 4);  ///< TXFRQ
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t WUF = (1U << 20);  ///< WUF
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NF = (1U << 2);  ///< NF
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFE
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFF
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFT
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFT
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t WUCF = (1U << 20);  ///< Wakeup from Stop mode clear flag
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NCF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< PRESCALER
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x40010200;
    constexpr uint32_t SEC_COMP_BASE = 0x50010200;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP1_CSR;  ///< Offset: 0x00 - Comparator 1 control and status register
        volatile uint32_t COMP2_CSR;  ///< Offset: 0x04 - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);
    inline Registers* SEC_COMP = reinterpret_cast<Registers*>(SEC_COMP_BASE);

    // Bit definitions
    /// COMP1_CSR Register bits
    namespace comp1_csr_bits {
        constexpr uint32_t COMP1_EN = (1U << 0);  ///< Comparator 1 enable bit
        constexpr uint32_t COMP1_PWRMODE = (2 << 2);  ///< Power Mode of the comparator 1
        constexpr uint32_t COMP1_INMSEL = (3 << 4);  ///< Comparator 1 Input Minus connection configuration bit
        constexpr uint32_t COMP1_INPSEL = (1U << 7);  ///< Comparator1 input plus selection bit
        constexpr uint32_t COMP1_POLARITY = (1U << 15);  ///< Comparator 1 polarity selection bit
        constexpr uint32_t COMP1_HYST = (2 << 16);  ///< Comparator 1 hysteresis selection bits
        constexpr uint32_t COMP1_BLANKING = (3 << 18);  ///< Comparator 1 blanking source selection bits
        constexpr uint32_t COMP1_BRGEN = (1U << 22);  ///< Scaler bridge enable
        constexpr uint32_t COMP1_SCALEN = (1U << 23);  ///< Voltage scaler enable bit
        constexpr uint32_t COMP1_VALUE = (1U << 30);  ///< Comparator 1 output status bit
        constexpr uint32_t COMP1_LOCK = (1U << 31);  ///< COMP1_CSR register lock bit
    }

    /// COMP2_CSR Register bits
    namespace comp2_csr_bits {
        constexpr uint32_t COMP2_EN = (1U << 0);  ///< Comparator 2 enable bit
        constexpr uint32_t COMP2_PWRMODE = (2 << 2);  ///< Power Mode of the comparator 2
        constexpr uint32_t COMP2_INMSEL = (3 << 4);  ///< Comparator 2 Input Minus connection configuration bit
        constexpr uint32_t COMP2_INPSEL = (1U << 7);  ///< Comparator 2 Input Plus connection configuration bit
        constexpr uint32_t COMP2_WINMODE = (1U << 9);  ///< Windows mode selection bit
        constexpr uint32_t COMP2_POLARITY = (1U << 15);  ///< Comparator 2 polarity selection bit
        constexpr uint32_t COMP2_HYST = (2 << 16);  ///< Comparator 2 hysteresis selection bits
        constexpr uint32_t COMP2_BLANKING = (3 << 18);  ///< Comparator 2 blanking source selection bits
        constexpr uint32_t COMP2_BRGEN = (1U << 22);  ///< Scaler bridge enable
        constexpr uint32_t COMP2_SCALEN = (1U << 23);  ///< Voltage scaler enable bit
        constexpr uint32_t COMP2_VALUE = (1U << 30);  ///< Comparator 2 output status bit
        constexpr uint32_t COMP2_LOCK = (1U << 31);  ///< COMP2_CSR register lock bit
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x40010030;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - VREF control and status register
        volatile uint32_t CCR;  ///< Offset: 0x04 - calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer enable
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode
        constexpr uint32_t VRS = (1U << 2);  ///< Voltage reference scale
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trimming code
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x40024000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t ICR;  ///< Offset: 0x08 - interrupt clear register
        volatile uint32_t ISR;  ///< Offset: 0x0C - interrupt status register
        volatile uint32_t IOHCR;  ///< Offset: 0x10 - I/O hysteresis control register
        volatile uint32_t IOASCR;  ///< Offset: 0x18 - I/O analog switch control register
        volatile uint32_t IOSCR;  ///< Offset: 0x20 - I/O sampling control register
        volatile uint32_t IOCCR;  ///< Offset: 0x28 - I/O channel control register
        volatile uint32_t IOGCSR;  ///< Offset: 0x30 - I/O group control status register
        volatile uint32_t IOG1CR;  ///< Offset: 0x34 - I/O group x counter register
        volatile uint32_t IOG2CR;  ///< Offset: 0x38 - I/O group x counter register
        volatile uint32_t IOG3CR;  ///< Offset: 0x3C - I/O group x counter register
        volatile uint32_t IOG4CR;  ///< Offset: 0x40 - I/O group x counter register
        volatile uint32_t IOG5CR;  ///< Offset: 0x44 - I/O group x counter register
        volatile uint32_t IOG6CR;  ///< Offset: 0x48 - I/O group x counter register
        volatile uint32_t IOG7CR;  ///< Offset: 0x4C - I/O group x counter register
        volatile uint32_t IOG8CR;  ///< Offset: 0x50 - I/O group x counter register
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CTPH = (4 << 28);  ///< Charge transfer pulse high
        constexpr uint32_t CTPL = (4 << 24);  ///< Charge transfer pulse low
        constexpr uint32_t SSD = (7 << 17);  ///< Spread spectrum deviation
        constexpr uint32_t SSE = (1U << 16);  ///< Spread spectrum enable
        constexpr uint32_t SSPSC = (1U << 15);  ///< Spread spectrum prescaler
        constexpr uint32_t PGPSC = (3 << 12);  ///< pulse generator prescaler
        constexpr uint32_t MCV = (3 << 5);  ///< Max count value
        constexpr uint32_t IODEF = (1U << 4);  ///< I/O Default mode
        constexpr uint32_t SYNCPOL = (1U << 3);  ///< Synchronization pin polarity
        constexpr uint32_t AM = (1U << 2);  ///< Acquisition mode
        constexpr uint32_t START = (1U << 1);  ///< Start a new acquisition
        constexpr uint32_t TSCE = (1U << 0);  ///< Touch sensing controller enable
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t MCEIE = (1U << 1);  ///< Max count error interrupt enable
        constexpr uint32_t EOAIE = (1U << 0);  ///< End of acquisition interrupt enable
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t MCEIC = (1U << 1);  ///< Max count error interrupt clear
        constexpr uint32_t EOAIC = (1U << 0);  ///< End of acquisition interrupt clear
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t MCEF = (1U << 1);  ///< Max count error flag
        constexpr uint32_t EOAF = (1U << 0);  ///< End of acquisition flag
    }

    /// IOHCR Register bits
    namespace iohcr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOASCR Register bits
    namespace ioascr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOSCR Register bits
    namespace ioscr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOCCR Register bits
    namespace ioccr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOGCSR Register bits
    namespace iogcsr_bits {
        constexpr uint32_t G8S = (1U << 23);  ///< Analog I/O group x status
        constexpr uint32_t G7S = (1U << 22);  ///< Analog I/O group x status
        constexpr uint32_t G6S = (1U << 21);  ///< Analog I/O group x status
        constexpr uint32_t G5S = (1U << 20);  ///< Analog I/O group x status
        constexpr uint32_t G4S = (1U << 19);  ///< Analog I/O group x status
        constexpr uint32_t G3S = (1U << 18);  ///< Analog I/O group x status
        constexpr uint32_t G2S = (1U << 17);  ///< Analog I/O group x status
        constexpr uint32_t G1S = (1U << 16);  ///< Analog I/O group x status
        constexpr uint32_t G8E = (1U << 7);  ///< Analog I/O group x enable
        constexpr uint32_t G7E = (1U << 6);  ///< Analog I/O group x enable
        constexpr uint32_t G6E = (1U << 5);  ///< Analog I/O group x enable
        constexpr uint32_t G5E = (1U << 4);  ///< Analog I/O group x enable
        constexpr uint32_t G4E = (1U << 3);  ///< Analog I/O group x enable
        constexpr uint32_t G3E = (1U << 2);  ///< Analog I/O group x enable
        constexpr uint32_t G2E = (1U << 1);  ///< Analog I/O group x enable
        constexpr uint32_t G1E = (1U << 0);  ///< Analog I/O group x enable
    }

    /// IOG1CR Register bits
    namespace iog1cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG2CR Register bits
    namespace iog2cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG3CR Register bits
    namespace iog3cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG4CR Register bits
    namespace iog4cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG5CR Register bits
    namespace iog5cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG6CR Register bits
    namespace iog6cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG7CR Register bits
    namespace iog7cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG8CR Register bits
    namespace iog8cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

}

// ============================================================================
// UCPD1 Peripheral
// ============================================================================

namespace ucpd1 {
    /// Base addresses
    constexpr uint32_t UCPD1_BASE = 0x4000DC00;

    /// UCPD1 Register structure
    struct Registers {
        volatile uint32_t CFG1;  ///< Offset: 0x00 - UCPD configuration register
        volatile uint32_t CFG2;  ///< Offset: 0x04 - UCPD configuration register 2
        volatile uint32_t CFG3;  ///< Offset: 0x08 - UCPD configuration register 3
        volatile uint32_t CR;  ///< Offset: 0x0C - UCPD control register
        volatile uint32_t IMR;  ///< Offset: 0x10 - UCPD Interrupt Mask Register
        volatile uint32_t SR;  ///< Offset: 0x14 - UCPD Status Register
        volatile uint32_t ICR;  ///< Offset: 0x18 - UCPD Interrupt Clear Register
        volatile uint32_t TX_ORDSET;  ///< Offset: 0x1C - UCPD Tx Ordered Set Type Register
        volatile uint32_t TX_PAYSZ;  ///< Offset: 0x20 - UCPD Tx Paysize Register
        volatile uint32_t TXDR;  ///< Offset: 0x24 - UCPD Tx Data Register
        volatile uint32_t RX_ORDSET;  ///< Offset: 0x28 - UCPD Rx Ordered Set Register
        volatile uint32_t RX_PAYSZ;  ///< Offset: 0x2C - UCPD Rx Paysize Register
        volatile uint32_t RXDR;  ///< Offset: 0x30 - UCPD Receive Data Register
        volatile uint32_t RX_ORDEXT1;  ///< Offset: 0x34 - UCPD Rx Ordered Set Extension Register
        volatile uint32_t RX_ORDEXT2;  ///< Offset: 0x38 - UCPD Rx Ordered Set Extension Register
    };

    /// Peripheral instances
    inline Registers* UCPD1 = reinterpret_cast<Registers*>(UCPD1_BASE);

    // Bit definitions
    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t HBITCLKDIV = (6 << 0);  ///< HBITCLKDIV
        constexpr uint32_t IFRGAP = (5 << 6);  ///< IFRGAP
        constexpr uint32_t TRANSWIN = (5 << 11);  ///< TRANSWIN
        constexpr uint32_t PSC_USBPDCLK = (3 << 17);  ///< PSC_USBPDCLK
        constexpr uint32_t RXORDSETEN = (9 << 20);  ///< RXORDSETEN
        constexpr uint32_t TXDMAEN = (1U << 29);  ///< TXDMAEN
        constexpr uint32_t RXDMAEN = (1U << 30);  ///< RXDMAEN:
        constexpr uint32_t UCPDEN = (1U << 31);  ///< UCPDEN
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t RXFILTDIS = (1U << 0);  ///< RXFILTDIS
        constexpr uint32_t RXFILT2N3 = (1U << 1);  ///< RXFILT2N3
        constexpr uint32_t FORCECLK = (1U << 2);  ///< FORCECLK
        constexpr uint32_t WUPEN = (1U << 3);  ///< WUPEN
    }

    /// CFG3 Register bits
    namespace cfg3_bits {
        constexpr uint32_t TRIM1_NG_CCRPD = (4 << 0);  ///< TRIM1_NG_CCRPD
        constexpr uint32_t TRIM1_NG_CC1A5 = (5 << 4);  ///< TRIM1_NG_CC1A5
        constexpr uint32_t TRIM1_NG_CC3A0 = (4 << 9);  ///< TRIM1_NG_CC3A0
        constexpr uint32_t TRIM2_NG_CCRPD = (4 << 16);  ///< TRIM2_NG_CCRPD
        constexpr uint32_t TRIM2_NG_CC1A5 = (5 << 20);  ///< TRIM2_NG_CC1A5
        constexpr uint32_t TRIM2_NG_CC3A0 = (4 << 25);  ///< TRIM2_NG_CC3A0
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TXMODE = (2 << 0);  ///< TXMODE
        constexpr uint32_t TXSEND = (1U << 2);  ///< TXSEND
        constexpr uint32_t TXHRST = (1U << 3);  ///< TXHRST
        constexpr uint32_t RXMODE = (1U << 4);  ///< RXMODE
        constexpr uint32_t PHYRXEN = (1U << 5);  ///< PHYRXEN
        constexpr uint32_t PHYCCSEL = (1U << 6);  ///< PHYCCSEL
        constexpr uint32_t ANASUBMODE = (2 << 7);  ///< ANASUBMODE
        constexpr uint32_t ANAMODE = (1U << 9);  ///< ANAMODE
        constexpr uint32_t CCENABLE = (2 << 10);  ///< CCENABLE
        constexpr uint32_t FRSRXEN = (1U << 16);  ///< FRSRXEN
        constexpr uint32_t FRSTX = (1U << 17);  ///< FRSTX
        constexpr uint32_t RDCH = (1U << 18);  ///< RDCH
        constexpr uint32_t CC1TCDIS = (1U << 20);  ///< CC1TCDIS
        constexpr uint32_t CC2TCDIS = (1U << 21);  ///< CC2TCDIS
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t TXISIE = (1U << 0);  ///< TXISIE
        constexpr uint32_t TXMSGDISCIE = (1U << 1);  ///< TXMSGDISCIE
        constexpr uint32_t TXMSGSENTIE = (1U << 2);  ///< TXMSGSENTIE
        constexpr uint32_t TXMSGABTIE = (1U << 3);  ///< TXMSGABTIE
        constexpr uint32_t HRSTDISCIE = (1U << 4);  ///< HRSTDISCIE
        constexpr uint32_t HRSTSENTIE = (1U << 5);  ///< HRSTSENTIE
        constexpr uint32_t TXUNDIE = (1U << 6);  ///< TXUNDIE
        constexpr uint32_t RXNEIE = (1U << 8);  ///< RXNEIE
        constexpr uint32_t RXORDDETIE = (1U << 9);  ///< RXORDDETIE
        constexpr uint32_t RXHRSTDETIE = (1U << 10);  ///< RXHRSTDETIE
        constexpr uint32_t RXOVRIE = (1U << 11);  ///< RXOVRIE
        constexpr uint32_t RXMSGENDIE = (1U << 12);  ///< RXMSGENDIE
        constexpr uint32_t TYPECEVT1IE = (1U << 14);  ///< TYPECEVT1IE
        constexpr uint32_t TYPECEVT2IE = (1U << 15);  ///< TYPECEVT2IE
        constexpr uint32_t FRSEVTIE = (1U << 20);  ///< FRSEVTIE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TXIS = (1U << 0);  ///< TXIS
        constexpr uint32_t TXMSGDISC = (1U << 1);  ///< TXMSGDISC
        constexpr uint32_t TXMSGSENT = (1U << 2);  ///< TXMSGSENT
        constexpr uint32_t TXMSGABT = (1U << 3);  ///< TXMSGABT
        constexpr uint32_t HRSTDISC = (1U << 4);  ///< HRSTDISC
        constexpr uint32_t HRSTSENT = (1U << 5);  ///< HRSTSENT
        constexpr uint32_t TXUND = (1U << 6);  ///< TXUND
        constexpr uint32_t RXNE = (1U << 8);  ///< RXNE
        constexpr uint32_t RXORDDET = (1U << 9);  ///< RXORDDET
        constexpr uint32_t RXHRSTDET = (1U << 10);  ///< RXHRSTDET
        constexpr uint32_t RXOVR = (1U << 11);  ///< RXOVR
        constexpr uint32_t RXMSGEND = (1U << 12);  ///< RXMSGEND
        constexpr uint32_t RXERR = (1U << 13);  ///< RXERR
        constexpr uint32_t TYPECEVT1 = (1U << 14);  ///< TYPECEVT1
        constexpr uint32_t TYPECEVT2 = (1U << 15);  ///< TYPECEVT2
        constexpr uint32_t TYPEC_VSTATE_CC1 = (2 << 16);  ///< TYPEC_VSTATE_CC1
        constexpr uint32_t TYPEC_VSTATE_CC2 = (2 << 18);  ///< TYPEC_VSTATE_CC2
        constexpr uint32_t FRSEVT = (1U << 20);  ///< FRSEVT
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t TXMSGDISCCF = (1U << 1);  ///< TXMSGDISCCF
        constexpr uint32_t TXMSGSENTCF = (1U << 2);  ///< TXMSGSENTCF
        constexpr uint32_t TXMSGABTCF = (1U << 3);  ///< TXMSGABTCF
        constexpr uint32_t HRSTDISCCF = (1U << 4);  ///< HRSTDISCCF
        constexpr uint32_t HRSTSENTCF = (1U << 5);  ///< HRSTSENTCF
        constexpr uint32_t TXUNDCF = (1U << 6);  ///< TXUNDCF
        constexpr uint32_t RXORDDETCF = (1U << 9);  ///< RXORDDETCF
        constexpr uint32_t RXHRSTDETCF = (1U << 10);  ///< RXHRSTDETCF
        constexpr uint32_t RXOVRCF = (1U << 11);  ///< RXOVRCF
        constexpr uint32_t RXMSGENDCF = (1U << 12);  ///< RXMSGENDCF
        constexpr uint32_t TYPECEVT1CF = (1U << 14);  ///< TYPECEVT1CF
        constexpr uint32_t TYPECEVT2CF = (1U << 15);  ///< TYPECEVT2CF
        constexpr uint32_t FRSEVTCF = (1U << 20);  ///< FRSEVTCF
    }

    /// TX_ORDSET Register bits
    namespace tx_ordset_bits {
        constexpr uint32_t TXORDSET = (20 << 0);  ///< TXORDSET
    }

    /// TX_PAYSZ Register bits
    namespace tx_paysz_bits {
        constexpr uint32_t TXPAYSZ = (10 << 0);  ///< TXPAYSZ
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< TXDATA
    }

    /// RX_ORDSET Register bits
    namespace rx_ordset_bits {
        constexpr uint32_t RXORDSET = (3 << 0);  ///< RXORDSET
        constexpr uint32_t RXSOP3OF4 = (1U << 3);  ///< RXSOP3OF4
        constexpr uint32_t RXSOPKINVALID = (3 << 4);  ///< RXSOPKINVALID
    }

    /// RX_PAYSZ Register bits
    namespace rx_paysz_bits {
        constexpr uint32_t RXPAYSZ = (10 << 0);  ///< RXPAYSZ
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< RXDATA
    }

    /// RX_ORDEXT1 Register bits
    namespace rx_ordext1_bits {
        constexpr uint32_t RXSOPX1 = (20 << 0);  ///< RXSOPX1
    }

    /// RX_ORDEXT2 Register bits
    namespace rx_ordext2_bits {
        constexpr uint32_t RXSOPX2 = (20 << 0);  ///< RXSOPX2
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t FDCAN1_BASE = 0x4000A400;
    constexpr uint32_t SEC_FDCAN1_BASE = 0x5000A400;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t FDCAN_CREL;  ///< Offset: 0x00 - FDCAN Core Release Register
        volatile uint32_t FDCAN_ENDN;  ///< Offset: 0x04 - FDCAN Core Release Register
        volatile uint32_t FDCAN_DBTP;  ///< Offset: 0x0C - FDCAN Data Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TEST;  ///< Offset: 0x10 - FDCAN Test Register
        volatile uint32_t FDCAN_RWD;  ///< Offset: 0x14 - FDCAN RAM Watchdog Register
        volatile uint32_t FDCAN_CCCR;  ///< Offset: 0x18 - FDCAN CC Control Register
        volatile uint32_t FDCAN_NBTP;  ///< Offset: 0x1C - FDCAN Nominal Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TSCC;  ///< Offset: 0x20 - FDCAN Timestamp Counter Configuration Register
        volatile uint32_t FDCAN_TSCV;  ///< Offset: 0x24 - FDCAN Timestamp Counter Value Register
        volatile uint32_t FDCAN_TOCC;  ///< Offset: 0x28 - FDCAN Timeout Counter Configuration Register
        volatile uint32_t FDCAN_TOCV;  ///< Offset: 0x2C - FDCAN Timeout Counter Value Register
        volatile uint32_t FDCAN_ECR;  ///< Offset: 0x40 - FDCAN Error Counter Register
        volatile uint32_t FDCAN_PSR;  ///< Offset: 0x44 - FDCAN Protocol Status Register
        volatile uint32_t FDCAN_TDCR;  ///< Offset: 0x48 - FDCAN Transmitter Delay Compensation Register
        volatile uint32_t FDCAN_IR;  ///< Offset: 0x50 - FDCAN Interrupt Register
        volatile uint32_t FDCAN_IE;  ///< Offset: 0x54 - FDCAN Interrupt Enable Register
        volatile uint32_t FDCAN_ILS;  ///< Offset: 0x58 - FDCAN Interrupt Line Select Register
        volatile uint32_t FDCAN_ILE;  ///< Offset: 0x5C - FDCAN Interrupt Line Enable Register
        volatile uint32_t FDCAN_RXGFC;  ///< Offset: 0x80 - FDCAN Global Filter Configuration Register
        volatile uint32_t FDCAN_XIDAM;  ///< Offset: 0x84 - FDCAN Extended ID and Mask Register
        volatile uint32_t FDCAN_HPMS;  ///< Offset: 0x88 - FDCAN High Priority Message Status Register
        volatile uint32_t FDCAN_RXF0S;  ///< Offset: 0x90 - FDCAN Rx FIFO 0 Status Register
        volatile uint32_t FDCAN_RXF0A;  ///< Offset: 0x94 - CAN Rx FIFO 0 Acknowledge Register
        volatile uint32_t FDCAN_RXF1S;  ///< Offset: 0x98 - FDCAN Rx FIFO 1 Status Register
        volatile uint32_t FDCAN_RXF1A;  ///< Offset: 0x9C - FDCAN Rx FIFO 1 Acknowledge Register
        volatile uint32_t FDCAN_TXFQS;  ///< Offset: 0xC4 - FDCAN Tx FIFO/Queue Status Register
        volatile uint32_t FDCAN_TXBRP;  ///< Offset: 0xC8 - FDCAN Tx Buffer Request Pending Register
        volatile uint32_t FDCAN_TXBAR;  ///< Offset: 0xCC - FDCAN Tx Buffer Add Request Register
        volatile uint32_t FDCAN_TXBCR;  ///< Offset: 0xD0 - FDCAN Tx Buffer Cancellation Request Register
        volatile uint32_t FDCAN_TXBTO;  ///< Offset: 0xD4 - FDCAN Tx Buffer Transmission Occurred Register
        volatile uint32_t FDCAN_TXBCF;  ///< Offset: 0xD8 - FDCAN Tx Buffer Cancellation Finished Register
        volatile uint32_t FDCAN_TXBTIE;  ///< Offset: 0xDC - FDCAN Tx Buffer Transmission Interrupt Enable Register
        volatile uint32_t FDCAN_TXBCIE;  ///< Offset: 0xE0 - FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        volatile uint32_t FDCAN_TXEFS;  ///< Offset: 0xE4 - FDCAN Tx Event FIFO Status Register
        volatile uint32_t FDCAN_TXEFA;  ///< Offset: 0xE8 - FDCAN Tx Event FIFO Acknowledge Register
        volatile uint32_t FDCAN_CKDIV;  ///< Offset: 0x100 - FDCAN TT Trigger Memory Configuration Register
        volatile uint32_t FDCAN_TXBC;  ///< Offset: 0xC0 - FDCAN Tx buffer configuration register
    };

    /// Peripheral instances
    inline Registers* FDCAN1 = reinterpret_cast<Registers*>(FDCAN1_BASE);
    inline Registers* SEC_FDCAN1 = reinterpret_cast<Registers*>(SEC_FDCAN1_BASE);

    // Bit definitions
    /// FDCAN_CREL Register bits
    namespace fdcan_crel_bits {
        constexpr uint32_t REL = (4 << 28);  ///< Core release
        constexpr uint32_t STEP = (4 << 24);  ///< Step of Core release
        constexpr uint32_t SUBSTEP = (4 << 20);  ///< Sub-step of Core release
        constexpr uint32_t YEAR = (4 << 16);  ///< Timestamp Year
        constexpr uint32_t MON = (8 << 8);  ///< Timestamp Month
        constexpr uint32_t DAY = (8 << 0);  ///< Timestamp Day
    }

    /// FDCAN_ENDN Register bits
    namespace fdcan_endn_bits {
        constexpr uint32_t ETV = (32 << 0);  ///< Endiannes Test Value
    }

    /// FDCAN_DBTP Register bits
    namespace fdcan_dbtp_bits {
        constexpr uint32_t DSJW = (4 << 0);  ///< Synchronization Jump Width
        constexpr uint32_t DTSEG2 = (4 << 4);  ///< Data time segment after sample point
        constexpr uint32_t DTSEG1 = (5 << 8);  ///< Data time segment after sample point
        constexpr uint32_t DBRP = (5 << 16);  ///< Data BIt Rate Prescaler
        constexpr uint32_t TDC = (1U << 23);  ///< Transceiver Delay Compensation
    }

    /// FDCAN_TEST Register bits
    namespace fdcan_test_bits {
        constexpr uint32_t LBCK = (1U << 4);  ///< Loop Back mode
        constexpr uint32_t TX = (2 << 5);  ///< Loop Back mode
        constexpr uint32_t RX = (1U << 7);  ///< Control of Transmit Pin
    }

    /// FDCAN_RWD Register bits
    namespace fdcan_rwd_bits {
        constexpr uint32_t WDV = (8 << 8);  ///< Watchdog value
        constexpr uint32_t WDC = (8 << 0);  ///< Watchdog configuration
    }

    /// FDCAN_CCCR Register bits
    namespace fdcan_cccr_bits {
        constexpr uint32_t INIT = (1U << 0);  ///< Initialization
        constexpr uint32_t CCE = (1U << 1);  ///< Configuration Change Enable
        constexpr uint32_t ASM = (1U << 2);  ///< ASM Restricted Operation Mode
        constexpr uint32_t CSA = (1U << 3);  ///< Clock Stop Acknowledge
        constexpr uint32_t CSR = (1U << 4);  ///< Clock Stop Request
        constexpr uint32_t MON = (1U << 5);  ///< Bus Monitoring Mode
        constexpr uint32_t DAR = (1U << 6);  ///< Disable Automatic Retransmission
        constexpr uint32_t TEST = (1U << 7);  ///< Test Mode Enable
        constexpr uint32_t FDOE = (1U << 8);  ///< FD Operation Enable
        constexpr uint32_t BSE = (1U << 9);  ///< FDCAN Bit Rate Switching
        constexpr uint32_t PXHD = (1U << 12);  ///< Protocol Exception Handling Disable
        constexpr uint32_t EFBI = (1U << 13);  ///< Edge Filtering during Bus Integration
        constexpr uint32_t TXP = (1U << 14);  ///< TXP
        constexpr uint32_t NISO = (1U << 15);  ///< Non ISO Operation
    }

    /// FDCAN_NBTP Register bits
    namespace fdcan_nbtp_bits {
        constexpr uint32_t NSJW = (7 << 25);  ///< NSJW: Nominal (Re)Synchronization Jump Width
        constexpr uint32_t NBRP = (9 << 16);  ///< Bit Rate Prescaler
        constexpr uint32_t NTSEG1 = (8 << 8);  ///< Nominal Time segment before sample point
        constexpr uint32_t TSEG2 = (7 << 0);  ///< Nominal Time segment after sample point
    }

    /// FDCAN_TSCC Register bits
    namespace fdcan_tscc_bits {
        constexpr uint32_t TCP = (4 << 16);  ///< Timestamp Counter Prescaler
        constexpr uint32_t TSS = (2 << 0);  ///< Timestamp Select
    }

    /// FDCAN_TSCV Register bits
    namespace fdcan_tscv_bits {
        constexpr uint32_t TSC = (16 << 0);  ///< Timestamp Counter
    }

    /// FDCAN_TOCC Register bits
    namespace fdcan_tocc_bits {
        constexpr uint32_t ETOC = (1U << 0);  ///< Enable Timeout Counter
        constexpr uint32_t TOS = (2 << 1);  ///< Timeout Select
        constexpr uint32_t TOP = (16 << 16);  ///< Timeout Period
    }

    /// FDCAN_TOCV Register bits
    namespace fdcan_tocv_bits {
        constexpr uint32_t TOC = (16 << 0);  ///< Timeout Counter
    }

    /// FDCAN_ECR Register bits
    namespace fdcan_ecr_bits {
        constexpr uint32_t CEL = (8 << 16);  ///< AN Error Logging
        constexpr uint32_t RP = (1U << 15);  ///< Receive Error Passive
        constexpr uint32_t REC = (7 << 8);  ///< Receive Error Counter
        constexpr uint32_t TEC = (8 << 0);  ///< Transmit Error Counter
    }

    /// FDCAN_PSR Register bits
    namespace fdcan_psr_bits {
        constexpr uint32_t LEC = (3 << 0);  ///< Last Error Code
        constexpr uint32_t ACT = (2 << 3);  ///< Activity
        constexpr uint32_t EP = (1U << 5);  ///< Error Passive
        constexpr uint32_t EW = (1U << 6);  ///< Warning Status
        constexpr uint32_t BO = (1U << 7);  ///< Bus_Off Status
        constexpr uint32_t DLEC = (3 << 8);  ///< Data Last Error Code
        constexpr uint32_t RESI = (1U << 11);  ///< ESI flag of last received FDCAN Message
        constexpr uint32_t RBRS = (1U << 12);  ///< BRS flag of last received FDCAN Message
        constexpr uint32_t REDL = (1U << 13);  ///< Received FDCAN Message
        constexpr uint32_t PXE = (1U << 14);  ///< Protocol Exception Event
        constexpr uint32_t TDCV = (7 << 16);  ///< Transmitter Delay Compensation Value
    }

    /// FDCAN_TDCR Register bits
    namespace fdcan_tdcr_bits {
        constexpr uint32_t TDCF = (7 << 0);  ///< Transmitter Delay Compensation Filter Window Length
        constexpr uint32_t TDCO = (7 << 8);  ///< Transmitter Delay Compensation Offset
    }

    /// FDCAN_IR Register bits
    namespace fdcan_ir_bits {
        constexpr uint32_t RF0N = (1U << 0);  ///< RF0N
        constexpr uint32_t RF0F = (1U << 1);  ///< RF0F
        constexpr uint32_t RF0L = (1U << 2);  ///< RF0L
        constexpr uint32_t RF1N = (1U << 3);  ///< RF1N
        constexpr uint32_t RF1F = (1U << 4);  ///< RF1F
        constexpr uint32_t RF1L = (1U << 5);  ///< RF1L
        constexpr uint32_t HPM = (1U << 6);  ///< HPM
        constexpr uint32_t TC = (1U << 7);  ///< TC
        constexpr uint32_t TCF = (1U << 8);  ///< TCF
        constexpr uint32_t TFE = (1U << 9);  ///< TFE
        constexpr uint32_t TEFN = (1U << 10);  ///< TEFN
        constexpr uint32_t TEFF = (1U << 11);  ///< TEFF
        constexpr uint32_t TEFL = (1U << 12);  ///< TEFL
        constexpr uint32_t TSW = (1U << 13);  ///< TSW
        constexpr uint32_t MRAF = (1U << 14);  ///< MRAF
        constexpr uint32_t TOO = (1U << 15);  ///< TOO
        constexpr uint32_t ELO = (1U << 16);  ///< ELO
        constexpr uint32_t EP = (1U << 17);  ///< EP
        constexpr uint32_t EW = (1U << 18);  ///< EW
        constexpr uint32_t BO = (1U << 19);  ///< BO
        constexpr uint32_t WDI = (1U << 20);  ///< WDI
        constexpr uint32_t PEA = (1U << 21);  ///< PEA
        constexpr uint32_t PED = (1U << 22);  ///< PED
        constexpr uint32_t ARA = (1U << 23);  ///< ARA
    }

    /// FDCAN_IE Register bits
    namespace fdcan_ie_bits {
        constexpr uint32_t RF0NE = (1U << 0);  ///< Rx FIFO 0 New Message Enable
        constexpr uint32_t RF0FE = (1U << 1);  ///< Rx FIFO 0 Full Enable
        constexpr uint32_t RF0LE = (1U << 2);  ///< Rx FIFO 0 Message Lost Enable
        constexpr uint32_t RF1NE = (1U << 3);  ///< Rx FIFO 1 New Message Enable
        constexpr uint32_t RF1FE = (1U << 4);  ///< Rx FIFO 1 Watermark Reached Enable
        constexpr uint32_t RF1LE = (1U << 5);  ///< Rx FIFO 1 Message Lost Enable
        constexpr uint32_t HPME = (1U << 6);  ///< High Priority Message Enable
        constexpr uint32_t TCE = (1U << 7);  ///< Transmission Completed Enable
        constexpr uint32_t TCFE = (1U << 8);  ///< Transmission Cancellation Finished Enable
        constexpr uint32_t TEFE = (1U << 9);  ///< Tx FIFO Empty Enable
        constexpr uint32_t TEFNE = (1U << 10);  ///< Tx Event FIFO New Entry Enable
        constexpr uint32_t TEFFE = (1U << 11);  ///< Tx Event FIFO Full Enable
        constexpr uint32_t TEFLE = (1U << 12);  ///< Tx Event FIFO Element Lost Enable
        constexpr uint32_t MRAFE = (1U << 13);  ///< Message RAM Access Failure Enable
        constexpr uint32_t TOOE = (1U << 14);  ///< Timeout Occurred Enable
        constexpr uint32_t ELOE = (1U << 15);  ///< Error Logging Overflow Enable
        constexpr uint32_t EPE = (1U << 16);  ///< Error Passive Enable
        constexpr uint32_t EWE = (1U << 17);  ///< Warning Status Enable
        constexpr uint32_t BOE = (1U << 18);  ///< Bus_Off Status Enable
        constexpr uint32_t WDIE = (1U << 19);  ///< Watchdog Interrupt Enable
        constexpr uint32_t PEAE = (1U << 20);  ///< Protocol Error in Arbitration Phase Enable
        constexpr uint32_t PEDE = (1U << 21);  ///< Protocol Error in Data Phase Enable
        constexpr uint32_t ARAE = (1U << 22);  ///< Access to Reserved Address Enable
    }

    /// FDCAN_ILS Register bits
    namespace fdcan_ils_bits {
        constexpr uint32_t RxFIFO0 = (1U << 0);  ///< RxFIFO0
        constexpr uint32_t RxFIFO1 = (1U << 1);  ///< RxFIFO1
        constexpr uint32_t SMSG = (1U << 2);  ///< SMSG
        constexpr uint32_t TFERR = (1U << 3);  ///< TFERR
        constexpr uint32_t MISC = (1U << 4);  ///< MISC
        constexpr uint32_t BERR = (1U << 5);  ///< BERR
        constexpr uint32_t PERR = (1U << 6);  ///< PERR
    }

    /// FDCAN_ILE Register bits
    namespace fdcan_ile_bits {
        constexpr uint32_t EINT0 = (1U << 0);  ///< Enable Interrupt Line 0
        constexpr uint32_t EINT1 = (1U << 1);  ///< Enable Interrupt Line 1
    }

    /// FDCAN_RXGFC Register bits
    namespace fdcan_rxgfc_bits {
        constexpr uint32_t RRFE = (1U << 0);  ///< Reject Remote Frames Extended
        constexpr uint32_t RRFS = (1U << 1);  ///< Reject Remote Frames Standard
        constexpr uint32_t ANFE = (2 << 2);  ///< Accept Non-matching Frames Extended
        constexpr uint32_t ANFS = (2 << 4);  ///< Accept Non-matching Frames Standard
        constexpr uint32_t F1OM = (1U << 8);  ///< F1OM
        constexpr uint32_t F0OM = (1U << 9);  ///< F0OM
        constexpr uint32_t LSS = (5 << 16);  ///< LSS
        constexpr uint32_t LSE = (4 << 24);  ///< LSE
    }

    /// FDCAN_XIDAM Register bits
    namespace fdcan_xidam_bits {
        constexpr uint32_t EIDM = (29 << 0);  ///< Extended ID Mask
    }

    /// FDCAN_HPMS Register bits
    namespace fdcan_hpms_bits {
        constexpr uint32_t BIDX = (3 << 0);  ///< Buffer Index
        constexpr uint32_t MSI = (2 << 6);  ///< Message Storage Indicator
        constexpr uint32_t FIDX = (5 << 8);  ///< Filter Index
        constexpr uint32_t FLST = (1U << 15);  ///< Filter List
    }

    /// FDCAN_RXF0S Register bits
    namespace fdcan_rxf0s_bits {
        constexpr uint32_t F0FL = (4 << 0);  ///< Rx FIFO 0 Fill Level
        constexpr uint32_t F0GI = (2 << 8);  ///< Rx FIFO 0 Get Index
        constexpr uint32_t F0PI = (2 << 16);  ///< Rx FIFO 0 Put Index
        constexpr uint32_t F0F = (1U << 24);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0L = (1U << 25);  ///< Rx FIFO 0 Message Lost
    }

    /// FDCAN_RXF0A Register bits
    namespace fdcan_rxf0a_bits {
        constexpr uint32_t F0AI = (3 << 0);  ///< Rx FIFO 0 Acknowledge Index
    }

    /// FDCAN_RXF1S Register bits
    namespace fdcan_rxf1s_bits {
        constexpr uint32_t F1FL = (4 << 0);  ///< Rx FIFO 1 Fill Level
        constexpr uint32_t F1GI = (2 << 8);  ///< Rx FIFO 1 Get Index
        constexpr uint32_t F1PI = (2 << 16);  ///< Rx FIFO 1 Put Index
        constexpr uint32_t F1F = (1U << 24);  ///< Rx FIFO 1 Full
        constexpr uint32_t RF1L = (1U << 25);  ///< Rx FIFO 1 Message Lost
    }

    /// FDCAN_RXF1A Register bits
    namespace fdcan_rxf1a_bits {
        constexpr uint32_t F1AI = (3 << 0);  ///< Rx FIFO 1 Acknowledge Index
    }

    /// FDCAN_TXFQS Register bits
    namespace fdcan_txfqs_bits {
        constexpr uint32_t TFFL = (3 << 0);  ///< Tx FIFO Free Level
        constexpr uint32_t TFGI = (2 << 8);  ///< TFGI
        constexpr uint32_t TFQPI = (2 << 16);  ///< Tx FIFO/Queue Put Index
        constexpr uint32_t TFQF = (1U << 21);  ///< Tx FIFO/Queue Full
    }

    /// FDCAN_TXBRP Register bits
    namespace fdcan_txbrp_bits {
        constexpr uint32_t TRP = (3 << 0);  ///< Transmission Request Pending
    }

    /// FDCAN_TXBAR Register bits
    namespace fdcan_txbar_bits {
        constexpr uint32_t AR = (3 << 0);  ///< Add Request
    }

    /// FDCAN_TXBCR Register bits
    namespace fdcan_txbcr_bits {
        constexpr uint32_t CR = (3 << 0);  ///< Cancellation Request
    }

    /// FDCAN_TXBTO Register bits
    namespace fdcan_txbto_bits {
        constexpr uint32_t TO = (3 << 0);  ///< Transmission Occurred.
    }

    /// FDCAN_TXBCF Register bits
    namespace fdcan_txbcf_bits {
        constexpr uint32_t CF = (3 << 0);  ///< Cancellation Finished
    }

    /// FDCAN_TXBTIE Register bits
    namespace fdcan_txbtie_bits {
        constexpr uint32_t TIE = (3 << 0);  ///< Transmission Interrupt Enable
    }

    /// FDCAN_TXBCIE Register bits
    namespace fdcan_txbcie_bits {
        constexpr uint32_t CF = (3 << 0);  ///< Cancellation Finished Interrupt Enable
    }

    /// FDCAN_TXEFS Register bits
    namespace fdcan_txefs_bits {
        constexpr uint32_t EFFL = (3 << 0);  ///< Event FIFO Fill Level
        constexpr uint32_t EFGI = (2 << 8);  ///< Event FIFO Get Index.
        constexpr uint32_t EFF = (1U << 24);  ///< Event FIFO Full.
        constexpr uint32_t TEFL = (1U << 25);  ///< Tx Event FIFO Element Lost.
        constexpr uint32_t EFPI = (2 << 16);  ///< Event FIFO Put Index
    }

    /// FDCAN_TXEFA Register bits
    namespace fdcan_txefa_bits {
        constexpr uint32_t EFAI = (2 << 0);  ///< Event FIFO Acknowledge Index
    }

    /// FDCAN_CKDIV Register bits
    namespace fdcan_ckdiv_bits {
        constexpr uint32_t PDIV = (4 << 0);  ///< PDIV
    }

    /// FDCAN_TXBC Register bits
    namespace fdcan_txbc_bits {
        constexpr uint32_t TFQM = (1U << 24);  ///< Tx FIFO/Queue Mode
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (8 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t Polynomialcoefficients = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// CRS Peripheral
// ============================================================================

namespace crs {
    /// Base addresses
    constexpr uint32_t CRS_BASE = 0x40006000;

    /// CRS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - configuration register
        volatile uint32_t ISR;  ///< Offset: 0x08 - interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x0C - interrupt flag clear register
    };

    /// Peripheral instances
    inline Registers* CRS = reinterpret_cast<Registers*>(CRS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TRIM = (7 << 8);  ///< HSI48 oscillator smooth trimming
        constexpr uint32_t SWSYNC = (1U << 7);  ///< Generate software SYNC event
        constexpr uint32_t AUTOTRIMEN = (1U << 6);  ///< Automatic trimming enable
        constexpr uint32_t CEN = (1U << 5);  ///< Frequency error counter enable
        constexpr uint32_t ESYNCIE = (1U << 3);  ///< Expected SYNC interrupt enable
        constexpr uint32_t ERRIE = (1U << 2);  ///< Synchronization or trimming error interrupt enable
        constexpr uint32_t SYNCWARNIE = (1U << 1);  ///< SYNC warning interrupt enable
        constexpr uint32_t SYNCOKIE = (1U << 0);  ///< SYNC event OK interrupt enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SYNCPOL = (1U << 31);  ///< SYNC polarity selection
        constexpr uint32_t SYNCSRC = (2 << 28);  ///< SYNC signal source selection
        constexpr uint32_t SYNCDIV = (3 << 24);  ///< SYNC divider
        constexpr uint32_t FELIM = (8 << 16);  ///< Frequency error limit
        constexpr uint32_t RELOAD = (16 << 0);  ///< Counter reload value
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t FECAP = (16 << 16);  ///< Frequency error capture
        constexpr uint32_t FEDIR = (1U << 15);  ///< Frequency error direction
        constexpr uint32_t TRIMOVF = (1U << 10);  ///< Trimming overflow or underflow
        constexpr uint32_t SYNCMISS = (1U << 9);  ///< SYNC missed
        constexpr uint32_t SYNCERR = (1U << 8);  ///< SYNC error
        constexpr uint32_t ESYNCF = (1U << 3);  ///< Expected SYNC flag
        constexpr uint32_t ERRF = (1U << 2);  ///< Error flag
        constexpr uint32_t SYNCWARNF = (1U << 1);  ///< SYNC warning flag
        constexpr uint32_t SYNCOKF = (1U << 0);  ///< SYNC event OK flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ESYNCC = (1U << 3);  ///< Expected SYNC clear flag
        constexpr uint32_t ERRC = (1U << 2);  ///< Error clear flag
        constexpr uint32_t SYNCWARNC = (1U << 1);  ///< SYNC warning clear flag
        constexpr uint32_t SYNCOKC = (1U << 0);  ///< SYNC event OK clear flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_Common_BASE = 0x42028300;
    constexpr uint32_t SEC_ADC_Common_BASE = 0x52028300;
    constexpr uint32_t ADC_BASE = 0x42028000;
    constexpr uint32_t SEC_ADC_BASE = 0x52028000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - ADC Common status register
        volatile uint32_t CCR;  ///< Offset: 0x08 - ADC common control register
        volatile uint32_t CDR;  ///< Offset: 0x0C - Common regular data register for dual mode
    };

    /// Peripheral instances
    inline Registers* ADC_Common = reinterpret_cast<Registers*>(ADC_Common_BASE);
    inline Registers* SEC_ADC_Common = reinterpret_cast<Registers*>(SEC_ADC_Common_BASE);
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);
    inline Registers* SEC_ADC = reinterpret_cast<Registers*>(SEC_ADC_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ADDRDY_MST = (1U << 0);  ///< ADDRDY_MST
        constexpr uint32_t EOSMP_MST = (1U << 1);  ///< EOSMP_MST
        constexpr uint32_t EOC_MST = (1U << 2);  ///< EOC_MST
        constexpr uint32_t EOS_MST = (1U << 3);  ///< EOS_MST
        constexpr uint32_t OVR_MST = (1U << 4);  ///< OVR_MST
        constexpr uint32_t JEOC_MST = (1U << 5);  ///< JEOC_MST
        constexpr uint32_t JEOS_MST = (1U << 6);  ///< JEOS_MST
        constexpr uint32_t AWD1_MST = (1U << 7);  ///< AWD1_MST
        constexpr uint32_t AWD2_MST = (1U << 8);  ///< AWD2_MST
        constexpr uint32_t AWD3_MST = (1U << 9);  ///< AWD3_MST
        constexpr uint32_t JQOVF_MST = (1U << 10);  ///< JQOVF_MST
        constexpr uint32_t ADRDY_SLV = (1U << 16);  ///< ADRDY_SLV
        constexpr uint32_t EOSMP_SLV = (1U << 17);  ///< EOSMP_SLV
        constexpr uint32_t EOC_SLV = (1U << 18);  ///< EOC_SLV
        constexpr uint32_t EOS_SLV = (1U << 19);  ///< EOS_SLV
        constexpr uint32_t OVR_SLV = (1U << 20);  ///< OVR_SLV
        constexpr uint32_t JEOC_SLV = (1U << 21);  ///< JEOC_SLV
        constexpr uint32_t JEOS_SLV = (1U << 22);  ///< JEOS_SLV
        constexpr uint32_t AWD1_SLV = (1U << 23);  ///< AWD1_SLV
        constexpr uint32_t AWD2_SLV = (1U << 24);  ///< AWD2_SLV
        constexpr uint32_t AWD3_SLV = (1U << 25);  ///< AWD3_SLV
        constexpr uint32_t JQOVF_SLV = (1U << 26);  ///< JQOVF_SLV
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t CKMODE = (2 << 16);  ///< ADC clock mode
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler
        constexpr uint32_t VREFEN = (1U << 22);  ///< VREFINT enable
        constexpr uint32_t CH17SEL = (1U << 23);  ///< CH17SEL
        constexpr uint32_t CH18SEL = (1U << 24);  ///< CH18SEL
        constexpr uint32_t MDMA = (2 << 14);  ///< MDMA
        constexpr uint32_t DMACFG = (1U << 13);  ///< DMACFG
        constexpr uint32_t DELAY = (3 << 8);  ///< DELAY
        constexpr uint32_t DUAL = (5 << 0);  ///< DUAL
    }

    /// CDR Register bits
    namespace cdr_bits {
        constexpr uint32_t RDATA_MST = (16 << 0);  ///< RDATA_MST
        constexpr uint32_t RDATA_SLV = (16 << 16);  ///< RDATA_SLV
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;
    constexpr uint32_t NVIC_STIR_BASE = 0xE000EF00;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ISER0;  ///< Offset: 0x00 - Interrupt Set-Enable Register
        volatile uint32_t ISER1;  ///< Offset: 0x04 - Interrupt Set-Enable Register
        volatile uint32_t ISER2;  ///< Offset: 0x08 - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x80 - Interrupt Clear-Enable Register
        volatile uint32_t ICER1;  ///< Offset: 0x84 - Interrupt Clear-Enable Register
        volatile uint32_t ICER2;  ///< Offset: 0x88 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x100 - Interrupt Set-Pending Register
        volatile uint32_t ISPR1;  ///< Offset: 0x104 - Interrupt Set-Pending Register
        volatile uint32_t ISPR2;  ///< Offset: 0x108 - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x180 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR1;  ///< Offset: 0x184 - Interrupt Clear-Pending Register
        volatile uint32_t ICPR2;  ///< Offset: 0x188 - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x200 - Interrupt Active Bit Register
        volatile uint32_t IABR1;  ///< Offset: 0x204 - Interrupt Active Bit Register
        volatile uint32_t IABR2;  ///< Offset: 0x208 - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x300 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x304 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x308 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x30C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x310 - Interrupt Priority Register
        volatile uint32_t IPR5;  ///< Offset: 0x314 - Interrupt Priority Register
        volatile uint32_t IPR6;  ///< Offset: 0x318 - Interrupt Priority Register
        volatile uint32_t IPR7;  ///< Offset: 0x31C - Interrupt Priority Register
        volatile uint32_t IPR8;  ///< Offset: 0x320 - Interrupt Priority Register
        volatile uint32_t IPR9;  ///< Offset: 0x324 - Interrupt Priority Register
        volatile uint32_t IPR10;  ///< Offset: 0x328 - Interrupt Priority Register
        volatile uint32_t IPR11;  ///< Offset: 0x32C - Interrupt Priority Register
        volatile uint32_t IPR12;  ///< Offset: 0x330 - Interrupt Priority Register
        volatile uint32_t IPR13;  ///< Offset: 0x334 - Interrupt Priority Register
        volatile uint32_t IPR14;  ///< Offset: 0x338 - Interrupt Priority Register
        volatile uint32_t IPR15;  ///< Offset: 0x33C - Interrupt Priority Register
        volatile uint32_t IPR16;  ///< Offset: 0x340 - Interrupt Priority Register
        volatile uint32_t IPR17;  ///< Offset: 0x344 - Interrupt Priority Register
        volatile uint32_t IPR18;  ///< Offset: 0x348 - Interrupt Priority Register
        volatile uint32_t IPR19;  ///< Offset: 0x34C - Interrupt Priority Register
        volatile uint32_t IPR20;  ///< Offset: 0x350 - Interrupt Priority Register
        volatile uint32_t ISER3;  ///< Offset: 0x0C - Interrupt Set-Enable Register
        volatile uint32_t ICER3;  ///< Offset: 0x8C - Interrupt Clear-Enable Register
        volatile uint32_t ISPR3;  ///< Offset: 0x10C - Interrupt Set-Pending Register
        volatile uint32_t ICPR3;  ///< Offset: 0x18C - Interrupt Clear-Pending Register
        volatile uint32_t IABR3;  ///< Offset: 0x20C - Interrupt Active Bit Register
        volatile uint32_t IPR21;  ///< Offset: 0x354 - IPR21
        volatile uint32_t IPR22;  ///< Offset: 0x358 - IPR22
        volatile uint32_t IPR23;  ///< Offset: 0x35C - IPR23
        volatile uint32_t IPR24;  ///< Offset: 0x360 - IPR24
        volatile uint32_t IPR25;  ///< Offset: 0x364 - IPR25
        volatile uint32_t IPR26;  ///< Offset: 0x368 - IPR26
        volatile uint32_t IPR27;  ///< Offset: 0x36C - IPR27
        volatile uint32_t IPR28;  ///< Offset: 0x370 - IPR28
        volatile uint32_t IPR29;  ///< Offset: 0x374 - IPR29
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);
    inline Registers* NVIC_STIR = reinterpret_cast<Registers*>(NVIC_STIR_BASE);

    // Bit definitions
    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER1 Register bits
    namespace iser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ISER2 Register bits
    namespace iser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER1 Register bits
    namespace icer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ICER2 Register bits
    namespace icer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR1 Register bits
    namespace ispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ISPR2 Register bits
    namespace ispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR1 Register bits
    namespace icpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// ICPR2 Register bits
    namespace icpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR1 Register bits
    namespace iabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IABR2 Register bits
    namespace iabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR5 Register bits
    namespace ipr5_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR6 Register bits
    namespace ipr6_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR7 Register bits
    namespace ipr7_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR8 Register bits
    namespace ipr8_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR9 Register bits
    namespace ipr9_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR10 Register bits
    namespace ipr10_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR11 Register bits
    namespace ipr11_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR12 Register bits
    namespace ipr12_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR13 Register bits
    namespace ipr13_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR14 Register bits
    namespace ipr14_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR15 Register bits
    namespace ipr15_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR16 Register bits
    namespace ipr16_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR17 Register bits
    namespace ipr17_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR18 Register bits
    namespace ipr18_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR19 Register bits
    namespace ipr19_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR20 Register bits
    namespace ipr20_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x44020000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t FMC_BCR1;  ///< Offset: 0x00 - FMC_BCR1
        volatile uint32_t FMC_BCR2;  ///< Offset: 0x08 - FMC_BCR2
        volatile uint32_t FMC_BCR3;  ///< Offset: 0x10 - >FMC_BCR3
        volatile uint32_t FMC_BCR4;  ///< Offset: 0x18 - >FMC_BCR4
        volatile uint32_t FMC_BTR1;  ///< Offset: 0x04 - This register contains the control information of each...
        volatile uint32_t FMC_BTR2;  ///< Offset: 0x0C - FMC_BTR2
        volatile uint32_t FMC_BTR3;  ///< Offset: 0x14 - FMC_BTR3
        volatile uint32_t FMC_BTR4;  ///< Offset: 0x1C - FMC_BTR4
        volatile uint32_t FMC_PCR;  ///< Offset: 0x80 - NAND Flash control registers
        volatile uint32_t FMC_SR;  ///< Offset: 0x84 - This register contains information about the FIFO status...
        volatile uint32_t FMC_PMEM;  ///< Offset: 0x88 - The FMC_PMEM read/write register contains the timing...
        volatile uint32_t FMC_PATT;  ///< Offset: 0x8C - The FMC_PATT read/write register contains the timing...
        volatile uint32_t FMC_ECCR;  ///< Offset: 0x94 - This register contain the current error correction code...
        volatile uint32_t FMC_BWTR1;  ///< Offset: 0x104 - This register contains the control information of each...
        volatile uint32_t FMC_BWTR2;  ///< Offset: 0x10C - This register contains the control information of each...
        volatile uint32_t FMC_BWTR3;  ///< Offset: 0x114 - This register contains the control information of each...
        volatile uint32_t FMC_BWTR4;  ///< Offset: 0x11C - This register contains the control information of each...
        volatile uint32_t PCSCNTR;  ///< Offset: 0x20 - PCSCNTR
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// FMC_BCR1 Register bits
    namespace fmc_bcr1_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t NBLSET = (2 << 22);  ///< NBLSET
    }

    /// FMC_BCR2 Register bits
    namespace fmc_bcr2_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t NBLSET = (2 << 22);  ///< NBLSET
    }

    /// FMC_BCR3 Register bits
    namespace fmc_bcr3_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t NBLSET = (2 << 22);  ///< NBLSET
    }

    /// FMC_BCR4 Register bits
    namespace fmc_bcr4_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type These bits define the type of external memory attached to the corresponding memory bank:
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width Defines the external memory device width, valid for all type of memories.
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable This bit enables NOR Flash memory access operations.
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
        constexpr uint32_t NBLSET = (2 << 22);  ///< NBLSET
    }

    /// FMC_BTR1 Register bits
    namespace fmc_btr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        constexpr uint32_t DATAHLD = (2 << 30);  ///< DATAHLD
    }

    /// FMC_BTR2 Register bits
    namespace fmc_btr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        constexpr uint32_t DATAHLD = (2 << 30);  ///< DATAHLD
    }

    /// FMC_BTR3 Register bits
    namespace fmc_btr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        constexpr uint32_t DATAHLD = (2 << 30);  ///< DATAHLD
    }

    /// FMC_BTR4 Register bits
    namespace fmc_btr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
        constexpr uint32_t DATAHLD = (2 << 30);  ///< DATAHLD
    }

    /// FMC_PCR Register bits
    namespace fmc_pcr_bits {
        constexpr uint32_t PWAITEN = (1U << 1);  ///< Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:
        constexpr uint32_t PBKEN = (1U << 2);  ///< NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
        constexpr uint32_t PTYP = (1U << 3);  ///< Memory type
        constexpr uint32_t PWID = (2 << 4);  ///< Data bus width. These bits define the external memory device width.
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECC computation logic enable bit
        constexpr uint32_t TCLR = (4 << 9);  ///< CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
        constexpr uint32_t TAR = (4 << 13);  ///< ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECC page size. These bits define the page size for the extended ECC:
    }

    /// FMC_SR Register bits
    namespace fmc_sr_bits {
        constexpr uint32_t IRS = (1U << 0);  ///< Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t ILS = (1U << 1);  ///< Interrupt high-level status The flag is set by hardware and reset by software.
        constexpr uint32_t IFS = (1U << 2);  ///< Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t IREN = (1U << 3);  ///< Interrupt rising edge detection enable bit
        constexpr uint32_t ILEN = (1U << 4);  ///< Interrupt high-level detection enable bit
        constexpr uint32_t IFEN = (1U << 5);  ///< Interrupt falling edge detection enable bit
        constexpr uint32_t FEMPT = (1U << 6);  ///< FIFO empty. Read-only bit that provides the status of the FIFO
    }

    /// FMC_PMEM Register bits
    namespace fmc_pmem_bits {
        constexpr uint32_t MEMSET = (8 << 0);  ///< Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMWAIT = (8 << 8);  ///< Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t MEMHOLD = (8 << 16);  ///< Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMHIZ = (8 << 24);  ///< Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
    }

    /// FMC_PATT Register bits
    namespace fmc_patt_bits {
        constexpr uint32_t ATTSET = (8 << 0);  ///< Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTWAIT = (8 << 8);  ///< Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t ATTHOLD = (8 << 16);  ///< Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTHIZ = (8 << 24);  ///< Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
    }

    /// FMC_ECCR Register bits
    namespace fmc_eccr_bits {
        constexpr uint32_t ECC = (32 << 0);  ///< ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
    }

    /// FMC_BWTR1 Register bits
    namespace fmc_bwtr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// FMC_BWTR2 Register bits
    namespace fmc_bwtr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// FMC_BWTR3 Register bits
    namespace fmc_bwtr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// FMC_BWTR4 Register bits
    namespace fmc_bwtr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    }

    /// PCSCNTR Register bits
    namespace pcscntr_bits {
        constexpr uint32_t CSCOUNT = (16 << 0);  ///< Chip select counter
        constexpr uint32_t CNTB1EN = (1U << 16);  ///< Counter Bank 1 enable
        constexpr uint32_t CNTB2EN = (1U << 17);  ///< Counter Bank 2 enable
        constexpr uint32_t CNTB3EN = (1U << 18);  ///< Counter Bank 3 enable
        constexpr uint32_t CNTB4EN = (1U << 19);  ///< Counter Bank 4 enable
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x420C0800;
    constexpr uint32_t SEC_RNG_BASE = 0x520C0800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t RNG_CR;  ///< Offset: 0x00 - RNG control register
        volatile uint32_t RNG_SR;  ///< Offset: 0x04 - RNG status register
        volatile uint32_t RNG_DR;  ///< Offset: 0x08 - The RNG_DR register is a read-only register that...
        volatile uint32_t RNG_HTCR;  ///< Offset: 0x10 - The RNG_DR register is a read-only register that...
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);
    inline Registers* SEC_RNG = reinterpret_cast<Registers*>(SEC_RNG_BASE);

    // Bit definitions
    /// RNG_CR Register bits
    namespace rng_cr_bits {
        constexpr uint32_t RNGEN = (1U << 2);  ///< Random number generator enable
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
        constexpr uint32_t RNG_CONFIG3 = (4 << 8);  ///< RNG configuration 3
        constexpr uint32_t NISTC = (1U << 12);  ///< Non NIST compliant
        constexpr uint32_t RNG_CONFIG2 = (3 << 13);  ///< RNG configuration 2
        constexpr uint32_t CLKDIV = (4 << 16);  ///< Clock divider factor
        constexpr uint32_t RNG_CONFIG1 = (6 << 20);  ///< RNG configuration 1
        constexpr uint32_t CONDRST = (1U << 30);  ///< Conditioning soft reset
        constexpr uint32_t CONFIGLOCK = (1U << 31);  ///< RNG Config Lock
    }

    /// RNG_SR Register bits
    namespace rng_sr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated.
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01)
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register.
    }

    /// RNG_DR Register bits
    namespace rng_dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data 32-bit random data which are valid when DRDY=1.
    }

    /// RNG_HTCR Register bits
    namespace rng_htcr_bits {
        constexpr uint32_t HTCFG = (32 << 0);  ///< health test configuration
    }

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC1_BASE = 0x420C8000;
    constexpr uint32_t SEC_SDMMC1_BASE = 0x520C8000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t SDMMC_POWER;  ///< Offset: 0x00 - SDMMC power control register
        volatile uint32_t SDMMC_CLKCR;  ///< Offset: 0x04 - The SDMMC_CLKCR register controls the SDMMC_CK output...
        volatile uint32_t SDMMC_ARGR;  ///< Offset: 0x08 - The SDMMC_ARGR register contains a 32-bit command...
        volatile uint32_t SDMMC_CMDR;  ///< Offset: 0x0C - The SDMMC_CMDR register contains the command index and...
        volatile uint32_t SDMMC_RESP1R;  ///< Offset: 0x14 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_RESP2R;  ///< Offset: 0x18 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_RESP3R;  ///< Offset: 0x1C - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_RESP4R;  ///< Offset: 0x20 - The SDMMC_RESP1/2/3/4R registers contain the status of a...
        volatile uint32_t SDMMC_DTIMER;  ///< Offset: 0x24 - The SDMMC_DTIMER register contains the data timeout...
        volatile uint32_t SDMMC_DLENR;  ///< Offset: 0x28 - The SDMMC_DLENR register contains the number of data...
        volatile uint32_t SDMMC_DCTRL;  ///< Offset: 0x2C - The SDMMC_DCTRL register control the data path state...
        volatile uint32_t SDMMC_DCNTR;  ///< Offset: 0x30 - The SDMMC_DCNTR register loads the value from the data...
        volatile uint32_t SDMMC_STAR;  ///< Offset: 0x34 - The SDMMC_STAR register is a read-only register. It...
        volatile uint32_t SDMMC_ICR;  ///< Offset: 0x38 - The SDMMC_ICR register is a write-only register. Writing...
        volatile uint32_t SDMMC_MASKR;  ///< Offset: 0x3C - The interrupt mask register determines which status...
        volatile uint32_t SDMMC_ACKTIMER;  ///< Offset: 0x40 - The SDMMC_ACKTIMER register contains the acknowledgment...
        volatile uint32_t SDMMC_IDMACTRLR;  ///< Offset: 0x50 - The receive and transmit FIFOs can be read or written as...
        volatile uint32_t SDMMC_IDMABSIZER;  ///< Offset: 0x54 - The SDMMC_IDMABSIZER register contains the buffers size...
        volatile uint32_t SDMMC_IDMABASE0R;  ///< Offset: 0x58 - The SDMMC_IDMABASE0R register contains the memory buffer...
        volatile uint32_t SDMMC_IDMABASE1R;  ///< Offset: 0x5C - The SDMMC_IDMABASE1R register contains the double buffer...
        volatile uint32_t SDMMC_FIFOR;  ///< Offset: 0x80 - The receive and transmit FIFOs can be only read or...
        volatile uint32_t SDMMC_VER;  ///< Offset: 0x3F4 - SDMMC IP version register
        volatile uint32_t SDMMC_ID;  ///< Offset: 0x3F8 - SDMMC IP identification register
        volatile uint32_t SDMMC_RESPCMDR;  ///< Offset: 0x10 - SDMMC command response register
    };

    /// Peripheral instances
    inline Registers* SDMMC1 = reinterpret_cast<Registers*>(SDMMC1_BASE);
    inline Registers* SEC_SDMMC1 = reinterpret_cast<Registers*>(SEC_SDMMC1_BASE);

    // Bit definitions
    /// SDMMC_POWER Register bits
    namespace sdmmc_power_bits {
        constexpr uint32_t PWRCTRL = (2 << 0);  ///< SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
        constexpr uint32_t VSWITCH = (1U << 2);  ///< Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
        constexpr uint32_t VSWITCHEN = (1U << 3);  ///< Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
        constexpr uint32_t DIRPOL = (1U << 4);  ///< Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    }

    /// SDMMC_CLKCR Register bits
    namespace sdmmc_clkcr_bits {
        constexpr uint32_t CLKDIV = (10 << 0);  ///< Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
        constexpr uint32_t PWRSAV = (1U << 12);  ///< Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
        constexpr uint32_t WIDBUS = (2 << 14);  ///< Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        constexpr uint32_t NEGEDGE = (1U << 16);  ///< SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
        constexpr uint32_t HWFC_EN = (1U << 17);  ///< Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
        constexpr uint32_t DDR = (1U << 18);  ///< Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
        constexpr uint32_t BUSSPEED = (1U << 19);  ///< Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
        constexpr uint32_t SELCLKRX = (2 << 20);  ///< Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    }

    /// SDMMC_ARGR Register bits
    namespace sdmmc_argr_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
    }

    /// SDMMC_CMDR Register bits
    namespace sdmmc_cmdr_bits {
        constexpr uint32_t CMDINDEX = (6 << 0);  ///< Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
        constexpr uint32_t CMDTRANS = (1U << 6);  ///< The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
        constexpr uint32_t CMDSTOP = (1U << 7);  ///< The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
        constexpr uint32_t WAITRESP = (2 << 8);  ///< Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
        constexpr uint32_t WAITINT = (1U << 10);  ///< CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
        constexpr uint32_t WAITPEND = (1U << 11);  ///< CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
        constexpr uint32_t CPSMEN = (1U << 12);  ///< Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
        constexpr uint32_t DTHOLD = (1U << 13);  ///< Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
        constexpr uint32_t BOOTMODE = (1U << 14);  ///< Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
        constexpr uint32_t BOOTEN = (1U << 15);  ///< Enable boot mode procedure.
        constexpr uint32_t CMDSUSPEND = (1U << 16);  ///< The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    }

    /// SDMMC_RESP1R Register bits
    namespace sdmmc_resp1r_bits {
        constexpr uint32_t CARDSTATUS1 = (32 << 0);  ///< see Table 432
    }

    /// SDMMC_RESP2R Register bits
    namespace sdmmc_resp2r_bits {
        constexpr uint32_t CARDSTATUS2 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_RESP3R Register bits
    namespace sdmmc_resp3r_bits {
        constexpr uint32_t CARDSTATUS3 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_RESP4R Register bits
    namespace sdmmc_resp4r_bits {
        constexpr uint32_t CARDSTATUS4 = (32 << 0);  ///< see Table404.
    }

    /// SDMMC_DTIMER Register bits
    namespace sdmmc_dtimer_bits {
        constexpr uint32_t DATATIME = (32 << 0);  ///< Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
    }

    /// SDMMC_DLENR Register bits
    namespace sdmmc_dlenr_bits {
        constexpr uint32_t DATALENGTH = (25 << 0);  ///< Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
    }

    /// SDMMC_DCTRL Register bits
    namespace sdmmc_dctrl_bits {
        constexpr uint32_t DTEN = (1U << 0);  ///< Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
        constexpr uint32_t DTDIR = (1U << 1);  ///< Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t DTMODE = (2 << 2);  ///< Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t DBLOCKSIZE = (4 << 4);  ///< Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
        constexpr uint32_t RWSTART = (1U << 8);  ///< Read wait start. If this bit is set, read wait operation starts.
        constexpr uint32_t RWSTOP = (1U << 9);  ///< Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
        constexpr uint32_t RWMOD = (1U << 10);  ///< Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
        constexpr uint32_t BOOTACKEN = (1U << 12);  ///< Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t FIFORST = (1U << 13);  ///< FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    }

    /// SDMMC_DCNTR Register bits
    namespace sdmmc_dcntr_bits {
        constexpr uint32_t DATACOUNT = (25 << 0);  ///< Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
    }

    /// SDMMC_STAR Register bits
    namespace sdmmc_star_bits {
        constexpr uint32_t CCRCFAIL = (1U << 0);  ///< Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DCRCFAIL = (1U << 1);  ///< Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CTIMEOUT = (1U << 2);  ///< Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
        constexpr uint32_t DTIMEOUT = (1U << 3);  ///< Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t TXUNDERR = (1U << 4);  ///< Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t RXOVERR = (1U << 5);  ///< Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CMDREND = (1U << 6);  ///< Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CMDSENT = (1U << 7);  ///< Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DATAEND = (1U << 8);  ///< Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DHOLD = (1U << 9);  ///< Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DBCKEND = (1U << 10);  ///< Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DABORT = (1U << 11);  ///< Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t DPSMACT = (1U << 12);  ///< Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
        constexpr uint32_t CPSMACT = (1U << 13);  ///< Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
        constexpr uint32_t TXFIFOHE = (1U << 14);  ///< Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
        constexpr uint32_t RXFIFOHF = (1U << 15);  ///< Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
        constexpr uint32_t TXFIFOF = (1U << 16);  ///< Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
        constexpr uint32_t RXFIFOF = (1U << 17);  ///< Receive FIFO full This bit is cleared when one FIFO location becomes empty.
        constexpr uint32_t TXFIFOE = (1U << 18);  ///< Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
        constexpr uint32_t RXFIFOE = (1U << 19);  ///< Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
        constexpr uint32_t BUSYD0 = (1U << 20);  ///< Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
        constexpr uint32_t BUSYD0END = (1U << 21);  ///< end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t SDIOIT = (1U << 22);  ///< SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t ACKFAIL = (1U << 23);  ///< Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t ACKTIMEOUT = (1U << 24);  ///< Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t VSWEND = (1U << 25);  ///< Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t CKSTOP = (1U << 26);  ///< SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t IDMATE = (1U << 27);  ///< IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
        constexpr uint32_t IDMABTC = (1U << 28);  ///< IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    }

    /// SDMMC_ICR Register bits
    namespace sdmmc_icr_bits {
        constexpr uint32_t CCRCFAILC = (1U << 0);  ///< CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
        constexpr uint32_t DCRCFAILC = (1U << 1);  ///< DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
        constexpr uint32_t CTIMEOUTC = (1U << 2);  ///< CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
        constexpr uint32_t DTIMEOUTC = (1U << 3);  ///< DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
        constexpr uint32_t TXUNDERRC = (1U << 4);  ///< TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
        constexpr uint32_t RXOVERRC = (1U << 5);  ///< RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
        constexpr uint32_t CMDRENDC = (1U << 6);  ///< CMDREND flag clear bit Set by software to clear the CMDREND flag.
        constexpr uint32_t CMDSENTC = (1U << 7);  ///< CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
        constexpr uint32_t DATAENDC = (1U << 8);  ///< DATAEND flag clear bit Set by software to clear the DATAEND flag.
        constexpr uint32_t DHOLDC = (1U << 9);  ///< DHOLD flag clear bit Set by software to clear the DHOLD flag.
        constexpr uint32_t DBCKENDC = (1U << 10);  ///< DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
        constexpr uint32_t DABORTC = (1U << 11);  ///< DABORT flag clear bit Set by software to clear the DABORT flag.
        constexpr uint32_t BUSYD0ENDC = (1U << 21);  ///< BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
        constexpr uint32_t SDIOITC = (1U << 22);  ///< SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
        constexpr uint32_t ACKFAILC = (1U << 23);  ///< ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
        constexpr uint32_t ACKTIMEOUTC = (1U << 24);  ///< ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
        constexpr uint32_t VSWENDC = (1U << 25);  ///< VSWEND flag clear bit Set by software to clear the VSWEND flag.
        constexpr uint32_t CKSTOPC = (1U << 26);  ///< CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
        constexpr uint32_t IDMATEC = (1U << 27);  ///< IDMA transfer error clear bit Set by software to clear the IDMATE flag.
        constexpr uint32_t IDMABTCC = (1U << 28);  ///< IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    }

    /// SDMMC_MASKR Register bits
    namespace sdmmc_maskr_bits {
        constexpr uint32_t CCRCFAILIE = (1U << 0);  ///< Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
        constexpr uint32_t DCRCFAILIE = (1U << 1);  ///< Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
        constexpr uint32_t CTIMEOUTIE = (1U << 2);  ///< Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
        constexpr uint32_t DTIMEOUTIE = (1U << 3);  ///< Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
        constexpr uint32_t TXUNDERRIE = (1U << 4);  ///< Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
        constexpr uint32_t RXOVERRIE = (1U << 5);  ///< Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
        constexpr uint32_t CMDRENDIE = (1U << 6);  ///< Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
        constexpr uint32_t CMDSENTIE = (1U << 7);  ///< Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
        constexpr uint32_t DATAENDIE = (1U << 8);  ///< Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
        constexpr uint32_t DHOLDIE = (1U << 9);  ///< Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
        constexpr uint32_t DBCKENDIE = (1U << 10);  ///< Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
        constexpr uint32_t DABORTIE = (1U << 11);  ///< Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
        constexpr uint32_t TXFIFOHEIE = (1U << 14);  ///< Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
        constexpr uint32_t RXFIFOHFIE = (1U << 15);  ///< Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
        constexpr uint32_t RXFIFOFIE = (1U << 17);  ///< Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
        constexpr uint32_t TXFIFOEIE = (1U << 18);  ///< Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
        constexpr uint32_t BUSYD0ENDIE = (1U << 21);  ///< BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
        constexpr uint32_t SDIOITIE = (1U << 22);  ///< SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
        constexpr uint32_t ACKFAILIE = (1U << 23);  ///< Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
        constexpr uint32_t ACKTIMEOUTIE = (1U << 24);  ///< Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
        constexpr uint32_t VSWENDIE = (1U << 25);  ///< Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
        constexpr uint32_t CKSTOPIE = (1U << 26);  ///< Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
        constexpr uint32_t IDMABTCIE = (1U << 28);  ///< IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    }

    /// SDMMC_ACKTIMER Register bits
    namespace sdmmc_acktimer_bits {
        constexpr uint32_t ACKTIME = (25 << 0);  ///< Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
    }

    /// SDMMC_IDMACTRLR Register bits
    namespace sdmmc_idmactrlr_bits {
        constexpr uint32_t IDMAEN = (1U << 0);  ///< IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABMODE = (1U << 1);  ///< Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABACT = (1U << 2);  ///< Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    }

    /// SDMMC_IDMABSIZER Register bits
    namespace sdmmc_idmabsizer_bits {
        constexpr uint32_t IDMABNDT = (8 << 5);  ///< Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    }

    /// SDMMC_IDMABASE0R Register bits
    namespace sdmmc_idmabase0r_bits {
        constexpr uint32_t IDMABASE0 = (32 << 0);  ///< Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
    }

    /// SDMMC_IDMABASE1R Register bits
    namespace sdmmc_idmabase1r_bits {
        constexpr uint32_t IDMABASE1 = (32 << 0);  ///< Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
    }

    /// SDMMC_FIFOR Register bits
    namespace sdmmc_fifor_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
    }

    /// SDMMC_VER Register bits
    namespace sdmmc_ver_bits {
        constexpr uint32_t MINREV = (4 << 0);  ///< IP minor revision number.
        constexpr uint32_t MAJREV = (4 << 4);  ///< IP major revision number.
    }

    /// SDMMC_ID Register bits
    namespace sdmmc_id_bits {
        constexpr uint32_t IP_ID = (32 << 0);  ///< SDMMC IP identification.
    }

    /// SDMMC_RESPCMDR Register bits
    namespace sdmmc_respcmdr_bits {
        constexpr uint32_t RESPCMD = (6 << 0);  ///< Response command index
    }

}


} // namespace alloy::generated::stm32l562

#endif // ALLOY_GENERATED_STM32L562_PERIPHERALS_HPP