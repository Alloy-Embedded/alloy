/// Auto-generated code for STM32U031
/// Generated by Alloy Code Generator
/// Source: st_stm32u031.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:00
#ifndef ALLOY_GENERATED_STM32U031_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32U031_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32u031 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_dbgmcu = true;
    constexpr uint32_t num_dbgmcu_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 3;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 6;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 9;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_tsc = true;
    constexpr uint32_t num_tsc_instances = 1;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbgmcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 6;
    constexpr uint32_t max_gpio_pins = 96;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_usart4 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x40012400;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register 1
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR;  ///< Offset: 0x14 - ADC sampling time register
        volatile uint32_t ADC_AWD1TR;  ///< Offset: 0x20 - ADC watchdog threshold register
        volatile uint32_t ADC_AWD2TR;  ///< Offset: 0x24 - ADC watchdog threshold register
        volatile uint32_t ADC_CHSELR;  ///< Offset: 0x28 - ADC channel selection register
        volatile uint32_t ADC_CHSELR_ALTERNATE;  ///< Offset: 0x28 - ADC channel selection register
        volatile uint32_t ADC_AWD3TR;  ///< Offset: 0x2C - ADC watchdog threshold register
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC Analog Watchdog 3 Configuration register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xB4 - ADC calibration factor
        volatile uint32_t ADC_CCR;  ///< Offset: 0x308 - ADC common configuration register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready This bit is set by hardware after the ADC has been enabled (ADEN+1) and when the ADC reaches a state where it is ready to accept conversion requests. It is cleared by software writing 1 to it.
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to 1.
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
        constexpr uint32_t EOS = (1U << 3);  ///< End of sequence flag This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
        constexpr uint32_t AWD1 = (1U << 7);  ///< Analog watchdog 1 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
        constexpr uint32_t AWD2 = (1U << 8);  ///< Analog watchdog 2 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
        constexpr uint32_t AWD3 = (1U << 9);  ///< Analog watchdog 3 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
        constexpr uint32_t EOCAL = (1U << 11);  ///< End Of Calibration flag This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
        constexpr uint32_t CCRDY = (1U << 13);  ///< Channel Configuration Ready flag This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it. Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable This bit is set and cleared by software to enable/disable the ADC Ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of conversion interrupt enable This bit is set and cleared by software to enable/disable the end of conversion interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of conversion sequence interrupt enable This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable This bit is set and cleared by software to enable/disable the overrun interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD1IE = (1U << 7);  ///< Analog watchdog 1 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD2IE = (1U << 8);  ///< Analog watchdog 2 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t AWD3IE = (1U << 9);  ///< Analog watchdog 3 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t EOCALIE = (1U << 11);  ///< End of calibration interrupt enable This bit is set and cleared by software to enable/disable the end of calibration interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
        constexpr uint32_t CCRDYIE = (1U << 13);  ///< Channel Configuration Ready Interrupt enable This bit is set and cleared by software to enable/disable the channel configuration ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable command This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set. It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start conversion command
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop conversion command
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC Voltage Regulator Enable
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration This bit is set by software to start the calibration of the ADC.
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< Direct memory access enable This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to Section113.6.5: Managing converted data using the DMA on page1333.
        constexpr uint32_t DMACFG = (1U << 1);  ///< Direct memory access configuration This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN1=11. For more details, refer to Section113.6.5: Managing converted data using the DMA on page1333.
        constexpr uint32_t SCANDIR = (1U << 2);  ///< Scan sequence direction This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared. Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t RES = (2 << 3);  ///< Data resolution These bits are written by software to select the resolution of the conversion.
        constexpr uint32_t ALIGN = (1U << 5);  ///< Data alignment This bit is set and cleared by software to select right or left alignment. Refer to Figure141: Data alignment and resolution (oversampling disabled: OVSE = 0) on page1332
        constexpr uint32_t EXTSEL = (3 << 6);  ///< External trigger selection These bits select the external event used to trigger the start of conversion (refer to Table160: External triggers for details):
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection These bits are set and cleared by software to select the external trigger polarity and enable the trigger.
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun management mode This bit is set and cleared by software and configure the way data overruns are managed.
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN1=11 and CONT1=11.
        constexpr uint32_t WAIT = (1U << 14);  ///< Wait conversion mode This bit is set and cleared by software to enable/disable wait conversion mode.<sup>.</sup>
        constexpr uint32_t AUTOFF = (1U << 15);  ///< Auto-off mode This bit is set and cleared by software to enable/disable auto-off mode.<sup>.</sup>
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode This bit is set and cleared by software to enable/disable discontinuous mode. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN1=11 and CONT1=11.
        constexpr uint32_t CHSELRMOD = (1U << 21);  ///< Mode selection of the ADC_CHSELR register This bit is set and cleared by software to control the ADC_CHSELR feature: Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< Enable the watchdog on a single channel or on all channels This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels
        constexpr uint32_t AWD1EN = (1U << 23);  ///< Analog watchdog enable This bit is set and cleared by software.
        constexpr uint32_t AWD1CH = (5 << 26);  ///< Analog watchdog channel selection These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. ..... Others: Reserved Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t OVSE = (1U << 0);  ///< Oversampler Enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADEN bit is cleared.
        constexpr uint32_t OVSR = (3 << 2);  ///< Oversampling ratio This bit filed defines the number of oversampling ratio. Note: The software is allowed to write this bit only when ADEN bit is cleared.
        constexpr uint32_t OVSS = (4 << 5);  ///< Oversampling shift This bit is set and cleared by software. Others: Reserved Note: The software is allowed to write this bit only when ADEN bit is cleared.
        constexpr uint32_t TOVS = (1U << 9);  ///< Triggered Oversampling This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADEN bit is cleared.
        constexpr uint32_t LFTRIG = (1U << 29);  ///< Low frequency trigger mode enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADEN bit is cleared.
        constexpr uint32_t CKMODE = (2 << 30);  ///< ADC clock mode These bits are set and cleared by software to define how the analog ADC is clocked: In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL1=10, ADSTART1=10, ADSTP1=10, ADDIS1=10 and ADEN1=10).
    }

    /// ADC_SMPR Register bits
    namespace adc_smpr_bits {
        constexpr uint32_t SMP1 = (3 << 0);  ///< Sampling time selection 1 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP2 = (3 << 4);  ///< Sampling time selection 2 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL0 = (1U << 8);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL1 = (1U << 9);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL2 = (1U << 10);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL3 = (1U << 11);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL4 = (1U << 12);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL5 = (1U << 13);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL6 = (1U << 14);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL7 = (1U << 15);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL8 = (1U << 16);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL9 = (1U << 17);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL10 = (1U << 18);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL11 = (1U << 19);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL12 = (1U << 20);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL13 = (1U << 21);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL14 = (1U << 22);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL15 = (1U << 23);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL16 = (1U << 24);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL17 = (1U << 25);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL18 = (1U << 26);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPSEL19 = (1U << 27);  ///< Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD1TR Register bits
    namespace adc_awd1tr_bits {
        constexpr uint32_t LT1 = (12 << 0);  ///< Analog watchdog 1 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
        constexpr uint32_t HT1 = (12 << 16);  ///< Analog watchdog 1 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
    }

    /// ADC_AWD2TR Register bits
    namespace adc_awd2tr_bits {
        constexpr uint32_t LT2 = (12 << 0);  ///< Analog watchdog 2 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
        constexpr uint32_t HT2 = (12 << 16);  ///< Analog watchdog 2 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
    }

    /// ADC_CHSELR Register bits
    namespace adc_chselr_bits {
        constexpr uint32_t CHSEL0 = (1U << 0);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL1 = (1U << 1);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL2 = (1U << 2);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL3 = (1U << 3);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL4 = (1U << 4);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL5 = (1U << 5);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL6 = (1U << 6);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL7 = (1U << 7);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL8 = (1U << 8);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL9 = (1U << 9);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL10 = (1U << 10);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL11 = (1U << 11);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL12 = (1U << 12);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL13 = (1U << 13);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL14 = (1U << 14);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL15 = (1U << 15);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL16 = (1U << 16);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL17 = (1U << 17);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL18 = (1U << 18);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        constexpr uint32_t CHSEL19 = (1U << 19);  ///< Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    }

    /// ADC_CHSELR_ALTERNATE Register bits
    namespace adc_chselr_alternate_bits {
        constexpr uint32_t SQ1 = (4 << 0);  ///< 1st conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ2 = (4 << 4);  ///< 2nd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ3 = (4 << 8);  ///< 3rd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ4 = (4 << 12);  ///< 4th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ5 = (4 << 16);  ///< 5th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ6 = (4 << 20);  ///< 6th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ7 = (4 << 24);  ///< 7th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t SQ8 = (4 << 28);  ///< 8th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. ... Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3TR Register bits
    namespace adc_awd3tr_bits {
        constexpr uint32_t LT3 = (12 << 0);  ///< Analog watchdog 3lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
        constexpr uint32_t HT3 = (12 << 16);  ///< Analog watchdog 3 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t DATA = (16 << 0);  ///< Converted data These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in Figure141: Data alignment and resolution (oversampling disabled: OVSE = 0) on page1332. Just after a calibration is complete, DATA[6:0] contains the calibration factor.
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH0 = (1U << 0);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH1 = (1U << 1);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH2 = (1U << 2);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH3 = (1U << 3);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH4 = (1U << 4);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH5 = (1U << 5);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH6 = (1U << 6);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH7 = (1U << 7);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH8 = (1U << 8);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH9 = (1U << 9);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH10 = (1U << 10);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH11 = (1U << 11);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH12 = (1U << 12);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH13 = (1U << 13);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH14 = (1U << 14);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH15 = (1U << 15);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH16 = (1U << 16);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH17 = (1U << 17);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH18 = (1U << 18);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2CH19 = (1U << 19);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH0 = (1U << 0);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH1 = (1U << 1);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH2 = (1U << 2);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH3 = (1U << 3);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH4 = (1U << 4);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH5 = (1U << 5);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH6 = (1U << 6);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH7 = (1U << 7);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH8 = (1U << 8);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH9 = (1U << 9);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH10 = (1U << 10);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH11 = (1U << 11);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH12 = (1U << 12);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH13 = (1U << 13);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH14 = (1U << 14);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH15 = (1U << 15);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH16 = (1U << 16);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH17 = (1U << 17);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH18 = (1U << 18);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3CH19 = (1U << 19);  ///< Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t CALFACT = (7 << 0);  ///< Calibration factor These bits are written by hardware or by software. Once a calibration is complete,1they are updated by hardware with the calibration factors. Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new conversion is launched. Just after a calibration is complete, DATA[6:0] contains the calibration factor. Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing).
    }

    /// ADC_CCR Register bits
    namespace adc_ccr_bits {
        constexpr uint32_t PRESC = (4 << 18);  ///< ADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL1=10, ADSTART1=10, ADSTP1=10, ADDIS1=10 and ADEN1=10).
        constexpr uint32_t VREFEN = (1U << 22);  ///< V<sub>REFINT</sub> enable This bit is set and cleared by software to enable/disable the V<sub>REFINT</sub>. Note: Software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t TSEN = (1U << 23);  ///< Temperature sensor enable This bit is set and cleared by software to enable/disable the temperature sensor. Note: Software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
        constexpr uint32_t VBATEN = (1U << 24);  ///< V<sub>BAT</sub> enable This bit is set and cleared by software to enable/disable the V<sub>BAT</sub> channel. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP1_BASE = 0x40010200;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP1_CSR;  ///< Offset: 0x00 - Comparator 1 control and status register
        volatile uint32_t COMP2_CSR;  ///< Offset: 0x04 - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* COMP1 = reinterpret_cast<Registers*>(COMP1_BASE);

    // Bit definitions
    /// COMP1_CSR Register bits
    namespace comp1_csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator 1 enable bit This bit is controlled by software (if not locked). It enables the comparator 1:
        constexpr uint32_t INMSEL = (4 << 4);  ///< Comparator 1 signal selector for inverting input INM This bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP_INM of the comparator 1: Refer to Table176: COMP1 inverting input assignment.
        constexpr uint32_t INPSEL = (3 << 8);  ///< Comparator 1 signal selector for noninverting input This bitfield is controlled by software (if not locked). It selects the signal for the noninverting input COMP_INP of the comparator 1 (also see the WINMODE bit): Refer to Table175: COMP1 noninverting input assignment.
        constexpr uint32_t WINMODE = (1U << 11);  ///< Comparator 1 noninverting input selector for window mode This bit is controlled by software (if not locked). It selects the signal for COMP_INP input of the comparator 1:
        constexpr uint32_t WINOUT = (1U << 14);  ///< Comparator 1 output selector This bit is controlled by software (if not locked). It selects the comparator 1 output:
        constexpr uint32_t POLARITY = (1U << 15);  ///< Comparator 1 polarity selector This bit is controlled by software (if not locked). It selects the comparator 1 output polarity:
        constexpr uint32_t HYST = (2 << 16);  ///< Comparator 1 hysteresis selector This bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 1:
        constexpr uint32_t PWRMODE = (2 << 18);  ///< Comparator 1 power mode selector This bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 1:
        constexpr uint32_t BLANKSEL = (5 << 20);  ///< Comparator 1 blanking source selector This bitfield is controlled by software (if not locked). It selects the blanking source: Others: Reserved, must not be used
        constexpr uint32_t VALUE = (1U << 30);  ///< Comparator 1 output status This bit is read-only. It reflects the level of the comparator 1 output after the polarity selector and blanking, as indicated in Figure163.
        constexpr uint32_t LOCK = (1U << 31);  ///< COMP_CSR register lock This bit is set by software and cleared by a system reset. It locks the comparator 3 control bits. When locked, all register bits are read-only.
    }

    /// COMP2_CSR Register bits
    namespace comp2_csr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator 2 enable bit This bit is controlled by software (if not locked). It enables the comparator 2:
        constexpr uint32_t INMSEL = (4 << 4);  ///< Comparator 2 signal selector for inverting input INM This bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP_INM of the comparator 2: Refer to Table178: COMP2 inverting input assignment.
        constexpr uint32_t INPSEL = (2 << 8);  ///< Comparator 2 signal selector for noninverting input This bitfield is controlled by software (if not locked). It selects the signal for the noninverting input COMP_INP of the comparator 2 (also see the WINMODE bit): Refer to Table177: COMP2 noninverting input assignment.
        constexpr uint32_t WINMODE = (1U << 11);  ///< Comparator 2 noninverting input selector for window mode This bit is controlled by software (if not locked). It selects the signal for COMP_INP input of the comparator 2:
        constexpr uint32_t WINOUT = (1U << 14);  ///< Comparator 2 output selector This bit is controlled by software (if not locked). It selects the comparator 2 output:
        constexpr uint32_t POLARITY = (1U << 15);  ///< Comparator 2 polarity selector This bit is controlled by software (if not locked). It selects the comparator 2 output polarity:
        constexpr uint32_t HYST = (2 << 16);  ///< Comparator 2 hysteresis selector This bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 2:
        constexpr uint32_t PWRMODE = (2 << 18);  ///< Comparator 2 power mode selector This bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 2:
        constexpr uint32_t BLANKSEL = (5 << 20);  ///< Comparator 2 blanking source selector This bitfield is controlled by software (if not locked). It selects the blanking source: Others: Reserved, must not be used
        constexpr uint32_t VALUE = (1U << 30);  ///< Comparator 2 output status This bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in Figure163.
        constexpr uint32_t LOCK = (1U << 31);  ///< COMP_CSR register lock This bit is set by software and cleared by a system reset. It locks the comparator 3 control bits. When locked, all register bits are read-only.
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRC_DR;  ///< Offset: 0x00 - CRC data register
        volatile uint32_t CRC_IDR;  ///< Offset: 0x04 - CRC independent data register
        volatile uint32_t CRC_CR;  ///< Offset: 0x08 - CRC control register
        volatile uint32_t CRC_INIT;  ///< Offset: 0x10 - CRC initial value
        volatile uint32_t CRC_POL;  ///< Offset: 0x14 - CRC polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRC_DR Register bits
    namespace crc_dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits This register is used to write new data to the CRC calculator. It holds the previous CRC calculation result when it is read. If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
    }

    /// CRC_IDR Register bits
    namespace crc_idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 32-bit data register bits These bits can be used as a temporary storage location for four bytes. This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register
    }

    /// CRC_CR Register bits
    namespace crc_cr_bits {
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size These bits control the size of the polynomial.
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data This bitfield controls the reversal of the bit order of the input data
        constexpr uint32_t REV_OUT = (2 << 7);  ///< Reverse output data This bitfield controls the reversal of the bit order of the output data.
        constexpr uint32_t RTYPE_IN = (1U << 9);  ///< Reverse type input This bit controls the reversal granularity of the input data.
        constexpr uint32_t RTYPE_OUT = (1U << 10);  ///< Reverse type output This bit controls the reversal granularity of the output data.
    }

    /// CRC_INIT Register bits
    namespace crc_init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value This register is used to write the CRC initial value.
    }

    /// CRC_POL Register bits
    namespace crc_pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial This register is used to write the coefficients of the polynomial to be used for CRC calculation. If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC_BASE = 0x40007400;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC channel1 sample and hold sample time register
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC sample and hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC sample and hold refresh time register
    };

    /// Peripheral instances
    inline Registers* DAC = reinterpret_cast<Registers*>(DAC_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable This bit is set and cleared by software to enable/disable DAC channel1 trigger. Note: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle.
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1 ... Refer to the trigger selection tables in Section114.4.2: DAC pins and internal signals for details on trigger configuration and mapping. Note: Only used if bit TEN11=11 (DAC channel1 trigger enabled).
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. 1x: Triangle wave generation enabled Only used if bit TEN11=11 (DAC channel1 trigger enabled).
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable This bit is set and cleared by software.
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC channel1 calibration enable This bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN11=10 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data These bits are written by software. They specify 12-bit data for DAC channel1.
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data These bits are written by software. They specify 12-bit data for DAC channel1.
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data These bits are written by software. They specify 8-bit data for DAC channel1.
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC channel1 calibration offset status This bit is set and cleared by hardware
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC channel1 busy writing sample time flag This bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization).
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC channel1 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC channel1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN11=10 and bit CEN11=10 in the DAC_CR register). If EN11=11 or CEN11=11 the write operation is ignored. They can be set and cleared by software to select the DAC channel1 mode: DAC channel1 in Normal mode DAC channel1 in sample & hold mode Note: This register can be modified only when EN11=10.
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC channel1 sample time (only valid in Sample and hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST11=11, the write operation is ignored.
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC channel1 hold time (only valid in Sample and hold mode) Hold time1=1(THOLD[9:0]) x LSI clock period Note: This register can be modified only when EN11=10.
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC channel1 refresh time (only valid in Sample and hold mode) Refresh time1=1(TREFRESH[7:0]) x LSI clock period Note: This register can be modified only when EN11=10.
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0x40015800;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t DBGMCU_IDCODE;  ///< Offset: 0x00 - DBGMCU device ID code register
        volatile uint32_t DBGMCU_CR;  ///< Offset: 0x04 - DBGMCU configuration register
        volatile uint32_t DBGMCU_APB1FZR;  ///< Offset: 0x08 - DBGMCU APB1 freeze register
        volatile uint32_t DBGMCU_APB2FZR;  ///< Offset: 0x0C - DBG APB2 freeze register
        volatile uint32_t DBGMCU_SR;  ///< Offset: 0xFC - DBGMCU status register
        volatile uint32_t DBGMCU_DBG_AUTH_HOST;  ///< Offset: 0x100 - DBGMCU debug authentication mailbox host register
        volatile uint32_t DBGMCU_DBG_AUTH_DEVICE;  ///< Offset: 0x104 - DBGMCU debug authentication mailbox device register
        volatile uint32_t DBGMCU_PIDR4;  ///< Offset: 0xFD0 - DBGMCU CoreSight peripheral identity register 4
        volatile uint32_t DBGMCU_PIDR0;  ///< Offset: 0xFE0 - DBGMCU CoreSight peripheral identity register 0
        volatile uint32_t DBGMCU_PIDR1;  ///< Offset: 0xFE4 - DBGMCU CoreSight peripheral identity register 1
        volatile uint32_t DBGMCU_PIDR2;  ///< Offset: 0xFE8 - DBGMCU CoreSight peripheral identity register 2
        volatile uint32_t DBGMCU_PIDR3;  ///< Offset: 0xFEC - DBGMCU CoreSight peripheral identity register 3
        volatile uint32_t DBGMCU_CIDR0;  ///< Offset: 0xFF0 - DBGMCU CoreSight component identity register 0
        volatile uint32_t DBGMCU_CIDR1;  ///< Offset: 0xFF4 - DBGMCU CoreSight component identity register 1
        volatile uint32_t DBGMCU_CIDR2;  ///< Offset: 0xFF8 - DBGMCU CoreSight component identity register 2
        volatile uint32_t DBGMCU_CIDR3;  ///< Offset: 0xFFC - DBGMCU CoreSight component identity register 3
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// DBGMCU_IDCODE Register bits
    namespace dbgmcu_idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device identifier This field indicates the device ID.
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision identifier This field indicates the revision of the device.
    }

    /// DBGMCU_CR Register bits
    namespace dbgmcu_cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode Debug options in Stop mode.
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby and Shutdown modes Debug options in Standby or Shutdown mode.
    }

    /// DBGMCU_APB1FZR Register bits
    namespace dbgmcu_apb1fzr_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 stop in debug
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 stop in debug
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< TIM4 stop in debug
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< TIM6 stop in debug
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 stop in debug
        constexpr uint32_t DBG_RTC_STOP = (1U << 10);  ///< RTC stop in debug
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< WWDG stop in debug
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< IWDG stop in debug
        constexpr uint32_t DBG_I2C3_STOP = (1U << 21);  ///< I2C3 SMBUS timeout stop in debug
        constexpr uint32_t DBG_I2C1_STOP = (1U << 22);  ///< I2C1 SMBUS timeout stop in debug
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 30);  ///< LPTIM2 stop in debug
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 31);  ///< LPTIM1 stop in debug
    }

    /// DBGMCU_APB2FZR Register bits
    namespace dbgmcu_apb2fzr_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 stop in debug
        constexpr uint32_t DBG_TIM14_STOP = (1U << 15);  ///< TIM14 stop in debug
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< TIM15 stop in debug
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< TIM16 stop in debug
    }

    /// DBGMCU_SR Register bits
    namespace dbgmcu_sr_bits {
        constexpr uint32_t AP1_PRESENT = (1U << 0);  ///< Identifies whether access port AP1 is present in device
        constexpr uint32_t AP0_PRESENT = (1U << 1);  ///< Identifies whether access port AP0 is present in device
        constexpr uint32_t AP1_ENABLED = (1U << 16);  ///< Identifies whether access port AP0 is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)
        constexpr uint32_t AP0_ENABLED = (1U << 17);  ///< Identifies whether access port AP0 is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)
    }

    /// DBGMCU_DBG_AUTH_HOST Register bits
    namespace dbgmcu_dbg_auth_host_bits {
        constexpr uint32_t MESSAGE = (32 << 0);  ///< Debug host to device mailbox message. During debug authentication the debug host communicates with the device via this register.
    }

    /// DBGMCU_DBG_AUTH_DEVICE Register bits
    namespace dbgmcu_dbg_auth_device_bits {
        constexpr uint32_t MESSAGE = (32 << 0);  ///< Device to debug host mailbox message. During debug authentication the device communicates with the debug host via this register.
    }

    /// DBGMCU_PIDR4 Register bits
    namespace dbgmcu_pidr4_bits {
        constexpr uint32_t JEP106CON = (4 << 0);  ///< JEP106 continuation code
        constexpr uint32_t SIZE = (4 << 4);  ///< register file size
    }

    /// DBGMCU_PIDR0 Register bits
    namespace dbgmcu_pidr0_bits {
        constexpr uint32_t PARTNUM = (8 << 0);  ///< part number bits [7:0]
    }

    /// DBGMCU_PIDR1 Register bits
    namespace dbgmcu_pidr1_bits {
        constexpr uint32_t PARTNUM = (4 << 0);  ///< part number bits [11:8]
        constexpr uint32_t JEP106ID = (4 << 4);  ///< JEP106 identity code bits [3:0]
    }

    /// DBGMCU_PIDR2 Register bits
    namespace dbgmcu_pidr2_bits {
        constexpr uint32_t JEP106ID = (3 << 0);  ///< JEP106 identity code bits [6:4]
        constexpr uint32_t JEDEC = (1U << 3);  ///< JEDEC assigned value
        constexpr uint32_t REVISION = (4 << 4);  ///< component revision number
    }

    /// DBGMCU_PIDR3 Register bits
    namespace dbgmcu_pidr3_bits {
        constexpr uint32_t CMOD = (4 << 0);  ///< customer modified
        constexpr uint32_t REVAND = (4 << 4);  ///< metal fix version
    }

    /// DBGMCU_CIDR0 Register bits
    namespace dbgmcu_cidr0_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [7:0]
    }

    /// DBGMCU_CIDR1 Register bits
    namespace dbgmcu_cidr1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< component identification bits [11:8]
        constexpr uint32_t CLASS_ = (4 << 4);  ///< component identification bits [15:12] - component class (renamed from CLASS_)
    }

    /// DBGMCU_CIDR2 Register bits
    namespace dbgmcu_cidr2_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [23:16]
    }

    /// DBGMCU_CIDR3 Register bits
    namespace dbgmcu_cidr3_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [31:24]
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAMUX_BASE = 0x40020800;
    constexpr uint32_t DMA1_BASE = 0x40020000;
    constexpr uint32_t DMA2_BASE = 0x40020400;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMAMUX_C0CR;  ///< Offset: 0x00 - DMAMUX request line multiplexer channel 0 configuration register
        volatile uint32_t DMAMUX_C1CR;  ///< Offset: 0x04 - DMAMUX request line multiplexer channel 1 configuration register
        volatile uint32_t DMAMUX_C2CR;  ///< Offset: 0x08 - DMAMUX request line multiplexer channel 2 configuration register
        volatile uint32_t DMAMUX_C3CR;  ///< Offset: 0x0C - DMAMUX request line multiplexer channel 3 configuration register
        volatile uint32_t DMAMUX_C4CR;  ///< Offset: 0x10 - DMAMUX request line multiplexer channel 4 configuration register
        volatile uint32_t DMAMUX_C5CR;  ///< Offset: 0x14 - DMAMUX request line multiplexer channel 5 configuration register
        volatile uint32_t DMAMUX_C6CR;  ///< Offset: 0x18 - DMAMUX request line multiplexer channel 6 configuration register
        volatile uint32_t DMAMUX_C7CR;  ///< Offset: 0x1C - DMAMUX request line multiplexer channel 7 configuration register
        volatile uint32_t DMAMUX_C8CR;  ///< Offset: 0x20 - DMAMUX request line multiplexer channel 8 configuration register
        volatile uint32_t DMAMUX_C9CR;  ///< Offset: 0x24 - DMAMUX request line multiplexer channel 9 configuration register
        volatile uint32_t DMAMUX_C10CR;  ///< Offset: 0x28 - DMAMUX request line multiplexer channel 10 configuration register
        volatile uint32_t DMAMUX_C11CR;  ///< Offset: 0x2C - DMAMUX request line multiplexer channel 11 configuration register
        volatile uint32_t DMAMUX_CSR;  ///< Offset: 0x80 - DMAMUX request line multiplexer interrupt channel status register
        volatile uint32_t DMAMUX_CFR;  ///< Offset: 0x84 - DMAMUX request line multiplexer interrupt clear flag register
        volatile uint32_t DMAMUX_RG0CR;  ///< Offset: 0x100 - DMAMUX request generator channel 0 configuration register
        volatile uint32_t DMAMUX_RG1CR;  ///< Offset: 0x104 - DMAMUX request generator channel 1 configuration register
        volatile uint32_t DMAMUX_RG2CR;  ///< Offset: 0x108 - DMAMUX request generator channel 2 configuration register
        volatile uint32_t DMAMUX_RG3CR;  ///< Offset: 0x10C - DMAMUX request generator channel 3 configuration register
        volatile uint32_t DMAMUX_RGSR;  ///< Offset: 0x140 - DMAMUX request generator interrupt status register
        volatile uint32_t DMAMUX_RGCFR;  ///< Offset: 0x144 - DMAMUX request generator interrupt clear flag register
    };

    /// Peripheral instances
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);
    inline Registers* DMA2 = reinterpret_cast<Registers*>(DMA2_BASE);

    // Bit definitions
    /// DMAMUX_C0CR Register bits
    namespace dmamux_c0cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C1CR Register bits
    namespace dmamux_c1cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C2CR Register bits
    namespace dmamux_c2cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C3CR Register bits
    namespace dmamux_c3cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C4CR Register bits
    namespace dmamux_c4cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C5CR Register bits
    namespace dmamux_c5cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C6CR Register bits
    namespace dmamux_c6cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C7CR Register bits
    namespace dmamux_c7cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C8CR Register bits
    namespace dmamux_c8cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C9CR Register bits
    namespace dmamux_c9cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C10CR Register bits
    namespace dmamux_c10cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_C11CR Register bits
    namespace dmamux_c11cr_bits {
        constexpr uint32_t DMAREQ_ID = (7 << 0);  ///< DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
        constexpr uint32_t SOIE = (1U << 8);  ///< Synchronization overrun interrupt enable
        constexpr uint32_t EGE = (1U << 9);  ///< Event generation enable
        constexpr uint32_t SE = (1U << 16);  ///< Synchronization enable
        constexpr uint32_t SPOL = (2 << 17);  ///< Synchronization polarity Defines the edge polarity of the selected synchronization input:
        constexpr uint32_t NBREQ = (5 << 19);  ///< Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
        constexpr uint32_t SYNC_ID = (5 << 24);  ///< Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
    }

    /// DMAMUX_CSR Register bits
    namespace dmamux_csr_bits {
        constexpr uint32_t SOF0 = (1U << 0);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF1 = (1U << 1);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF2 = (1U << 2);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF3 = (1U << 3);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF4 = (1U << 4);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF5 = (1U << 5);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF6 = (1U << 6);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF7 = (1U << 7);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF8 = (1U << 8);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF9 = (1U << 9);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF10 = (1U << 10);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
        constexpr uint32_t SOF11 = (1U << 11);  ///< Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
    }

    /// DMAMUX_CFR Register bits
    namespace dmamux_cfr_bits {
        constexpr uint32_t CSOF0 = (1U << 0);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF1 = (1U << 1);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF2 = (1U << 2);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF3 = (1U << 3);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF4 = (1U << 4);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF5 = (1U << 5);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF6 = (1U << 6);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF7 = (1U << 7);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF8 = (1U << 8);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF9 = (1U << 9);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF10 = (1U << 10);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
        constexpr uint32_t CSOF11 = (1U << 11);  ///< Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
    }

    /// DMAMUX_RG0CR Register bits
    namespace dmamux_rg0cr_bits {
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
        constexpr uint32_t OIE = (1U << 8);  ///< Trigger overrun interrupt enable
        constexpr uint32_t GE = (1U << 16);  ///< DMA request generator channel x enable
        constexpr uint32_t GPOL = (2 << 17);  ///< DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
    }

    /// DMAMUX_RG1CR Register bits
    namespace dmamux_rg1cr_bits {
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
        constexpr uint32_t OIE = (1U << 8);  ///< Trigger overrun interrupt enable
        constexpr uint32_t GE = (1U << 16);  ///< DMA request generator channel x enable
        constexpr uint32_t GPOL = (2 << 17);  ///< DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
    }

    /// DMAMUX_RG2CR Register bits
    namespace dmamux_rg2cr_bits {
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
        constexpr uint32_t OIE = (1U << 8);  ///< Trigger overrun interrupt enable
        constexpr uint32_t GE = (1U << 16);  ///< DMA request generator channel x enable
        constexpr uint32_t GPOL = (2 << 17);  ///< DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
    }

    /// DMAMUX_RG3CR Register bits
    namespace dmamux_rg3cr_bits {
        constexpr uint32_t SIG_ID = (5 << 0);  ///< Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
        constexpr uint32_t OIE = (1U << 8);  ///< Trigger overrun interrupt enable
        constexpr uint32_t GE = (1U << 16);  ///< DMA request generator channel x enable
        constexpr uint32_t GPOL = (2 << 17);  ///< DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
        constexpr uint32_t GNBREQ = (5 << 19);  ///< Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
    }

    /// DMAMUX_RGSR Register bits
    namespace dmamux_rgsr_bits {
        constexpr uint32_t OF0 = (1U << 0);  ///< Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
        constexpr uint32_t OF1 = (1U << 1);  ///< Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
        constexpr uint32_t OF2 = (1U << 2);  ///< Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
        constexpr uint32_t OF3 = (1U << 3);  ///< Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
    }

    /// DMAMUX_RGCFR Register bits
    namespace dmamux_rgcfr_bits {
        constexpr uint32_t COF0 = (1U << 0);  ///< Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
        constexpr uint32_t COF1 = (1U << 1);  ///< Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
        constexpr uint32_t COF2 = (1U << 2);  ///< Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
        constexpr uint32_t COF3 = (1U << 3);  ///< Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x40021800;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t EXTI_FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register 1
        volatile uint32_t EXTI_SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register 1
        volatile uint32_t EXTI_RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register 1
        volatile uint32_t EXTI_FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register 1
        volatile uint32_t EXTI_EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register 1
        volatile uint32_t EXTI_EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register 2
        volatile uint32_t EXTI_EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register 3
        volatile uint32_t EXTI_EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register 4
        volatile uint32_t EXTI_IMR1;  ///< Offset: 0x80 - EXTI CPU wake-up with interrupt mask register
        volatile uint32_t EXTI_EMR1;  ///< Offset: 0x84 - EXTI CPU wake-up with event mask register
        volatile uint32_t EXTI_IMR2;  ///< Offset: 0x90 - EXTI CPU wake-up with interrupt mask register
        volatile uint32_t EXTI_EMR2;  ///< Offset: 0x94 - EXTI CPU wake-up with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// EXTI_RTSR1 Register bits
    namespace exti_rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT17 = (1U << 17);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT18 = (1U << 18);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT19 = (1U << 19);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT20 = (1U << 20);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
    }

    /// EXTI_FTSR1 Register bits
    namespace exti_ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT17 = (1U << 17);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT18 = (1U << 18);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT19 = (1U << 19);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT20 = (1U << 20);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
    }

    /// EXTI_SWIER1 Register bits
    namespace exti_swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI17 = (1U << 17);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI18 = (1U << 18);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI19 = (1U << 19);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI20 = (1U << 20);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
    }

    /// EXTI_RPR1 Register bits
    namespace exti_rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF1 = (1U << 1);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF2 = (1U << 2);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF3 = (1U << 3);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF4 = (1U << 4);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF5 = (1U << 5);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF6 = (1U << 6);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF7 = (1U << 7);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF8 = (1U << 8);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF9 = (1U << 9);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF10 = (1U << 10);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF11 = (1U << 11);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF12 = (1U << 12);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF13 = (1U << 13);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF14 = (1U << 14);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF15 = (1U << 15);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF16 = (1U << 16);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF17 = (1U << 17);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF18 = (1U << 18);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF19 = (1U << 19);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF20 = (1U << 20);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t RPIF21 = (1U << 21);  ///< Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
    }

    /// EXTI_FPR1 Register bits
    namespace exti_fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF17 = (1U << 17);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF18 = (1U << 18);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF19 = (1U << 19);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF20 = (1U << 20);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
        constexpr uint32_t FPIF21 = (1U << 21);  ///< Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
    }

    /// EXTI_EXTICR1 Register bits
    namespace exti_exticr1_bits {
        constexpr uint32_t EXTI0 = (8 << 0);  ///< EXTI0 GPIO port selection These bits are written by software to select the source input for EXTI0 external interrupt. Others reserved
        constexpr uint32_t EXTI1 = (8 << 8);  ///< EXTI1 GPIO port selection These bits are written by software to select the source input for EXTI1 external interrupt. Others reserved
        constexpr uint32_t EXTI2 = (8 << 16);  ///< EXTI2 GPIO port selection These bits are written by software to select the source input for EXTI2 external interrupt. Others reserved
        constexpr uint32_t EXTI3 = (8 << 24);  ///< EXTI3 GPIO port selection These bits are written by software to select the source input for EXTI3 external interrupt. Others reserved
    }

    /// EXTI_EXTICR2 Register bits
    namespace exti_exticr2_bits {
        constexpr uint32_t EXTI4 = (8 << 0);  ///< EXTI4 GPIO port selection These bits are written by software to select the source input for EXTI4 external interrupt. Others reserved
        constexpr uint32_t EXTI5 = (8 << 8);  ///< EXTI5 GPIO port selection These bits are written by software to select the source input for EXTI5 external interrupt. Others reserved
        constexpr uint32_t EXTI6 = (8 << 16);  ///< EXTI6 GPIO port selection These bits are written by software to select the source input for EXTI6 external interrupt. Others reserved
        constexpr uint32_t EXTI7 = (8 << 24);  ///< EXTI7 GPIO port selection These bits are written by software to select the source input for EXTI7 external interrupt. Others reserved
    }

    /// EXTI_EXTICR3 Register bits
    namespace exti_exticr3_bits {
        constexpr uint32_t EXTI8 = (8 << 0);  ///< EXTI8 GPIO port selection These bits are written by software to select the source input for EXTI8 external interrupt. Others reserved
        constexpr uint32_t EXTI9 = (8 << 8);  ///< EXTI9 GPIO port selection These bits are written by software to select the source input for EXTI9 external interrupt. Others reserved
        constexpr uint32_t EXTI10 = (8 << 16);  ///< EXTI10 GPIO port selection These bits are written by software to select the source input for EXTI10 external interrupt. Others reserved
        constexpr uint32_t EXTI11 = (8 << 24);  ///< EXTI11 GPIO port selection These bits are written by software to select the source input for EXTI11 external interrupt. Others reserved
    }

    /// EXTI_EXTICR4 Register bits
    namespace exti_exticr4_bits {
        constexpr uint32_t EXTI12 = (8 << 0);  ///< EXTI12 GPIO port selection These bits are written by software to select the source input for EXTI12 external interrupt. Others reserved
        constexpr uint32_t EXTI13 = (8 << 8);  ///< EXTI13 GPIO port selection These bits are written by software to select the source input for EXTI13 external interrupt. Others reserved
        constexpr uint32_t EXTI14 = (8 << 16);  ///< EXTI14 GPIO port selection These bits are written by software to select the source input for EXTI14 external interrupt. Others reserved
        constexpr uint32_t EXTI15 = (8 << 24);  ///< EXTI15 GPIO port selection These bits are written by software to select the source input for EXTI15 external interrupt. Others reserved
    }

    /// EXTI_IMR1 Register bits
    namespace exti_imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM17 = (1U << 17);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM18 = (1U << 18);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM26 = (1U << 26);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM27 = (1U << 27);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM28 = (1U << 28);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM29 = (1U << 29);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM30 = (1U << 30);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t IM31 = (1U << 31);  ///< CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
    }

    /// EXTI_EMR1 Register bits
    namespace exti_emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM17 = (1U << 17);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM18 = (1U << 18);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM20 = (1U << 20);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM22 = (1U << 22);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM24 = (1U << 24);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM26 = (1U << 26);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM27 = (1U << 27);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM28 = (1U << 28);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM29 = (1U << 29);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM30 = (1U << 30);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
        constexpr uint32_t EM31 = (1U << 31);  ///< CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
    }

    /// EXTI_IMR2 Register bits
    namespace exti_imr2_bits {
        constexpr uint32_t IM32 = (1U << 0);  ///< CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t IM33 = (1U << 1);  ///< CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t IM34 = (1U << 2);  ///< CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t IM35 = (1U << 3);  ///< CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t IM36 = (1U << 4);  ///< CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t IM37 = (1U << 5);  ///< CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
    }

    /// EXTI_EMR2 Register bits
    namespace exti_emr2_bits {
        constexpr uint32_t EM32 = (1U << 0);  ///< CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t EM33 = (1U << 1);  ///< CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t EM34 = (1U << 2);  ///< CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t EM35 = (1U << 3);  ///< CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t EM36 = (1U << 4);  ///< CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
        constexpr uint32_t EM37 = (1U << 5);  ///< CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASH_ACR;  ///< Offset: 0x00 - FLASH access control register
        volatile uint32_t FLASH_KEYR;  ///< Offset: 0x08 - FLASH key register
        volatile uint32_t FLASH_OPTKEYR;  ///< Offset: 0x0C - FLASH option key register
        volatile uint32_t FLASH_SR;  ///< Offset: 0x10 - FLASH status register
        volatile uint32_t FLASH_CR;  ///< Offset: 0x14 - FLASH control register
        volatile uint32_t FLASH_ECCR;  ///< Offset: 0x18 - FLASH ECC register
        volatile uint32_t FLASH_OPTR;  ///< Offset: 0x20 - FLASH option register
        volatile uint32_t FLASH_WRP1AR;  ///< Offset: 0x2C - FLASH WRP area A address register
        volatile uint32_t FLASH_WRP1BR;  ///< Offset: 0x30 - FLASH WRP area B address register
        volatile uint32_t FLASH_SECR;  ///< Offset: 0x80 - FLASH security register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// FLASH_ACR Register bits
    namespace flash_acr_bits {
        constexpr uint32_t LATENCY = (3 << 0);  ///< Flash memory access latency The value in this bitfield represents the number of CPU wait states when accessing the flash memory. Other: Reserved A new write into the bitfield becomes effective when it returns the same value upon read.
        constexpr uint32_t PRFTEN = (1U << 8);  ///< CPU Prefetch enable
        constexpr uint32_t ICEN = (1U << 9);  ///< CPU Instruction cache enable
        constexpr uint32_t ICRST = (1U << 11);  ///< CPU Instruction cache reset This bit can be written only when the instruction cache is disabled.
        constexpr uint32_t EMPTY = (1U << 16);  ///< Main flash memory area empty This bit indicates whether the first location of the main flash memory area is erased or has a programmed value. The bit can be set and reset by software.
        constexpr uint32_t DBG_SWEN = (1U << 18);  ///< Debug access software enable Software may use this bit to enable/disable the debugger read access.
    }

    /// FLASH_KEYR Register bits
    namespace flash_keyr_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< FLASH key The following values must be written consecutively to unlock the FLASH control register (FLASH_CR), thus enabling programming/erasing operations: KEY1: 0x4567 0123 KEY2: 0xCDEF 89AB
    }

    /// FLASH_OPTKEYR Register bits
    namespace flash_optkeyr_bits {
        constexpr uint32_t OPTKEY = (32 << 0);  ///< Option byte key The following values must be written consecutively to unlock the flash memory option registers, enabling option byte programming/erasing operations: KEY1: 0x0819 2A3B KEY2: 0x4C5D 6E7F
    }

    /// FLASH_SR Register bits
    namespace flash_sr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< End of operation Set by hardware when one or more flash memory operation (programming / erase) has been completed successfully. This bit is set only if the end of operation interrupts are enabled (EOPIE=1). Cleared by writing 1.
        constexpr uint32_t OPERR = (1U << 1);  ///< Operation error Set by hardware when a flash memory operation (program / erase) completes unsuccessfully. This bit is set only if error interrupts are enabled (ERRIE=1). Cleared by writing 1.
        constexpr uint32_t PROGERR = (1U << 3);  ///< Programming error Set by hardware when a double-word address to be programmed contains a value different from '0xFFFF FFFF' before programming, except if the data to write is '0x0000 0000'. Cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Write protection error Set by hardware when an address to be erased/programmed belongs to a write-protected part (by WRP, PCROP or RDP Level 1) of the flash memory. Cleared by writing 1.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Programming alignment error Set by hardware when the data to program cannot be contained in the same double word (64-bit) flash memory in case of standard programming, or if there is a change of page during fast programming. Cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Size error Set by hardware when the size of the access is a byte or half-word during a program or a fast program sequence. Only double word programming is allowed (consequently: word access). Cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Programming sequence error Set by hardware when a write access to the flash memory is performed by the code while PG or FSTPG have not been set previously. Set also by hardware when PROGERR, SIZERR, PGAERR, WRPERR, MISSERR or FASTERR is set due to a previous programming error. Cleared by writing 1.
        constexpr uint32_t MISSERR = (1U << 8);  ///< Fast programming data miss error In Fast programming mode, 16 double words (128 bytes) must be sent to flash memory successively, and the new data must be sent to the logic control before the current data is fully programmed. MISSERR is set by hardware when the new data is not present in time. Cleared by writing 1.
        constexpr uint32_t FASTERR = (1U << 9);  ///< Fast programming error Set by hardware when a fast programming sequence (activated by FSTPG) is interrupted due to an error (alignment, size, write protection or data miss). The corresponding status bit (PGAERR, SIZERR, WRPERR or MISSERR) is set at the same time. Cleared by writing 1.
        constexpr uint32_t RDERR = (1U << 14);  ///< PCROP read error Set by hardware when an address to be read belongs to a read protected area of the flash memory (PCROP protection). An interrupt is generated if RDERRIE is set in FLASH_CR. Cleared by writing 1.
        constexpr uint32_t OPTVERR = (1U << 15);  ///< Option and Engineering bits loading validity error
        constexpr uint32_t BSY1 = (1U << 16);  ///< Busy This flag indicates that a flash memory operation requested by FLASH control register (FLASH_CR) is in progress. This bit is set at the beginning of the flash memory operation, and cleared when the operation finishes or when an error occurs.
        constexpr uint32_t CFGBSY = (1U << 18);  ///< Programming or erase configuration busy. This flag is set and cleared by hardware. It is set when the first word is sent for program or when setting the STRT bit of FLASH control register (FLASH_CR) for erase. It is cleared when the flash memory program or erase operation completes or ends with an error. When set, launching any other operation through the FLASH control register (FLASH_CR) is impossible, and must be postponed (a programming or erase operation is ongoing). When cleared, the program and erase settings in the FLASH control register (FLASH_CR) can be modified.
    }

    /// FLASH_CR Register bits
    namespace flash_cr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Flash memory programming enable
        constexpr uint32_t PER = (1U << 1);  ///< Page erase enable
        constexpr uint32_t MER1 = (1U << 2);  ///< Mass erase When set, this bit triggers the mass erase, that is, all user pages.
        constexpr uint32_t PNB = (7 << 3);  ///< Page number selection These bits select the page to erase: ... Note: Values corresponding to addresses outside the main memory are not allowed.
        constexpr uint32_t STRT = (1U << 16);  ///< Start erase operation This bit triggers an erase operation when set. This bit is possible to set only by software and to clear only by hardware. The hardware clears it when one of BSY1 and BSY2 flags in the FLASH_SR register transits to zero.
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Start of modification of option bytes This bit triggers an options operation when set. This bit is set only by software, and is cleared when the BSY1 bit is cleared in FLASH_SR.
        constexpr uint32_t FSTPG = (1U << 18);  ///< Fast programming enable
        constexpr uint32_t EOPIE = (1U << 24);  ///< End-of-operation interrupt enable This bit enables the interrupt generation upon setting the EOP flag in the FLASH_SR register.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Error interrupt enable This bit enables the interrupt generation upon setting the OPERR flag in the FLASH_SR register.
        constexpr uint32_t RDERRIE = (1U << 26);  ///< PCROP read error interrupt enable This bit enables the interrupt generation upon setting the RDERR flag in the FLASH_SR register.
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Option byte load launch When set, this bit triggers the load of option bytes into option registers. It is automatically cleared upon the completion of the load. The high state of the bit indicates pending option byte load. The bit cannot be cleared by software. It cannot be written as long as OPTLOCK is set.
        constexpr uint32_t SEC_PROT = (1U << 28);  ///< Securable memory area protection enable This bit enables the protection on securable area, provided that a non-null securable memory area size (SEC_SIZE[4:0]) is defined in option bytes. This bit is possible to set only by software and to clear only through a system reset.
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Options Lock This bit is set only. When set, all bits concerning user option in FLASH_CR register and so option page are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit must be cleared before doing the unlock sequence for OPTLOCK bit. In case of an unsuccessful unlock operation, this bit remains set until the next reset.
        constexpr uint32_t LOCK = (1U << 31);  ///< FLASH_CR Lock This bit is set only. When set, the FLASH_CR register is locked. It is cleared by hardware after detecting the unlock sequence. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_ECCR Register bits
    namespace flash_eccr_bits {
        constexpr uint32_t ADDR_ECC = (14 << 0);  ///< ECC fail double-word address offset In case of ECC error or ECC correction detected, this bitfield contains double-word offset (multiple of 64 bits) to main Flash memory.
        constexpr uint32_t SYSF_ECC = (1U << 20);  ///< System Flash memory ECC fail This bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory.
        constexpr uint32_t ECCCIE = (1U << 24);  ///< ECC correction interrupt enable
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction Set by hardware when one ECC error has been detected and corrected. An interrupt is generated if ECCIE is set. Cleared by writing 1.
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection Set by hardware when two ECC errors have been detected. When this bit is set, a NMI is generated. Cleared by writing 1.
    }

    /// FLASH_OPTR Register bits
    namespace flash_optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Read protection level Other: Level 1, memories read protection active
        constexpr uint32_t BORR_LEV = (3 << 8);  ///< BOR reset level
        constexpr uint32_t NRST_STOP = (1U << 13);  ///< Reset generated when entering Stop mode
        constexpr uint32_t NRST_STDBY = (1U << 14);  ///< Reset generated when entering Standby mode
        constexpr uint32_t NRST_SHDW = (1U << 15);  ///< Reset generated when entering Shutdown mode
        constexpr uint32_t IWDG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t BDRST = (1U << 21);  ///< Backup domain reset
        constexpr uint32_t RAM_PARITY_CHECK = (1U << 22);  ///< SRAM parity check control enable/disable
        constexpr uint32_t BKPSRAM_HW_ERASE_DISABLE = (1U << 23);  ///< Backup SRAM erase prevention
        constexpr uint32_t NBOOT_SEL = (1U << 24);  ///< BOOT0 signal source selection This option bit defines the source of the BOOT0 signal.
        constexpr uint32_t NBOOT1 = (1U << 25);  ///< Boot configuration Together with the BOOT0 pin or option bit NBOOT0 (depending on NBOOT_SEL option bit configuration), this bit selects boot mode from the main flash memory, SRAM or the system memory. Refer to Section12.5: Boot configuration.
        constexpr uint32_t NBOOT0 = (1U << 26);  ///< NBOOT0 option bit
        constexpr uint32_t NRST_MODE = (2 << 27);  ///< NRST pin configuration
        constexpr uint32_t IRHEN = (1U << 29);  ///< Internal reset holder enable bit
    }

    /// FLASH_WRP1AR Register bits
    namespace flash_wrp1ar_bits {
        constexpr uint32_t WRP1A_STRT = (7 << 0);  ///< WRP area A start offset This bitfield contains the offset of the first page of the WRP area A. Note: The number of effective bits depends on the size of the flash memory in the device.
        constexpr uint32_t WRP1A_END = (7 << 16);  ///< WRP area A end offset This bitfield contains the offset of the last page of the WRP area A. Note: The number of effective bits depends on the size of the flash memory in the device.
    }

    /// FLASH_WRP1BR Register bits
    namespace flash_wrp1br_bits {
        constexpr uint32_t WRP1B_STRT = (7 << 0);  ///< WRP area B start offset This bitfield contains the offset of the first page of the WRP area B. Note: The number of effective bits depends on the size of the flash memory in the device.
        constexpr uint32_t WRP1B_END = (7 << 16);  ///< WRP area B end offset This bitfield contains the offset of the last page of the WRP area B. Note: The number of effective bits depends on the size of the flash memory in the device.
    }

    /// FLASH_SECR Register bits
    namespace flash_secr_bits {
        constexpr uint32_t HDP1_PEND = (7 << 0);  ///< Last page of the first hide protection area
        constexpr uint32_t BOOT_LOCK = (1U << 16);  ///< used to force boot from user area If the bit is set in association with RDP level 1, the debug capabilities are disabled, except in the case of a bad OBL (mismatch).
        constexpr uint32_t HDP1EN = (8 << 24);  ///< Hide protection area enable
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x50000000;
    constexpr uint32_t GPIOB_BASE = 0x50000400;
    constexpr uint32_t GPIOC_BASE = 0x50000800;
    constexpr uint32_t GPIOD_BASE = 0x50000C00;
    constexpr uint32_t GPIOE_BASE = 0x50001000;
    constexpr uint32_t GPIOF_BASE = 0x50001400;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIOA_MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t GPIOA_OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t GPIOA_OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t GPIOA_PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t GPIOA_IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t GPIOA_ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t GPIOA_BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t GPIOA_LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t GPIOA_AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t GPIOA_AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t GPIOA_BRR;  ///< Offset: 0x28 - GPIO port bit reset register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);

    // Bit definitions
    /// GPIOA_MODER Register bits
    namespace gpioa_moder_bits {
        constexpr uint32_t MODE0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
        constexpr uint32_t MODE15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
    }

    /// GPIOA_OTYPER Register bits
    namespace gpioa_otyper_bits {
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
    }

    /// GPIOA_OSPEEDR Register bits
    namespace gpioa_ospeedr_bits {
        constexpr uint32_t OSPEED0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
        constexpr uint32_t OSPEED15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
    }

    /// GPIOA_PUPDR Register bits
    namespace gpioa_pupdr_bits {
        constexpr uint32_t PUPD0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
        constexpr uint32_t PUPD15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
    }

    /// GPIOA_IDR Register bits
    namespace gpioa_idr_bits {
        constexpr uint32_t ID0 = (1U << 0);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID1 = (1U << 1);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID2 = (1U << 2);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID3 = (1U << 3);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID4 = (1U << 4);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID5 = (1U << 5);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID6 = (1U << 6);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID7 = (1U << 7);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID8 = (1U << 8);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID9 = (1U << 9);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID10 = (1U << 10);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID11 = (1U << 11);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID12 = (1U << 12);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID13 = (1U << 13);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID14 = (1U << 14);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
        constexpr uint32_t ID15 = (1U << 15);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
    }

    /// GPIOA_ODR Register bits
    namespace gpioa_odr_bits {
        constexpr uint32_t OD0 = (1U << 0);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD1 = (1U << 1);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD2 = (1U << 2);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD3 = (1U << 3);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD4 = (1U << 4);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD5 = (1U << 5);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD6 = (1U << 6);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD7 = (1U << 7);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD8 = (1U << 8);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD9 = (1U << 9);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD10 = (1U << 10);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD11 = (1U << 11);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD12 = (1U << 12);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD13 = (1U << 13);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD14 = (1U << 14);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
        constexpr uint32_t OD15 = (1U << 15);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
    }

    /// GPIOA_BSRR Register bits
    namespace gpioa_bsrr_bits {
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    }

    /// GPIOA_LCKR Register bits
    namespace gpioa_lckr_bits {
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
        constexpr uint32_t LCKK = (1U << 16);  ///< Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
    }

    /// GPIOA_AFRL Register bits
    namespace gpioa_afrl_bits {
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
    }

    /// GPIOA_AFRH Register bits
    namespace gpioa_afrh_bits {
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
    }

    /// GPIOA_BRR Register bits
    namespace gpioa_brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t IWDG_KR;  ///< Offset: 0x00 - IWDG key register
        volatile uint32_t IWDG_PR;  ///< Offset: 0x04 - IWDG prescaler register
        volatile uint32_t IWDG_RLR;  ///< Offset: 0x08 - IWDG reload register
        volatile uint32_t IWDG_SR;  ///< Offset: 0x0C - IWDG status register
        volatile uint32_t IWDG_WINR;  ///< Offset: 0x10 - IWDG window register
        volatile uint32_t IWDG_EWCR;  ///< Offset: 0x14 - IWDG early wake-up interrupt register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);

    // Bit definitions
    /// IWDG_KR Register bits
    namespace iwdg_kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000) These bits can be used for several functions, depending upon the value written by the application: - 0xAAAA: reloads the RL[11:0] value into the IWDCNT down-counter (watchdog refresh), and write-protects registers. This value must be written by software at regular intervals, otherwise the watchdog generates a reset when the counter reaches 0. - 0x5555: enables write-accesses to the registers. - 0xCCCC: enables the watchdog (except if the hardware watchdog option is selected) and write-protects registers. - values different from 0x5555: write-protects registers. Note that only IWDG_PR, IWDG_RLR, IWDG_EWCR and IWDG_WINR registers have a write-protection mechanism.
    }

    /// IWDG_PR Register bits
    namespace iwdg_pr_bits {
        constexpr uint32_t PR = (4 << 0);  ///< Prescaler divider These bits are write access protected, see Section126.4.6. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset to be able to change the prescaler divider. Others: divider / 1024 Note: Reading this register returns the prescaler value from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG status register (IWDG_SR) is reset.
    }

    /// IWDG_RLR Register bits
    namespace iwdg_rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value These bits are write access protected, see Section126.4.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_KR). The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2. The RVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value. Note: Reading this register returns the reload value from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the RVU bit in the IWDG status register (IWDG_SR) is reset.
    }

    /// IWDG_SR Register bits
    namespace iwdg_sr_bits {
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the V<sub>DD</sub> voltage domain (takes up to six periods of the IWDG kernel clock iwdg_ker_ck). The prescaler value can be updated only when PVU bit is reset.
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to six periods of the IWDG kernel clock iwdg_ker_ck). The reload value can be updated only when RVU bit is reset.
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to one period of presc_ck and two periods of the IWDG kernel clock iwdg_ker_ck). The window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1.
        constexpr uint32_t EWU = (1U << 3);  ///< Watchdog interrupt comparator value update This bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the V<sub>DD</sub> voltage domain (takes up to one period of presc_ck and two periods of the IWDG kernel clock iwdg_ker_ck). The EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset.
        constexpr uint32_t ONF = (1U << 8);  ///< Watchdog enable status bit Set to 1 by hardware as soon as the IWDG is started. In software mode, it remains to '1' until the IWDG is reset. In hardware mode, this bit is always set to '1'.
        constexpr uint32_t EWIF = (1U << 14);  ///< Watchdog early interrupt flag This bit is set to 1 by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to 1.
    }

    /// IWDG_WINR Register bits
    namespace iwdg_winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value These bits are write access protected, see Section126.4.6.They contain the high limit of the window value to be compared with the downcounter. To prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]1+11 and greater than 1. The WVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value. Note: Reading this register returns the reload value from the V<sub>DD</sub> voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG status register (IWDG_SR) is reset.
    }

    /// IWDG_EWCR Register bits
    namespace iwdg_ewcr_bits {
        constexpr uint32_t EWIT = (12 << 0);  ///< Watchdog counter window value These bits are write access protected (see Section126.4.6). They are written by software to define at which position of the IWDCNT down-counter the early wake-up interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0]1-11. EWIT[11:0] must be bigger than 1. An interrupt is generated only if EWIE = 1. The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value. Note: Reading this register returns the Early wake-up comparator value and the Interrupt enable bit from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the IWDG status register (IWDG_SR) is reset.
        constexpr uint32_t EWIC = (1U << 14);  ///< Watchdog early interrupt acknowledge The software must write a 1 into this bit in order to acknowledge the early wake-up interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0.
        constexpr uint32_t EWIE = (1U << 15);  ///< Watchdog early interrupt enable Set and reset by software. The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the value of this bit.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t I2C3_BASE = 0x40008800;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2C_CR1;  ///< Offset: 0x00 - I2C control register 1
        volatile uint32_t I2C_CR2;  ///< Offset: 0x04 - I2C control register 2
        volatile uint32_t I2C_OAR1;  ///< Offset: 0x08 - I2C own address 1 register
        volatile uint32_t I2C_OAR2;  ///< Offset: 0x0C - I2C own address 2 register
        volatile uint32_t I2C_TIMINGR;  ///< Offset: 0x10 - I2C timing register
        volatile uint32_t I2C_TIMEOUTR;  ///< Offset: 0x14 - I2C timeout register
        volatile uint32_t I2C_ISR;  ///< Offset: 0x18 - I2C interrupt and status register
        volatile uint32_t I2C_ICR;  ///< Offset: 0x1C - I2C interrupt clear register
        volatile uint32_t I2C_PECR;  ///< Offset: 0x20 - I2C PEC register
        volatile uint32_t I2C_RXDR;  ///< Offset: 0x24 - I2C receive data register
        volatile uint32_t I2C_TXDR;  ///< Offset: 0x28 - I2C transmit data register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);

    // Bit definitions
    /// I2C_CR1 Register bits
    namespace i2c_cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable Note: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least three APB clock cycles.
        constexpr uint32_t TXIE = (1U << 1);  ///< TX interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< Stop detection interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer complete interrupt enable Note: Any of these events generate an interrupt: Note: Transfer complete (TC) Note: Transfer complete reload (TCR)
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable Note: Any of these errors generate an interrupt: Note: Arbitration loss (ARLO) Note: Bus error detection (BERR) Note: Overrun/Underrun (OVR)
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * t<sub>I2CCLK</sub> <sub>...</sub> Note: If the analog filter is enabled, the digital filter is added to it. This filter can be programmed only when the I2C is disabled (PE = 0).
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF Note: This bit can be programmed only when the I2C is disabled (PE = 0).
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control This bit is used to enable hardware byte control in slave mode.
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can be programmed only when the I2C is disabled (PE = 0).
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wake-up from Stop mode enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t FMP = (1U << 24);  ///< Fast-mode Plus 20 mA drive enable
        constexpr uint32_t ADDRACLR = (1U << 30);  ///< Address match flag (ADDR) automatic clear
        constexpr uint32_t STOPFACLR = (1U << 31);  ///< STOP detection flag (STOPF) automatic clear
    }

    /// I2C_CR2 Register bits
    namespace i2c_cr2_bits {
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] must be written with the 7-bit slave address to be sent. Bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] must be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
        constexpr uint32_t START = (1U << 13);  ///< Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated start condition when RELOAD = 0, after the end of the NBYTES transfer. Otherwise, setting this bit generates a START condition once the bus is free. Note: Writing 0 to this bit has no effect. Note: The START bit can be set even if the bus is BUSY or I2C is in slave mode. Note: This bit has no effect when RELOAD is set.
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In master mode: Note: Writing 0 to this bit has no effect.
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0. Note: Writing 0 to this bit has no effect. Note: This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. Note: When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated, whatever the NACK bit value. Note: When hardware PEC checking is enabled (PECBYTE = 1), the PEC acknowledge value does not depend on the NACK value.
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode This bit is set and cleared by software.
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    }

    /// I2C_OAR1 Register bits
    namespace i2c_oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. Bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN = 0.
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own address 1 10-bit mode Note: This bit can be written only when OA1EN = 0.
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own address 1 enable
    }

    /// I2C_OAR2 Register bits
    namespace i2c_oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN = 0.
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own address 2 masks Note: These bits can be written only when OA2EN = 0. Note: As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own address 2 enable
    }

    /// I2C_TIMINGR Register bits
    namespace i2c_timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode) This field is used to generate the SCL low period in master mode. t<sub>SCLL </sub>= (SCLL + 1) x t<sub>PRESC</sub> Note: SCLL is also used to generate t<sub>BUF </sub>and t<sub>SU:STA </sub>timings.
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode) This field is used to generate the SCL high period in master mode. t<sub>SCLH </sub>= (SCLH + 1) x t<sub>PRESC</sub> Note: SCLH is also used to generate t<sub>SU:STO </sub>and t<sub>HD:STA </sub>timing.
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time This field is used to generate the delay t<sub>SDADEL </sub>between SCL falling edge and SDA edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SDADEL</sub>. t<sub>SDADEL</sub>= SDADEL x t<sub>PRESC</sub> Note: SDADEL is used to generate t<sub>HD:DAT </sub>timing.
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time This field is used to generate a delay t<sub>SCLDEL </sub>between SDA edge and SCL rising edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SCLDEL</sub>. t<sub>SCLDEL </sub>= (SCLDEL + 1) x t<sub>PRESC</sub> Note: t<sub>SCLDEL</sub> is used to generate t<sub>SU:DAT </sub>timing.
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler This field is used to prescale I2CCLK to generate the clock period t<sub>PRESC </sub>used for data setup and hold counters (refer to I2C timings) and for SCL high and low level counters (refer to I2C master initialization). t<sub>PRESC </sub>= (PRESC + 1) x t<sub>I2CCLK</sub>
    }

    /// I2C_TIMEOUTR Register bits
    namespace i2c_timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A This field is used to configure: The SCL low timeout condition t<sub>TIMEOUT</sub> when TIDLE = 0 t<sub>TIMEOUT</sub>= (TIMEOUTA + 1) x 2048 x t<sub>I2CCLK</sub> The bus idle condition (both SCL and SDA high) when TIDLE = 1 t<sub>IDLE</sub>= (TIMEOUTA + 1) x 4 x t<sub>I2CCLK</sub> Note: These bits can be written only when TIMOUTEN = 0.
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection Note: This bit can be written only when TIMOUTEN = 0.
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (t<sub>LOW:MEXT</sub>) is detected In slave mode, the slave cumulative clock low extend time (t<sub>LOW:SEXT</sub>) is detected t<sub>LOW:EXT </sub>= (TIMEOUTB + TIDLE = 01) x 2048 x t<sub>I2CCLK</sub> Note: These bits can be written only when TEXTEN = 0.
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// I2C_ISR Register bits
    namespace i2c_isr_bits {
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE = 0.
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software only when NOSTRETCH = 1, to generate a TXIS event (interrupt if TXIE = 1 or DMA request if TXDMAEN = 1). Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t NACKF = (1U << 4);  ///< Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag This flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode) This flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload This flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE = 0. Note: This flag is only for master mode, or for slave mode when the SBC bit is set.
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error This flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE = 0.
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected, and cleared by hardware when a STOP condition is detected, or when PE = 0.
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (slave mode) This flag is updated when an address match event occurs (ADDR = 1).
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the two MSBs of the address.
    }

    /// I2C_ICR Register bits
    namespace i2c_icr_bits {
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear Writing 1 to this bit clears the NACKF flag in I2C_ISR register.
        constexpr uint32_t STOPCF = (1U << 5);  ///< STOP detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    }

    /// I2C_PECR Register bits
    namespace i2c_pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE = 0.
    }

    /// I2C_RXDR Register bits
    namespace i2c_rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data Data byte received from the I<sup>2</sup>C bus
    }

    /// I2C_TXDR Register bits
    namespace i2c_txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data Data byte to be transmitted to the I<sup>2</sup>C bus Note: These bits can be written only when TXE = 1.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM1_BASE = 0x40007C00;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t LPTIM1_ISR_OUTPUT;  ///< Offset: 0x00 - LPTIM1 interrupt and status register [alternate]
        volatile uint32_t LPTIM1_ISR_INPUT;  ///< Offset: 0x00 - LPTIM1 interrupt and status register [alternate]
        volatile uint32_t LPTIM1_ICR_OUTPUT;  ///< Offset: 0x04 - LPTIM1 interrupt clear register [alternate]
        volatile uint32_t LPTIM1_ICR_INPUT;  ///< Offset: 0x04 - LPTIM1 interrupt clear register [alternate]
        volatile uint32_t LPTIM1_DIER_OUTPUT;  ///< Offset: 0x08 - LPTIM1 interrupt enable register [alternate]
        volatile uint32_t LPTIM1_DIER_INPUT;  ///< Offset: 0x08 - LPTIM1 interrupt enable register [alternate]
        volatile uint32_t LPTIM1_CFGR;  ///< Offset: 0x0C - LPTIM configuration register
        volatile uint32_t LPTIM1_CR;  ///< Offset: 0x10 - LPTIM control register
        volatile uint32_t LPTIM1_CCR1;  ///< Offset: 0x14 - LPTIM compare register 1
        volatile uint32_t LPTIM1_ARR;  ///< Offset: 0x18 - LPTIM autoreload register
        volatile uint32_t LPTIM1_CNT;  ///< Offset: 0x1C - LPTIM counter register
        volatile uint32_t LPTIM1_CFGR2;  ///< Offset: 0x24 - LPTIM configuration register 2
        volatile uint32_t LPTIM1_RCR;  ///< Offset: 0x28 - LPTIM repetition register
        volatile uint32_t LPTIM1_CCMR1;  ///< Offset: 0x2C - LPTIM capture/compare mode register 1
        volatile uint32_t LPTIM1_CCMR2;  ///< Offset: 0x30 - LPTIM capture/compare mode register 2
        volatile uint32_t LPTIM1_CCR2;  ///< Offset: 0x34 - LPTIM compare register 2
        volatile uint32_t LPTIM1_CCR3;  ///< Offset: 0x38 - LPTIM compare register 3
        volatile uint32_t LPTIM1_CCR4;  ///< Offset: 0x3C - LPTIM compare register 4
    };

    /// Peripheral instances
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);

    // Bit definitions
    /// LPTIM1_ISR_OUTPUT Register bits
    namespace lptim1_isr_output_bits {
        constexpr uint32_t CC1IF = (1U << 0);  ///< Compare 1 interrupt flag If channel CC1 is configured as output: The CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
        constexpr uint32_t CMP1OK = (1U << 3);  ///< Compare register 1 update OK CMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register.
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred UE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA.
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update OK REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.
        constexpr uint32_t CC2IF = (1U << 9);  ///< Compare 2 interrupt flag If channel CC2 is configured as output: The CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3IF = (1U << 10);  ///< Compare 3 interrupt flag If channel CC3 is configured as output: The CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4IF = (1U << 11);  ///< Compare 4 interrupt flag If channel CC4 is configured as output: The CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP2OK = (1U << 19);  ///< Compare register 2 update OK CMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP3OK = (1U << 20);  ///< Compare register 3 update OK CMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP4OK = (1U << 21);  ///< Compare register 4 update OK CMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DIEROK = (1U << 24);  ///< Interrupt enable register update OK DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.
    }

    /// LPTIM1_ISR_INPUT Register bits
    namespace lptim1_isr_input_bits {
        constexpr uint32_t CC1IF = (1U << 0);  ///< capture 1 interrupt flag If channel CC1 is configured as input: CC1IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR1 register. The corresponding interrupt or DMA request is generated if enabled. The CC1OF flag is set if the CC1IF flag was already high.
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred UE is set by hardware to inform application that an update event was generated. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register.
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update OK REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.
        constexpr uint32_t CC2IF = (1U << 9);  ///< Capture 2 interrupt flag If channel CC2 is configured as input: CC2IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR2 register. The corresponding interrupt or DMA request is generated if enabled. The CC2OF flag is set if the CC2IF flag was already high. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3IF = (1U << 10);  ///< Capture 3 interrupt flag If channel CC3 is configured as input: CC3IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR3 register. The corresponding interrupt or DMA request is generated if enabled. The CC3OF flag is set if the CC3IF flag was already high. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4IF = (1U << 11);  ///< Capture 4 interrupt flag If channel CC4 is configured as input: CC4IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR4 register. The corresponding interrupt or DMA request is generated if enabled. The CC4OF flag is set if the CC4IF flag was already high. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC1OF = (1U << 12);  ///< Capture 1 over-capture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC1OCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC2OF = (1U << 13);  ///< Capture 2 over-capture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC2OCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3OF = (1U << 14);  ///< Capture 3 over-capture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC3OCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4OF = (1U << 15);  ///< Capture 4 over-capture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC4OCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DIEROK = (1U << 24);  ///< Interrupt enable register update OK DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.
    }

    /// LPTIM1_ICR_OUTPUT Register bits
    namespace lptim1_icr_output_bits {
        constexpr uint32_t CC1CF = (1U << 0);  ///< Capture/compare 1 clear flag Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
        constexpr uint32_t CMP1OKCF = (1U << 3);  ///< Compare register 1 update OK clear flag Writing 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register.
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.
        constexpr uint32_t CC2CF = (1U << 9);  ///< Capture/compare 2 clear flag Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3CF = (1U << 10);  ///< Capture/compare 3 clear flag Writing 1 to this bit clears the CC3IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4CF = (1U << 11);  ///< Capture/compare 4 clear flag Writing 1 to this bit clears the CC4IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP2OKCF = (1U << 19);  ///< Compare register 2 update OK clear flag Writing 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP3OKCF = (1U << 20);  ///< Compare register 3 update OK clear flag Writing 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP4OKCF = (1U << 21);  ///< Compare register 4 update OK clear flag Writing 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DIEROKCF = (1U << 24);  ///< Interrupt enable register update OK clear flag Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.
    }

    /// LPTIM1_ICR_INPUT Register bits
    namespace lptim1_icr_input_bits {
        constexpr uint32_t CC1CF = (1U << 0);  ///< Capture/compare 1 clear flag Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.
        constexpr uint32_t CC2CF = (1U << 9);  ///< Capture/compare 2 clear flag Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3CF = (1U << 10);  ///< Capture/compare 3 clear flag Writing 1 to this bit clears the CC3IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4CF = (1U << 11);  ///< Capture/compare 4 clear flag Writing 1 to this bit clears the CC4IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC1OCF = (1U << 12);  ///< Capture/compare 1 over-capture clear flag Writing 1 to this bit clears the CC1OF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC2OCF = (1U << 13);  ///< Capture/compare 2 over-capture clear flag Writing 1 to this bit clears the CC2OF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3OCF = (1U << 14);  ///< Capture/compare 3 over-capture clear flag Writing 1 to this bit clears the CC3OF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4OCF = (1U << 15);  ///< Capture/compare 4 over-capture clear flag Writing 1 to this bit clears the CC4OF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DIEROKCF = (1U << 24);  ///< Interrupt enable register update OK clear flag Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.
    }

    /// LPTIM1_DIER_OUTPUT Register bits
    namespace lptim1_dier_output_bits {
        constexpr uint32_t CC1IE = (1U << 0);  ///< Capture/compare 1 interrupt enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t CMP1OKIE = (1U << 3);  ///< Compare register 1 update OK interrupt enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< Repetition register update OK interrupt Enable
        constexpr uint32_t CC2IE = (1U << 9);  ///< Capture/compare 2 interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3IE = (1U << 10);  ///< Capture/compare 3 interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4IE = (1U << 11);  ///< Capture/compare 4 interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP2OKIE = (1U << 19);  ///< Compare register 2 update OK interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP3OKIE = (1U << 20);  ///< Compare register 3 update OK interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CMP4OKIE = (1U << 21);  ///< Compare register 4 update OK interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UEDE = (1U << 23);  ///< Update event DMA request enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
    }

    /// LPTIM1_DIER_INPUT Register bits
    namespace lptim1_dier_input_bits {
        constexpr uint32_t CC1IE = (1U << 0);  ///< Capture/compare 1 interrupt enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< Repetition register update OK interrupt Enable
        constexpr uint32_t CC2IE = (1U << 9);  ///< Capture/compare 2 interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3IE = (1U << 10);  ///< Capture/compare 3 interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4IE = (1U << 11);  ///< Capture/compare 4 interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC1OIE = (1U << 12);  ///< Capture/compare 1 over-capture interrupt enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC2OIE = (1U << 13);  ///< Capture/compare 2 over-capture interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3OIE = (1U << 14);  ///< Capture/compare 3 over-capture interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4OIE = (1U << 15);  ///< Capture/compare 4 over-capture interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC1DE = (1U << 16);  ///< Capture/compare 1 DMA request enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
        constexpr uint32_t UEDE = (1U << 23);  ///< Update event DMA request enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC2DE = (1U << 25);  ///< Capture/compare 2 DMA request enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC3DE = (1U << 26);  ///< Capture/compare 3 DMA request enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
        constexpr uint32_t CC4DE = (1U << 27);  ///< Capture/compare 4 DMA request enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
    }

    /// LPTIM1_CFGR Register bits
    namespace lptim1_cfgr_bits {
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector The CKSEL bit selects which clock source the LPTIM uses:
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active. Refer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes.
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector The TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources: See Section125.4.3: LPTIM input and trigger mapping for details.
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable The TIMOUT bit controls the Timeout feature
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape The WAVE bit controls the output shape
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode The PRELOAD bit controls the LPTIM1_ARR, LPTIM1_RCR and the LPTIM1_CCRx registers update modality
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
    }

    /// LPTIM1_CR Register bits
    namespace lptim1_cr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM enable The ENABLE bit is set and cleared by software.
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM1_ARR and LPTIM1_CNT registers. This bit can only be set when the LPTIM is enabled. It is automatically reset by hardware.
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM1_ARR and LPTIM1_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.
        constexpr uint32_t COUNTRST = (1U << 3);  ///< Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM1_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware. COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.
        constexpr uint32_t RSTARE = (1U << 4);  ///< Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM1_CNT register asynchronously resets LPTIM1_CNT register content. This bit can be set only when the LPTIM is enabled.
    }

    /// LPTIM1_CCR1 Register bits
    namespace lptim1_ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the capture/compare 1 register. Depending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 1 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC1 output. If channel CC1 is configured as input: CCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM1_CCR1 register is read-only and cannot be programmed.
    }

    /// LPTIM1_ARR Register bits
    namespace lptim1_arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CCRx[15:0] value.
    }

    /// LPTIM1_CNT Register bits
    namespace lptim1_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value When the LPTIM is running with an asynchronous clock, reading the LPTIM1_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
    }

    /// LPTIM1_CFGR2 Register bits
    namespace lptim1_cfgr2_bits {
        constexpr uint32_t IN1SEL = (2 << 0);  ///< LPTIM input 1 selection The IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
        constexpr uint32_t IN2SEL = (2 << 4);  ///< LPTIM input 2 selection The IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
        constexpr uint32_t IC1SEL = (2 << 16);  ///< LPTIM input capture 1 selection The IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
        constexpr uint32_t IC2SEL = (2 << 20);  ///< LPTIM input capture 2 selection The IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
    }

    /// LPTIM1_RCR Register bits
    namespace lptim1_rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition register value REP is the repetition value for the LPTIM.
    }

    /// LPTIM1_CCMR1 Register bits
    namespace lptim1_ccmr1_bits {
        constexpr uint32_t CC1SEL = (1U << 0);  ///< Capture/compare 1 selection This bitfield defines the direction of the channel input (capture) or output mode.
        constexpr uint32_t CC1E = (1U << 1);  ///< Capture/compare 1 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM1_CCR1) or not.
        constexpr uint32_t CC1P = (2 << 2);  ///< Capture/compare 1 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC1 polarity for capture operations.
        constexpr uint32_t IC1PSC = (2 << 8);  ///< Input capture 1 prescaler This bitfield defines the ratio of the prescaler acting on the CC1 input (IC1).
        constexpr uint32_t IC1F = (2 << 12);  ///< Input capture 1 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
        constexpr uint32_t CC2SEL = (1U << 16);  ///< Capture/compare 2 selection This bitfield defines the direction of the channel, input (capture) or output mode.
        constexpr uint32_t CC2E = (1U << 17);  ///< Capture/compare 2 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM1_CCR2) or not.
        constexpr uint32_t CC2P = (2 << 18);  ///< Capture/compare 2 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC2 polarity for capture operations.
        constexpr uint32_t IC2PSC = (2 << 24);  ///< Input capture 2 prescaler This bitfield defines the ratio of the prescaler acting on the CC2 input (IC2).
        constexpr uint32_t IC2F = (2 << 28);  ///< Input capture 2 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
    }

    /// LPTIM1_CCMR2 Register bits
    namespace lptim1_ccmr2_bits {
        constexpr uint32_t CC3SEL = (1U << 0);  ///< Capture/compare 3 selection This bitfield defines the direction of the channel input (capture) or output mode.
        constexpr uint32_t CC3E = (1U << 1);  ///< Capture/compare 3 output enable. Condition: CC3 as output: Condition: CC3 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM1_CCR3) or not.
        constexpr uint32_t CC3P = (2 << 2);  ///< Capture/compare 3 output polarity. Condition: CC3 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC3 as input: This field is used to select the IC3 polarity for capture operations.
        constexpr uint32_t IC3PSC = (2 << 8);  ///< Input capture 3 prescaler This bitfield defines the ratio of the prescaler acting on the CC3 input (IC3).
        constexpr uint32_t IC3F = (2 << 12);  ///< Input capture 3 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
        constexpr uint32_t CC4SEL = (1U << 16);  ///< Capture/compare 4 selection This bitfield defines the direction of the channel, input (capture) or output mode.
        constexpr uint32_t CC4E = (1U << 17);  ///< Capture/compare 4 output enable. Condition: CC4 as output: Condition: CC4 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM1_CCR4) or not.
        constexpr uint32_t CC4P = (2 << 18);  ///< Capture/compare 4 output polarity. Condition: CC4 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC4 as input: This field is used to select the IC4 polarity for capture operations.
        constexpr uint32_t IC4PSC = (2 << 24);  ///< Input capture 4 prescaler This bitfield defines the ratio of the prescaler acting on the CC4 input (IC4).
        constexpr uint32_t IC4F = (2 << 28);  ///< Input capture 4 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
    }

    /// LPTIM1_CCR2 Register bits
    namespace lptim1_ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the capture/compare 2 register. Depending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 2 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC2 output. If channel CC2 is configured as input: CCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM1_CCR2 register is read-only and cannot be programmed.
    }

    /// LPTIM1_CCR3 Register bits
    namespace lptim1_ccr3_bits {
        constexpr uint32_t CCR3 = (16 << 0);  ///< Capture/compare 3 value If channel CC3 is configured as output: CCR3 is the value to be loaded in the capture/compare 3 register. Depending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 3 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC3 output. If channel CC3 is configured as input: CCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM1_CCR3 register is read-only and cannot be programmed.
    }

    /// LPTIM1_CCR4 Register bits
    namespace lptim1_ccr4_bits {
        constexpr uint32_t CCR4 = (16 << 0);  ///< Capture/compare 4 value If channel CC4 is configured as output: CCR4 is the value to be loaded in the capture/compare 4 register. Depending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 4 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC4 output. If channel CC4 is configured as input: CCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM1_CCR4 register is read-only and cannot be programmed.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x40008000;
    constexpr uint32_t LPUART2_BASE = 0x40008400;
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t USART4_BASE = 0x40004C00;

    /// USART Register structure
    struct Registers {
        volatile uint32_t LPUART_CR1;  ///< Offset: 0x00 - LPUART control register 1
        volatile uint32_t LPUART_CR1_ALTERNATE;  ///< Offset: 0x00 - LPUART control register 1
        volatile uint32_t LPUART_CR2;  ///< Offset: 0x04 - LPUART control register 2
        volatile uint32_t LPUART_CR3;  ///< Offset: 0x08 - LPUART control register 3
        volatile uint32_t LPUART_BRR;  ///< Offset: 0x0C - LPUART baud rate register
        volatile uint32_t LPUART_RQR;  ///< Offset: 0x18 - LPUART request register
        volatile uint32_t LPUART_ISR;  ///< Offset: 0x1C - LPUART interrupt and status register
        volatile uint32_t LPUART_ISR_ALTERNATE;  ///< Offset: 0x1C - LPUART interrupt and status register
        volatile uint32_t LPUART_ICR;  ///< Offset: 0x20 - LPUART interrupt flag clear register
        volatile uint32_t LPUART_RDR;  ///< Offset: 0x24 - LPUART receive data register
        volatile uint32_t LPUART_TDR;  ///< Offset: 0x28 - LPUART transmit data register
        volatile uint32_t LPUART_PRESC;  ///< Offset: 0x2C - LPUART prescaler register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* USART4 = reinterpret_cast<Registers*>(USART4_BASE);

    // Bit definitions
    /// LPUART_CR1 Register bits
    namespace lpuart_cr1_bits {
        constexpr uint32_t UE = (1U << 0);  ///< LPUART enable When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
        constexpr uint32_t UESM = (1U << 1);  ///< LPUART enable in low-power mode When this bit is cleared, the LPUART cannot wake up the MCU from low-power mode. When this bit is set, the LPUART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable This bit enables the receiver. It is set and cleared by software.
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register. Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFIFO not empty interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wake-up method This bit determines the LPUART wake-up method from Mute mode. It is set or cleared by software.	 This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t M0 = (1U << 12);  ///< Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description). This bit can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section132.4.14: RS232 Hardware flow control and RS485 Driver Enable. If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section131.5.21: RS232 Hardware flow control and RS485 Driver Enable. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t M1 = (1U << 28);  ///< Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit M[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit M[1:0] = 10: 1 Start bit, 7 Data bits, n Stop bit This bit can only be written when the LPUART is disabled (UE=0). Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable This bit is set and cleared by software.
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFIFO empty interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFIFO Full interrupt enable This bit is set and cleared by software.
    }

    /// LPUART_CR1_ALTERNATE Register bits
    namespace lpuart_cr1_alternate_bits {
        constexpr uint32_t UE = (1U << 0);  ///< LPUART enable When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
        constexpr uint32_t UESM = (1U << 1);  ///< LPUART enable in low-power mode When this bit is cleared, the LPUART cannot wake up the MCU from low-power mode. When this bit is set, the LPUART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable This bit enables the receiver. It is set and cleared by software.
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register. Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXNEIE = (1U << 5);  ///< Receive data register not empty This bit is set and cleared by software.
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXEIE = (1U << 7);  ///< Transmit data register empty This bit is set and cleared by software.
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable This bit is set and cleared by software.
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wake-up method This bit determines the LPUART wake-up method from Mute mode. It is set or cleared by software.	 This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t M0 = (1U << 12);  ///< Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description). This bit can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable This bit is set and cleared by software.
        constexpr uint32_t DEDT = (5 << 16);  ///< Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section132.4.14: RS232 Hardware flow control and RS485 Driver Enable. If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t DEAT = (5 << 21);  ///< Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section131.5.21: RS232 Hardware flow control and RS485 Driver Enable. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t M1 = (1U << 28);  ///< Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit M[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit M[1:0] = 10: 1 Start bit, 7 Data bits, n Stop bit This bit can only be written when the LPUART is disabled (UE=0). Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFO mode enable This bit is set and cleared by software.
    }

    /// LPUART_CR2 Register bits
    namespace lpuart_cr2_bits {
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the LPUART is disabled (UE=0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits These bits are used for programming the stop bits. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the LPUART node These bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode: In Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used. In low-power mode: they are used for wake up from low-power mode on character match. When WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1. In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set. These bits can only be written when the reception is disabled (RE1=10) or when the USART is disabled (UE1=10).
    }

    /// LPUART_CR3 Register bits
    namespace lpuart_cr3_bits {
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register).
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver This bit is set/reset by software
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter This bit is set/reset by software
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable This bit can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable This bit can only be written when the LPUART is disabled (UE=0)
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register. This bit can only be written when the LPUART is disabled (UE=0). Note: This control bit enables checking the communication flow w/o reading the data.
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error This bit can only be written when the LPUART is disabled (UE=0). Note: The reception errors are: parity error, framing error or noise error.
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection This bit can only be written when the LPUART is disabled (UE=0).
        constexpr uint32_t WUS0 = (1U << 20);  ///< Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wake-up from low-power mode flag). This bitfield can only be written when the LPUART is disabled (UE=0). Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
        constexpr uint32_t WUS1 = (1U << 21);  ///< Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wake-up from low-power mode flag). This bitfield can only be written when the LPUART is disabled (UE=0). Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
        constexpr uint32_t WUFIE = (1U << 22);  ///< Wake-up from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFIFO threshold interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< Receive FIFO threshold configuration Remaining combinations: Reserved.
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFIFO threshold interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFIFO threshold configuration Remaining combinations: Reserved.
    }

    /// LPUART_BRR Register bits
    namespace lpuart_brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< LPUART baud rate division (LPUARTDIV)
    }

    /// LPUART_RQR Register bits
    namespace lpuart_rqr_bits {
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software must wait for the TXE flag assertion before setting the SBKRQ bit.
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request Writing 1 to this bit puts the LPUART in Mute mode and resets the RWU flag.
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request Writing 1 to this bit clears the RXNE flag. This enables discarding the received data without reading it, and avoid an overrun condition.
        constexpr uint32_t TXFRQ = (1U << 4);  ///< Transmit data flush request This bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register). Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
    }

    /// LPUART_ISR Register bits
    namespace lpuart_isr_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. An interrupt is generated if PEIE = 1 in the LPUART_CR1 register. Note: This error is associated with the character in the LPUART_RDR.
        constexpr uint32_t FE = (1U << 1);  ///< Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE1=11 in the LPUART_CR3 register. Note: This error is associated with the character in the LPUART_RDR.
        constexpr uint32_t NE = (1U << 2);  ///< Start bit noise detection flag This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. Note: This error is associated with the character in the LPUART_RDR.
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register. An interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register, or EIE = 1 in the LPUART_CR3 register. Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected This bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). Note: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.
        constexpr uint32_t RXFNE = (1U << 5);  ///< RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. An interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register.
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete This bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows: When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set. When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached. When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred. When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty. An interrupt is generated if TCIE=1 in the LPUART_CR1 register. TC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register.
        constexpr uint32_t TXFNF = (1U << 7);  ///< TXFIFO not full TXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR. The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF must be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). An interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register. Note: This bit is used during single buffer transmission.
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. An interrupt is generated if CTSIE=1 in the LPUART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        constexpr uint32_t CMF = (1U << 17);  ///< Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. An interrupt is generated if CMIE=1in the LPUART_CR1 register.
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wake-up from Mute mode This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register. When wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. Note: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value.
        constexpr uint32_t WUF = (1U << 20);  ///< Wake-up from low-power mode flag This bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register. An interrupt is generated if WUFIE=1 in the LPUART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. It can be used to verify that the LPUART is ready for reception before entering low-power mode. Note: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value.
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFIFO Empty This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register. An interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register.
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFIFO Full This bit is set by hardware when the number of received data corresponds to RXFIFO1size1+11 (RXFIFO full + 1 data in the LPUART_RDR register. An interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register.
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFIFO threshold flag This bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register.
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register.
    }

    /// LPUART_ISR_ALTERNATE Register bits
    namespace lpuart_isr_alternate_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Parity error This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. An interrupt is generated if PEIE = 1 in the LPUART_CR1 register. Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.
        constexpr uint32_t FE = (1U << 1);  ///< Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE1=11 in the LPUART_CR3 register. Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.
        constexpr uint32_t NE = (1U << 2);  ///< Start bit noise detection flag This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXNE/RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.
        constexpr uint32_t ORE = (1U << 3);  ///< Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the LPUART_RDR register while RXNE=1 (RXFF = 1 in case FIFO mode is enabled). It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register. An interrupt is generated if RXNEIE=1 in the LPUART_CR1 register, or EIE = 1 in the LPUART_CR3 register. Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs). Note: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.
        constexpr uint32_t RXNE = (1U << 5);  ///< Read data register not empty RXNE bit is set by hardware when the content of the LPUART_RDR shift register has been transferred to the LPUART_RDR register. It is cleared by a read to the LPUART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. An interrupt is generated if RXNEIE=1 in the LPUART_CR1 register.
        constexpr uint32_t TC = (1U << 6);  ///< Transmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag is set when the transmission of a frame containing data is complete and when TXE is set. An interrupt is generated if TCIE=1 in the LPUART_CR1 register. TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.
        constexpr uint32_t TXE = (1U << 7);  ///< Transmit data register empty TXE is set by hardware when the content of the LPUART_TDR register has been transferred into the shift register. It is cleared by a write to the LPUART_TDR register. An interrupt is generated if the TXEIE bit =1 in the LPUART_CR1 register. Note: This bit is used during single buffer transmission.
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTS interrupt flag This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. An interrupt is generated if CTSIE=1 in the LPUART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t CTS = (1U << 10);  ///< CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        constexpr uint32_t BUSY = (1U << 16);  ///< Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        constexpr uint32_t CMF = (1U << 17);  ///< Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. An interrupt is generated if CMIE=1in the LPUART_CR1 register.
        constexpr uint32_t SBKF = (1U << 18);  ///< Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        constexpr uint32_t RWU = (1U << 19);  ///< Receiver wake-up from Mute mode This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register. When wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. Note: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value.
        constexpr uint32_t WUF = (1U << 20);  ///< Wake-up from low-power mode flag This bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register. An interrupt is generated if WUFIE=1 in the LPUART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
        constexpr uint32_t TEACK = (1U << 21);  ///< Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.
        constexpr uint32_t REACK = (1U << 22);  ///< Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. It can be used to verify that the LPUART is ready for reception before entering low-power mode. Note: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value.
    }

    /// LPUART_ICR Register bits
    namespace lpuart_icr_bits {
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag Writing 1 to this bit clears the PE flag in the LPUART_ISR register.
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag Writing 1 to this bit clears the FE flag in the LPUART_ISR register.
        constexpr uint32_t NECF = (1U << 2);  ///< Noise detected clear flag Writing 1 to this bit clears the NE flag in the LPUART_ISR register.
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag Writing 1 to this bit clears the ORE flag in the LPUART_ISR register.
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the LPUART_ISR register.
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag Writing 1 to this bit clears the TC flag in the LPUART_ISR register.
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag Writing 1 to this bit clears the CTSIF flag in the LPUART_ISR register.
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag Writing 1 to this bit clears the CMF flag in the LPUART_ISR register.
        constexpr uint32_t WUCF = (1U << 20);  ///< Wake-up from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
    }

    /// LPUART_RDR Register bits
    namespace lpuart_rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value Contains the received data character. The RDR register provides the parallel interface between the input shift register and the internal bus (see Figure1254). When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
    }

    /// LPUART_TDR Register bits
    namespace lpuart_tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value Contains the data character to be transmitted. The TDR register provides the parallel interface between the internal bus and the output shift register (see Figure1254). When transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity. Note: This register must be written only when TXE/TXFNF=1.
    }

    /// LPUART_PRESC Register bits
    namespace lpuart_presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< Clock prescaler The LPUART input clock can be divided by a prescaler: Remaining combinations: Reserved. Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256.
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x40007800;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP_CSR;  ///< Offset: 0x00 - OPAMP control/status register
        volatile uint32_t OPAMP_OTR;  ///< Offset: 0x04 - OPAMP offset trimming register in normal mode
        volatile uint32_t OPAMP_LPOTR;  ///< Offset: 0x08 - OPAMP offset trimming register in low-power mode
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP_CSR Register bits
    namespace opamp_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< Operational amplifier Low Power Mode The operational amplifier must be disable to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< Operational amplifier PGA mode
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< Operational amplifier Programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. 1x:	Inverting input not externally connected. These configurations are valid only when OPAMODE = 10 (PGA mode)
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enabled
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< allows to switch from factory AOP offset trimmed values to AOP offset user trimmed values This bit is active for both mode normal and low-power.
        constexpr uint32_t CALOUT = (1U << 15);  ///< Operational amplifier calibration output During calibration mode offset is trimmed when this signal toggle.
        constexpr uint32_t OPA_RANGE = (1U << 31);  ///< Operational amplifier power supply range for stability All AOP must be in power down to allow AOP-RANGE bit write. It applies to all AOP embedded in the product.
    }

    /// OPAMP_OTR Register bits
    namespace opamp_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP_LPOTR Register bits
    namespace opamp_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40007000;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWR_CR1;  ///< Offset: 0x00 - Power control register 1
        volatile uint32_t PWR_CR2;  ///< Offset: 0x04 - Power control register 2
        volatile uint32_t PWR_CR3;  ///< Offset: 0x08 - Power control register 3
        volatile uint32_t PWR_CR4;  ///< Offset: 0x0C - Power control register 4
        volatile uint32_t PWR_SR1;  ///< Offset: 0x10 - Power status register 1
        volatile uint32_t PWR_SR2;  ///< Offset: 0x14 - Power status register 2
        volatile uint32_t PWR_SCR;  ///< Offset: 0x18 - Power status clear register
        volatile uint32_t PWR_PUCRA;  ///< Offset: 0x20 - Power Port A pull-up control register
        volatile uint32_t PWR_PDCRA;  ///< Offset: 0x24 - Power Port A pull-down control register
        volatile uint32_t PWR_PUCRB;  ///< Offset: 0x28 - Power Port B pull-up control register
        volatile uint32_t PWR_PDCRB;  ///< Offset: 0x2C - Power Port B pull-down control register
        volatile uint32_t PWR_PUCRC;  ///< Offset: 0x30 - Power Port C pull-up control register
        volatile uint32_t PWR_PDCRC;  ///< Offset: 0x34 - Power Port C pull-down control register
        volatile uint32_t PWR_PUCRD;  ///< Offset: 0x38 - Power Port D pull-up control register
        volatile uint32_t PWR_PDCRD;  ///< Offset: 0x3C - Power Port D pull-down control register
        volatile uint32_t PWR_PUCRE;  ///< Offset: 0x40 - Power Port E pull-up control register
        volatile uint32_t PWR_PDCRE;  ///< Offset: 0x44 - Power Port E pull-down control register
        volatile uint32_t PWR_PUCRF;  ///< Offset: 0x48 - Power Port F pull-up control register
        volatile uint32_t PWR_PDCRF;  ///< Offset: 0x4C - Power Port F pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// PWR_CR1 Register bits
    namespace pwr_cr1_bits {
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection These bits select the low-power mode entered when CPU enters the deepsleep mode. 1xx: Shutdown mode Note: If LPR bit is set, Stop 2 mode cannot be selected and Stop 1 mode shall be entered instead of Stop 2. Note: In Standby mode, SRAM2 can be preserved or not, depending on RRS bit configuration in PWR_CR3.
        constexpr uint32_t FPD_STOP = (1U << 3);  ///< Flash memory powered down during Stop mode. This bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Stop mode.
        constexpr uint32_t FPD_LPRUN = (1U << 4);  ///< Flash memory powered down during Low-power run mode. This bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Low-power sleep mode.
        constexpr uint32_t FPD_LPSLP = (1U << 5);  ///< Flash memory powered down during Low-power sleep mode. This bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Low-power sleep mode.
        constexpr uint32_t DBP = (1U << 8);  ///< Disable backup domain write protection In reset state, the RTC and backup registers are protected against parasitic write access. This bit must be set to enable write access to these registers.
        constexpr uint32_t VOS = (2 << 9);  ///< Voltage scaling range selection
        constexpr uint32_t LPR = (1U << 14);  ///< Low-power run When this bit is set, the regulator is switched from main mode (MR) to low-power mode (LPR). Note: Stop 2 mode cannot be entered when LPR bit is set. Stop 1 is entered instead.
    }

    /// PWR_CR2 Register bits
    namespace pwr_cr2_bits {
        constexpr uint32_t PVDE = (1U << 0);  ///< Programmable voltage detector enable Note: This bit is write-protected when the bit PVDL (PVD Lock) is set in the SYSCFG_CBR register. Note: This bit is reset only by a system reset.
        constexpr uint32_t PLS = (3 << 1);  ///< Programmable voltage detector level selection. These bits select the voltage threshold detected by the programmable voltage detector: Note: These bits are write-protected when the bit PVDL (PVD Lock) is set in the SYSCFG_CBR register. Note: These bits are reset only by a system reset.
        constexpr uint32_t PVME1 = (1U << 4);  ///< Peripheral voltage monitoring 1 enable: V<sub>DDUSB</sub> vs. 1.21V
        constexpr uint32_t PVME3 = (1U << 5);  ///< Peripheral voltage monitoring 3 enable: V<sub>DDA</sub> vs. 1.621V
        constexpr uint32_t PVME4 = (1U << 6);  ///< Peripheral voltage monitoring 4 enable: V<sub>DDA</sub> vs. 1.861V
        constexpr uint32_t USV = (1U << 10);  ///< V<sub>DDUSB</sub> USB supply valid This bit is used to validate the V<sub>DDUSB</sub> supply for electrical and logical isolation purpose. Setting this bit is mandatory to use the USB FS peripheral. If V<sub>DDUSB</sub> is not always present in the application, the PVM can be used to determine whether this supply is ready or not.
    }

    /// PWR_CR3 Register bits
    namespace pwr_cr3_bits {
        constexpr uint32_t EWUP1 = (1U << 0);  ///< Enable Wake-up pin WKUP1 When this bit is set, the external wake-up pin WKUP1 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP2 = (1U << 1);  ///< Enable Wake-up pin WKUP2 When this bit is set, the external wake-up pin WKUP2 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP3 = (1U << 2);  ///< Enable Wake-up pin WKUP3 When this bit is set, the external wake-up pin WKUP3 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP4 = (1U << 3);  ///< Enable Wake-up pin WKUP4 When this bit is set, the external wake-up pin WKUP4 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP5 = (1U << 4);  ///< Enable Wake-up pin WKUP5 When this bit is set, the external wake-up pin WKUP5 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP5 bit in the PWR_CR4 register.
        constexpr uint32_t EWUP7 = (1U << 6);  ///< Enable Wake-up pin WKUP7. When this bit is set, the external wake-up pin WKUP7 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP7 bit in the PWR_CR4 register.
        constexpr uint32_t RRS = (1U << 8);  ///< SRAM2 retention in Standby mode
        constexpr uint32_t ENULP = (1U << 9);  ///< Enable ULP sampling When this bit is set, the BORL, BORH and PVD are periodically sampled instead continuous monitoring to reduce power consumption. Fast supply drop between two sample/compare phases is not detected in this mode. This bit has impact only on STOP2, Standby and shutdown low power modes.
        constexpr uint32_t APC = (1U << 10);  ///< Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied. When this bit is cleared, the PWR_PUCRx and PWR_PDCRx registers are not applied to the I/Os, instead the I/Os are in floating mode during Standby or configured according GPIO controller GPIOx_PUPDR register during RUN mode.
        constexpr uint32_t EIWUL = (1U << 15);  ///< Enable internal wake-up line
    }

    /// PWR_CR4 Register bits
    namespace pwr_cr4_bits {
        constexpr uint32_t WP1 = (1U << 0);  ///< Wake-up pin WKUP1 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP1
        constexpr uint32_t WP2 = (1U << 1);  ///< Wake-up pin WKUP2 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP2
        constexpr uint32_t WP3 = (1U << 2);  ///< Wake-up pin WKUP3 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP3
        constexpr uint32_t WP4 = (1U << 3);  ///< Wake-up pin WKUP4 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP4
        constexpr uint32_t WP5 = (1U << 4);  ///< Wake-up pin WKUP5 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP5
        constexpr uint32_t WP7 = (1U << 6);  ///< Wake-up pin WKUP7 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP7
        constexpr uint32_t VBE = (1U << 8);  ///< V<sub>BAT</sub> battery charging enable
        constexpr uint32_t VBRS = (1U << 9);  ///< V<sub>BAT</sub> battery charging resistor selection
    }

    /// PWR_SR1 Register bits
    namespace pwr_sr1_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wake-up flag 1 This bit is set when a wake-up event is detected on wake-up pin, WKUP1. It is cleared by writing 1 in the CWUF1 bit of the PWR_SCR register.
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wake-up flag 2 This bit is set when a wake-up event is detected on wake-up pin, WKUP2. It is cleared by writing 1 in the CWUF2 bit of the PWR_SCR register.
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wake-up flag 3 This bit is set when a wake-up event is detected on wake-up pin, WKUP3. It is cleared by writing 1 in the CWUF3 bit of the PWR_SCR register.
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wake-up flag 4 This bit is set when a wake-up event is detected on wake-up pin,WKUP4. It is cleared by writing 1 in the CWUF4 bit of the PWR_SCR register.
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wake-up flag 5 This bit is set when a wake-up event is detected on wake-up pin, WKUP5. It is cleared by writing 1 in the CWUF5 bit of the PWR_SCR register.
        constexpr uint32_t WUF7 = (1U << 6);  ///< Wake-up flag 7 This bit is set when a wake-up event is detected on wake-up pin, WKUP7. It is cleared by writing 1 in the CWUF7 bit of the PWR_SCR register.
        constexpr uint32_t SBF = (1U << 8);  ///< Standby flag This bit is set by hardware when the device enters the Standby mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
        constexpr uint32_t STOPF = (3 << 9);  ///< Stop Flags These bits are set by hardware when the device enters any stop mode and are cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
        constexpr uint32_t WUFI = (1U << 15);  ///< Wake-up flag internal This bit is set when a wake-up is detected on the internal wake-up line. It is cleared when all internal wake-up sources are cleared.
    }

    /// PWR_SR2 Register bits
    namespace pwr_sr2_bits {
        constexpr uint32_t FLASH_RDY = (1U << 7);  ///< Flash ready flag This bit is set by hardware to indicate when the flash memory is readey to be accessed after wake-up from power-down. To place the flash memory in power-down, set either FPD_LPRUN, FPD_LPSLP or FPD_STP bits. Note : If the system boots from SRAM, the user application must wait until the FLASH_RDY bit is set, prior to jumping to flash memory.
        constexpr uint32_t REGLPS = (1U << 8);  ///< Low-power regulator started This bit provides the information whether the low-power regulator is ready after a power-on reset or a Standby/Shutdown. If the Standby mode is entered while REGLPS bit is still cleared, the wake-up from Standby mode time may be increased.
        constexpr uint32_t REGLPF = (1U << 9);  ///< Low-power regulator flag This bit is set by hardware when the MCU is in Low-power run mode. When the MCU exits from the Low-power run mode, this bit remains at 1 until the regulator is ready in main mode. A polling on this bit must be done before increasing the product frequency. This bit is cleared by hardware when the regulator is ready.
        constexpr uint32_t VOSF = (1U << 10);  ///< Voltage scaling flag A delay is required for the internal regulator to be ready after the voltage scaling has been changed. VOSF indicates that the regulator reached the voltage level defined with VOS bits of the PWR_CR1 register.
        constexpr uint32_t PVDO = (1U << 11);  ///< Programmable voltage detector output
        constexpr uint32_t PVMO1 = (1U << 12);  ///< Peripheral voltage monitoring output: V<sub>DDUSB</sub> vs. 1.2 V Note: PVMO1 is cleared when PVM1 is disabled (PVME1 = 0). After enabling PVM1, the PVM1 output is valid after the PVM1 wake-up time.
        constexpr uint32_t PVMO3 = (1U << 14);  ///< Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.621V Note: PVMO3 is cleared when PVM3 is disabled (PVME3 = 0). After enabling PVM3, the PVM3 output is valid after the PVM3 wake-up time.
        constexpr uint32_t PVMO4 = (1U << 15);  ///< Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 2.21V Note: PVMO4 is cleared when PVM4 is disabled (PVME4 = 0). After enabling PVM4, the PVM4 output is valid after the PVM4 wake-up time.
    }

    /// PWR_SCR Register bits
    namespace pwr_scr_bits {
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Clear wake-up flag 1 Setting this bit clears the WUF1 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Clear wake-up flag 2 Setting this bit clears the WUF2 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Clear wake-up flag 3 Setting this bit clears the WUF3 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Clear wake-up flag 4 Setting this bit clears the WUF4 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Clear wake-up flag 5 Setting this bit clears the WUF5 flag in the PWR_SR1 register.
        constexpr uint32_t CWUF7 = (1U << 6);  ///< Clear wake-up flag 7 Setting this bit clears the WUF7 flag in the PWR_SR1 register.
        constexpr uint32_t CSBF = (1U << 8);  ///< Clear standby flag Setting this bit clears the SBF flag in the PWR_SR1 register.
    }

    /// PWR_PUCRA Register bits
    namespace pwr_pucra_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
    }

    /// PWR_PDCRA Register bits
    namespace pwr_pdcra_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRB Register bits
    namespace pwr_pucrb_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PDCRB Register bits
    namespace pwr_pdcrb_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRC Register bits
    namespace pwr_pucrc_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
    }

    /// PWR_PDCRC Register bits
    namespace pwr_pdcrc_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRD Register bits
    namespace pwr_pucrd_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU10 = (1U << 10);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU11 = (1U << 11);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU12 = (1U << 12);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU13 = (1U << 13);  ///< Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
    }

    /// PWR_PDCRD Register bits
    namespace pwr_pdcrd_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD10 = (1U << 10);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD11 = (1U << 11);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD12 = (1U << 12);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD13 = (1U << 13);  ///< Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRE Register bits
    namespace pwr_pucre_bits {
        constexpr uint32_t PU3 = (1U << 3);  ///< Port E pull-up bit 3 When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU7 = (1U << 7);  ///< Port E pull-up bit y When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU8 = (1U << 8);  ///< Port E pull-up bit y When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU9 = (1U << 9);  ///< Port E pull-up bit y When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
    }

    /// PWR_PDCRE Register bits
    namespace pwr_pdcre_bits {
        constexpr uint32_t PD3 = (1U << 3);  ///< Port E pull-down bit 3 When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD7 = (1U << 7);  ///< Port E pull-down bit y When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD8 = (1U << 8);  ///< Port E pull-down bit y When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD9 = (1U << 9);  ///< Port E pull-down bit y When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
    }

    /// PWR_PUCRF Register bits
    namespace pwr_pucrf_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
        constexpr uint32_t PU3 = (1U << 3);  ///< Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
    }

    /// PWR_PDCRF Register bits
    namespace pwr_pdcrf_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
        constexpr uint32_t PD3 = (1U << 3);  ///< Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x40021000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t RCC_CR;  ///< Offset: 0x00 - Clock control register
        volatile uint32_t RCC_ICSCR;  ///< Offset: 0x04 - Internal clock sources calibration register
        volatile uint32_t RCC_CFGR;  ///< Offset: 0x08 - Clock configuration register
        volatile uint32_t RCC_PLLCFGR;  ///< Offset: 0x0C - PLL configuration register
        volatile uint32_t RCC_CIER;  ///< Offset: 0x18 - Clock interrupt enable register
        volatile uint32_t RCC_CIFR;  ///< Offset: 0x1C - Clock interrupt flag register
        volatile uint32_t RCC_CICR;  ///< Offset: 0x20 - Clock interrupt clear register
        volatile uint32_t RCC_AHBRSTR;  ///< Offset: 0x28 - AHB peripheral reset register
        volatile uint32_t RCC_IOPRSTR;  ///< Offset: 0x2C - I/O port reset register
        volatile uint32_t RCC_APBRSTR1;  ///< Offset: 0x38 - APB peripheral reset register 1
        volatile uint32_t RCC_APBRSTR2;  ///< Offset: 0x40 - APB peripheral reset register 2
        volatile uint32_t RCC_AHBENR;  ///< Offset: 0x48 - AHB peripheral clock enable register
        volatile uint32_t RCC_IOPENR;  ///< Offset: 0x4C - I/O port clock enable register
        volatile uint32_t RCC_DBGCFGR;  ///< Offset: 0x50 - Debug configuration register
        volatile uint32_t RCC_APBENR1;  ///< Offset: 0x58 - APB peripheral clock enable register 1
        volatile uint32_t RCC_APBENR2;  ///< Offset: 0x60 - APB peripheral clock enable register 2
        volatile uint32_t RCC_AHBSMENR;  ///< Offset: 0x68 - AHB peripheral clock enable in Sleep/Stop mode register
        volatile uint32_t RCC_IOPSMENR;  ///< Offset: 0x6C - I/O port in Sleep mode clock enable register
        volatile uint32_t RCC_APBSMENR1;  ///< Offset: 0x78 - APB peripheral clock enable in Sleep/Stop mode register 1
        volatile uint32_t RCC_APBSMENR2;  ///< Offset: 0x80 - APB peripheral clock enable in Sleep/Stop mode register 2
        volatile uint32_t RCC_CCIPR;  ///< Offset: 0x88 - Peripherals independent clock configuration register
        volatile uint32_t RCC_BDCR;  ///< Offset: 0x90 - RTC domain control register
        volatile uint32_t RCC_CSR;  ///< Offset: 0x94 - Control/status register
        volatile uint32_t RCC_CRRCR;  ///< Offset: 0x98 - RCC clock recovery RC register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);

    // Bit definitions
    /// RCC_CR Register bits
    namespace rcc_cr_bits {
        constexpr uint32_t MSION = (1U << 0);  ///< MSI clock enable This bit is set and cleared by software. Cleared by hardware to stop the MSI oscillator when entering Stop, Standby or Shutdown mode. Set by hardware to force the MSI oscillator ON when exiting Standby or Shutdown mode. Set by hardware to force the MSI oscillator ON when STOPWUCK=0 when exiting from Stop modes, or in case of a failure of the HSE oscillator Set by hardware when used directly or indirectly as system clock.
        constexpr uint32_t MSIRDY = (1U << 1);  ///< MSI clock ready flag This bit is set by hardware to indicate that the MSI oscillator is stable. Note: Once the MSION bit is cleared, MSIRDY goes low after 6 MSI clock cycles.
        constexpr uint32_t MSIPLLEN = (1U << 2);  ///< MSI clock PLL enable Set and cleared by software to enable/ disable the PLL part of the MSI clock source. MSIPLLEN must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware).There is a hardware protection to avoid enabling MSIPLLEN if LSE is not ready. This bit is cleared by hardware when LSE is disabled (LSEON = 0) or when the Clock Security System on LSE detects a LSE failure (refer to RCC_CSR register).
        constexpr uint32_t MSIRGSEL = (1U << 3);  ///< MSI clock range selection Set by software to select the MSI clock range with MSIRANGE[3:0]. Write 0 has no effect. After a standby or a reset MSIRGSEL is at 0 and the MSI range value is provided by MSISRANGE in CSR register.
        constexpr uint32_t MSIRANGE = (4 << 4);  ///< MSI clock ranges These bits are configured by software to choose the frequency range of MSI when MSIRGSEL is set.12 frequency ranges are available: others: not allowed (hardware write protection) Note: Warning: MSIRANGE can be modified when MSI is OFF (MSION=0) or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when MSI is ON and NOT ready (MSION=1 and MSIRDY=0)
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable Set and cleared by software. Cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby, or Shutdown mode. Forced by hardware to keep the HSI16 oscillator ON when it is used directly or indirectly as system clock (also when leaving Stop, Standby, or Shutdown modes, or in case of failure of the HSE oscillator used for system clock).
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 always enable for peripheral kernels. Set and cleared by software to force HSI16 ON even in Stop modes. The HSI16 can only feed USART1, USART2, CEC and I2C1 peripherals configured with HSI16 as kernel clock. Keeping the HSI16 ON in Stop mode allows avoiding to slow down the communication speed because of the HSI16 startup time. This bit has no effect on HSION value.
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag Set by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION. Note: Once the HSION bit is cleared, HSIRDY goes low after 6 HSI16 clock cycles.
        constexpr uint32_t HSIASFS = (1U << 11);  ///< HSI16 automatic start from Stop Set and cleared by software. When the system wake-up clock is MSI, this bit is used to wake up the HSI16 is parallel of the system wake-up.
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable Set and cleared by software. Cleared by hardware to stop the HSE oscillator when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag Set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after 6 HSE clock cycles.
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass Set and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device. The HSEBYP bit can be written only if the HSE oscillator is disabled.
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable Set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
        constexpr uint32_t PLLON = (1U << 24);  ///< PLL enable Set and cleared by software to enable the PLL. Cleared by hardware when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the PLL clock is used as the system clock.
        constexpr uint32_t PLLRDY = (1U << 25);  ///< PLL clock ready flag Set by hardware to indicate that the PLL is locked.
    }

    /// RCC_ICSCR Register bits
    namespace rcc_icscr_bits {
        constexpr uint32_t MSICAL = (8 << 0);  ///< MSI clock calibration These bits are initialized at startup with the factory-programmed MSI calibration trim value. When MSITRIM is written, MSICAL is updated with the sum of MSITRIM and the factory trim value.
        constexpr uint32_t MSITRIM = (8 << 8);  ///< MSI clock trimming These bits provide an additional user-programmable trimming value that is added to the MSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the MSI.
        constexpr uint32_t HSICAL = (8 << 16);  ///< HSI16 clock calibration These bits are initialized at startup with the factory-programmed HSI16 calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
        constexpr uint32_t HSITRIM = (7 << 24);  ///< HSI16 clock trimming These bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI16. The default value is 64 when added to the HSICAL value, trim the HSI16 to 161MHz 1 11%.
    }

    /// RCC_CFGR Register bits
    namespace rcc_cfgr_bits {
        constexpr uint32_t SW = (3 << 0);  ///< System clock switch This bitfield is controlled by software and hardware. The bitfield selects the clock for SYSCLK as follows: Others: Reserved The setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, Standby, or Shutdown mode, or when the setting is 001 (HSE selected) and HSE oscillator failure is detected.
        constexpr uint32_t SWS = (3 << 3);  ///< System clock switch status This bitfield is controlled by hardware to indicate the clock source used as system clock: Others: Reserved
        constexpr uint32_t HPRE = (4 << 8);  ///< AHB prescaler This bitfield is controlled by software. To produce HCLK clock, it sets the division factor of SYSCLK clock as follows: 0xxx: 1 Caution: Depending on the device voltage range, the software has to set correctly these bits to ensure that the system frequency does not exceed the maximum allowed frequency (for more details, refer to Section14.1.4: Dynamic voltage scaling management). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value has been taken into account.
        constexpr uint32_t PPRE = (3 << 12);  ///< APB prescaler This bitfield is controlled by software. To produce PCLK clock, it sets the division factor of HCLK clock as follows: 0xx: 1
        constexpr uint32_t STOPWUCK = (1U << 15);  ///< Wake-up from Stop and CSS backup clock selection Set and cleared by software to select the system clock used when exiting Stop mode. The selected clock is also used as emergency clock for the Clock Security System on HSE. Warning: STOPWUCK must not be modified when the Clock Security System is enabled by HSECSSON in RCC_CR register and the system clock is HSE (SWS=10) or a switch on HSE is requested (SW=10).
        constexpr uint32_t MCO2SEL = (4 << 16);  ///< Microcontroller clock output 2 clock selector This bitfield is controlled by software. It sets the clock selector for MCO2 output as follows: Others: Reserved Note: This clock output may have some truncated cycles at startup or during MCO2 clock source switching.
        constexpr uint32_t MCO2PRE = (4 << 20);  ///< Microcontroller clock output 2 prescaler This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO2 output as follows: ... Others: reserved It is highly recommended to set this field before the MCO2 output is enabled.
        constexpr uint32_t MCOSEL = (4 << 24);  ///< Microcontroller clock output clock selector This bitfield is controlled by software. It sets the clock selector for MCO output as follows: Others: Reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
        constexpr uint32_t MCOPRE = (4 << 28);  ///< Microcontroller clock output prescaler This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO output as follows: ... Others: reserved It is highly recommended to set this field before the MCO output is enabled.
    }

    /// RCC_PLLCFGR Register bits
    namespace rcc_pllcfgr_bits {
        constexpr uint32_t PLLSRC = (2 << 0);  ///< PLL input clock source This bit is controlled by software to select PLL clock source, as follows: The bitfield can be written only when the PLL is disabled. When the PLL is not used, selecting 00 allows saving power.
        constexpr uint32_t PLLM = (3 << 4);  ///< Division factor M of the PLL input clock divider This bit is controlled by software to divide the PLL input clock before the actual phase-locked loop, as follows: The bitfield can be written only when the PLL is disabled. Caution: The software must set these bits so that the PLL input frequency after the /M divider is between 2.66 and 161MHz.
        constexpr uint32_t PLLN = (7 << 8);  ///< PLL frequency multiplication factor N This bit is controlled by software to set the division factor of the f<sub>VCO</sub> feedback divider (that determines the PLL multiplication ratio) as follows: ... ... The bitfield can be written only when the PLL is disabled. Caution: The software must set these bits so that the VCO output frequency is between 96 and 3441MHz.
        constexpr uint32_t PLLPEN = (1U << 16);  ///< PLLPCLK clock output enable This bit is controlled by software to enable/disable the PLLPCLK clock output of the PLL: Disabling the PLLPCLK clock output, when not used, allows saving power.
        constexpr uint32_t PLLP = (5 << 17);  ///< PLL VCO division factor P for PLLPCLK clock output This bitfield is controlled by software. It sets the PLL VCO division factor P as follows: ... The bitfield can be written only when the PLL is disabled. Caution: The software must set this bitfield so as not to exceed 541MHz on this clock.
        constexpr uint32_t PLLQEN = (1U << 24);  ///< PLLQCLK clock output enable This bit is controlled by software to enable/disable the PLLQCLK clock output of the PLL: Disabling the PLLQCLK clock output, when not used, allows saving power.
        constexpr uint32_t PLLQ = (3 << 25);  ///< PLL VCO division factor Q for PLLQCLK clock output This bitfield is controlled by software. It sets the PLL VCO division factor Q as follows: The bitfield can be written only when the PLL is disabled. Caution: The software must set this bitfield so as not to exceed 541MHz on this clock.
        constexpr uint32_t PLLREN = (1U << 28);  ///< PLLRCLK clock output enable This bit is controlled by software to enable/disable the PLLRCLK clock output of the PLL: This bit cannot be written when PLLRCLK output of the PLL is selected for system clock. Disabling the PLLRCLK clock output, when not used, allows saving power.
        constexpr uint32_t PLLR = (3 << 29);  ///< PLL VCO division factor R for PLLRCLK clock output This bitfield is controlled by software. It sets the PLL VCO division factor R as follows: The bitfield can be written only when the PLL is disabled. The PLLRCLK clock can be selected as system clock. Caution: The software must set this bitfield so as not to exceed 122MHz on this clock.
    }

    /// RCC_CIER Register bits
    namespace rcc_cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:
        constexpr uint32_t MSIRDYIE = (1U << 2);  ///< MSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the MSI oscillator stabilization.
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI16 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization:
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:
        constexpr uint32_t PLLRDYIE = (1U << 5);  ///< PLL ready interrupt enable Set and cleared by software to enable/disable interrupt caused by PLL lock:
        constexpr uint32_t LSECSSIE = (1U << 9);  ///< LSE clock security system interrupt enable Set and cleared by software to enable/disable interrupt caused by the clock security system on LSE.
        constexpr uint32_t HSI48RDYIE = (1U << 10);  ///< HSI48 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the internal HSI48 oscillator.
    }

    /// RCC_CIFR Register bits
    namespace rcc_cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag Set by hardware when the LSI clock becomes stable and LSIRDYDIE is set. Cleared by software setting the LSIRDYC bit.
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag Set by hardware when the LSE clock becomes stable and LSERDYDIE is set. Cleared by software setting the LSERDYC bit.
        constexpr uint32_t MSIRDYF = (1U << 2);  ///< MSI ready interrupt flag Set by hardware when the MSI clock becomes stable and MSIRDYDIE is set. Cleared by software setting the MSIRDYC bit.
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI16 ready interrupt flag Set by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in a response to setting the HSION (refer to Clock control register (RCC_CR)). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. Cleared by software setting the HSIRDYC bit.
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag Set by hardware when the HSE clock becomes stable and HSERDYIE is set. Cleared by software setting the HSERDYC bit.
        constexpr uint32_t PLLRDYF = (1U << 5);  ///< PLL ready interrupt flag Set by hardware when the PLL locks and PLLRDYIE is set. Cleared by software setting the PLLRDYC bit.
        constexpr uint32_t CSSF = (1U << 8);  ///< HSE clock security system interrupt flag Set by hardware when a failure is detected in the HSE oscillator. Cleared by software setting the CSSC bit.
        constexpr uint32_t LSECSSF = (1U << 9);  ///< LSE clock security system interrupt flag Set by hardware when a failure is detected in the LSE oscillator. Cleared by software by setting the LSECSSC bit.
        constexpr uint32_t HSI48RDYF = (1U << 10);  ///< HSI48 ready interrupt flag Set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set in a response to setting the HSI48ON (refer to RCC clock recovery RC register (RCC_CRRCR)). Cleared by software setting the HSI48RDYC bit.
    }

    /// RCC_CICR Register bits
    namespace rcc_cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear This bit is set by software to clear the LSIRDYF flag.
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear This bit is set by software to clear the LSERDYF flag.
        constexpr uint32_t MSIRDYC = (1U << 2);  ///< MSI ready interrupt clear This bit is set by software to clear the MSIRDYF flag.
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI16 ready interrupt clear This bit is set software to clear the HSIRDYF flag.
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear This bit is set by software to clear the HSERDYF flag.
        constexpr uint32_t PLLRDYC = (1U << 5);  ///< PLL ready interrupt clear This bit is set by software to clear the PLLRDYF flag.
        constexpr uint32_t CSSC = (1U << 8);  ///< Clock security system interrupt clear This bit is set by software to clear the HSECSSF flag.
        constexpr uint32_t LSECSSC = (1U << 9);  ///< LSE Clock security system interrupt clear This bit is set by software to clear the LSECSSF flag.
        constexpr uint32_t HSI48RDYC = (1U << 10);  ///< HSI48 oscillator ready interrupt clear This bit is set by software to clear the HSI48RDYF flag.
    }

    /// RCC_AHBRSTR Register bits
    namespace rcc_ahbrstr_bits {
        constexpr uint32_t DMA1RST = (1U << 0);  ///< DMA1 and DMAMUX reset Set and cleared by software.
        constexpr uint32_t DMA2RST = (1U << 1);  ///< DMA2 and DMAMUX reset Set and cleared by software.
        constexpr uint32_t FLASHRST = (1U << 8);  ///< Flash memory interface reset Set and cleared by software. This bit can only be set when the flash memory is in power down mode.
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset Set and cleared by software.
        constexpr uint32_t RNGRST = (1U << 18);  ///< Random number generator reset Set and cleared by software.
        constexpr uint32_t TSCRST = (1U << 24);  ///< Touch sensing controller reset Set and cleared by software.
    }

    /// RCC_IOPRSTR Register bits
    namespace rcc_ioprstr_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< I/O port A reset This bit is set and cleared by software.
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< I/O port B reset This bit is set and cleared by software.
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< I/O port C reset This bit is set and cleared by software.
        constexpr uint32_t GPIODRST = (1U << 3);  ///< I/O port D reset This bit is set and cleared by software.
        constexpr uint32_t GPIOERST = (1U << 4);  ///< I/O port E reset This bit is set and cleared by software.
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< I/O port F reset This bit is set and cleared by software.
    }

    /// RCC_APBRSTR1 Register bits
    namespace rcc_apbrstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 timer reset Set and cleared by software.
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 timer reset Set and cleared by software.
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 timer reset Set and cleared by software.
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 timer reset Set and cleared by software.
        constexpr uint32_t LPUART2RST = (1U << 7);  ///< LPUART2 reset Set and cleared by software.
        constexpr uint32_t LCDRST = (1U << 9);  ///< LCD reset<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t USBRST = (1U << 13);  ///< USB reset<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset Set and cleared by software.
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset Set and cleared by software.
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset Set and cleared by software.
        constexpr uint32_t USART4RST = (1U << 19);  ///< USART4 reset Set and cleared by software.
        constexpr uint32_t LPUART1RST = (1U << 20);  ///< LPUART1 reset Set and cleared by software.
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset Set and cleared by software.
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset Set and cleared by software.
        constexpr uint32_t I2C3RST = (1U << 23);  ///< I2C3 reset Set and cleared by software.
        constexpr uint32_t OPAMPRST = (1U << 24);  ///< OPAMP reset Set and cleared by software.
        constexpr uint32_t PWRRST = (1U << 28);  ///< Power interface reset Set and cleared by software.
        constexpr uint32_t DAC1RST = (1U << 29);  ///< DAC1 interface reset Set and cleared by software.
        constexpr uint32_t LPTIM2RST = (1U << 30);  ///< Low Power Timer 2 reset Set and cleared by software.
        constexpr uint32_t LPTIM1RST = (1U << 31);  ///< Low Power Timer 1 reset Set and cleared by software.
    }

    /// RCC_APBRSTR2 Register bits
    namespace rcc_apbrstr2_bits {
        constexpr uint32_t SYSCFGRST = (1U << 0);  ///< SYSCFG, COMP and VREFBUF reset Set and cleared by software.
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 timer reset Set and cleared by software.
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset Set and cleared by software.
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset Set and cleared by software.
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 timer reset Set and cleared by software.
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 timer reset Set and cleared by software.
        constexpr uint32_t ADCRST = (1U << 20);  ///< ADC reset Set and cleared by software.
    }

    /// RCC_AHBENR Register bits
    namespace rcc_ahbenr_bits {
        constexpr uint32_t DMA1EN = (1U << 0);  ///< DMA1 and DMAMUX clock enable Set and cleared by software. DMAMUX is enabled as long as at least one DMA peripheral is enabled.
        constexpr uint32_t DMA2EN = (1U << 1);  ///< DMA2 and DMAMUX clock enable Set and cleared by software. DMAMUX is enabled as long as at least one DMA peripheral is enabled.
        constexpr uint32_t FLASHEN = (1U << 8);  ///< Flash memory interface clock enable Set and cleared by software. This bit can only be cleared when the flash memory is in power down mode.
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable Set and cleared by software.
        constexpr uint32_t RNGEN = (1U << 18);  ///< Random number generator clock enable Set and cleared by software.
        constexpr uint32_t TSCEN = (1U << 24);  ///< Touch sensing controller clock enable Set and cleared by software.
    }

    /// RCC_IOPENR Register bits
    namespace rcc_iopenr_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< I/O port A clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< I/O port B clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< I/O port C clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIODEN = (1U << 3);  ///< I/O port D clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< I/O port E clock enable<sup>(1)</sup> This bit is set and cleared by software.
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< I/O port F clock enable This bit is set and cleared by software.
    }

    /// RCC_DBGCFGR Register bits
    namespace rcc_dbgcfgr_bits {
        constexpr uint32_t DBGEN = (1U << 0);  ///< Debug support clock enable Set and cleared by software.
        constexpr uint32_t DBGRST = (1U << 1);  ///< Debug support reset Set and cleared by software.
    }

    /// RCC_APBENR1 Register bits
    namespace rcc_apbenr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 timer clock enable Set and cleared by software.
        constexpr uint32_t LPUART2EN = (1U << 7);  ///< LPUART2 clock enable Set and cleared by software.
        constexpr uint32_t LCDEN = (1U << 9);  ///< LCD clock enable<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t RTCAPBEN = (1U << 10);  ///< RTC APB clock enable Set and cleared by software.
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable Set by software to enable the window watchdog clock. Cleared by hardware system reset This bit can also be set by hardware if the WWDG_SW option bit is 0.
        constexpr uint32_t USBEN = (1U << 13);  ///< USB clock enable<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable Set and cleared by software.
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable Set and cleared by software.
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable Set and cleared by software.
        constexpr uint32_t USART4EN = (1U << 19);  ///< USART4 clock enable Set and cleared by software.
        constexpr uint32_t LPUART1EN = (1U << 20);  ///< LPUART1 clock enable Set and cleared by software.
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable Set and cleared by software.
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable Set and cleared by software.
        constexpr uint32_t I2C3EN = (1U << 23);  ///< I2C3 clock enable Set and cleared by software.
        constexpr uint32_t OPAMPEN = (1U << 24);  ///< OPAMP clock enable Set and cleared by software.
        constexpr uint32_t PWREN = (1U << 28);  ///< Power interface clock enable Set and cleared by software.
        constexpr uint32_t DAC1EN = (1U << 29);  ///< DAC1 interface clock enable Set and cleared by software.
        constexpr uint32_t LPTIM2EN = (1U << 30);  ///< LPTIM2 clock enable Set and cleared by software.
        constexpr uint32_t LPTIM1EN = (1U << 31);  ///< LPTIM1 clock enable Set and cleared by software.
    }

    /// RCC_APBENR2 Register bits
    namespace rcc_apbenr2_bits {
        constexpr uint32_t SYSCFGEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable Set and cleared by software.
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 timer clock enable Set and cleared by software.
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable Set and cleared by software.
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1 clock enable Set and cleared by software.
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 timer clock enable Set and cleared by software.
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 timer clock enable Set and cleared by software.
        constexpr uint32_t ADCEN = (1U << 20);  ///< ADC clock enable Set and cleared by software.
    }

    /// RCC_AHBSMENR Register bits
    namespace rcc_ahbsmenr_bits {
        constexpr uint32_t DMA1SMEN = (1U << 0);  ///< DMA1 and DMAMUX clock enable during Sleep mode Set and cleared by software. Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
        constexpr uint32_t DMA2SMEN = (1U << 1);  ///< DMA2 and DMAMUX clock enable during Sleep mode Set and cleared by software. Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< Flash memory interface clock enable during Sleep mode Set and cleared by software. This bit can be activated only when the flash memory is in power down mode.
        constexpr uint32_t SRAMSMEN = (1U << 9);  ///< SRAM clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t RNGSMEN = (1U << 18);  ///< RNG clock enable during Sleep and Stop mode Set and cleared by software.
        constexpr uint32_t TSCSMEN = (1U << 24);  ///< TSC clock enable during Sleep and Stop mode Set and cleared by software.
    }

    /// RCC_IOPSMENR Register bits
    namespace rcc_iopsmenr_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< I/O port A clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< I/O port B clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< I/O port C clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< I/O port D clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< I/O port E clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< I/O port F clock enable during Sleep mode Set and cleared by software.
    }

    /// RCC_APBSMENR1 Register bits
    namespace rcc_apbsmenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t LPUART2SMEN = (1U << 7);  ///< LPUART2 clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t LCDSMEN = (1U << 9);  ///< LCD clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t RTCAPBSMEN = (1U << 10);  ///< RTC APB clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< WWDG clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t USBSMEN = (1U << 13);  ///< USB clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t USART4SMEN = (1U << 19);  ///< USART4 clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t LPUART1SMEN = (1U << 20);  ///< LPUART1 clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t I2C3SMEN = (1U << 23);  ///< I2C3 clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t OPAMPSMEN = (1U << 24);  ///< OPAMP clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t PWRSMEN = (1U << 28);  ///< Power interface clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t DAC1SMEN = (1U << 29);  ///< DAC1 interface clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t LPTIM2SMEN = (1U << 30);  ///< Low Power Timer 2 clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t LPTIM1SMEN = (1U << 31);  ///< Low Power Timer 1 clock enable during Sleep and Stop modes Set and cleared by software.
    }

    /// RCC_APBSMENR2 Register bits
    namespace rcc_apbsmenr2_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 0);  ///< SYSCFG, COMP and VREFBUF clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep and Stop modes Set and cleared by software.
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 timer clock enable during Sleep mode Set and cleared by software.
        constexpr uint32_t ADCSMEN = (1U << 20);  ///< ADC clock enable during Sleep mode Set and cleared by software.
    }

    /// RCC_CCIPR Register bits
    namespace rcc_ccipr_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 clock source selection This bitfield is controlled by software to select USART1 clock source as follows:
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 clock source selection This bitfield is controlled by software to select USART2 clock source as follows:
        constexpr uint32_t LPUART2SEL = (2 << 8);  ///< LPUART2 clock source selection This bitfield is controlled by software to select LPUART2 clock source as follows:
        constexpr uint32_t LPUART1SEL = (2 << 10);  ///< LPUART1 clock source selection This bitfield is controlled by software to select LPUART1 clock source as follows:
        constexpr uint32_t I2C1SEL = (2 << 12);  ///< I2C1 clock source selection This bitfield is controlled by software to select I2C1 clock source as follows:
        constexpr uint32_t I2C3SEL = (2 << 16);  ///< I2C3 clock source selection This bitfield is controlled by software to select I2C3 clock source as follows:
        constexpr uint32_t LPTIM1SEL = (2 << 18);  ///< LPTIM1 clock source selection This bitfield is controlled by software to select LPTIM1 clock source as follows:
        constexpr uint32_t LPTIM2SEL = (2 << 20);  ///< LPTIM2 clock source selection This bitfield is controlled by software to select LPTIM2 clock source as follows:
        constexpr uint32_t TIM1SEL = (1U << 24);  ///< TIM1 clock source selection This bit is set and cleared by software. It selects TIM1 clock source as follows:
        constexpr uint32_t TIM15SEL = (1U << 25);  ///< TIM15 clock source selection This bit is set and cleared by software. It selects TIM15 clock source as follows:
        constexpr uint32_t CLK48SEL = (2 << 26);  ///< 481MHz clock source selection This bitfield is controlled by software to select the 481MHz clock source used by the USB FS and the RNG:
        constexpr uint32_t ADCSEL = (2 << 28);  ///< ADCs clock source selection This bitfield is controlled by software to select the clock source for ADC:
    }

    /// RCC_BDCR Register bits
    namespace rcc_bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable Set and cleared by software to enable LSE oscillator:
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready Set and cleared by hardware to indicate when the external 321kHz oscillator is ready (stable): After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass Set and cleared by software to bypass the LSE oscillator (in debug mode). This bit can be written only when the external 321kHz oscillator is disabled (LSEON=0 and LSERDY=0).
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability Set by software to select the LSE oscillator drive capability as follows: Applicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode.
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable Set by software to enable the clock security system on LSE (321kHz) oscillator as follows: LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD =1). In that case the software must disable the LSECSSON bit.
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure Detection Set by hardware to indicate when a failure is detected by the clock security system on the external 321kHz oscillator (LSE):
        constexpr uint32_t LSESYSEN = (1U << 7);  ///< LSE clock enable for system usage This bit must be set by software to enable the LSE clock for a system usage.
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC clock source selection Set by software to select the clock source for the RTC as follows: Once the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The BDRST bit can be used to reset this bitfield to 00.
        constexpr uint32_t LSESYSRDY = (1U << 11);  ///< LSE clock ready for system usage This flag is set by hardware to indicate that the LSE clock is ready for being used by the system (see LSESYSEN bit). This flag is set when LSE clock is ready (LSEON1=11 and LSERDY1=11) and two LSE clock cycles after that LSESYSEN is set. Cleared by hardware to indicate that the LSE clock is not ready to be used by the system.
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC clock enable Set and cleared by software. The bit enables clock to RTC and TAMP.
        constexpr uint32_t BDRST = (1U << 16);  ///< RTC domain software reset Set and cleared by software to reset the RTC domain:
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable Set and cleared by software.
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection Set and cleared by software to select the low-speed output clock:
    }

    /// RCC_CSR Register bits
    namespace rcc_csr_bits {
        constexpr uint32_t LSION = (1U << 0);  ///< LSI oscillator enable Set and cleared by software to enable/disable the LSI oscillator:
        constexpr uint32_t LSIRDY = (1U << 1);  ///< LSI oscillator ready Set and cleared by hardware to indicate when the LSI oscillator is ready (stable): After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
        constexpr uint32_t LSIPREDIV = (1U << 2);  ///< Internal low-speed oscillator pre-divided by 128 Set and reset by hardware to indicate when the low-speed internal RC oscillator has to be divided by 128. The software has to switch off the LSI before changing this bit.
        constexpr uint32_t MSISRANGE = (4 << 8);  ///< MSI range after Standby mode Set by software to chose the MSI frequency at startup. This range is used after exiting Standby mode until MSIRGSEL is set. After a pad or a power-on reset, the range is always 41MHz. MSISRANGE[3:0] can be written only when MSIRGSEL1=11. Others: Reserved Note: Changing the MSISRANGE[3:0] does not change the current MSI frequency.
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flags Set by software to clear the reset flags.
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option byte loader reset flag Set by hardware when a reset from the Option byte loading occurs. Cleared by setting the RMVF bit.
        constexpr uint32_t PINRSTF = (1U << 26);  ///< Pin reset flag Set by hardware when a reset from the NRST pin occurs. Cleared by setting the RMVF bit.
        constexpr uint32_t PWRRSTF = (1U << 27);  ///< BOR or POR/PDR flag Set by hardware when a BOR or POR/PDR occurs. Cleared by setting the RMVF bit.
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag Set by hardware when a software reset occurs. Cleared by setting the RMVF bit.
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent window watchdog reset flag Set by hardware when an independent watchdog reset domain occurs. Cleared by setting the RMVF bit.
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag Set by hardware when a window watchdog reset occurs. Cleared by setting the RMVF bit.
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag Set by hardware when a reset occurs due to illegal Stop, Standby, or Shutdown mode entry. Cleared by setting the RMVF bit. This operates only if nRST_STOP, nRST_STDBY or nRST_SHDW option bits are cleared.
    }

    /// RCC_CRRCR Register bits
    namespace rcc_crrcr_bits {
        constexpr uint32_t HSI48ON = (1U << 0);  ///< HSI48 RC oscillator enable<sup>(1)</sup>
        constexpr uint32_t HSI48RDY = (1U << 1);  ///< HSI48 clock ready flag<sup>(1)</sup> The flag is set when the HSI48 clock is ready for use.
        constexpr uint32_t HSI48CAL = (9 << 7);  ///< HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40025000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t RNG_CR;  ///< Offset: 0x00 - RNG control register
        volatile uint32_t RNG_SR;  ///< Offset: 0x04 - RNG status register
        volatile uint32_t RNG_DR;  ///< Offset: 0x08 - RNG data register
        volatile uint32_t RNG_HTCR;  ///< Offset: 0x10 - RNG health test control register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// RNG_CR Register bits
    namespace rng_cr_bits {
        constexpr uint32_t RNGEN = (1U << 2);  ///< True random number generator enable
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt enable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection The clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, that is to enable or disable CED, the RNG must be disabled. Writing this bit is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
        constexpr uint32_t ARDIS = (1U << 7);  ///< Auto reset disable When auto-reset is enabled the application still need to clear the SEIS bit after a noise source error. Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
        constexpr uint32_t RNG_CONFIG3 = (4 << 8);  ///< RNG configuration 3 Reserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details. If the NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG.
        constexpr uint32_t NISTC = (1U << 12);  ///< NIST custom two conditioning loops are performed and 256 bits of noise source are used. Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
        constexpr uint32_t RNG_CONFIG2 = (3 << 13);  ///< RNG configuration 2 Reserved to the RNG configuration (bitfield 2). Bit 13 can be set when RNG power consumption is critical. See Section120.3.8: RNG low-power use. Refer to the RNG_CONFIG1 bitfield for details.
        constexpr uint32_t CLKDIV = (4 << 16);  ///< Clock divider factor This value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN1=10). ... Writing these bits is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
        constexpr uint32_t RNG_CONFIG1 = (6 << 20);  ///< RNG configuration 1 Reserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section120.6: RNG entropy source validation. Writing any bit of RNG_CONFIG1 is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
        constexpr uint32_t CONDRST = (1U << 30);  ///< Conditioning soft reset Write 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_HTCR are not changed by CONDRST. This bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written. When CONDRST is set to 0 by the software, its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles.
        constexpr uint32_t CONFIGLOCK = (1U << 31);  ///< RNG Config lock This bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset.
    }

    /// RNG_SR Register bits
    namespace rng_sr_bits {
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready Once the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated. Note: The DRDY bit can rise when the peripheral is disabled (RNGEN1=10 in the RNG_CR register). If IE=1 in the RNG_CR register, an interrupt is generated when DRDY1=11.
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status Note: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0.
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status Runtime repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10) Startup or continuous adaptive proportion test on noise source failed. Startup post-processing/conditioning sanity check failed.
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect. An interrupt is pending if IE = 1 in the RNG_CR register.
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect. An interrupt is pending if IE = 1 in the RNG_CR register.
    }

    /// RNG_DR Register bits
    namespace rng_dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data 32-bit random data, which are valid when DRDY1=11. When DRDY1=10, the RNDATA value is1zero. When DRDY is set, it is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event).
    }

    /// RNG_HTCR Register bits
    namespace rng_htcr_bits {
        constexpr uint32_t HTCFG = (32 << 0);  ///< health test configuration This configuration is used by RNG to configure the health tests. See Section120.6: RNG entropy source validation for the recommended value. Note: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written.
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40002800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_TR;  ///< Offset: 0x00 - RTC time register
        volatile uint32_t RTC_DR;  ///< Offset: 0x04 - RTC date register
        volatile uint32_t RTC_SSR;  ///< Offset: 0x08 - RTC subsecond register
        volatile uint32_t RTC_ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t RTC_PRER;  ///< Offset: 0x10 - RTC prescaler register
        volatile uint32_t RTC_WUTR;  ///< Offset: 0x14 - RTC wake-up timer register
        volatile uint32_t RTC_CR;  ///< Offset: 0x18 - RTC control register
        volatile uint32_t RTC_WPR;  ///< Offset: 0x24 - RTC write protection register
        volatile uint32_t RTC_CALR;  ///< Offset: 0x28 - RTC calibration register
        volatile uint32_t RTC_SHIFTR;  ///< Offset: 0x2C - RTC shift control register
        volatile uint32_t RTC_TSTR;  ///< Offset: 0x30 - RTC timestamp time register
        volatile uint32_t RTC_TSDR;  ///< Offset: 0x34 - RTC timestamp date register
        volatile uint32_t RTC_TSSSR;  ///< Offset: 0x38 - RTC timestamp subsecond register
        volatile uint32_t RTC_ALRMAR;  ///< Offset: 0x40 - RTC alarm A register
        volatile uint32_t RTC_ALRMASSR;  ///< Offset: 0x44 - RTC alarm A subsecond register
        volatile uint32_t RTC_ALRMBR;  ///< Offset: 0x48 - RTC alarm B register
        volatile uint32_t RTC_ALRMBSSR;  ///< Offset: 0x4C - RTC alarm B subsecond register
        volatile uint32_t RTC_SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t RTC_MISR;  ///< Offset: 0x54 - RTC masked interrupt status register
        volatile uint32_t RTC_SCR;  ///< Offset: 0x5C - RTC status clear register
        volatile uint32_t RTC_ALRABINR;  ///< Offset: 0x70 - RTC alarm A binary mode register
        volatile uint32_t RTC_ALRBBINR;  ///< Offset: 0x74 - RTC alarm B binary mode register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// RTC_TR Register bits
    namespace rtc_tr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_DR Register bits
    namespace rtc_dr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units ...
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
    }

    /// RTC_SSR Register bits
    namespace rtc_ssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous binary counter SS[31:16]: Synchronous binary counter MSB values When Binary or Mixed mode is selected (BIN = 01 or 10 or 11): SS[31:16] are the 16 MSB of the SS[31:0] free-running down-counter. When BCD mode is selected (BIN=00): SS[31:16] are forced by hardware to 0x0000. SS[15:0]: Subsecond value/synchronous binary counter LSB values When Binary mode is selected (BIN = 01 or 10 or 11): SS[15:0] are the 16 LSB of the SS[31:0] free-running down-counter. When BCD mode is selected (BIN=00): SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    }

    /// RTC_ICSR Register bits
    namespace rtc_icsr_bits {
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wake-up timer write flag This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t BIN = (2 << 8);  ///< Binary mode
        constexpr uint32_t BCDU = (3 << 10);  ///< BCD update (BIN = 10 or 11) In mixed mode when both BCD calendar and binary extended counter are used (BIN = 10 or 11), the calendar second is incremented using the SSR Least Significant Bits.
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
    }

    /// RTC_PRER Register bits
    namespace rtc_prer_bits {
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    }

    /// RTC_WUTR Register bits
    namespace rtc_wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wake-up auto-reload value bits When the wake-up timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]1+11) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register. When WUCKSEL[2] = 1, the wake-up timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs between WUT and (WUT + 2) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.
        constexpr uint32_t WUTOCLR = (16 << 16);  ///< Wake-up auto-reload output clear value When WUTOCLR[15:0] is different from 0x0000, WUTF is set by hardware when the auto-reload down-counter reaches 0 and is cleared by hardware when the auto-reload downcounter reaches WUTOCLR[15:0]. When WUTOCLR[15:0] = 0x0000, WUTF is set by hardware when the WUT down-counter reaches 0 and is cleared by software.
    }

    /// RTC_CR Register bits
    namespace rtc_cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< ck_wut wake-up clock selection 10x: ck_spre (usually 11Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. 11x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. Furthermore, 2<sup>16</sup> is added to the WUT counter value.
        constexpr uint32_t TSEDGE = (1U << 3);  ///< Timestamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
        constexpr uint32_t REFCKON = (1U << 4);  ///< RTC_REFIN reference clock detection enable (50 or 601Hz) Note: BIN must be 0x00 and PREDIV_S must be 0x00FF.
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
        constexpr uint32_t FMT = (1U << 6);  ///< Hour format
        constexpr uint32_t SSRUIE = (1U << 7);  ///< SSR underflow interrupt enable
        constexpr uint32_t ALRAE = (1U << 8);  ///< Alarm A enable
        constexpr uint32_t ALRBE = (1U << 9);  ///< Alarm B enable
        constexpr uint32_t WUTE = (1U << 10);  ///< Wake-up timer enable Note: When the wake-up timer is disabled, wait for WUTWF = 1 before enabling it again.
        constexpr uint32_t TSE = (1U << 11);  ///< timestamp enable
        constexpr uint32_t ALRAIE = (1U << 12);  ///< Alarm A interrupt enable
        constexpr uint32_t ALRBIE = (1U << 13);  ///< Alarm B interrupt enable
        constexpr uint32_t WUTIE = (1U << 14);  ///< Wake-up timer interrupt enable
        constexpr uint32_t TSIE = (1U << 15);  ///< Timestamp interrupt enable
        constexpr uint32_t ADD1H = (1U << 16);  ///< Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
        constexpr uint32_t SUB1H = (1U << 17);  ///< Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
        constexpr uint32_t BKP = (1U << 18);  ///< Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
        constexpr uint32_t COSEL = (1U << 19);  ///< Calibration output selection When COE = 1, this bit selects which signal is output on CALIB. These frequencies are valid for RTCCLK at 32.7681kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section128.3.16: Calibration clock output.
        constexpr uint32_t POL = (1U << 20);  ///< Output polarity This bit is used to configure the polarity of TAMPALRM output.
        constexpr uint32_t OSEL = (2 << 21);  ///< Output selection These bits are used to select the flag to be routed to TAMPALRM output.
        constexpr uint32_t COE = (1U << 23);  ///< Calibration output enable This bit enables the CALIB output
        constexpr uint32_t ITSE = (1U << 24);  ///< timestamp on internal event enable
        constexpr uint32_t TAMPTS = (1U << 25);  ///< Activate timestamp on tamper detection event TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set up to 3 ck_apre cycles after the tamper flags. Note: TAMPTS must be cleared before entering RTC initialization mode.
        constexpr uint32_t TAMPOE = (1U << 26);  ///< Tamper detection output enable on TAMPALRM
        constexpr uint32_t ALRAFCLR = (1U << 27);  ///< Alarm A flag automatic clear
        constexpr uint32_t ALRBFCLR = (1U << 28);  ///< Alarm B flag automatic clear
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM pull-up enable
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM output type
        constexpr uint32_t OUT2EN = (1U << 31);  ///< RTC_OUT2 output enable
    }

    /// RTC_WPR Register bits
    namespace rtc_wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection.
    }

    /// RTC_CALR Register bits
    namespace rtc_calr_bits {
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus The frequency of the calendar is reduced by masking CALM out of 2<sup>20</sup> RTCCLK pulses (321seconds if the input frequency is 327681Hz). This decreases the frequency of the calendar with a resolution of 0.95371ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section128.3.14: RTC smooth digital calibration on page1733.
        constexpr uint32_t LPCAL = (1U << 12);  ///< RTC low-power mode
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1. Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section128.3.14: RTC smooth digital calibration.
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section128.3.14: RTC smooth digital calibration.
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.51ppm.
    }

    /// RTC_SHIFTR Register bits
    namespace rtc_shiftr_bits {
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). In mixed BCD-binary mode (BIN=10 or 11), the SUBFS[14:BCDU+8] must be written with 0. Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    }

    /// RTC_TSTR Register bits
    namespace rtc_tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format.
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format.
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format.
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format.
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// RTC_TSDR Register bits
    namespace rtc_tsdr_bits {
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
    }

    /// RTC_TSSSR Register bits
    namespace rtc_tsssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Subsecond value/synchronous binary counter values SS[31:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    }

    /// RTC_ALRMAR Register bits
    namespace rtc_alrmar_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format.
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format.
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
    }

    /// RTC_ALRMASSR Register bits
    namespace rtc_alrmassr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Subseconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. This field is the mirror of SS[14:0] in the RTC_ALRABINR, and so can also be read or written through RTC_ALRABINR.
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit ... From 32 to 63: All 32 SS bits are compared and must match to activate alarm. Note: In BCD mode (BIN=00) the overflow bits of the synchronous counter (bits 31:15) are never compared. These bits can be different from 0 only after a shift operation.
        constexpr uint32_t SSCLR = (1U << 31);  ///< Clear synchronous counter on alarm (Binary mode only) Note: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11).
    }

    /// RTC_ALRMBR Register bits
    namespace rtc_alrmbr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
    }

    /// RTC_ALRMBSSR Register bits
    namespace rtc_alrmbssr_bits {
        constexpr uint32_t SS = (15 << 0);  ///< Subseconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. This field is the mirror of SS[14:0] in the RTC_ALRBBINR, and so can also be read or written through RTC_ALRBBINR.
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit ... From 32 to 63: All 32 SS bits are compared and must match to activate alarm. Note: In BCD mode (BIN=00)The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
        constexpr uint32_t SSCLR = (1U << 31);  ///< Clear synchronous counter on alarm (Binary mode only) Note: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11).
    }

    /// RTC_SR Register bits
    namespace rtc_sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
        constexpr uint32_t ALRBF = (1U << 1);  ///< Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
        constexpr uint32_t WUTF = (1U << 2);  ///< Wake-up timer flag This flag is set by hardware when the wake-up auto-reload counter reaches 0. If WUTOCLR[15:0] is different from 0x0000, WUTF is cleared by hardware when the wake-up auto-reload counter reaches WUTOCLR value. If WUTOCLR[15:0] is 0x0000, WUTF must be cleared by software. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSF = (1U << 3);  ///< Timestamp flag This flag is set by hardware when a timestamp event occurs. If ITSF flag is set, TSF must be cleared together with ITSF. Note: TSF is not set if TAMPTS1=11 and the tamper flag is read during the 3 ck_apre cycles following tamper event. Refer to Timestamp on tamper event for more details.
        constexpr uint32_t TSOVF = (1U << 4);  ///< Timestamp overflow flag This flag is set by hardware when a timestamp event occurs while TSF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSF = (1U << 5);  ///< Internal timestamp flag This flag is set by hardware when a timestamp on the internal event occurs.
        constexpr uint32_t SSRUF = (1U << 6);  ///< SSR underflow flag This flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1.
    }

    /// RTC_MISR Register bits
    namespace rtc_misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< Alarm A masked flag This flag is set by hardware when the alarm A interrupt occurs.
        constexpr uint32_t ALRBMF = (1U << 1);  ///< Alarm B masked flag This flag is set by hardware when the alarm B interrupt occurs.
        constexpr uint32_t WUTMF = (1U << 2);  ///< Wake-up timer masked flag This flag is set by hardware when the wake-up timer interrupt occurs. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
        constexpr uint32_t TSMF = (1U << 3);  ///< Timestamp masked flag This flag is set by hardware when a timestamp interrupt occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
        constexpr uint32_t TSOVMF = (1U << 4);  ///< Timestamp overflow masked flag This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t ITSMF = (1U << 5);  ///< Internal timestamp masked flag This flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSR underflow masked flag This flag is set by hardware when the SSR underflow interrupt occurs.
    }

    /// RTC_SCR Register bits
    namespace rtc_scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< Clear alarm A flag Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.
        constexpr uint32_t CALRBF = (1U << 1);  ///< Clear alarm B flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
        constexpr uint32_t CWUTF = (1U << 2);  ///< Clear wake-up timer flag Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
        constexpr uint32_t CTSF = (1U << 3);  ///< Clear timestamp flag Writing 1 in this bit clears the TSF bit in the RTC_SR register. If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
        constexpr uint32_t CTSOVF = (1U << 4);  ///< Clear timestamp overflow flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        constexpr uint32_t CITSF = (1U << 5);  ///< Clear internal timestamp flag Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
        constexpr uint32_t CSSRUF = (1U << 6);  ///< Clear SSR underflow flag Writing 1 in this bit clears the SSRUF in the RTC_SR register.
    }

    /// RTC_ALRABINR Register bits
    namespace rtc_alrabinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode This value is compared with the contents of the synchronous counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. SS[14:0] is the mirror of SS[14:0] in the RTC_ALRMASSRR, and so can also be read or written through RTC_ALRMASSR.
    }

    /// RTC_ALRBBINR Register bits
    namespace rtc_alrbbinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode This value is compared with the contents of the synchronous counter to determine if Alarm Bis to be activated. Only bits 0 up MASKSS-1 are compared. SS[14:0] is the mirror of SS[14:0] in the RTC_ALRMBSSRR, and so can also be read or written through RTC_ALRMBSSR.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CR1;  ///< Offset: 0x00 - SPI control register 1
        volatile uint32_t SPI_CR2;  ///< Offset: 0x04 - SPI control register 2
        volatile uint32_t SPI_SR;  ///< Offset: 0x08 - SPI status register
        volatile uint32_t SPI_DR;  ///< Offset: 0x0C - SPI data register
        volatile uint32_t SPI_CRCPR;  ///< Offset: 0x10 - SPI CRC polynomial register
        volatile uint32_t SPI_RXCRCR;  ///< Offset: 0x14 - SPI Rx CRC register
        volatile uint32_t SPI_TXCRCR;  ///< Offset: 0x18 - SPI Tx CRC register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// SPI_CR1 Register bits
    namespace spi_cr1_bits {
        constexpr uint32_t CPHA = (1U << 0);  ///< Clock phase Note: This bit should not be changed when communication is ongoing. Note: This bit is not used in SPI TI mode except the case when CRC is applied at TI mode.
        constexpr uint32_t CPOL = (1U << 1);  ///< Clock polarity Note: This bit should not be changed when communication is ongoing. Note: This bit is not used in SPI TI mode except the case when CRC is applied at TI mode.
        constexpr uint32_t MSTR = (1U << 2);  ///< Master selection Note: This bit should not be changed when communication is ongoing.
        constexpr uint32_t BR = (3 << 3);  ///< Baud rate control Note: These bits should not be changed when communication is ongoing.
        constexpr uint32_t SPE = (1U << 6);  ///< SPI enable Note: When disabling the SPI, follow the procedure described in Procedure for disabling the SPI on page1954.
        constexpr uint32_t LSBFIRST = (1U << 7);  ///< Frame format Note: 1. This bit should not be changed when communication is ongoing. Note: 2. This bit is not used in SPI TI mode.
        constexpr uint32_t SSI = (1U << 8);  ///< Internal slave select This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored. Note: This bit is not used in SPI TI mode.
        constexpr uint32_t SSM = (1U << 9);  ///< Software slave management When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit. Note: This bit is not used in SPI TI mode.
        constexpr uint32_t RXONLY = (1U << 10);  ///< Receive only mode enabled. This bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted.
        constexpr uint32_t CRCL = (1U << 11);  ///< CRC length This bit is set and cleared by software to select the CRC length. Note: This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
        constexpr uint32_t CRCNEXT = (1U << 12);  ///< Transmit CRC next Note: This bit has to be written as soon as the last data is written in the SPI_DR register.
        constexpr uint32_t CRCEN = (1U << 13);  ///< Hardware CRC calculation enable Note: This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
        constexpr uint32_t BIDIOE = (1U << 14);  ///< Output enable in bidirectional mode This bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode. Note: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.
        constexpr uint32_t BIDIMODE = (1U << 15);  ///< Bidirectional data mode enable. This bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.
    }

    /// SPI_CR2 Register bits
    namespace spi_cr2_bits {
        constexpr uint32_t RXDMAEN = (1U << 0);  ///< Rx buffer DMA enable When this bit is set, a DMA request is generated whenever the RXNE flag is set.
        constexpr uint32_t TXDMAEN = (1U << 1);  ///< Tx buffer DMA enable When this bit is set, a DMA request is generated whenever the TXE flag is set.
        constexpr uint32_t SSOE = (1U << 2);  ///< SS output enable Note: This bit is not used in SPI TI mode.
        constexpr uint32_t NSSP = (1U << 3);  ///< NSS pulse management This bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer. It has no meaning if CPHA = 1, or FRF = 1. Note: 1. This bit must be written only when the SPI is disabled (SPE=0). Note: 2. This bit is not used in SPI TI mode.
        constexpr uint32_t FRF = (1U << 4);  ///< Frame format 1 SPI TI mode Note: This bit must be written only when the SPI is disabled (SPE=0).
        constexpr uint32_t ERRIE = (1U << 5);  ///< Error interrupt enable This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode).
        constexpr uint32_t RXNEIE = (1U << 6);  ///< RX buffer not empty interrupt enable
        constexpr uint32_t TXEIE = (1U << 7);  ///< Tx buffer empty interrupt enable
        constexpr uint32_t DS = (4 << 8);  ///< Data size These bits configure the data length for SPI transfers. If software attempts to write one of the Not used values, they are forced to the value 0111 (8-bit)
        constexpr uint32_t FRXTH = (1U << 12);  ///< FIFO reception threshold This bit is used to set the threshold of the RXFIFO that triggers an RXNE event
        constexpr uint32_t LDMA_RX = (1U << 13);  ///< Last DMA transfer for reception This bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register). Note: Refer to Procedure for disabling the SPI on page1954 if the CRCEN bit is set.
        constexpr uint32_t LDMA_TX = (1U << 14);  ///< Last DMA transfer for transmission This bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register). Note: Refer to Procedure for disabling the SPI on page1954 if the CRCEN bit is set.
    }

    /// SPI_SR Register bits
    namespace spi_sr_bits {
        constexpr uint32_t RXNE = (1U << 0);  ///< Receive buffer not empty
        constexpr uint32_t TXE = (1U << 1);  ///< Transmit buffer empty
        constexpr uint32_t CRCERR = (1U << 4);  ///< CRC error flag Note: This flag is set by hardware and cleared by software writing 0.
        constexpr uint32_t MODF = (1U << 5);  ///< Mode fault This flag is set by hardware and reset by a software sequence. Refer to Section1: Mode fault (MODF) on page1964 for the software sequence.
        constexpr uint32_t OVR = (1U << 6);  ///< Overrun flag This flag is set by hardware and reset by a software sequence.
        constexpr uint32_t BSY = (1U << 7);  ///< Busy flag This flag is set and cleared by hardware. Note: The BSY flag must be used with caution: refer to Section133.4.10: SPI status flags and Procedure for disabling the SPI on page1954.
        constexpr uint32_t FRE = (1U << 8);  ///< Frame format error This flag is used for SPI in TI slave mode. Refer to Section133.4.11: SPI error flags. This flag is set by hardware and reset when SPI_SR is read by software.
        constexpr uint32_t FRLVL = (2 << 9);  ///< FIFO reception level These bits are set and cleared by hardware. Note: These bits are not used in SPI receive-only mode while CRC calculation is enabled.
        constexpr uint32_t FTLVL = (2 << 11);  ///< FIFO transmission level These bits are set and cleared by hardware.
    }

    /// SPI_DR Register bits
    namespace spi_dr_bits {
        constexpr uint32_t DR = (16 << 0);  ///< Data register Data received or to be transmitted The data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See Section133.4.9: Data transmission and reception procedures). Note: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used.
    }

    /// SPI_CRCPR Register bits
    namespace spi_crcpr_bits {
        constexpr uint32_t CRCPOLY = (16 << 0);  ///< CRC polynomial register This register contains the polynomial for the CRC calculation. The CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.
    }

    /// SPI_RXCRCR Register bits
    namespace spi_rxcrcr_bits {
        constexpr uint32_t RXCRC = (16 << 0);  ///< Rx CRC register When CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY Flag is set could return an incorrect value.
    }

    /// SPI_TXCRCR Register bits
    namespace spi_txcrcr_bits {
        constexpr uint32_t TXCRC = (16 << 0);  ///< Tx CRC register When CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY flag is set could return an incorrect value.
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x40010000;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t SYSCFG_CFGR1;  ///< Offset: 0x00 - SYSCFG configuration register 1
        volatile uint32_t SYSCFG_CFGR2;  ///< Offset: 0x18 - SYSCFG configuration register 2
        volatile uint32_t SYSCFG_SCSR;  ///< Offset: 0x1C - SYSCFG SRAM2 control and status register
        volatile uint32_t SYSCFG_SKR;  ///< Offset: 0x20 - SYSCFG SRAM2 key register
        volatile uint32_t SYSCFG_TSCCR;  ///< Offset: 0x24 - SYSCFG TSC comparator register
        volatile uint32_t SYSCFG_ITLINE0;  ///< Offset: 0x80 - SYSCFG interrupt line 0 status register
        volatile uint32_t SYSCFG_ITLINE1;  ///< Offset: 0x84 - SYSCFG interrupt line 1 status register
        volatile uint32_t SYSCFG_ITLINE2;  ///< Offset: 0x88 - SYSCFG interrupt line 2 status register
        volatile uint32_t SYSCFG_ITLINE3;  ///< Offset: 0x8C - SYSCFG interrupt line 3 status register
        volatile uint32_t SYSCFG_ITLINE4;  ///< Offset: 0x90 - SYSCFG interrupt line 4 status register
        volatile uint32_t SYSCFG_ITLINE5;  ///< Offset: 0x94 - SYSCFG interrupt line 5 status register
        volatile uint32_t SYSCFG_ITLINE6;  ///< Offset: 0x98 - SYSCFG interrupt line 6 status register
        volatile uint32_t SYSCFG_ITLINE7;  ///< Offset: 0x9C - SYSCFG interrupt line 7 status register
        volatile uint32_t SYSCFG_ITLINE8;  ///< Offset: 0xA0 - SYSCFG interrupt line 8 status register
        volatile uint32_t SYSCFG_ITLINE9;  ///< Offset: 0xA4 - SYSCFG interrupt line 9 status register
        volatile uint32_t SYSCFG_ITLINE10;  ///< Offset: 0xA8 - SYSCFG interrupt line 10 status register
        volatile uint32_t SYSCFG_ITLINE11;  ///< Offset: 0xAC - SYSCFG interrupt line 11 status register
        volatile uint32_t SYSCFG_ITLINE12;  ///< Offset: 0xB0 - SYSCFG interrupt line 12 status register
        volatile uint32_t SYSCFG_ITLINE13;  ///< Offset: 0xB4 - SYSCFG interrupt line 13 status register
        volatile uint32_t SYSCFG_ITLINE14;  ///< Offset: 0xB8 - SYSCFG interrupt line 14 status register
        volatile uint32_t SYSCFG_ITLINE15;  ///< Offset: 0xBC - SYSCFG interrupt line 15 status register
        volatile uint32_t SYSCFG_ITLINE16;  ///< Offset: 0xC0 - SYSCFG interrupt line 16 status register
        volatile uint32_t SYSCFG_ITLINE17;  ///< Offset: 0xC4 - SYSCFG interrupt line 17 status register
        volatile uint32_t SYSCFG_ITLINE18;  ///< Offset: 0xC8 - SYSCFG interrupt line 18 status register
        volatile uint32_t SYSCFG_ITLINE19;  ///< Offset: 0xCC - SYSCFG interrupt line 19 status register
        volatile uint32_t SYSCFG_ITLINE20;  ///< Offset: 0xD0 - SYSCFG interrupt line 20 status register
        volatile uint32_t SYSCFG_ITLINE21;  ///< Offset: 0xD4 - SYSCFG interrupt line 21 status register
        volatile uint32_t SYSCFG_ITLINE22;  ///< Offset: 0xD8 - SYSCFG interrupt line 22 status register
        volatile uint32_t SYSCFG_ITLINE23;  ///< Offset: 0xDC - SYSCFG interrupt line 23 status register
        volatile uint32_t SYSCFG_ITLINE24;  ///< Offset: 0xE0 - SYSCFG interrupt line 24 status register
        volatile uint32_t SYSCFG_ITLINE25;  ///< Offset: 0xE4 - SYSCFG interrupt line 25 status register
        volatile uint32_t SYSCFG_ITLINE26;  ///< Offset: 0xE8 - SYSCFG interrupt line 26 status register
        volatile uint32_t SYSCFG_ITLINE27;  ///< Offset: 0xEC - SYSCFG interrupt line 27 status register
        volatile uint32_t SYSCFG_ITLINE28;  ///< Offset: 0xF0 - SYSCFG interrupt line 28 status register
        volatile uint32_t SYSCFG_ITLINE29;  ///< Offset: 0xF4 - SYSCFG interrupt line 29 status register
        volatile uint32_t SYSCFG_ITLINE30;  ///< Offset: 0xF8 - SYSCFG interrupt line 30 status register
        volatile uint32_t SYSCFG_ITLINE31;  ///< Offset: 0xFC - SYSCFG interrupt line 31 status register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// SYSCFG_CFGR1 Register bits
    namespace syscfg_cfgr1_bits {
        constexpr uint32_t MEM_MODE = (2 << 0);  ///< Memory mapping selection bits These bits are set and cleared by software. They control the memory internal mapping at address 0x000010000. After reset these bits take on the value selected by the actual boot mode configuration. Refer to Section12.5: Boot configuration for more details. X0: Main flash memory mapped at 0x000010000
        constexpr uint32_t PA11_RMP = (1U << 3);  ///< PA11 pin remapping This bit is set and cleared by software. When set, it remaps the PA11 pin to operate as PA9 GPIO port, instead as PA11 GPIO port.
        constexpr uint32_t PA12_RMP = (1U << 4);  ///< PA12 pin remapping This bit is set and cleared by software. When set, it remaps the PA12 pin to operate as PA10 GPIO port, instead as PA12 GPIO port.
        constexpr uint32_t IR_POL = (1U << 5);  ///< IR output polarity selection
        constexpr uint32_t IR_MOD = (2 << 6);  ///< IR Modulation Envelope signal selection This bitfield selects the signal for IR modulation envelope:
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable This bit selects the way of supplying I/O analog switches: When using the analog inputs , setting to 0 is recommended for high V<sub>DD</sub>, setting to 1 for low V<sub>DD</sub> (less than 2.4 V).
        constexpr uint32_t I2C_PB6_FMP = (1U << 16);  ///< Fast Mode Plus (FM+) enable for PB6 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB6 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
        constexpr uint32_t I2C_PB7_FMP = (1U << 17);  ///< Fast Mode Plus (FM+) enable for PB7 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB7 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
        constexpr uint32_t I2C_PB8_FMP = (1U << 18);  ///< Fast Mode Plus (FM+) enable for PB8 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB8 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
        constexpr uint32_t I2C_PB9_FMP = (1U << 19);  ///< Fast Mode Plus (FM+) enable for PB9 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB9 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
        constexpr uint32_t I2C_PA9_FMP = (1U << 22);  ///< Fast Mode Plus (FM+) enable for PA9 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA9 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
        constexpr uint32_t I2C_PA10_FMP = (1U << 23);  ///< Fast Mode Plus (FM+) enable for PA10 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA10 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
        constexpr uint32_t I2C3_FMP = (1U << 24);  ///< Fast Mode Plus (FM+) enable for I2C3 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C3 through GPIOx_AFR registers. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C3 can be enabled through their corresponding I2Cx_FMP bit. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
    }

    /// SYSCFG_CFGR2 Register bits
    namespace syscfg_cfgr2_bits {
        constexpr uint32_t CCL = (1U << 0);  ///< Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP bit enable bit This bit is set by software and cleared by a system reset. It can be use to enable and lock the connection of Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP (Hardfault) output to TIM1/15/16 Break input.
        constexpr uint32_t SPL = (1U << 1);  ///< SRAM1 parity lock bit This bit is set by software and cleared by a system reset. It can be used to enable and lock the SRAM1 parity error signal connection to TIM1/15/16 Break input.
        constexpr uint32_t PVDL = (1U << 2);  ///< PVD lock enable bit This bit is set by software and cleared by a system reset. It can be used to enable and lock the PVD connection to TIM1/15/16 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR register.
        constexpr uint32_t ECCL = (1U << 3);  ///< ECC error lock bit This bit is set by software and cleared by a system reset. It can be used to enable and lock the flash ECC 2-bit error detection signal connection to TIM1/15/16 Break input.
        constexpr uint32_t BKPL = (1U << 4);  ///< Backup SRAM2 parity lock This bit is set by software and cleared by a system reset. It can be used to enable and lock the SRAM2 parity error signal connection to TIM1/15/16 Break input.
        constexpr uint32_t BKPF = (1U << 7);  ///< Backup SRAM2 parity error flag This bit is set by hardware when an SRAM2 parity error is detected. It is cleared by software by writing 1.
        constexpr uint32_t SPF = (1U << 8);  ///< SRAM1 parity error flag This bit is set by hardware when an SRAM1 parity error is detected. It is cleared by software by writing 1.
    }

    /// SYSCFG_SCSR Register bits
    namespace syscfg_scsr_bits {
        constexpr uint32_t SRAM2ER = (1U << 0);  ///< SRAM2 erase Setting this bit starts a hardware SRAM2 erase operation. This bit is automatically cleared at the end of the SRAM2 erase operation. Note: This bit is write-protected: setting this bit is possible only after the correct key sequence is written in the SYSCFG_SKR register.
        constexpr uint32_t SRAM2BSY = (1U << 1);  ///< SRAM2 busy by erase operation
    }

    /// SYSCFG_SKR Register bits
    namespace syscfg_skr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< SRAM2 write protection key for software erase The following steps are required to unlock the write protection of the SRAM2ER bit in the SYSCFG_CFGR2 register: Write 0xCA into KEY[7:0] Write 0x53 into KEY[7:0] Writing a wrong key reactivates the write protection.
    }

    /// SYSCFG_TSCCR Register bits
    namespace syscfg_tsccr_bits {
        constexpr uint32_t G2_IO1 = (1U << 0);  ///< Comparator mode for group 2 on I/O 1
        constexpr uint32_t G2_IO3 = (1U << 1);  ///< Comparator mode for group 2 on I/O 3
        constexpr uint32_t G4_IO3 = (1U << 2);  ///< Comparator mode for group 4 on I/O 3
        constexpr uint32_t G6_IO1 = (1U << 3);  ///< Comparator mode for group 6 on I/O 1
        constexpr uint32_t G7_IO1 = (1U << 4);  ///< Comparator mode for group 7 on I/O 1
        constexpr uint32_t TSC_IOCTRL = (1U << 5);  ///< I/O control in comparator mode The I/O control in comparator mode can be overwritten by hardware.
    }

    /// SYSCFG_ITLINE0 Register bits
    namespace syscfg_itline0_bits {
        constexpr uint32_t WWDG = (1U << 0);  ///< Window watchdog interrupt pending flag
    }

    /// SYSCFG_ITLINE1 Register bits
    namespace syscfg_itline1_bits {
        constexpr uint32_t PVDOUT = (1U << 0);  ///< PVD supply monitoring interrupt request pending (EXTI line 16).
        constexpr uint32_t PVMOUT1 = (1U << 1);  ///< V<sub>DDUSB</sub> supply monitoring interrupt request pending (EXTI line 19)
        constexpr uint32_t PVMOUT3 = (1U << 2);  ///< ADC supply monitoring interrupt request pending (EXTI line 20)
        constexpr uint32_t PVMOUT4 = (1U << 3);  ///< DAC supply monitoring interrupt request pending (EXTI line 21)
    }

    /// SYSCFG_ITLINE2 Register bits
    namespace syscfg_itline2_bits {
        constexpr uint32_t TAMP = (1U << 0);  ///< Tamper interrupt request pending (EXTI line 21)
        constexpr uint32_t RTC = (1U << 1);  ///< RTC interrupt request pending (EXTI line 19)
    }

    /// SYSCFG_ITLINE3 Register bits
    namespace syscfg_itline3_bits {
        constexpr uint32_t FLASH_ITF = (1U << 0);  ///< Flash interface interrupt request pending
        constexpr uint32_t FLASH_ECC = (1U << 1);  ///< Flash interface ECC interrupt request pending
    }

    /// SYSCFG_ITLINE4 Register bits
    namespace syscfg_itline4_bits {
        constexpr uint32_t RCC = (1U << 0);  ///< Reset and clock control interrupt request pending
    }

    /// SYSCFG_ITLINE5 Register bits
    namespace syscfg_itline5_bits {
        constexpr uint32_t EXTI0 = (1U << 0);  ///< EXTI line 0 interrupt request pending
        constexpr uint32_t EXTI1 = (1U << 1);  ///< EXTI line 1 interrupt request pending
    }

    /// SYSCFG_ITLINE6 Register bits
    namespace syscfg_itline6_bits {
        constexpr uint32_t EXTI2 = (1U << 0);  ///< EXTI line 2 interrupt request pending
        constexpr uint32_t EXTI3 = (1U << 1);  ///< EXTI line 3 interrupt request pending
    }

    /// SYSCFG_ITLINE7 Register bits
    namespace syscfg_itline7_bits {
        constexpr uint32_t EXTI4 = (1U << 0);  ///< EXTI line 4 interrupt request pending
        constexpr uint32_t EXTI5 = (1U << 1);  ///< EXTI line 5 interrupt request pending
        constexpr uint32_t EXTI6 = (1U << 2);  ///< EXTI line 6 interrupt request pending
        constexpr uint32_t EXTI7 = (1U << 3);  ///< EXTI line 7 interrupt request pending
        constexpr uint32_t EXTI8 = (1U << 4);  ///< EXTI line 8 interrupt request pending
        constexpr uint32_t EXTI9 = (1U << 5);  ///< EXTI line 9 interrupt request pending
        constexpr uint32_t EXTI10 = (1U << 6);  ///< EXTI line 10 interrupt request pending
        constexpr uint32_t EXTI11 = (1U << 7);  ///< EXTI line 11 interrupt request pending
        constexpr uint32_t EXTI12 = (1U << 8);  ///< EXTI line 12 interrupt request pending
        constexpr uint32_t EXTI13 = (1U << 9);  ///< EXTI line 13 interrupt request pending
        constexpr uint32_t EXTI14 = (1U << 10);  ///< EXTI line 14 interrupt request pending
        constexpr uint32_t EXTI15 = (1U << 11);  ///< EXTI line 15 interrupt request pending
    }

    /// SYSCFG_ITLINE8 Register bits
    namespace syscfg_itline8_bits {
        constexpr uint32_t USB = (1U << 0);  ///< USB interrupt request pending
    }

    /// SYSCFG_ITLINE9 Register bits
    namespace syscfg_itline9_bits {
        constexpr uint32_t DMA1_CH1 = (1U << 0);  ///< DMA1 channel 1 interrupt request pending
    }

    /// SYSCFG_ITLINE10 Register bits
    namespace syscfg_itline10_bits {
        constexpr uint32_t DMA1_CH2 = (1U << 0);  ///< DMA1 channel 2 interrupt request pending
        constexpr uint32_t DMA1_CH3 = (1U << 1);  ///< DMA1 channel 3 interrupt request pending
    }

    /// SYSCFG_ITLINE11 Register bits
    namespace syscfg_itline11_bits {
        constexpr uint32_t DMAMUX = (1U << 0);  ///< DMAMUX interrupt request pending
        constexpr uint32_t DMA1_CH4 = (1U << 1);  ///< DMA1 channel 4 interrupt request pending
        constexpr uint32_t DMA1_CH5 = (1U << 2);  ///< DMA1 channel 5 interrupt request pending
        constexpr uint32_t DMA1_CH6 = (1U << 3);  ///< DMA1 channel 6 interrupt request pending
        constexpr uint32_t DMA1_CH7 = (1U << 4);  ///< DMA1 channel 7 interrupt request pending
        constexpr uint32_t DMA2_CH1 = (1U << 5);  ///< DMA2 channel 1 interrupt request pending
        constexpr uint32_t DMA2_CH2 = (1U << 6);  ///< DMA2 channel 2 interrupt request pending
        constexpr uint32_t DMA2_CH3 = (1U << 7);  ///< DMA2 channel 3 interrupt request pending
        constexpr uint32_t DMA2_CH4 = (1U << 8);  ///< DMA2 channel 4 interrupt request pending
        constexpr uint32_t DMA2_CH5 = (1U << 9);  ///< DMA2 channel 5 interrupt request pending
    }

    /// SYSCFG_ITLINE12 Register bits
    namespace syscfg_itline12_bits {
        constexpr uint32_t ADC = (1U << 0);  ///< ADC interrupt request pending
        constexpr uint32_t COMP1 = (1U << 1);  ///< Comparator 1 interrupt request pending (EXTI line 17)
    }

    /// SYSCFG_ITLINE13 Register bits
    namespace syscfg_itline13_bits {
        constexpr uint32_t TIM1_CCU = (1U << 0);  ///< Timer 1 commutation interrupt request pending
        constexpr uint32_t TIM1_TRG = (1U << 1);  ///< Timer 1 trigger interrupt request pending
        constexpr uint32_t TIM1_UPD = (1U << 2);  ///< Timer 1 update interrupt request pending
        constexpr uint32_t TIM1_BRK = (1U << 3);  ///< Timer 1 break interrupt request pending
    }

    /// SYSCFG_ITLINE14 Register bits
    namespace syscfg_itline14_bits {
        constexpr uint32_t TIM1_CC1 = (1U << 0);  ///< Timer 1 capture compare 1 interrupt request pending
        constexpr uint32_t TIM1_CC2 = (1U << 1);  ///< Timer 1 capture compare 2 interrupt request pending
        constexpr uint32_t TIM1_CC3 = (1U << 2);  ///< Timer 1 capture compare 3 interrupt request pending
        constexpr uint32_t TIM1_CC4 = (1U << 3);  ///< Timer 1 capture compare 4 interrupt request pending
    }

    /// SYSCFG_ITLINE15 Register bits
    namespace syscfg_itline15_bits {
        constexpr uint32_t TIM2 = (1U << 0);  ///< Timer 2 interrupt request pending
    }

    /// SYSCFG_ITLINE16 Register bits
    namespace syscfg_itline16_bits {
        constexpr uint32_t TIM3 = (1U << 0);  ///< Timer 3 interrupt request pending
    }

    /// SYSCFG_ITLINE17 Register bits
    namespace syscfg_itline17_bits {
        constexpr uint32_t TIM6 = (1U << 0);  ///< Timer 6 interrupt request pending
        constexpr uint32_t DAC = (1U << 1);  ///< DAC underrun interrupt request pending
        constexpr uint32_t LPTIM1 = (1U << 2);  ///< Low-power timer 1 interrupt request pending (EXTI line 29)
    }

    /// SYSCFG_ITLINE18 Register bits
    namespace syscfg_itline18_bits {
        constexpr uint32_t TIM7 = (1U << 0);  ///< Timer 7 interrupt request pending
        constexpr uint32_t LPTIM2 = (1U << 1);  ///< Low-power timer 2 interrupt request pending (EXTI line 30)
    }

    /// SYSCFG_ITLINE19 Register bits
    namespace syscfg_itline19_bits {
        constexpr uint32_t TIM15 = (1U << 0);  ///< Timer 15 interrupt request pending
    }

    /// SYSCFG_ITLINE20 Register bits
    namespace syscfg_itline20_bits {
        constexpr uint32_t TIM16 = (1U << 0);  ///< Timer 16 interrupt request pending
    }

    /// SYSCFG_ITLINE21 Register bits
    namespace syscfg_itline21_bits {
        constexpr uint32_t TSC_MCE = (1U << 0);  ///< TSC max count error interrupt request pending
        constexpr uint32_t TSC_EOA = (1U << 1);  ///< TSC end of acquisition interrupt request pending
    }

    /// SYSCFG_ITLINE22 Register bits
    namespace syscfg_itline22_bits {
        constexpr uint32_t LCD = (1U << 0);  ///< LCD interrupt request pending
    }

    /// SYSCFG_ITLINE23 Register bits
    namespace syscfg_itline23_bits {
        constexpr uint32_t I2C1 = (1U << 0);  ///< I2C1 interrupt request pending (EXTI line 33)
    }

    /// SYSCFG_ITLINE24 Register bits
    namespace syscfg_itline24_bits {
        constexpr uint32_t I2C2 = (1U << 0);  ///< I2C2 interrupt request pending
        constexpr uint32_t I2C3 = (1U << 2);  ///< I2C3 interrupt request pending (EXTI line 23)
    }

    /// SYSCFG_ITLINE25 Register bits
    namespace syscfg_itline25_bits {
        constexpr uint32_t SPI1 = (1U << 0);  ///< SPI1 interrupt request pending
    }

    /// SYSCFG_ITLINE26 Register bits
    namespace syscfg_itline26_bits {
        constexpr uint32_t SPI2 = (1U << 0);  ///< SPI2 interrupt request pending
    }

    /// SYSCFG_ITLINE27 Register bits
    namespace syscfg_itline27_bits {
        constexpr uint32_t USART1 = (1U << 0);  ///< USART1 interrupt request pending, combined with EXTI line 25
    }

    /// SYSCFG_ITLINE28 Register bits
    namespace syscfg_itline28_bits {
        constexpr uint32_t USART2 = (1U << 0);  ///< USART2 interrupt request pending (EXTI line 35)
        constexpr uint32_t LPUART2 = (1U << 1);  ///< LPUART2 interrupt request pending (EXTI line 31)
    }

    /// SYSCFG_ITLINE29 Register bits
    namespace syscfg_itline29_bits {
        constexpr uint32_t USART3 = (1U << 0);  ///< USART3 interrupt request pending
        constexpr uint32_t LPUART1 = (1U << 1);  ///< LPUART1 interrupt request pending (EXTI line 30)
    }

    /// SYSCFG_ITLINE30 Register bits
    namespace syscfg_itline30_bits {
        constexpr uint32_t USART4 = (1U << 0);  ///< USART4 interrupt request pending
        constexpr uint32_t LPUART3 = (1U << 1);  ///< LPUART3 interrupt request pending (EXTI line 32)
    }

    /// SYSCFG_ITLINE31 Register bits
    namespace syscfg_itline31_bits {
        constexpr uint32_t RNG = (1U << 0);  ///< RNG interrupt request pending
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x4000B000;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t TAMP_CR1;  ///< Offset: 0x00 - TAMP control register 1
        volatile uint32_t TAMP_CR2;  ///< Offset: 0x04 - TAMP control register 2
        volatile uint32_t TAMP_CR3;  ///< Offset: 0x08 - TAMP control register 3
        volatile uint32_t TAMP_FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t TAMP_IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t TAMP_SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t TAMP_MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t TAMP_SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t TAMP_BKP0R;  ///< Offset: 0x100 - TAMP backup 0 register
        volatile uint32_t TAMP_BKP1R;  ///< Offset: 0x104 - TAMP backup 1 register
        volatile uint32_t TAMP_BKP2R;  ///< Offset: 0x108 - TAMP backup 2 register
        volatile uint32_t TAMP_BKP3R;  ///< Offset: 0x10C - TAMP backup 3 register
        volatile uint32_t TAMP_BKP4R;  ///< Offset: 0x110 - TAMP backup 4 register
        volatile uint32_t TAMP_BKP5R;  ///< Offset: 0x114 - TAMP backup 5 register
        volatile uint32_t TAMP_BKP6R;  ///< Offset: 0x118 - TAMP backup 6 register
        volatile uint32_t TAMP_BKP7R;  ///< Offset: 0x11C - TAMP backup 7 register
        volatile uint32_t TAMP_BKP8R;  ///< Offset: 0x120 - TAMP backup 8 register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// TAMP_CR1 Register bits
    namespace tamp_cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper detection on TAMP_IN1 enable
        constexpr uint32_t TAMP2E = (1U << 1);  ///< Tamper detection on TAMP_IN2 enable<sup>(1)</sup>
        constexpr uint32_t TAMP3E = (1U << 2);  ///< Tamper detection on TAMP_IN3 enable<sup>(1)</sup>
        constexpr uint32_t TAMP4E = (1U << 3);  ///< Tamper detection on TAMP_IN4 enable<sup>(1)</sup>
        constexpr uint32_t TAMP5E = (1U << 4);  ///< Tamper detection on TAMP_IN5 enable<sup>(1)</sup>
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< Internal tamper 3 enable
        constexpr uint32_t ITAMP4E = (1U << 19);  ///< Internal tamper 4 enable
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< Internal tamper 5 enable
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< Internal tamper 6 enable
    }

    /// TAMP_CR2 Register bits
    namespace tamp_cr2_bits {
        constexpr uint32_t TAMP1POM = (1U << 0);  ///< Tamper 1 potential mode
        constexpr uint32_t TAMP2POM = (1U << 1);  ///< Tamper 2 potential mode
        constexpr uint32_t TAMP3POM = (1U << 2);  ///< Tamper 3 potential mode
        constexpr uint32_t TAMP4POM = (1U << 3);  ///< Tamper 4 potential mode
        constexpr uint32_t TAMP5POM = (1U << 4);  ///< Tamper 5 potential mode
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< Tamper 1 mask The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< Tamper 2 mask The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< Tamper 3 mask The tamper 3 interrupt must not be enabled when TAMP3MSK is set.
        constexpr uint32_t BKBLOCK = (1U << 22);  ///< Backup registers and device secrets<sup>(1)</sup> access blocked
        constexpr uint32_t BKERASE = (1U << 23);  ///< Backup registers and device secrets<sup>(1)</sup> erase Writing 1 to this bit reset the backup registers and device secrets<sup>(1)</sup>. Writing 0 has no effect. This bit is always read as 0.
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< Active level for tamper 1 input If TAMPFLT1=100 tamper 1 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 1 input falling edge triggers a tamper detection event.
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< Active level for tamper 2 input If TAMPFLT = 00 tamper 2 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 2 input falling edge triggers a tamper detection event.
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< Active level for tamper 3 input If TAMPFLT1=100 tamper 3 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 3 input falling edge triggers a tamper detection event.
        constexpr uint32_t TAMP4TRG = (1U << 27);  ///< Active level for tamper 4 input (active mode disabled) If TAMPFLT1=100 tamper 4 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 4 input falling edge triggers a tamper detection event.
        constexpr uint32_t TAMP5TRG = (1U << 28);  ///< Active level for tamper 5 input (active mode disabled) If TAMPFLT1=100 tamper 5 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 5 input falling edge triggers a tamper detection event.
    }

    /// TAMP_CR3 Register bits
    namespace tamp_cr3_bits {
        constexpr uint32_t ITAMP3POM = (1U << 2);  ///< Internal tamper 3 potential mode
        constexpr uint32_t ITAMP4POM = (1U << 3);  ///< Internal tamper 4 potential mode
        constexpr uint32_t ITAMP5POM = (1U << 4);  ///< Internal tamper 5 potential mode
        constexpr uint32_t ITAMP6POM = (1U << 5);  ///< Internal tamper 6 potential mode
    }

    /// TAMP_FLTCR Register bits
    namespace tamp_fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< Tamper sampling frequency Determines the frequency at which each of the TAMP_INx inputs are sampled.
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMP_INx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMP_INx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMP_INx pull-up disable This bit determines if each of the TAMPx pins are precharged before each sample.
    }

    /// TAMP_IER Register bits
    namespace tamp_ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< Tamper 2 interrupt enable
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< Tamper 3 interrupt enable
        constexpr uint32_t TAMP4IE = (1U << 3);  ///< Tamper 4 interrupt enable
        constexpr uint32_t TAMP5IE = (1U << 4);  ///< Tamper 5 interrupt enable
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< Internal tamper 3 interrupt enable
        constexpr uint32_t ITAMP4IE = (1U << 19);  ///< Internal tamper 4 interrupt enable
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< Internal tamper 5 interrupt enable
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< Internal tamper 6 interrupt enable
    }

    /// TAMP_SR Register bits
    namespace tamp_sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP3 input.
        constexpr uint32_t TAMP4F = (1U << 3);  ///< TAMP4 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP4 input.
        constexpr uint32_t TAMP5F = (1U << 4);  ///< TAMP5 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP5 input.
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< Internal tamper 3 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
        constexpr uint32_t ITAMP4F = (1U << 19);  ///< Internal tamper 4 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 4.
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< Internal tamper 5 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< Internal tamper 6 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
    }

    /// TAMP_MISR Register bits
    namespace tamp_misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1 interrupt masked flag This flag is set by hardware when the tamper 1 interrupt is raised.
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2 interrupt masked flag This flag is set by hardware when the tamper 2 interrupt is raised.
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3 interrupt masked flag This flag is set by hardware when the tamper 3 interrupt is raised.
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4 interrupt masked flag This flag is set by hardware when the tamper 4 interrupt is raised.
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5 interrupt masked flag This flag is set by hardware when the tamper 5 interrupt is raised.
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< Internal tamper 3 interrupt masked flag This flag is set by hardware when the internal tamper 3 interrupt is raised.
        constexpr uint32_t ITAMP4MF = (1U << 19);  ///< Internal tamper 4 interrupt masked flag This flag is set by hardware when the internal tamper 4 interrupt is raised.
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< Internal tamper 5 interrupt masked flag This flag is set by hardware when the internal tamper 5 interrupt is raised.
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< Internal tamper 6 interrupt masked flag This flag is set by hardware when the internal tamper 6 interrupt is raised.
    }

    /// TAMP_SCR Register bits
    namespace tamp_scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< Clear TAMP1 detection flag Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< Clear TAMP2 detection flag Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< Clear TAMP3 detection flag Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP4F = (1U << 3);  ///< Clear TAMP4 detection flag Writing 1 in this bit clears the TAMP4F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP5F = (1U << 4);  ///< Clear TAMP5 detection flag Writing 1 in this bit clears the TAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< Clear ITAMP3 detection flag Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP4F = (1U << 19);  ///< Clear ITAMP4 detection flag Writing 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< Clear ITAMP5 detection flag Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< Clear ITAMP6 detection flag Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
    }

    /// TAMP_BKP0R Register bits
    namespace tamp_bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP1R Register bits
    namespace tamp_bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP2R Register bits
    namespace tamp_bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP3R Register bits
    namespace tamp_bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP4R Register bits
    namespace tamp_bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP5R Register bits
    namespace tamp_bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP6R Register bits
    namespace tamp_bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP7R Register bits
    namespace tamp_bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP8R Register bits
    namespace tamp_bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x40024000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t TSC_CR;  ///< Offset: 0x00 - TSC control register
        volatile uint32_t TSC_IER;  ///< Offset: 0x04 - TSC interrupt enable register
        volatile uint32_t TSC_ICR;  ///< Offset: 0x08 - TSC interrupt clear register
        volatile uint32_t TSC_ISR;  ///< Offset: 0x0C - TSC interrupt status register
        volatile uint32_t TSC_IOHCR;  ///< Offset: 0x10 - TSC I/O hysteresis control register
        volatile uint32_t TSC_IOASCR;  ///< Offset: 0x18 - TSC I/O analog switch control register
        volatile uint32_t TSC_IOSCR;  ///< Offset: 0x20 - TSC I/O sampling control register
        volatile uint32_t TSC_IOCCR;  ///< Offset: 0x28 - TSC I/O channel control register
        volatile uint32_t TSC_IOGCSR;  ///< Offset: 0x30 - TSC I/O group control status register
        volatile uint32_t TSC_IOG1CR;  ///< Offset: 0x34 - TSC I/O group 1 counter register
        volatile uint32_t TSC_IOG2CR;  ///< Offset: 0x38 - TSC I/O group 2 counter register
        volatile uint32_t TSC_IOG3CR;  ///< Offset: 0x3C - TSC I/O group 3 counter register
        volatile uint32_t TSC_IOG4CR;  ///< Offset: 0x40 - TSC I/O group 4 counter register
        volatile uint32_t TSC_IOG5CR;  ///< Offset: 0x44 - TSC I/O group 5 counter register
        volatile uint32_t TSC_IOG6CR;  ///< Offset: 0x48 - TSC I/O group 6 counter register
        volatile uint32_t TSC_IOG7CR;  ///< Offset: 0x4C - TSC I/O group 7 counter register
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// TSC_CR Register bits
    namespace tsc_cr_bits {
        constexpr uint32_t TSCE = (1U << 0);  ///< Touch sensing controller enable This bit is set and cleared by software to enable/disable the touch sensing controller. Note: When the touch sensing controller is disabled, TSC registers settings have no effect.
        constexpr uint32_t START = (1U << 1);  ///< Start a new acquisition This bit is set by software to start a new acquisition. It is cleared by hardware as soon as the acquisition is complete or by software to cancel the ongoing acquisition.
        constexpr uint32_t AM = (1U << 2);  ///< Acquisition mode This bit is set and cleared by software to select the acquisition mode. Note: This bit must not be modified when an acquisition is ongoing.
        constexpr uint32_t SYNCPOL = (1U << 3);  ///< Synchronization pin polarity This bit is set and cleared by software to select the polarity of the synchronization input pin.
        constexpr uint32_t IODEF = (1U << 4);  ///< I/O Default mode This bit is set and cleared by software. It defines the configuration of all the TSC I/Os when there is no ongoing acquisition. When there is an ongoing acquisition, it defines the configuration of all unused I/Os (not defined as sampling capacitor I/O or as channel I/O). Note: This bit must not be modified when an acquisition is ongoing.
        constexpr uint32_t MCV = (3 << 5);  ///< Max count value These bits are set and cleared by software. They define the maximum number of charge transfer pulses that can be generated before a max count error is generated. Note: These bits must not be modified when an acquisition is ongoing.
        constexpr uint32_t PGPSC = (3 << 12);  ///< Pulse generator prescaler These bits are set and cleared by software.They select the AHB clock divider used to generate the pulse generator clock (PGCLK). Note: These bits must not be modified when an acquisition is ongoing. Note: Some configurations are forbidden. Refer to the Section119.4.4: Charge transfer acquisition sequence for details.
        constexpr uint32_t SSPSC = (1U << 15);  ///< Spread spectrum prescaler This bit is set and cleared by software. It selects the AHB clock divider used to generate the spread spectrum clock (SSCLK). Note: This bit must not be modified when an acquisition is ongoing.
        constexpr uint32_t SSE = (1U << 16);  ///< Spread spectrum enable This bit is set and cleared by software to enable/disable the spread spectrum feature. Note: This bit must not be modified when an acquisition is ongoing.
        constexpr uint32_t SSD = (7 << 17);  ///< Spread spectrum deviation These bits are set and cleared by software. They define the spread spectrum deviation which consists in adding a variable number of periods of the SSCLK clock to the charge transfer pulse high state. ... Note: These bits must not be modified when an acquisition is ongoing.
        constexpr uint32_t CTPL = (4 << 24);  ///< Charge transfer pulse low These bits are set and cleared by software. They define the duration of the low state of the charge transfer pulse (transfer of charge from C<sub>X</sub> to C<sub>S</sub>). ... Note: These bits must not be modified when an acquisition is ongoing. Note: Some configurations are forbidden. Refer to the Section119.4.4: Charge transfer acquisition sequence for details.
        constexpr uint32_t CTPH = (4 << 28);  ///< Charge transfer pulse high These bits are set and cleared by software. They define the duration of the high state of the charge transfer pulse (charge of C<sub>X</sub>). ... Note: These bits must not be modified when an acquisition is ongoing.
    }

    /// TSC_IER Register bits
    namespace tsc_ier_bits {
        constexpr uint32_t EOAIE = (1U << 0);  ///< End of acquisition interrupt enable This bit is set and cleared by software to enable/disable the end of acquisition interrupt.
        constexpr uint32_t MCEIE = (1U << 1);  ///< Max count error interrupt enable This bit is set and cleared by software to enable/disable the max count error interrupt.
    }

    /// TSC_ICR Register bits
    namespace tsc_icr_bits {
        constexpr uint32_t EOAIC = (1U << 0);  ///< End of acquisition interrupt clear This bit is set by software to clear the end of acquisition flag and it is cleared by hardware when the flag is reset. Writing a 0 has no effect.
        constexpr uint32_t MCEIC = (1U << 1);  ///< Max count error interrupt clear This bit is set by software to clear the max count error flag and it is cleared by hardware when the flag is reset. Writing a 0 has no effect.
    }

    /// TSC_ISR Register bits
    namespace tsc_isr_bits {
        constexpr uint32_t EOAF = (1U << 0);  ///< End of acquisition flag This bit is set by hardware when the acquisition of all enabled group is complete (all GxS bits of all enabled analog I/O groups are set or when a max count error is detected). It is cleared by software writing 1 to the bit EOAIC of the TSC_ICR register.
        constexpr uint32_t MCEF = (1U << 1);  ///< Max count error flag This bit is set by hardware as soon as an analog I/O group counter reaches the max count value specified. It is cleared by software writing 1 to the bit MCEIC of the TSC_ICR register.
    }

    /// TSC_IOHCR Register bits
    namespace tsc_iohcr_bits {
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
    }

    /// TSC_IOASCR Register bits
    namespace tsc_ioascr_bits {
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
    }

    /// TSC_IOSCR Register bits
    namespace tsc_ioscr_bits {
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
    }

    /// TSC_IOCCR Register bits
    namespace tsc_ioccr_bits {
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
    }

    /// TSC_IOGCSR Register bits
    namespace tsc_iogcsr_bits {
        constexpr uint32_t G1E = (1U << 0);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G2E = (1U << 1);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G3E = (1U << 2);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G4E = (1U << 3);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G5E = (1U << 4);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G6E = (1U << 5);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G7E = (1U << 6);  ///< Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
        constexpr uint32_t G1S = (1U << 16);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
        constexpr uint32_t G2S = (1U << 17);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
        constexpr uint32_t G3S = (1U << 18);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
        constexpr uint32_t G4S = (1U << 19);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
        constexpr uint32_t G5S = (1U << 20);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
        constexpr uint32_t G6S = (1U << 21);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
        constexpr uint32_t G7S = (1U << 22);  ///< Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
    }

    /// TSC_IOG1CR Register bits
    namespace tsc_iog1cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

    /// TSC_IOG2CR Register bits
    namespace tsc_iog2cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

    /// TSC_IOG3CR Register bits
    namespace tsc_iog3cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

    /// TSC_IOG4CR Register bits
    namespace tsc_iog4cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

    /// TSC_IOG5CR Register bits
    namespace tsc_iog5cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

    /// TSC_IOG6CR Register bits
    namespace tsc_iog6cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

    /// TSC_IOG7CR Register bits
    namespace tsc_iog7cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x40010030;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
        constexpr uint32_t HIZ = (1U << 1);  ///< High impedance mode This bit controls the analog switch to connect or not the V<sub>REF+</sub> pin. Refer to Table172: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
        constexpr uint32_t VRS = (1U << 2);  ///< Voltage reference scale This bit selects the value generated by the voltage reference buffer.
        constexpr uint32_t VRR = (1U << 3);  ///< Voltage reference buffer ready
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< None
    }

}


} // namespace alloy::generated::stm32u031

#endif // ALLOY_GENERATED_STM32U031_PERIPHERALS_HPP