/// Auto-generated code for STM32U535
/// Generated by Alloy Code Generator
/// Source: st_stm32u535.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-30 23:21:54
#ifndef ALLOY_GENERATED_STM32U535_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32U535_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32u535 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x42028000;
    constexpr uint32_t SEC_ADC1_BASE = 0x52028000;
    constexpr uint32_t ADC12_Common_BASE = 0x42028300;
    constexpr uint32_t SEC_ADC12_Common_BASE = 0x52028300;
    constexpr uint32_t ADC4_BASE = 0x46021000;
    constexpr uint32_t SEC_ADC4_BASE = 0x56021000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR1;  ///< Offset: 0x14 - ADC sample time register 1
        volatile uint32_t ADC_SMPR2;  ///< Offset: 0x18 - ADC sample time register 2
        volatile uint32_t ADC_PCSEL;  ///< Offset: 0x1C - ADC channel preselection register
        volatile uint32_t ADC_SQR1;  ///< Offset: 0x30 - ADC regular sequence register 1
        volatile uint32_t ADC_SQR2;  ///< Offset: 0x34 - ADC regular sequence register 2
        volatile uint32_t ADC_SQR3;  ///< Offset: 0x38 - ADC regular sequence register 3
        volatile uint32_t ADC_SQR4;  ///< Offset: 0x3C - ADC regular sequence register 4
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC regular Data Register
        volatile uint32_t ADC_JSQR;  ///< Offset: 0x4C - ADC injected sequence register
        volatile uint32_t ADC_OFR1;  ///< Offset: 0x60 - ADC offset register
        volatile uint32_t ADC_OFR2;  ///< Offset: 0x64 - ADC offset register
        volatile uint32_t ADC_OFR3;  ///< Offset: 0x68 - ADC offset register
        volatile uint32_t ADC_OFR4;  ///< Offset: 0x6C - ADC offset register
        volatile uint32_t ADC_GCOMP;  ///< Offset: 0x70 - ADC gain compensation register
        volatile uint32_t ADC_JDR1;  ///< Offset: 0x80 - ADC injected data register
        volatile uint32_t ADC_JDR2;  ///< Offset: 0x84 - ADC injected data register
        volatile uint32_t ADC_JDR3;  ///< Offset: 0x88 - ADC injected data register
        volatile uint32_t ADC_JDR4;  ///< Offset: 0x8C - ADC injected data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC analog watchdog 3 configuration register
        volatile uint32_t ADC_LTR1;  ///< Offset: 0xA8 - ADC watchdog threshold register 1
        volatile uint32_t ADC_HTR1;  ///< Offset: 0xAC - ADC watchdog threshold register 1
        volatile uint32_t ADC_LTR2;  ///< Offset: 0xB0 - ADC watchdog lower threshold register 2
        volatile uint32_t ADC_HTR2;  ///< Offset: 0xB4 - ADC watchdog higher threshold register 2
        volatile uint32_t ADC_LTR3;  ///< Offset: 0xB8 - ADC watchdog lower threshold register 3
        volatile uint32_t ADC_HTR3;  ///< Offset: 0xBC - ADC watchdog higher threshold register 3
        volatile uint32_t ADC_DIFSEL;  ///< Offset: 0xC0 - ADC differential mode selection register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xC4 - ADC user control register
        volatile uint32_t ADC_CALFACT2;  ///< Offset: 0xC8 - ADC calibration factor register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* SEC_ADC1 = reinterpret_cast<Registers*>(SEC_ADC1_BASE);
    inline Registers* ADC12_Common = reinterpret_cast<Registers*>(ADC12_Common_BASE);
    inline Registers* SEC_ADC12_Common = reinterpret_cast<Registers*>(SEC_ADC12_Common_BASE);
    inline Registers* ADC4 = reinterpret_cast<Registers*>(ADC4_BASE);
    inline Registers* SEC_ADC4 = reinterpret_cast<Registers*>(SEC_ADC4_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t LDORDY = (1U << 12);  ///< LDORDY
        constexpr uint32_t AWD3 = (1U << 9);  ///< AWD3
        constexpr uint32_t AWD2 = (1U << 8);  ///< AWD2
        constexpr uint32_t AWD1 = (1U << 7);  ///< AWD1
        constexpr uint32_t JEOS = (1U << 6);  ///< JEOS
        constexpr uint32_t JEOC = (1U << 5);  ///< JEOC
        constexpr uint32_t OVR = (1U << 4);  ///< OVR
        constexpr uint32_t EOS = (1U << 3);  ///< EOS
        constexpr uint32_t EOC = (1U << 2);  ///< EOC
        constexpr uint32_t EOSMP = (1U << 1);  ///< EOSMP
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADRDY
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t AWD3IE = (1U << 9);  ///< AWD3IE
        constexpr uint32_t AWD2IE = (1U << 8);  ///< AWD2IE
        constexpr uint32_t AWD1IE = (1U << 7);  ///< AWD1IE
        constexpr uint32_t JEOSIE = (1U << 6);  ///< JEOSIE
        constexpr uint32_t JEOCIE = (1U << 5);  ///< JEOCIE
        constexpr uint32_t OVRIE = (1U << 4);  ///< OVRIE
        constexpr uint32_t EOSIE = (1U << 3);  ///< EOSIE
        constexpr uint32_t EOCIE = (1U << 2);  ///< EOCIE
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< EOSMPIE
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADRDYIE
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADCAL
        constexpr uint32_t DEEPPWD = (1U << 29);  ///< DEEPPWD
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADVREGEN
        constexpr uint32_t CALINDEX = (4 << 24);  ///< CALINDEX
        constexpr uint32_t ADCALLIN = (1U << 16);  ///< ADCALLIN
        constexpr uint32_t JADSTP = (1U << 5);  ///< JADSTP
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADSTP
        constexpr uint32_t JADSTART = (1U << 3);  ///< JADSTART
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADSTART
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADDIS
        constexpr uint32_t ADEN = (1U << 0);  ///< ADEN
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t AWD1CH = (5 << 26);  ///< AWD1CH
        constexpr uint32_t JAUTO = (1U << 25);  ///< JAUTO
        constexpr uint32_t JAWD1EN = (1U << 24);  ///< JAWD1EN
        constexpr uint32_t AWD1EN = (1U << 23);  ///< AWD1EN
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< AWD1SGL
        constexpr uint32_t JDISCEN = (1U << 20);  ///< JDISCEN
        constexpr uint32_t DISCNUM = (3 << 17);  ///< DISCNUM
        constexpr uint32_t DISCEN = (1U << 16);  ///< DISCEN
        constexpr uint32_t AUTDLY = (1U << 14);  ///< AUTDLY
        constexpr uint32_t CONT = (1U << 13);  ///< CONT
        constexpr uint32_t OVRMOD = (1U << 12);  ///< OVRMOD
        constexpr uint32_t EXTEN = (2 << 10);  ///< EXTEN
        constexpr uint32_t EXTSEL = (5 << 5);  ///< EXTSEL
        constexpr uint32_t RES = (2 << 2);  ///< RES
        constexpr uint32_t DMNGT = (2 << 0);  ///< DMNGT
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t LSHIFT = (4 << 28);  ///< LSHIFT
        constexpr uint32_t LFTRIG = (1U << 27);  ///< LFTRIG
        constexpr uint32_t OSR = (10 << 16);  ///< OSR
        constexpr uint32_t SMPTRIG = (1U << 15);  ///< SMPTRIG
        constexpr uint32_t SWTRIG = (1U << 14);  ///< SWTRIG
        constexpr uint32_t BULB = (1U << 13);  ///< BULB
        constexpr uint32_t ROVSM = (1U << 10);  ///< ROVSM
        constexpr uint32_t TROVS = (1U << 9);  ///< TROVS
        constexpr uint32_t OVSS = (4 << 5);  ///< OVSS
        constexpr uint32_t JOVSE = (1U << 1);  ///< JOVSE
        constexpr uint32_t ROVSE = (1U << 0);  ///< ROVSE
    }

    /// ADC_SMPR1 Register bits
    namespace adc_smpr1_bits {
        constexpr uint32_t SMP9 = (3 << 27);  ///< SMP9
        constexpr uint32_t SMP8 = (3 << 24);  ///< SMP8
        constexpr uint32_t SMP7 = (3 << 21);  ///< SMP7
        constexpr uint32_t SMP6 = (3 << 18);  ///< SMP6
        constexpr uint32_t SMP5 = (3 << 15);  ///< SMP5
        constexpr uint32_t SMP4 = (3 << 12);  ///< SMP4
        constexpr uint32_t SMP3 = (3 << 9);  ///< SMP3
        constexpr uint32_t SMP2 = (3 << 6);  ///< SMP2
        constexpr uint32_t SMP1 = (3 << 3);  ///< SMP1
        constexpr uint32_t SMP0 = (3 << 0);  ///< SMP0
    }

    /// ADC_SMPR2 Register bits
    namespace adc_smpr2_bits {
        constexpr uint32_t SMP19 = (3 << 27);  ///< SMP19
        constexpr uint32_t SMP18 = (3 << 24);  ///< SMP18
        constexpr uint32_t SMP17 = (3 << 21);  ///< SMP17
        constexpr uint32_t SMP16 = (3 << 18);  ///< SMP16
        constexpr uint32_t SMP15 = (3 << 15);  ///< SMP15
        constexpr uint32_t SMP14 = (3 << 12);  ///< SMP14
        constexpr uint32_t SMP13 = (3 << 9);  ///< SMP13
        constexpr uint32_t SMP12 = (3 << 6);  ///< SMP12
        constexpr uint32_t SMP11 = (3 << 3);  ///< SMP11
        constexpr uint32_t SMP10 = (3 << 0);  ///< SMP10
    }

    /// ADC_PCSEL Register bits
    namespace adc_pcsel_bits {
        constexpr uint32_t PCSEL19 = (1U << 19);  ///< PCSEL19
        constexpr uint32_t PCSEL18 = (1U << 18);  ///< PCSEL18
        constexpr uint32_t PCSEL17 = (1U << 17);  ///< PCSEL17
        constexpr uint32_t PCSEL16 = (1U << 16);  ///< PCSEL16
        constexpr uint32_t PCSEL15 = (1U << 15);  ///< PCSEL15
        constexpr uint32_t PCSEL14 = (1U << 14);  ///< PCSEL14
        constexpr uint32_t PCSEL13 = (1U << 13);  ///< PCSEL13
        constexpr uint32_t PCSEL12 = (1U << 12);  ///< PCSEL12
        constexpr uint32_t PCSEL11 = (1U << 11);  ///< PCSEL11
        constexpr uint32_t PCSEL10 = (1U << 10);  ///< PCSEL10
        constexpr uint32_t PCSEL9 = (1U << 9);  ///< PCSEL9
        constexpr uint32_t PCSEL8 = (1U << 8);  ///< PCSEL8
        constexpr uint32_t PCSEL7 = (1U << 7);  ///< PCSEL7
        constexpr uint32_t PCSEL6 = (1U << 6);  ///< PCSEL6
        constexpr uint32_t PCSEL5 = (1U << 5);  ///< PCSEL5
        constexpr uint32_t PCSEL4 = (1U << 4);  ///< PCSEL4
        constexpr uint32_t PCSEL3 = (1U << 3);  ///< PCSEL3
        constexpr uint32_t PCSEL2 = (1U << 2);  ///< PCSEL2
        constexpr uint32_t PCSEL1 = (1U << 1);  ///< PCSEL1
        constexpr uint32_t PCSEL0 = (1U << 0);  ///< PCSEL0
    }

    /// ADC_SQR1 Register bits
    namespace adc_sqr1_bits {
        constexpr uint32_t SQ4 = (5 << 24);  ///< SQ4
        constexpr uint32_t SQ3 = (5 << 18);  ///< SQ3
        constexpr uint32_t SQ2 = (5 << 12);  ///< SQ2
        constexpr uint32_t SQ1 = (5 << 6);  ///< SQ1
        constexpr uint32_t L = (4 << 0);  ///< L
    }

    /// ADC_SQR2 Register bits
    namespace adc_sqr2_bits {
        constexpr uint32_t SQ9 = (5 << 24);  ///< SQ9
        constexpr uint32_t SQ8 = (5 << 18);  ///< SQ8
        constexpr uint32_t SQ7 = (5 << 12);  ///< SQ7
        constexpr uint32_t SQ6 = (5 << 6);  ///< SQ6
        constexpr uint32_t SQ5 = (5 << 0);  ///< SQ5
    }

    /// ADC_SQR3 Register bits
    namespace adc_sqr3_bits {
        constexpr uint32_t SQ14 = (5 << 24);  ///< SQ14
        constexpr uint32_t SQ13 = (5 << 18);  ///< SQ13
        constexpr uint32_t SQ12 = (5 << 12);  ///< SQ12
        constexpr uint32_t SQ11 = (5 << 6);  ///< SQ11
        constexpr uint32_t SQ10 = (5 << 0);  ///< SQ10
    }

    /// ADC_SQR4 Register bits
    namespace adc_sqr4_bits {
        constexpr uint32_t SQ16 = (5 << 6);  ///< SQ16
        constexpr uint32_t SQ15 = (5 << 0);  ///< SQ15
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t RDATA = (32 << 0);  ///< RDATA
    }

    /// ADC_JSQR Register bits
    namespace adc_jsqr_bits {
        constexpr uint32_t JSQ4 = (5 << 27);  ///< JSQ4
        constexpr uint32_t JSQ3 = (5 << 21);  ///< JSQ3
        constexpr uint32_t JSQ2 = (5 << 15);  ///< JSQ2
        constexpr uint32_t JSQ1 = (5 << 9);  ///< JSQ1
        constexpr uint32_t JEXTEN = (2 << 7);  ///< JEXTEN
        constexpr uint32_t JEXTSEL = (5 << 2);  ///< JEXTSEL
        constexpr uint32_t JL = (2 << 0);  ///< JL
    }

    /// ADC_OFR1 Register bits
    namespace adc_ofr1_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_OFR2 Register bits
    namespace adc_ofr2_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_OFR3 Register bits
    namespace adc_ofr3_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_OFR4 Register bits
    namespace adc_ofr4_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_GCOMP Register bits
    namespace adc_gcomp_bits {
        constexpr uint32_t GCOMP = (1U << 31);  ///< GCOMP
        constexpr uint32_t GCOMPCOEFF = (14 << 0);  ///< GCOMPCOEFF
    }

    /// ADC_JDR1 Register bits
    namespace adc_jdr1_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_JDR2 Register bits
    namespace adc_jdr2_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_JDR3 Register bits
    namespace adc_jdr3_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_JDR4 Register bits
    namespace adc_jdr4_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH = (20 << 0);  ///< AWD2CH
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH = (20 << 0);  ///< AWD3CH
    }

    /// ADC_LTR1 Register bits
    namespace adc_ltr1_bits {
        constexpr uint32_t LTR1 = (25 << 0);  ///< LTR1
    }

    /// ADC_HTR1 Register bits
    namespace adc_htr1_bits {
        constexpr uint32_t AWDFILT1 = (3 << 29);  ///< AWDFILT1
        constexpr uint32_t HTR1 = (25 << 0);  ///< HTR1
    }

    /// ADC_LTR2 Register bits
    namespace adc_ltr2_bits {
        constexpr uint32_t LTR2 = (25 << 0);  ///< LTR2
    }

    /// ADC_HTR2 Register bits
    namespace adc_htr2_bits {
        constexpr uint32_t HTR2 = (25 << 0);  ///< HTR2
    }

    /// ADC_LTR3 Register bits
    namespace adc_ltr3_bits {
        constexpr uint32_t LTR3 = (25 << 0);  ///< LTR3
    }

    /// ADC_HTR3 Register bits
    namespace adc_htr3_bits {
        constexpr uint32_t HTR3 = (25 << 0);  ///< HTR3
    }

    /// ADC_DIFSEL Register bits
    namespace adc_difsel_bits {
        constexpr uint32_t DIFSEL = (20 << 0);  ///< DIFSEL
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t CAPTURE_COEF = (1U << 25);  ///< CAPTURE_COEF
        constexpr uint32_t LATCH_COEF = (1U << 24);  ///< LATCH_COEF
        constexpr uint32_t VALIDITY = (1U << 16);  ///< VALIDITY
        constexpr uint32_t I_APB_DATA = (8 << 8);  ///< I_APB_DATA
        constexpr uint32_t I_APB_ADDR = (8 << 0);  ///< I_APB_ADDR
    }

    /// ADC_CALFACT2 Register bits
    namespace adc_calfact2_bits {
        constexpr uint32_t CALFACT = (32 << 0);  ///< CALFACT
    }

}

// ============================================================================
// ADF1 Peripheral
// ============================================================================

namespace adf1 {
    /// Base addresses
    constexpr uint32_t ADF1_BASE = 0x46024000;

    /// ADF1 Register structure
    struct Registers {
        volatile uint32_t ADF_GCR;  ///< Offset: 0x00 - ADF Global Control Register
        volatile uint32_t ADF_CKGCR;  ///< Offset: 0x04 - ADF clock generator control register
        volatile uint32_t ADF_SITF0CR;  ///< Offset: 0x80 - ADF serial interface control register 0
        volatile uint32_t ADF_BSMX0CR;  ///< Offset: 0x84 - ADF bitstream matrix control register 0
        volatile uint32_t ADF_DFLT0CR;  ///< Offset: 0x88 - ADF digital filter control register 0
        volatile uint32_t ADF_DFLT0CICR;  ///< Offset: 0x8C - ADF digital filer configuration register 0
        volatile uint32_t ADF_DFLT0RSFR;  ///< Offset: 0x90 - ADF reshape filter configuration register 0
        volatile uint32_t ADF_DLY0CR;  ///< Offset: 0xA4 - ADF delay control register 0
        volatile uint32_t ADF_DFLT0IER;  ///< Offset: 0xAC - ADF DFLT0 interrupt enable register
        volatile uint32_t ADF_DFLT0ISR;  ///< Offset: 0xB0 - ADF DFLT0 interrupt status register 0
        volatile uint32_t ADF_SADCR;  ///< Offset: 0xB8 - ADF SAD control register
        volatile uint32_t ADF_SADCFGR;  ///< Offset: 0xBC - ADF SAD configuration register
        volatile uint32_t ADF_SADSDLVR;  ///< Offset: 0xC0 - ADF SAD sound level register
        volatile uint32_t ADF_SADANLVR;  ///< Offset: 0xC4 - ADF SAD ambient noise level register
        volatile uint32_t ADF_DFLT0DR;  ///< Offset: 0xF0 - ADF digital filter data register 0
    };

    /// Peripheral instances
    inline Registers* ADF1 = reinterpret_cast<Registers*>(ADF1_BASE);

    // Bit definitions
    /// ADF_GCR Register bits
    namespace adf_gcr_bits {
        constexpr uint32_t TRGO = (1U << 0);  ///< Trigger output control Set by software and reset by
    }

    /// ADF_CKGCR Register bits
    namespace adf_ckgcr_bits {
        constexpr uint32_t CKGACTIVE = (1U << 31);  ///< Clock generator active flag
        constexpr uint32_t PROCDIV = (7 << 24);  ///< Divider to control the serial interface clock
        constexpr uint32_t CCKDIV = (4 << 16);  ///< Divider to control the ADF_CCK clock
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter trigger signal selection
        constexpr uint32_t TRGSENS = (1U << 8);  ///< CKGEN trigger sensitivity selection
        constexpr uint32_t CCK1DIR = (1U << 6);  ///< ADF_CCK1 direction
        constexpr uint32_t CCK0DIR = (1U << 5);  ///< ADF_CCK0 direction
        constexpr uint32_t CKGMOD = (1U << 4);  ///< Clock generator mode
        constexpr uint32_t CCK1EN = (1U << 2);  ///< ADF_CCK1 clock enable
        constexpr uint32_t CCK0EN = (1U << 1);  ///< ADF_CCK0 clock enable
        constexpr uint32_t CKGDEN = (1U << 0);  ///< CKGEN dividers enable
    }

    /// ADF_SITF0CR Register bits
    namespace adf_sitf0cr_bits {
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< SITFACTIVE
        constexpr uint32_t STH = (5 << 8);  ///< STH
        constexpr uint32_t SITFMOD = (2 << 4);  ///< SITFMOD
        constexpr uint32_t SCKSRC = (2 << 1);  ///< SCKSRC
        constexpr uint32_t SITFEN = (1U << 0);  ///< SITFEN
    }

    /// ADF_BSMX0CR Register bits
    namespace adf_bsmx0cr_bits {
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX active flag
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream selection
    }

    /// ADF_DFLT0CR Register bits
    namespace adf_dflt0cr_bits {
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< DFLT0 active flag
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< DFLT0 run status flag
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded
        constexpr uint32_t TRGSRC = (4 << 12);  ///< DFLT0 trigger signal selection
        constexpr uint32_t ACQMOD = (3 << 4);  ///< DFLT0 trigger mode
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO threshold selection
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA requests enable
        constexpr uint32_t DFLTEN = (1U << 0);  ///< DFLT0 enable
    }

    /// ADF_DFLT0CICR Register bits
    namespace adf_dflt0cicr_bits {
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC order
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter
    }

    /// ADF_DFLT0RSFR Register bits
    namespace adf_dflt0rsfr_bits {
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-pass filter bypass
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass
    }

    /// ADF_DLY0CR Register bits
    namespace adf_dly0cr_bits {
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip busy flag
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream
    }

    /// ADF_DFLT0IER Register bits
    namespace adf_dflt0ier_bits {
        constexpr uint32_t SDLVLIE = (1U << 13);  ///< SAD sound-level value ready enable
        constexpr uint32_t SDDETIE = (1U << 12);  ///< Sound activity detection interrupt enable
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape filter overrun interrupt enable
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable
    }

    /// ADF_DFLT0ISR Register bits
    namespace adf_dflt0isr_bits {
        constexpr uint32_t SDLVLF = (1U << 13);  ///< Sound level value ready flag
        constexpr uint32_t SDDETF = (1U << 12);  ///< Sound activity detection flag
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape filter overrun detection flag
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO not empty flag
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag
    }

    /// ADF_SADCR Register bits
    namespace adf_sadcr_bits {
        constexpr uint32_t SADACTIVE = (1U << 31);  ///< SAD Active flag
        constexpr uint32_t SADMOD = (2 << 12);  ///< SAD working mode
        constexpr uint32_t FRSIZE = (3 << 8);  ///< Frame size
        constexpr uint32_t HYSTEN = (1U << 7);  ///< Hysteresis enable
        constexpr uint32_t SADST = (2 << 4);  ///< SAD state
        constexpr uint32_t DETCFG = (1U << 3);  ///< Sound trigger event configuration
        constexpr uint32_t DATCAP = (2 << 1);  ///< Data capture mode
        constexpr uint32_t SADEN = (1U << 0);  ///< Sound activity detector enable
    }

    /// ADF_SADCFGR Register bits
    namespace adf_sadcfgr_bits {
        constexpr uint32_t ANMIN = (13 << 16);  ///< ANMIN
        constexpr uint32_t HGOVR = (3 << 12);  ///< Hangover time window
        constexpr uint32_t LFRNB = (3 << 8);  ///< LFRNB
        constexpr uint32_t ANSLP = (3 << 4);  ///< ANSLP
        constexpr uint32_t SNTHR = (4 << 0);  ///< SNTHR
    }

    /// ADF_SADSDLVR Register bits
    namespace adf_sadsdlvr_bits {
        constexpr uint32_t SDLVL = (15 << 0);  ///< SDLVL
    }

    /// ADF_SADANLVR Register bits
    namespace adf_sadanlvr_bits {
        constexpr uint32_t ANLVL = (15 << 0);  ///< ANLVL
    }

    /// ADF_DFLT0DR Register bits
    namespace adf_dflt0dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< DR
    }

}

// ============================================================================
// SEC Peripheral
// ============================================================================

namespace sec {
    /// Base addresses
    constexpr uint32_t SEC_ADF1_BASE = 0x56024000;
    constexpr uint32_t SEC_CORDIC_BASE = 0x50021000;
    constexpr uint32_t SEC_CRC_BASE = 0x50023000;
    constexpr uint32_t SEC_CRS_BASE = 0x50006000;
    constexpr uint32_t SEC_DCACHE_BASE = 0x50031400;
    constexpr uint32_t SEC_DCMI_BASE = 0x5202C000;
    constexpr uint32_t SEC_DLYBOS_BASE = 0x520CF000;
    constexpr uint32_t SEC_DLYBSD_BASE = 0x520C8400;
    constexpr uint32_t SEC_EXTI_BASE = 0x56022000;
    constexpr uint32_t SEC_FMAC_BASE = 0x50021400;
    constexpr uint32_t SEC_GTZC1_MPCBB1_BASE = 0x50032C00;
    constexpr uint32_t SEC_GTZC1_MPCBB2_BASE = 0x50033000;
    constexpr uint32_t SEC_GTZC1_TZIC_BASE = 0x50032800;
    constexpr uint32_t SEC_GTZC1_TZSC_BASE = 0x50032400;
    constexpr uint32_t SEC_GTZC2_MPCBB4_BASE = 0x56023800;
    constexpr uint32_t SEC_GTZC2_TZIC_BASE = 0x56023400;
    constexpr uint32_t SEC_GTZC2_TZSC_BASE = 0x56023000;
    constexpr uint32_t SEC_HASH_BASE = 0x520C0400;
    constexpr uint32_t SEC_ICache_BASE = 0x50030400;
    constexpr uint32_t SEC_MDF1_BASE = 0x50025000;
    constexpr uint32_t SEC_OPAMP_BASE = 0x56005000;
    constexpr uint32_t SEC_PSSI_BASE = 0x5202C400;
    constexpr uint32_t SEC_RAMCFG_BASE = 0x50026000;
    constexpr uint32_t SEC_SAI1_BASE = 0x50015400;
    constexpr uint32_t SEC_SYSCFG_BASE = 0x56000400;
    constexpr uint32_t SEC_TAMP_BASE = 0x56007C00;
    constexpr uint32_t SEC_TSC_BASE = 0x50024000;
    constexpr uint32_t SEC_VREFBUF_BASE = 0x56007400;

    /// SEC Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SEC_ADF1 = reinterpret_cast<Registers*>(SEC_ADF1_BASE);
    inline Registers* SEC_CORDIC = reinterpret_cast<Registers*>(SEC_CORDIC_BASE);
    inline Registers* SEC_CRC = reinterpret_cast<Registers*>(SEC_CRC_BASE);
    inline Registers* SEC_CRS = reinterpret_cast<Registers*>(SEC_CRS_BASE);
    inline Registers* SEC_DCACHE = reinterpret_cast<Registers*>(SEC_DCACHE_BASE);
    inline Registers* SEC_DCMI = reinterpret_cast<Registers*>(SEC_DCMI_BASE);
    inline Registers* SEC_DLYBOS = reinterpret_cast<Registers*>(SEC_DLYBOS_BASE);
    inline Registers* SEC_DLYBSD = reinterpret_cast<Registers*>(SEC_DLYBSD_BASE);
    inline Registers* SEC_EXTI = reinterpret_cast<Registers*>(SEC_EXTI_BASE);
    inline Registers* SEC_FMAC = reinterpret_cast<Registers*>(SEC_FMAC_BASE);
    inline Registers* SEC_GTZC1_MPCBB1 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB1_BASE);
    inline Registers* SEC_GTZC1_MPCBB2 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB2_BASE);
    inline Registers* SEC_GTZC1_TZIC = reinterpret_cast<Registers*>(SEC_GTZC1_TZIC_BASE);
    inline Registers* SEC_GTZC1_TZSC = reinterpret_cast<Registers*>(SEC_GTZC1_TZSC_BASE);
    inline Registers* SEC_GTZC2_MPCBB4 = reinterpret_cast<Registers*>(SEC_GTZC2_MPCBB4_BASE);
    inline Registers* SEC_GTZC2_TZIC = reinterpret_cast<Registers*>(SEC_GTZC2_TZIC_BASE);
    inline Registers* SEC_GTZC2_TZSC = reinterpret_cast<Registers*>(SEC_GTZC2_TZSC_BASE);
    inline Registers* SEC_HASH = reinterpret_cast<Registers*>(SEC_HASH_BASE);
    inline Registers* SEC_ICache = reinterpret_cast<Registers*>(SEC_ICache_BASE);
    inline Registers* SEC_MDF1 = reinterpret_cast<Registers*>(SEC_MDF1_BASE);
    inline Registers* SEC_OPAMP = reinterpret_cast<Registers*>(SEC_OPAMP_BASE);
    inline Registers* SEC_PSSI = reinterpret_cast<Registers*>(SEC_PSSI_BASE);
    inline Registers* SEC_RAMCFG = reinterpret_cast<Registers*>(SEC_RAMCFG_BASE);
    inline Registers* SEC_SAI1 = reinterpret_cast<Registers*>(SEC_SAI1_BASE);
    inline Registers* SEC_SYSCFG = reinterpret_cast<Registers*>(SEC_SYSCFG_BASE);
    inline Registers* SEC_TAMP = reinterpret_cast<Registers*>(SEC_TAMP_BASE);
    inline Registers* SEC_TSC = reinterpret_cast<Registers*>(SEC_TSC_BASE);
    inline Registers* SEC_VREFBUF = reinterpret_cast<Registers*>(SEC_VREFBUF_BASE);

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x46005400;
    constexpr uint32_t SEC_COMP_BASE = 0x56005400;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP1_CSR;  ///< Offset: 0x00 - Comparator 1 control and status register
        volatile uint32_t COMP2_CSR;  ///< Offset: 0x04 - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);
    inline Registers* SEC_COMP = reinterpret_cast<Registers*>(SEC_COMP_BASE);

    // Bit definitions
    /// COMP1_CSR Register bits
    namespace comp1_csr_bits {
        constexpr uint32_t COMP1_EN = (1U << 0);  ///< Comparator 1 enable bit
        constexpr uint32_t COMP1_INMSEL = (4 << 4);  ///< Comparator 1 Input Minus connection configuration bit
        constexpr uint32_t COMP1_INPSEL = (2 << 8);  ///< Comparator1 input plus selection bit
        constexpr uint32_t COMP1_WINMODE = (1U << 11);  ///< COMP1_WINMODE
        constexpr uint32_t COMP1_WINOUT = (1U << 14);  ///< COMP1_WINOUT
        constexpr uint32_t COMP1_POLARITY = (1U << 15);  ///< Comparator 1 polarity selection bit
        constexpr uint32_t COMP1_HYST = (2 << 16);  ///< Comparator 1 hysteresis selection bits
        constexpr uint32_t COMP1_PWRMODE = (2 << 18);  ///< COMP1_PWRMODE
        constexpr uint32_t COMP1_BLANKSEL = (5 << 20);  ///< COMP1_BLANKSEL
        constexpr uint32_t COMP1_VALUE = (1U << 30);  ///< Comparator 1 output status bit
        constexpr uint32_t COMP1_LOCK = (1U << 31);  ///< COMP1_CSR register lock bit
    }

    /// COMP2_CSR Register bits
    namespace comp2_csr_bits {
        constexpr uint32_t COM2_EN = (1U << 0);  ///< Comparator 2 enable bit
        constexpr uint32_t COM2_INMSEL = (4 << 4);  ///< Comparator 2 Input Minus connection configuration bit
        constexpr uint32_t COM2_INPSEL = (2 << 8);  ///< Comparator 2 input plus selection bit
        constexpr uint32_t COM2_WINMODE = (1U << 11);  ///< COM2_WINMODE
        constexpr uint32_t COM2_WINOUT = (1U << 14);  ///< COM2_WINOUT
        constexpr uint32_t COM2_POLARITY = (1U << 15);  ///< Comparator 2 polarity selection bit
        constexpr uint32_t COM2_HYST = (2 << 16);  ///< Comparator 2 hysteresis selection bits
        constexpr uint32_t COM2_PWRMODE = (2 << 18);  ///< COM2_PWRMODE
        constexpr uint32_t COM2_BLANKSEL = (5 << 20);  ///< COM2_BLANKSEL
        constexpr uint32_t COM2_VALUE = (1U << 30);  ///< Comparator 2 output status bit
        constexpr uint32_t COM2_LOCK = (1U << 31);  ///< COMP2_CSR register lock bit
    }

}

// ============================================================================
// CORDIC Peripheral
// ============================================================================

namespace cordic {
    /// Base addresses
    constexpr uint32_t CORDIC_BASE = 0x40021000;

    /// CORDIC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - CORDIC Control Status register
        volatile uint32_t WDATA;  ///< Offset: 0x04 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x08 - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* CORDIC = reinterpret_cast<Registers*>(CORDIC_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t FUNC = (4 << 0);  ///< Function
        constexpr uint32_t PRECISION = (4 << 4);  ///< Precision required (number of iterations)
        constexpr uint32_t SCALE = (3 << 8);  ///< Scaling factor
        constexpr uint32_t IEN = (1U << 16);  ///< Enable interrupt
        constexpr uint32_t DMAREN = (1U << 17);  ///< Enable DMA read channel
        constexpr uint32_t DMAWEN = (1U << 18);  ///< Enable DMA write channel
        constexpr uint32_t NRES = (1U << 19);  ///< Number of results in the CORDIC_RDATA register
        constexpr uint32_t NARGS = (1U << 20);  ///< Number of arguments expected by the CORDIC_WDATA register
        constexpr uint32_t RESSIZE = (1U << 21);  ///< Width of output data
        constexpr uint32_t ARGSIZE = (1U << 22);  ///< Width of input data
        constexpr uint32_t RRDY = (1U << 31);  ///< Result ready flag
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t ARG = (32 << 0);  ///< Function input arguments
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RES = (32 << 0);  ///< Function result
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// CRS Peripheral
// ============================================================================

namespace crs {
    /// Base addresses
    constexpr uint32_t CRS_BASE = 0x40006000;

    /// CRS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - configuration register
        volatile uint32_t ISR;  ///< Offset: 0x08 - interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x0C - interrupt flag clear register
    };

    /// Peripheral instances
    inline Registers* CRS = reinterpret_cast<Registers*>(CRS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TRIM = (7 << 8);  ///< HSI48 oscillator smooth trimming
        constexpr uint32_t SWSYNC = (1U << 7);  ///< Generate software SYNC event
        constexpr uint32_t AUTOTRIMEN = (1U << 6);  ///< Automatic trimming enable
        constexpr uint32_t CEN = (1U << 5);  ///< Frequency error counter enable
        constexpr uint32_t ESYNCIE = (1U << 3);  ///< Expected SYNC interrupt enable
        constexpr uint32_t ERRIE = (1U << 2);  ///< Synchronization or trimming error interrupt enable
        constexpr uint32_t SYNCWARNIE = (1U << 1);  ///< SYNC warning interrupt enable
        constexpr uint32_t SYNCOKIE = (1U << 0);  ///< SYNC event OK interrupt enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SYNCPOL = (1U << 31);  ///< SYNC polarity selection
        constexpr uint32_t SYNCSRC = (2 << 28);  ///< SYNC signal source selection
        constexpr uint32_t SYNCDIV = (3 << 24);  ///< SYNC divider
        constexpr uint32_t FELIM = (8 << 16);  ///< Frequency error limit
        constexpr uint32_t RELOAD = (16 << 0);  ///< Counter reload value
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t FECAP = (16 << 16);  ///< Frequency error capture
        constexpr uint32_t FEDIR = (1U << 15);  ///< Frequency error direction
        constexpr uint32_t TRIMOVF = (1U << 10);  ///< Trimming overflow or underflow
        constexpr uint32_t SYNCMISS = (1U << 9);  ///< SYNC missed
        constexpr uint32_t SYNCERR = (1U << 8);  ///< SYNC error
        constexpr uint32_t ESYNCF = (1U << 3);  ///< Expected SYNC flag
        constexpr uint32_t ERRF = (1U << 2);  ///< Error flag
        constexpr uint32_t SYNCWARNF = (1U << 1);  ///< SYNC warning flag
        constexpr uint32_t SYNCOKF = (1U << 0);  ///< SYNC event OK flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ESYNCC = (1U << 3);  ///< Expected SYNC clear flag
        constexpr uint32_t ERRC = (1U << 2);  ///< Error clear flag
        constexpr uint32_t SYNCWARNC = (1U << 1);  ///< SYNC warning clear flag
        constexpr uint32_t SYNCOKC = (1U << 0);  ///< SYNC event OK clear flag
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC1_BASE = 0x46021800;
    constexpr uint32_t SEC_DAC1_BASE = 0x56021800;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC channel2 sample and hold sample time register
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
        volatile uint32_t DAC_AUTOCR;  ///< Offset: 0x54 - Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);
    inline Registers* SEC_DAC1 = reinterpret_cast<Registers*>(SEC_DAC1_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC channel1 calibration enable
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL2 = (4 << 18);  ///< DAC channel2 trigger selection
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC channel2 calibration enable
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
        constexpr uint32_t DACC1DHRB = (12 << 16);  ///< DAC channel1 12-bit right-aligned data B
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
        constexpr uint32_t DACC1DHRB = (12 << 20);  ///< DAC channel1 12-bit left-aligned data B
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
        constexpr uint32_t DACC1DHRB = (8 << 8);  ///< DAC channel1 8-bit right-aligned Sdata
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data
        constexpr uint32_t DACC2DHRB = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data
        constexpr uint32_t DACC2DHRB = (12 << 20);  ///< DAC channel2 12-bit left-aligned data B
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data
        constexpr uint32_t DACC2DHRB = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output
        constexpr uint32_t DACC1DORB = (12 << 16);  ///< DAC channel1 data output
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output
        constexpr uint32_t DACC2DORB = (12 << 16);  ///< DAC channel2 data output
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DAC1RDY = (1U << 11);  ///< DAC channel1 ready status bit
        constexpr uint32_t DORSTAT1 = (1U << 12);  ///< DAC channel1 output register status bit
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag
        constexpr uint32_t DAC2RDY = (1U << 27);  ///< DAC channel 2 ready status bit
        constexpr uint32_t DORSTAT2 = (1U << 28);  ///< DAC channel 2 output register status bit
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode
        constexpr uint32_t DMADOUBLE1 = (1U << 8);  ///< DAC Channel1 DMA double data mode
        constexpr uint32_t SINFORMAT1 = (1U << 9);  ///< Enable signed format for DAC channel1
        constexpr uint32_t HFSEL = (2 << 14);  ///< High frequency interface mode selection
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode
        constexpr uint32_t DMADOUBLE2 = (1U << 24);  ///< DAC Channel2 DMA double data mode
        constexpr uint32_t SINFORMAT2 = (1U << 25);  ///< Enable signed format for DAC channel2
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode)
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample and hold mode)
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample and hold mode)
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample and hold mode)
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample and hold mode)
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample and hold mode)
    }

    /// DAC_AUTOCR Register bits
    namespace dac_autocr_bits {
        constexpr uint32_t AUTOMODE = (1U << 22);  ///< DAC Autonomous mode
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0xE0044000;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - DBGMCU_IDCODE
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU configuration register
        volatile uint32_t APB1LFZR;  ///< Offset: 0x08 - Debug MCU APB1L peripheral freeze register
        volatile uint32_t APB1HFZR;  ///< Offset: 0x0C - Debug MCU APB1H peripheral freeze register
        volatile uint32_t APB2FZR;  ///< Offset: 0x10 - Debug MCU APB2 peripheral freeze register
        volatile uint32_t APB3FZR;  ///< Offset: 0x14 - Debug MCU APB3 peripheral freeze register
        volatile uint32_t AHB1FZR;  ///< Offset: 0x20 - Debug MCU AHB1 peripheral freeze register
        volatile uint32_t AHB3FZR;  ///< Offset: 0x28 - Debug MCU AHB3 peripheral freeze register
        volatile uint32_t SR;  ///< Offset: 0xFC - DBGMCU status register
        volatile uint32_t DBGMCU_DBG_AUTH_HOST;  ///< Offset: 0x100 - DBGMCU debug host authentication register
        volatile uint32_t DBG_AUTH_DEVICE;  ///< Offset: 0x104 - DBGMCU debug device authentication register
        volatile uint32_t PIDR4;  ///< Offset: 0xFD0 - Debug MCU CoreSight peripheral identity register 4
        volatile uint32_t PIDR0;  ///< Offset: 0xFE0 - Debug MCU CoreSight peripheral identity register 0
        volatile uint32_t PIDR1;  ///< Offset: 0xFE4 - Debug MCU CoreSight peripheral identity register 1
        volatile uint32_t PIDR2;  ///< Offset: 0xFE8 - Debug MCU CoreSight peripheral identity register 2
        volatile uint32_t PIDR3;  ///< Offset: 0xFEC - Debug MCU CoreSight peripheral identity register 3
        volatile uint32_t CIDR0;  ///< Offset: 0xFF0 - Debug MCU CoreSight component identity register 0
        volatile uint32_t CIDR1;  ///< Offset: 0xFF4 - Debug MCU CoreSight component identity register 1
        volatile uint32_t CIDR2;  ///< Offset: 0xFF8 - Debug MCU CoreSight component identity register 2
        volatile uint32_t CIDR3;  ///< Offset: 0xFFC - Debug MCU CoreSight component identity register 3
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device dentification
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby mode
        constexpr uint32_t TRACE_IOEN = (1U << 4);  ///< Trace pin assignment control
        constexpr uint32_t TRACE_EN = (1U << 5);  ///< trace port and clock enable
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< Trace pin assignment control
    }

    /// APB1LFZR Register bits
    namespace apb1lfzr_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 stop in debug
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 stop in debug
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< TIM4 stop in debug
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< TIM5 stop in debug
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< TIM6 stop in debug
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 stop in debug
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Window watchdog counter stop in debug
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Independent watchdog counter stop in debug
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout stop in debug
        constexpr uint32_t DBG_I2C2_STOP = (1U << 22);  ///< I2C2 SMBUS timeout stop in debug
    }

    /// APB1HFZR Register bits
    namespace apb1hfzr_bits {
        constexpr uint32_t DBG_I2C4_STOP = (1U << 1);  ///< I2C4 stop in debug
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 5);  ///< LPTIM2 stop in debug
    }

    /// APB2FZR Register bits
    namespace apb2fzr_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM8_STOP = (1U << 13);  ///< TIM8 stop in debug
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< TIM15 counter stopped when core is halted
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< TIM16 counter stopped when core is halted
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

    /// APB3FZR Register bits
    namespace apb3fzr_bits {
        constexpr uint32_t DBG_I2C3_STOP = (1U << 10);  ///< I2C3 stop in debug
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 17);  ///< LPTIM1 stop in debug
        constexpr uint32_t DBG_LPTIM3_STOP = (1U << 18);  ///< LPTIM3 stop in debug
        constexpr uint32_t DBG_LPTIM4_STOP = (1U << 19);  ///< LPTIM4 stop in debug
        constexpr uint32_t DBG_RTC_STOP = (1U << 30);  ///< RTC stop in debug
    }

    /// AHB1FZR Register bits
    namespace ahb1fzr_bits {
        constexpr uint32_t DBG_GPDMA0_STOP = (1U << 0);  ///< GPDMA channel 0 stop in debug
        constexpr uint32_t DBG_GPDMA1_STOP = (1U << 1);  ///< GPDMA channel 1 stop in debug
        constexpr uint32_t DBG_GPDMA2_STOP = (1U << 2);  ///< GPDMA channel 2 stop in debug
        constexpr uint32_t DBG_GPDMA3_STOP = (1U << 3);  ///< GPDMA channel 3 stop in debug
        constexpr uint32_t DBG_GPDMA4_STOP = (1U << 4);  ///< GPDMA channel 4 stop in debug
        constexpr uint32_t DBG_GPDMA5_STOP = (1U << 5);  ///< GPDMA channel 5 stop in debug
        constexpr uint32_t DBG_GPDMA6_STOP = (1U << 6);  ///< GPDMA channel 6 stop in debug
        constexpr uint32_t DBG_GPDMA7_STOP = (1U << 7);  ///< GPDMA channel 7 stop in debug
        constexpr uint32_t DBG_GPDMA8_STOP = (1U << 8);  ///< GPDMA channel 8 stop in debug
        constexpr uint32_t DBG_GPDMA9_STOP = (1U << 9);  ///< GPDMA channel 9 stop in debug
        constexpr uint32_t DBG_GPDMA10_STOP = (1U << 10);  ///< GPDMA channel 10 stop in debug
        constexpr uint32_t DBG_GPDMA11_STOP = (1U << 11);  ///< GPDMA channel 11 stop in debug
        constexpr uint32_t DBG_GPDMA12_STOP = (1U << 12);  ///< GPDMA channel 12 stop in debug
        constexpr uint32_t DBG_GPDMA13_STOP = (1U << 13);  ///< GPDMA channel 13 stop in debug
        constexpr uint32_t DBG_GPDMA14_STOP = (1U << 14);  ///< GPDMA channel 14 stop in debug
        constexpr uint32_t DBG_GPDMA15_STOP = (1U << 15);  ///< GPDMA channel 15 stop in debug
    }

    /// AHB3FZR Register bits
    namespace ahb3fzr_bits {
        constexpr uint32_t DBG_LPDMA0_STOP = (1U << 0);  ///< LPDMA channel 0 stop in debug
        constexpr uint32_t DBG_LPDMA1_STOP = (1U << 1);  ///< LPDMA channel 1 stop in debug
        constexpr uint32_t DBG_LPDMA2_STOP = (1U << 2);  ///< LPDMA channel 2 stop in debug
        constexpr uint32_t DBG_LPDMA3_STOP = (1U << 3);  ///< LPDMA channel 3 stop in debug
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t AP_PRESENT = (8 << 0);  ///< AP_PRESENT
        constexpr uint32_t AP_LOCKED = (8 << 8);  ///< AP_LOCKED
    }

    /// DBGMCU_DBG_AUTH_HOST Register bits
    namespace dbgmcu_dbg_auth_host_bits {
        constexpr uint32_t AUTH_KEY = (32 << 0);  ///< AUTH_KEY
    }

    /// DBG_AUTH_DEVICE Register bits
    namespace dbg_auth_device_bits {
        constexpr uint32_t AUTH_ID = (16 << 0);  ///< AUTH_ID
    }

    /// PIDR4 Register bits
    namespace pidr4_bits {
        constexpr uint32_t JEP106CON = (4 << 0);  ///< JEP106 continuation code
        constexpr uint32_t KCOUNT_4 = (4 << 4);  ///< register file size
    }

    /// PIDR0 Register bits
    namespace pidr0_bits {
        constexpr uint32_t PARTNUM = (8 << 0);  ///< part number bits [7:0]
    }

    /// PIDR1 Register bits
    namespace pidr1_bits {
        constexpr uint32_t PARTNUM = (4 << 0);  ///< part number bits [11:8]
        constexpr uint32_t JEP106ID = (4 << 4);  ///< JEP106 identity code bits [3:0]
    }

    /// PIDR2 Register bits
    namespace pidr2_bits {
        constexpr uint32_t JEP106ID = (3 << 0);  ///< JEP106 identity code bits [6:4]
        constexpr uint32_t JEDEC = (1U << 3);  ///< JEDEC assigned value
        constexpr uint32_t REVISION = (4 << 4);  ///< component revision number
    }

    /// PIDR3 Register bits
    namespace pidr3_bits {
        constexpr uint32_t CMOD = (4 << 0);  ///< customer modified
        constexpr uint32_t REVAND = (4 << 4);  ///< metal fix version
    }

    /// CIDR0 Register bits
    namespace cidr0_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [7:0]
    }

    /// CIDR1 Register bits
    namespace cidr1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< component identification bits [11:8]
        constexpr uint32_t CLASS = (4 << 4);  ///< component identification bits [15:12] - component class
    }

    /// CIDR2 Register bits
    namespace cidr2_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [23:16]
    }

    /// CIDR3 Register bits
    namespace cidr3_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [31:24]
    }

}

// ============================================================================
// DCACHE Peripheral
// ============================================================================

namespace dcache {
    /// Base addresses
    constexpr uint32_t DCACHE_BASE = 0x40031400;

    /// DCACHE Register structure
    struct Registers {
        volatile uint32_t DCACHE_CR;  ///< Offset: 0x00 - DCACHE control register
        volatile uint32_t DCACHE_SR;  ///< Offset: 0x04 - DCACHE status register
        volatile uint32_t DCACHE_IER;  ///< Offset: 0x08 - DCACHE interrupt enable register
        volatile uint32_t DCACHE_FCR;  ///< Offset: 0x0C - DCACHE flag clear register
        volatile uint32_t DCACHE_RHMONR;  ///< Offset: 0x10 - DCACHE read-hit monitor register
        volatile uint32_t DCACHE_RMMONR;  ///< Offset: 0x14 - DCACHE read-miss monitor register
        volatile uint32_t DCACHE_WHMONR;  ///< Offset: 0x20 - write-hit monitor register
        volatile uint32_t DCACHE_WMMONR;  ///< Offset: 0x24 - write-miss monitor register
        volatile uint32_t DCACHE_CMDRSADDRR;  ///< Offset: 0x28 - command range start address register
        volatile uint32_t DCACHE_CMDREADDRR;  ///< Offset: 0x2C - command range start address register
    };

    /// Peripheral instances
    inline Registers* DCACHE = reinterpret_cast<Registers*>(DCACHE_BASE);

    // Bit definitions
    /// DCACHE_CR Register bits
    namespace dcache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t CACHECMD = (3 << 8);  ///< CACHECMD
        constexpr uint32_t STARTCMD = (1U << 11);  ///< STARTCMD
        constexpr uint32_t RHITMEN = (1U << 16);  ///< RHITMEN
        constexpr uint32_t RMISSMEN = (1U << 17);  ///< RMISSMEN
        constexpr uint32_t RHITMRST = (1U << 18);  ///< RHITMRST
        constexpr uint32_t RMISSMRST = (1U << 19);  ///< RMISSMRST
        constexpr uint32_t WHITMEN = (1U << 20);  ///< WHITMEN
        constexpr uint32_t WMISSMEN = (1U << 21);  ///< WMISSMEN
        constexpr uint32_t WHITMRST = (1U << 22);  ///< WHITMRST
        constexpr uint32_t WMISSMRST = (1U << 23);  ///< WMISSMRST
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// DCACHE_SR Register bits
    namespace dcache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
        constexpr uint32_t BUSYCMDF = (1U << 3);  ///< BUSYCMDF
        constexpr uint32_t CMDENDF = (1U << 4);  ///< CMDENDF
    }

    /// DCACHE_IER Register bits
    namespace dcache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
        constexpr uint32_t CMDENDIE = (1U << 4);  ///< CMDENDIE
    }

    /// DCACHE_FCR Register bits
    namespace dcache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
        constexpr uint32_t CCMDENDF = (1U << 4);  ///< CCMDENDF
    }

    /// DCACHE_RHMONR Register bits
    namespace dcache_rhmonr_bits {
        constexpr uint32_t RHITMON = (32 << 0);  ///< RHITMON
    }

    /// DCACHE_RMMONR Register bits
    namespace dcache_rmmonr_bits {
        constexpr uint32_t MRISSMON = (16 << 0);  ///< RMISSMON
    }

    /// DCACHE_WHMONR Register bits
    namespace dcache_whmonr_bits {
        constexpr uint32_t WHITMON = (32 << 0);  ///< WHITMON
    }

    /// DCACHE_WMMONR Register bits
    namespace dcache_wmmonr_bits {
        constexpr uint32_t WMISSMON = (16 << 0);  ///< WMISSMON
    }

    /// DCACHE_CMDRSADDRR Register bits
    namespace dcache_cmdrsaddrr_bits {
        constexpr uint32_t CMDSTARTADDR = (28 << 4);  ///< CMDSTARTADDR
    }

    /// DCACHE_CMDREADDRR Register bits
    namespace dcache_cmdreaddrr_bits {
        constexpr uint32_t CMDENDADDR = (28 << 4);  ///< CMDENDADDR
    }

}

// ============================================================================
// DCMI Peripheral
// ============================================================================

namespace dcmi {
    /// Base addresses
    constexpr uint32_t DCMI_BASE = 0x4202C000;

    /// DCMI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - interrupt clear register
        volatile uint32_t ESCR;  ///< Offset: 0x18 - background offset register
        volatile uint32_t ESUR;  ///< Offset: 0x1C - embedded synchronization unmask register
        volatile uint32_t CWSTRT;  ///< Offset: 0x20 - crop window start
        volatile uint32_t CWSIZE;  ///< Offset: 0x24 - crop window size
        volatile uint32_t DR;  ///< Offset: 0x28 - data register
    };

    /// Peripheral instances
    inline Registers* DCMI = reinterpret_cast<Registers*>(DCMI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OELS = (1U << 20);  ///< Odd/Even Line Select (Line Select Start)
        constexpr uint32_t LSM = (1U << 19);  ///< Line Select mode
        constexpr uint32_t OEBS = (1U << 18);  ///< Odd/Even Byte Select (Byte Select Start)
        constexpr uint32_t BSM = (2 << 16);  ///< Byte Select mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< DCMI enable
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t FCRC = (2 << 8);  ///< Frame capture rate control
        constexpr uint32_t VSPOL = (1U << 7);  ///< Vertical synchronization polarity
        constexpr uint32_t HSPOL = (1U << 6);  ///< Horizontal synchronization polarity
        constexpr uint32_t PCKPOL = (1U << 5);  ///< Pixel clock polarity
        constexpr uint32_t ESS = (1U << 4);  ///< Embedded synchronization select
        constexpr uint32_t JPEG = (1U << 3);  ///< JPEG format
        constexpr uint32_t CROP = (1U << 2);  ///< Crop feature
        constexpr uint32_t CM = (1U << 1);  ///< Capture mode
        constexpr uint32_t CAPTURE = (1U << 0);  ///< Capture enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t FNE = (1U << 2);  ///< FIFO not empty
        constexpr uint32_t VSYNC = (1U << 1);  ///< Vertical synchronization
        constexpr uint32_t HSYNC = (1U << 0);  ///< Horizontal synchronization
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t LINE_RIS = (1U << 4);  ///< Line raw interrupt status
        constexpr uint32_t VSYNC_RIS = (1U << 3);  ///< DCMI_VSYNC raw interrupt status
        constexpr uint32_t ERR_RIS = (1U << 2);  ///< Synchronization error raw interrupt status
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< Overrun raw interrupt status
        constexpr uint32_t FRAME_RIS = (1U << 0);  ///< Capture complete raw interrupt status
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t LINE_IE = (1U << 4);  ///< Line interrupt enable
        constexpr uint32_t VSYNC_IE = (1U << 3);  ///< DCMI_VSYNC interrupt enable
        constexpr uint32_t ERR_IE = (1U << 2);  ///< Synchronization error interrupt enable
        constexpr uint32_t OVR_IE = (1U << 1);  ///< Overrun interrupt enable
        constexpr uint32_t FRAME_IE = (1U << 0);  ///< Capture complete interrupt enable
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t LINE_MIS = (1U << 4);  ///< Line masked interrupt status
        constexpr uint32_t VSYNC_MIS = (1U << 3);  ///< VSYNC masked interrupt status
        constexpr uint32_t ERR_MIS = (1U << 2);  ///< Synchronization error masked interrupt status
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< Overrun masked interrupt status
        constexpr uint32_t FRAME_MIS = (1U << 0);  ///< Capture complete masked interrupt status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t LINE_ISC = (1U << 4);  ///< line interrupt status clear
        constexpr uint32_t VSYNC_ISC = (1U << 3);  ///< Vertical Synchronization interrupt status clear
        constexpr uint32_t ERR_ISC = (1U << 2);  ///< Synchronization error interrupt status clear
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< Overrun interrupt status clear
        constexpr uint32_t FRAME_ISC = (1U << 0);  ///< Capture complete interrupt status clear
    }

    /// ESCR Register bits
    namespace escr_bits {
        constexpr uint32_t FEC = (8 << 24);  ///< Frame end delimiter code
        constexpr uint32_t LEC = (8 << 16);  ///< Line end delimiter code
        constexpr uint32_t LSC = (8 << 8);  ///< Line start delimiter code
        constexpr uint32_t FSC = (8 << 0);  ///< Frame start delimiter code
    }

    /// ESUR Register bits
    namespace esur_bits {
        constexpr uint32_t FEU = (8 << 24);  ///< Frame end delimiter unmask
        constexpr uint32_t LEU = (8 << 16);  ///< Line end delimiter unmask
        constexpr uint32_t LSU = (8 << 8);  ///< Line start delimiter unmask
        constexpr uint32_t FSU = (8 << 0);  ///< Frame start delimiter unmask
    }

    /// CWSTRT Register bits
    namespace cwstrt_bits {
        constexpr uint32_t VST = (13 << 16);  ///< Vertical start line count
        constexpr uint32_t HOFFCNT = (14 << 0);  ///< Horizontal offset count
    }

    /// CWSIZE Register bits
    namespace cwsize_bits {
        constexpr uint32_t VLINE = (14 << 16);  ///< Vertical line count
        constexpr uint32_t CAPCNT = (14 << 0);  ///< Capture count
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t BYTE3 = (8 << 24);  ///< Data byte 3
        constexpr uint32_t BYTE2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t BYTE1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t BYTE0 = (8 << 0);  ///< Data byte 0
    }

}

// ============================================================================
// DLYBOS Peripheral
// ============================================================================

namespace dlybos {
    /// Base addresses
    constexpr uint32_t DLYBOS_BASE = 0x420CF000;

    /// DLYBOS Register structure
    struct Registers {
        volatile uint32_t DLYB_CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DLYB_CFGR;  ///< Offset: 0x04 - configuration register
    };

    /// Peripheral instances
    inline Registers* DLYBOS = reinterpret_cast<Registers*>(DLYBOS_BASE);

    // Bit definitions
    /// DLYB_CR Register bits
    namespace dlyb_cr_bits {
        constexpr uint32_t DEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t SEN = (1U << 1);  ///< OPALPM
    }

    /// DLYB_CFGR Register bits
    namespace dlyb_cfgr_bits {
        constexpr uint32_t SEL = (4 << 0);  ///< SEL
        constexpr uint32_t UNIT = (7 << 8);  ///< UNIT
        constexpr uint32_t LNG = (12 << 16);  ///< LNG
        constexpr uint32_t LNGF = (1U << 31);  ///< LNGF
    }

}

// ============================================================================
// DLYBSD Peripheral
// ============================================================================

namespace dlybsd {
    /// Base addresses
    constexpr uint32_t DLYBSD_BASE = 0x420C8400;

    /// DLYBSD Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBSD = reinterpret_cast<Registers*>(DLYBSD_BASE);

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x46022000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t EXTI_FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t EXTI_SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t EXTI_RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t EXTI_FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTI_SECCFGR1;  ///< Offset: 0x14 - EXTI security configuration register
        volatile uint32_t EXTI_PRIVCFGR1;  ///< Offset: 0x18 - EXTI privilege configuration register
        volatile uint32_t EXTI_EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t EXTI_LOCKR;  ///< Offset: 0x70 - EXTI lock register
        volatile uint32_t EXTI_IMR1;  ///< Offset: 0x80 - EXTI CPU wake-up with interrupt mask register
        volatile uint32_t EXTI_EMR1;  ///< Offset: 0x84 - EXTI CPU wake-up with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// EXTI_RTSR1 Register bits
    namespace exti_rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT17 = (1U << 17);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT18 = (1U << 18);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT19 = (1U << 19);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT20 = (1U << 20);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT22 = (1U << 22);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT23 = (1U << 23);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT24 = (1U << 24);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT25 = (1U << 25);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_FTSR1 Register bits
    namespace exti_ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT17 = (1U << 17);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT18 = (1U << 18);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT19 = (1U << 19);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT20 = (1U << 20);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT22 = (1U << 22);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT23 = (1U << 23);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT24 = (1U << 24);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT25 = (1U << 25);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_SWIER1 Register bits
    namespace exti_swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI17 = (1U << 17);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI18 = (1U << 18);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI19 = (1U << 19);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI20 = (1U << 20);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI22 = (1U << 22);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI23 = (1U << 23);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI24 = (1U << 24);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI25 = (1U << 25);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_RPR1 Register bits
    namespace exti_rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF1 = (1U << 1);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF2 = (1U << 2);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF3 = (1U << 3);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF4 = (1U << 4);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF6 = (1U << 6);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF7 = (1U << 7);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF8 = (1U << 8);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF9 = (1U << 9);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF10 = (1U << 10);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF11 = (1U << 11);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF12 = (1U << 12);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF13 = (1U << 13);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF14 = (1U << 14);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF15 = (1U << 15);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF16 = (1U << 16);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF17 = (1U << 17);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF18 = (1U << 18);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF19 = (1U << 19);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF20 = (1U << 20);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF21 = (1U << 21);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF22 = (1U << 22);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF23 = (1U << 23);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF24 = (1U << 24);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF25 = (1U << 25);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_FPR1 Register bits
    namespace exti_fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF17 = (1U << 17);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF18 = (1U << 18);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF19 = (1U << 19);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF20 = (1U << 20);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF21 = (1U << 21);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF22 = (1U << 22);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF23 = (1U << 23);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF24 = (1U << 24);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF25 = (1U << 25);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_SECCFGR1 Register bits
    namespace exti_seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC1 = (1U << 1);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC2 = (1U << 2);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC3 = (1U << 3);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC4 = (1U << 4);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC5 = (1U << 5);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC6 = (1U << 6);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC7 = (1U << 7);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC8 = (1U << 8);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC9 = (1U << 9);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC10 = (1U << 10);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC11 = (1U << 11);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC12 = (1U << 12);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC13 = (1U << 13);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC14 = (1U << 14);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC15 = (1U << 15);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC16 = (1U << 16);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC17 = (1U << 17);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC18 = (1U << 18);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC19 = (1U << 19);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC20 = (1U << 20);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC21 = (1U << 21);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC22 = (1U << 22);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC23 = (1U << 23);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC24 = (1U << 24);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC25 = (1U << 25);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_PRIVCFGR1 Register bits
    namespace exti_privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV1 = (1U << 1);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV2 = (1U << 2);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV3 = (1U << 3);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV4 = (1U << 4);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV5 = (1U << 5);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV6 = (1U << 6);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV7 = (1U << 7);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV8 = (1U << 8);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV9 = (1U << 9);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV10 = (1U << 10);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV11 = (1U << 11);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV12 = (1U << 12);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV13 = (1U << 13);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV14 = (1U << 14);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV15 = (1U << 15);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV16 = (1U << 16);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV17 = (1U << 17);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV18 = (1U << 18);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV19 = (1U << 19);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV20 = (1U << 20);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV21 = (1U << 21);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV22 = (1U << 22);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV23 = (1U << 23);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV24 = (1U << 24);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV25 = (1U << 25);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_EXTICR1 Register bits
    namespace exti_exticr1_bits {
        constexpr uint32_t EXTI0 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI1 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI2 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI3 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR2 Register bits
    namespace exti_exticr2_bits {
        constexpr uint32_t EXTI4 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI5 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI6 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI7 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR3 Register bits
    namespace exti_exticr3_bits {
        constexpr uint32_t EXTI8 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI9 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI10 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI11 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR4 Register bits
    namespace exti_exticr4_bits {
        constexpr uint32_t EXTI12 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI13 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI14 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI15 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_LOCKR Register bits
    namespace exti_lockr_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Global security and privilege configuration registers (EXTI_SECCFGR and EXTI_PRIVCFGR) lock This bit is written once after reset.
    }

    /// EXTI_IMR1 Register bits
    namespace exti_imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM17 = (1U << 17);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM18 = (1U << 18);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_EMR1 Register bits
    namespace exti_emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM17 = (1U << 17);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM18 = (1U << 18);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM20 = (1U << 20);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM22 = (1U << 22);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM24 = (1U << 24);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t FDCAN1_RAM_BASE = 0x4000AC00;
    constexpr uint32_t SEC_FDCAN1_RAM_BASE = 0x5000AC00;
    constexpr uint32_t FDCAN1_BASE = 0x4000A400;
    constexpr uint32_t SEC_FDCAN1_BASE = 0x5000A400;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t FDCAN_CREL;  ///< Offset: 0x00 - FDCAN Core Release Register
        volatile uint32_t FDCAN_ENDN;  ///< Offset: 0x04 - FDCAN endian register
        volatile uint32_t FDCAN_DBTP;  ///< Offset: 0x0C - FDCAN Data Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TEST;  ///< Offset: 0x10 - FDCAN Test Register
        volatile uint32_t FDCAN_RWD;  ///< Offset: 0x14 - FDCAN RAM Watchdog Register
        volatile uint32_t FDCAN_CCCR;  ///< Offset: 0x18 - FDCAN CC Control Register
        volatile uint32_t FDCAN_NBTP;  ///< Offset: 0x1C - FDCAN Nominal Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TSCC;  ///< Offset: 0x20 - FDCAN Timestamp Counter Configuration Register
        volatile uint32_t FDCAN_TSCV;  ///< Offset: 0x24 - FDCAN Timestamp Counter Value Register
        volatile uint32_t FDCAN_TOCC;  ///< Offset: 0x28 - FDCAN Timeout Counter Configuration Register
        volatile uint32_t FDCAN_TOCV;  ///< Offset: 0x2C - FDCAN Timeout Counter Value Register
        volatile uint32_t FDCAN_ECR;  ///< Offset: 0x40 - FDCAN Error Counter Register
        volatile uint32_t FDCAN_PSR;  ///< Offset: 0x44 - FDCAN Protocol Status Register
        volatile uint32_t FDCAN_TDCR;  ///< Offset: 0x48 - FDCAN Transmitter Delay Compensation Register
        volatile uint32_t FDCAN_IR;  ///< Offset: 0x50 - FDCAN Interrupt Register
        volatile uint32_t FDCAN_IE;  ///< Offset: 0x54 - FDCAN Interrupt Enable Register
        volatile uint32_t FDCAN_ILS;  ///< Offset: 0x58 - FDCAN Interrupt Line Select Register
        volatile uint32_t FDCAN_ILE;  ///< Offset: 0x5C - FDCAN Interrupt Line Enable Register
        volatile uint32_t FDCAN_RXGFC;  ///< Offset: 0x80 - FDCAN Global Filter Configuration Register
        volatile uint32_t FDCAN_XIDAM;  ///< Offset: 0x84 - FDCAN Extended ID and Mask Register
        volatile uint32_t FDCAN_HPMS;  ///< Offset: 0x88 - FDCAN High Priority Message Status Register
        volatile uint32_t FDCAN_RXF0S;  ///< Offset: 0x90 - FDCAN Rx FIFO 0 Status Register
        volatile uint32_t FDCAN_RXF0A;  ///< Offset: 0x94 - CAN Rx FIFO 0 Acknowledge Register
        volatile uint32_t FDCAN_RXF1S;  ///< Offset: 0x98 - FDCAN Rx FIFO 1 Status Register
        volatile uint32_t FDCAN_RXF1A;  ///< Offset: 0x9C - FDCAN Rx FIFO 1 Acknowledge Register
        volatile uint32_t FDCAN_TXBC;  ///< Offset: 0xC0 - FDCAN Tx buffer configuration register
        volatile uint32_t FDCAN_TXFQS;  ///< Offset: 0xC4 - FDCAN Tx FIFO/Queue Status Register
        volatile uint32_t FDCAN_TXBRP;  ///< Offset: 0xC8 - FDCAN Tx Buffer Request Pending Register
        volatile uint32_t FDCAN_TXBAR;  ///< Offset: 0xCC - FDCAN Tx Buffer Add Request Register
        volatile uint32_t FDCAN_TXBCR;  ///< Offset: 0xD0 - FDCAN Tx Buffer Cancellation Request Register
        volatile uint32_t FDCAN_TXBTO;  ///< Offset: 0xD4 - FDCAN Tx Buffer Transmission Occurred Register
        volatile uint32_t FDCAN_TXBCF;  ///< Offset: 0xD8 - FDCAN Tx Buffer Cancellation Finished Register
        volatile uint32_t FDCAN_TXBTIE;  ///< Offset: 0xDC - FDCAN Tx Buffer Transmission Interrupt Enable Register
        volatile uint32_t FDCAN_TXBCIE;  ///< Offset: 0xE0 - FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        volatile uint32_t FDCAN_TXEFS;  ///< Offset: 0xE4 - FDCAN Tx Event FIFO Status Register
        volatile uint32_t FDCAN_TXEFA;  ///< Offset: 0xE8 - FDCAN Tx Event FIFO Acknowledge Register
        volatile uint32_t FDCAN_CKDIV;  ///< Offset: 0x100 - FDCAN CFG clock divider register
    };

    /// Peripheral instances
    inline Registers* FDCAN1_RAM = reinterpret_cast<Registers*>(FDCAN1_RAM_BASE);
    inline Registers* SEC_FDCAN1_RAM = reinterpret_cast<Registers*>(SEC_FDCAN1_RAM_BASE);
    inline Registers* FDCAN1 = reinterpret_cast<Registers*>(FDCAN1_BASE);
    inline Registers* SEC_FDCAN1 = reinterpret_cast<Registers*>(SEC_FDCAN1_BASE);

    // Bit definitions
    /// FDCAN_CREL Register bits
    namespace fdcan_crel_bits {
        constexpr uint32_t REL = (4 << 28);  ///< Core release
        constexpr uint32_t STEP = (4 << 24);  ///< Step of Core release
        constexpr uint32_t SUBSTEP = (4 << 20);  ///< Sub-step of Core release
        constexpr uint32_t YEAR = (4 << 16);  ///< Timestamp Year
        constexpr uint32_t MON = (8 << 8);  ///< Timestamp Month
        constexpr uint32_t DAY = (8 << 0);  ///< Timestamp Day
    }

    /// FDCAN_ENDN Register bits
    namespace fdcan_endn_bits {
        constexpr uint32_t ETV = (32 << 0);  ///< Endiannes Test Value
    }

    /// FDCAN_DBTP Register bits
    namespace fdcan_dbtp_bits {
        constexpr uint32_t DSJW = (4 << 0);  ///< Synchronization Jump Width
        constexpr uint32_t DTSEG2 = (4 << 4);  ///< Data time segment after sample point
        constexpr uint32_t DTSEG1 = (5 << 8);  ///< Data time segment after sample point
        constexpr uint32_t DBRP = (5 << 16);  ///< Data BIt Rate Prescaler
        constexpr uint32_t TDC = (1U << 23);  ///< Transceiver Delay Compensation
    }

    /// FDCAN_TEST Register bits
    namespace fdcan_test_bits {
        constexpr uint32_t LBCK = (1U << 4);  ///< Loop Back mode
        constexpr uint32_t TX = (2 << 5);  ///< Loop Back mode
        constexpr uint32_t RX = (1U << 7);  ///< Control of Transmit Pin
    }

    /// FDCAN_RWD Register bits
    namespace fdcan_rwd_bits {
        constexpr uint32_t WDV = (8 << 8);  ///< Watchdog value
        constexpr uint32_t WDC = (8 << 0);  ///< Watchdog configuration
    }

    /// FDCAN_CCCR Register bits
    namespace fdcan_cccr_bits {
        constexpr uint32_t INIT = (1U << 0);  ///< Initialization
        constexpr uint32_t CCE = (1U << 1);  ///< Configuration Change Enable
        constexpr uint32_t ASM = (1U << 2);  ///< ASM Restricted Operation Mode
        constexpr uint32_t CSA = (1U << 3);  ///< Clock Stop Acknowledge
        constexpr uint32_t CSR = (1U << 4);  ///< Clock Stop Request
        constexpr uint32_t MON = (1U << 5);  ///< Bus Monitoring Mode
        constexpr uint32_t DAR = (1U << 6);  ///< Disable Automatic Retransmission
        constexpr uint32_t TEST = (1U << 7);  ///< Test Mode Enable
        constexpr uint32_t FDOE = (1U << 8);  ///< FD Operation Enable
        constexpr uint32_t BRSE = (1U << 9);  ///< FDCAN Bit Rate Switching
        constexpr uint32_t PXHD = (1U << 12);  ///< Protocol Exception Handling Disable
        constexpr uint32_t EFBI = (1U << 13);  ///< Edge Filtering during Bus Integration
        constexpr uint32_t TXP = (1U << 14);  ///< TXP
        constexpr uint32_t NISO = (1U << 15);  ///< Non ISO Operation
    }

    /// FDCAN_NBTP Register bits
    namespace fdcan_nbtp_bits {
        constexpr uint32_t NSJW = (7 << 25);  ///< Nominal (Re)Synchronization Jump Width
        constexpr uint32_t NBRP = (9 << 16);  ///< Bit Rate Prescaler
        constexpr uint32_t NTSEG1 = (8 << 8);  ///< Nominal Time segment before sample point
        constexpr uint32_t NTSEG2 = (7 << 0);  ///< Nominal Time segment after sample point
    }

    /// FDCAN_TSCC Register bits
    namespace fdcan_tscc_bits {
        constexpr uint32_t TCP = (4 << 16);  ///< Timestamp Counter Prescaler
        constexpr uint32_t TSS = (2 << 0);  ///< Timestamp Select
    }

    /// FDCAN_TSCV Register bits
    namespace fdcan_tscv_bits {
        constexpr uint32_t TSC = (16 << 0);  ///< Timestamp Counter
    }

    /// FDCAN_TOCC Register bits
    namespace fdcan_tocc_bits {
        constexpr uint32_t ETOC = (1U << 0);  ///< Enable Timeout Counter
        constexpr uint32_t TOS = (2 << 1);  ///< Timeout Select
        constexpr uint32_t TOP = (16 << 16);  ///< Timeout Period
    }

    /// FDCAN_TOCV Register bits
    namespace fdcan_tocv_bits {
        constexpr uint32_t TOC = (16 << 0);  ///< Timeout Counter
    }

    /// FDCAN_ECR Register bits
    namespace fdcan_ecr_bits {
        constexpr uint32_t CEL = (8 << 16);  ///< AN Error Logging
        constexpr uint32_t RP = (1U << 15);  ///< Receive Error Passive
        constexpr uint32_t REC = (7 << 8);  ///< Receive Error Counter
        constexpr uint32_t TEC = (8 << 0);  ///< Transmit Error Counter
    }

    /// FDCAN_PSR Register bits
    namespace fdcan_psr_bits {
        constexpr uint32_t LEC = (3 << 0);  ///< Last Error Code
        constexpr uint32_t ACT = (2 << 3);  ///< Activity
        constexpr uint32_t EP = (1U << 5);  ///< Error Passive
        constexpr uint32_t EW = (1U << 6);  ///< Warning Status
        constexpr uint32_t BO = (1U << 7);  ///< Bus_Off Status
        constexpr uint32_t DLEC = (3 << 8);  ///< Data Last Error Code
        constexpr uint32_t RESI = (1U << 11);  ///< ESI flag of last received FDCAN Message
        constexpr uint32_t RBRS = (1U << 12);  ///< BRS flag of last received FDCAN Message
        constexpr uint32_t REDL = (1U << 13);  ///< Received FDCAN Message
        constexpr uint32_t PXE = (1U << 14);  ///< Protocol Exception Event
        constexpr uint32_t TDCV = (7 << 16);  ///< Transmitter Delay Compensation Value
    }

    /// FDCAN_TDCR Register bits
    namespace fdcan_tdcr_bits {
        constexpr uint32_t TDCF = (7 << 0);  ///< Transmitter Delay Compensation Filter Window Length
        constexpr uint32_t TDCO = (7 << 8);  ///< Transmitter Delay Compensation Offset
    }

    /// FDCAN_IR Register bits
    namespace fdcan_ir_bits {
        constexpr uint32_t RF0N = (1U << 0);  ///< RF0N
        constexpr uint32_t RF0F = (1U << 1);  ///< RF0F
        constexpr uint32_t RF0L = (1U << 2);  ///< RF0L
        constexpr uint32_t RF1N = (1U << 3);  ///< RF1N
        constexpr uint32_t RF1F = (1U << 4);  ///< RF1F
        constexpr uint32_t RF1L = (1U << 5);  ///< RF1L
        constexpr uint32_t HPM = (1U << 6);  ///< HPM
        constexpr uint32_t TC = (1U << 7);  ///< TC
        constexpr uint32_t TCF = (1U << 8);  ///< TCF
        constexpr uint32_t TFE = (1U << 9);  ///< TFE
        constexpr uint32_t TEFN = (1U << 10);  ///< TEFN
        constexpr uint32_t TEFF = (1U << 11);  ///< TEFF
        constexpr uint32_t TEFL = (1U << 12);  ///< TEFL
        constexpr uint32_t TSW = (1U << 13);  ///< TSW
        constexpr uint32_t MRAF = (1U << 14);  ///< MRAF
        constexpr uint32_t TOO = (1U << 15);  ///< TOO
        constexpr uint32_t ELO = (1U << 16);  ///< ELO
        constexpr uint32_t EP = (1U << 17);  ///< EP
        constexpr uint32_t EW = (1U << 18);  ///< EW
        constexpr uint32_t BO = (1U << 19);  ///< BO
        constexpr uint32_t WDI = (1U << 20);  ///< WDI
        constexpr uint32_t PEA = (1U << 21);  ///< PEA
        constexpr uint32_t PED = (1U << 22);  ///< PED
        constexpr uint32_t ARA = (1U << 23);  ///< ARA
    }

    /// FDCAN_IE Register bits
    namespace fdcan_ie_bits {
        constexpr uint32_t RF0NE = (1U << 0);  ///< Rx FIFO 0 New Message Enable
        constexpr uint32_t RF0FE = (1U << 1);  ///< Rx FIFO 0 Full Enable
        constexpr uint32_t RF0LE = (1U << 2);  ///< Rx FIFO 0 Message Lost Enable
        constexpr uint32_t RF1NE = (1U << 3);  ///< Rx FIFO 1 New Message Enable
        constexpr uint32_t RF1FE = (1U << 4);  ///< Rx FIFO 1 Watermark Reached Enable
        constexpr uint32_t RF1LE = (1U << 5);  ///< Rx FIFO 1 Message Lost Enable
        constexpr uint32_t HPME = (1U << 6);  ///< High Priority Message Enable
        constexpr uint32_t TCE = (1U << 7);  ///< Transmission Completed Enable
        constexpr uint32_t TCFE = (1U << 8);  ///< Transmission Cancellation Finished Enable
        constexpr uint32_t TEFE = (1U << 9);  ///< Tx FIFO Empty Enable
        constexpr uint32_t TEFNE = (1U << 10);  ///< Tx Event FIFO New Entry Enable
        constexpr uint32_t TEFFE = (1U << 11);  ///< Tx Event FIFO Full Enable
        constexpr uint32_t TEFLE = (1U << 12);  ///< Tx Event FIFO Element Lost Enable
        constexpr uint32_t TSWE = (1U << 13);  ///< TSWE
        constexpr uint32_t MRAFE = (1U << 14);  ///< Message RAM Access Failure Enable
        constexpr uint32_t TOOE = (1U << 15);  ///< Timeout Occurred Enable
        constexpr uint32_t ELOE = (1U << 16);  ///< Error Logging Overflow Enable
        constexpr uint32_t EPE = (1U << 17);  ///< Error Passive Enable
        constexpr uint32_t EWE = (1U << 18);  ///< Warning Status Enable
        constexpr uint32_t BOE = (1U << 19);  ///< Bus_Off Status Enable
        constexpr uint32_t WDIE = (1U << 20);  ///< Watchdog Interrupt Enable
        constexpr uint32_t PEAE = (1U << 21);  ///< Protocol Error in Arbitration Phase Enable
        constexpr uint32_t PEDE = (1U << 22);  ///< Protocol Error in Data Phase Enable
        constexpr uint32_t ARAE = (1U << 23);  ///< Access to Reserved Address Enable
    }

    /// FDCAN_ILS Register bits
    namespace fdcan_ils_bits {
        constexpr uint32_t RxFIFO0 = (1U << 0);  ///< RxFIFO0
        constexpr uint32_t RxFIFO1 = (1U << 1);  ///< RxFIFO1
        constexpr uint32_t SMSG = (1U << 2);  ///< SMSG
        constexpr uint32_t TFERR = (1U << 3);  ///< TFERR
        constexpr uint32_t MISC = (1U << 4);  ///< MISC
        constexpr uint32_t BERR = (1U << 5);  ///< BERR
        constexpr uint32_t PERR = (1U << 6);  ///< PERR
    }

    /// FDCAN_ILE Register bits
    namespace fdcan_ile_bits {
        constexpr uint32_t EINT0 = (1U << 0);  ///< Enable Interrupt Line 0
        constexpr uint32_t EINT1 = (1U << 1);  ///< Enable Interrupt Line 1
    }

    /// FDCAN_RXGFC Register bits
    namespace fdcan_rxgfc_bits {
        constexpr uint32_t RRFE = (1U << 0);  ///< Reject Remote Frames Extended
        constexpr uint32_t RRFS = (1U << 1);  ///< Reject Remote Frames Standard
        constexpr uint32_t ANFE = (2 << 2);  ///< Accept Non-matching Frames Extended
        constexpr uint32_t ANFS = (2 << 4);  ///< Accept Non-matching Frames Standard
        constexpr uint32_t F1OM = (1U << 8);  ///< F1OM
        constexpr uint32_t F0OM = (1U << 9);  ///< F0OM
        constexpr uint32_t LSS = (5 << 16);  ///< LSS
        constexpr uint32_t LSE = (4 << 24);  ///< LSE
    }

    /// FDCAN_XIDAM Register bits
    namespace fdcan_xidam_bits {
        constexpr uint32_t EIDM = (29 << 0);  ///< Extended ID Mask
    }

    /// FDCAN_HPMS Register bits
    namespace fdcan_hpms_bits {
        constexpr uint32_t BIDX = (3 << 0);  ///< Buffer Index
        constexpr uint32_t MSI = (2 << 6);  ///< Message Storage Indicator
        constexpr uint32_t FIDX = (5 << 8);  ///< Filter Index
        constexpr uint32_t FLST = (1U << 15);  ///< Filter List
    }

    /// FDCAN_RXF0S Register bits
    namespace fdcan_rxf0s_bits {
        constexpr uint32_t F0FL = (4 << 0);  ///< Rx FIFO 0 Fill Level
        constexpr uint32_t F0GI = (2 << 8);  ///< Rx FIFO 0 Get Index
        constexpr uint32_t F0PI = (2 << 16);  ///< Rx FIFO 0 Put Index
        constexpr uint32_t F0F = (1U << 24);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0L = (1U << 25);  ///< Rx FIFO 0 Message Lost
    }

    /// FDCAN_RXF0A Register bits
    namespace fdcan_rxf0a_bits {
        constexpr uint32_t F0AI = (3 << 0);  ///< Rx FIFO 0 Acknowledge Index
    }

    /// FDCAN_RXF1S Register bits
    namespace fdcan_rxf1s_bits {
        constexpr uint32_t F1FL = (4 << 0);  ///< Rx FIFO 1 Fill Level
        constexpr uint32_t F1GI = (2 << 8);  ///< Rx FIFO 1 Get Index
        constexpr uint32_t F1PI = (2 << 16);  ///< Rx FIFO 1 Put Index
        constexpr uint32_t F1F = (1U << 24);  ///< Rx FIFO 1 Full
        constexpr uint32_t RF1L = (1U << 25);  ///< Rx FIFO 1 Message Lost
    }

    /// FDCAN_RXF1A Register bits
    namespace fdcan_rxf1a_bits {
        constexpr uint32_t F1AI = (3 << 0);  ///< Rx FIFO 1 Acknowledge Index
    }

    /// FDCAN_TXBC Register bits
    namespace fdcan_txbc_bits {
        constexpr uint32_t TFQM = (1U << 24);  ///< Tx FIFO/Queue Mode
    }

    /// FDCAN_TXFQS Register bits
    namespace fdcan_txfqs_bits {
        constexpr uint32_t TFFL = (3 << 0);  ///< Tx FIFO Free Level
        constexpr uint32_t TFGI = (2 << 8);  ///< TFGI
        constexpr uint32_t TFQPI = (2 << 16);  ///< Tx FIFO/Queue Put Index
        constexpr uint32_t TFQF = (1U << 21);  ///< Tx FIFO/Queue Full
    }

    /// FDCAN_TXBRP Register bits
    namespace fdcan_txbrp_bits {
        constexpr uint32_t TRP = (3 << 0);  ///< Transmission Request Pending
    }

    /// FDCAN_TXBAR Register bits
    namespace fdcan_txbar_bits {
        constexpr uint32_t AR = (3 << 0);  ///< Add Request
    }

    /// FDCAN_TXBCR Register bits
    namespace fdcan_txbcr_bits {
        constexpr uint32_t CR = (3 << 0);  ///< Cancellation Request
    }

    /// FDCAN_TXBTO Register bits
    namespace fdcan_txbto_bits {
        constexpr uint32_t TO = (3 << 0);  ///< Transmission Occurred.
    }

    /// FDCAN_TXBCF Register bits
    namespace fdcan_txbcf_bits {
        constexpr uint32_t CF = (3 << 0);  ///< Cancellation Finished
    }

    /// FDCAN_TXBTIE Register bits
    namespace fdcan_txbtie_bits {
        constexpr uint32_t TIE = (3 << 0);  ///< Transmission Interrupt Enable
    }

    /// FDCAN_TXBCIE Register bits
    namespace fdcan_txbcie_bits {
        constexpr uint32_t CFIE = (3 << 0);  ///< Cancellation Finished Interrupt Enable
    }

    /// FDCAN_TXEFS Register bits
    namespace fdcan_txefs_bits {
        constexpr uint32_t EFFL = (3 << 0);  ///< Event FIFO Fill Level
        constexpr uint32_t EFGI = (2 << 8);  ///< Event FIFO Get Index.
        constexpr uint32_t EFPI = (2 << 16);  ///< Event FIFO Put Index
        constexpr uint32_t EFF = (1U << 24);  ///< Event FIFO Full.
        constexpr uint32_t TEFL = (1U << 25);  ///< Tx Event FIFO Element Lost.
    }

    /// FDCAN_TXEFA Register bits
    namespace fdcan_txefa_bits {
        constexpr uint32_t EFAI = (2 << 0);  ///< Event FIFO Acknowledge Index
    }

    /// FDCAN_CKDIV Register bits
    namespace fdcan_ckdiv_bits {
        constexpr uint32_t PDIV = (4 << 0);  ///< PDIV
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;
    constexpr uint32_t SEC_FLASH_BASE = 0x50022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASH_ACR;  ///< Offset: 0x00 - FLASH access control register
        volatile uint32_t FLASH_NSKEYR;  ///< Offset: 0x08 - FLASH non-secure key register
        volatile uint32_t FLASH_SECKEYR;  ///< Offset: 0x0C - FLASH secure key register
        volatile uint32_t FLASH_OPTKEYR;  ///< Offset: 0x10 - FLASH option key register
        volatile uint32_t FLASH_PDKEY1R;  ///< Offset: 0x18 - FLASH bank 1 power-down key register
        volatile uint32_t FLASH_PDKEY2R;  ///< Offset: 0x1C - FLASH bank 2 power-down key register
        volatile uint32_t FLASH_NSSR;  ///< Offset: 0x20 - FLASH non-secure status register
        volatile uint32_t FLASH_SECSR;  ///< Offset: 0x24 - FLASH secure status register
        volatile uint32_t FLASH_NSCR;  ///< Offset: 0x28 - FLASH non-secure control register
        volatile uint32_t FLASH_SECCR;  ///< Offset: 0x2C - FLASH secure control register
        volatile uint32_t FLASH_ECCR;  ///< Offset: 0x30 - FLASH ECC register
        volatile uint32_t FLASH_OPSR;  ///< Offset: 0x34 - FLASH operation status register
        volatile uint32_t FLASH_OPTR;  ///< Offset: 0x40 - FLASH option register
        volatile uint32_t FLASH_NSBOOTADD0R;  ///< Offset: 0x44 - FLASH non-secure boot address 0 register
        volatile uint32_t FLASH_NSBOOTADD1R;  ///< Offset: 0x48 - FLASH non-secure boot address 1 register
        volatile uint32_t FLASH_SECBOOTADD0R;  ///< Offset: 0x4C - FLASH secure boot address 0 register
        volatile uint32_t FLASH_SECWM1R1;  ///< Offset: 0x50 - FLASH secure watermark1 register 1
        volatile uint32_t FLASH_SECWM1R2;  ///< Offset: 0x54 - FLASH secure watermark1 register 2
        volatile uint32_t FLASH_WRP1AR;  ///< Offset: 0x58 - FLASH WRP1 area A address register
        volatile uint32_t FLASH_WRP1BR;  ///< Offset: 0x5C - FLASH WRP1 area B address register
        volatile uint32_t FLASH_SECWM2R1;  ///< Offset: 0x60 - FLASH secure watermark2 register 1
        volatile uint32_t FLASH_SECWM2R2;  ///< Offset: 0x64 - FLASH secure watermark2 register 2
        volatile uint32_t FLASH_WRP2AR;  ///< Offset: 0x68 - FLASH WPR2 area A address register
        volatile uint32_t FLASH_WRP2BR;  ///< Offset: 0x6C - FLASH WPR2 area B address register
        volatile uint32_t FLASH_OEM1KEYR1;  ///< Offset: 0x70 - FLASH OEM1 key register 1
        volatile uint32_t FLASH_OEM1KEYR2;  ///< Offset: 0x74 - FLASH OEM1 key register 2
        volatile uint32_t FLASH_OEM2KEYR1;  ///< Offset: 0x78 - FLASH OEM2 key register 1
        volatile uint32_t FLASH_OEM2KEYR2;  ///< Offset: 0x7C - FLASH OEM2 key register 2
        volatile uint32_t FLASH_SEC1BBR1;  ///< Offset: 0x80 - FLASH secure block based bank 1 register 1
        volatile uint32_t FLASH_SEC1BBR2;  ///< Offset: 0x84 - FLASH secure block based bank 1 register 2
        volatile uint32_t FLASH_SEC1BBR3;  ///< Offset: 0x88 - FLASH secure block based bank 1 register 3
        volatile uint32_t FLASH_SEC1BBR4;  ///< Offset: 0x8C - FLASH secure block based bank 1 register 4
        volatile uint32_t FLASH_SEC1BBR5;  ///< Offset: 0x90 - FLASH secure block based bank 1 register 5
        volatile uint32_t FLASH_SEC1BBR6;  ///< Offset: 0x94 - FLASH secure block based bank 1 register 6
        volatile uint32_t FLASH_SEC1BBR7;  ///< Offset: 0x98 - FLASH secure block based bank 1 register 7
        volatile uint32_t FLASH_SEC1BBR8;  ///< Offset: 0x9C - FLASH secure block based bank 1 register 8
        volatile uint32_t FLASH_SEC2BBR1;  ///< Offset: 0xA0 - FLASH secure block based bank 2 register 1
        volatile uint32_t FLASH_SEC2BBR2;  ///< Offset: 0xA4 - FLASH secure block based bank 2 register 2
        volatile uint32_t FLASH_SEC2BBR3;  ///< Offset: 0xA8 - FLASH secure block based bank 2 register 3
        volatile uint32_t FLASH_SEC2BBR4;  ///< Offset: 0xAC - FLASH secure block based bank 2 register 4
        volatile uint32_t FLASH_SEC2BBR5;  ///< Offset: 0xB0 - FLASH secure block based bank 2 register 5
        volatile uint32_t FLASH_SEC2BBR6;  ///< Offset: 0xB4 - FLASH secure block based bank 2 register 6
        volatile uint32_t FLASH_SEC2BBR7;  ///< Offset: 0xB8 - FLASH secure block based bank 2 register 7
        volatile uint32_t FLASH_SEC2BBR8;  ///< Offset: 0xBC - FLASH secure block based bank 2 register 8
        volatile uint32_t FLASH_SECHDPCR;  ///< Offset: 0xC0 - FLASH secure HDP control register
        volatile uint32_t FLASH_PRIVCFGR;  ///< Offset: 0xC4 - FLASH privilege configuration register
        volatile uint32_t FLASH_PRIV1BBR1;  ///< Offset: 0xD0 - FLASH privilege block based bank 1 register 1
        volatile uint32_t FLASH_PRIV1BBR2;  ///< Offset: 0xD4 - FLASH privilege block based bank 1 register 2
        volatile uint32_t FLASH_PRIV1BBR3;  ///< Offset: 0xD8 - FLASH privilege block based bank 1 register 3
        volatile uint32_t FLASH_PRIV1BBR4;  ///< Offset: 0xDC - FLASH privilege block based bank 1 register 4
        volatile uint32_t FLASH_PRIV1BBR5;  ///< Offset: 0xE0 - FLASH privilege block based bank 1 register 5
        volatile uint32_t FLASH_PRIV1BBR6;  ///< Offset: 0xE4 - FLASH privilege block based bank 1 register 6
        volatile uint32_t FLASH_PRIV1BBR7;  ///< Offset: 0xE8 - FLASH privilege block based bank 1 register 7
        volatile uint32_t FLASH_PRIV1BBR8;  ///< Offset: 0xEC - FLASH privilege block based bank 1 register 8
        volatile uint32_t FLASH_PRIV2BBR1;  ///< Offset: 0xF0 - FLASH privilege block based bank 2 register 1
        volatile uint32_t FLASH_PRIV2BBR2;  ///< Offset: 0xF4 - FLASH privilege block based bank 2 register 2
        volatile uint32_t FLASH_PRIV2BBR3;  ///< Offset: 0xF8 - FLASH privilege block based bank 2 register 3
        volatile uint32_t FLASH_PRIV2BBR4;  ///< Offset: 0xFC - FLASH privilege block based bank 2 register 4
        volatile uint32_t FLASH_PRIV2BBR5;  ///< Offset: 0x100 - FLASH privilege block based bank 2 register 5
        volatile uint32_t FLASH_PRIV2BBR6;  ///< Offset: 0x104 - FLASH privilege block based bank 2 register 6
        volatile uint32_t FLASH_PRIV2BBR7;  ///< Offset: 0x108 - FLASH privilege block based bank 2 register 7
        volatile uint32_t FLASH_PRIV2BBR8;  ///< Offset: 0x10C - FLASH privilege block based bank 2 register 8
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);
    inline Registers* SEC_FLASH = reinterpret_cast<Registers*>(SEC_FLASH_BASE);

    // Bit definitions
    /// FLASH_ACR Register bits
    namespace flash_acr_bits {
        constexpr uint32_t LATENCY = (4 << 0);  ///< Latency These bits represent the ratio between the HCLK (AHB clock) period and the Flash memory access time. ...
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable This bit enables the prefetch buffer in the embedded Flash memory.
        constexpr uint32_t LPM = (1U << 11);  ///< Low-power read mode This bit puts the Flash memory in low-power read mode.
        constexpr uint32_t PDREQ1 = (1U << 12);  ///< Bank 1 power-down mode request This bit is write-protected with FLASH_PDKEY1R. This bit requests bank 1 to enter power-down mode. When bank 1 enters power-down mode, this bit is cleared by hardware and the PDKEY1R is locked.
        constexpr uint32_t PDREQ2 = (1U << 13);  ///< Bank 2 power-down mode request This bit is write-protected with FLASH_PDKEY2R. This bit requests bank 2 to enter power-down mode. When bank 2 enters power-down mode, this bit is cleared by hardware and the PDKEY2R is locked.
        constexpr uint32_t SLEEP_PD = (1U << 14);  ///< Flash memory power-down mode during Sleep mode This bit determines whether the Flash memory is in power-down mode or Idle mode when the device is in Sleep mode. The Flash must not be put in power-down while a program or an erase operation is on-going.
    }

    /// FLASH_NSKEYR Register bits
    namespace flash_nskeyr_bits {
        constexpr uint32_t NSKEY = (32 << 0);  ///< Flash memory non-secure key The following values must be written consecutively to unlock the FLASH_NSCR register, allowing the Flash memory non-secure programming/erasing operations: KEY1: 0x4567 0123 KEY2: 0xCDEF 89AB
    }

    /// FLASH_SECKEYR Register bits
    namespace flash_seckeyr_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Flash memory secure key The following values must be written consecutively to unlock the FLASH_SECCR register, allowing the Flash memory secure programming/erasing operations: KEY1: 0x4567 0123 KEY2: 0xCDEF 89AB
    }

    /// FLASH_OPTKEYR Register bits
    namespace flash_optkeyr_bits {
        constexpr uint32_t OPTKEY = (32 << 0);  ///< Option byte key The following values must be written consecutively to unlock the FLASH_OPTR register allowing option byte programming/erasing operations: KEY1: 0x0819 2A3B KEY2: 0x4C5D 6E7F
    }

    /// FLASH_PDKEY1R Register bits
    namespace flash_pdkey1r_bits {
        constexpr uint32_t PDKEY1 = (32 << 0);  ///< Bank 1 power-down key The following values must be written consecutively to unlock the PDREQ1 bit in FLASH_ACR: PDKEY1_1: 0x0415 2637 PDKEY1_2: 0xFAFB FCFD
    }

    /// FLASH_PDKEY2R Register bits
    namespace flash_pdkey2r_bits {
        constexpr uint32_t PDKEY2 = (32 << 0);  ///< Bank 2 power-down key The following values must be written consecutively to unlock the PDREQ2 bit in FLASH_ACR: PDKEY2_1: 0x4051 6273 PDKEY2_2: 0xAFBF CFDF
    }

    /// FLASH_NSSR Register bits
    namespace flash_nssr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< Non-secure end of operation This bit is set by hardware when one or more Flash memory non-secure operation (program/erase) has been completed successfully. This bit is set only if the non-secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_NSCR). This bit is cleared by writing 1.
        constexpr uint32_t OPERR = (1U << 1);  ///< Non-secure operation error This bit is set by hardware when a Flash memory non-secure operation (program/erase) completes unsuccessfully. This bit is set only if non-secure error interrupts are enabled (NSERRIE = 1). This bit is cleared by writing 1.
        constexpr uint32_t PROGERR = (1U << 3);  ///< Non-secure programming error This bit is set by hardware when a non-secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Non-secure write protection error This bit is set by hardware when an non-secure address to be erased/programmed belongs to a write-protected part (by WRP, PCROP, HDP or RDP level 1) of the Flash memory. This bit is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Non-secure programming alignment error This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address. This bit is cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Non-secure size error This bit is set by hardware when the size of the access is a byte or half-word during a non-secure program sequence. Only quad-word programming is allowed by means of successive word accesses. This bit is cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Non-secure programming sequence error This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t OPTWERR = (1U << 13);  ///< Option write error This bit is set by hardware when the options bytes are written with an invalid configuration. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t BSY = (1U << 16);  ///< Non-secure busy This indicates that a Flash memory secure or non-secure operation is in progress. This bit is set at the beginning of a Flash operation and reset when the operation finishes or when an error occurs.
        constexpr uint32_t WDW = (1U << 17);  ///< Non-secure wait data to write This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.
        constexpr uint32_t OEM1LOCK = (1U << 18);  ///< OEM1 lock This bit indicates that the OEM1 RDP key read during the OBL is not virgin. When set, the OEM1 RDP lock mechanism is active.
        constexpr uint32_t OEM2LOCK = (1U << 19);  ///< OEM2 lock This bit indicates that the OEM2 RDP key read during the OBL is not virgin. When set, the OEM2 RDP lock mechanism is active.
        constexpr uint32_t PD1 = (1U << 20);  ///< Bank 1 in power-down mode This bit indicates that the Flash memory bank 1 is in power-down state. It is reset when bank 1 is in normal mode or being awaken.
        constexpr uint32_t PD2 = (1U << 21);  ///< Bank 2 in power-down mode This bit indicates that the Flash memory bank 2 is in power-down state. It is reset when bank 2 is in normal mode or being awaken.
    }

    /// FLASH_SECSR Register bits
    namespace flash_secsr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< Secure end of operation This bit is set by hardware when one or more Flash memory secure operation (program/erase) has been completed successfully. This bit is set only if the secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_SECCR). This bit is cleared by writing 1.
        constexpr uint32_t OPERR = (1U << 1);  ///< Secure operation error This bit is set by hardware when a Flash memory secure operation (program/erase) completes unsuccessfully. This bit is set only if secure error interrupts are enabled (SECERRIE = 1). This bit is cleared by writing 1.
        constexpr uint32_t PROGERR = (1U << 3);  ///< Secure programming error This bit is set by hardware when a secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Secure write protection error This bit is set by hardware when an secure address to be erased/programmed belongs to a write-protected part (by WRP, PCROP, HDP or RDP level 1) of the Flash memory.This bit is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Secure programming alignment error This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address.This bit is cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Secure size error This bit is set by hardware when the size of the access is a byte or half-word during a secure program sequence. Only quad-word programming is allowed by means of successive word accesses.This bit is cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Secure programming sequence error This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t RDERR = (1U << 14);  ///< Secure readout protection error This bit is set by hardware when a read access is performed to a secure PCROP area and when a cacheable fetch access is performed to a secure PCROP area. An interrupt is generated if RDERRIE is set in FLASH_SECCR register. This bit is cleared by writing 1.
        constexpr uint32_t BSY = (1U << 16);  ///< Secure busy This bit indicates that a Flash memory secure or non-secure operation is in progress. This is set on the beginning of a Flash operation and reset when the operation finishes or when an error occurs.
        constexpr uint32_t WDW = (1U << 17);  ///< Secure wait data to write This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.
    }

    /// FLASH_NSCR Register bits
    namespace flash_nscr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Non-secure programming
        constexpr uint32_t PER = (1U << 1);  ///< Non-secure page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Non-secure bank 1 mass erase This bit triggers the bank 1 non-secure mass erase (all bank 1 user pages) when set.
        constexpr uint32_t PNB = (8 << 3);  ///< Non-secure page number selection These bits select the page to erase. ... ...
        constexpr uint32_t BKER = (1U << 11);  ///< Non-secure bank selection for page erase
        constexpr uint32_t BWR = (1U << 14);  ///< Non-secure burst write programming mode When set, this bit selects the burst write programming mode.
        constexpr uint32_t MER2 = (1U << 15);  ///< Non-secure bank 2 mass erase This bit triggers the bank 2 non-secure mass erase (all bank 2 user pages) when set.
        constexpr uint32_t STRT = (1U << 16);  ///< Non-secure start This bit triggers a non-secure erase operation when set. If MER1, MER2 and PER bits are reset and the STRT bit is set, the PGSERR bit in FLASH_NSSR is set (this condition is forbidden). This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_NSSR.
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start This bit triggers an options operation when set. It can not be written if OPTLOCK bit is set. This bit is set only by software, and is cleared when the BSY bit is cleared in FLASH_NSSR.
        constexpr uint32_t EOPIE = (1U << 24);  ///< Non-secure end of operation interrupt enable This bit enables the interrupt generation when the EOP bit in the FLASH_NSSR is set to 1.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Non-secure error interrupt enable This bit enables the interrupt generation when the OPERR bit in the FLASH_NSSR is set to 1.
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading When set to 1, this bit forces the option byte reloading. This bit is cleared only when the option byte loading is complete. It cannot be written if OPTLOCK is set.
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Option lock This bit is set only. When set, all bits concerning user options in FLASH_NSCR register are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit in the FLASH_NSCR must be cleared before doing the unlock sequence for OPTLOCK bit. In case of an unsuccessful unlock operation, this bit remains set until the next reset.
        constexpr uint32_t LOCK = (1U << 31);  ///< Non-secure lock This bit is set only. When set, the FLASH_NSCR register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_NSKEYR register. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_SECCR Register bits
    namespace flash_seccr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Secure programming
        constexpr uint32_t PER = (1U << 1);  ///< Secure page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Secure bank 1 mass erase This bit triggers the bank 1 secure mass erase (all bank 1 user pages) when set.
        constexpr uint32_t PNB = (8 << 3);  ///< Secure page number selection These bits select the page to erase. ... ...
        constexpr uint32_t BKER = (1U << 11);  ///< Secure bank selection for page erase
        constexpr uint32_t BWR = (1U << 14);  ///< Secure burst write programming mode When set, this bit selects the burst write programming mode.
        constexpr uint32_t MER2 = (1U << 15);  ///< Secure bank 2 mass erase This bit triggers the bank 2 secure mass erase (all bank 2 user pages) when set.
        constexpr uint32_t STRT = (1U << 16);  ///< Secure start This bit triggers a secure erase operation when set. If MER1, MER2 and PER bits are reset and the STRT bit is set, the PGSERR in the FLASH_SECSR is set (this condition is forbidden). This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_SECSR.
        constexpr uint32_t EOPIE = (1U << 24);  ///< Secure End of operation interrupt enable This bit enables the interrupt generation when the EOP bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Secure error interrupt enable This bit enables the interrupt generation when the OPERR bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t RDERRIE = (1U << 26);  ///< Secure PCROP read error interrupt enable This bit enables the interrupt generation when the RDERR bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t INV = (1U << 29);  ///< Flash memory security state invert This bit inverts the Flash memory security state.
        constexpr uint32_t LOCK = (1U << 31);  ///< Secure lock This bit is set only. When set, the FLASH_SECCR register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_SECKEYR register. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_ECCR Register bits
    namespace flash_eccr_bits {
        constexpr uint32_t ADDR_ECC = (21 << 0);  ///< ECC fail address This field indicates which address is concerned by the ECC error correction or by the double ECC error detection. The address is given by bank from address 0x0 0000 to 0x1F FFF0.
        constexpr uint32_t BK_ECC = (1U << 21);  ///< ECC fail bank This bit indicates which bank is concerned by the ECC error correction or by the double ECC error detection.
        constexpr uint32_t SYSF_ECC = (1U << 22);  ///< System Flash memory ECC fail This bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory.
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable This bit enables the interrupt generation when the ECCC bit in the FLASH_ECCR register is set.
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction This bit is set by hardware when one ECC error has been detected and corrected (only if ECCC and ECCD were previously cleared). An interrupt is generated if ECCIE is set. This bit is cleared by writing 1.
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection This bit is set by hardware when two ECC errors have been detected (only if ECCC and ECCD were previously cleared). When this bit is set, a NMI is generated. This bit is cleared by writing 1.
    }

    /// FLASH_OPSR Register bits
    namespace flash_opsr_bits {
        constexpr uint32_t ADDR_OP = (21 << 0);  ///< Interrupted operation address This field indicates which address in the Flash memory was accessed when reset occurred. The address is given by bank from address 0x0 0000 to 0x1F FFF0.
        constexpr uint32_t BK_OP = (1U << 21);  ///< Interrupted operation bank This bit indicates which Flash memory bank was accessed when reset occurred
        constexpr uint32_t SYSF_OP = (1U << 22);  ///< Operation in system Flash memory interrupted This bit indicates that the reset occurred during an operation in the system Flash memory.
        constexpr uint32_t CODE_OP = (3 << 29);  ///< Flash memory operation code This field indicates which Flash memory operation has been interrupted by a system reset:
    }

    /// FLASH_OPTR Register bits
    namespace flash_optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Readout protection level Others: Level 1 (memories readout protection active) Note: Refer to for more details.
        constexpr uint32_t BOR_LEV = (3 << 8);  ///< BOR reset level These bits contain the VDD supply level threshold that activates/releases the reset.
        constexpr uint32_t nRST_STOP = (1U << 12);  ///< Reset generation in Stop mode
        constexpr uint32_t nRST_STDBY = (1U << 13);  ///< Reset generation in Standby mode
        constexpr uint32_t nRST_SHDW = (1U << 14);  ///< Reset generation in Shutdown mode
        constexpr uint32_t SRAM1345_RST = (1U << 15);  ///< SRAM1, SRAM4 and SRAM5 erase upon system reset
        constexpr uint32_t IWDG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t SWAP_BANK = (1U << 20);  ///< Swap banks
        constexpr uint32_t DUALBANK = (1U << 21);  ///< Dual-bank on 1-Mbyte and 512-Kbyte Flash memory devices
        constexpr uint32_t BKPRAM_ECC = (1U << 22);  ///< Backup RAM ECC detection and correction enable
        constexpr uint32_t SRAM2_ECC = (1U << 24);  ///< SRAM2 ECC detection and correction enable
        constexpr uint32_t SRAM2_RST = (1U << 25);  ///< SRAM2 erase when system reset
        constexpr uint32_t nSWBOOT0 = (1U << 26);  ///< Software BOOT0
        constexpr uint32_t nBOOT0 = (1U << 27);  ///< nBOOT0 option bit
        constexpr uint32_t PA15_PUPEN = (1U << 28);  ///< PA15 pull-up enable
        constexpr uint32_t IO_VDD_HSLV = (1U << 29);  ///< High-speed IO at low VDD voltage configuration bit This bit can be set only with VDD below 2.5V
        constexpr uint32_t IO_VDDIO2_HSLV = (1U << 30);  ///< High-speed IO at low VDDIO2 voltage configuration bit This bit can be set only with VDDIO2 below 2.5 V.
        constexpr uint32_t TZEN = (1U << 31);  ///< Global TrustZone security enable
    }

    /// FLASH_NSBOOTADD0R Register bits
    namespace flash_nsbootadd0r_bits {
        constexpr uint32_t NSBOOTADD0 = (25 << 7);  ///< Non-secure boot base address 0 The non-secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: NSBOOTADD0[24:0] = 0x0100000: Boot from non-secure Flash memory (0x0800 0000) NSBOOTADD0[24:0] = 0x017F200: Boot from system memory bootloader (0x0BF9 0000) NSBOOTADD0[24:0] = 0x0400000: Boot from non-secure SRAM1 on S-Bus (0x2000 0000)
    }

    /// FLASH_NSBOOTADD1R Register bits
    namespace flash_nsbootadd1r_bits {
        constexpr uint32_t NSBOOTADD1 = (25 << 7);  ///< Non-secure boot address 1 The non-secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: NSBOOTADD1[24:0] = 0x0100000: Boot from non-secure Flash memory (0x0800 0000) NSBOOTADD1[24:0] = 0x017F200: Boot from system memory bootloader (0x0BF9 0000) NSBOOTADD1[24:0] = 0x0400000: Boot from non-secure SRAM1 on S-Bus (0x2000 0000)
    }

    /// FLASH_SECBOOTADD0R Register bits
    namespace flash_secbootadd0r_bits {
        constexpr uint32_t BOOT_LOCK = (1U << 0);  ///< Boot lock When set, the boot is always forced to base address value programmed in SECBOOTADD0[24:0] option bytes whatever the boot selection option. When set, this bit can only be cleared by an RDP at level 0.
        constexpr uint32_t SECBOOTADD0 = (25 << 7);  ///< Secure boot base address 0 The secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. This bits correspond to address [31:7] The SECBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: SECBOOTADD0[24:0] = 0x018 0000: Boot from secure Flash memory (0x0C00 0000) SECBOOTADD0[24:0] = 0x01F F000: Boot from RSS (0x0FF8 0000) SECBOOTADD0[24:0] = 0x060 0000: Boot from secure SRAM1 on S-Bus (0x3000 0000)
    }

    /// FLASH_SECWM1R1 Register bits
    namespace flash_secwm1r1_bits {
        constexpr uint32_t SECWM1_PSTRT = (8 << 0);  ///< Start page of first secure area This field contains the first page of the secure area in bank 1.
        constexpr uint32_t SECWM1_PEND = (8 << 16);  ///< End page of first secure area This field contains the last page of the secure area in bank 1.
    }

    /// FLASH_SECWM1R2 Register bits
    namespace flash_secwm1r2_bits {
        constexpr uint32_t PCROP1_PSTRT = (8 << 0);  ///< Start page of first PCROP area This field contains the first page of the PCROP area in bank 1.
        constexpr uint32_t PCROP1EN = (1U << 15);  ///< PCROP1 area enable
        constexpr uint32_t HDP1_PEND = (8 << 16);  ///< End page of first hide protection area This field contains the last page of the HDP area in bank 1.
        constexpr uint32_t HDP1EN = (1U << 31);  ///< Hide protection first area enable
    }

    /// FLASH_WRP1AR Register bits
    namespace flash_wrp1ar_bits {
        constexpr uint32_t WRP1A_PSTRT = (8 << 0);  ///< bank 1 WPR first area A start page This field contains the first page of the first WPR area for bank 1.
        constexpr uint32_t WRP1A_PEND = (8 << 16);  ///< Bank 1 WPR first area A end page This field contains the last page of the first WPR area in bank 1.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 1 WPR first area A unlock
    }

    /// FLASH_WRP1BR Register bits
    namespace flash_wrp1br_bits {
        constexpr uint32_t WRP1B_PSTRT = (8 << 0);  ///< Bank 1 WRP second area B start page This field contains the first page of the second WRP area for bank 1.
        constexpr uint32_t WRP1B_PEND = (8 << 16);  ///< Bank 1 WRP second area B end page This field contains the last page of the second WRP area in bank 1.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 1 WPR second area B unlock
    }

    /// FLASH_SECWM2R1 Register bits
    namespace flash_secwm2r1_bits {
        constexpr uint32_t SECWM2_PSTRT = (8 << 0);  ///< Start page of second secure area This field contains the first page of the secure area in bank 2.
        constexpr uint32_t SECWM2_PEND = (8 << 16);  ///< End page of second secure area This field contains the last page of the secure area in bank 2.
    }

    /// FLASH_SECWM2R2 Register bits
    namespace flash_secwm2r2_bits {
        constexpr uint32_t PCROP2_PSTRT = (8 << 0);  ///< Start page of PCROP2 area PRCROP2_PSTRT contains the first page of the PCROP area in bank 2.
        constexpr uint32_t PCROP2EN = (1U << 15);  ///< PCROP2 area enable
        constexpr uint32_t HDP2_PEND = (8 << 16);  ///< End page of hide protection second area HDP2_PEND contains the last page of the HDP area in bank 2.
        constexpr uint32_t HDP2EN = (1U << 31);  ///< Hide protection second area enable
    }

    /// FLASH_WRP2AR Register bits
    namespace flash_wrp2ar_bits {
        constexpr uint32_t WRP2A_PSTRT = (8 << 0);  ///< Bank 2 WPR first area A start page This field contains the first page of the first WRP area for bank 2.
        constexpr uint32_t WRP2A_PEND = (8 << 16);  ///< Bank 2 WPR first area A end page This field contains the last page of the first WRP area in bank 2.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 2 WPR first area A unlock
    }

    /// FLASH_WRP2BR Register bits
    namespace flash_wrp2br_bits {
        constexpr uint32_t WRP2B_PSTRT = (8 << 0);  ///< Bank 2 WPR second area B start page This field contains the first page of the second WRP area for bank 2.
        constexpr uint32_t WRP2B_PEND = (8 << 16);  ///< Bank 2 WPR second area B end page This field contains the last page of the second WRP area in bank 2.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 2 WPR second area B unlock
    }

    /// FLASH_OEM1KEYR1 Register bits
    namespace flash_oem1keyr1_bits {
        constexpr uint32_t OEM1KEY = (32 << 0);  ///< OEM1 least significant bytes key
    }

    /// FLASH_OEM1KEYR2 Register bits
    namespace flash_oem1keyr2_bits {
        constexpr uint32_t OEM1KEY = (32 << 0);  ///< OEM1 most significant bytes key
    }

    /// FLASH_OEM2KEYR1 Register bits
    namespace flash_oem2keyr1_bits {
        constexpr uint32_t OEM2KEY = (32 << 0);  ///< OEM2 least significant bytes key
    }

    /// FLASH_OEM2KEYR2 Register bits
    namespace flash_oem2keyr2_bits {
        constexpr uint32_t OEM2KEY = (32 << 0);  ///< OEM2 most significant bytes key
    }

    /// FLASH_SEC1BBR1 Register bits
    namespace flash_sec1bbr1_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR2 Register bits
    namespace flash_sec1bbr2_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR3 Register bits
    namespace flash_sec1bbr3_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR4 Register bits
    namespace flash_sec1bbr4_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR5 Register bits
    namespace flash_sec1bbr5_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR6 Register bits
    namespace flash_sec1bbr6_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR7 Register bits
    namespace flash_sec1bbr7_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR8 Register bits
    namespace flash_sec1bbr8_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC2BBR1 Register bits
    namespace flash_sec2bbr1_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR2 Register bits
    namespace flash_sec2bbr2_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR3 Register bits
    namespace flash_sec2bbr3_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR4 Register bits
    namespace flash_sec2bbr4_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR5 Register bits
    namespace flash_sec2bbr5_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR6 Register bits
    namespace flash_sec2bbr6_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR7 Register bits
    namespace flash_sec2bbr7_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR8 Register bits
    namespace flash_sec2bbr8_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SECHDPCR Register bits
    namespace flash_sechdpcr_bits {
        constexpr uint32_t HDP1_ACCDIS = (1U << 0);  ///< HDP1 area access disable When set, this bit is only cleared by a system reset.
        constexpr uint32_t HDP2_ACCDIS = (1U << 1);  ///< HDP2 area access disable When set, this bit is only cleared by a system reset.
    }

    /// FLASH_PRIVCFGR Register bits
    namespace flash_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< Privileged protection for secure registers
        constexpr uint32_t NSPRIV = (1U << 1);  ///< Privileged protection for non-secure registers
    }

    /// FLASH_PRIV1BBR1 Register bits
    namespace flash_priv1bbr1_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR2 Register bits
    namespace flash_priv1bbr2_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR3 Register bits
    namespace flash_priv1bbr3_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR4 Register bits
    namespace flash_priv1bbr4_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR5 Register bits
    namespace flash_priv1bbr5_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR6 Register bits
    namespace flash_priv1bbr6_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR7 Register bits
    namespace flash_priv1bbr7_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR8 Register bits
    namespace flash_priv1bbr8_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV2BBR1 Register bits
    namespace flash_priv2bbr1_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR2 Register bits
    namespace flash_priv2bbr2_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR3 Register bits
    namespace flash_priv2bbr3_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR4 Register bits
    namespace flash_priv2bbr4_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR5 Register bits
    namespace flash_priv2bbr5_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR6 Register bits
    namespace flash_priv2bbr6_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR7 Register bits
    namespace flash_priv2bbr7_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR8 Register bits
    namespace flash_priv2bbr8_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

}

// ============================================================================
// FMAC Peripheral
// ============================================================================

namespace fmac {
    /// Base addresses
    constexpr uint32_t FMAC_BASE = 0x40021400;

    /// FMAC Register structure
    struct Registers {
        volatile uint32_t X1BUFCFG;  ///< Offset: 0x00 - FMAC X1 Buffer Configuration register
        volatile uint32_t X2BUFCFG;  ///< Offset: 0x04 - FMAC X2 Buffer Configuration register
        volatile uint32_t YBUFCFG;  ///< Offset: 0x08 - FMAC Y Buffer Configuration register
        volatile uint32_t PARAM;  ///< Offset: 0x0C - FMAC Parameter register
        volatile uint32_t CR;  ///< Offset: 0x10 - FMAC Control register
        volatile uint32_t SR;  ///< Offset: 0x14 - FMAC Status register
        volatile uint32_t WDATA;  ///< Offset: 0x18 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x1C - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* FMAC = reinterpret_cast<Registers*>(FMAC_BASE);

    // Bit definitions
    /// X1BUFCFG Register bits
    namespace x1bufcfg_bits {
        constexpr uint32_t X1_BASE = (8 << 0);  ///< Base address of X1 buffer
        constexpr uint32_t X1_BUF_SIZE = (8 << 8);  ///< Allocated size of X1 buffer in 16-bit words
        constexpr uint32_t FULL_WM = (2 << 24);  ///< Watermark for buffer full flag
    }

    /// X2BUFCFG Register bits
    namespace x2bufcfg_bits {
        constexpr uint32_t X2_BASE = (8 << 0);  ///< Base address of X2 buffer
        constexpr uint32_t X2_BUF_SIZE = (8 << 8);  ///< Size of X2 buffer in 16-bit words
    }

    /// YBUFCFG Register bits
    namespace ybufcfg_bits {
        constexpr uint32_t Y_BASE = (8 << 0);  ///< Base address of Y buffer
        constexpr uint32_t Y_BUF_SIZE = (8 << 8);  ///< Size of Y buffer in 16-bit words
        constexpr uint32_t EMPTY_WM = (2 << 24);  ///< Watermark for buffer empty flag
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t START = (1U << 31);  ///< Enable execution
        constexpr uint32_t FUNC = (7 << 24);  ///< Function
        constexpr uint32_t R = (8 << 16);  ///< Input parameter R
        constexpr uint32_t Q = (8 << 8);  ///< Input parameter Q
        constexpr uint32_t P = (8 << 0);  ///< Input parameter P
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 16);  ///< Reset FMAC unit
        constexpr uint32_t CLIPEN = (1U << 15);  ///< Enable clipping
        constexpr uint32_t DMAWEN = (1U << 9);  ///< Enable DMA write channel requests
        constexpr uint32_t DMAREN = (1U << 8);  ///< Enable DMA read channel requests
        constexpr uint32_t SATIEN = (1U << 4);  ///< Enable saturation error interrupts
        constexpr uint32_t UNFLIEN = (1U << 3);  ///< Enable underflow error interrupts
        constexpr uint32_t OVFLIEN = (1U << 2);  ///< Enable overflow error interrupts
        constexpr uint32_t WIEN = (1U << 1);  ///< Enable write interrupt
        constexpr uint32_t RIEN = (1U << 0);  ///< Enable read interrupt
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t YEMPTY = (1U << 0);  ///< Y buffer empty flag
        constexpr uint32_t X1FULL = (1U << 1);  ///< X1 buffer full flag
        constexpr uint32_t OVFL = (1U << 8);  ///< Overflow error flag
        constexpr uint32_t UNFL = (1U << 9);  ///< Underflow error flag
        constexpr uint32_t SAT = (1U << 10);  ///< Saturation error flag
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Write data
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Read data
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA1_BASE = 0x40020000;
    constexpr uint32_t SEC_GPDMA1_BASE = 0x50020000;
    constexpr uint32_t LPDMA1_BASE = 0x46025000;
    constexpr uint32_t SEC_LPDMA1_BASE = 0x56025000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t GPDMA_SECCFGR;  ///< Offset: 0x00 - GPDMA secure configuration register
        volatile uint32_t GPDMA_PRIVCFGR;  ///< Offset: 0x04 - GPDMA privileged configuration register
        volatile uint32_t MISR;  ///< Offset: 0x0C - non-secure masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x10 - secure masked interrupt status register
        volatile uint32_t GPDMA_C0LBAR;  ///< Offset: 0x50 - channel x linked-list base address register
        volatile uint32_t GPDMA_C0FCR;  ///< Offset: 0x5C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C0SR;  ///< Offset: 0x60 - channel x status register
        volatile uint32_t GPDMA_C0CR;  ///< Offset: 0x64 - channel x control register
        volatile uint32_t GPDMA_C0TR1;  ///< Offset: 0x90 - GPDMA channel x transfer register 1
        volatile uint32_t GPDMA_C0TR2;  ///< Offset: 0x94 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C0BR1;  ///< Offset: 0x98 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C0SAR;  ///< Offset: 0x9C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C0DAR;  ///< Offset: 0xA0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C0LLR;  ///< Offset: 0xCC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C1LBAR;  ///< Offset: 0xD0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C1FCR;  ///< Offset: 0xDC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C1SR;  ///< Offset: 0xE0 - channel x status register
        volatile uint32_t GPDMA_C1CR;  ///< Offset: 0xE4 - channel x control register
        volatile uint32_t GPDMA_C1TR1;  ///< Offset: 0x110 - GPDMA channel x transfer register 1
        volatile uint32_t GPDMA_C1TR2;  ///< Offset: 0x114 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C1BR1;  ///< Offset: 0x118 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C1SAR;  ///< Offset: 0x11C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C1DAR;  ///< Offset: 0x120 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C1LLR;  ///< Offset: 0x14C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C2LBAR;  ///< Offset: 0x150 - channel x linked-list base address register
        volatile uint32_t GPDMA_C2FCR;  ///< Offset: 0x15C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C2SR;  ///< Offset: 0x160 - channel x status register
        volatile uint32_t GPDMA_C2CR;  ///< Offset: 0x164 - channel x control register
        volatile uint32_t GPDMA_C2TR1;  ///< Offset: 0x190 - GPDMA channel x transfer register 1
        volatile uint32_t GPDMA_C2TR2;  ///< Offset: 0x194 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C2BR1;  ///< Offset: 0x198 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C2SAR;  ///< Offset: 0x19C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C2DAR;  ///< Offset: 0x1A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C2LLR;  ///< Offset: 0x1CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C3LBAR;  ///< Offset: 0x1D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C3FCR;  ///< Offset: 0x1DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C3SR;  ///< Offset: 0x1E0 - channel x status register
        volatile uint32_t GPDMA_C3CR;  ///< Offset: 0x1E4 - channel x control register
        volatile uint32_t GPDMA_C3TR1;  ///< Offset: 0x210 - GPDMA channel x transfer register 1
        volatile uint32_t GPDMA_C3TR2;  ///< Offset: 0x214 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C4TR2;  ///< Offset: 0x294 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C5TR2;  ///< Offset: 0x314 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C6TR2;  ///< Offset: 0x394 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C7TR2;  ///< Offset: 0x414 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C8TR2;  ///< Offset: 0x494 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C9TR2;  ///< Offset: 0x514 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C10TR2;  ///< Offset: 0x594 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C11TR2;  ///< Offset: 0x614 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C12TR2;  ///< Offset: 0x694 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C13TR2;  ///< Offset: 0x714 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C14TR2;  ///< Offset: 0x794 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C15TR2;  ///< Offset: 0x814 - GPDMA channel x transfer register 2
        volatile uint32_t GPDMA_C3BR1;  ///< Offset: 0x218 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C4BR1;  ///< Offset: 0x298 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C5BR1;  ///< Offset: 0x318 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C6BR1;  ///< Offset: 0x398 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C7BR1;  ///< Offset: 0x418 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C8BR1;  ///< Offset: 0x498 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C9BR1;  ///< Offset: 0x518 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C10BR1;  ///< Offset: 0x598 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C11BR1;  ///< Offset: 0x618 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C12BR1;  ///< Offset: 0x698 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C13BR1;  ///< Offset: 0x718 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C14BR1;  ///< Offset: 0x798 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C15BR1;  ///< Offset: 0x818 - GPDMA channel x block register 1
        volatile uint32_t GPDMA_C3SAR;  ///< Offset: 0x21C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C4SAR;  ///< Offset: 0x29C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C5SAR;  ///< Offset: 0x31C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C6SAR;  ///< Offset: 0x39C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C7SAR;  ///< Offset: 0x41C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C8SAR;  ///< Offset: 0x49C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C9SAR;  ///< Offset: 0x51C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C10SAR;  ///< Offset: 0x59C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C11SAR;  ///< Offset: 0x61C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C12SAR;  ///< Offset: 0x69C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C13SAR;  ///< Offset: 0x71C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C14SAR;  ///< Offset: 0x79C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C15SAR;  ///< Offset: 0x81C - GPDMA channel x source address register
        volatile uint32_t GPDMA_C3DAR;  ///< Offset: 0x220 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C4DAR;  ///< Offset: 0x2A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C5DAR;  ///< Offset: 0x320 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C6DAR;  ///< Offset: 0x3A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C7DAR;  ///< Offset: 0x420 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C8DAR;  ///< Offset: 0x4A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C9DAR;  ///< Offset: 0x520 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C10DAR;  ///< Offset: 0x5A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C11DAR;  ///< Offset: 0x620 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C12DAR;  ///< Offset: 0x6A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C13DAR;  ///< Offset: 0x720 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C14DAR;  ///< Offset: 0x7A0 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C15DAR;  ///< Offset: 0x820 - GPDMA channel x destination address register
        volatile uint32_t GPDMA_C3LLR;  ///< Offset: 0x24C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C4LLR;  ///< Offset: 0x2CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C5LLR;  ///< Offset: 0x34C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C6LLR;  ///< Offset: 0x3CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C7LLR;  ///< Offset: 0x44C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C8LLR;  ///< Offset: 0x4CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C9LLR;  ///< Offset: 0x54C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C10LLR;  ///< Offset: 0x5CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C11LLR;  ///< Offset: 0x64C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C12LLR;  ///< Offset: 0x6CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C13LLR;  ///< Offset: 0x74C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C14LLR;  ///< Offset: 0x7CC - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C15LLR;  ///< Offset: 0x84C - GPDMA channel x linked-list address register
        volatile uint32_t GPDMA_C4LBAR;  ///< Offset: 0x250 - channel x linked-list base address register
        volatile uint32_t GPDMA_C5LBAR;  ///< Offset: 0x2D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C6LBAR;  ///< Offset: 0x350 - channel x linked-list base address register
        volatile uint32_t GPDMA_C7LBAR;  ///< Offset: 0x3D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C8LBAR;  ///< Offset: 0x450 - channel x linked-list base address register
        volatile uint32_t GPDMA_C9LBAR;  ///< Offset: 0x4D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C10LBAR;  ///< Offset: 0x550 - channel x linked-list base address register
        volatile uint32_t GPDMA_C11LBAR;  ///< Offset: 0x5D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C12LBAR;  ///< Offset: 0x650 - channel x linked-list base address register
        volatile uint32_t GPDMA_C13LBAR;  ///< Offset: 0x6D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C14LBAR;  ///< Offset: 0x750 - channel x linked-list base address register
        volatile uint32_t GPDMA_C15LBAR;  ///< Offset: 0x7D0 - channel x linked-list base address register
        volatile uint32_t GPDMA_C4FCR;  ///< Offset: 0x25C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C5FCR;  ///< Offset: 0x2DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C6FCR;  ///< Offset: 0x35C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C7FCR;  ///< Offset: 0x3DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C8FCR;  ///< Offset: 0x45C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C9FCR;  ///< Offset: 0x4DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C10FCR;  ///< Offset: 0x55C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C11FCR;  ///< Offset: 0x5DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C12FCR;  ///< Offset: 0x65C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C13FCR;  ///< Offset: 0x6DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C14FCR;  ///< Offset: 0x75C - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C15FCR;  ///< Offset: 0x7DC - GPDMA channel x flag clear register
        volatile uint32_t GPDMA_C4SR;  ///< Offset: 0x260 - channel x status register
        volatile uint32_t GPDMA_C5SR;  ///< Offset: 0x2E0 - channel x status register
        volatile uint32_t GPDMA_C6SR;  ///< Offset: 0x360 - channel x status register
        volatile uint32_t GPDMA_C7SR;  ///< Offset: 0x3E0 - channel x status register
        volatile uint32_t GPDMA_C8SR;  ///< Offset: 0x460 - channel x status register
        volatile uint32_t GPDMA_C9SR;  ///< Offset: 0x4E0 - channel x status register
        volatile uint32_t GPDMA_C10SR;  ///< Offset: 0x560 - channel x status register
        volatile uint32_t GPDMA_C11SR;  ///< Offset: 0x5E0 - channel x status register
        volatile uint32_t GPDMA_C12SR;  ///< Offset: 0x660 - channel x status register
        volatile uint32_t GPDMA_C13SR;  ///< Offset: 0x6E0 - channel x status register
        volatile uint32_t GPDMA_C14SR;  ///< Offset: 0x760 - channel x status register
        volatile uint32_t GPDMA_C15SR;  ///< Offset: 0x7E0 - channel x status register
        volatile uint32_t GPDMA_C4CR;  ///< Offset: 0x264 - channel x control register
        volatile uint32_t GPDMA_C5CR;  ///< Offset: 0x2E4 - channel x control register
        volatile uint32_t GPDMA_C6CR;  ///< Offset: 0x364 - channel x control register
        volatile uint32_t GPDMA_C7CR;  ///< Offset: 0x3E4 - channel x control register
        volatile uint32_t GPDMA_C8CR;  ///< Offset: 0x464 - channel x control register
        volatile uint32_t GPDMA_C9CR;  ///< Offset: 0x4E4 - channel x control register
        volatile uint32_t GPDMA_C10CR;  ///< Offset: 0x564 - channel x control register
        volatile uint32_t GPDMA_C11CR;  ///< Offset: 0x5E4 - channel x control register
        volatile uint32_t GPDMA_C12CR;  ///< Offset: 0x664 - channel x control register
        volatile uint32_t GPDMA_C13CR;  ///< Offset: 0x6E4 - channel x control register
        volatile uint32_t GPDMA_C14CR;  ///< Offset: 0x764 - channel x control register
        volatile uint32_t GPDMA_C15CR;  ///< Offset: 0x7E4 - channel x control register
        volatile uint32_t GPDMA_C12TR3;  ///< Offset: 0x6A4 - GPDMA channel x transfer register 3
        volatile uint32_t GPDMA_C13TR3;  ///< Offset: 0x724 - GPDMA channel x transfer register 3
        volatile uint32_t GPDMA_C14TR3;  ///< Offset: 0x7A4 - GPDMA channel x transfer register 3
        volatile uint32_t GPDMA_C15TR3;  ///< Offset: 0x824 - GPDMA channel x transfer register 3
        volatile uint32_t GPDMA_C12BR2;  ///< Offset: 0x6A8 - GPDMA channel x block register 2
        volatile uint32_t GPDMA_C13BR2;  ///< Offset: 0x728 - GPDMA channel x block register 2
        volatile uint32_t GPDMA_C14BR2;  ///< Offset: 0x7A8 - GPDMA channel x block register 2
        volatile uint32_t GPDMA_C15BR2;  ///< Offset: 0x828 - GPDMA channel x block register 2
    };

    /// Peripheral instances
    inline Registers* GPDMA1 = reinterpret_cast<Registers*>(GPDMA1_BASE);
    inline Registers* SEC_GPDMA1 = reinterpret_cast<Registers*>(SEC_GPDMA1_BASE);
    inline Registers* LPDMA1 = reinterpret_cast<Registers*>(LPDMA1_BASE);
    inline Registers* SEC_LPDMA1 = reinterpret_cast<Registers*>(SEC_LPDMA1_BASE);

    // Bit definitions
    /// GPDMA_SECCFGR Register bits
    namespace gpdma_seccfgr_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
    }

    /// GPDMA_PRIVCFGR Register bits
    namespace gpdma_privcfgr_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t MIS0 = (1U << 0);  ///< MIS0
        constexpr uint32_t MIS1 = (1U << 1);  ///< MIS1
        constexpr uint32_t MIS2 = (1U << 2);  ///< MIS2
        constexpr uint32_t MIS3 = (1U << 3);  ///< MIS3
        constexpr uint32_t MIS4 = (1U << 4);  ///< MIS4
        constexpr uint32_t MIS5 = (1U << 5);  ///< MIS5
        constexpr uint32_t MIS6 = (1U << 6);  ///< MIS6
        constexpr uint32_t MIS7 = (1U << 7);  ///< MIS7
        constexpr uint32_t MIS8 = (1U << 8);  ///< MIS8
        constexpr uint32_t MIS9 = (1U << 9);  ///< MIS9
        constexpr uint32_t MIS10 = (1U << 10);  ///< MIS10
        constexpr uint32_t MIS11 = (1U << 11);  ///< MIS11
        constexpr uint32_t MIS12 = (1U << 12);  ///< MIS12
        constexpr uint32_t MIS13 = (1U << 13);  ///< MIS13
        constexpr uint32_t MIS14 = (1U << 14);  ///< MIS14
        constexpr uint32_t MIS15 = (1U << 15);  ///< MIS15
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t MIS0 = (1U << 0);  ///< MIS0
        constexpr uint32_t MIS1 = (1U << 1);  ///< MIS1
        constexpr uint32_t MIS2 = (1U << 2);  ///< MIS2
        constexpr uint32_t MIS3 = (1U << 3);  ///< MIS3
        constexpr uint32_t MIS4 = (1U << 4);  ///< MIS4
        constexpr uint32_t MIS5 = (1U << 5);  ///< MIS5
        constexpr uint32_t MIS6 = (1U << 6);  ///< MIS6
        constexpr uint32_t MIS7 = (1U << 7);  ///< MIS7
        constexpr uint32_t MIS8 = (1U << 8);  ///< MIS8
        constexpr uint32_t MIS9 = (1U << 9);  ///< MIS9
        constexpr uint32_t MIS10 = (1U << 10);  ///< MIS10
        constexpr uint32_t MIS11 = (1U << 11);  ///< MIS11
        constexpr uint32_t MIS12 = (1U << 12);  ///< MIS12
        constexpr uint32_t MIS13 = (1U << 13);  ///< MIS13
        constexpr uint32_t MIS14 = (1U << 14);  ///< MIS14
        constexpr uint32_t MIS15 = (1U << 15);  ///< MIS15
    }

    /// GPDMA_C0LBAR Register bits
    namespace gpdma_c0lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C0FCR Register bits
    namespace gpdma_c0fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C0SR Register bits
    namespace gpdma_c0sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C0CR Register bits
    namespace gpdma_c0cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C0TR1 Register bits
    namespace gpdma_c0tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: a source block size must be a multiple of the source data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: A source burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxSAR[2:0] and address offset GPDMA_CxTR3.SAO[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe source address, pointed by DMA_CxSAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If SBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the source data width i.e. SDW_LOG2[1:0].Note: A burst transfer must have an aligned address (c.f. start address GPDMA_CxSAR and address offset GPDMA_CxTR3.SAO) with its data width (byte, half-word or word). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< PAM
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source wordIf source data width is shorter than a word, this bit is ignored.If source data width is a word:- 0: no byte-based exchange within the unaligned half-word of each source word- 1: the two consecutive bytes within the unaligned half-word of each source word are exchanged
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated portAllocate the master port to the source transfer.- 0: port 0 (AHB) is allocated to the source transfer- 1: port 1 (AHB) is allocated to the source transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the DMA transfer from the sourceThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer from the source is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: A destination burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: When configured in packing mode (i.e. if PAM[1]=1 and destination data width different from source data width), a source block size must be a multiple of the destination data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe destination address, pointed by DMA_CxDAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If DBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the destination data width i.e. DDW_LOG2[1:0].Note: A burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchangeIf destination data size is a byte, this bit is ignored.If destination data size is not a byte:- 0: no byte-based exchange within half-word- 1: the two consecutive (post PAM) bytes are exchanged in each destination half-word
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchangeIf destination data size is shorter than a word, this bit is ignored.If destination data size is a word:- 0: no halfword-based exchange within word- 1: the two consecutive (post PAM) half-words are exchanged in each destination word
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated portAllocate the master port to the destination transfer.- 0: port 0 (AHB) is allocated to the destination transfer- 1: port 1 (AHB) is allocated to the destination transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the DMA transfer to the destinationThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer to the destination is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
    }

    /// GPDMA_C0TR2 Register bits
    namespace gpdma_c0tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C0BR1 Register bits
    namespace gpdma_c0br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C0SAR Register bits
    namespace gpdma_c0sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C0DAR Register bits
    namespace gpdma_c0dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C0LLR Register bits
    namespace gpdma_c0llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C1LBAR Register bits
    namespace gpdma_c1lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C1FCR Register bits
    namespace gpdma_c1fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C1SR Register bits
    namespace gpdma_c1sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C1CR Register bits
    namespace gpdma_c1cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C1TR1 Register bits
    namespace gpdma_c1tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: a source block size must be a multiple of the source data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: A source burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxSAR[2:0] and address offset GPDMA_CxTR3.SAO[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe source address, pointed by DMA_CxSAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If SBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the source data width i.e. SDW_LOG2[1:0].Note: A burst transfer must have an aligned address (c.f. start address GPDMA_CxSAR and address offset GPDMA_CxTR3.SAO) with its data width (byte, half-word or word). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< PAM
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source wordIf source data width is shorter than a word, this bit is ignored.If source data width is a word:- 0: no byte-based exchange within the unaligned half-word of each source word- 1: the two consecutive bytes within the unaligned half-word of each source word are exchanged
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated portAllocate the master port to the source transfer.- 0: port 0 (AHB) is allocated to the source transfer- 1: port 1 (AHB) is allocated to the source transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the DMA transfer from the sourceThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer from the source is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: A destination burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: When configured in packing mode (i.e. if PAM[1]=1 and destination data width different from source data width), a source block size must be a multiple of the destination data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe destination address, pointed by DMA_CxDAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If DBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the destination data width i.e. DDW_LOG2[1:0].Note: A burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchangeIf destination data size is a byte, this bit is ignored.If destination data size is not a byte:- 0: no byte-based exchange within half-word- 1: the two consecutive (post PAM) bytes are exchanged in each destination half-word
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchangeIf destination data size is shorter than a word, this bit is ignored.If destination data size is a word:- 0: no halfword-based exchange within word- 1: the two consecutive (post PAM) half-words are exchanged in each destination word
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated portAllocate the master port to the destination transfer.- 0: port 0 (AHB) is allocated to the destination transfer- 1: port 1 (AHB) is allocated to the destination transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the DMA transfer to the destinationThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer to the destination is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
    }

    /// GPDMA_C1TR2 Register bits
    namespace gpdma_c1tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< TRIGM mode
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C1BR1 Register bits
    namespace gpdma_c1br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C1SAR Register bits
    namespace gpdma_c1sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C1DAR Register bits
    namespace gpdma_c1dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C1LLR Register bits
    namespace gpdma_c1llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C2LBAR Register bits
    namespace gpdma_c2lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C2FCR Register bits
    namespace gpdma_c2fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C2SR Register bits
    namespace gpdma_c2sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C2CR Register bits
    namespace gpdma_c2cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C2TR1 Register bits
    namespace gpdma_c2tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: a source block size must be a multiple of the source data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: A source burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxSAR[2:0] and address offset GPDMA_CxTR3.SAO[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe source address, pointed by DMA_CxSAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If SBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the source data width i.e. SDW_LOG2[1:0].Note: A burst transfer must have an aligned address (c.f. start address GPDMA_CxSAR and address offset GPDMA_CxTR3.SAO) with its data width (byte, half-word or word). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< PAM
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source wordIf source data width is shorter than a word, this bit is ignored.If source data width is a word:- 0: no byte-based exchange within the unaligned half-word of each source word- 1: the two consecutive bytes within the unaligned half-word of each source word are exchanged
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated portAllocate the master port to the source transfer.- 0: port 0 (AHB) is allocated to the source transfer- 1: port 1 (AHB) is allocated to the source transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the DMA transfer from the sourceThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer from the source is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: A destination burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: When configured in packing mode (i.e. if PAM[1]=1 and destination data width different from source data width), a source block size must be a multiple of the destination data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe destination address, pointed by DMA_CxDAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If DBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the destination data width i.e. DDW_LOG2[1:0].Note: A burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchangeIf destination data size is a byte, this bit is ignored.If destination data size is not a byte:- 0: no byte-based exchange within half-word- 1: the two consecutive (post PAM) bytes are exchanged in each destination half-word
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchangeIf destination data size is shorter than a word, this bit is ignored.If destination data size is a word:- 0: no halfword-based exchange within word- 1: the two consecutive (post PAM) half-words are exchanged in each destination word
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated portAllocate the master port to the destination transfer.- 0: port 0 (AHB) is allocated to the destination transfer- 1: port 1 (AHB) is allocated to the destination transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the DMA transfer to the destinationThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer to the destination is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
    }

    /// GPDMA_C2TR2 Register bits
    namespace gpdma_c2tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C2BR1 Register bits
    namespace gpdma_c2br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C2SAR Register bits
    namespace gpdma_c2sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C2DAR Register bits
    namespace gpdma_c2dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C2LLR Register bits
    namespace gpdma_c2llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C3LBAR Register bits
    namespace gpdma_c3lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C3FCR Register bits
    namespace gpdma_c3fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C3SR Register bits
    namespace gpdma_c3sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C3CR Register bits
    namespace gpdma_c3cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel. i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C3TR1 Register bits
    namespace gpdma_c3tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: a source block size must be a multiple of the source data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: A source burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxSAR[2:0] and address offset GPDMA_CxTR3.SAO[2:0] vs SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe source address, pointed by DMA_CxSAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If SBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the source data width i.e. SDW_LOG2[1:0].Note: A burst transfer must have an aligned address (c.f. start address GPDMA_CxSAR and address offset GPDMA_CxTR3.SAO) with its data width (byte, half-word or word). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< PAM
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source wordIf source data width is shorter than a word, this bit is ignored.If source data width is a word:- 0: no byte-based exchange within the unaligned half-word of each source word- 1: the two consecutive bytes within the unaligned half-word of each source word are exchanged
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated portAllocate the master port to the source transfer.- 0: port 0 (AHB) is allocated to the source transfer- 1: port 1 (AHB) is allocated to the source transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the DMA transfer from the sourceThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer from the source is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes- 00: byte- 01: half-word (2 bytes)- 10: word (4 bytes)- 11: a user setting error is reported and no transfer is issued.Note: Setting a 8-byte data width is causing a user setting error to be reported and none transfer is issued.Note: A destination burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: When configured in packing mode (i.e. if PAM[1]=1 and destination data width different from source data width), a source block size must be a multiple of the destination data width (c.f. GPDMA_CxBR1.BNDT[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst- 0: fixed burst- 1: contiguously incremented burstThe destination address, pointed by DMA_CxDAR, is either kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1 , between 0 and 63.Burst length unit is one data a.k.a. beat within a burst.If DBL_1[5:0]=0, then burst can be named as single.Each data/beat has a width defined by the destination data width i.e. DDW_LOG2[1:0].Note: A burst transfer must have an aligned address with its data width (c.f. start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0] vs DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.Note: If a burst transfer would have crossed a 1kB address boundary on a AHB transfer, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the AHB protocol.Note: If a burst transfer is of length greater than the FIFO size of the channel x, internally DMA modifies and shortens the programmed burst into single(s) or burst(s) of lower length, to be compliant with the FIFO size. Transfer performance is lower, with DMA re-arbitration between effective and lower burst(s)/singles, but data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchangeIf destination data size is a byte, this bit is ignored.If destination data size is not a byte:- 0: no byte-based exchange within half-word- 1: the two consecutive (post PAM) bytes are exchanged in each destination half-word
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchangeIf destination data size is shorter than a word, this bit is ignored.If destination data size is a word:- 0: no halfword-based exchange within word- 1: the two consecutive (post PAM) half-words are exchanged in each destination word
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated portAllocate the master port to the destination transfer.- 0: port 0 (AHB) is allocated to the destination transfer- 1: port 1 (AHB) is allocated to the destination transferNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the DMA transfer to the destinationThis is a secure register bit.This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0.When is de-asserted GPDMA_SECCFGR.SECx, this bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the DMA transfer to the destination is non-secure.If GPDMA_SECCFGR.SECx=1 (and a secure access):- 0: non-secure- 1: secure
    }

    /// GPDMA_C3TR2 Register bits
    namespace gpdma_c3tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C4TR2 Register bits
    namespace gpdma_c4tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: rst read of a/each block transfer is conditioned by one hit trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode
    }

    /// GPDMA_C5TR2 Register bits
    namespace gpdma_c5tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C6TR2 Register bits
    namespace gpdma_c6tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: Defines the transfer granularity for its conditioning by the trigger. If the channel x is enabled (i.e. when GPDMA_CxCR.EN is asserted) with TRIGPOL[1:0]=00 or 11, these bits are ignored. Else, a DMA transfer is conditioned by (at least) one trigger hit, either at: - 00: at block level (for channel x=12 to 15: for each block if a 2D/repeated block is configured i.e. if GPDMA_CxBR1.BRC[10:0]! = 0): the first burst read of a/each block transfer is conditioned by one hit trigger. - 01: at 2D/repeated block level for channel x=12 to 15; same as 00 for channel x=0 to 11
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C7TR2 Register bits
    namespace gpdma_c7tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: Defines the transfer granularity for its conditioning by the trigger. If the channel x is enabled (i.e. when GPDMA_CxCR.EN is asserted) with TRIGPOL[1:0]=00 or 11, these bits are ignored. Else, a DMA transfer is conditioned by (at least) one trigger hit, either at: - 00: at block level (for channel x=12 to 15: for each block if a 2D/repeated block is configured i.e. if GPDMA_CxBR1.BRC[10:0]! = 0): the first burst read of a/each block transfer is conditioned by one hit trigger. - 01: at 2D/repeated block level for channel x=12 to 15; same as 00 for channel x=0 to 11: the first burst read of a 2D/repeated block transfer is conditioned by one hit trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C8TR2 Register bits
    namespace gpdma_c8tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: Defines the transfer granularity for its conditioning by the trigger. If the channel x is enabled (i.e. when GPDMA_CxCR.EN is asserted) with TRIGPOL[1:0]=00 or 11, these bits are ignored. Else, a DMA transfer is conditioned by (at least) one trigger hit, either at: - 00: at block level (for channel x=12 to 15: for each block if a 2D/repeated block is configured i.e. if GPDMA_CxBR1.BRC[10:0]! = 0): the first burst read of a/each block transfer is conditioned by one hit trigger. - 01: at 2D/repeated block level for channel x=12 to 15; same as 00 for channel x=0 to 11: the first burst read of a 2D/repeated block transfer is conditioned by one hit trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C9TR2 Register bits
    namespace gpdma_c9tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: Defines the transfer granularity for its conditioning by the trigger. If the channel x is enabled (i.e. when GPDMA_CxCR.EN is asserted) with TRIGPOL[1:0]=00 or 11, these bits are ignored. Else, a DMA transfer is conditioned by (at least) one trigger hit, either at: - 00: at block level (for channel x=12 to 15: for each block if a 2D/repeated block is configured i.e. if GPDMA_CxBR1.BRC[10:0]! = 0): the first burst read of a/each block transfer is conditioned by one hit trigger. - 01: at 2D/repeated block level for channel x=12 to 15; same as 00 for channel x=0 to 11: the first burst read of a 2D/repeated block transfer is conditioned by one hit trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C10TR2 Register bits
    namespace gpdma_c10tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: Defines the transfer granularity for its conditioning by the trigger. If the channel x is enabled (i.e. when GPDMA_CxCR.EN is asserted) with TRIGPOL[1:0]=00 or 11, these bits are ignored. Else, a DMA transfer is conditioned by (at least) one trigger hit, either at: - 00: at block level (for channel x=12 to 15: for each block if a 2D/repeated block is configured i.e. if GPDMA_CxBR1.BRC[10:0]! = 0): the first burst read of a/each block transfer is conditioned by one hit trigger. - 01: at 2D/repeated block level for channel x=12 to 15; same as 00 for channel x=0 to 11: the first burst read of a 2D/repeated block transfer is conditioned by one hit trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C11TR2 Register bits
    namespace gpdma_c11tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: enabled. Transferring a next LLIn+1 which updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0] resets the monitoring, trashing the (possible) memorized hit of the formerly defined LLIn trigger. After that a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, this new second trigger hitn+2 is lost and not memorized. Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by single(s) or/and by burst(s) of lower length) is conditioned once by the trigger. Note: When the programmed destination burst is internally shortened by single(s) or/and by burst(s) of lower length (e.g. vs FIFO size, vs block size, 1kB/4kB boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C12TR2 Register bits
    namespace gpdma_c12tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: enabled. Transferring a next LLIn+1 which updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0] resets the monitoring, trashing the (possible) memorized hit of the formerly defined LLIn trigger. After that a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, this new second trigger hitn+2 is lost and not memorized. Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by single(s) or/and by burst(s) of lower length) is conditioned once by the trigger. Note: When the programmed destination burst is internally shortened by single(s) or/and by burst(s) of lower length (e.g. vs FIFO size, vs block size, 1kB/4kB boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C13TR2 Register bits
    namespace gpdma_c13tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: enabled. Transferring a next LLIn+1 which updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0] resets the monitoring, trashing the (possible) memorized hit of the formerly defined LLIn trigger. After that a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, this new second trigger hitn+2 is lost and not memorized. Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by single(s) or/and by burst(s) of lower length) is conditioned once by the trigger. Note: When the programmed destination burst is internally shortened by single(s) or/and by burst(s) of lower length (e.g. vs FIFO size, vs block size, 1kB/4kB boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C14TR2 Register bits
    namespace gpdma_c14tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: enabled. Transferring a next LLIn+1 which updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0] resets the monitoring, trashing the (possible) memorized hit of the formerly defined LLIn trigger. After that a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, this new second trigger hitn+2 is lost and not memorized. Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by single(s) or/and by burst(s) of lower length) is conditioned once by the trigger. Note: When the programmed destination burst is internally shortened by single(s) or/and by burst(s) of lower length (e.g. vs FIFO size, vs block size, 1kB/4kB boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C15TR2 Register bits
    namespace gpdma_c15tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< DMA hardware request selection If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else, the selected hardware request as per Table 12 is internally taken into account. Note: The user must not assign a same input hardware request (i.e. a same REQSEL[6:0] value) to different active DMA channels (i.e. if GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for the related x channels). In other words, DMA is not intended to hardware support the case of simultaneous enabled channels having been -incorrectly- configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< Software request When GPDMA_CxCR.EN is asserted, this field is internally taken into account: - 0: no software request. The selected hardware request REQSEL[6:0] is taken into account. - 1: software request (for a memory-to-memory transfer). And the default selected hardware request as per REQSEL[6:0] is ignored.
        constexpr uint32_t DREQ = (1U << 10);  ///< Destination hardware request If the channel x is activated (i.e. GPDMA_CxCR.EN is asserted) with SWREQ=1 (i.e. software request for a memory-to-memory transfer), this bit is ignored. Else: - 0: the selected hardware request is driven by a source peripheral (i.e. this request signal is taken into account by the DMA transfer scheduler over the source/read port) - 1: the selected hardware request is driven by a destination peripheral (.e. this request signal is taken into account by the DMA transfer scheduler over the destination/write port)
        constexpr uint32_t BREQ = (1U << 11);  ///< BREQ
        constexpr uint32_t TRIGM = (2 << 14);  ///< Trigger mode: enabled. Transferring a next LLIn+1 which updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0] resets the monitoring, trashing the (possible) memorized hit of the formerly defined LLIn trigger. After that a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, this new second trigger hitn+2 is lost and not memorized. Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by single(s) or/and by burst(s) of lower length) is conditioned once by the trigger. Note: When the programmed destination burst is internally shortened by single(s) or/and by burst(s) of lower length (e.g. vs FIFO size, vs block size, 1kB/4kB boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< Trigger event input selection Note: Selects the trigger event input as per Table 13 of the DMA transfer, with an active trigger event if TRIGPOL[1:0] !=00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< Trigger event polarity Defines the polarity of the selected trigger event input defined by TRIGSEL[5:0]. - 00: no trigger. Masked trigger event. - 01: trigger on the rising edge - 10: trigger on the falling edge - 11: same as 00
        constexpr uint32_t TCEM = (2 << 30);  ///< Transfer complete event mode Defines the transfer granularity for the transfer complete (and half transfer complete) event generation. - 00: at block level (i.e. when GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 01: channel x=0 to 11: same as 00 ;channel x=12 to 15: at 2D/repeated block level (i.e. when GPDMA_CxBR1.BRC[10:0]= 0 and GPDMA_CxBR1.BNDT[15:0]= 0): the complete (and the half) transfer event is generated at the end (respectively half of the end) of the 2D/repeated block Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. - 10: at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer (the LLI data transfer being a block or a 2D/repeated block transfer), if any data transfer. Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1. - 11: at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI is the one that updates the link address GPDMA_CxLLR.LA[15:2] to zero and that clears all the update bits - UT1, UT2, UB1, USA, UDA, if present UT3, UB2 and ULL - of the GPDMA_CxLLR register. If the channel transfer is continuous/infinite, no event is generated.
    }

    /// GPDMA_C3BR1 Register bits
    namespace gpdma_c3br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C4BR1 Register bits
    namespace gpdma_c4br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C5BR1 Register bits
    namespace gpdma_c5br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C6BR1 Register bits
    namespace gpdma_c6br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C7BR1 Register bits
    namespace gpdma_c7br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C8BR1 Register bits
    namespace gpdma_c8br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C9BR1 Register bits
    namespace gpdma_c9br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C10BR1 Register bits
    namespace gpdma_c10br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C11BR1 Register bits
    namespace gpdma_c11br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
    }

    /// GPDMA_C12BR1 Register bits
    namespace gpdma_c12br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
        constexpr uint32_t BRC = (11 << 16);  ///< BRC
        constexpr uint32_t SDEC = (1U << 28);  ///< SDEC
        constexpr uint32_t DDEC = (1U << 29);  ///< DDEC
        constexpr uint32_t BRSDEC = (1U << 30);  ///< BRSDEC
        constexpr uint32_t BRDDEC = (1U << 31);  ///< BRDDEC
    }

    /// GPDMA_C13BR1 Register bits
    namespace gpdma_c13br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
        constexpr uint32_t BRC = (11 << 16);  ///< BRC
        constexpr uint32_t SDEC = (1U << 28);  ///< SDEC
        constexpr uint32_t DDEC = (1U << 29);  ///< DDEC
        constexpr uint32_t BRSDEC = (1U << 30);  ///< BRSDEC
        constexpr uint32_t BRDDEC = (1U << 31);  ///< BRDDEC
    }

    /// GPDMA_C14BR1 Register bits
    namespace gpdma_c14br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
        constexpr uint32_t BRC = (11 << 16);  ///< BRC
        constexpr uint32_t SDEC = (1U << 28);  ///< SDEC
        constexpr uint32_t DDEC = (1U << 29);  ///< DDEC
        constexpr uint32_t BRSDEC = (1U << 30);  ///< BRSDEC
        constexpr uint32_t BRDDEC = (1U << 31);  ///< BRDDEC
    }

    /// GPDMA_C15BR1 Register bits
    namespace gpdma_c15br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source
        constexpr uint32_t BRC = (11 << 16);  ///< BRC
        constexpr uint32_t SDEC = (1U << 28);  ///< SDEC
        constexpr uint32_t DDEC = (1U << 29);  ///< DDEC
        constexpr uint32_t BRSDEC = (1U << 30);  ///< BRSDEC
        constexpr uint32_t BRDDEC = (1U << 31);  ///< BRDDEC
    }

    /// GPDMA_C3SAR Register bits
    namespace gpdma_c3sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C4SAR Register bits
    namespace gpdma_c4sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C5SAR Register bits
    namespace gpdma_c5sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C6SAR Register bits
    namespace gpdma_c6sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C7SAR Register bits
    namespace gpdma_c7sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C8SAR Register bits
    namespace gpdma_c8sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C9SAR Register bits
    namespace gpdma_c9sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C10SAR Register bits
    namespace gpdma_c10sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C11SAR Register bits
    namespace gpdma_c11sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C12SAR Register bits
    namespace gpdma_c12sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C13SAR Register bits
    namespace gpdma_c13sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C14SAR Register bits
    namespace gpdma_c14sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C15SAR Register bits
    namespace gpdma_c15sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address
    }

    /// GPDMA_C3DAR Register bits
    namespace gpdma_c3dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C4DAR Register bits
    namespace gpdma_c4dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C5DAR Register bits
    namespace gpdma_c5dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C6DAR Register bits
    namespace gpdma_c6dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C7DAR Register bits
    namespace gpdma_c7dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C8DAR Register bits
    namespace gpdma_c8dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C9DAR Register bits
    namespace gpdma_c9dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C10DAR Register bits
    namespace gpdma_c10dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C11DAR Register bits
    namespace gpdma_c11dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C12DAR Register bits
    namespace gpdma_c12dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C13DAR Register bits
    namespace gpdma_c13dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C14DAR Register bits
    namespace gpdma_c14dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C15DAR Register bits
    namespace gpdma_c15dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address
    }

    /// GPDMA_C3LLR Register bits
    namespace gpdma_c3llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C4LLR Register bits
    namespace gpdma_c4llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C5LLR Register bits
    namespace gpdma_c5llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C6LLR Register bits
    namespace gpdma_c6llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C7LLR Register bits
    namespace gpdma_c7llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C8LLR Register bits
    namespace gpdma_c8llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C9LLR Register bits
    namespace gpdma_c9llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C10LLR Register bits
    namespace gpdma_c10llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C11LLR Register bits
    namespace gpdma_c11llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C12LLR Register bits
    namespace gpdma_c12llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory This bit controls the update of the GPDMA_CxBR2 register from the memory during the link transfer. - 0: no GPDMA_CxBR2 update - 1: GPDMA_CxBR2 update
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory This bit controls the update of the GPDMA_CxTR3 register from the memory during the link transfer. - 0: no GPDMA_CxTR3 update - 1: GPDMA_CxTR3 update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C13LLR Register bits
    namespace gpdma_c13llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory This bit controls the update of the GPDMA_CxBR2 register from the memory during the link transfer. - 0: no GPDMA_CxBR2 update - 1: GPDMA_CxBR2 update
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory This bit controls the update of the GPDMA_CxTR3 register from the memory during the link transfer. - 0: no GPDMA_CxTR3 update - 1: GPDMA_CxTR3 update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C14LLR Register bits
    namespace gpdma_c14llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory This bit controls the update of the GPDMA_CxBR2 register from the memory during the link transfer. - 0: no GPDMA_CxBR2 update - 1: GPDMA_CxBR2 update
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory This bit controls the update of the GPDMA_CxTR3 register from the memory during the link transfer. - 0: no GPDMA_CxTR3 update - 1: GPDMA_CxTR3 update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C15LLR Register bits
    namespace gpdma_c15llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low significant address) to the next linked-list data structure If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:2]=0: the current LLI is the last one. The channel transfer is completed without any update of the linked-list DMA register file. Else, this field is the pointer to the memory address offset from which the next linked-list data structure will be automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list DMA internal register file i.e. possibly GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR. Note: The user should program the pointer to be 32-bit aligned. The two low significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR from memory This bit controls the update of the GPDMA_CxLLR register from the memory during the link transfer. - 0: no GPDMA_CxLLR update - 1: GPDMA_CxLLR update
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory This bit controls the update of the GPDMA_CxBR2 register from the memory during the link transfer. - 0: no GPDMA_CxBR2 update - 1: GPDMA_CxBR2 update
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory This bit controls the update of the GPDMA_CxTR3 register from the memory during the link transfer. - 0: no GPDMA_CxTR3 update - 1: GPDMA_CxTR3 update
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR from memory This bit controls the update of the GPDMA_CxDAR register from the memory during the link transfer. - 0: no GPDMA_CxDAR update - 1: GPDMA_CxDAR update
        constexpr uint32_t USA = (1U << 28);  ///< Update GPDMA_CxSAR from memory This bit controls the update of the GPDMA_CxSAR register from the memory during the link transfer. - 0: no GPDMA_CxSAR update - 1: GPDMA_CxSAR update
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory This bit controls the update of the GPDMA_CxBR1 register from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR != 0, the linked-list is not completed. Then GPDMA_CxBR1.BNDT[15:0] is restored to the programmed value after data transfer is completed and before the link transfer. - 0: no GPDMA_CxBR1 update (GPDMA_CxBR1.BNDT[15:0] is restored, if any link transfer) - 1: GPDMA_CxBR1 update
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory This bit controls the update of the GPDMA_CxTR2 register from the memory during the link transfer. - 0: no GPDMA_CxTR2 update - 1: GPDMA_CxTR2 update
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory This bit controls the update of the GPDMA_CxTR1 register from the memory during the link transfer. - 0: no GPDMA_CxTR1 update - 1: GPDMA_CxTR1 update
    }

    /// GPDMA_C4LBAR Register bits
    namespace gpdma_c4lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C5LBAR Register bits
    namespace gpdma_c5lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C6LBAR Register bits
    namespace gpdma_c6lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C7LBAR Register bits
    namespace gpdma_c7lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C8LBAR Register bits
    namespace gpdma_c8lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C9LBAR Register bits
    namespace gpdma_c9lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C10LBAR Register bits
    namespace gpdma_c10lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C11LBAR Register bits
    namespace gpdma_c11lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C12LBAR Register bits
    namespace gpdma_c12lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C13LBAR Register bits
    namespace gpdma_c13lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C14LBAR Register bits
    namespace gpdma_c14lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C15LBAR Register bits
    namespace gpdma_c15lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of DMA channel x
    }

    /// GPDMA_C4FCR Register bits
    namespace gpdma_c4fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C5FCR Register bits
    namespace gpdma_c5fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C6FCR Register bits
    namespace gpdma_c6fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C7FCR Register bits
    namespace gpdma_c7fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C8FCR Register bits
    namespace gpdma_c8fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C9FCR Register bits
    namespace gpdma_c9fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C10FCR Register bits
    namespace gpdma_c10fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C11FCR Register bits
    namespace gpdma_c11fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C12FCR Register bits
    namespace gpdma_c12fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C13FCR Register bits
    namespace gpdma_c13fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C14FCR Register bits
    namespace gpdma_c14fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C15FCR Register bits
    namespace gpdma_c15fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear - 0: no effect - 1: clears the corresponding TCF flag
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear - 0: no effect - 1: clears the corresponding HTF flag
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear - 0: no effect - 1: clears the corresponding DTEF flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear - 0: no effect - 1: clears the corresponding ULEF flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear - 0: no effect - 1: clears the corresponding USEF flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear - 0: no effect - 1: clears the corresponding SUSPF flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C4SR Register bits
    namespace gpdma_c4sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C5SR Register bits
    namespace gpdma_c5sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C6SR Register bits
    namespace gpdma_c6sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C7SR Register bits
    namespace gpdma_c7sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C8SR Register bits
    namespace gpdma_c8sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C9SR Register bits
    namespace gpdma_c9sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C10SR Register bits
    namespace gpdma_c10sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C11SR Register bits
    namespace gpdma_c11sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C12SR Register bits
    namespace gpdma_c12sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C13SR Register bits
    namespace gpdma_c13sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C14SR Register bits
    namespace gpdma_c14sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C15SR Register bits
    namespace gpdma_c15sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag - 0: the channel is not in idle state - 1: the channel is in idle state This idle flag is de-asserted by hardware when the channel is enabled (i.e. is written 1 into GPDMA_CxCR.EN) with a valid channel configuration (i.e. no USEF to be immediately reported). This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (i.e. in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag - 0: no transfer complete event - 1: a transfer complete event occurred A transfer complete event is either a block transfer complete or a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0].
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag - 0: no half transfer event - 1: an half transfer event occurred An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode i.e. GPDMA_CxTR2.TCEM[1:0]. An half block transfer occurs when half of the bytes of the source block size (i.e. rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. Half 2D/repeated block transfer occurs when half of the repeated blocks (i.e. rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2) have been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag - 0: no data transfer error event - 1: a master bus error event occurred on a data transfer
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag - 0: no update link transfer error event - 1: a master bus error event occurred while updating a linked-list register from memory
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag - 0: no user setting error event - 1: a user setting error event occurred
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag - 0: no completed suspension event - 1: a completed suspension event occurred
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level Number of available write beats in the FIFO, in units of the programmed destination data width (c.f. GPDMA_CxTR1.DDW_LOG2[1:0], i.e. in units of bytes, half-words, or words). Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0] in order to know exactly how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be indeed suspended i.e. GPDMA_CxSR.SUSPF=1.
    }

    /// GPDMA_C4CR Register bits
    namespace gpdma_c4cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C5CR Register bits
    namespace gpdma_c5cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C6CR Register bits
    namespace gpdma_c6cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C7CR Register bits
    namespace gpdma_c7cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C8CR Register bits
    namespace gpdma_c8cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C9CR Register bits
    namespace gpdma_c9cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C10CR Register bits
    namespace gpdma_c10cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C11CR Register bits
    namespace gpdma_c11cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C12CR Register bits
    namespace gpdma_c12cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C13CR Register bits
    namespace gpdma_c13cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C14CR Register bits
    namespace gpdma_c14cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C15CR Register bits
    namespace gpdma_c15cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable - 0: write: ignored, read: channel disabled - 1: write: enable channel, read: channel enabled Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: * this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). * Else, this bit can be asserted by software. Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset - 0: no channel reset - 1: channel reset This bit is write only. Writing 0 has no impact. Writing 1 implies/will imply the reset of the FIFO, the reset of the channel internal state, and the reset of the SUSP and EN bits, whatever is written in respectively bit 2 and bit 0. The reset is/will be effective when the channel is in state i.e. either i) the active channel is in suspended state (i.e. GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=1) or ii) the channel is in disabled state (i.e. GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). After writing a RESET, if the user wants to continue using this channel, the user should explicitly reconfigure the channel including the hardware-modified configuration registers GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR, before enabling again the channel. Following the programming sequence in Figure 4: DMA channel abort and restart sequence.
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend - 0: write: resume channel, read: channel not suspended - 1: write: suspend channel, read: channel suspended Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: Software must write 1 in order to suspend an active channel i.e. a channel with an on-going DMA transfer over its master ports. Software must write 0 in order to resume a suspended channel, following the programming sequence in Figure 3: DMA channel suspend and resume sequence.
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable - 0: interrupt disabled - 1: interrupt enabled
        constexpr uint32_t LSM = (1U << 16);  ///< Link Step mode:- 0: channel is executed for the full linked-list, and completed at the end (if any) of the last LLI i.e. when GPDMA_CxLLR=0: the 16 low significant bits of the link address are null (LA[15:0]=0) and all the update bits are null i.e. UT1=UB1=UT2=USA=UDA=UB2 =UT3=ULL=0. Then GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0.- 1: channel is executed once for the current LLI:* First the (possibly 2D/repeated) block transfer is executed as defined by the current internal register file until that (GPDMA_CxBR1.BRC[10:0]=0 and GPDMA_CxBR1.BNDT[15:0]=0).* Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR register. Then channel execution is completed.Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated portAllocate the master port for the update of the DMA linked-list registers from the memory.- 0: port 0 (AHB) is allocated for the update of the DMA linked-list channel x registers- 1: port 1 (AHB) is allocated for the update of the DMA linked-list channel x registersNote: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the DMA transfer of the channel x vs others- 00: low priority, low weight- 01: low priority, mid weight- 10: low priority, high weight- 11: high priorityNote: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C12TR3 Register bits
    namespace gpdma_c12tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.SINC=1. Note: A source address offset must be aligned with the programmed data width of a source burst (c.f. SAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.DINC=1. Note: A destination address offset must be aligned with the programmed data width of a destination burst (c.f. DAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. Note: When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C13TR3 Register bits
    namespace gpdma_c13tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.SINC=1. Note: A source address offset must be aligned with the programmed data width of a source burst (c.f. SAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.DINC=1. Note: A destination address offset must be aligned with the programmed data width of a destination burst (c.f. DAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. Note: When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C14TR3 Register bits
    namespace gpdma_c14tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.SINC=1. Note: A source address offset must be aligned with the programmed data width of a source burst (c.f. SAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.DINC=1. Note: A destination address offset must be aligned with the programmed data width of a destination burst (c.f. DAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. Note: When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C15TR3 Register bits
    namespace gpdma_c15tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.SINC=1. Note: A source address offset must be aligned with the programmed data width of a source burst (c.f. SAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode i.e. if GPDMA_CxTR1.DINC=1. Note: A destination address offset must be aligned with the programmed data width of a destination burst (c.f. DAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. Note: When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C12BR2 Register bits
    namespace gpdma_c12br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset For a channel with 2D addressing capability, this field BRSAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (i.e. GPDMA_CxSAR) at the end of a block transfer. Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (c.f. BRSAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset For a channel with 2D addressing capability, this field BRDAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (i.e. GPDMA_CxDAR) at the end of a block transfer. Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (c.f. BRDAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
    }

    /// GPDMA_C13BR2 Register bits
    namespace gpdma_c13br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset For a channel with 2D addressing capability, this field BRSAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (i.e. GPDMA_CxSAR) at the end of a block transfer. Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (c.f. BRSAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset For a channel with 2D addressing capability, this field BRDAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (i.e. GPDMA_CxDAR) at the end of a block transfer. Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (c.f. BRDAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
    }

    /// GPDMA_C14BR2 Register bits
    namespace gpdma_c14br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset For a channel with 2D addressing capability, this field BRSAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (i.e. GPDMA_CxSAR) at the end of a block transfer. Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (c.f. BRSAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset For a channel with 2D addressing capability, this field BRDAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (i.e. GPDMA_CxDAR) at the end of a block transfer. Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (c.f. BRDAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
    }

    /// GPDMA_C15BR2 Register bits
    namespace gpdma_c15br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset For a channel with 2D addressing capability, this field BRSAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (i.e. GPDMA_CxSAR) at the end of a block transfer. Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (c.f. BRSAO[2:0] vs GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset For a channel with 2D addressing capability, this field BRDAO[15:0] is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (i.e. GPDMA_CxDAR) at the end of a block transfer. Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (c.f. BRDAO[2:0] vs GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x42020000;
    constexpr uint32_t SEC_GPIOA_BASE = 0x52020000;
    constexpr uint32_t GPIOB_BASE = 0x42020400;
    constexpr uint32_t SEC_GPIOB_BASE = 0x52020400;
    constexpr uint32_t GPIOC_BASE = 0x42020800;
    constexpr uint32_t SEC_GPIOC_BASE = 0x52020800;
    constexpr uint32_t GPIOD_BASE = 0x42020C00;
    constexpr uint32_t SEC_GPIOD_BASE = 0x52020C00;
    constexpr uint32_t GPIOE_BASE = 0x42021000;
    constexpr uint32_t SEC_GPIOE_BASE = 0x52021000;
    constexpr uint32_t GPIOG_BASE = 0x42021800;
    constexpr uint32_t SEC_GPIOG_BASE = 0x52021800;
    constexpr uint32_t GPIOH_BASE = 0x42021C00;
    constexpr uint32_t SEC_GPIOH_BASE = 0x52021C00;
    constexpr uint32_t LPGPIO1_BASE = 0x46020000;
    constexpr uint32_t SEC_LPGPIO1_BASE = 0x56020000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIO_MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t GPIO_OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t GPIO_OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t GPIO_PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t GPIO_IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t GPIO_ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t GPIO_BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t GPIO_LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t GPIO_AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t GPIO_AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t GPIO_BRR;  ///< Offset: 0x28 - GPIO port bit reset register
        volatile uint32_t GPIO_HSLVR;  ///< Offset: 0x2C - GPIO high-speed low-voltage register
        volatile uint32_t GPIO_SECCFGR;  ///< Offset: 0x30 - GPIO secure configuration register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* SEC_GPIOA = reinterpret_cast<Registers*>(SEC_GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* SEC_GPIOB = reinterpret_cast<Registers*>(SEC_GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* SEC_GPIOC = reinterpret_cast<Registers*>(SEC_GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* SEC_GPIOD = reinterpret_cast<Registers*>(SEC_GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* SEC_GPIOE = reinterpret_cast<Registers*>(SEC_GPIOE_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* SEC_GPIOG = reinterpret_cast<Registers*>(SEC_GPIOG_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* SEC_GPIOH = reinterpret_cast<Registers*>(SEC_GPIOH_BASE);
    inline Registers* LPGPIO1 = reinterpret_cast<Registers*>(LPGPIO1_BASE);
    inline Registers* SEC_LPGPIO1 = reinterpret_cast<Registers*>(SEC_LPGPIO1_BASE);

    // Bit definitions
    /// GPIO_MODER Register bits
    namespace gpio_moder_bits {
        constexpr uint32_t MODE0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_OTYPER Register bits
    namespace gpio_otyper_bits {
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_OSPEEDR Register bits
    namespace gpio_ospeedr_bits {
        constexpr uint32_t OSPEED0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_PUPDR Register bits
    namespace gpio_pupdr_bits {
        constexpr uint32_t PUPD0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_IDR Register bits
    namespace gpio_idr_bits {
        constexpr uint32_t ID0 = (1U << 0);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID1 = (1U << 1);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID2 = (1U << 2);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID3 = (1U << 3);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID4 = (1U << 4);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID5 = (1U << 5);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID6 = (1U << 6);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID7 = (1U << 7);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID8 = (1U << 8);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID9 = (1U << 9);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID10 = (1U << 10);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID11 = (1U << 11);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID12 = (1U << 12);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID13 = (1U << 13);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID14 = (1U << 14);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID15 = (1U << 15);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_ODR Register bits
    namespace gpio_odr_bits {
        constexpr uint32_t OD0 = (1U << 0);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD1 = (1U << 1);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD2 = (1U << 2);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD3 = (1U << 3);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD4 = (1U << 4);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD5 = (1U << 5);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD6 = (1U << 6);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD7 = (1U << 7);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD8 = (1U << 8);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD9 = (1U << 9);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD10 = (1U << 10);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD11 = (1U << 11);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD12 = (1U << 12);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD13 = (1U << 13);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD14 = (1U << 14);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD15 = (1U << 15);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_BSRR Register bits
    namespace gpio_bsrr_bits {
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_LCKR Register bits
    namespace gpio_lckr_bits {
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCKK = (1U << 16);  ///< Lock key This bit can be read any time. It can only be modified using the lock key write sequence. - LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] - LOCK key read RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the lock key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the LOCK. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
    }

    /// GPIO_AFRL Register bits
    namespace gpio_afrl_bits {
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_AFRH Register bits
    namespace gpio_afrh_bits {
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_BRR Register bits
    namespace gpio_brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_HSLVR Register bits
    namespace gpio_hslvr_bits {
        constexpr uint32_t HSLV0 = (1U << 0);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV1 = (1U << 1);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV2 = (1U << 2);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV3 = (1U << 3);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV4 = (1U << 4);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV5 = (1U << 5);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV6 = (1U << 6);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV7 = (1U << 7);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV8 = (1U << 8);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV9 = (1U << 9);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV10 = (1U << 10);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV11 = (1U << 11);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV12 = (1U << 12);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV13 = (1U << 13);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV14 = (1U << 14);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV15 = (1U << 15);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_SECCFGR Register bits
    namespace gpio_seccfgr_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC1 = (1U << 1);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC2 = (1U << 2);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC3 = (1U << 3);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC4 = (1U << 4);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC5 = (1U << 5);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC6 = (1U << 6);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC7 = (1U << 7);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC8 = (1U << 8);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC9 = (1U << 9);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC10 = (1U << 10);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC11 = (1U << 11);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC12 = (1U << 12);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC13 = (1U << 13);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC14 = (1U << 14);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC15 = (1U << 15);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
    }

}

// ============================================================================
// GTZC1 Peripheral
// ============================================================================

namespace gtzc1 {
    /// Base addresses
    constexpr uint32_t GTZC1_MPCBB1_BASE = 0x40032C00;
    constexpr uint32_t GTZC1_MPCBB2_BASE = 0x40033000;
    constexpr uint32_t GTZC1_TZIC_BASE = 0x40032800;
    constexpr uint32_t GTZC1_TZSC_BASE = 0x40032400;

    /// GTZC1 Register structure
    struct Registers {
        volatile uint32_t MPCBB1_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB1_CFGLOCK1;  ///< Offset: 0x10 - GTZC1 SRAMz MPCBB configuration lock register 1
        volatile uint32_t MPCBB1_CFGLOCK2;  ///< Offset: 0x14 - GTZC1 SRAMz MPCBB configuration lock register 2
        volatile uint32_t MPCBB1_SECCFGR0;  ///< Offset: 0x100 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR1;  ///< Offset: 0x104 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR2;  ///< Offset: 0x108 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR3;  ///< Offset: 0x10C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR4;  ///< Offset: 0x110 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR5;  ///< Offset: 0x114 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR6;  ///< Offset: 0x118 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR7;  ///< Offset: 0x11C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR8;  ///< Offset: 0x120 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR9;  ///< Offset: 0x124 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR10;  ///< Offset: 0x128 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR11;  ///< Offset: 0x12C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR12;  ///< Offset: 0x130 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR13;  ///< Offset: 0x134 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR14;  ///< Offset: 0x138 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR15;  ///< Offset: 0x13C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR16;  ///< Offset: 0x140 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR17;  ///< Offset: 0x144 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR18;  ///< Offset: 0x148 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR19;  ///< Offset: 0x14C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR20;  ///< Offset: 0x150 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR21;  ///< Offset: 0x154 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR22;  ///< Offset: 0x158 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR23;  ///< Offset: 0x15C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR24;  ///< Offset: 0x160 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR25;  ///< Offset: 0x164 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR26;  ///< Offset: 0x168 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR27;  ///< Offset: 0x16C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR28;  ///< Offset: 0x170 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR29;  ///< Offset: 0x174 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR30;  ///< Offset: 0x178 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR31;  ///< Offset: 0x17C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR32;  ///< Offset: 0x180 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR33;  ///< Offset: 0x184 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR34;  ///< Offset: 0x188 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR35;  ///< Offset: 0x18C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR36;  ///< Offset: 0x190 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR37;  ///< Offset: 0x194 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR38;  ///< Offset: 0x198 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR39;  ///< Offset: 0x19C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR40;  ///< Offset: 0x1A0 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR41;  ///< Offset: 0x1A4 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR42;  ///< Offset: 0x1A8 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR43;  ///< Offset: 0x1AC - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR44;  ///< Offset: 0x1B0 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR45;  ///< Offset: 0x1B4 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR46;  ///< Offset: 0x1B8 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR47;  ///< Offset: 0x1BC - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR48;  ///< Offset: 0x1C0 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR49;  ///< Offset: 0x1C4 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR50;  ///< Offset: 0x1C8 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR51;  ///< Offset: 0x1CC - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR0;  ///< Offset: 0x200 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR1;  ///< Offset: 0x204 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR2;  ///< Offset: 0x208 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR3;  ///< Offset: 0x20C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR4;  ///< Offset: 0x210 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR5;  ///< Offset: 0x214 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR6;  ///< Offset: 0x218 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR7;  ///< Offset: 0x21C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR8;  ///< Offset: 0x220 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR9;  ///< Offset: 0x224 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR10;  ///< Offset: 0x228 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR11;  ///< Offset: 0x22C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR12;  ///< Offset: 0x230 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR13;  ///< Offset: 0x234 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR14;  ///< Offset: 0x238 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR15;  ///< Offset: 0x23C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR16;  ///< Offset: 0x240 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR17;  ///< Offset: 0x244 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR18;  ///< Offset: 0x248 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR19;  ///< Offset: 0x24C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR20;  ///< Offset: 0x250 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR21;  ///< Offset: 0x254 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR22;  ///< Offset: 0x258 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR23;  ///< Offset: 0x25C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR24;  ///< Offset: 0x260 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR25;  ///< Offset: 0x264 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR26;  ///< Offset: 0x268 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR27;  ///< Offset: 0x26C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR28;  ///< Offset: 0x270 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR29;  ///< Offset: 0x274 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR30;  ///< Offset: 0x278 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR31;  ///< Offset: 0x27C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR32;  ///< Offset: 0x280 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR33;  ///< Offset: 0x284 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR34;  ///< Offset: 0x288 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR35;  ///< Offset: 0x28C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR36;  ///< Offset: 0x290 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR37;  ///< Offset: 0x294 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR38;  ///< Offset: 0x298 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR39;  ///< Offset: 0x29C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR40;  ///< Offset: 0x2A0 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR41;  ///< Offset: 0x2A4 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR42;  ///< Offset: 0x2A8 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR43;  ///< Offset: 0x2AC - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR44;  ///< Offset: 0x2B0 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR45;  ///< Offset: 0x2B4 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR46;  ///< Offset: 0x2B8 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR47;  ///< Offset: 0x2BC - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR48;  ///< Offset: 0x2C0 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR49;  ///< Offset: 0x2C4 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR50;  ///< Offset: 0x2C8 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR51;  ///< Offset: 0x2CC - MPCBB privileged configuration for super-block x register
    };

    /// Peripheral instances
    inline Registers* GTZC1_MPCBB1 = reinterpret_cast<Registers*>(GTZC1_MPCBB1_BASE);
    inline Registers* GTZC1_MPCBB2 = reinterpret_cast<Registers*>(GTZC1_MPCBB2_BASE);
    inline Registers* GTZC1_TZIC = reinterpret_cast<Registers*>(GTZC1_TZIC_BASE);
    inline Registers* GTZC1_TZSC = reinterpret_cast<Registers*>(GTZC1_TZSC_BASE);

    // Bit definitions
    /// MPCBB1_CR Register bits
    namespace mpcbb1_cr_bits {
        constexpr uint32_t GLOCK = (1U << 0);  ///< lock the control register of the MPCBB until next reset
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< SRAMx clocks security state
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< secure read/write illegal access disable
    }

    /// MPCBB1_CFGLOCK1 Register bits
    namespace mpcbb1_cfglock1_bits {
        constexpr uint32_t SPLCK0 = (1U << 0);  ///< SPLCK0
        constexpr uint32_t SPLCK1 = (1U << 1);  ///< SPLCK1
        constexpr uint32_t SPLCK2 = (1U << 2);  ///< SPLCK2
        constexpr uint32_t SPLCK3 = (1U << 3);  ///< SPLCK3
        constexpr uint32_t SPLCK4 = (1U << 4);  ///< SPLCK4
        constexpr uint32_t SPLCK5 = (1U << 5);  ///< SPLCK5
        constexpr uint32_t SPLCK6 = (1U << 6);  ///< SPLCK6
        constexpr uint32_t SPLCK7 = (1U << 7);  ///< SPLCK7
        constexpr uint32_t SPLCK8 = (1U << 8);  ///< SPLCK8
        constexpr uint32_t SPLCK9 = (1U << 9);  ///< SPLCK9
        constexpr uint32_t SPLCK10 = (1U << 10);  ///< SPLCK10
        constexpr uint32_t SPLCK11 = (1U << 11);  ///< SPLCK11
        constexpr uint32_t SPLCK12 = (1U << 12);  ///< SPLCK12
        constexpr uint32_t SPLCK13 = (1U << 13);  ///< SPLCK13
        constexpr uint32_t SPLCK14 = (1U << 14);  ///< SPLCK14
        constexpr uint32_t SPLCK15 = (1U << 15);  ///< SPLCK15
        constexpr uint32_t SPLCK16 = (1U << 16);  ///< SPLCK16
        constexpr uint32_t SPLCK17 = (1U << 17);  ///< SPLCK17
        constexpr uint32_t SPLCK18 = (1U << 18);  ///< SPLCK18
        constexpr uint32_t SPLCK19 = (1U << 19);  ///< SPLCK19
        constexpr uint32_t SPLCK20 = (1U << 20);  ///< SPLCK20
        constexpr uint32_t SPLCK21 = (1U << 21);  ///< SPLCK21
        constexpr uint32_t SPLCK22 = (1U << 22);  ///< SPLCK22
        constexpr uint32_t SPLCK23 = (1U << 23);  ///< SPLCK23
        constexpr uint32_t SPLCK24 = (1U << 24);  ///< SPLCK24
        constexpr uint32_t SPLCK25 = (1U << 25);  ///< SPLCK25
        constexpr uint32_t SPLCK26 = (1U << 26);  ///< SPLCK26
        constexpr uint32_t SPLCK27 = (1U << 27);  ///< SPLCK27
        constexpr uint32_t SPLCK28 = (1U << 28);  ///< SPLCK28
        constexpr uint32_t SPLCK29 = (1U << 29);  ///< SPLCK29
        constexpr uint32_t SPLCK30 = (1U << 30);  ///< SPLCK30
        constexpr uint32_t SPLCK31 = (1U << 31);  ///< SPLCK31
    }

    /// MPCBB1_CFGLOCK2 Register bits
    namespace mpcbb1_cfglock2_bits {
        constexpr uint32_t SPLCK32 = (1U << 0);  ///< SPLCK32
        constexpr uint32_t SPLCK33 = (1U << 1);  ///< SPLCK33
        constexpr uint32_t SPLCK34 = (1U << 2);  ///< SPLCK34
        constexpr uint32_t SPLCK35 = (1U << 3);  ///< SPLCK35
        constexpr uint32_t SPLCK36 = (1U << 4);  ///< SPLCK36
        constexpr uint32_t SPLCK37 = (1U << 5);  ///< SPLCK37
        constexpr uint32_t SPLCK38 = (1U << 6);  ///< SPLCK38
        constexpr uint32_t SPLCK39 = (1U << 7);  ///< SPLCK39
        constexpr uint32_t SPLCK40 = (1U << 8);  ///< SPLCK40
        constexpr uint32_t SPLCK41 = (1U << 9);  ///< SPLCK41
        constexpr uint32_t SPLCK42 = (1U << 10);  ///< SPLCK42
        constexpr uint32_t SPLCK43 = (1U << 11);  ///< SPLCK43
        constexpr uint32_t SPLCK44 = (1U << 12);  ///< SPLCK44
        constexpr uint32_t SPLCK45 = (1U << 13);  ///< SPLCK45
        constexpr uint32_t SPLCK46 = (1U << 14);  ///< SPLCK46
        constexpr uint32_t SPLCK47 = (1U << 15);  ///< SPLCK47
        constexpr uint32_t SPLCK48 = (1U << 16);  ///< SPLCK48
        constexpr uint32_t SPLCK49 = (1U << 17);  ///< SPLCK49
        constexpr uint32_t SPLCK50 = (1U << 18);  ///< SPLCK50
        constexpr uint32_t SPLCK51 = (1U << 19);  ///< SPLCK51
    }

    /// MPCBB1_SECCFGR0 Register bits
    namespace mpcbb1_seccfgr0_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR1 Register bits
    namespace mpcbb1_seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR2 Register bits
    namespace mpcbb1_seccfgr2_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR3 Register bits
    namespace mpcbb1_seccfgr3_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR4 Register bits
    namespace mpcbb1_seccfgr4_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR5 Register bits
    namespace mpcbb1_seccfgr5_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR6 Register bits
    namespace mpcbb1_seccfgr6_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR7 Register bits
    namespace mpcbb1_seccfgr7_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR8 Register bits
    namespace mpcbb1_seccfgr8_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR9 Register bits
    namespace mpcbb1_seccfgr9_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR10 Register bits
    namespace mpcbb1_seccfgr10_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR11 Register bits
    namespace mpcbb1_seccfgr11_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR12 Register bits
    namespace mpcbb1_seccfgr12_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR13 Register bits
    namespace mpcbb1_seccfgr13_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR14 Register bits
    namespace mpcbb1_seccfgr14_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR15 Register bits
    namespace mpcbb1_seccfgr15_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR16 Register bits
    namespace mpcbb1_seccfgr16_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR17 Register bits
    namespace mpcbb1_seccfgr17_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR18 Register bits
    namespace mpcbb1_seccfgr18_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR19 Register bits
    namespace mpcbb1_seccfgr19_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR20 Register bits
    namespace mpcbb1_seccfgr20_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR21 Register bits
    namespace mpcbb1_seccfgr21_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR22 Register bits
    namespace mpcbb1_seccfgr22_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR23 Register bits
    namespace mpcbb1_seccfgr23_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR24 Register bits
    namespace mpcbb1_seccfgr24_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR25 Register bits
    namespace mpcbb1_seccfgr25_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR26 Register bits
    namespace mpcbb1_seccfgr26_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR27 Register bits
    namespace mpcbb1_seccfgr27_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR28 Register bits
    namespace mpcbb1_seccfgr28_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR29 Register bits
    namespace mpcbb1_seccfgr29_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR30 Register bits
    namespace mpcbb1_seccfgr30_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR31 Register bits
    namespace mpcbb1_seccfgr31_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR32 Register bits
    namespace mpcbb1_seccfgr32_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR33 Register bits
    namespace mpcbb1_seccfgr33_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR34 Register bits
    namespace mpcbb1_seccfgr34_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR35 Register bits
    namespace mpcbb1_seccfgr35_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR36 Register bits
    namespace mpcbb1_seccfgr36_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR37 Register bits
    namespace mpcbb1_seccfgr37_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR38 Register bits
    namespace mpcbb1_seccfgr38_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR39 Register bits
    namespace mpcbb1_seccfgr39_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR40 Register bits
    namespace mpcbb1_seccfgr40_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR41 Register bits
    namespace mpcbb1_seccfgr41_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR42 Register bits
    namespace mpcbb1_seccfgr42_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR43 Register bits
    namespace mpcbb1_seccfgr43_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR44 Register bits
    namespace mpcbb1_seccfgr44_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR45 Register bits
    namespace mpcbb1_seccfgr45_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR46 Register bits
    namespace mpcbb1_seccfgr46_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR47 Register bits
    namespace mpcbb1_seccfgr47_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR48 Register bits
    namespace mpcbb1_seccfgr48_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR49 Register bits
    namespace mpcbb1_seccfgr49_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR50 Register bits
    namespace mpcbb1_seccfgr50_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR51 Register bits
    namespace mpcbb1_seccfgr51_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_PRIVCFGR0 Register bits
    namespace mpcbb1_privcfgr0_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR1 Register bits
    namespace mpcbb1_privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR2 Register bits
    namespace mpcbb1_privcfgr2_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR3 Register bits
    namespace mpcbb1_privcfgr3_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR4 Register bits
    namespace mpcbb1_privcfgr4_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR5 Register bits
    namespace mpcbb1_privcfgr5_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR6 Register bits
    namespace mpcbb1_privcfgr6_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR7 Register bits
    namespace mpcbb1_privcfgr7_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR8 Register bits
    namespace mpcbb1_privcfgr8_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR9 Register bits
    namespace mpcbb1_privcfgr9_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR10 Register bits
    namespace mpcbb1_privcfgr10_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR11 Register bits
    namespace mpcbb1_privcfgr11_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR12 Register bits
    namespace mpcbb1_privcfgr12_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR13 Register bits
    namespace mpcbb1_privcfgr13_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR14 Register bits
    namespace mpcbb1_privcfgr14_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR15 Register bits
    namespace mpcbb1_privcfgr15_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR16 Register bits
    namespace mpcbb1_privcfgr16_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR17 Register bits
    namespace mpcbb1_privcfgr17_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR18 Register bits
    namespace mpcbb1_privcfgr18_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR19 Register bits
    namespace mpcbb1_privcfgr19_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR20 Register bits
    namespace mpcbb1_privcfgr20_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR21 Register bits
    namespace mpcbb1_privcfgr21_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR22 Register bits
    namespace mpcbb1_privcfgr22_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR23 Register bits
    namespace mpcbb1_privcfgr23_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR24 Register bits
    namespace mpcbb1_privcfgr24_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR25 Register bits
    namespace mpcbb1_privcfgr25_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR26 Register bits
    namespace mpcbb1_privcfgr26_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR27 Register bits
    namespace mpcbb1_privcfgr27_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR28 Register bits
    namespace mpcbb1_privcfgr28_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR29 Register bits
    namespace mpcbb1_privcfgr29_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR30 Register bits
    namespace mpcbb1_privcfgr30_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR31 Register bits
    namespace mpcbb1_privcfgr31_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR32 Register bits
    namespace mpcbb1_privcfgr32_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR33 Register bits
    namespace mpcbb1_privcfgr33_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR34 Register bits
    namespace mpcbb1_privcfgr34_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR35 Register bits
    namespace mpcbb1_privcfgr35_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR36 Register bits
    namespace mpcbb1_privcfgr36_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR37 Register bits
    namespace mpcbb1_privcfgr37_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR38 Register bits
    namespace mpcbb1_privcfgr38_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR39 Register bits
    namespace mpcbb1_privcfgr39_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR40 Register bits
    namespace mpcbb1_privcfgr40_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR41 Register bits
    namespace mpcbb1_privcfgr41_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR42 Register bits
    namespace mpcbb1_privcfgr42_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR43 Register bits
    namespace mpcbb1_privcfgr43_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR44 Register bits
    namespace mpcbb1_privcfgr44_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR45 Register bits
    namespace mpcbb1_privcfgr45_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR46 Register bits
    namespace mpcbb1_privcfgr46_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR47 Register bits
    namespace mpcbb1_privcfgr47_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR48 Register bits
    namespace mpcbb1_privcfgr48_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR49 Register bits
    namespace mpcbb1_privcfgr49_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR50 Register bits
    namespace mpcbb1_privcfgr50_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR51 Register bits
    namespace mpcbb1_privcfgr51_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

}

// ============================================================================
// GTZC2 Peripheral
// ============================================================================

namespace gtzc2 {
    /// Base addresses
    constexpr uint32_t GTZC2_MPCBB4_BASE = 0x46023800;
    constexpr uint32_t GTZC2_TZIC_BASE = 0x46023400;
    constexpr uint32_t GTZC2_TZSC_BASE = 0x46023000;

    /// GTZC2 Register structure
    struct Registers {
        volatile uint32_t MPCBB4_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB4_CFGLOCK;  ///< Offset: 0x10 - GTZC2 SRAM4 MPCBB configuration lock register
        volatile uint32_t MPCBB4_SECCFGR0;  ///< Offset: 0x100 - MPCBB security configuration for super-block 0 register
        volatile uint32_t MPCBB4_PRIVCFGR0;  ///< Offset: 0x200 - MPCBB privileged configuration for super-block 0 register
    };

    /// Peripheral instances
    inline Registers* GTZC2_MPCBB4 = reinterpret_cast<Registers*>(GTZC2_MPCBB4_BASE);
    inline Registers* GTZC2_TZIC = reinterpret_cast<Registers*>(GTZC2_TZIC_BASE);
    inline Registers* GTZC2_TZSC = reinterpret_cast<Registers*>(GTZC2_TZSC_BASE);

    // Bit definitions
    /// MPCBB4_CR Register bits
    namespace mpcbb4_cr_bits {
        constexpr uint32_t GLOCK = (1U << 0);  ///< lock the control register of the MPCBB until next reset
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< SRAMx clocks security state
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< secure read/write illegal access disable
    }

    /// MPCBB4_CFGLOCK Register bits
    namespace mpcbb4_cfglock_bits {
        constexpr uint32_t SPLCK0 = (1U << 0);  ///< Security/privilege configuration lock for super-block 0
    }

    /// MPCBB4_SECCFGR0 Register bits
    namespace mpcbb4_seccfgr0_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB4_PRIVCFGR0 Register bits
    namespace mpcbb4_privcfgr0_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

}

// ============================================================================
// HASH Peripheral
// ============================================================================

namespace hash {
    /// Base addresses
    constexpr uint32_t HASH_BASE = 0x420C0400;

    /// HASH Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DIN;  ///< Offset: 0x04 - data input register
        volatile uint32_t STR;  ///< Offset: 0x08 - start register
        volatile uint32_t HRA0;  ///< Offset: 0x0C - HASH aliased digest register 0
        volatile uint32_t HRA1;  ///< Offset: 0x10 - HASH aliased digest register 1
        volatile uint32_t HRA2;  ///< Offset: 0x14 - HASH aliased digest register 2
        volatile uint32_t HRA3;  ///< Offset: 0x18 - HASH aliased digest register 3
        volatile uint32_t HRA4;  ///< Offset: 0x1C - HASH aliased digest register 4
        volatile uint32_t HR0;  ///< Offset: 0x310 - digest register 0
        volatile uint32_t HR1;  ///< Offset: 0x314 - digest register 1
        volatile uint32_t HR2;  ///< Offset: 0x318 - digest register 4
        volatile uint32_t HR3;  ///< Offset: 0x31C - digest register 3
        volatile uint32_t HR4;  ///< Offset: 0x320 - digest register 4
        volatile uint32_t HR5;  ///< Offset: 0x324 - supplementary digest register 5
        volatile uint32_t HR6;  ///< Offset: 0x328 - supplementary digest register 6
        volatile uint32_t HR7;  ///< Offset: 0x32C - supplementary digest register 7
        volatile uint32_t IMR;  ///< Offset: 0x20 - interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x24 - status register
        volatile uint32_t CSR0;  ///< Offset: 0xF8 - context swap registers
        volatile uint32_t CSR1;  ///< Offset: 0xFC - context swap registers
        volatile uint32_t CSR2;  ///< Offset: 0x100 - context swap registers
        volatile uint32_t CSR3;  ///< Offset: 0x104 - context swap registers
        volatile uint32_t CSR4;  ///< Offset: 0x108 - context swap registers
        volatile uint32_t CSR5;  ///< Offset: 0x10C - context swap registers
        volatile uint32_t CSR6;  ///< Offset: 0x110 - context swap registers
        volatile uint32_t CSR7;  ///< Offset: 0x114 - context swap registers
        volatile uint32_t CSR8;  ///< Offset: 0x118 - context swap registers
        volatile uint32_t CSR9;  ///< Offset: 0x11C - context swap registers
        volatile uint32_t CSR10;  ///< Offset: 0x120 - context swap registers
        volatile uint32_t CSR11;  ///< Offset: 0x124 - context swap registers
        volatile uint32_t CSR12;  ///< Offset: 0x128 - context swap registers
        volatile uint32_t CSR13;  ///< Offset: 0x12C - context swap registers
        volatile uint32_t CSR14;  ///< Offset: 0x130 - context swap registers
        volatile uint32_t CSR15;  ///< Offset: 0x134 - context swap registers
        volatile uint32_t CSR16;  ///< Offset: 0x138 - context swap registers
        volatile uint32_t CSR17;  ///< Offset: 0x13C - context swap registers
        volatile uint32_t CSR18;  ///< Offset: 0x140 - context swap registers
        volatile uint32_t CSR19;  ///< Offset: 0x144 - context swap registers
        volatile uint32_t CSR20;  ///< Offset: 0x148 - context swap registers
        volatile uint32_t CSR21;  ///< Offset: 0x14C - context swap registers
        volatile uint32_t CSR22;  ///< Offset: 0x150 - context swap registers
        volatile uint32_t CSR23;  ///< Offset: 0x154 - context swap registers
        volatile uint32_t CSR24;  ///< Offset: 0x158 - context swap registers
        volatile uint32_t CSR25;  ///< Offset: 0x15C - context swap registers
        volatile uint32_t CSR26;  ///< Offset: 0x160 - context swap registers
        volatile uint32_t CSR27;  ///< Offset: 0x164 - context swap registers
        volatile uint32_t CSR28;  ///< Offset: 0x168 - context swap registers
        volatile uint32_t CSR29;  ///< Offset: 0x16C - context swap registers
        volatile uint32_t CSR30;  ///< Offset: 0x170 - context swap registers
        volatile uint32_t CSR31;  ///< Offset: 0x174 - context swap registers
        volatile uint32_t CSR32;  ///< Offset: 0x178 - context swap registers
        volatile uint32_t CSR33;  ///< Offset: 0x17C - context swap registers
        volatile uint32_t CSR34;  ///< Offset: 0x180 - context swap registers
        volatile uint32_t CSR35;  ///< Offset: 0x184 - context swap registers
        volatile uint32_t CSR36;  ///< Offset: 0x188 - context swap registers
        volatile uint32_t CSR37;  ///< Offset: 0x18C - context swap registers
        volatile uint32_t CSR38;  ///< Offset: 0x190 - context swap registers
        volatile uint32_t CSR39;  ///< Offset: 0x194 - context swap registers
        volatile uint32_t CSR40;  ///< Offset: 0x198 - context swap registers
        volatile uint32_t CSR41;  ///< Offset: 0x19C - context swap registers
        volatile uint32_t CSR42;  ///< Offset: 0x1A0 - context swap registers
        volatile uint32_t CSR43;  ///< Offset: 0x1A4 - context swap registers
        volatile uint32_t CSR44;  ///< Offset: 0x1A8 - context swap registers
        volatile uint32_t CSR45;  ///< Offset: 0x1AC - context swap registers
        volatile uint32_t CSR46;  ///< Offset: 0x1B0 - context swap registers
        volatile uint32_t CSR47;  ///< Offset: 0x1B4 - context swap registers
        volatile uint32_t CSR48;  ///< Offset: 0x1B8 - context swap registers
        volatile uint32_t CSR49;  ///< Offset: 0x1BC - context swap registers
        volatile uint32_t CSR50;  ///< Offset: 0x1C0 - context swap registers
        volatile uint32_t CSR51;  ///< Offset: 0x1C4 - context swap registers
        volatile uint32_t CSR52;  ///< Offset: 0x1C8 - context swap registers
        volatile uint32_t CSR53;  ///< Offset: 0x1CC - context swap registers
    };

    /// Peripheral instances
    inline Registers* HASH = reinterpret_cast<Registers*>(HASH_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t INIT = (1U << 2);  ///< Initialize message digest calculation
        constexpr uint32_t DMAE = (1U << 3);  ///< DMA enable
        constexpr uint32_t DATATYPE = (2 << 4);  ///< Data type selection
        constexpr uint32_t MODE = (1U << 6);  ///< Mode selection
        constexpr uint32_t ALGO = (2 << 17);  ///< Algorithm selection
        constexpr uint32_t NBW = (4 << 8);  ///< Number of words already pushed
        constexpr uint32_t DINNE = (1U << 12);  ///< DIN not empty
        constexpr uint32_t MDMAT = (1U << 13);  ///< Multiple DMA Transfers
        constexpr uint32_t LKEY = (1U << 16);  ///< Long key selection
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data input
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t DCAL = (1U << 8);  ///< Digest calculation
        constexpr uint32_t NBLW = (5 << 0);  ///< Number of valid bits in the last word of the message
    }

    /// HRA0 Register bits
    namespace hra0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HRA1 Register bits
    namespace hra1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HRA2 Register bits
    namespace hra2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HRA3 Register bits
    namespace hra3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HRA4 Register bits
    namespace hra4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HR0 Register bits
    namespace hr0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HR1 Register bits
    namespace hr1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HR2 Register bits
    namespace hr2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HR3 Register bits
    namespace hr3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HR4 Register bits
    namespace hr4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HR5 Register bits
    namespace hr5_bits {
        constexpr uint32_t H5 = (32 << 0);  ///< H5
    }

    /// HR6 Register bits
    namespace hr6_bits {
        constexpr uint32_t H6 = (32 << 0);  ///< H6
    }

    /// HR7 Register bits
    namespace hr7_bits {
        constexpr uint32_t H7 = (32 << 0);  ///< H7
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t DCIE = (1U << 1);  ///< Digest calculation completion interrupt enable
        constexpr uint32_t DINIE = (1U << 0);  ///< Data input interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy bit
        constexpr uint32_t DMAS = (1U << 2);  ///< DMA Status
        constexpr uint32_t DCIS = (1U << 1);  ///< Digest calculation completion interrupt status
        constexpr uint32_t DINIS = (1U << 0);  ///< Data input interrupt status
        constexpr uint32_t NBWE = (5 << 16);  ///< Number of words expected
        constexpr uint32_t DINNE = (1U << 15);  ///< DIN not empty
        constexpr uint32_t NBWP = (5 << 9);  ///< Number of words already pushed
    }

    /// CSR0 Register bits
    namespace csr0_bits {
        constexpr uint32_t CS0 = (32 << 0);  ///< CS0
    }

    /// CSR1 Register bits
    namespace csr1_bits {
        constexpr uint32_t CS1 = (32 << 0);  ///< CS1
    }

    /// CSR2 Register bits
    namespace csr2_bits {
        constexpr uint32_t CS2 = (32 << 0);  ///< CS2
    }

    /// CSR3 Register bits
    namespace csr3_bits {
        constexpr uint32_t CS3 = (32 << 0);  ///< CS3
    }

    /// CSR4 Register bits
    namespace csr4_bits {
        constexpr uint32_t CS4 = (32 << 0);  ///< CS4
    }

    /// CSR5 Register bits
    namespace csr5_bits {
        constexpr uint32_t CS5 = (32 << 0);  ///< CS5
    }

    /// CSR6 Register bits
    namespace csr6_bits {
        constexpr uint32_t CS6 = (32 << 0);  ///< CS6
    }

    /// CSR7 Register bits
    namespace csr7_bits {
        constexpr uint32_t CS7 = (32 << 0);  ///< CS7
    }

    /// CSR8 Register bits
    namespace csr8_bits {
        constexpr uint32_t CS8 = (32 << 0);  ///< CS8
    }

    /// CSR9 Register bits
    namespace csr9_bits {
        constexpr uint32_t CS9 = (32 << 0);  ///< CS9
    }

    /// CSR10 Register bits
    namespace csr10_bits {
        constexpr uint32_t CS10 = (32 << 0);  ///< CS10
    }

    /// CSR11 Register bits
    namespace csr11_bits {
        constexpr uint32_t CS11 = (32 << 0);  ///< CS11
    }

    /// CSR12 Register bits
    namespace csr12_bits {
        constexpr uint32_t CS12 = (32 << 0);  ///< CS12
    }

    /// CSR13 Register bits
    namespace csr13_bits {
        constexpr uint32_t CS13 = (32 << 0);  ///< CS13
    }

    /// CSR14 Register bits
    namespace csr14_bits {
        constexpr uint32_t CS14 = (32 << 0);  ///< CS14
    }

    /// CSR15 Register bits
    namespace csr15_bits {
        constexpr uint32_t CS15 = (32 << 0);  ///< CS15
    }

    /// CSR16 Register bits
    namespace csr16_bits {
        constexpr uint32_t CS16 = (32 << 0);  ///< CS16
    }

    /// CSR17 Register bits
    namespace csr17_bits {
        constexpr uint32_t CS17 = (32 << 0);  ///< CS17
    }

    /// CSR18 Register bits
    namespace csr18_bits {
        constexpr uint32_t CS18 = (32 << 0);  ///< CS18
    }

    /// CSR19 Register bits
    namespace csr19_bits {
        constexpr uint32_t CS19 = (32 << 0);  ///< CS19
    }

    /// CSR20 Register bits
    namespace csr20_bits {
        constexpr uint32_t CS20 = (32 << 0);  ///< CS20
    }

    /// CSR21 Register bits
    namespace csr21_bits {
        constexpr uint32_t CS21 = (32 << 0);  ///< CS21
    }

    /// CSR22 Register bits
    namespace csr22_bits {
        constexpr uint32_t CS22 = (32 << 0);  ///< CS22
    }

    /// CSR23 Register bits
    namespace csr23_bits {
        constexpr uint32_t CS23 = (32 << 0);  ///< CS23
    }

    /// CSR24 Register bits
    namespace csr24_bits {
        constexpr uint32_t CS24 = (32 << 0);  ///< CS24
    }

    /// CSR25 Register bits
    namespace csr25_bits {
        constexpr uint32_t CS25 = (32 << 0);  ///< CS25
    }

    /// CSR26 Register bits
    namespace csr26_bits {
        constexpr uint32_t CS26 = (32 << 0);  ///< CS26
    }

    /// CSR27 Register bits
    namespace csr27_bits {
        constexpr uint32_t CS27 = (32 << 0);  ///< CS27
    }

    /// CSR28 Register bits
    namespace csr28_bits {
        constexpr uint32_t CS28 = (32 << 0);  ///< CS28
    }

    /// CSR29 Register bits
    namespace csr29_bits {
        constexpr uint32_t CS29 = (32 << 0);  ///< CS29
    }

    /// CSR30 Register bits
    namespace csr30_bits {
        constexpr uint32_t CS30 = (32 << 0);  ///< CS30
    }

    /// CSR31 Register bits
    namespace csr31_bits {
        constexpr uint32_t CS31 = (32 << 0);  ///< CS31
    }

    /// CSR32 Register bits
    namespace csr32_bits {
        constexpr uint32_t CS32 = (32 << 0);  ///< CS32
    }

    /// CSR33 Register bits
    namespace csr33_bits {
        constexpr uint32_t CS33 = (32 << 0);  ///< CS33
    }

    /// CSR34 Register bits
    namespace csr34_bits {
        constexpr uint32_t CS34 = (32 << 0);  ///< CS34
    }

    /// CSR35 Register bits
    namespace csr35_bits {
        constexpr uint32_t CS35 = (32 << 0);  ///< CS35
    }

    /// CSR36 Register bits
    namespace csr36_bits {
        constexpr uint32_t CS36 = (32 << 0);  ///< CS36
    }

    /// CSR37 Register bits
    namespace csr37_bits {
        constexpr uint32_t CS37 = (32 << 0);  ///< CS37
    }

    /// CSR38 Register bits
    namespace csr38_bits {
        constexpr uint32_t CS38 = (32 << 0);  ///< CS38
    }

    /// CSR39 Register bits
    namespace csr39_bits {
        constexpr uint32_t CS39 = (32 << 0);  ///< CS39
    }

    /// CSR40 Register bits
    namespace csr40_bits {
        constexpr uint32_t CS40 = (32 << 0);  ///< CS40
    }

    /// CSR41 Register bits
    namespace csr41_bits {
        constexpr uint32_t CS41 = (32 << 0);  ///< CS41
    }

    /// CSR42 Register bits
    namespace csr42_bits {
        constexpr uint32_t CS42 = (32 << 0);  ///< CS42
    }

    /// CSR43 Register bits
    namespace csr43_bits {
        constexpr uint32_t CS43 = (32 << 0);  ///< CS43
    }

    /// CSR44 Register bits
    namespace csr44_bits {
        constexpr uint32_t CS44 = (32 << 0);  ///< CS44
    }

    /// CSR45 Register bits
    namespace csr45_bits {
        constexpr uint32_t CS45 = (32 << 0);  ///< CS45
    }

    /// CSR46 Register bits
    namespace csr46_bits {
        constexpr uint32_t CS46 = (32 << 0);  ///< CS46
    }

    /// CSR47 Register bits
    namespace csr47_bits {
        constexpr uint32_t CS47 = (32 << 0);  ///< CS47
    }

    /// CSR48 Register bits
    namespace csr48_bits {
        constexpr uint32_t CS48 = (32 << 0);  ///< CS48
    }

    /// CSR49 Register bits
    namespace csr49_bits {
        constexpr uint32_t CS49 = (32 << 0);  ///< CS49
    }

    /// CSR50 Register bits
    namespace csr50_bits {
        constexpr uint32_t CS50 = (32 << 0);  ///< CS50
    }

    /// CSR51 Register bits
    namespace csr51_bits {
        constexpr uint32_t CS51 = (32 << 0);  ///< CS51
    }

    /// CSR52 Register bits
    namespace csr52_bits {
        constexpr uint32_t CS52 = (32 << 0);  ///< CS52
    }

    /// CSR53 Register bits
    namespace csr53_bits {
        constexpr uint32_t CS53 = (32 << 0);  ///< CS53
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t SEC_I2C1_BASE = 0x50005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t SEC_I2C2_BASE = 0x50005800;
    constexpr uint32_t I2C3_BASE = 0x46002800;
    constexpr uint32_t SEC_I2C3_BASE = 0x56002800;
    constexpr uint32_t I2C4_BASE = 0x40008400;
    constexpr uint32_t SEC_I2C4_BASE = 0x50008400;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t I2C_AUTOCR;  ///< Offset: 0x2C - I2C Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* SEC_I2C1 = reinterpret_cast<Registers*>(SEC_I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* SEC_I2C2 = reinterpret_cast<Registers*>(SEC_I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* SEC_I2C3 = reinterpret_cast<Registers*>(SEC_I2C3_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);
    inline Registers* SEC_I2C4 = reinterpret_cast<Registers*>(SEC_I2C4_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
        constexpr uint32_t FMP = (1U << 24);  ///< Fast-mode Plus 20 mA drive enable
        constexpr uint32_t ADDRACLR = (1U << 30);  ///< Address match flag (ADDR) automatic clear
        constexpr uint32_t STOPFACLR = (1U << 31);  ///< STOP detection flag (STOPF) automatic clear
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

    /// I2C_AUTOCR Register bits
    namespace i2c_autocr_bits {
        constexpr uint32_t TCDMAEN = (1U << 6);  ///< DMA request enable on Transfer Complete event
        constexpr uint32_t TCRDMAEN = (1U << 7);  ///< DMA request enable on Transfer Complete Reload event
        constexpr uint32_t TRIGSEL = (4 << 16);  ///< Trigger selection
        constexpr uint32_t TRIGPOL = (1U << 20);  ///< Trigger polarity
        constexpr uint32_t TRIGEN = (1U << 21);  ///< Trigger enable
    }

}

// ============================================================================
// ICache Peripheral
// ============================================================================

namespace icache {
    /// Base addresses
    constexpr uint32_t ICache_BASE = 0x40030400;

    /// ICache Register structure
    struct Registers {
        volatile uint32_t ICACHE_CR;  ///< Offset: 0x00 - ICACHE control register
        volatile uint32_t ICACHE_SR;  ///< Offset: 0x04 - ICACHE status register
        volatile uint32_t ICACHE_IER;  ///< Offset: 0x08 - ICACHE interrupt enable register
        volatile uint32_t ICACHE_FCR;  ///< Offset: 0x0C - ICACHE flag clear register
        volatile uint32_t ICACHE_HMONR;  ///< Offset: 0x10 - ICACHE hit monitor register
        volatile uint32_t ICACHE_MMONR;  ///< Offset: 0x14 - ICACHE miss monitor register
        volatile uint32_t ICACHE_CRR0;  ///< Offset: 0x20 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR1;  ///< Offset: 0x24 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR2;  ///< Offset: 0x28 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR3;  ///< Offset: 0x2C - ICACHE region configuration register
    };

    /// Peripheral instances
    inline Registers* ICache = reinterpret_cast<Registers*>(ICache_BASE);

    // Bit definitions
    /// ICACHE_CR Register bits
    namespace icache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t WAYSEL = (1U << 2);  ///< WAYSEL
        constexpr uint32_t HITMEN = (1U << 16);  ///< HITMEN
        constexpr uint32_t MISSMEN = (1U << 17);  ///< MISSMEN
        constexpr uint32_t HITMRST = (1U << 18);  ///< HITMRST
        constexpr uint32_t MISSMRST = (1U << 19);  ///< MISSMRST
    }

    /// ICACHE_SR Register bits
    namespace icache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
    }

    /// ICACHE_IER Register bits
    namespace icache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
    }

    /// ICACHE_FCR Register bits
    namespace icache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
    }

    /// ICACHE_HMONR Register bits
    namespace icache_hmonr_bits {
        constexpr uint32_t HITMON = (32 << 0);  ///< HITMON
    }

    /// ICACHE_MMONR Register bits
    namespace icache_mmonr_bits {
        constexpr uint32_t MISSMON = (16 << 0);  ///< MISSMON
    }

    /// ICACHE_CRR0 Register bits
    namespace icache_crr0_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR1 Register bits
    namespace icache_crr1_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR2 Register bits
    namespace icache_crr2_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR3 Register bits
    namespace icache_crr3_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t SEC_IWDG_BASE = 0x50003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;
    constexpr uint32_t SEC_WWDG_BASE = 0x50002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
        volatile uint32_t EWCR;  ///< Offset: 0x14 - IWDG early wakeup interrupt register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* SEC_IWDG = reinterpret_cast<Registers*>(SEC_IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);
    inline Registers* SEC_WWDG = reinterpret_cast<Registers*>(SEC_WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (4 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EWIF = (1U << 14);  ///< Watchdog Early interrupt flag
        constexpr uint32_t EWU = (1U << 3);  ///< Watchdog interrupt comparator value update
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

    /// EWCR Register bits
    namespace ewcr_bits {
        constexpr uint32_t EWIT = (12 << 0);  ///< Watchdog counter window value
        constexpr uint32_t EWIC = (1U << 14);  ///< Watchdog early interrupt acknowledge
        constexpr uint32_t EWIE = (1U << 15);  ///< Watchdog early interrupt enable
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM1_BASE = 0x46004400;
    constexpr uint32_t SEC_LPTIM1_BASE = 0x56004400;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t SEC_LPTIM2_BASE = 0x50009400;
    constexpr uint32_t LPTIM3_BASE = 0x46004800;
    constexpr uint32_t SEC_LPTIM3_BASE = 0x56004800;
    constexpr uint32_t LPTIM4_BASE = 0x46004C00;
    constexpr uint32_t SEC_LPTIM4_BASE = 0x56004C00;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t SEC_TIM1_BASE = 0x50012C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t SEC_TIM2_BASE = 0x50000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t SEC_TIM3_BASE = 0x50000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t SEC_TIM4_BASE = 0x50000800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t SEC_TIM5_BASE = 0x50000C00;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t SEC_TIM6_BASE = 0x50001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t SEC_TIM7_BASE = 0x50001400;
    constexpr uint32_t TIM8_BASE = 0x40013400;
    constexpr uint32_t SEC_TIM8_BASE = 0x50013400;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t SEC_TIM15_BASE = 0x50014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t SEC_TIM16_BASE = 0x50014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t SEC_TIM17_BASE = 0x50014800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t ISR_output;  ///< Offset: 0x00 - Interrupt and Status Register (output mode)
        volatile uint32_t ISR_input;  ///< Offset: 0x00 - Interrupt and Status Register (intput mode)
        volatile uint32_t ICR_output;  ///< Offset: 0x04 - Interrupt Clear Register (output mode)
        volatile uint32_t ICR_input;  ///< Offset: 0x04 - Interrupt Clear Register (intput mode)
        volatile uint32_t DIER_output;  ///< Offset: 0x08 - LPTIM interrupt Enable Register (output mode)
        volatile uint32_t DIER_input;  ///< Offset: 0x08 - LPTIM interrupt Enable Register (intput mode)
        volatile uint32_t CFGR;  ///< Offset: 0x0C - Configuration Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t CCR1;  ///< Offset: 0x14 - Compare Register
        volatile uint32_t ARR;  ///< Offset: 0x18 - Autoreload Register
        volatile uint32_t CNT;  ///< Offset: 0x1C - Counter Register
        volatile uint32_t CFGR2;  ///< Offset: 0x24 - LPTIM configuration register 2
        volatile uint32_t RCR;  ///< Offset: 0x28 - LPTIM repetition register
        volatile uint32_t CCMR1;  ///< Offset: 0x2C - LPTIM capture/compare mode register 1
        volatile uint32_t CCR2;  ///< Offset: 0x34 - LPTIM Compare Register 2
    };

    /// Peripheral instances
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* SEC_LPTIM1 = reinterpret_cast<Registers*>(SEC_LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* SEC_LPTIM2 = reinterpret_cast<Registers*>(SEC_LPTIM2_BASE);
    inline Registers* LPTIM3 = reinterpret_cast<Registers*>(LPTIM3_BASE);
    inline Registers* SEC_LPTIM3 = reinterpret_cast<Registers*>(SEC_LPTIM3_BASE);
    inline Registers* LPTIM4 = reinterpret_cast<Registers*>(LPTIM4_BASE);
    inline Registers* SEC_LPTIM4 = reinterpret_cast<Registers*>(SEC_LPTIM4_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* SEC_TIM1 = reinterpret_cast<Registers*>(SEC_TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* SEC_TIM2 = reinterpret_cast<Registers*>(SEC_TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* SEC_TIM3 = reinterpret_cast<Registers*>(SEC_TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* SEC_TIM4 = reinterpret_cast<Registers*>(SEC_TIM4_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* SEC_TIM5 = reinterpret_cast<Registers*>(SEC_TIM5_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* SEC_TIM6 = reinterpret_cast<Registers*>(SEC_TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* SEC_TIM7 = reinterpret_cast<Registers*>(SEC_TIM7_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* SEC_TIM8 = reinterpret_cast<Registers*>(SEC_TIM8_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* SEC_TIM15 = reinterpret_cast<Registers*>(SEC_TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* SEC_TIM16 = reinterpret_cast<Registers*>(SEC_TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* SEC_TIM17 = reinterpret_cast<Registers*>(SEC_TIM17_BASE);

    // Bit definitions
    /// ISR_output Register bits
    namespace isr_output_bits {
        constexpr uint32_t DIEROK = (1U << 24);  ///< Interrupt enable register update OK
        constexpr uint32_t CMP2OK = (1U << 19);  ///< Compare register 2 update OK
        constexpr uint32_t CC2IF = (1U << 9);  ///< Compare 2 interrupt flag
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update Ok
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t CMP1OK = (1U << 3);  ///< Compare register 1 update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CC1IF = (1U << 0);  ///< Compare 1 interrupt flag
    }

    /// ISR_input Register bits
    namespace isr_input_bits {
        constexpr uint32_t DIEROK = (1U << 24);  ///< Interrupt enable register update OK
        constexpr uint32_t CC2OF = (1U << 13);  ///< Capture 2 over-capture flag
        constexpr uint32_t CC1OF = (1U << 12);  ///< Capture 1 over-capture flag
        constexpr uint32_t CC2IF = (1U << 9);  ///< Capture 2 interrupt flag
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update Ok
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CC1IF = (1U << 0);  ///< Compare 1 interrupt flag
    }

    /// ICR_output Register bits
    namespace icr_output_bits {
        constexpr uint32_t DIEROKCF = (1U << 24);  ///< Interrupt enable register update OK clear flag
        constexpr uint32_t CMP2OKCF = (1U << 19);  ///< Compare register 2 update OK clear flag
        constexpr uint32_t CC2CF = (1U << 9);  ///< Capture/compare 2 clear flag
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t CMP1OKCF = (1U << 3);  ///< Compare register 1 update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// ICR_input Register bits
    namespace icr_input_bits {
        constexpr uint32_t DIEROKCF = (1U << 24);  ///< Interrupt enable register update OK clear flag
        constexpr uint32_t CC2OCF = (1U << 13);  ///< Capture/compare 2 over-capture clear flag
        constexpr uint32_t CC1OCF = (1U << 12);  ///< Capture/compare 1 over-capture clear flag
        constexpr uint32_t CC2CF = (1U << 9);  ///< Capture/compare 2 clear flag
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// DIER_output Register bits
    namespace dier_output_bits {
        constexpr uint32_t UEDE = (1U << 23);  ///< Update event DMA request enable
        constexpr uint32_t CMP2OKIE = (1U << 19);  ///< Compare register 2 update OK interrupt enable
        constexpr uint32_t CC2IE = (1U << 9);  ///< Capture/compare 2 interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< REPOKIE
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t CMP1OKIE = (1U << 3);  ///< Compare register 1 update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// DIER_input Register bits
    namespace dier_input_bits {
        constexpr uint32_t CC2DE = (1U << 25);  ///< Capture/compare 2 DMA request enable
        constexpr uint32_t CC1DE = (1U << 16);  ///< Capture/compare 1 DMA request enable
        constexpr uint32_t CC2OIE = (1U << 13);  ///< Capture/compare 2 over-capture interrupt enable
        constexpr uint32_t CC1OIE = (1U << 12);  ///< Capture/compare 1 over-capture interrupt enable
        constexpr uint32_t CC2IE = (1U << 9);  ///< Capture/compare 2 interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< REPOKIE
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode
        constexpr uint32_t WAVPOL = (1U << 21);  ///< Waveform shape polarity
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RSTARE = (1U << 4);  ///< Reset after read enable
        constexpr uint32_t COUNTRST = (1U << 3);  ///< Counter reset
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in continuous mode
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in single mode
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM Enable
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/compare 1 value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t IC2SEL = (2 << 20);  ///< LPTIM input capture 2 selection
        constexpr uint32_t IC1SEL = (2 << 16);  ///< LPTIM input capture 1 selection
        constexpr uint32_t IN2SEL = (2 << 4);  ///< LPTIM input 2 selection
        constexpr uint32_t IN1SEL = (2 << 0);  ///< LPTIM input 1 selection
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition register value
    }

    /// CCMR1 Register bits
    namespace ccmr1_bits {
        constexpr uint32_t CC1SEL = (1U << 0);  ///< Capture/compare 1 selection
        constexpr uint32_t CC1E = (1U << 1);  ///< Capture/compare 1 output enable
        constexpr uint32_t CC1P = (2 << 2);  ///< Capture/compare 1 output polarity
        constexpr uint32_t IC1PSC = (2 << 8);  ///< Input capture 1 prescaler
        constexpr uint32_t IC1F = (2 << 12);  ///< Input capture 1 filter
        constexpr uint32_t CC2SEL = (1U << 16);  ///< Capture/compare 2 selection
        constexpr uint32_t CC2E = (1U << 17);  ///< Capture/compare 2 output enable
        constexpr uint32_t CC2P = (2 << 18);  ///< Capture/compare 2 output polarity
        constexpr uint32_t IC2PSC = (2 << 24);  ///< Input capture 2 prescaler
        constexpr uint32_t IC2F = (2 << 28);  ///< Input capture 2 filter
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/compare 2 value
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x46002400;
    constexpr uint32_t SEC_LPUART1_BASE = 0x56002400;
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t SEC_USART1_BASE = 0x50013800;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t SEC_USART3_BASE = 0x50004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t SEC_UART4_BASE = 0x50004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;
    constexpr uint32_t SEC_UART5_BASE = 0x50005000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1_enabled;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR1_disabled;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR_enabled;  ///< Offset: 0x1C - Interrupt and status register
        volatile uint32_t ISR_disabled;  ///< Offset: 0x1C - Interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - prescaler register
        volatile uint32_t AUTOCR;  ///< Offset: 0x30 - Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* SEC_LPUART1 = reinterpret_cast<Registers*>(SEC_LPUART1_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* SEC_USART1 = reinterpret_cast<Registers*>(SEC_USART1_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* SEC_USART3 = reinterpret_cast<Registers*>(SEC_USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* SEC_UART4 = reinterpret_cast<Registers*>(SEC_UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* SEC_UART5 = reinterpret_cast<Registers*>(SEC_UART5_BASE);

    // Bit definitions
    /// CR1_enabled Register bits
    namespace cr1_enabled_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFFIE
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFEIE
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFNEIE
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR1_disabled Register bits
    namespace cr1_disabled_bits {
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFNEIE
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the LPUART node
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFTCFG
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFTIE
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< RXFTCFG
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFTIE
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< BRR
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< TXFRQ
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
    }

    /// ISR_enabled Register bits
    namespace isr_enabled_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFT
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFT
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFF
        constexpr uint32_t TXFF = (1U << 23);  ///< TXFF
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXFNF = (1U << 7);  ///< TXFNF
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXFNE = (1U << 5);  ///< RXFNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NE = (1U << 2);  ///< NE
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ISR_disabled Register bits
    namespace isr_disabled_bits {
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NE = (1U << 2);  ///< NE
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NECF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< PRESCALER
    }

    /// AUTOCR Register bits
    namespace autocr_bits {
        constexpr uint32_t TDN = (16 << 0);  ///< TDN
        constexpr uint32_t TRIGPOL = (1U << 16);  ///< TRIGPOL
        constexpr uint32_t TRIGEN = (1U << 17);  ///< TRIGEN
        constexpr uint32_t IDLEDIS = (1U << 18);  ///< IDLEDIS
        constexpr uint32_t TRIGSEL = (4 << 19);  ///< TRIGSEL
    }

}

// ============================================================================
// MDF1 Peripheral
// ============================================================================

namespace mdf1 {
    /// Base addresses
    constexpr uint32_t MDF1_BASE = 0x40025000;

    /// MDF1 Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - MDF global control register
        volatile uint32_t CKGCR;  ///< Offset: 0x04 - MDF clock generator control register
        volatile uint32_t MDF_SITF0CR;  ///< Offset: 0x80 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF1CR;  ///< Offset: 0x100 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF2CR;  ///< Offset: 0x180 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF3CR;  ///< Offset: 0x200 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF4CR;  ///< Offset: 0x280 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF5CR;  ///< Offset: 0x300 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_BSMX0CR;  ///< Offset: 0x84 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX1CR;  ///< Offset: 0x104 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX2CR;  ///< Offset: 0x184 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX3CR;  ///< Offset: 0x204 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX4CR;  ///< Offset: 0x284 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX5CR;  ///< Offset: 0x304 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_DFLT0CR;  ///< Offset: 0x88 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT1CR;  ///< Offset: 0x108 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT2CR;  ///< Offset: 0x188 - This register is used to control the digital filter 2.
        volatile uint32_t MDF_DFLT3CR;  ///< Offset: 0x208 - This register is used to control the digital filter 3.
        volatile uint32_t MDF_DFLT4CR;  ///< Offset: 0x288 - This register is used to control the digital filter 4.
        volatile uint32_t MDF_DFLT5CR;  ///< Offset: 0x308 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT0CICR;  ///< Offset: 0x8C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT1CICR;  ///< Offset: 0x10C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT2CICR;  ///< Offset: 0x18C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT3CICR;  ///< Offset: 0x20C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT4CICR;  ///< Offset: 0x28C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT5CICR;  ///< Offset: 0x30C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT0RSFR;  ///< Offset: 0x90 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT1RSFR;  ///< Offset: 0x110 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT2RSFR;  ///< Offset: 0x190 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT3RSFR;  ///< Offset: 0x210 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT4RSFR;  ///< Offset: 0x290 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT5RSFR;  ///< Offset: 0x310 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT0INTR;  ///< Offset: 0x94 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT1INTR;  ///< Offset: 0x114 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT2INTR;  ///< Offset: 0x194 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT3INTR;  ///< Offset: 0x214 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT4INTR;  ///< Offset: 0x294 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT5INTR;  ///< Offset: 0x314 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_OLD0CR;  ///< Offset: 0x98 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD1CR;  ///< Offset: 0x118 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD2CR;  ///< Offset: 0x198 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD3CR;  ///< Offset: 0x218 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD4CR;  ///< Offset: 0x298 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD5CR;  ///< Offset: 0x318 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD0THLR;  ///< Offset: 0x9C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD1THLR;  ///< Offset: 0x11C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD2THLR;  ///< Offset: 0x19C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD3THLR;  ///< Offset: 0x21C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD4THLR;  ///< Offset: 0x29C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD5THLR;  ///< Offset: 0x31C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD0THHR;  ///< Offset: 0xA0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD1THHR;  ///< Offset: 0x120 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD2THHR;  ///< Offset: 0x1A0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD3THHR;  ///< Offset: 0x220 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD4THHR;  ///< Offset: 0x2A0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD5THHR;  ///< Offset: 0x320 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_DLY0CR;  ///< Offset: 0xA4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY1CR;  ///< Offset: 0x124 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY2CR;  ///< Offset: 0x1A4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY3CR;  ///< Offset: 0x224 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY4CR;  ///< Offset: 0x2A4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY5CR;  ///< Offset: 0x324 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD0CR;  ///< Offset: 0xA8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD1CR;  ///< Offset: 0x128 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD2CR;  ///< Offset: 0x1A8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD3CR;  ///< Offset: 0x228 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD4CR;  ///< Offset: 0x2A8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD5CR;  ///< Offset: 0x328 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DFLT0IER;  ///< Offset: 0xAC - This register is used for allowing or not the events to...
        volatile uint32_t MDF_DFLT0ISR;  ///< Offset: 0xB0 - MDF DFLT0 interrupt status register 0
        volatile uint32_t MDF_DFLT1IER;  ///< Offset: 0x12C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT2IER;  ///< Offset: 0x1AC - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT3IER;  ///< Offset: 0x22C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT4IER;  ///< Offset: 0x2AC - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT5IER;  ///< Offset: 0x32C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT1ISR;  ///< Offset: 0x130 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT2ISR;  ///< Offset: 0x1B0 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT3ISR;  ///< Offset: 0x230 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT4ISR;  ///< Offset: 0x2B0 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT5ISR;  ///< Offset: 0x330 - This register contains the status flags for each digital...
        volatile uint32_t MDF_OEC0CR;  ///< Offset: 0xB4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC1CR;  ///< Offset: 0x134 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC2CR;  ///< Offset: 0x1B4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC3CR;  ///< Offset: 0x234 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC4CR;  ///< Offset: 0x2B4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC5CR;  ///< Offset: 0x334 - This register contains the offset compensation value.
        volatile uint32_t MDF_SNPS0DR;  ///< Offset: 0xEC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS1DR;  ///< Offset: 0x16C - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS2DR;  ///< Offset: 0x1EC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS3DR;  ///< Offset: 0x26C - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS4DR;  ///< Offset: 0x2EC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS5DR;  ///< Offset: 0x36C - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT0DR;  ///< Offset: 0xF0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT1DR;  ///< Offset: 0x170 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT2DR;  ///< Offset: 0x1F0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT3DR;  ///< Offset: 0x270 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT4DR;  ///< Offset: 0x2F0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT5DR;  ///< Offset: 0x370 - This register is used to read the data processed by each...
    };

    /// Peripheral instances
    inline Registers* MDF1 = reinterpret_cast<Registers*>(MDF1_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t TRGO = (1U << 0);  ///< TRGO
        constexpr uint32_t ILVNB = (4 << 4);  ///< ILVNB
    }

    /// CKGCR Register bits
    namespace ckgcr_bits {
        constexpr uint32_t CKGDEN = (1U << 0);  ///< CKGDEN
        constexpr uint32_t CCK0EN = (1U << 1);  ///< CCK0EN
        constexpr uint32_t CCK1EN = (1U << 2);  ///< CCK1EN
        constexpr uint32_t CKGMOD = (1U << 4);  ///< CKGMOD
        constexpr uint32_t CCK0DIR = (1U << 5);  ///< CCK0DIR
        constexpr uint32_t CCK1DIR = (1U << 6);  ///< CCK1DIR
        constexpr uint32_t TRGSENS = (1U << 8);  ///< TRGSENS
        constexpr uint32_t TRGSRC = (4 << 12);  ///< TRGSRC
        constexpr uint32_t CCKDIV = (4 << 16);  ///< CCKDIV
        constexpr uint32_t PROCDIV = (7 << 24);  ///< PROCDIV
        constexpr uint32_t CKGACTIVE = (1U << 31);  ///< CKGACTIVE
    }

    /// MDF_SITF0CR Register bits
    namespace mdf_sitf0cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF1CR Register bits
    namespace mdf_sitf1cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag
    }

    /// MDF_SITF2CR Register bits
    namespace mdf_sitf2cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag
    }

    /// MDF_SITF3CR Register bits
    namespace mdf_sitf3cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF4CR Register bits
    namespace mdf_sitf4cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF5CR Register bits
    namespace mdf_sitf5cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX0CR Register bits
    namespace mdf_bsmx0cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX1CR Register bits
    namespace mdf_bsmx1cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX2CR Register bits
    namespace mdf_bsmx2cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX3CR Register bits
    namespace mdf_bsmx3cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to a in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX4CR Register bits
    namespace mdf_bsmx4cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX5CR Register bits
    namespace mdf_bsmx5cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_DFLT0CR Register bits
    namespace mdf_dflt0cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT1CR Register bits
    namespace mdf_dflt1cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT2CR Register bits
    namespace mdf_dflt2cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT3CR Register bits
    namespace mdf_dflt3cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT4CR Register bits
    namespace mdf_dflt4cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT5CR Register bits
    namespace mdf_dflt5cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT0CICR Register bits
    namespace mdf_dflt0cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT1CICR Register bits
    namespace mdf_dflt1cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT2CICR Register bits
    namespace mdf_dflt2cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT3CICR Register bits
    namespace mdf_dflt3cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT4CICR Register bits
    namespace mdf_dflt4cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT5CICR Register bits
    namespace mdf_dflt5cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT0RSFR Register bits
    namespace mdf_dflt0rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT1RSFR Register bits
    namespace mdf_dflt1rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT2RSFR Register bits
    namespace mdf_dflt2rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT3RSFR Register bits
    namespace mdf_dflt3rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT4RSFR Register bits
    namespace mdf_dflt4rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT5RSFR Register bits
    namespace mdf_dflt5rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT0INTR Register bits
    namespace mdf_dflt0intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT1INTR Register bits
    namespace mdf_dflt1intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT2INTR Register bits
    namespace mdf_dflt2intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT3INTR Register bits
    namespace mdf_dflt3intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT4INTR Register bits
    namespace mdf_dflt4intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT5INTR Register bits
    namespace mdf_dflt5intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD0CR Register bits
    namespace mdf_old0cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD1CR Register bits
    namespace mdf_old1cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD2CR Register bits
    namespace mdf_old2cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD3CR Register bits
    namespace mdf_old3cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD4CR Register bits
    namespace mdf_old4cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD5CR Register bits
    namespace mdf_old5cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD0THLR Register bits
    namespace mdf_old0thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD1THLR Register bits
    namespace mdf_old1thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD2THLR Register bits
    namespace mdf_old2thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD3THLR Register bits
    namespace mdf_old3thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD4THLR Register bits
    namespace mdf_old4thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD5THLR Register bits
    namespace mdf_old5thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD0THHR Register bits
    namespace mdf_old0thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD1THHR Register bits
    namespace mdf_old1thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD2THHR Register bits
    namespace mdf_old2thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD3THHR Register bits
    namespace mdf_old3thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD4THHR Register bits
    namespace mdf_old4thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD5THHR Register bits
    namespace mdf_old5thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_DLY0CR Register bits
    namespace mdf_dly0cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY1CR Register bits
    namespace mdf_dly1cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY2CR Register bits
    namespace mdf_dly2cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY3CR Register bits
    namespace mdf_dly3cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY4CR Register bits
    namespace mdf_dly4cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY5CR Register bits
    namespace mdf_dly5cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_SCD0CR Register bits
    namespace mdf_scd0cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD1CR Register bits
    namespace mdf_scd1cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD2CR Register bits
    namespace mdf_scd2cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD3CR Register bits
    namespace mdf_scd3cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD4CR Register bits
    namespace mdf_scd4cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD5CR Register bits
    namespace mdf_scd5cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_DFLT0IER Register bits
    namespace mdf_dflt0ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT0ISR Register bits
    namespace mdf_dflt0isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< FTHF
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on , writing 0 has no effect. - 1: Reading 1 means that a new data is available on , writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was higher than OLDTHL when the last OLD event occurred. - 1: The signal was lower than OLDTHL when the last OLD event occurred.
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH when the last OLD event occurred. - 1: The signal was higher than OLDTHH when the last OLD event occurred.
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT1IER Register bits
    namespace mdf_dflt1ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT2IER Register bits
    namespace mdf_dflt2ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT3IER Register bits
    namespace mdf_dflt3ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT4IER Register bits
    namespace mdf_dflt4ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT5IER Register bits
    namespace mdf_dflt5ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT1ISR Register bits
    namespace mdf_dflt1isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT2ISR Register bits
    namespace mdf_dflt2isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT3ISR Register bits
    namespace mdf_dflt3isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT4ISR Register bits
    namespace mdf_dflt4isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT5ISR Register bits
    namespace mdf_dflt5isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_OEC0CR Register bits
    namespace mdf_oec0cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC1CR Register bits
    namespace mdf_oec1cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC2CR Register bits
    namespace mdf_oec2cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC3CR Register bits
    namespace mdf_oec3cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC4CR Register bits
    namespace mdf_oec4cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC5CR Register bits
    namespace mdf_oec5cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_SNPS0DR Register bits
    namespace mdf_snps0dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS1DR Register bits
    namespace mdf_snps1dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS2DR Register bits
    namespace mdf_snps2dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS3DR Register bits
    namespace mdf_snps3dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS4DR Register bits
    namespace mdf_snps4dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS5DR Register bits
    namespace mdf_snps5dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_DFLT0DR Register bits
    namespace mdf_dflt0dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT1DR Register bits
    namespace mdf_dflt1dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT2DR Register bits
    namespace mdf_dflt2dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT3DR Register bits
    namespace mdf_dflt3dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT4DR Register bits
    namespace mdf_dflt4dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT5DR Register bits
    namespace mdf_dflt5dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t OCTOSPI1_BASE = 0x420D1400;
    constexpr uint32_t SEC_OCTOSPI1_BASE = 0x520D1400;
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SEC_SPI1_BASE = 0x50013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SEC_SPI2_BASE = 0x50003800;
    constexpr uint32_t SPI3_BASE = 0x46002000;
    constexpr uint32_t SEC_SPI3_BASE = 0x56002000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DCR1;  ///< Offset: 0x08 - device configuration register 1
        volatile uint32_t DCR2;  ///< Offset: 0x0C - device configuration register 2
        volatile uint32_t DCR3;  ///< Offset: 0x10 - device configuration register 3
        volatile uint32_t DCR4;  ///< Offset: 0x14 - DCR4
        volatile uint32_t SR;  ///< Offset: 0x20 - status register
        volatile uint32_t FCR;  ///< Offset: 0x24 - flag clear register
        volatile uint32_t DLR;  ///< Offset: 0x40 - data length register
        volatile uint32_t AR;  ///< Offset: 0x48 - address register
        volatile uint32_t DR;  ///< Offset: 0x50 - data register
        volatile uint32_t PSMKR;  ///< Offset: 0x80 - polling status mask register
        volatile uint32_t PSMAR;  ///< Offset: 0x88 - polling status match register
        volatile uint32_t PIR;  ///< Offset: 0x90 - polling interval register
        volatile uint32_t CCR;  ///< Offset: 0x100 - communication configuration register
        volatile uint32_t TCR;  ///< Offset: 0x108 - timing configuration register
        volatile uint32_t IR;  ///< Offset: 0x110 - instruction register
        volatile uint32_t ABR;  ///< Offset: 0x120 - alternate bytes register
        volatile uint32_t LPTR;  ///< Offset: 0x130 - low-power timeout register
        volatile uint32_t WPCCR;  ///< Offset: 0x140 - wrap communication configuration register
        volatile uint32_t WPTCR;  ///< Offset: 0x148 - wrap timing configuration register
        volatile uint32_t WPIR;  ///< Offset: 0x150 - wrap instruction register
        volatile uint32_t WPABR;  ///< Offset: 0x160 - wrap alternate bytes register
        volatile uint32_t WCCR;  ///< Offset: 0x180 - write communication configuration register
        volatile uint32_t WTCR;  ///< Offset: 0x188 - write timing configuration register
        volatile uint32_t WIR;  ///< Offset: 0x190 - write instruction register
        volatile uint32_t WABR;  ///< Offset: 0x1A0 - write alternate bytes register
        volatile uint32_t HLCR;  ///< Offset: 0x200 - HyperBus latency configuration register
    };

    /// Peripheral instances
    inline Registers* OCTOSPI1 = reinterpret_cast<Registers*>(OCTOSPI1_BASE);
    inline Registers* SEC_OCTOSPI1 = reinterpret_cast<Registers*>(SEC_OCTOSPI1_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SEC_SPI1 = reinterpret_cast<Registers*>(SEC_SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SEC_SPI2 = reinterpret_cast<Registers*>(SEC_SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SEC_SPI3 = reinterpret_cast<Registers*>(SEC_SPI3_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t FMODE = (2 << 28);  ///< Functional mode
        constexpr uint32_t PMM = (1U << 23);  ///< Polling match mode
        constexpr uint32_t APMS = (1U << 22);  ///< Automatic poll mode stop
        constexpr uint32_t TOIE = (1U << 20);  ///< TimeOut interrupt enable
        constexpr uint32_t SMIE = (1U << 19);  ///< Status match interrupt enable
        constexpr uint32_t FTIE = (1U << 18);  ///< FIFO threshold interrupt enable
        constexpr uint32_t TCIE = (1U << 17);  ///< Transfer complete interrupt enable
        constexpr uint32_t TEIE = (1U << 16);  ///< Transfer error interrupt enable
        constexpr uint32_t FTHRES = (5 << 8);  ///< IFO threshold level
        constexpr uint32_t FSEL = (1U << 7);  ///< FLASH memory selection
        constexpr uint32_t DQM = (1U << 6);  ///< Dual-quad mode
        constexpr uint32_t TCEN = (1U << 3);  ///< Timeout counter enable
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA enable
        constexpr uint32_t ABORT = (1U << 1);  ///< Abort request
        constexpr uint32_t EN = (1U << 0);  ///< Enable
    }

    /// DCR1 Register bits
    namespace dcr1_bits {
        constexpr uint32_t CKMODE = (1U << 0);  ///< Mode 0 / mode 3
        constexpr uint32_t FRCK = (1U << 1);  ///< Free running clock
        constexpr uint32_t DLYBYP = (1U << 3);  ///< Delay block bypass
        constexpr uint32_t CSHT = (6 << 8);  ///< Chip-select high time
        constexpr uint32_t DEVSIZE = (5 << 16);  ///< Device size
        constexpr uint32_t MTYP = (3 << 24);  ///< Memory type
    }

    /// DCR2 Register bits
    namespace dcr2_bits {
        constexpr uint32_t PRESCALER = (8 << 0);  ///< Clock prescaler
        constexpr uint32_t WRAPSIZE = (3 << 16);  ///< Wrap size
    }

    /// DCR3 Register bits
    namespace dcr3_bits {
        constexpr uint32_t MAXTRAN = (8 << 0);  ///< Maximum transfer
        constexpr uint32_t CSBOUND = (5 << 16);  ///< CS boundary
    }

    /// DCR4 Register bits
    namespace dcr4_bits {
        constexpr uint32_t REFRESH = (32 << 0);  ///< Refresh rate
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TEF = (1U << 0);  ///< Transfer error flag
        constexpr uint32_t TCF = (1U << 1);  ///< transfer complete flag
        constexpr uint32_t FTF = (1U << 2);  ///< FIFO threshold flag
        constexpr uint32_t SMF = (1U << 3);  ///< status match flag
        constexpr uint32_t TOF = (1U << 4);  ///< timeout flag
        constexpr uint32_t BUSY = (1U << 5);  ///< BUSY
        constexpr uint32_t FLEVEL = (6 << 8);  ///< FIFO level
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t CTEF = (1U << 0);  ///< Clear Transfer error flag
        constexpr uint32_t CTCF = (1U << 1);  ///< Clear transfer complete flag
        constexpr uint32_t CSMF = (1U << 3);  ///< Clear status match flag
        constexpr uint32_t CTOF = (1U << 4);  ///< Clear timeout flag
    }

    /// DLR Register bits
    namespace dlr_bits {
        constexpr uint32_t DL = (32 << 0);  ///< Data length
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< ADDRESS
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< DATA
    }

    /// PSMKR Register bits
    namespace psmkr_bits {
        constexpr uint32_t MASK = (32 << 0);  ///< Status MASK
    }

    /// PSMAR Register bits
    namespace psmar_bits {
        constexpr uint32_t MATCH = (32 << 0);  ///< Status match
    }

    /// PIR Register bits
    namespace pir_bits {
        constexpr uint32_t INTERVAL = (16 << 0);  ///< polling interval
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t IMODE = (3 << 0);  ///< Instruction mode
        constexpr uint32_t IDTR = (1U << 3);  ///< Instruction double transfer rate
        constexpr uint32_t ISIZE = (2 << 4);  ///< Instruction size
        constexpr uint32_t ADMODE = (3 << 8);  ///< Address mode
        constexpr uint32_t ADDTR = (1U << 11);  ///< Address double transfer rate
        constexpr uint32_t ABMODE = (3 << 16);  ///< Alternate byte mode
        constexpr uint32_t ABDTR = (1U << 19);  ///< Alternate bytes double transfer rate
        constexpr uint32_t ABSIZE = (2 << 20);  ///< Alternate bytes size
        constexpr uint32_t DMODE = (3 << 24);  ///< Data mode
        constexpr uint32_t DDTR = (1U << 27);  ///< Alternate bytes double transfer rate
        constexpr uint32_t DQSE = (1U << 29);  ///< DQS enable
        constexpr uint32_t SIOO = (1U << 31);  ///< Send instruction only once mode
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t DCYC = (5 << 0);  ///< Number of dummy cycles
        constexpr uint32_t DHQC = (1U << 28);  ///< Delay hold quarter cycle
        constexpr uint32_t SSHIFT = (1U << 30);  ///< Sample shift
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t INSTRUCTION = (32 << 0);  ///< INSTRUCTION
    }

    /// ABR Register bits
    namespace abr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< Alternate bytes
    }

    /// LPTR Register bits
    namespace lptr_bits {
        constexpr uint32_t TIMEOUT = (16 << 0);  ///< Timeout period
    }

    /// WPCCR Register bits
    namespace wpccr_bits {
        constexpr uint32_t IMODE = (3 << 0);  ///< Instruction mode
        constexpr uint32_t IDTR = (1U << 3);  ///< Instruction double transfer rate
        constexpr uint32_t ISIZE = (2 << 4);  ///< Instruction size
        constexpr uint32_t ADMODE = (3 << 8);  ///< Address mode
        constexpr uint32_t ADDTR = (1U << 11);  ///< Address double transfer rate
        constexpr uint32_t ABMODE = (3 << 16);  ///< Alternate byte mode
        constexpr uint32_t ABDTR = (1U << 19);  ///< Alternate bytes double transfer rate
        constexpr uint32_t ABSIZE = (2 << 20);  ///< Alternate bytes size
        constexpr uint32_t DMODE = (3 << 24);  ///< Data mode
        constexpr uint32_t DDTR = (1U << 27);  ///< alternate bytes double transfer rate
        constexpr uint32_t DQSE = (1U << 29);  ///< DQS enable
    }

    /// WPTCR Register bits
    namespace wptcr_bits {
        constexpr uint32_t DCYC = (5 << 0);  ///< Number of dummy cycles
        constexpr uint32_t DHQC = (1U << 28);  ///< Delay hold quarter cycle
        constexpr uint32_t SSHIFT = (1U << 30);  ///< Sample shift
    }

    /// WPIR Register bits
    namespace wpir_bits {
        constexpr uint32_t INSTRUCTION = (32 << 0);  ///< INSTRUCTION
    }

    /// WPABR Register bits
    namespace wpabr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< Alternate bytes
    }

    /// WCCR Register bits
    namespace wccr_bits {
        constexpr uint32_t IMODE = (3 << 0);  ///< Instruction mode
        constexpr uint32_t IDTR = (1U << 3);  ///< Instruction double transfer rate
        constexpr uint32_t ISIZE = (2 << 4);  ///< Instruction size
        constexpr uint32_t ADMODE = (3 << 8);  ///< Address mode
        constexpr uint32_t ADDTR = (1U << 11);  ///< Address double transfer rate
        constexpr uint32_t ABMODE = (3 << 16);  ///< Alternate byte mode
        constexpr uint32_t ABDTR = (1U << 19);  ///< Alternate bytes double transfer rate
        constexpr uint32_t ABSIZE = (2 << 20);  ///< Alternate bytes size
        constexpr uint32_t DMODE = (3 << 24);  ///< Data mode
        constexpr uint32_t DDTR = (1U << 27);  ///< alternate bytes double transfer rate
        constexpr uint32_t DQSE = (1U << 29);  ///< DQS enable
    }

    /// WTCR Register bits
    namespace wtcr_bits {
        constexpr uint32_t DCYC = (5 << 0);  ///< Number of dummy cycles
    }

    /// WIR Register bits
    namespace wir_bits {
        constexpr uint32_t INSTRUCTION = (32 << 0);  ///< INSTRUCTION
    }

    /// WABR Register bits
    namespace wabr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< ALTERNATE
    }

    /// HLCR Register bits
    namespace hlcr_bits {
        constexpr uint32_t LM = (1U << 0);  ///< Latency mode
        constexpr uint32_t WZL = (1U << 1);  ///< Write zero latency
        constexpr uint32_t TACC = (8 << 8);  ///< Access time
        constexpr uint32_t TRWR = (8 << 16);  ///< Read write recovery time
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x46005000;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP1_CSR;  ///< Offset: 0x00 - OPAMP1 control/status register
        volatile uint32_t OPAMP1_OTR;  ///< Offset: 0x04 - OPAMP1 offset trimming register in normal mode
        volatile uint32_t OPAMP1_LPOTR;  ///< Offset: 0x08 - OPAMP1 offset trimming register in low-power mode
        volatile uint32_t OPAMP2_CRS;  ///< Offset: 0x10 - OPAMP2 control/status register
        volatile uint32_t OPAMP2_OTR;  ///< Offset: 0x14 - OPAMP2 offset trimming register in normal mode
        volatile uint32_t OPAMP2_LPOTR;  ///< Offset: 0x18 - OPAMP2 offset trimming register in low-power mode
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP1_CSR Register bits
    namespace opamp1_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< OPAMP enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< OPAMP low-power mode The OPAMP must be disabled to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< OPAMP PGA mode 00 and 01: internal PGA disabled
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< OPAMP programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. 1x: inverting input not externally connected
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non-inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< ‘factory’ or ‘user’ offset trimmed values selection This bit is active for normal and low-power modes.
        constexpr uint32_t CALOUT = (1U << 15);  ///< OPAMP calibration output During the calibration mode, the offset is trimmed when this signal toggles.
        constexpr uint32_t OPAHSM = (1U << 30);  ///< OPAMP high-speed mode This bit is effective for both normal and low-power modes.
        constexpr uint32_t OPA_RANGE = (1U << 31);  ///< OPAMP range setting This bit must be set before enabling the OPAMP and this bit affects all OPAMP instances.
    }

    /// OPAMP1_OTR Register bits
    namespace opamp1_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP1_LPOTR Register bits
    namespace opamp1_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

    /// OPAMP2_CRS Register bits
    namespace opamp2_crs_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< OPAMP enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< OPAMP low-power mode The OPAMP must be disabled to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< OPAMP PGA mode 00 and 01: internal PGA disabled
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< OPAMP programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. in PGA mode for filtering) 1x: inverting input not externally connected
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< ‘factory’ or ‘user’ offset trimmed values selection This bit is active for normal and low-power modes.
        constexpr uint32_t CALOUT = (1U << 15);  ///< OPAMP calibration output During calibration mode, the offset is trimmed when this signal toggles.
        constexpr uint32_t OPAHSM = (1U << 30);  ///< OPAMP high-speed mode This bit is effective for both normal and high-speed modes.
    }

    /// OPAMP2_OTR Register bits
    namespace opamp2_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_LPOTR Register bits
    namespace opamp2_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

}

// ============================================================================
// PSSI Peripheral
// ============================================================================

namespace pssi {
    /// Base addresses
    constexpr uint32_t PSSI_BASE = 0x4202C400;

    /// PSSI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - PSSI control register
        volatile uint32_t SR;  ///< Offset: 0x04 - PSSI status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - PSSI raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - PSSI interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - PSSI masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - PSSI interrupt clear register
        volatile uint32_t DR;  ///< Offset: 0x28 - PSSI data register
    };

    /// Peripheral instances
    inline Registers* PSSI = reinterpret_cast<Registers*>(PSSI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CKPOL = (1U << 5);  ///< Parallel data clock polarity 		This bit configures the capture edge of the parallel clock or the edge used for driving outputs, depending on OUTEN.
        constexpr uint32_t DEPOL = (1U << 6);  ///< Data enable (PSSI_DE) polarity 		This bit indicates the level on the PSSI_DE pin when the data are not valid on the parallel interface.
        constexpr uint32_t RDYPOL = (1U << 8);  ///< Ready (PSSI_RDY) polarity 		This bit indicates the level on the PSSI_RDY pin when the data are not valid on the parallel interface.
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< PSSI enable 		The contents of the FIFO are flushed when ENABLE is cleared to 0. 		Note: When ENABLE=1, the content of PSSI_CR must not be changed, except for the ENABLE bit itself. All configuration bits can change as soon as ENABLE changes from 0 to 1. 		The DMA controller and all PSSI configuration registers must be programmed correctly before setting the ENABLE bit to 1. 		The ENABLE bit and the DCMI ENABLE bit (bit 15 of DCMI_CR) must not be set to 1 at the same time.
        constexpr uint32_t DERDYCFG = (3 << 18);  ///< Data enable and ready configuration 		When the PSSI_RDY function is mapped to the PSSI_DE pin (settings 101 or 111), it is still the RDYPOL bit which determines its polarity. Similarly, when the PSSI_DE function is mapped to the PSSI_RDY pin (settings 110 or 111), it is still the DEPOL bit which determines its polarity.
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA enable bit
        constexpr uint32_t OUTEN = (1U << 31);  ///< Data direction selection bit
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RTT4B = (1U << 2);  ///< RTT4B
        constexpr uint32_t RTT1B = (1U << 3);  ///< RTT1B
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< OVR_RIS
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t OVR_IE = (1U << 1);  ///< OVR_IE
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< OVR_MIS
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< OVR_ISC
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t BYTE0 = (8 << 0);  ///< Data byte 0
        constexpr uint32_t BYTE1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t BYTE2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t BYTE3 = (8 << 24);  ///< Data byte 3
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x46020800;
    constexpr uint32_t SEC_PWR_BASE = 0x56020800;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWR_CR1;  ///< Offset: 0x00 - PWR control register 1
        volatile uint32_t PWR_CR2;  ///< Offset: 0x04 - PWR control register 2
        volatile uint32_t PWR_CR3;  ///< Offset: 0x08 - PWR control register 3
        volatile uint32_t PWR_VOSR;  ///< Offset: 0x0C - PWR voltage scaling register
        volatile uint32_t PWR_SVMCR;  ///< Offset: 0x10 - PWR supply voltage monitoring control register
        volatile uint32_t PWR_WUCR1;  ///< Offset: 0x14 - PWR wakeup control register 1
        volatile uint32_t PWR_WUCR2;  ///< Offset: 0x18 - PWR wakeup control register 2
        volatile uint32_t PWR_WUCR3;  ///< Offset: 0x1C - PWR wakeup control register 3
        volatile uint32_t PWR_BDCR1;  ///< Offset: 0x20 - PWR Backup domain control register 1
        volatile uint32_t PWR_BDCR2;  ///< Offset: 0x24 - PWR Backup domain control register 2
        volatile uint32_t PWR_DBPR;  ///< Offset: 0x28 - PWR disable Backup domain register
        volatile uint32_t PWR_UCPDR;  ///< Offset: 0x2C - PWR USB Type-C™ and Power Delivery register
        volatile uint32_t PWR_SECCFGR;  ///< Offset: 0x30 - PWR security configuration register
        volatile uint32_t PWR_PRIVCFGR;  ///< Offset: 0x34 - PWR privilege control register
        volatile uint32_t PWR_SR;  ///< Offset: 0x38 - PWR status register
        volatile uint32_t PWR_SVMSR;  ///< Offset: 0x3C - PWR supply voltage monitoring status register
        volatile uint32_t PWR_BDSR;  ///< Offset: 0x40 - PWR Backup domain status register
        volatile uint32_t PWR_WUSR;  ///< Offset: 0x44 - PWR wakeup status register
        volatile uint32_t PWR_WUSCR;  ///< Offset: 0x48 - PWR wakeup status clear register
        volatile uint32_t PWR_APCR;  ///< Offset: 0x4C - PWR apply pull configuration register
        volatile uint32_t PWR_PUCRA;  ///< Offset: 0x50 - PWR port A pull-up control register
        volatile uint32_t PWR_PDCRA;  ///< Offset: 0x54 - PWR port A pull-down control register
        volatile uint32_t PWR_PUCRB;  ///< Offset: 0x58 - PWR port B pull-up control register
        volatile uint32_t PWR_PDCRB;  ///< Offset: 0x5C - PWR port B pull-down control register
        volatile uint32_t PWR_PUCRC;  ///< Offset: 0x60 - Power port C pull up control register
        volatile uint32_t PWR_PDCRC;  ///< Offset: 0x64 - PWR port C pull-down control register
        volatile uint32_t PWR_PUCRD;  ///< Offset: 0x68 - PWR port D pull-up control register
        volatile uint32_t PWR_PDCRD;  ///< Offset: 0x6C - PWR port D pull-down control register
        volatile uint32_t PWR_PUCRE;  ///< Offset: 0x70 - PWR port E pull-up control register
        volatile uint32_t PWR_PDCRE;  ///< Offset: 0x74 - PWR port E pull-down control register
        volatile uint32_t PWR_PUCRF;  ///< Offset: 0x78 - PWR port F pull-up control register
        volatile uint32_t PWR_PDCRF;  ///< Offset: 0x7C - PWR port F pull-down control register
        volatile uint32_t PWR_PUCRG;  ///< Offset: 0x80 - PWR port G pull-up control register
        volatile uint32_t PWR_PDCRG;  ///< Offset: 0x84 - PWR port G pull-down control register
        volatile uint32_t PWR_PUCRH;  ///< Offset: 0x88 - PWR port H pull-up control register
        volatile uint32_t PWR_PDCRH;  ///< Offset: 0x8C - PWR port H pull-down control register
        volatile uint32_t PWR_PUCRI;  ///< Offset: 0x90 - PWR port I pull-up control register
        volatile uint32_t PWR_PDCRI;  ///< Offset: 0x94 - PWR port I pull-down control register
        volatile uint32_t PWR_PUCRJ;  ///< Offset: 0x98 - PWR port J pull-up control register
        volatile uint32_t PWR_PDCRJ;  ///< Offset: 0x9C - PWR port J pull-down control register
        volatile uint32_t PWR_CR4;  ///< Offset: 0xA8 - PWR control register 4
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);
    inline Registers* SEC_PWR = reinterpret_cast<Registers*>(SEC_PWR_BASE);

    // Bit definitions
    /// PWR_CR1 Register bits
    namespace pwr_cr1_bits {
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection These bits select the low-power mode entered when the CPU enters the Deepsleep mode. 10x: Standby mode (Standby mode also entered if LPMS = 11X in PWR_CR1 with BREN = 1 in PWR_BDCR1) 11x: Shutdown mode if BREN = 0 in PWR_BDCR1
        constexpr uint32_t RRSB1 = (1U << 5);  ///< SRAM2 page 1 retention in Stop 3 and Standby modes This bit is used to keep the SRAM2 page 1 content in Stop 3 and Standby modes. The SRAM2 page 1 corresponds to the first 8 Kbytes of the SRAM2 (from SRAM2 base address to SRAM2 base address + 0x1FFF). Note: This bit has no effect in Shutdown mode.
        constexpr uint32_t RRSB2 = (1U << 6);  ///< SRAM2 page 2 retention in Stop 3 and Standby modes This bit is used to keep the SRAM2 page 2 content in Stop 3 and Standby modes. The SRAM2 page 2 corresponds to the last 56 Kbytes of the SRAM2 (from SRAM2 base address + 0x2000 to SRAM2 base address + 0xFFFF). Note: This bit has no effect in Shutdown mode.
        constexpr uint32_t ULPMEN = (1U << 7);  ///< BOR ultra-low power mode This bit is used to reduce the consumption by configuring the BOR in discontinuous mode. This bit must be set to reach the lowest power consumption in the low-power modes.
        constexpr uint32_t SRAM1PD = (1U << 8);  ///< SRAM1 power down This bit is used to reduce the consumption by powering off the SRAM1.
        constexpr uint32_t SRAM2PD = (1U << 9);  ///< SRAM2 power down This bit is used to reduce the consumption by powering off the SRAM2.
        constexpr uint32_t SRAM4PD = (1U << 11);  ///< SRAM4 power down This bit is used to reduce the consumption by powering off the SRAM4.
        constexpr uint32_t SRAM5PD = (1U << 12);  ///< SRAM5 power down This bit is used to reduce the consumption by powering off the SRAM5. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
    }

    /// PWR_CR2 Register bits
    namespace pwr_cr2_bits {
        constexpr uint32_t SRAM1PDS1 = (1U << 0);  ///< SRAM1 page 1 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM1PDS2 = (1U << 1);  ///< SRAM1 page 2 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM1PDS3 = (1U << 2);  ///< SRAM1 page 3 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM2PDS1 = (1U << 4);  ///< SRAM2 page 1 (8 Kbytes) power-down in Stop modes (Stop 0, 1, 2) Note: The SRAM2 page 1 retention in Stop 3 is controlled by RRSB1 bit in PWR_CR1.
        constexpr uint32_t SRAM2PDS2 = (1U << 5);  ///< SRAM2 page 2 (56 Kbytes) power-down in Stop modes (Stop 0, 1, 2) Note: The SRAM2 page 2 retention in Stop 3 is controlled by RRSB2 bit in PWR_CR1.
        constexpr uint32_t SRAM4PDS = (1U << 6);  ///< SRAM4 power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t ICRAMPDS = (1U << 8);  ///< ICACHE SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t DC1RAMPDS = (1U << 9);  ///< DCACHE1 SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t PRAMPDS = (1U << 11);  ///< FMAC, FDCAN and USB peripherals SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM4FWU = (1U << 13);  ///< SRAM4 fast wakeup from Stop 0, Stop 1 and Stop 2 modes This bit is used to obtain the best trade-off between low-power consumption and wakeup time. SRAM4 wakeup time increases the wakeup time when exiting Stop 0, 1 and 2 modes, and also increases the LPDMA access time to SRAM4 during Stop modes.
        constexpr uint32_t FLASHFWU = (1U << 14);  ///< Flash memory fast wakeup from Stop 0 and Stop 1 modes This bit is used to obtain the best trade-off between low-power consumption and wakeup time when exiting the Stop 0 or Stop 1 modes. When this bit is set, the Flash memory remains in normal mode in Stop 0 and Stop 1 modes, which offers a faster startup time with higher consumption.
        constexpr uint32_t SRDRUN = (1U << 31);  ///< SmartRun domain in Run mode
    }

    /// PWR_CR3 Register bits
    namespace pwr_cr3_bits {
        constexpr uint32_t REGSEL = (1U << 1);  ///< Regulator selection Note: REGSEL is reserved and must be kept at reset value in packages without SMPS.
        constexpr uint32_t FSTEN = (1U << 2);  ///< Fast soft start
    }

    /// PWR_VOSR Register bits
    namespace pwr_vosr_bits {
        constexpr uint32_t USBBOOSTRDY = (1U << 13);  ///< USB EPOD booster ready This bit is set to 1 by hardware when the power booster startup time is reached. The USB clock can be provided only after this bit is set. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t BOOSTRDY = (1U << 14);  ///< EPOD booster ready This bit is set to 1 by hardware when the power booster startup time is reached. The system clock frequency can be switched higher than 50 MHz only after this bit is set.
        constexpr uint32_t VOSRDY = (1U << 15);  ///< Ready bit for VCORE voltage scaling output selection
        constexpr uint32_t VOS = (2 << 16);  ///< Voltage scaling range selection This field is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1.
        constexpr uint32_t BOOSTEN = (1U << 18);  ///< EPOD booster enable This bit is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1. This bit must be set in range 1 and range 2 before increasing the system clock frequency above 50 MHz. This bit is reset when going into Stop modes (0, 1, 2, 3).
        constexpr uint32_t USBPWREN = (1U << 19);  ///< USB power enable This bit is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t USBBOOSTEN = (1U << 20);  ///< USB EPOD booster enable This bit is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1. This bit must be set in range 1 and range 2 before enabling the USB peripheral. This bit is reset when going into Stop modes (0, 1, 2, 3). Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
    }

    /// PWR_SVMCR Register bits
    namespace pwr_svmcr_bits {
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t PVDLS = (3 << 5);  ///< Power voltage detector level selection These bits select the voltage threshold detected by the power voltage detector:
        constexpr uint32_t UVMEN = (1U << 24);  ///< VDDUSB independent USB voltage monitor enable
        constexpr uint32_t IO2VMEN = (1U << 25);  ///< VDDIO2 independent I/Os voltage monitor enable
        constexpr uint32_t AVM1EN = (1U << 26);  ///< VDDA independent analog supply voltage monitor 1 enable (1.6 V threshold)
        constexpr uint32_t AVM2EN = (1U << 27);  ///< VDDA independent analog supply voltage monitor 2 enable (1.8 V threshold)
        constexpr uint32_t USV = (1U << 28);  ///< VDDUSB independent USB supply valid This bit is used to validate the VDDUSB supply for electrical and logical isolation purpose. Setting this bit is mandatory to use the USB peripheral. If VDDUSB is not always present in the application, the VDDUSB voltage monitor can be used to determine whether this supply is ready or not.
        constexpr uint32_t IO2SV = (1U << 29);  ///< VDDIO2 independent I/Os supply valid This bit is used to validate the VDDIO2 supply for electrical and logical isolation purpose. Setting this bit is mandatory to use PG[15:2]. If VDDIO2 is not always present in the application, the VDDIO2 voltage monitor can be used to determine whether this supply is ready or not.
        constexpr uint32_t ASV = (1U << 30);  ///< VDDA independent analog supply valid This bit is used to validate the VDDA supply for electrical and logical isolation purpose. Setting this bit is mandatory to use the analog peripherals. If VDDA is not always present in the application, the VDDA voltage monitor can be used to determine whether this supply is ready or not.
    }

    /// PWR_WUCR1 Register bits
    namespace pwr_wucr1_bits {
        constexpr uint32_t WUPEN1 = (1U << 0);  ///< Wakeup pin WKUP1 enable
        constexpr uint32_t WUPEN2 = (1U << 1);  ///< Wakeup pin WKUP2 enable
        constexpr uint32_t WUPEN3 = (1U << 2);  ///< Wakeup pin WKUP3 enable
        constexpr uint32_t WUPEN4 = (1U << 3);  ///< Wakeup pin WKUP4 enable
        constexpr uint32_t WUPEN5 = (1U << 4);  ///< Wakeup pin WKUP5 enable
        constexpr uint32_t WUPEN6 = (1U << 5);  ///< Wakeup pin WKUP6 enable
        constexpr uint32_t WUPEN7 = (1U << 6);  ///< Wakeup pin WKUP7 enable
        constexpr uint32_t WUPEN8 = (1U << 7);  ///< Wakeup pin WKUP8 enable
    }

    /// PWR_WUCR2 Register bits
    namespace pwr_wucr2_bits {
        constexpr uint32_t WUPP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity. This bit must be configured when WUPEN1 = 0.
        constexpr uint32_t WUPP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity This bit must be configured when WUPEN2 = 0.
        constexpr uint32_t WUPP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity This bit must be configured when WUPEN3 = 0.
        constexpr uint32_t WUPP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity This bit must be configured when WUPEN4 = 0.
        constexpr uint32_t WUPP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity This bit must be configured when WUPEN5 = 0.
        constexpr uint32_t WUPP6 = (1U << 5);  ///< Wakeup pin WKUP6 polarity This bit must be configured when WUPEN6 = 0.
        constexpr uint32_t WUPP7 = (1U << 6);  ///< Wakeup pin WKUP7 polarity This bit must be configured when WUPEN7 = 0.
        constexpr uint32_t WUPP8 = (1U << 7);  ///< Wakeup pin WKUP8 polarity This bit must be configured when WUPEN8 = 0.
    }

    /// PWR_WUCR3 Register bits
    namespace pwr_wucr3_bits {
        constexpr uint32_t WUSEL1 = (2 << 0);  ///< Wakeup pin WKUP1 selection This field must be configured when WUPEN1 = 0.
        constexpr uint32_t WUSEL2 = (2 << 2);  ///< Wakeup pin WKUP2 selection This field must be configured when WUPEN2 = 0.
        constexpr uint32_t WUSEL3 = (2 << 4);  ///< Wakeup pin WKUP3 selection This field must be configured when WUPEN3 = 0.
        constexpr uint32_t WUSEL4 = (2 << 6);  ///< Wakeup pin WKUP4 selection This field must be configured when WUPEN4 = 0.
        constexpr uint32_t WUSEL5 = (2 << 8);  ///< Wakeup pin WKUP5 selection This field must be configured when WUPEN5 = 0.
        constexpr uint32_t WUSEL6 = (2 << 10);  ///< Wakeup pin WKUP6 selection This field must be configured when WUPEN6 = 0.
        constexpr uint32_t WUSEL7 = (2 << 12);  ///< Wakeup pin WKUP7 selection This field must be configured when WUPEN7 = 0.
        constexpr uint32_t WUSEL8 = (2 << 14);  ///< Wakeup pin WKUP8 selection This field must be configured when WUPEN8 = 0.
    }

    /// PWR_BDCR1 Register bits
    namespace pwr_bdcr1_bits {
        constexpr uint32_t BREN = (1U << 0);  ///< Backup RAM retention in Standby and VBAT modes When this bit is set, the backup RAM content is kept in Standby and VBAT modes. If BREN is reset, the backup RAM can still be used in Run, Sleep and Stop modes. However, its content is lost in Standby, Shutdown and VBAT modes. This bit can be written only when the regulator is LDO, which must be configured before switching to SMPS. Note: Backup RAM cannot be preserved in Shutdown mode.
        constexpr uint32_t MONEN = (1U << 4);  ///< Backup domain voltage and temperature monitoring enable
    }

    /// PWR_BDCR2 Register bits
    namespace pwr_bdcr2_bits {
        constexpr uint32_t VBE = (1U << 0);  ///< VBAT charging enable
        constexpr uint32_t VBRS = (1U << 1);  ///< VBAT charging resistor selection
    }

    /// PWR_DBPR Register bits
    namespace pwr_dbpr_bits {
        constexpr uint32_t DBP = (1U << 0);  ///< Disable Backup domain write protection In reset state, all registers and SRAM in Backup domain are protected against parasitic write access. This bit must be set to enable the write access to these registers.
    }

    /// PWR_UCPDR Register bits
    namespace pwr_ucpdr_bits {
        constexpr uint32_t UCPD_DBDIS = (1U << 0);  ///< UCPD dead battery disable After exiting reset, the USB Type-C “dead battery” behavior is enabled, which may have a pull-down effect on CC1 and CC2 pins. It is recommended to disable it in all cases, either to stop this pull-down or to handover control to the UCPD (the UCPD must be initialized before doing the disable).
        constexpr uint32_t UCPD_STBY = (1U << 1);  ///< UCPD Standby mode When set, this bit is used to memorize the UCPD configuration in Standby mode. This bit must be written to 1 just before entering Standby mode when using UCPD. It must be written to 0 after exiting the Standby mode and before writing any UCPD registers.
    }

    /// PWR_SECCFGR Register bits
    namespace pwr_seccfgr_bits {
        constexpr uint32_t WUP1SEC = (1U << 0);  ///< WUP1 secure protection
        constexpr uint32_t WUP2SEC = (1U << 1);  ///< WUP2 secure protection
        constexpr uint32_t WUP3SEC = (1U << 2);  ///< WUP3 secure protection
        constexpr uint32_t WUP4SEC = (1U << 3);  ///< WUP4 secure protection
        constexpr uint32_t WUP5SEC = (1U << 4);  ///< WUP5 secure protection
        constexpr uint32_t WUP6SEC = (1U << 5);  ///< WUP6 secure protection
        constexpr uint32_t WUP7SEC = (1U << 6);  ///< WUP7 secure protection
        constexpr uint32_t WUP8SEC = (1U << 7);  ///< WUP8 secure protection
        constexpr uint32_t LPMSEC = (1U << 12);  ///< Low-power modes secure protection
        constexpr uint32_t VDMSEC = (1U << 13);  ///< Voltage detection and monitoring secure protection
        constexpr uint32_t VBSEC = (1U << 14);  ///< Backup domain secure protection
        constexpr uint32_t APCSEC = (1U << 15);  ///< Pull-up/pull-down secure protection
    }

    /// PWR_PRIVCFGR Register bits
    namespace pwr_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< PWR secure functions privilege configuration This bit is set and reset by software. It can be written only by a secure privileged access.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< PWR non-secure functions privilege configuration This bit is set and reset by software. It can be written only by privileged access, secure or non-secure.
    }

    /// PWR_SR Register bits
    namespace pwr_sr_bits {
        constexpr uint32_t CSSF = (1U << 0);  ///< Clear Stop and Standby flags This bit is protected against non-secure access when LPMSEC = 1 in PWR_SECCFGR. This bit is protected against unprivileged access when LPMSEC = 1 and SPRIV = 1 in PWR_PRIVCFGR, or when LPMSEC = 0 and NSPRIV = 1. Writing 1 to this bit clears the STOPF and SBF flags.
        constexpr uint32_t STOPF = (1U << 1);  ///< Stop flag This bit is set by hardware when the device enters a Stop mode, and is cleared by software by writing 1 to the CSSF bit.
        constexpr uint32_t SBF = (1U << 2);  ///< Standby flag This bit is set by hardware when the device enters the Standby mode, and is cleared by writing 1 to the CSSF bit, or by a power-on reset. It is not cleared by the system reset.
    }

    /// PWR_SVMSR Register bits
    namespace pwr_svmsr_bits {
        constexpr uint32_t REGS = (1U << 1);  ///< Regulator selection
        constexpr uint32_t PVDO = (1U << 4);  ///< VDD voltage detector output
        constexpr uint32_t ACTVOSRDY = (1U << 15);  ///< Voltage level ready for currently used VOS
        constexpr uint32_t ACTVOS = (2 << 16);  ///< VOS currently applied to VCORE This field provides the last VOS value.
        constexpr uint32_t VDDUSBRDY = (1U << 24);  ///< VDDUSB ready
        constexpr uint32_t VDDIO2RDY = (1U << 25);  ///< VDDIO2 ready
        constexpr uint32_t VDDA1RDY = (1U << 26);  ///< VDDA ready versus 1.6V voltage monitor
        constexpr uint32_t VDDA2RDY = (1U << 27);  ///< VDDA ready versus 1.8 V voltage monitor
    }

    /// PWR_BDSR Register bits
    namespace pwr_bdsr_bits {
        constexpr uint32_t VBATH = (1U << 1);  ///< Backup domain voltage level monitoring versus high threshold
        constexpr uint32_t TEMPL = (1U << 2);  ///< Temperature level monitoring versus low threshold
        constexpr uint32_t TEMPH = (1U << 3);  ///< Temperature level monitoring versus high threshold
    }

    /// PWR_WUSR Register bits
    namespace pwr_wusr_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1 This bit is set when a wakeup event is detected on WKUP1 pin. This bit is cleared by writing 1 in the CWUF1 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN1 = 0.
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2 This bit is set when a wakeup event is detected on WKUP2 pin. This bit is cleared by writing 1 in the CWUF2 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN2 = 0.
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3 This bit is set when a wakeup event is detected on WKUP3 pin. This bit is cleared by writing 1 in the CWUF3 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN3 = 0.
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4 This bit is set when a wakeup event is detected on WKUP4 pin. This bit is cleared by writing 1 in the CWUF4 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN4 = 0.
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5 This bit is set when a wakeup event is detected on WKUP5 pin. This bit is cleared by writing 1 in the CWUF5 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN5 = 0.
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6 This bit is set when a wakeup event is detected on WKUP6 pin. This bit is cleared by writing 1 in the CWUF6 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN6 = 0. If WUSEL = 11, this bit is cleared by hardware when all internal wakeup source are cleared.
        constexpr uint32_t WUF7 = (1U << 6);  ///< Wakeup flag 7 This bit is set when a wakeup event is detected on WKUP7 pin. This bit is cleared by writing 1 in the CWUF7 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN7 = 0. If WUSEL = 11, this bit is cleared by hardware when all internal wakeup source are cleared.
        constexpr uint32_t WUF8 = (1U << 7);  ///< Wakeup flag 8 This bit is set when a wakeup event is detected on WKUP8 pin. This bit is cleared by writing 1 in the CWUF8 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN8 = 0. If WUSEL = 11, this bit is cleared by hardware when all internal wakeup source are cleared.
    }

    /// PWR_WUSCR Register bits
    namespace pwr_wuscr_bits {
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Wakeup flag 1 Writing 1 to this bit clears the WUF1 flag in PWR_WUSR.
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Wakeup flag 2 Writing 1 to this bit clears the WUF2 flag in PWR_WUSR.
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Wakeup flag 3 Writing 1 to this bit clears the WUF3 flag in PWR_WUSR.
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Wakeup flag 4 Writing 1 to this bit clears the WUF4 flag in PWR_WUSR.
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Wakeup flag 5 Writing 1 to this bit clears the WUF5 flag in PWR_WUSR.
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Wakeup flag 6 Writing 1 to this bit clears the WUF6 flag in PWR_WUSR.
        constexpr uint32_t CWUF7 = (1U << 6);  ///< Wakeup flag 7 Writing 1 to this bit clears the WUF7 flag in PWR_WUSR.
        constexpr uint32_t CWUF8 = (1U << 7);  ///< Wakeup flag 8 Writing 1 to this bit clears the WUF8 flag in PWR_WUSR.
    }

    /// PWR_APCR Register bits
    namespace pwr_apcr_bits {
        constexpr uint32_t APC = (1U << 0);  ///< Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in PWR_PUCRx and PWR_PDCRx are applied. When this bit is cleared, PWR_PUCRx and PWR_PDCRx are not applied to the I/Os.
    }

    /// PWR_PUCRA Register bits
    namespace pwr_pucra_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit 15 When set, this bit activates the pull-up on PA15 when the APC bit is set in PWR_APCR. The pull-up is not activated if the corresponding PD15 bit is also set.
    }

    /// PWR_PDCRA Register bits
    namespace pwr_pdcra_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit 14 When set, this bit activates the pull-down on PA14 when the APC bit is set in PWR_APCR.
    }

    /// PWR_PUCRB Register bits
    namespace pwr_pucrb_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRB Register bits
    namespace pwr_pdcrb_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRC Register bits
    namespace pwr_pucrc_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRC Register bits
    namespace pwr_pdcrc_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRD Register bits
    namespace pwr_pucrd_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRD Register bits
    namespace pwr_pdcrd_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRE Register bits
    namespace pwr_pucre_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRE Register bits
    namespace pwr_pdcre_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRF Register bits
    namespace pwr_pucrf_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRF Register bits
    namespace pwr_pdcrf_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRG Register bits
    namespace pwr_pucrg_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRG Register bits
    namespace pwr_pdcrg_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRH Register bits
    namespace pwr_pucrh_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRH Register bits
    namespace pwr_pdcrh_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRI Register bits
    namespace pwr_pucri_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRI Register bits
    namespace pwr_pdcri_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRJ Register bits
    namespace pwr_pucrj_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
    }

    /// PWR_PDCRJ Register bits
    namespace pwr_pdcrj_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
    }

    /// PWR_CR4 Register bits
    namespace pwr_cr4_bits {
        constexpr uint32_t SRAM1PDS4 = (1U << 0);  ///< SRAM1PDS4
        constexpr uint32_t SRAM1PDS5 = (1U << 1);  ///< SRAM1PDS5
        constexpr uint32_t SRAM1PDS6 = (1U << 2);  ///< SRAM1PDS6
        constexpr uint32_t SRAM1PDS7 = (1U << 3);  ///< SRAM1PDS7
        constexpr uint32_t SRAM1PDS8 = (1U << 4);  ///< SRAM1PDS8
        constexpr uint32_t SRAM1PDS9 = (1U << 5);  ///< SRAM1PDS9
        constexpr uint32_t SRAM1PDS10 = (1U << 6);  ///< SRAM1PDS10
        constexpr uint32_t SRAM1PDS11 = (1U << 7);  ///< SRAM1PDS11
        constexpr uint32_t SRAM1PDS12 = (1U << 8);  ///< SRAM1PDS12
        constexpr uint32_t SRAM5PDS1 = (1U << 16);  ///< SRAM5PDS1
        constexpr uint32_t SRAM5PDS2 = (1U << 17);  ///< SRAM5PDS2
        constexpr uint32_t SRAM5PDS3 = (1U << 18);  ///< SRAM5PDS3
        constexpr uint32_t SRAM5PDS4 = (1U << 19);  ///< SRAM5PDS4
        constexpr uint32_t SRAM5PDS5 = (1U << 20);  ///< SRAM5PDS5
        constexpr uint32_t SRAM5PDS6 = (1U << 21);  ///< SRAM5PDS6
        constexpr uint32_t SRAM5PDS7 = (1U << 22);  ///< SRAM5PDS7
        constexpr uint32_t SRAM5PDS8 = (1U << 23);  ///< SRAM5PDS8
        constexpr uint32_t SRAM5PDS9 = (1U << 24);  ///< SRAM5PDS9
        constexpr uint32_t SRAM5PDS10 = (1U << 25);  ///< SRAM5PDS10
        constexpr uint32_t SRAM5PDS11 = (1U << 26);  ///< SRAM5PDS11
        constexpr uint32_t SRAM5PDS12 = (1U << 27);  ///< SRAM5PDS12
        constexpr uint32_t SRAM5PDS13 = (1U << 28);  ///< SRAM5PDS13
    }

}

// ============================================================================
// RAMCFG Peripheral
// ============================================================================

namespace ramcfg {
    /// Base addresses
    constexpr uint32_t RAMCFG_BASE = 0x40026000;

    /// RAMCFG Register structure
    struct Registers {
        volatile uint32_t M1CR;  ///< Offset: 0x00 - RAMCFG SRAM x control register
        volatile uint32_t M1ISR;  ///< Offset: 0x08 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM1ERKEYR;  ///< Offset: 0x28 - RAMCFG SRAM x erase key register
        volatile uint32_t M2CR;  ///< Offset: 0x40 - RAMCFG SRAM x control register
        volatile uint32_t M2IER;  ///< Offset: 0x44 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t M2ISR;  ///< Offset: 0x48 - RAMCFG RAMx interrupt status register
        volatile uint32_t M2SEAR;  ///< Offset: 0x4C - RAMCFG RAM x ECC single error address register
        volatile uint32_t M2DEAR;  ///< Offset: 0x50 - RAMCFG RAM x ECC double error address register
        volatile uint32_t M2ICR;  ///< Offset: 0x54 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M2WPR1;  ///< Offset: 0x58 - RAMCFG SRAM2 write protection register 1
        volatile uint32_t M2WPR2;  ///< Offset: 0x5C - RAMCFG SRAM2 write protection register 2
        volatile uint32_t M2ECCKEYR;  ///< Offset: 0x64 - RAMCFG SRAM x ECC key register
        volatile uint32_t M2ERKEYR;  ///< Offset: 0x68 - RAMCFG SRAM x erase key register
        volatile uint32_t M3CR;  ///< Offset: 0x80 - RAMCFG SRAM x control register
        volatile uint32_t M3IER;  ///< Offset: 0x84 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t M3ISR;  ///< Offset: 0x88 - RAMCFG RAMx interrupt status register
        volatile uint32_t M3SEAR;  ///< Offset: 0x8C - RAMCFG RAM x ECC single error address register
        volatile uint32_t M3DEAR;  ///< Offset: 0x90 - RAMCFG RAM x ECC double error address register
        volatile uint32_t M3ICR;  ///< Offset: 0x94 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M3ECCKEYR;  ///< Offset: 0xA4 - RAMCFG SRAM x ECC key register
        volatile uint32_t M3ERKEYR;  ///< Offset: 0xA8 - RAMCFG SRAM x erase key register
        volatile uint32_t M4CR;  ///< Offset: 0xC0 - RAMCFG SRAM x control register
        volatile uint32_t M4ISR;  ///< Offset: 0xC8 - RAMCFG RAMx interrupt status register
        volatile uint32_t M4ERKEYR;  ///< Offset: 0xE8 - RAMCFG SRAM x erase key register
        volatile uint32_t M5CR;  ///< Offset: 0x100 - RAMCFG SRAM x control register
        volatile uint32_t M5IER;  ///< Offset: 0x104 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t M5ISR;  ///< Offset: 0x108 - RAMCFG RAMx interrupt status register
        volatile uint32_t M5SEAR;  ///< Offset: 0x10C - RAMCFG RAM x ECC single error address register
        volatile uint32_t M5DEAR;  ///< Offset: 0x110 - RAMCFG RAM x ECC double error address register
        volatile uint32_t M5ICR;  ///< Offset: 0x114 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M5ECCKEYR;  ///< Offset: 0x124 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M5ERKEYR;  ///< Offset: 0x128 - Erase write protection key The following steps are...
        volatile uint32_t M6CR;  ///< Offset: 0x140 - memory x control register
        volatile uint32_t M6ISR;  ///< Offset: 0x148 - ECC single error detected and corrected Note: This bit...
        volatile uint32_t M6ERKEYR;  ///< Offset: 0x168 - Erase write protection key The following steps are...
    };

    /// Peripheral instances
    inline Registers* RAMCFG = reinterpret_cast<Registers*>(RAMCFG_BASE);

    // Bit definitions
    /// M1CR Register bits
    namespace m1cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M1ISR Register bits
    namespace m1isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM1ERKEYR Register bits
    namespace ram1erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M2CR Register bits
    namespace m2cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M2IER Register bits
    namespace m2ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// M2ISR Register bits
    namespace m2isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M2SEAR Register bits
    namespace m2sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// M2DEAR Register bits
    namespace m2dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// M2ICR Register bits
    namespace m2icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// M2WPR1 Register bits
    namespace m2wpr1_bits {
        constexpr uint32_t P0WP = (1U << 0);  ///< P0WP
        constexpr uint32_t P1WP = (1U << 1);  ///< P1WP
        constexpr uint32_t P2WP = (1U << 2);  ///< P2WP
        constexpr uint32_t P3WP = (1U << 3);  ///< P3WP
        constexpr uint32_t P4WP = (1U << 4);  ///< P4WP
        constexpr uint32_t P5WP = (1U << 5);  ///< P5WP
        constexpr uint32_t P6WP = (1U << 6);  ///< P6WP
        constexpr uint32_t P7WP = (1U << 7);  ///< P7WP
        constexpr uint32_t P8WP = (1U << 8);  ///< P8WP
        constexpr uint32_t P9WP = (1U << 9);  ///< P9WP
        constexpr uint32_t P10WP = (1U << 10);  ///< P10WP
        constexpr uint32_t P11WP = (1U << 11);  ///< P11WP
        constexpr uint32_t P12WP = (1U << 12);  ///< P12WP
        constexpr uint32_t P13WP = (1U << 13);  ///< P13WP
        constexpr uint32_t P14WP = (1U << 14);  ///< P14WP
        constexpr uint32_t P15WP = (1U << 15);  ///< P15WP
        constexpr uint32_t P16WP = (1U << 16);  ///< P16WP
        constexpr uint32_t P17WP = (1U << 17);  ///< P17WP
        constexpr uint32_t P18WP = (1U << 18);  ///< P18WP
        constexpr uint32_t P19WP = (1U << 19);  ///< P19WP
        constexpr uint32_t P20WP = (1U << 20);  ///< P20WP
        constexpr uint32_t P21WP = (1U << 21);  ///< P21WP
        constexpr uint32_t P22WP = (1U << 22);  ///< P22WP
        constexpr uint32_t P23WP = (1U << 23);  ///< P23WP
        constexpr uint32_t P24WP = (1U << 24);  ///< P24WP
        constexpr uint32_t P25WP = (1U << 25);  ///< P25WP
        constexpr uint32_t P26WP = (1U << 26);  ///< P26WP
        constexpr uint32_t P27WP = (1U << 27);  ///< P27WP
        constexpr uint32_t P28WP = (1U << 28);  ///< P28WP
        constexpr uint32_t P29WP = (1U << 29);  ///< P29WP
        constexpr uint32_t P30WP = (1U << 30);  ///< P30WP
        constexpr uint32_t P31WP = (1U << 31);  ///< P31WP
    }

    /// M2WPR2 Register bits
    namespace m2wpr2_bits {
        constexpr uint32_t P32WP = (1U << 0);  ///< P32WP
        constexpr uint32_t P33WP = (1U << 1);  ///< P33WP
        constexpr uint32_t P34WP = (1U << 2);  ///< P34WP
        constexpr uint32_t P35WP = (1U << 3);  ///< P35WP
        constexpr uint32_t P36WP = (1U << 4);  ///< P36WP
        constexpr uint32_t P37WP = (1U << 5);  ///< P37WP
        constexpr uint32_t P38WP = (1U << 6);  ///< P38WP
        constexpr uint32_t P39WP = (1U << 7);  ///< P39WP
        constexpr uint32_t P40WP = (1U << 8);  ///< P40WP
        constexpr uint32_t P41WP = (1U << 9);  ///< P41WP
        constexpr uint32_t P42WP = (1U << 10);  ///< P42WP
        constexpr uint32_t P43WP = (1U << 11);  ///< P43WP
        constexpr uint32_t P44WP = (1U << 12);  ///< P44WP
        constexpr uint32_t P45WP = (1U << 13);  ///< P45WP
        constexpr uint32_t P46WP = (1U << 14);  ///< P46WP
        constexpr uint32_t P47WP = (1U << 15);  ///< P47WP
        constexpr uint32_t P48WP = (1U << 16);  ///< P48WP
        constexpr uint32_t P49WP = (1U << 17);  ///< P49WP
        constexpr uint32_t P50WP = (1U << 18);  ///< P50WP
        constexpr uint32_t P51WP = (1U << 19);  ///< P51WP
        constexpr uint32_t P52WP = (1U << 20);  ///< P52WP
        constexpr uint32_t P53WP = (1U << 21);  ///< P53WP
        constexpr uint32_t P54WP = (1U << 22);  ///< P54WP
        constexpr uint32_t P55WP = (1U << 23);  ///< P55WP
        constexpr uint32_t P56WP = (1U << 24);  ///< P56WP
        constexpr uint32_t P57WP = (1U << 25);  ///< P57WP
        constexpr uint32_t P58WP = (1U << 26);  ///< P58WP
        constexpr uint32_t P59WP = (1U << 27);  ///< P59WP
        constexpr uint32_t P60WP = (1U << 28);  ///< P60WP
        constexpr uint32_t P61WP = (1U << 29);  ///< P61WP
        constexpr uint32_t P62WP = (1U << 30);  ///< P62WP
        constexpr uint32_t P63WP = (1U << 31);  ///< P63WP
    }

    /// M2ECCKEYR Register bits
    namespace m2ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// M2ERKEYR Register bits
    namespace m2erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M3CR Register bits
    namespace m3cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M3IER Register bits
    namespace m3ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// M3ISR Register bits
    namespace m3isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M3SEAR Register bits
    namespace m3sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// M3DEAR Register bits
    namespace m3dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// M3ICR Register bits
    namespace m3icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// M3ECCKEYR Register bits
    namespace m3ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// M3ERKEYR Register bits
    namespace m3erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M4CR Register bits
    namespace m4cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M4ISR Register bits
    namespace m4isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M4ERKEYR Register bits
    namespace m4erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M5CR Register bits
    namespace m5cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M5IER Register bits
    namespace m5ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// M5ISR Register bits
    namespace m5isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M5SEAR Register bits
    namespace m5sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// M5DEAR Register bits
    namespace m5dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// M5ICR Register bits
    namespace m5icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// M5ECCKEYR Register bits
    namespace m5ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// M5ERKEYR Register bits
    namespace m5erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< Erase write protection key The following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register. 1) Write 0xCA into ERASEKEY[7:0]. 2) Write 0x53 into ERASEKEY[7:0]. Note: Writing a wrong key reactivates the write protection.
    }

    /// M6CR Register bits
    namespace m6cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M6ISR Register bits
    namespace m6isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< ECC single error detected and corrected Note: This bit is reserved and must be kept at reset value in SRAM1, SRAM4 and SRAM5 interrupt status registers.
        constexpr uint32_t DED = (1U << 1);  ///< ECC double error detected Note: This bit is reserved and must be kept at reset value in SRAM1, SRAM4 and SRAM5 interrupt status registers.
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAM busy with erase operation Note: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the option bit is enabled, tamper detection or readout protection regression. Refer to .
    }

    /// M6ERKEYR Register bits
    namespace m6erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< Erase write protection key The following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register. 1) Write 0xCA into ERASEKEY[7:0]. 2) Write 0x53 into ERASEKEY[7:0]. Note: Writing a wrong key reactivates the write protection.
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x46020C00;
    constexpr uint32_t SEC_RCC_BASE = 0x56020C00;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t RCC_CR;  ///< Offset: 0x00 - RCC clock control register
        volatile uint32_t RCC_ICSCR1;  ///< Offset: 0x08 - RCC internal clock sources calibration register 1
        volatile uint32_t RCC_ICSCR2;  ///< Offset: 0x0C - RCC internal clock sources calibration register 2
        volatile uint32_t RCC_ICSCR3;  ///< Offset: 0x10 - RCC internal clock sources calibration register 3
        volatile uint32_t RCC_CRRCR;  ///< Offset: 0x14 - RCC clock recovery RC register
        volatile uint32_t RCC_CFGR1;  ///< Offset: 0x1C - RCC clock configuration register 1
        volatile uint32_t RCC_CFGR2;  ///< Offset: 0x20 - RCC clock configuration register 2
        volatile uint32_t RCC_CFGR3;  ///< Offset: 0x24 - RCC clock configuration register 3
        volatile uint32_t RCC_PLL1CFGR;  ///< Offset: 0x28 - RCC PLL1 configuration register
        volatile uint32_t RCC_PLL2CFGR;  ///< Offset: 0x2C - RCC PLL2 configuration register
        volatile uint32_t RCC_PLL3CFGR;  ///< Offset: 0x30 - RCC PLL3 configuration register
        volatile uint32_t RCC_PLL1DIVR;  ///< Offset: 0x34 - RCC PLL1 dividers register
        volatile uint32_t RCC_PLL1FRACR;  ///< Offset: 0x38 - RCC PLL1 fractional divider register
        volatile uint32_t RCC_PLL2DIVR;  ///< Offset: 0x3C - RCC PLL2 dividers configuration register
        volatile uint32_t RCC_PLL2FRACR;  ///< Offset: 0x40 - RCC PLL2 fractional divider register
        volatile uint32_t RCC_PLL3DIVR;  ///< Offset: 0x44 - RCC PLL3 dividers configuration register
        volatile uint32_t RCC_PLL3FRACR;  ///< Offset: 0x48 - RCC PLL3 fractional divider register
        volatile uint32_t RCC_CIER;  ///< Offset: 0x50 - RCC clock interrupt enable register
        volatile uint32_t RCC_CIFR;  ///< Offset: 0x54 - RCC clock interrupt flag register
        volatile uint32_t RCC_CICR;  ///< Offset: 0x58 - RCC clock interrupt clear register
        volatile uint32_t RCC_AHB1RSTR;  ///< Offset: 0x60 - RCC AHB1 peripheral reset register
        volatile uint32_t RCC_AHB2RSTR1;  ///< Offset: 0x64 - RCC AHB2 peripheral reset register 1
        volatile uint32_t RCC_AHB2RSTR2;  ///< Offset: 0x68 - RCC AHB2 peripheral reset register 2
        volatile uint32_t RCC_AHB3RSTR;  ///< Offset: 0x6C - RCC AHB3 peripheral reset register
        volatile uint32_t RCC_APB1RSTR1;  ///< Offset: 0x74 - RCC APB1 peripheral reset register 1
        volatile uint32_t RCC_APB1RSTR2;  ///< Offset: 0x78 - RCC APB1 peripheral reset register 2
        volatile uint32_t RCC_APB2RSTR;  ///< Offset: 0x7C - RCC APB2 peripheral reset register
        volatile uint32_t RCC_APB3RSTR;  ///< Offset: 0x80 - RCC APB3 peripheral reset register
        volatile uint32_t RCC_AHB1ENR;  ///< Offset: 0x88 - RCC AHB1 peripheral clock enable register
        volatile uint32_t RCC_AHB2ENR1;  ///< Offset: 0x8C - RCC AHB2 peripheral clock enable register 1
        volatile uint32_t RCC_AHB2ENR2;  ///< Offset: 0x90 - RCC AHB2 peripheral clock enable register 2
        volatile uint32_t RCC_AHB3ENR;  ///< Offset: 0x94 - RCC AHB3 peripheral clock enable register
        volatile uint32_t RCC_APB1ENR1;  ///< Offset: 0x9C - RCC APB1 peripheral clock enable register 1
        volatile uint32_t RCC_APB1ENR2;  ///< Offset: 0xA0 - RCC APB1 peripheral clock enable register 2
        volatile uint32_t RCC_APB2ENR;  ///< Offset: 0xA4 - RCC APB2 peripheral clock enable register
        volatile uint32_t RCC_APB3ENR;  ///< Offset: 0xA8 - RCC APB3 peripheral clock enable register
        volatile uint32_t RCC_AHB1SMENR;  ///< Offset: 0xB0 - RCC AHB1 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_AHB2SMENR1;  ///< Offset: 0xB4 - RCC AHB2 peripheral clock enable in Sleep and	Stop modes...
        volatile uint32_t RCC_AHB2SMENR2;  ///< Offset: 0xB8 - RCC AHB2 peripheral clock enable in Sleep and	Stop modes...
        volatile uint32_t RCC_AHB3SMENR;  ///< Offset: 0xBC - RCC AHB3 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_APB1SMENR1;  ///< Offset: 0xC4 - RCC APB1 peripheral clock enable in Sleep and Stop...
        volatile uint32_t RCC_APB1SMENR2;  ///< Offset: 0xC8 - RCC APB1 peripheral clocks enable in Sleep and	Stop...
        volatile uint32_t RCC_APB2SMENR;  ///< Offset: 0xCC - RCC APB2 peripheral clocks enable in Sleep and Stop...
        volatile uint32_t RCC_APB3SMENR;  ///< Offset: 0xD0 - RCC APB3 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_SRDAMR;  ///< Offset: 0xD8 - RCC SmartRun domain peripheral autonomous mode register
        volatile uint32_t RCC_CCIPR1;  ///< Offset: 0xE0 - RCC peripherals independent clock configuration register 1
        volatile uint32_t RCC_CCIPR2;  ///< Offset: 0xE4 - RCC peripherals independent clock configuration register 2
        volatile uint32_t RCC_CCIPR3;  ///< Offset: 0xE8 - RCC peripherals independent clock configuration register 3
        volatile uint32_t RCC_BDCR;  ///< Offset: 0xF0 - RCC backup domain control register
        volatile uint32_t RCC_CSR;  ///< Offset: 0xF4 - RCC control/status register
        volatile uint32_t RCC_SECCFGR;  ///< Offset: 0x110 - RCC secure configuration register
        volatile uint32_t RCC_PRIVCFGR;  ///< Offset: 0x114 - RCC privilege configuration register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);
    inline Registers* SEC_RCC = reinterpret_cast<Registers*>(SEC_RCC_BASE);

    // Bit definitions
    /// RCC_CR Register bits
    namespace rcc_cr_bits {
        constexpr uint32_t MSISON = (1U << 0);  ///< MSIS clock enable This bit is set and cleared by software. It is cleared by hardware to stop the MSIS oscillator when entering Stop, Standby or Shutdown mode. This bit is set by hardware to force the�MSIS oscillator on when exiting Standby or Shutdown mode. It is set by hardware to force the MSIS oscillator ON when STOPWUCK = 0 when exiting Stop modes, or in case of a failure of the HSE oscillator. Set by hardware when used directly or indirectly as system clock.
        constexpr uint32_t MSIKERON = (1U << 1);  ///< MSI enable for some peripheral kernels This bit is set and cleared by software to force MSI ON even in Stop modes. Keeping the MSI on in Stop mode allows the communication speed not to be reduced by the MSI startup time. This bit has no effect on MSISON and MSIKON values (see Section�11.4.24 for more details). This bit must be configured at 0 before entering Stop 3 mode.
        constexpr uint32_t MSISRDY = (1U << 2);  ///< MSIS clock ready flag This bit is set by hardware to indicate that the MSIS oscillator is stable. It is set only when MSIS is enabled by software (by setting MSISON). Note: Once the MSISON bit is cleared, MSISRDY goes low after six MSIS clock cycles.
        constexpr uint32_t MSIPLLEN = (1U << 3);  ///< MSI clock PLL-mode enable This bit is set and cleared by software to enable/disable the PLL part of the MSI clock source. MSIPLLEN must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware). A hardware protection prevents from enabling MSIPLLEN if LSE is not ready. This bit is cleared by hardware when LSE is disabled (LSEON = 0) or when the CSS on LSE detects a LSE failure (see RCC_CSR).
        constexpr uint32_t MSIKON = (1U << 4);  ///< MSIK clock enable This bit is set and cleared by software. It is cleared by hardware to stop the MSIK when entering Stop, Standby, or Shutdown mode. This bit is set by hardware to force the MSIK oscillator ON when exiting Standby or Shutdown mode. It is set by hardware to force the MSIK oscillator on when STOPWUCK = 0 or STOPKERWUCK�=�0 when exiting Stop modes, or in case of a failure of the HSE oscillator.
        constexpr uint32_t MSIKRDY = (1U << 5);  ///< MSIK clock ready flag This bit is set by hardware to indicate that the MSIK is stable. It is set only when MSI kernel oscillator is enabled by software by setting MSIKON. Note: Once MSIKON bit is cleared, MSIKRDY goes low after six MSIK oscillator clock cycles.
        constexpr uint32_t MSIPLLSEL = (1U << 6);  ///< MSI clock with PLL mode selection This bit is set and cleared by software to select which MSI output clock uses the PLL mode. It�can be written only when the MSI PLL mode is disabled (MSIPLLEN = 0). Note: If the MSI kernel clock output uses the same oscillator source than the MSI system clock output, then the PLL mode is applied to both clock outputs.
        constexpr uint32_t MSIPLLFAST = (1U << 7);  ///< MSI PLL mode fast startup This bit is set and reset by software to enable/disable the fast PLL mode start-up of the MSI clock source. This bit is used only if PLL mode is selected (MSIPLLEN = 1). The fast start-up feature is not active the first time the PLL mode is selected. The�fast start-up is active when the MSI in PLL mode returns from switch off.
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby, or Shutdown mode. This bit is set by hardware to force the�HSI16 oscillator on when STOPWUCK = 1 when leaving Stop modes, or in case of failure of the HSE crystal oscillator. This bit is set by hardware if the HSI16 is used directly or indirectly as system clock.
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 enable for some peripheral kernels This bit is set and cleared by software to force HSI16 ON even in Stop modes. Keeping HSI16 on in Stop mode allows the communication speed not to be reduced by the HSI16 startup time. This bit has no effect on HSION value. Refer to Section�11.4.24 for more details. This bit must be configured at 0 before entering Stop 3 mode.
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag This bit is set by hardware to indicate that HSI16 oscillator is stable. It is set only when HSI16 is enabled by software (by setting HSION). Note: Once the HSION bit is cleared, HSIRDY goes low after six HSI16 clock cycles.
        constexpr uint32_t HSI48ON = (1U << 12);  ///< HSI48 clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSI48 when entering in Stop, Standby, or Shutdown modes.
        constexpr uint32_t HSI48RDY = (1U << 13);  ///< HSI48 clock ready flag This bit is set by hardware to indicate that HSI48 oscillator is stable. Itis set only when HSI48 is enabled by software (by setting HSI48ON).
        constexpr uint32_t SHSION = (1U << 14);  ///< SHSI clock enable This bit is set and cleared by software. It is cleared by hardware to stop the SHSI when entering in Stop, Standby, or Shutdown modes.
        constexpr uint32_t SHSIRDY = (1U << 15);  ///< SHSI clock ready flag This bit is set by hardware to indicate that the SHSI oscillator is stable. It is set only when SHSI is enabled by software (by setting SHSION). Note: Once the SHSION bit is cleared, SHSIRDY goes low after six SHSI clock cycles.
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSE oscillator when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag This bit is set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after six HSE clock cycles.
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass This bit is set and cleared by software to bypass the oscillator with an external clock. The�external clock must be enabled with the HSEON bit set, to be used by the device. This�bit can be written only if the HSE oscillator is disabled.
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable This bit is set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
        constexpr uint32_t HSEEXT = (1U << 20);  ///< HSE external clock bypass mode This bit is set and reset by software to select the external clock mode in bypass mode. External clock mode must be configured with HSEON bit to be used by the device. This bit can be written only if the HSE oscillator is disabled. This bit is active only if the HSE bypass mode is enabled.
        constexpr uint32_t PLL1ON = (1U << 24);  ///< PLL1 enable This bit is set and cleared by software to enable the main PLL. It is cleared by hardware when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the PLL1 clock is used as the system clock.
        constexpr uint32_t PLL1RDY = (1U << 25);  ///< PLL1 clock ready flag This bit is set by hardware to indicate that the PLL1 is locked.
        constexpr uint32_t PLL2ON = (1U << 26);  ///< PLL2 enable This bit is set and cleared by software to enable PLL2. It is cleared by hardware when entering Stop, Standby, or Shutdown mode.
        constexpr uint32_t PLL2RDY = (1U << 27);  ///< PLL2 clock ready flag This bit is set by hardware to indicate that the PLL2 is locked.
        constexpr uint32_t PLL3ON = (1U << 28);  ///< PLL3 enable This bit is set and cleared by software to enable PLL3. It is cleared by hardware when entering Stop, Standby, or Shutdown mode.
        constexpr uint32_t PLL3RDY = (1U << 29);  ///< PLL3 clock ready flag This bit is set by hardware to indicate that the PLL3 is locked.
    }

    /// RCC_ICSCR1 Register bits
    namespace rcc_icscr1_bits {
        constexpr uint32_t MSICAL3 = (5 << 0);  ///< MSIRC3 clock calibration for MSI ranges 12 to 15 These bits are initialized at startup with the factory-programmed MSIRC3 calibration trim value for ranges 12 to 15. When MSITRIM3 is written, MSICAL3 is updated with the sum of MSITRIM3[4:0] and the factory calibration trim value MSIRC2[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL2 = (5 << 5);  ///< MSIRC2 clock calibration for MSI ranges 8 to 11 These bits are initialized at startup with the factory-programmed MSIRC2 calibration trim value for ranges 8 to 11. When MSITRIM2 is written, MSICAL2 is updated with the sum of MSITRIM2[4:0] and the factory calibration trim value MSIRC2[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL1 = (5 << 10);  ///< MSIRC1 clock calibration for MSI ranges 4 to 7 These bits are initialized at startup with the factory-programmed MSIRC1 calibration trim value for ranges 4 to 7. When MSITRIM1 is written, MSICAL1 is updated with the sum of MSITRIM1[4:0] and the factory calibration trim value MSIRC1[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL0 = (5 << 15);  ///< MSIRC0 clock calibration for MSI ranges 0 to 3 These bits are initialized at startup with the factory-programmed MSIRC0 calibration trim value for ranges 0 to 3. When MSITRIM0 is written, MSICAL0 is updated with the sum of MSITRIM0[4:0] and the factory-programmed calibration trim value MSIRC0[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSIBIAS = (1U << 22);  ///< MSI bias mode selection This bit is set by software to select the MSI bias mode. By default, the MSI bias is in�continuous mode in order to maintain the output clocks accuracy. Setting this bit reduces the MSI consumption when the regulator is in range 4, or when the device is in Stop 1 or Stop�2 mode, but it�decreases the MSI accuracy
        constexpr uint32_t MSIRGSEL = (1U << 23);  ///< MSI clock range selection This bit is set by software to select the MSIS and MSIK clocks range with MSISRANGE[3:0] and MSIKRANGE[3:0]. Write 0 has no effect. After exiting Standby or Shutdown mode, or after a reset, this bit is at 0 and the MSIS and MSIK ranges are provided by MSISSRANGE[3:0] and MSIKSRANGE[3:0] in RCC_CSR.
        constexpr uint32_t MSIKRANGE = (4 << 24);  ///< MSIK clock ranges These bits are configured by software to choose the frequency range of MSIK oscillator when MSIRGSEL is set. 16 frequency ranges are available: Note: MSIKRANGE can be modified when MSIK is off (MSISON = 0) or when MSIK is ready (MSIKRDY�=�1). MSIKRANGE must NOT be modified when MSIK is on and NOT ready (MSIKON = 1 and MSIKRDY = 0) Note: MSIKRANGE is kept when the device wakes up from Stop mode, except when the�MSIK range is above 24 MHz. In this case MSIKRANGE is changed by hardware into�range 2 (24 MHz).
        constexpr uint32_t MSISRANGE = (4 << 28);  ///< MSIS clock ranges These bits are configured by software to choose the frequency range of MSIS oscillator when MSIRGSEL is set. 16 frequency ranges are available: Note: MSISRANGE can be modified when MSIS is off (MSISON = 0) or when MSIS is ready (MSISRDY�=�1). MSISRANGE must NOT be modified when MSIS is on and NOT ready (MSISON�=�1 and MSISRDY�=�0) Note: MSISRANGE is kept when the device wakes up from Stop mode, except when the�MSIS range is above 24 MHz. In this case MSISRANGE is changed by hardware into range 2 (24 MHz).
    }

    /// RCC_ICSCR2 Register bits
    namespace rcc_icscr2_bits {
        constexpr uint32_t MSITRIM3 = (5 << 0);  ///< MSI clock trimming for ranges 12 to 15 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC3[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM2 = (5 << 5);  ///< MSI clock trimming for ranges 8 to 11 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC2[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM1 = (5 << 10);  ///< MSI clock trimming for ranges 4 to 7 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC1[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM0 = (5 << 15);  ///< MSI clock trimming for ranges 0 to 3 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC0[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
    }

    /// RCC_ICSCR3 Register bits
    namespace rcc_icscr3_bits {
        constexpr uint32_t HSICAL = (12 << 0);  ///< HSI clock calibration These bits are initialized at startup with the factory-programmed HSI calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
        constexpr uint32_t HSITRIM = (5 << 16);  ///< HSI clock trimming These bits provide an additional user-programmable trimming value that is added to HSICAL[11:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the HSI.
    }

    /// RCC_CRRCR Register bits
    namespace rcc_crrcr_bits {
        constexpr uint32_t HSI48CAL = (9 << 0);  ///< HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value.
    }

    /// RCC_CFGR1 Register bits
    namespace rcc_cfgr1_bits {
        constexpr uint32_t SW = (2 << 0);  ///< system clock switch This bitfield is set and cleared by software to select system clock source (SYSCLK). It is configured by hardware to force MSIS oscillator selection when exiting Standby or Shutdown mode. This bitfield is configured by hardware to force MSIS or HSI16 oscillator selection when exiting Stop mode or in case of HSE oscillator failure, depending on STOPWUCK.
        constexpr uint32_t SWS = (2 << 2);  ///< system clock switch status This bitfield is set and cleared by hardware to indicate which clock source is used as system clock.
        constexpr uint32_t STOPWUCK = (1U << 4);  ///< wake-up from Stop and CSS backup clock selection This bit is set and cleared by software to select the system clock used when exiting Stop mode. The selected clock is also used as emergency clock for the clock security system on�HSE. STOPWUCK must not be modified when the CSS is enabled by HSECSSON in�RCC_CR, and the system clock is HSE (SWS = 10) or a switch on HSE is�requested (SW�=�10).
        constexpr uint32_t STOPKERWUCK = (1U << 5);  ///< wake-up from Stop kernel clock automatic enable selection This bit is set and cleared by software to enable automatically another oscillator when exiting Stop mode. This oscillator can be used as independent kernel clock by peripherals.
        constexpr uint32_t MCOSEL = (4 << 24);  ///< microcontroller clock output This bitfield is set and cleared by software. Others: reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
        constexpr uint32_t MCOPRE = (3 << 28);  ///< microcontroller clock output prescaler This bitfield is set and cleared by software. It is highly recommended to change this prescaler before MCO output is enabled. Others: not allowed
    }

    /// RCC_CFGR2 Register bits
    namespace rcc_cfgr2_bits {
        constexpr uint32_t HPRE = (4 << 0);  ///< AHB prescaler This bitfiled is set and cleared by software to control the division factor of the AHB clock (HCLK). Depending on the device voltage range, the software must set these bits correctly to ensure that the system frequency does not exceed the maximum allowed frequency (for more details, refer to Table�118). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account. 0xxx: SYSCLK not divided
        constexpr uint32_t PPRE1 = (3 << 4);  ///< APB1 prescaler This bitfiled is set and cleared by software to control the division factor of APB1 clock (PCLK1). 0xx: PCLK1 not divided
        constexpr uint32_t PPRE2 = (3 << 8);  ///< APB2 prescaler This bitfiled is set and cleared by software to control the division factor of APB2 clock (PCLK2). 0xx: PCLK2 not divided
        constexpr uint32_t DPRE = (3 << 12);  ///< DSI PHY prescaler This bitfiled is set and cleared by software to control the division factor of DSI PHY bus clock (DCLK). 0xx: DCLK not divided Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t AHB1DIS = (1U << 16);  ///< AHB1 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB1 peripherals (except those listed hereafter) are used and when their clocks are disabled in RCC_AHB1ENR. When this bit is set, all the AHB1 peripherals clocks are off, except for FLASH, BKPSRAM, ICACHE, DCACHE1 and SRAM1.
        constexpr uint32_t AHB2DIS1 = (1U << 17);  ///< AHB2_1 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB2 peripherals from RCC_AHB2ENR1 (except SRAM2 and SRAM3) are used and when their clocks are disabled in RCC_AHB2ENR1. When this bit is set, all the AHB2 peripherals clocks from RCC_AHB2ENR1 are off, except for SRAM2 and SRAM3.
        constexpr uint32_t AHB2DIS2 = (1U << 18);  ///< AHB2_2 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB2 peripherals from RCC_AHB2ENR2 are used and when their clocks are disabled in RCC_AHB2ENR2. When this bit is set, all the AHB2 peripherals clocks from RCC_AHB2ENR2 are off.
        constexpr uint32_t APB1DIS = (1U << 19);  ///< APB1 clock disable This bit can be set in order to further reduce power consumption, when none of the APB1 peripherals (except IWDG) are used and when their clocks are disabled in RCC_APB1ENR. When this bit is set, all the APB1 peripherals clocks are off, except for IWDG.
        constexpr uint32_t APB2DIS = (1U << 20);  ///< APB2 clock disable This bit can be set in order to further reduce power consumption, when none of the APB2 peripherals are used and when their clocks are disabled in RCC_APB2ENR. When this bit is set, all APB2 peripherals clocks are off.
    }

    /// RCC_CFGR3 Register bits
    namespace rcc_cfgr3_bits {
        constexpr uint32_t PPRE3 = (3 << 4);  ///< APB3 prescaler This bitfield is set and cleared by software to control the division factor of the APB3 clock (PCLK3). 0xx: HCLK not divided
        constexpr uint32_t AHB3DIS = (1U << 16);  ///< AHB3 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB3 peripherals (except SRAM4) are used and when their clocks are disabled in RCC_AHB3ENR. When this bit is set, all the AHB3 peripherals clocks are off, except for SRAM4.
        constexpr uint32_t APB3DIS = (1U << 17);  ///< APB3 clock disable This bit can be set in order to further reduce power consumption, when none of the APB3 peripherals from RCC_APB3ENR are used and when their clocks are disabled in RCC_APB3ENR. When this bit is set, all the APB3 peripherals clocks are off.
    }

    /// RCC_PLL1CFGR Register bits
    namespace rcc_pll1cfgr_bits {
        constexpr uint32_t PLL1SRC = (2 << 0);  ///< PLL1 entry clock source This bitfield is set and cleared by software to select PLL1 clock source. It can be written only when the PLL1 is disabled. In order to save power, when no PLL1 is used, this bitfield value must be zero.
        constexpr uint32_t PLL1RGE = (2 << 2);  ///< PLL1 input frequency range This bit is set and reset by software to select the proper reference frequency range used for PLL1. It must be written before enabling the PLL1. 00-01-10: PLL1 input (ref1_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL1FRACEN = (1U << 4);  ///< PLL1 fractional latch enable This bit is set and reset by software to latch the content of PLL1FRACN in the ΣΔ modulator. In order to latch the PLL1FRACN value into the ΣΔ modulator, PLL1FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL1FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL1M = (4 << 8);  ///< Prescaler for PLL1 This bitfield is set and cleared by software to configure the prescaler of the PLL1. The VCO1 input frequency is PLL1 input clock frequency/PLL1M. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1MBOOST = (4 << 12);  ///< Prescaler for EPOD booster input clock This bitfield is set and cleared by software to configure the prescaler of the PLL1, used for the EPOD booster. The EPOD booster input frequency is PLL1�input�clock�frequency/PLL1MBOOST. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0) and EPODboost mode is disabled (see Section�10: Power control (PWR)). others: reserved
        constexpr uint32_t PLL1PEN = (1U << 16);  ///< PLL1 DIVP divider output enable This bit is set and reset by software to enable the pll1_p_ck output of the PLL1. To save power, PLL1PEN and PLL1P bits must be set to 0 when pll1_p_ck is not used.
        constexpr uint32_t PLL1QEN = (1U << 17);  ///< PLL1 DIVQ divider output enable This bit is set and reset by software to enable the pll1_q_ck output of the PLL1. To save power, PLL1QEN and PLL1Q bits must be set to 0 when pll1_q_ck is not used.
        constexpr uint32_t PLL1REN = (1U << 18);  ///< PLL1 DIVR divider output enable This bit is set and reset by software to enable the pll1_r_ck output of the PLL1. To save power, PLL1RENPLL2REN and PLL1R bits must be set to 0 when pll1_r_ck is not used. This bit can be cleared only when the PLL1 is not used as SYSCLK.
    }

    /// RCC_PLL2CFGR Register bits
    namespace rcc_pll2cfgr_bits {
        constexpr uint32_t PLL2SRC = (2 << 0);  ///< PLL2 entry clock source This bitfield is set and cleared by software to select PLL2 clock source. It can be written only when the PLL2 is disabled. To save power, when no PLL2 is used, this bitfield value must be�zero.
        constexpr uint32_t PLL2RGE = (2 << 2);  ///< PLL2 input frequency range This bitfield is set and reset by software to select the proper reference frequency range used for�PLL2. It must be written before enabling the PLL2. 00-01-10: PLL2 input (ref2_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL2FRACEN = (1U << 4);  ///< PLL2 fractional latch enable This bit is set and reset by software to latch the content of PLL2FRACN in the ΣΔ modulator. In order to latch the PLL2FRACN value into the ΣΔ modulator, PLL2FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL2FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL2M = (4 << 8);  ///< Prescaler for PLL2 This bitfield is set and cleared by software to configure the prescaler of the PLL2. The VCO2 input frequency is PLL2 input clock frequency/PLL2M. This bit can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2PEN = (1U << 16);  ///< PLL2 DIVP divider output enable This bit is set and reset by software to enable the pll2_p_ck output of the PLL2. To save power, PLL2PEN and PLL2P bits must be set to 0 when pll2_p_ck is not used.
        constexpr uint32_t PLL2QEN = (1U << 17);  ///< PLL2 DIVQ divider output enable This bit is set and reset by software to enable the pll2_q_ck output of the PLL2. To save power, PLL2QEN and PLL2Q bits must be set to 0 when pll2_q_ck is not used.
        constexpr uint32_t PLL2REN = (1U << 18);  ///< PLL2 DIVR divider output enable This bit is set and reset by software to enable the pll2_r_ck output of the PLL2. To save power, PLL2REN and PLL2R bits must be set to 0 when pll2_r_ck is not used.
    }

    /// RCC_PLL3CFGR Register bits
    namespace rcc_pll3cfgr_bits {
        constexpr uint32_t PLL3SRC = (2 << 0);  ///< PLL3 entry clock source This bitfield is set and cleared by software to select PLL3 clock source. It can be written only when the PLL3 is disabled. To save power, when no PLL3 is used, this bitfield value must be�zero.
        constexpr uint32_t PLL3RGE = (2 << 2);  ///< PLL3 input frequency range This bit is set and reset by software to select the proper reference frequency range used for�PLL3. It must be written before enabling the PLL3. 00-01-10: PLL3 input (ref3_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL3FRACEN = (1U << 4);  ///< PLL3 fractional latch enable This bit is set and reset by software to latch the content of PLL3FRACN in the ΣΔ modulator. In order to latch the PLL3FRACN value into the ΣΔ modulator, PLL3FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL3FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL3M = (4 << 8);  ///< Prescaler for PLL3 This bitfield is set and cleared by software to configure the prescaler of the PLL3. The VCO3 input frequency is PLL3 input clock frequency/PLL3M. This bitfield can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3PEN = (1U << 16);  ///< PLL3 DIVP divider output enable This bit is set and reset by software to enable the pll3_p_ck output of the PLL3. To save power, PLL3PEN and PLL3P bits must be set to 0 when pll3_p_ck is not used.
        constexpr uint32_t PLL3QEN = (1U << 17);  ///< PLL3 DIVQ divider output enable This bit is set and reset by software to enable the pll3_q_ck output of the PLL3. To save power, PLL3QEN and PLL3Q bits must be set to 0 when pll3_q_ck is not used.
        constexpr uint32_t PLL3REN = (1U << 18);  ///< PLL3 DIVR divider output enable This bit is set and reset by software to enable the pll3_r_ck output of the PLL3. To save power, PLL3REN and PLL3R bits must be set to 0 when pll3_r_ck is not used.
    }

    /// RCC_PLL1DIVR Register bits
    namespace rcc_pll1divr_bits {
        constexpr uint32_t PLL1N = (9 << 0);  ///< Multiplication factor for PLL1 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL1ON = 0 and PLL1RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref1_ck</sub> x PLL1N, when fractional value 0 has been loaded in PLL1FRACN, with: PLL1N between 4 and 512 input frequency F<sub>ref1_ck</sub> between 4 and 16�MHz
        constexpr uint32_t PLL1P = (7 << 9);  ///< PLL1 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll1_p_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1Q = (7 << 16);  ///< PLL1 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll1_q_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1R = (7 << 24);  ///< PLL1 DIVR division factor This bitfield is set and reset by software to control frequency of the pll1_r_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). Only division by one and even division factors are allowed. ...
    }

    /// RCC_PLL1FRACR Register bits
    namespace rcc_pll1fracr_bits {
        constexpr uint32_t PLL1FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL1 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO. VCO output frequency = F<sub>ref1_ck</sub> x (PLL1N + (PLL1FRACN / 2<sup>13</sup>)), with: PLL1N must be between 4 and 512. PLL1FRACN can be between 0 and 2<sup>13</sup>- 1. The input frequency F<sub>ref1_ck</sub> must be between 4 and 16 MHz. To change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as�follows: Set PLL1FRACEN = 0. Write the new fractional value into PLL1FRACN. Set PLL1FRACEN = 1.
    }

    /// RCC_PLL2DIVR Register bits
    namespace rcc_pll2divr_bits {
        constexpr uint32_t PLL2N = (9 << 0);  ///< Multiplication factor for PLL2 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL2ON = 0 and PLL2RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref2_ck</sub> x PLL2N, when fractional value 0 has been loaded in PLL2FRACN, with: PLL2N between 4 and 512 input frequency F<sub>ref2_ck</sub> between 1MHz and 16MHz
        constexpr uint32_t PLL2P = (7 << 9);  ///< PLL2 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll2_p_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2Q = (7 << 16);  ///< PLL2 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll2_q_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2R = (7 << 24);  ///< PLL2 DIVR division factor This bitfield is set and reset by software to control the frequency of the pll2_r_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
    }

    /// RCC_PLL2FRACR Register bits
    namespace rcc_pll2fracr_bits {
        constexpr uint32_t PLL2FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL2 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL2 VCO. VCO output frequency = F<sub>ref2_ck</sub> x (PLL2N + (PLL2FRACN / 2<sup>13</sup>)), with PLL2N must be between 4 and 512. PLL2FRACN can be between 0 and 2<sup>13 </sup>- 1. The input frequency F<sub>ref2_ck</sub> must be between 4 and 16 MHz. In order to change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows: Set the bit PLL2FRACEN to 0. Write the new fractional value into PLL2FRACN. Set the bit PLL2FRACEN to 1.
    }

    /// RCC_PLL3DIVR Register bits
    namespace rcc_pll3divr_bits {
        constexpr uint32_t PLL3N = (9 << 0);  ///< Multiplication factor for PLL3 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL3ON = 0 and PLL3RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref3_ck</sub> x PLL3N, when fractional value 0 has been loaded in PLL3FRACN, with: PLL3N between 4 and 512 input frequency F<sub>ref3_ck</sub> between 4 and 16MHz
        constexpr uint32_t PLL3P = (7 << 9);  ///< PLL3 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll3_p_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3Q = (7 << 16);  ///< PLL3 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll3_q_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3R = (7 << 24);  ///< PLL3 DIVR division factor This bitfield is set and reset by software to control the frequency of the pll3_r_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
    }

    /// RCC_PLL3FRACR Register bits
    namespace rcc_pll3fracr_bits {
        constexpr uint32_t PLL3FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL3 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL3 VCO. VCO output frequency = F<sub>ref3_ck</sub> x (PLL3N + (PLL3FRACN / 2<sup>13</sup>)), with: PLL3N must be between 4 and 512. PLL3FRACN can be between 0 and 2<sup>13 </sup>- 1. The input frequency F<sub>ref3_ck</sub> must be between 4 and 16 MHz. In order to change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows: Set the bit PLL3FRACEN to 0. Write the new fractional value into PLL3FRACN. Set the bit PLL3FRACEN to 1.
    }

    /// RCC_CIER Register bits
    namespace rcc_cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization.
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.
        constexpr uint32_t MSISRDYIE = (1U << 2);  ///< MSIS ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the MSIS oscillator stabilization.
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI16 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization.
        constexpr uint32_t HSI48RDYIE = (1U << 5);  ///< HSI48 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSI48 oscillator stabilization.
        constexpr uint32_t PLL1RDYIE = (1U << 6);  ///< PLL ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL1 lock.
        constexpr uint32_t PLL2RDYIE = (1U << 7);  ///< PLL2 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL2 lock.
        constexpr uint32_t PLL3RDYIE = (1U << 8);  ///< PLL3 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL3 lock.
        constexpr uint32_t MSIKRDYIE = (1U << 11);  ///< MSIK ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the MSIK oscillator stabilization.
        constexpr uint32_t SHSIRDYIE = (1U << 12);  ///< SHSI ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the SHSI oscillator stabilization.
    }

    /// RCC_CIFR Register bits
    namespace rcc_cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag This bit is set by hardware when the LSI clock becomes stable and LSIRDYIE is set. It is cleared by software by�setting the LSIRDYC bit.
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag This bit is set by hardware when the LSE clock becomes stable and LSERDYIE is set. It is cleared by software by setting the LSERDYC bit.
        constexpr uint32_t MSISRDYF = (1U << 2);  ///< MSIS ready interrupt flag This bit is set by hardware when the MSIS clock becomes stable and MSISRDYIE is set. It�is cleared by software by setting the MSISRDYC bit.
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI16 ready interrupt flag This bit is set by hardware when the HSI16 clock becomes stable and HSIRDYIE = 1 in�response to setting the HSION (see RCC_CR). When HSION = 0 but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. This bit is cleared by software by setting the HSIRDYC bit.
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag This bit is set by hardware when the HSE clock becomes stable and HSERDYIE is set. It is cleared by software by setting the HSERDYC bit.
        constexpr uint32_t HSI48RDYF = (1U << 5);  ///< HSI48 ready interrupt flag This bit is set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set. it�is cleared by software by setting the HSI48RDYC bit.
        constexpr uint32_t PLL1RDYF = (1U << 6);  ///< PLL1 ready interrupt flag This bit is set by hardware when the PLL1 locks and PLL1RDYIE is set. It is cleared by software by setting the PLL1RDYC bit.
        constexpr uint32_t PLL2RDYF = (1U << 7);  ///< PLL2 ready interrupt flag This bit is set by hardware when the PLL2 locks and PLL2RDYIE is set. It is cleared by software by setting the PLL2RDYC bit.
        constexpr uint32_t PLL3RDYF = (1U << 8);  ///< PLL3 ready interrupt flag This bit is set by hardware when the PLL3 locks and PLL3RDYIE is set. It is cleared by software by setting the PLL3RDYC bit.
        constexpr uint32_t CSSF = (1U << 10);  ///< Clock security system interrupt flag This bit is set by hardware when a failure is detected in the HSE oscillator. It is cleared by software by setting the CSSC bit.
        constexpr uint32_t MSIKRDYF = (1U << 11);  ///< MSIK ready interrupt flag This bit is set by hardware when the MSIK clock becomes stable and MSIKRDYIE is set. It is cleared by software by setting the MSIKRDYC bit.
        constexpr uint32_t SHSIRDYF = (1U << 12);  ///< SHSI ready interrupt flag This bit is set by hardware when the SHSI clock becomes stable and SHSIRDYIE is set. It is cleared by software by setting the SHSIRDYC bit.
    }

    /// RCC_CICR Register bits
    namespace rcc_cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear Writing this bit to 1 clears the LSIRDYF flag. Writing 0 has no effect.
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear Writing this bit to 1 clears the LSERDYF flag. Writing 0 has no effect.
        constexpr uint32_t MSISRDYC = (1U << 2);  ///< MSIS ready interrupt clear Writing this bit to 1 clears the MSISRDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI16 ready interrupt clear Writing this bit to 1 clears the HSIRDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear Writing this bit to 1 clears the HSERDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSI48RDYC = (1U << 5);  ///< HSI48 ready interrupt clear Writing this bit to 1 clears the HSI48RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL1RDYC = (1U << 6);  ///< PLL1 ready interrupt clear Writing this bit to 1 clears the PLL1RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL2RDYC = (1U << 7);  ///< PLL2 ready interrupt clear Writing this bit to 1 clears the PLL2RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL3RDYC = (1U << 8);  ///< PLL3 ready interrupt clear Writing this bit to 1 clears the PLL3RDYF flag. Writing 0 has no effect.
        constexpr uint32_t CSSC = (1U << 10);  ///< Clock security system interrupt clear Writing this bit to 1 clears the CSSF flag. Writing 0 has no effect.
        constexpr uint32_t MSIKRDYC = (1U << 11);  ///< MSIK oscillator ready interrupt clear Writing this bit to 1 clears the MSIKRDYF flag. Writing 0 has no effect.
        constexpr uint32_t SHSIRDYC = (1U << 12);  ///< SHSI oscillator ready interrupt clear Writing this bit to 1 clears the SHSIRDYF flag. Writing 0 has no effect.
    }

    /// RCC_AHB1RSTR Register bits
    namespace rcc_ahb1rstr_bits {
        constexpr uint32_t GPDMA1RST = (1U << 0);  ///< GPDMA1 reset This bit is set and cleared by software.
        constexpr uint32_t CORDICRST = (1U << 1);  ///< CORDIC reset This bit is set and cleared by software.
        constexpr uint32_t FMACRST = (1U << 2);  ///< FMAC reset This bit is set and cleared by software.
        constexpr uint32_t MDF1RST = (1U << 3);  ///< MDF1 reset This bit is set and cleared by software.
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset This bit is set and cleared by software.
        constexpr uint32_t JPEGRST = (1U << 15);  ///< JPEG reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCRST = (1U << 16);  ///< TSC reset This bit is set and cleared by software.
        constexpr uint32_t RAMCFGRST = (1U << 17);  ///< RAMCFG reset This bit is set and cleared by software.
        constexpr uint32_t DMA2DRST = (1U << 18);  ///< DMA2D reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMURST = (1U << 19);  ///< GFXMMU reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DRST = (1U << 20);  ///< GPU2D reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2RSTR1 Register bits
    namespace rcc_ahb2rstr1_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< I/O port A reset This bit is set and cleared by software.
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< I/O port B reset This bit is set and cleared by software.
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< I/O port C reset This bit is set and cleared by software.
        constexpr uint32_t GPIODRST = (1U << 3);  ///< I/O port D reset This bit is set and cleared by software.
        constexpr uint32_t GPIOERST = (1U << 4);  ///< I/O port E reset This bit is set and cleared by software.
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< I/O port F reset This bit is set and cleared by software. This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. Note: If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< I/O port G reset This bit is set and cleared by software.
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< I/O port H reset This bit is set and cleared by software.
        constexpr uint32_t GPIOIRST = (1U << 8);  ///< I/O port I reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJRST = (1U << 9);  ///< I/O port J reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12RST = (1U << 10);  ///< ADC1 and ADC2 reset This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585, and ADC1/ADC2 in�STM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSIRST = (1U << 12);  ///< DCMI and PSSI reset This bit is set and cleared by software.
        constexpr uint32_t OTGRST = (1U << 14);  ///< OTG_FS or OTG_HS reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESRST = (1U << 16);  ///< AES hardware accelerator reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHRST = (1U << 17);  ///< HASH reset This bit is set and cleared by software.
        constexpr uint32_t RNGRST = (1U << 18);  ///< RNG reset This bit is set and cleared by software.
        constexpr uint32_t PKARST = (1U << 19);  ///< PKA reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESRST = (1U << 20);  ///< SAES hardware accelerator reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMRST = (1U << 21);  ///< OCTOSPIM reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1RST = (1U << 23);  ///< OTFDEC1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2RST = (1U << 24);  ///< OTFDEC2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1RST = (1U << 27);  ///< SDMMC1 reset This bit is set and cleared by software.
        constexpr uint32_t SDMMC2RST = (1U << 28);  ///< SDMMC2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2RSTR2 Register bits
    namespace rcc_ahb2rstr2_bits {
        constexpr uint32_t FSMCRST = (1U << 0);  ///< Flexible memory controller reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1RST = (1U << 4);  ///< OCTOSPI1 reset This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2RST = (1U << 8);  ///< OCTOSPI2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1RST = (1U << 12);  ///< HSPI1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3RSTR Register bits
    namespace rcc_ahb3rstr_bits {
        constexpr uint32_t LPGPIO1RST = (1U << 0);  ///< LPGPIO1 reset This bit is set and cleared by software.
        constexpr uint32_t ADC4RST = (1U << 5);  ///< ADC4 reset This bit is set and cleared by software.
        constexpr uint32_t DAC1RST = (1U << 6);  ///< DAC1 reset This bit is set and cleared by software.
        constexpr uint32_t LPDMA1RST = (1U << 9);  ///< LPDMA1 reset This bit is set and cleared by software.
        constexpr uint32_t ADF1RST = (1U << 10);  ///< ADF1 reset This bit is set and cleared by software.
    }

    /// RCC_APB1RSTR1 Register bits
    namespace rcc_apb1rstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 reset This bit is set and cleared by software.
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 reset This bit is set and cleared by software.
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM4 reset This bit is set and cleared by software.
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 reset This bit is set and cleared by software.
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 reset This bit is set and cleared by software.
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 reset This bit is set and cleared by software.
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset This bit is set and cleared by software.
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series.Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset This bit is set and cleared by software.
        constexpr uint32_t UART4RST = (1U << 19);  ///< UART4 reset This bit is set and cleared by software.
        constexpr uint32_t UART5RST = (1U << 20);  ///< UART5 reset This bit is set and cleared by software.
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset This bit is set and cleared by software.
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset This bit is set and cleared by software.
        constexpr uint32_t CRSRST = (1U << 24);  ///< CRS reset This bit is set and cleared by software.
        constexpr uint32_t USART6RST = (1U << 25);  ///< USART6 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1RSTR2 Register bits
    namespace rcc_apb1rstr2_bits {
        constexpr uint32_t I2C4RST = (1U << 1);  ///< I2C4 reset This bit is set and cleared by software
        constexpr uint32_t LPTIM2RST = (1U << 5);  ///< LPTIM2 reset This bit is set and cleared by software.
        constexpr uint32_t I2C5RST = (1U << 6);  ///< I2C5 reset This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6RST = (1U << 7);  ///< I2C6 reset This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1RST = (1U << 9);  ///< FDCAN1 reset This bit is set and cleared by software.
        constexpr uint32_t UCPD1RST = (1U << 23);  ///< UCPD1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2RSTR Register bits
    namespace rcc_apb2rstr_bits {
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 reset This bit is set and cleared by software.
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset This bit is set and cleared by software.
        constexpr uint32_t TIM8RST = (1U << 13);  ///< TIM8 reset This bit is set and cleared by software.
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset This bit is set and cleared by software.
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 reset This bit is set and cleared by software.
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 reset This bit is set and cleared by software.
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 reset This bit is set and cleared by software.
        constexpr uint32_t SAI1RST = (1U << 21);  ///< SAI1 reset This bit is set and cleared by software.
        constexpr uint32_t SAI2RST = (1U << 22);  ///< SAI2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBRST = (1U << 24);  ///< USB reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMRST = (1U << 25);  ///< GFXTIM reset This bit is set and cleared by software. Note: .This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCRST = (1U << 26);  ///< LTDC reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSIRST = (1U << 27);  ///< DSI reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3RSTR Register bits
    namespace rcc_apb3rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 1);  ///< SYSCFG reset This bit is set and cleared by software.
        constexpr uint32_t SPI3RST = (1U << 5);  ///< SPI3 reset This bit is set and cleared by software.
        constexpr uint32_t LPUART1RST = (1U << 6);  ///< LPUART1 reset This bit is set and cleared by software.
        constexpr uint32_t I2C3RST = (1U << 7);  ///< I2C3 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM1RST = (1U << 11);  ///< LPTIM1 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM3RST = (1U << 12);  ///< LPTIM3 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM4RST = (1U << 13);  ///< LPTIM4 reset This bit is set and cleared by software.
        constexpr uint32_t OPAMPRST = (1U << 14);  ///< OPAMP reset This bit is set and cleared by software.
        constexpr uint32_t COMPRST = (1U << 15);  ///< COMP reset This bit is set and cleared by software.
        constexpr uint32_t VREFRST = (1U << 20);  ///< VREFBUF reset This bit is set and cleared by software.
    }

    /// RCC_AHB1ENR Register bits
    namespace rcc_ahb1enr_bits {
        constexpr uint32_t GPDMA1EN = (1U << 0);  ///< GPDMA1 clock enable This bit is set and cleared by software.
        constexpr uint32_t CORDICEN = (1U << 1);  ///< CORDIC clock enable This bit is set and cleared by software.
        constexpr uint32_t FMACEN = (1U << 2);  ///< FMAC clock enable This bit is set and reset by software.
        constexpr uint32_t MDF1EN = (1U << 3);  ///< MDF1 clock enable This bit is set and reset by software.
        constexpr uint32_t FLASHEN = (1U << 8);  ///< FLASH clock enable This bit is set and cleared by software. This bit can be disabled only when the flash memory is in power-down mode.
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable This bit is set and cleared by software.
        constexpr uint32_t JPEGEN = (1U << 15);  ///< JPEG clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCEN = (1U << 16);  ///< Touch sensing controller clock enable This bit is set and cleared by software.
        constexpr uint32_t RAMCFGEN = (1U << 17);  ///< RAMCFG clock enable This bit is set and cleared by software.
        constexpr uint32_t DMA2DEN = (1U << 18);  ///< DMA2D clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMUEN = (1U << 19);  ///< GFXMMU clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DEN = (1U << 20);  ///< GPU2D clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DCACHE2EN = (1U << 21);  ///< DCACHE2 clock enable This bit is set and reset by software. Note: DCACHE2 clock must be enabled to access memories, even if the DCACHE2 is bypassed. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GTZC1EN = (1U << 24);  ///< GTZC1 clock enable This bit is set and reset by software.
        constexpr uint32_t BKPSRAMEN = (1U << 28);  ///< BKPSRAM clock enable This bit is set and reset by software.
        constexpr uint32_t DCACHE1EN = (1U << 30);  ///< DCACHE1 clock enable This bit is set and reset by software. Note: DCACHE1 clock must be enabled when external memories are accessed through OCTOSPI1, OCTOSPI2, HSPI1 or FSMC, even if the DCACHE1 is bypassed.
        constexpr uint32_t SRAM1EN = (1U << 31);  ///< SRAM1 clock enable This bit is set and reset by software.
    }

    /// RCC_AHB2ENR1 Register bits
    namespace rcc_ahb2enr1_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< I/O port A clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< I/O port B clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< I/O port C clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIODEN = (1U << 3);  ///< I/O port D clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< I/O port E clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< I/O port F clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< I/O port G clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< I/O port H clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOIEN = (1U << 8);  ///< I/O port I clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJEN = (1U << 9);  ///< I/O port J clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12EN = (1U << 10);  ///< ADC1 and ADC2 clock enable This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585, and ADC1/ADC2 in�STM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSIEN = (1U << 12);  ///< DCMI and PSSI clock enable This bit is set and cleared by software.
        constexpr uint32_t OTGEN = (1U << 14);  ///< OTG_FS or OTG_HS clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTGHSPHYEN = (1U << 15);  ///< OTG_HS PHY clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESEN = (1U << 16);  ///< AES clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHEN = (1U << 17);  ///< HASH clock enable This bit is set and cleared by software
        constexpr uint32_t RNGEN = (1U << 18);  ///< RNG clock enable This bit is set and cleared by software.
        constexpr uint32_t PKAEN = (1U << 19);  ///< PKA clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESEN = (1U << 20);  ///< SAES clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMEN = (1U << 21);  ///< OCTOSPIM clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1EN = (1U << 23);  ///< OTFDEC1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2EN = (1U << 24);  ///< OTFDEC2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1EN = (1U << 27);  ///< SDMMC1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SDMMC2EN = (1U << 28);  ///< SDMMC2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM2EN = (1U << 30);  ///< SRAM2 clock enable This bit is set and reset by software.
        constexpr uint32_t SRAM3EN = (1U << 31);  ///< SRAM3 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2ENR2 Register bits
    namespace rcc_ahb2enr2_bits {
        constexpr uint32_t FSMCEN = (1U << 0);  ///< FSMC clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1EN = (1U << 4);  ///< OCTOSPI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2EN = (1U << 8);  ///< OCTOSPI2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1EN = (1U << 12);  ///< HSPI1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM6EN = (1U << 30);  ///< SRAM6 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM5EN = (1U << 31);  ///< SRAM5 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3ENR Register bits
    namespace rcc_ahb3enr_bits {
        constexpr uint32_t LPGPIO1EN = (1U << 0);  ///< LPGPIO1 enable This bit is set and cleared by software.
        constexpr uint32_t PWREN = (1U << 2);  ///< PWR clock enable This bit is set and cleared by software.
        constexpr uint32_t ADC4EN = (1U << 5);  ///< ADC4 clock enable This bit is set and cleared by software.
        constexpr uint32_t DAC1EN = (1U << 6);  ///< DAC1 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPDMA1EN = (1U << 9);  ///< LPDMA1 clock enable This bit is set and cleared by software.
        constexpr uint32_t ADF1EN = (1U << 10);  ///< ADF1 clock enable This bit is set and cleared by software.
        constexpr uint32_t GTZC2EN = (1U << 12);  ///< GTZC2 clock enable This bit is set and cleared by software.
        constexpr uint32_t SRAM4EN = (1U << 31);  ///< SRAM4 clock enable This bit is set and reset by software.
    }

    /// RCC_APB1ENR1 Register bits
    namespace rcc_apb1enr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 clock enable This bit is set and cleared by software.
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable This bit is set by software to enable the window watchdog clock. It is reset by hardware system reset. This bit can also be set by hardware if the WWDG_SW option bit is reset.
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable This bit is set and cleared by software.
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable This bit is set and cleared by software.
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 clock enable This bit is set and cleared by software.
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable This bit is set and cleared by software.
        constexpr uint32_t CRSEN = (1U << 24);  ///< CRS clock enable This bit is set and cleared by software.
        constexpr uint32_t USART6EN = (1U << 25);  ///< USART6 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1ENR2 Register bits
    namespace rcc_apb1enr2_bits {
        constexpr uint32_t I2C4EN = (1U << 1);  ///< I2C4 clock enable This bit is set and cleared by software
        constexpr uint32_t LPTIM2EN = (1U << 5);  ///< LPTIM2 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C5EN = (1U << 6);  ///< I2C5 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6EN = (1U << 7);  ///< I2C6 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1EN = (1U << 9);  ///< FDCAN1 clock enable This bit is set and cleared by software.
        constexpr uint32_t UCPD1EN = (1U << 23);  ///< UCPD1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2ENR Register bits
    namespace rcc_apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM8EN = (1U << 13);  ///< TIM8 clock enable This bit is set and cleared by software.
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 clock enable This bit is set and cleared by software.
        constexpr uint32_t SAI1EN = (1U << 21);  ///< SAI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SAI2EN = (1U << 22);  ///< SAI2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBEN = (1U << 24);  ///< USB clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMEN = (1U << 25);  ///< GFXTIM clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCEN = (1U << 26);  ///< LTDC clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSIEN = (1U << 27);  ///< DSI clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3ENR Register bits
    namespace rcc_apb3enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 1);  ///< SYSCFG clock enable This bit is set and cleared by software.
        constexpr uint32_t SPI3EN = (1U << 5);  ///< SPI3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPUART1EN = (1U << 6);  ///< LPUART1 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C3EN = (1U << 7);  ///< I2C3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM1EN = (1U << 11);  ///< LPTIM1 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM3EN = (1U << 12);  ///< LPTIM3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM4EN = (1U << 13);  ///< LPTIM4 clock enable This bit is set and cleared by software.
        constexpr uint32_t OPAMPEN = (1U << 14);  ///< OPAMP clock enable This bit is set and cleared by software.
        constexpr uint32_t COMPEN = (1U << 15);  ///< COMP clock enable This bit is set and cleared by software.
        constexpr uint32_t VREFEN = (1U << 20);  ///< VREFBUF clock enable This bit is set and cleared by software.
        constexpr uint32_t RTCAPBEN = (1U << 21);  ///< RTC and TAMP APB clock enable This bit is set and cleared by software.
    }

    /// RCC_AHB1SMENR Register bits
    namespace rcc_ahb1smenr_bits {
        constexpr uint32_t GPDMA1SMEN = (1U << 0);  ///< GPDMA1 clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t CORDICSMEN = (1U << 1);  ///< CORDIC clocks enable during Sleep and Stop modes This bit is set and cleared by software during Sleep mode.
        constexpr uint32_t FMACSMEN = (1U << 2);  ///< FMAC clocks enable during Sleep and Stop modes. This bit is set and cleared by software.
        constexpr uint32_t MDF1SMEN = (1U << 3);  ///< MDF1 clocks enable during Sleep and Stop modes. This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< FLASH clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t JPEGSMEN = (1U << 15);  ///< JPEG clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCSMEN = (1U << 16);  ///< TSC clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t RAMCFGSMEN = (1U << 17);  ///< RAMCFG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t DMA2DSMEN = (1U << 18);  ///< DMA2D clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMUSMEN = (1U << 19);  ///< GFXMMU clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DSMEN = (1U << 20);  ///< GPU2D clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DCACHE2SMEN = (1U << 21);  ///< DCACHE2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GTZC1SMEN = (1U << 24);  ///< GTZC1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t BKPSRAMSMEN = (1U << 28);  ///< BKPSRAM clock enable during Sleep and Stop modes This bit is set and cleared by software
        constexpr uint32_t ICACHESMEN = (1U << 29);  ///< ICACHE clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t DCACHE1SMEN = (1U << 30);  ///< DCACHE1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM1SMEN = (1U << 31);  ///< SRAM1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
    }

    /// RCC_AHB2SMENR1 Register bits
    namespace rcc_ahb2smenr1_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< I/O port A clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< I/O port B clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< I/O port C clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< I/O port D clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< I/O port E clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< I/O port F clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGSMEN = (1U << 6);  ///< I/O port G clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOHSMEN = (1U << 7);  ///< I/O port H clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOISMEN = (1U << 8);  ///< I/O port I clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJSMEN = (1U << 9);  ///< I/O port J clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12SMEN = (1U << 10);  ///< ADC1 and ADC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585 and ADC1/ADC2 in�STM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSISMEN = (1U << 12);  ///< DCMI and PSSI clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t OTGSMEN = (1U << 14);  ///< OTG_FS and OTG_HS clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTGHSPHYSMEN = (1U << 15);  ///< OTG_HS PHY clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESSMEN = (1U << 16);  ///< AES clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHSMEN = (1U << 17);  ///< HASH clock enable during Sleep and Stop modes This bit is set and cleared by software
        constexpr uint32_t RNGSMEN = (1U << 18);  ///< RNG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t PKASMEN = (1U << 19);  ///< PKA clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESSMEN = (1U << 20);  ///< SAES accelerator clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMSMEN = (1U << 21);  ///< OCTOSPIM clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1SMEN = (1U << 23);  ///< OTFDEC1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2SMEN = (1U << 24);  ///< OTFDEC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1SMEN = (1U << 27);  ///< SDMMC1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SDMMC2SMEN = (1U << 28);  ///< SDMMC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM2SMEN = (1U << 30);  ///< SRAM2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM3SMEN = (1U << 31);  ///< SRAM3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2SMENR2 Register bits
    namespace rcc_ahb2smenr2_bits {
        constexpr uint32_t FSMCSMEN = (1U << 0);  ///< FSMC clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1SMEN = (1U << 4);  ///< OCTOSPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2SMEN = (1U << 8);  ///< OCTOSPI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1SMEN = (1U << 12);  ///< HSPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM6SMEN = (1U << 30);  ///< SRAM6 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM5SMEN = (1U << 31);  ///< SRAM5 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3SMENR Register bits
    namespace rcc_ahb3smenr_bits {
        constexpr uint32_t LPGPIO1SMEN = (1U << 0);  ///< LPGPIO1 enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t PWRSMEN = (1U << 2);  ///< PWR clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t ADC4SMEN = (1U << 5);  ///< ADC4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t DAC1SMEN = (1U << 6);  ///< DAC1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPDMA1SMEN = (1U << 9);  ///< LPDMA1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADF1SMEN = (1U << 10);  ///< ADF1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t GTZC2SMEN = (1U << 12);  ///< GTZC2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM4SMEN = (1U << 31);  ///< SRAM4 clock enable during Sleep and Stop modes This bit is set and cleared by software.
    }

    /// RCC_APB1SMENR1 Register bits
    namespace rcc_apb1smenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM5SMEN = (1U << 3);  ///< TIM5 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< Window watchdog clock enable during Sleep and Stop modes This bit is set and cleared by software. It is forced to one by hardware when the hardware WWDG option is activated.
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t UART4SMEN = (1U << 19);  ///< UART4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t UART5SMEN = (1U << 20);  ///< UART5 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t CRSSMEN = (1U << 24);  ///< CRS clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t USART6SMEN = (1U << 25);  ///< USART6 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1SMENR2 Register bits
    namespace rcc_apb1smenr2_bits {
        constexpr uint32_t I2C4SMEN = (1U << 1);  ///< I2C4 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM2SMEN = (1U << 5);  ///< LPTIM2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C5SMEN = (1U << 6);  ///< I2C5 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6SMEN = (1U << 7);  ///< I2C6 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1SMEN = (1U << 9);  ///< FDCAN1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t UCPD1SMEN = (1U << 23);  ///< UCPD1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2SMENR Register bits
    namespace rcc_apb2smenr_bits {
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t TIM8SMEN = (1U << 13);  ///< TIM8 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM17 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SAI1SMEN = (1U << 21);  ///< SAI1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SAI2SMEN = (1U << 22);  ///< SAI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series.Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBSMEN = (1U << 24);  ///< USB clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMSMEN = (1U << 25);  ///< GFXTIM clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCSMEN = (1U << 26);  ///< LTDC clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSISMEN = (1U << 27);  ///< DSI clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3SMENR Register bits
    namespace rcc_apb3smenr_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 1);  ///< SYSCFG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SPI3SMEN = (1U << 5);  ///< SPI3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPUART1SMEN = (1U << 6);  ///< LPUART1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C3SMEN = (1U << 7);  ///< I2C3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM1SMEN = (1U << 11);  ///< LPTIM1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM3SMEN = (1U << 12);  ///< LPTIM3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM4SMEN = (1U << 13);  ///< LPTIM4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t OPAMPSMEN = (1U << 14);  ///< OPAMP clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t COMPSMEN = (1U << 15);  ///< COMP clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t VREFSMEN = (1U << 20);  ///< VREFBUF clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t RTCAPBSMEN = (1U << 21);  ///< RTC and TAMP APB clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
    }

    /// RCC_SRDAMR Register bits
    namespace rcc_srdamr_bits {
        constexpr uint32_t SPI3AMEN = (1U << 5);  ///< SPI3 autonomous mode enable in Stop 0,1, 2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPUART1AMEN = (1U << 6);  ///< LPUART1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C3AMEN = (1U << 7);  ///< I2C3 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM1AMEN = (1U << 11);  ///< LPTIM1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM3AMEN = (1U << 12);  ///< LPTIM3 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM4AMEN = (1U << 13);  ///< LPTIM4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t OPAMPAMEN = (1U << 14);  ///< OPAMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t COMPAMEN = (1U << 15);  ///< COMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t VREFAMEN = (1U << 20);  ///< VREFBUF autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t RTCAPBAMEN = (1U << 21);  ///< RTC and TAMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADC4AMEN = (1U << 25);  ///< ADC4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPGPIO1AMEN = (1U << 26);  ///< LPGPIO1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t DAC1AMEN = (1U << 27);  ///< DAC1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPDMA1AMEN = (1U << 28);  ///< LPDMA1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADF1AMEN = (1U << 29);  ///< ADF1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t SRAM4AMEN = (1U << 31);  ///< SRAM4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
    }

    /// RCC_CCIPR1 Register bits
    namespace rcc_ccipr1_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 kernel clock source selection These bits are used to select the USART1 kernel clock source. Note: The USART1 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 kernel clock source selection These bits are used to select the USART2 kernel clock source. The USART2 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 kernel clock source selection These bits are used to select the USART3 kernel clock source. Note: The USART3 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t UART4SEL = (2 << 6);  ///< UART4 kernel clock source selection These bits are used to select the UART4 kernel clock source. Note: The UART4 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t UART5SEL = (2 << 8);  ///< UART5 kernel clock source selection These bits are used to select the UART5 kernel clock source. Note: The UART5 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t I2C1SEL = (2 << 10);  ///< I2C1 kernel clock source selection These bits are used to select the I2C1 kernel clock source. Note: The I2C1 is functional in Stop 0 and Stop 1 mode sonly when the kernel clock is HSI16�or MSIK.
        constexpr uint32_t I2C2SEL = (2 << 12);  ///< I2C2 kernel clock source selection These bits are used to select the I2C2 kernel clock source. Note: The I2C2 is functional in Stop 0 and Stop 1 mode sonly when the kernel clock is HSI16�or MSIK.
        constexpr uint32_t I2C4SEL = (2 << 14);  ///< I2C4 kernel clock source selection These bits are used to select the I2C4 kernel clock source. Note: The I2C4 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16�or MSIK.
        constexpr uint32_t SPI2SEL = (2 << 16);  ///< SPI2 kernel clock source selection These bits are used to select the SPI2 kernel clock source. Note: The SPI2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t LPTIM2SEL = (2 << 18);  ///< Low-power timer 2 kernel clock source selection These bits are used to select the LPTIM2 kernel clock source. Note: The LPTIM2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is LSI, LSE or HSI16 if HSIKERON = 1.
        constexpr uint32_t SPI1SEL = (2 << 20);  ///< SPI1 kernel clock source selection These bits are used to select the SPI1 kernel clock source. Note: The SPI1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t SYSTICKSEL = (2 << 22);  ///< SysTick clock source selection These bits are used to select the SysTick clock source. Note: When LSE or LSI is selected, the AHB frequency must be at least four times higher than the LSI or LSE frequency. In addition, a jitter up to one HCLK cycle is introduced, due to the LSE or LSI sampling with HCLK in the SysTick circuitry.
        constexpr uint32_t FDCAN1SEL = (2 << 24);  ///< FDCAN1 kernel clock source selection These bits are used to select the FDCAN1 kernel clock source.
        constexpr uint32_t ICLKSEL = (2 << 26);  ///< Intermediate clock source selection These bits are used to select the clock source for the OTG_FS, the USB, and the SDMMC.
        constexpr uint32_t TIMICSEL = (3 << 29);  ///< Clock sources for TIM16,TIM17, and LPTIM2 internal input capture When TIMICSEL2 is set, the TIM16, TIM17, and LPTIM2 internal input capture can be connected either to HSI/256, MSI/4, or MSI/1024. Depending on TIMICSEL[1:0] value, MSI is either MSIK or MSIS. When TIMICSEL2 is cleared, the HSI, MSIK, and MSIS clock sources cannot be selected as�TIM16, TIM17, or LPTIM2 internal input capture. 0xx: HSI, MSIK and MSIS dividers disabled Note: The clock division must be disabled (TIMICSEL configured to 0xx) before selecting or changing a clock sources division.
    }

    /// RCC_CCIPR2 Register bits
    namespace rcc_ccipr2_bits {
        constexpr uint32_t MDF1SEL = (3 << 0);  ///< MDF1 kernel clock source selection These bits are used to select the MDF1 kernel clock source. others: reserved
        constexpr uint32_t SAI1SEL = (3 << 5);  ///< SAI1 kernel clock source selection These bits are used to select the SAI1 kernel clock source. others: reserved Note: If the selected clock is the external clock and this clock is stopped, a switch to another clock is impossible.
        constexpr uint32_t SAI2SEL = (3 << 8);  ///< SAI2 kernel clock source selection These bits are used to select the SAI2 kernel clock source. others: reserved If the selected clock is the external clock and this clock is stopped, a switch to another clock is impossible. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t SAESSEL = (1U << 11);  ///< SAES kernel clock source selection This bit is used to select the SAES kernel clock source. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t RNGSEL = (2 << 12);  ///< RNG kernel clock source selection These bits are used to select the RNG kernel clock source.
        constexpr uint32_t SDMMCSEL = (1U << 14);  ///< SDMMC1 and SDMMC2 kernel clock source selection This bit is used to select the SDMMC kernel clock source. It is recommended to change it only after reset and before enabling the SDMMC.
        constexpr uint32_t DSISEL = (1U << 15);  ///< DSI kernel clock source selection This bit is used to select the DSI kernel clock source. This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. Note: If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART6SEL = (2 << 16);  ///< USART6 kernel clock source selection These bits are used to select the USART6 kernel clock source. The USART6 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t LTDCSEL = (1U << 18);  ///< LTDC kernel clock source selection This bit is used to select the LTDC kernel clock source. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPISEL = (2 << 20);  ///< OCTOSPI1 and OCTOSPI2 kernel clock source selection These bits are used to select the OCTOSPI1 and OCTOSPI2 kernel clock source.
        constexpr uint32_t HSPI1SEL = (2 << 22);  ///< HSPI1 kernel clock source selection These bits are used to select the HSPI1 kernel clock source. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t I2C5SEL = (2 << 24);  ///< I2C5 kernel clock source selection These bits are used to select the I2C5 kernel clock source. The I2C5 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16�or MSIK. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t I2C6SEL = (2 << 26);  ///< I2C6 kernel clock source selection These bits are used to select the I2C6 kernel clock source. The I2C6 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16�or MSIK. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t OTGHSSEL = (2 << 30);  ///< OTG_HS PHY kernel clock source selection These bits are used to select the OTG_HS PHY kernel clock source. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
    }

    /// RCC_CCIPR3 Register bits
    namespace rcc_ccipr3_bits {
        constexpr uint32_t LPUART1SEL = (3 << 0);  ///< LPUART1 kernel clock source selection These bits are used to select the LPUART1 kernel clock source. others: reserved Note: The LPUART1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16, LSE, or MSIK.
        constexpr uint32_t SPI3SEL = (2 << 3);  ///< SPI3 kernel clock source selection These bits are used to select the SPI3 kernel clock source. Note: The SPI3 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t I2C3SEL = (2 << 6);  ///< I2C3 kernel clock source selection These bits are used to select the I2C3 kernel clock source. Note: The I2C3 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t LPTIM34SEL = (2 << 8);  ///< LPTIM3 and LPTIM4 kernel clock source selection These bits are used to select the LPTIM3 and LPTIM4 kernel clock source. Note: The LPTIM3 and LPTIM4 are functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1, or MSIK with MSIKERON�=�1.
        constexpr uint32_t LPTIM1SEL = (2 << 10);  ///< LPTIM1 kernel clock source selection These bits are used to select the LPTIM1 kernel clock source. Note: The LPTIM1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1, or MSIK with MSIKERON = 1.
        constexpr uint32_t ADCDACSEL = (3 << 12);  ///< ADC1, ADC2, ADC4 and DAC1 kernel clock source selection These bits are used to select the ADC1, ADC2, ADC4, and DAC1 kernel clock source. others: reserved Note: The ADC1, ADC2, ADC4, and DAC1 are functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK (only ADC4 and DAC1 are functional in�Stop 2 mode).
        constexpr uint32_t DAC1SEL = (1U << 15);  ///< DAC1 sample-and-hold clock source selection This bit is used to select the DAC1 sample-and-hold clock source.
        constexpr uint32_t ADF1SEL = (3 << 16);  ///< ADF1 kernel clock source selection These bits are used to select the ADF1 kernel clock source. others: reserved Note: The ADF1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is AUDIOCLK or MSIK.
    }

    /// RCC_BDCR Register bits
    namespace rcc_bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable This bit is set and cleared by software.
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready This bit is set and cleared by hardware to indicate when the external 32�kHz oscillator is stable. After LSEON is cleared, this LSERDY bit goes low after six external low-speed oscillator clock cycles.
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass This bit is set and cleared by software to bypass oscillator in debug mode. It can be written only when the external 32�kHz oscillator is disabled (LSEON = 0 and LSERDY = 0).
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability This bitfield is set by software to modulate the drive capability of the LSE oscillator. It can be written only when the external 32 kHz oscillator is disabled (LSEON = 0 and LSERDY = 0). Note: The oscillator is in ‘Xtal mode’ when it is not in bypass mode.
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable This bit is set by software to enable the CSS on LSE. It must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD�=�1). In that case, the software must disable this LSECSSON bit.
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure detection This bit is set by hardware to indicate when a failure is detected by the CCS on the external 32�kHz oscillator (LSE).
        constexpr uint32_t LSESYSEN = (1U << 7);  ///< LSE system clock (LSESYS) enable This bit is set by software to enable always the LSE system clock generated by RCC, which can be used by any peripheral when its source clock is the LSE, or at system level if one of LSCOSEL, MCO, or MSI PLL mode is needed.
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC and TAMP clock source selection This bit is set by software to select the clock source for the RTC and TAMP. Once the RTC and TAMP clock source has been selected, it cannot be changed anymore unless the�backup domain is reset, or unless a failure is detected on LSE (LSECSSD is set). BDRST bit can be used to reset them.
        constexpr uint32_t LSESYSRDY = (1U << 11);  ///< LSE system clock (LSESYS) ready This bit is set and cleared by hardware to indicate when the LSE system clock is stable.When LSESYSEN is set, this LSESYSRDY flag is set after two LSE clock cycles. The LSE clock must be already enabled and stable (LSEON and LSERDY are set). When the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.
        constexpr uint32_t LSEGFON = (1U << 12);  ///< LSE clock glitch filter enable This bit is set and cleared by hardware to enable the LSE glitch filter. It can be written only when the LSE is disabled (LSEON = 0 and LSERDY = 0).
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC and TAMP clock enable This bit is set and cleared by software.
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset This bit is set and cleared by software.
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable This bit is set and cleared by software.
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection This bit is set and cleared by software.
        constexpr uint32_t LSION = (1U << 26);  ///< LSI oscillator enable This bit is set and cleared by software. The LSI oscillator is disabled 60��s maximum after the LSION bit is cleared.
        constexpr uint32_t LSIRDY = (1U << 27);  ///< LSI oscillator ready This bit is set and cleared by hardware to indicate when the LSI oscillator is stable. After�LSION is cleared, LSIRDY goes low after three internal low-speed oscillator clock cycles. This bit is set when the LSI is used by IWDG or RTC, even if LSION = 0.
        constexpr uint32_t LSIPREDIV = (1U << 28);  ///< Low-speed clock divider configuration This bit is set and cleared by software to enable the LSI division. It can be written only when the LSI is disabled (LSION = 0 and LSIRDY = 0). If the LSI was previously enabled, it is necessary to wait for at least 60 μs after clearing LSION bit (synchronization time for LSI to be really disabled), before writing LSIPREDIV. The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC.
    }

    /// RCC_CSR Register bits
    namespace rcc_csr_bits {
        constexpr uint32_t MSIKSRANGE = (4 << 8);  ///< MSIK range after Standby mode This bit is set by software to chose the MSIK frequency at startup. It is used after exiting Standby mode until MSIRGSEL is set. After a NRST pin or a power-on reset or when exiting Shutdown mode, the range is always 4�MHz. MSIKSRANGE can be written only when MSIRGSEL = 1. others: reserved Note: Changing this bitfield does not change the current MSIK frequency.
        constexpr uint32_t MSISSRANGE = (4 << 12);  ///< MSIS range after Standby mode This bitfield is set by software to chose the MSIS frequency at startup. It is used after exiting Standby mode until MSIRGSEL is set. After a NRST pin or a power-on reset or when exiting Shutdown mode, the range is always 4�MHz. MSISSRANGE can be written only when MSIRGSEL = 1. others: reserved Note: Changing this bitfield does not change the current MSIS frequency.
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flag This bit is set by software to clear the reset flags.
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option-byte loader reset flag This bit is set by hardware when a reset from the option-byte loading occurs. It is cleared by�writing to the RMVF bit.
        constexpr uint32_t PINRSTF = (1U << 26);  ///< NRST pin reset flag This bit is set by hardware when a reset from the NRST pin occurs. It is cleared by writing to�the RMVF bit.
        constexpr uint32_t BORRSTF = (1U << 27);  ///< Brownout reset or an exit from Shutdown mode reset flag This bit is set by hardware when a brownout reset or an exit from Shutdown mode reset occurs. It is cleared by writing to the RMVF bit.
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag This bit is set by hardware when a software reset occurs. It is cleared by writing to RMVF.
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent watchdog reset flag This bit is set by hardware when an independent watchdog reset domain occurs. It is cleared by writing to the RMVF bit.
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag This bit is set by hardware when a window watchdog reset occurs. It is cleared by writing to�the RMVF bit.
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag This bit is set by hardware when a reset occurs due to a Stop, Standby, or Shutdown mode entry, whereas the corresponding NRST_STOP, NRST_STBY, or NRST_SHDW option bit is cleared. This bit is cleared by writing to the RMVF bit.
    }

    /// RCC_SECCFGR Register bits
    namespace rcc_seccfgr_bits {
        constexpr uint32_t HSISEC = (1U << 0);  ///< HSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t HSESEC = (1U << 1);  ///< HSE clock configuration bits, status bit and HSE_CSS security This bit is set and reset by software.
        constexpr uint32_t MSISEC = (1U << 2);  ///< MSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t LSISEC = (1U << 3);  ///< LSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t LSESEC = (1U << 4);  ///< LSE clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t SYSCLKSEC = (1U << 5);  ///< SYSCLK clock selection, STOPWUCK bit, clock output on MCO configuration security This bit is set and reset by software.
        constexpr uint32_t PRESCSEC = (1U << 6);  ///< AHBx/APBx prescaler configuration bits security This bit is set and reset by software.
        constexpr uint32_t PLL1SEC = (1U << 7);  ///< PLL1 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t PLL2SEC = (1U << 8);  ///< PLL2 clock configuration and status bit security Set and reset by software.
        constexpr uint32_t PLL3SEC = (1U << 9);  ///< PLL3 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t ICLKSEC = (1U << 10);  ///< Intermediate clock source selection security This bit is set and reset by software.
        constexpr uint32_t HSI48SEC = (1U << 11);  ///< HSI48 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t RMVFSEC = (1U << 12);  ///< Remove reset flag security This bit is set and reset by software.
    }

    /// RCC_PRIVCFGR Register bits
    namespace rcc_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< RCC secure function privilege configuration This bit is set and reset by software. It can be written only by a secure privileged access.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< RCC non-secure function privilege configuration This bit is set and reset by software. It can be written only by privileged access, secure or non-secure.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x420C0800;
    constexpr uint32_t SEC_RNG_BASE = 0x520C0800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DR;  ///< Offset: 0x08 - data register
        volatile uint32_t HTCR;  ///< Offset: 0x10 - health test control register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);
    inline Registers* SEC_RNG = reinterpret_cast<Registers*>(SEC_RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CONFIGLOCK = (1U << 31);  ///< RNG Config Lock
        constexpr uint32_t CONDRST = (1U << 30);  ///< Conditioning soft reset
        constexpr uint32_t RNG_CONFIG1 = (6 << 20);  ///< RNG configuration 1
        constexpr uint32_t CLKDIV = (4 << 16);  ///< Clock divider factor
        constexpr uint32_t RNG_CONFIG2 = (3 << 13);  ///< RNG configuration 2
        constexpr uint32_t NISTC = (1U << 12);  ///< Non NIST compliant
        constexpr uint32_t RNG_CONFIG3 = (4 << 8);  ///< RNG configuration 3
        constexpr uint32_t ARDIS = (1U << 7);  ///< Auto reset disable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt Enable
        constexpr uint32_t RNGEN = (1U << 2);  ///< True random number generator enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data
    }

    /// HTCR Register bits
    namespace htcr_bits {
        constexpr uint32_t HTCFG = (32 << 0);  ///< health test configuration
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x46007800;
    constexpr uint32_t SEC_RTC_BASE = 0x56007800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - RTC control register
        volatile uint32_t PRIVCR;  ///< Offset: 0x1C - RTC privilege mode control register
        volatile uint32_t SECCFGR;  ///< Offset: 0x20 - RTC secure mode control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - RTC non-secure masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x58 - RTC secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - RTC status clear register
        volatile uint32_t ALRABINR;  ///< Offset: 0x70 - RTC alarm A binary mode register
        volatile uint32_t ALRBBINR;  ///< Offset: 0x74 - RTC alarm B binary mode register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);
    inline Registers* SEC_RTC = reinterpret_cast<Registers*>(SEC_RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< SS
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t BIN = (2 << 8);  ///< BIN
        constexpr uint32_t BCDU = (3 << 10);  ///< BCDU
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
        constexpr uint32_t WUTOCLR = (16 << 16);  ///< WUTOCLR
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< WUCKSEL
        constexpr uint32_t TSEDGE = (1U << 3);  ///< TSEDGE
        constexpr uint32_t REFCKON = (1U << 4);  ///< REFCKON
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< BYPSHAD
        constexpr uint32_t FMT = (1U << 6);  ///< FMT
        constexpr uint32_t SSRUIE = (1U << 7);  ///< SSRUIE
        constexpr uint32_t ALRAE = (1U << 8);  ///< ALRAE
        constexpr uint32_t ALRBE = (1U << 9);  ///< ALRBE
        constexpr uint32_t WUTE = (1U << 10);  ///< WUTE
        constexpr uint32_t TSE = (1U << 11);  ///< TSE
        constexpr uint32_t ALRAIE = (1U << 12);  ///< ALRAIE
        constexpr uint32_t ALRBIE = (1U << 13);  ///< ALRBIE
        constexpr uint32_t WUTIE = (1U << 14);  ///< WUTIE
        constexpr uint32_t TSIE = (1U << 15);  ///< TSIE
        constexpr uint32_t ADD1H = (1U << 16);  ///< ADD1H
        constexpr uint32_t SUB1H = (1U << 17);  ///< SUB1H
        constexpr uint32_t BKP = (1U << 18);  ///< BKP
        constexpr uint32_t COSEL = (1U << 19);  ///< COSEL
        constexpr uint32_t POL = (1U << 20);  ///< POL
        constexpr uint32_t OSEL = (2 << 21);  ///< OSEL
        constexpr uint32_t COE = (1U << 23);  ///< COE
        constexpr uint32_t ITSE = (1U << 24);  ///< ITSE
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t ALRAFCLR = (1U << 27);  ///< ALRAFCLR
        constexpr uint32_t ALRBFCLR = (1U << 28);  ///< ALRBFCLR
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t PRIV = (1U << 15);  ///< PRIV
        constexpr uint32_t INITPRIV = (1U << 14);  ///< INITPRIV
        constexpr uint32_t CALPRIV = (1U << 13);  ///< CALPRIV
        constexpr uint32_t TSPRIV = (1U << 3);  ///< TSPRIV
        constexpr uint32_t WUTPRIV = (1U << 2);  ///< WUTPRIV
        constexpr uint32_t ALRBPRIV = (1U << 1);  ///< ALRBPRIV
        constexpr uint32_t ALRAPRIV = (1U << 0);  ///< ALRAPRIV
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SEC = (1U << 15);  ///< SEC
        constexpr uint32_t INITSEC = (1U << 14);  ///< INITSEC
        constexpr uint32_t CALSEC = (1U << 13);  ///< CALSEC
        constexpr uint32_t TSSEC = (1U << 3);  ///< TSSEC
        constexpr uint32_t WUTSEC = (1U << 2);  ///< WUTSEC
        constexpr uint32_t ALRBSEC = (1U << 1);  ///< ALRBSEC
        constexpr uint32_t ALRASEC = (1U << 0);  ///< ALRASEC
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t LPCAL = (1U << 12);  ///< LPCAL
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t SSCLR = (1U << 31);  ///< SSCLR
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t SSCLR = (1U << 31);  ///< SSCLR
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
        constexpr uint32_t SSRUF = (1U << 6);  ///< SSRUF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSRUMF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSRUMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
        constexpr uint32_t CSSRUF = (1U << 6);  ///< CSSRUF
    }

    /// ALRABINR Register bits
    namespace alrabinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode
    }

    /// ALRBBINR Register bits
    namespace alrbbinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40015400;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - Global configuration register
        volatile uint32_t ACR1;  ///< Offset: 0x04 - A Configuration register 1
        volatile uint32_t BCR1;  ///< Offset: 0x24 - B Configuration register 1
        volatile uint32_t ACR2;  ///< Offset: 0x08 - A Configuration register 2
        volatile uint32_t BCR2;  ///< Offset: 0x28 - B Configuration register 2
        volatile uint32_t AFRCR;  ///< Offset: 0x0C - A frame configuration register
        volatile uint32_t BFRCR;  ///< Offset: 0x2C - B frame configuration register
        volatile uint32_t ASLOTR;  ///< Offset: 0x10 - A Slot register
        volatile uint32_t BSLOTR;  ///< Offset: 0x30 - B Slot register
        volatile uint32_t AIM;  ///< Offset: 0x14 - A Interrupt mask register
        volatile uint32_t BIM;  ///< Offset: 0x34 - B Interrupt mask register
        volatile uint32_t ASR;  ///< Offset: 0x18 - A Status register
        volatile uint32_t BSR;  ///< Offset: 0x38 - B Status register
        volatile uint32_t ACLRFR;  ///< Offset: 0x1C - A Clear flag register
        volatile uint32_t BCLRFR;  ///< Offset: 0x3C - B Clear flag register
        volatile uint32_t ADR;  ///< Offset: 0x20 - A Data register
        volatile uint32_t BDR;  ///< Offset: 0x40 - B Data register
        volatile uint32_t PDMCR;  ///< Offset: 0x44 - PDM control register
        volatile uint32_t PDMDLY;  ///< Offset: 0x48 - PDM delay register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t SYNCIN = (2 << 0);  ///< Synchronization inputs
        constexpr uint32_t SYNCOUT = (2 << 4);  ///< Synchronization outputs
    }

    /// ACR1 Register bits
    namespace acr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCKDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCKDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// ACR2 Register bits
    namespace acr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// AFRCR Register bits
    namespace afrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// BFRCR Register bits
    namespace bfrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// ASLOTR Register bits
    namespace aslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// BSLOTR Register bits
    namespace bslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// AIM Register bits
    namespace aim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// BIM Register bits
    namespace bim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// ASR Register bits
    namespace asr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// ACLRFR Register bits
    namespace aclrfr_bits {
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// BCLRFR Register bits
    namespace bclrfr_bits {
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// ADR Register bits
    namespace adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// BDR Register bits
    namespace bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// PDMCR Register bits
    namespace pdmcr_bits {
        constexpr uint32_t PDMEN = (1U << 0);  ///< PDM enable
        constexpr uint32_t MICNBR = (2 << 4);  ///< MICNBR
        constexpr uint32_t CKEN1 = (1U << 8);  ///< Clock enable of bitstream clock number 1
        constexpr uint32_t CKEN2 = (1U << 9);  ///< CKEN2
        constexpr uint32_t CKEN3 = (1U << 10);  ///< CKEN3
        constexpr uint32_t CKEN4 = (1U << 11);  ///< CKEN4
    }

    /// PDMDLY Register bits
    namespace pdmdly_bits {
        constexpr uint32_t DLYM1L = (3 << 0);  ///< Delay line adjust for first microphone of pair 1
        constexpr uint32_t DLYM1R = (3 << 4);  ///< Delay line adjust for second microphone of pair 1
        constexpr uint32_t DLYM2L = (3 << 8);  ///< Delay line for first microphone of pair 2
        constexpr uint32_t DLYM2R = (3 << 12);  ///< Delay line for second microphone of pair 2
        constexpr uint32_t DLYM3L = (3 << 16);  ///< DLYM3L
        constexpr uint32_t DLYM3R = (3 << 20);  ///< DLYM3R
        constexpr uint32_t DLYM4L = (3 << 24);  ///< DLYM4L
        constexpr uint32_t DLYM4R = (3 << 28);  ///< DLYM4R
    }

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_BASE = 0x420C8000;
    constexpr uint32_t SEC_SDMMC_BASE = 0x520C8000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t POWER;  ///< Offset: 0x00 - power control register
        volatile uint32_t CLKCR;  ///< Offset: 0x04 - clock control register
        volatile uint32_t ARGR;  ///< Offset: 0x08 - argument register
        volatile uint32_t CMDR;  ///< Offset: 0x0C - command register
        volatile uint32_t RESPCMDR;  ///< Offset: 0x10 - command response register
        volatile uint32_t RESP1;  ///< Offset: 0x14 - response 1 register
        volatile uint32_t RESP2;  ///< Offset: 0x18 - response 2 register
        volatile uint32_t RESP3;  ///< Offset: 0x1C - response 3 register
        volatile uint32_t RESP4;  ///< Offset: 0x20 - response 4 register
        volatile uint32_t DTIMER;  ///< Offset: 0x24 - data timer register
        volatile uint32_t DLENR;  ///< Offset: 0x28 - data length register
        volatile uint32_t DCTRL;  ///< Offset: 0x2C - data control register
        volatile uint32_t DCNTR;  ///< Offset: 0x30 - data counter register
        volatile uint32_t STAR;  ///< Offset: 0x34 - status register
        volatile uint32_t ICR;  ///< Offset: 0x38 - interrupt clear register
        volatile uint32_t MASKR;  ///< Offset: 0x3C - mask register
        volatile uint32_t ACKTIMER;  ///< Offset: 0x40 - acknowledgment timer register
        volatile uint32_t FIFOR0;  ///< Offset: 0x80 - data FIFO register 0
        volatile uint32_t FIFOR1;  ///< Offset: 0x84 - data FIFO register 1
        volatile uint32_t FIFOR2;  ///< Offset: 0x88 - data FIFO register 2
        volatile uint32_t FIFOR3;  ///< Offset: 0x8C - data FIFO register 3
        volatile uint32_t FIFOR4;  ///< Offset: 0x90 - data FIFO register 4
        volatile uint32_t FIFOR5;  ///< Offset: 0x94 - data FIFO register 5
        volatile uint32_t FIFOR6;  ///< Offset: 0x98 - data FIFO register 6
        volatile uint32_t FIFOR7;  ///< Offset: 0x9C - data FIFO register 7
        volatile uint32_t FIFOR8;  ///< Offset: 0xA0 - data FIFO register 8
        volatile uint32_t FIFOR9;  ///< Offset: 0xA4 - data FIFO register 9
        volatile uint32_t FIFOR10;  ///< Offset: 0xA8 - data FIFO register 10
        volatile uint32_t FIFOR11;  ///< Offset: 0xAC - data FIFO register 11
        volatile uint32_t FIFOR12;  ///< Offset: 0xB0 - data FIFO register 12
        volatile uint32_t FIFOR13;  ///< Offset: 0xB4 - data FIFO register 13
        volatile uint32_t FIFOR14;  ///< Offset: 0xB8 - data FIFO register 14
        volatile uint32_t FIFOR15;  ///< Offset: 0xBC - data FIFO register 15
        volatile uint32_t SDMMC_IDMACTRLR;  ///< Offset: 0x50 - DMA control register
        volatile uint32_t SDMMC_IDMABSIZER;  ///< Offset: 0x54 - buffer size register
        volatile uint32_t SDMMC_IDMABASER;  ///< Offset: 0x58 - buffer base address register
        volatile uint32_t SDMMC_IDMALAR;  ///< Offset: 0x64 - linked list address register
        volatile uint32_t SDMMC_IDMABAR;  ///< Offset: 0x68 - linked list memory base register
    };

    /// Peripheral instances
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);
    inline Registers* SEC_SDMMC = reinterpret_cast<Registers*>(SEC_SDMMC_BASE);

    // Bit definitions
    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t PWRCTRL = (2 << 0);  ///< SDMMC state control bits
        constexpr uint32_t VSWITCH = (1U << 2);  ///< Voltage switch sequence start
        constexpr uint32_t VSWITCHEN = (1U << 3);  ///< Voltage switch procedure enable
        constexpr uint32_t DIRPOL = (1U << 4);  ///< Data and command direction signals polarity selection
    }

    /// CLKCR Register bits
    namespace clkcr_bits {
        constexpr uint32_t SELCLKRX = (2 << 20);  ///< Receive clock selection
        constexpr uint32_t BUSSPEED = (1U << 19);  ///< Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50,DDR50, SDR104
        constexpr uint32_t DDR = (1U << 18);  ///< Data rate signaling selection
        constexpr uint32_t HWFC_EN = (1U << 17);  ///< HW Flow Control enable
        constexpr uint32_t NEGEDGE = (1U << 16);  ///< SDIO_CK dephasing selection bit
        constexpr uint32_t WIDBUS = (2 << 14);  ///< Wide bus mode enable bit
        constexpr uint32_t PWRSAV = (1U << 12);  ///< Power saving configuration bit
        constexpr uint32_t CLKDIV = (10 << 0);  ///< Clock divide factor
    }

    /// ARGR Register bits
    namespace argr_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command argument
    }

    /// CMDR Register bits
    namespace cmdr_bits {
        constexpr uint32_t CMDSUSPEND = (1U << 16);  ///< The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end
        constexpr uint32_t BOOTEN = (1U << 15);  ///< Enable boot mode procedure
        constexpr uint32_t BOOTMODE = (1U << 14);  ///< Select the boot mode procedure to be used
        constexpr uint32_t DTHOLD = (1U << 13);  ///< Hold new data block transmission and reception in the DPSM
        constexpr uint32_t CPSMEN = (1U << 12);  ///< Command path state machine (CPSM) Enable bit
        constexpr uint32_t WAITPEND = (1U << 11);  ///< CPSM Waits for ends of data transfer (CmdPend internal signal) from DPSM
        constexpr uint32_t WAITINT = (1U << 10);  ///< CPSM waits for interrupt request
        constexpr uint32_t WAITRESP = (2 << 8);  ///< Wait for response bits
        constexpr uint32_t CMDSTOP = (1U << 7);  ///< The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM
        constexpr uint32_t CMDTRANS = (1U << 6);  ///< The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM
        constexpr uint32_t CMDINDEX = (6 << 0);  ///< Command index
    }

    /// RESPCMDR Register bits
    namespace respcmdr_bits {
        constexpr uint32_t RESPCMD = (6 << 0);  ///< Response command index
    }

    /// RESP1 Register bits
    namespace resp1_bits {
        constexpr uint32_t CARDSTATUS1 = (32 << 0);  ///< CARDSTATUS1
    }

    /// RESP2 Register bits
    namespace resp2_bits {
        constexpr uint32_t CARDSTATUS2 = (32 << 0);  ///< CARDSTATUS2
    }

    /// RESP3 Register bits
    namespace resp3_bits {
        constexpr uint32_t CARDSTATUS3 = (32 << 0);  ///< CARDSTATUS3
    }

    /// RESP4 Register bits
    namespace resp4_bits {
        constexpr uint32_t CARDSTATUS4 = (32 << 0);  ///< CARDSTATUS4
    }

    /// DTIMER Register bits
    namespace dtimer_bits {
        constexpr uint32_t DATATIME = (32 << 0);  ///< Data and R1b busy timeout period
    }

    /// DLENR Register bits
    namespace dlenr_bits {
        constexpr uint32_t DATALENGTH = (25 << 0);  ///< Data length value
    }

    /// DCTRL Register bits
    namespace dctrl_bits {
        constexpr uint32_t FIFORST = (1U << 13);  ///< FIFO reset, will flush any remaining data
        constexpr uint32_t BOOTACKEN = (1U << 12);  ///< Enable the reception of the boot acknowledgment
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SD I/O enable functions
        constexpr uint32_t RWMOD = (1U << 10);  ///< Read wait mode
        constexpr uint32_t RWSTOP = (1U << 9);  ///< Read wait stop
        constexpr uint32_t RWSTART = (1U << 8);  ///< Read wait start
        constexpr uint32_t DBLOCKSIZE = (4 << 4);  ///< Data block size
        constexpr uint32_t DTMODE = (2 << 2);  ///< Data transfer mode selection
        constexpr uint32_t DTDIR = (1U << 1);  ///< Data transfer direction selection
        constexpr uint32_t DTEN = (1U << 0);  ///< DTEN
    }

    /// DCNTR Register bits
    namespace dcntr_bits {
        constexpr uint32_t DATACOUNT = (25 << 0);  ///< Data count value
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t IDMABTC = (1U << 28);  ///< IDMA buffer transfer complete
        constexpr uint32_t IDMATE = (1U << 27);  ///< IDMA transfer error
        constexpr uint32_t CKSTOP = (1U << 26);  ///< SDMMC_CK stopped in Voltage switch procedure
        constexpr uint32_t VSWEND = (1U << 25);  ///< Voltage switch critical timing section completion
        constexpr uint32_t ACKTIMEOUT = (1U << 24);  ///< Boot acknowledgment timeout
        constexpr uint32_t ACKFAIL = (1U << 23);  ///< Boot acknowledgment received (boot acknowledgment check fail)
        constexpr uint32_t SDIOIT = (1U << 22);  ///< SDIO interrupt received
        constexpr uint32_t BUSYD0END = (1U << 21);  ///< end of SDMMC_D0 Busy following a CMD response detected
        constexpr uint32_t BUSYD0 = (1U << 20);  ///< Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response
        constexpr uint32_t RXFIFOE = (1U << 19);  ///< Receive FIFO empty
        constexpr uint32_t TXFIFOE = (1U << 18);  ///< Transmit FIFO empty
        constexpr uint32_t RXFIFOF = (1U << 17);  ///< Receive FIFO full
        constexpr uint32_t TXFIFOF = (1U << 16);  ///< Transmit FIFO full
        constexpr uint32_t RXFIFOHF = (1U << 15);  ///< Receive FIFO half full
        constexpr uint32_t TXFIFOHE = (1U << 14);  ///< Transmit FIFO half empty
        constexpr uint32_t CPSMACT = (1U << 13);  ///< Command path state machine active, i.e. not in Idle state
        constexpr uint32_t DPSMACT = (1U << 12);  ///< Data path state machine active, i.e. not in Idle state
        constexpr uint32_t DABORT = (1U << 11);  ///< Data transfer aborted by CMD12
        constexpr uint32_t DBCKEND = (1U << 10);  ///< Data block sent/received
        constexpr uint32_t DHOLD = (1U << 9);  ///< Data transfer Hold
        constexpr uint32_t DATAEND = (1U << 8);  ///< Data transfer ended correctly
        constexpr uint32_t CMDSENT = (1U << 7);  ///< Command sent (no response required)
        constexpr uint32_t CMDREND = (1U << 6);  ///< Command response received (CRC check passed, or no CRC)
        constexpr uint32_t RXOVERR = (1U << 5);  ///< Received FIFO overrun error (masked by hardware when IDMA is enabled)
        constexpr uint32_t TXUNDERR = (1U << 4);  ///< Transmit FIFO underrun error (masked by hardware when IDMA is enabled)
        constexpr uint32_t DTIMEOUT = (1U << 3);  ///< Data timeout
        constexpr uint32_t CTIMEOUT = (1U << 2);  ///< Command response timeout
        constexpr uint32_t DCRCFAIL = (1U << 1);  ///< Data block sent/received (CRC check failed)
        constexpr uint32_t CCRCFAIL = (1U << 0);  ///< Command response received (CRC check failed)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t IDMABTCC = (1U << 28);  ///< IDMA buffer transfer complete clear bit
        constexpr uint32_t IDMATEC = (1U << 27);  ///< IDMA transfer error clear bit
        constexpr uint32_t CKSTOPC = (1U << 26);  ///< CKSTOP flag clear bit
        constexpr uint32_t VSWENDC = (1U << 25);  ///< VSWEND flag clear bit
        constexpr uint32_t ACKTIMEOUTC = (1U << 24);  ///< ACKTIMEOUT flag clear bit
        constexpr uint32_t ACKFAILC = (1U << 23);  ///< ACKFAIL flag clear bit
        constexpr uint32_t SDIOITC = (1U << 22);  ///< SDIOIT flag clear bit
        constexpr uint32_t BUSYD0ENDC = (1U << 21);  ///< BUSYD0END flag clear bit
        constexpr uint32_t DABORTC = (1U << 11);  ///< DABORT flag clear bit
        constexpr uint32_t DBCKENDC = (1U << 10);  ///< DBCKEND flag clear bit
        constexpr uint32_t DHOLDC = (1U << 9);  ///< DHOLD flag clear bit
        constexpr uint32_t DATAENDC = (1U << 8);  ///< DATAEND flag clear bit
        constexpr uint32_t CMDSENTC = (1U << 7);  ///< CMDSENT flag clear bit
        constexpr uint32_t CMDRENDC = (1U << 6);  ///< CMDREND flag clear bit
        constexpr uint32_t RXOVERRC = (1U << 5);  ///< RXOVERR flag clear bit
        constexpr uint32_t TXUNDERRC = (1U << 4);  ///< TXUNDERR flag clear bit
        constexpr uint32_t DTIMEOUTC = (1U << 3);  ///< DTIMEOUT flag clear bit
        constexpr uint32_t CTIMEOUTC = (1U << 2);  ///< CTIMEOUT flag clear bit
        constexpr uint32_t DCRCFAILC = (1U << 1);  ///< DCRCFAIL flag clear bit
        constexpr uint32_t CCRCFAILC = (1U << 0);  ///< CCRCFAIL flag clear bit
    }

    /// MASKR Register bits
    namespace maskr_bits {
        constexpr uint32_t IDMABTCIE = (1U << 28);  ///< IDMA buffer transfer complete interrupt enable
        constexpr uint32_t CKSTOPIE = (1U << 26);  ///< Voltage Switch clock stopped interrupt enable
        constexpr uint32_t VSWENDIE = (1U << 25);  ///< Voltage switch critical timing section completion interrupt enable
        constexpr uint32_t ACKTIMEOUTIE = (1U << 24);  ///< Acknowledgment timeout interrupt enable
        constexpr uint32_t ACKFAILIE = (1U << 23);  ///< Acknowledgment Fail interrupt enable
        constexpr uint32_t SDIOITIE = (1U << 22);  ///< SDIO mode interrupt received interrupt enable
        constexpr uint32_t BUSYD0ENDIE = (1U << 21);  ///< BUSYD0END interrupt enable
        constexpr uint32_t TXFIFOEIE = (1U << 18);  ///< Tx FIFO empty interrupt enable
        constexpr uint32_t RXFIFOFIE = (1U << 17);  ///< Rx FIFO full interrupt enable
        constexpr uint32_t RXFIFOHFIE = (1U << 15);  ///< Rx FIFO half full interrupt enable
        constexpr uint32_t TXFIFOHEIE = (1U << 14);  ///< Tx FIFO half empty interrupt enable
        constexpr uint32_t DABORTIE = (1U << 11);  ///< Data transfer aborted interrupt enable
        constexpr uint32_t DBCKENDIE = (1U << 10);  ///< Data block end interrupt enable
        constexpr uint32_t DHOLDIE = (1U << 9);  ///< Data hold interrupt enable
        constexpr uint32_t DATAENDIE = (1U << 8);  ///< Data end interrupt enable
        constexpr uint32_t CMDSENTIE = (1U << 7);  ///< Command sent interrupt enable
        constexpr uint32_t CMDRENDIE = (1U << 6);  ///< Command response received interrupt enable
        constexpr uint32_t RXOVERRIE = (1U << 5);  ///< Rx FIFO overrun error interrupt enable
        constexpr uint32_t TXUNDERRIE = (1U << 4);  ///< Tx FIFO underrun error interrupt enable
        constexpr uint32_t DTIMEOUTIE = (1U << 3);  ///< Data timeout interrupt enable
        constexpr uint32_t CTIMEOUTIE = (1U << 2);  ///< Command timeout interrupt enable
        constexpr uint32_t DCRCFAILIE = (1U << 1);  ///< Data CRC fail interrupt enable
        constexpr uint32_t CCRCFAILIE = (1U << 0);  ///< Command CRC fail interrupt enable
    }

    /// ACKTIMER Register bits
    namespace acktimer_bits {
        constexpr uint32_t ACKTIME = (25 << 0);  ///< Boot acknowledgment timeout period
    }

    /// FIFOR0 Register bits
    namespace fifor0_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR1 Register bits
    namespace fifor1_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR2 Register bits
    namespace fifor2_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR3 Register bits
    namespace fifor3_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR4 Register bits
    namespace fifor4_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR5 Register bits
    namespace fifor5_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR6 Register bits
    namespace fifor6_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR7 Register bits
    namespace fifor7_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR8 Register bits
    namespace fifor8_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR9 Register bits
    namespace fifor9_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR10 Register bits
    namespace fifor10_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR11 Register bits
    namespace fifor11_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR12 Register bits
    namespace fifor12_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR13 Register bits
    namespace fifor13_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR14 Register bits
    namespace fifor14_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR15 Register bits
    namespace fifor15_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// SDMMC_IDMACTRLR Register bits
    namespace sdmmc_idmactrlr_bits {
        constexpr uint32_t IDMAEN = (1U << 0);  ///< IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABMODE = (1U << 1);  ///< Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    }

    /// SDMMC_IDMABSIZER Register bits
    namespace sdmmc_idmabsizer_bits {
        constexpr uint32_t IDMABNDT = (12 << 5);  ///< Number of bytes per buffer
    }

    /// SDMMC_IDMABASER Register bits
    namespace sdmmc_idmabaser_bits {
        constexpr uint32_t IDMABASE = (32 << 0);  ///< Buffer memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only)
    }

    /// SDMMC_IDMALAR Register bits
    namespace sdmmc_idmalar_bits {
        constexpr uint32_t ULA = (1U << 31);  ///< Update SDMMC_IDMALAR from linked list when in linked list mode (SDMMC_IDMACTRLR.IDMABMODE select linked list mode)
        constexpr uint32_t ULS = (1U << 30);  ///< Update SDMMC_IDMABSIZE from the next linked list when in linked list mode (SDMMC_IDMACTRLR.IDMABMODE select linked list mode and ULA = 1)
        constexpr uint32_t ABR = (1U << 29);  ///< Acknowledge linked list buffer ready
        constexpr uint32_t IDMALA = (14 << 2);  ///< Acknowledge linked list buffer ready
    }

    /// SDMMC_IDMABAR Register bits
    namespace sdmmc_idmabar_bits {
        constexpr uint32_t IDMABA = (30 << 2);  ///< Word aligned Linked list memory base address
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x46000400;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t SECCFGR;  ///< Offset: 0x00 - SYSCFG secure configuration register
        volatile uint32_t CFGR1;  ///< Offset: 0x04 - configuration register 1
        volatile uint32_t FPUIMR;  ///< Offset: 0x08 - FPU interrupt mask register
        volatile uint32_t CNSLCKR;  ///< Offset: 0x0C - SYSCFG CPU non-secure lock register
        volatile uint32_t CSLOCKR;  ///< Offset: 0x10 - SYSCFG CPU secure lock register
        volatile uint32_t CFGR2;  ///< Offset: 0x14 - configuration register 2
        volatile uint32_t MESR;  ///< Offset: 0x18 - memory erase status register
        volatile uint32_t CCCSR;  ///< Offset: 0x1C - compensation cell control/status register
        volatile uint32_t CCVR;  ///< Offset: 0x20 - compensation cell value register
        volatile uint32_t CCCR;  ///< Offset: 0x24 - compensation cell code register
        volatile uint32_t RSSCMDR;  ///< Offset: 0x2C - RSS command register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SYSCFGSEC = (1U << 0);  ///< SYSCFG clock control security
        constexpr uint32_t CLASSBSEC = (1U << 1);  ///< CLASSBSEC
        constexpr uint32_t FPUSEC = (1U << 3);  ///< FPUSEC
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t ENDCAP = (2 << 24);  ///< ENDCAP
        constexpr uint32_t PB9_FMP = (1U << 19);  ///< PB9_FMP
        constexpr uint32_t PB8_FMP = (1U << 18);  ///< PB8_FMP
        constexpr uint32_t PB7_FMP = (1U << 17);  ///< PB7_FMP
        constexpr uint32_t PB6_FMP = (1U << 16);  ///< PB6_FMP
        constexpr uint32_t ANASWVDD = (1U << 9);  ///< GPIO analog switch control voltage selection
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
    }

    /// FPUIMR Register bits
    namespace fpuimr_bits {
        constexpr uint32_t FPU_IE = (6 << 0);  ///< Floating point unit interrupts enable bits
    }

    /// CNSLCKR Register bits
    namespace cnslckr_bits {
        constexpr uint32_t LOCKNSVTOR = (1U << 0);  ///< VTOR_NS register lock
        constexpr uint32_t LOCKNSMPU = (1U << 1);  ///< Non-secure MPU registers lock
    }

    /// CSLOCKR Register bits
    namespace cslockr_bits {
        constexpr uint32_t LOCKSVTAIRCR = (1U << 0);  ///< LOCKSVTAIRCR
        constexpr uint32_t LOCKSMPU = (1U << 1);  ///< LOCKSMPU
        constexpr uint32_t LOCKSAU = (1U << 2);  ///< LOCKSAU
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t ECCL = (1U << 3);  ///< ECC Lock
        constexpr uint32_t PVDL = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t SPL = (1U << 1);  ///< SRAM ECC lock bit
        constexpr uint32_t CLL = (1U << 0);  ///< LOCKUP (hardfault) output enable bit
    }

    /// MESR Register bits
    namespace mesr_bits {
        constexpr uint32_t IPMEE = (1U << 16);  ///< IPMEE
        constexpr uint32_t MCLR = (1U << 0);  ///< MCLR
    }

    /// CCCSR Register bits
    namespace cccsr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< EN1
        constexpr uint32_t CS1 = (1U << 1);  ///< CS1
        constexpr uint32_t EN2 = (1U << 2);  ///< EN2
        constexpr uint32_t CS2 = (1U << 3);  ///< CS2
        constexpr uint32_t EN3 = (1U << 4);  ///< EN3
        constexpr uint32_t CS3 = (1U << 5);  ///< CS3
        constexpr uint32_t RDY1 = (1U << 8);  ///< RDY1
        constexpr uint32_t RDY2 = (1U << 9);  ///< RDY2
        constexpr uint32_t RDY3 = (1U << 10);  ///< RDY3
    }

    /// CCVR Register bits
    namespace ccvr_bits {
        constexpr uint32_t NCV1 = (4 << 0);  ///< NCV1
        constexpr uint32_t PCV1 = (4 << 4);  ///< PCV1
        constexpr uint32_t NCV2 = (4 << 8);  ///< NCV2
        constexpr uint32_t PCV2 = (4 << 12);  ///< PCV2
        constexpr uint32_t NCV3 = (4 << 16);  ///< NCV3
        constexpr uint32_t PCV3 = (4 << 20);  ///< PCV3
    }

    /// CCCR Register bits
    namespace cccr_bits {
        constexpr uint32_t NCC1 = (4 << 0);  ///< NCC1
        constexpr uint32_t PCC1 = (4 << 4);  ///< PCC1
        constexpr uint32_t NCC2 = (4 << 8);  ///< NCC2
        constexpr uint32_t PCC2 = (4 << 12);  ///< PCC2
        constexpr uint32_t NCC3 = (4 << 16);  ///< NCC3
        constexpr uint32_t PCC3 = (4 << 20);  ///< PCC3
    }

    /// RSSCMDR Register bits
    namespace rsscmdr_bits {
        constexpr uint32_t RSSCMD = (16 << 0);  ///< RSS commands
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x46007C00;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - control register 3
        volatile uint32_t FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t ATCR1;  ///< Offset: 0x10 - TAMP active tamper control register
        volatile uint32_t ATSEEDR;  ///< Offset: 0x14 - TAMP active tamper seed register
        volatile uint32_t ATOR;  ///< Offset: 0x18 - TAMP active tamper output register
        volatile uint32_t ATCR2;  ///< Offset: 0x1C - TAMP active tamper control register 2
        volatile uint32_t SECCFGR;  ///< Offset: 0x20 - TAMP secure mode register
        volatile uint32_t PRIVCR;  ///< Offset: 0x24 - TAMP privilege mode control register
        volatile uint32_t IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x38 - TAMP secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t COUNT1R;  ///< Offset: 0x40 - TAMP monotonic counter 1register
        volatile uint32_t ERCFGR;  ///< Offset: 0x54 - TAMP erase configuration register
        volatile uint32_t BKP0R;  ///< Offset: 0x100 - TAMP backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x104 - TAMP backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x108 - TAMP backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x10C - TAMP backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x110 - TAMP backup register
        volatile uint32_t BKP5R;  ///< Offset: 0x114 - TAMP backup register
        volatile uint32_t BKP6R;  ///< Offset: 0x118 - TAMP backup register
        volatile uint32_t BKP7R;  ///< Offset: 0x11C - TAMP backup register
        volatile uint32_t BKP8R;  ///< Offset: 0x120 - TAMP backup register
        volatile uint32_t BKP9R;  ///< Offset: 0x124 - TAMP backup register
        volatile uint32_t BKP10R;  ///< Offset: 0x128 - TAMP backup register
        volatile uint32_t BKP11R;  ///< Offset: 0x12C - TAMP backup register
        volatile uint32_t BKP12R;  ///< Offset: 0x130 - TAMP backup register
        volatile uint32_t BKP13R;  ///< Offset: 0x134 - TAMP backup register
        volatile uint32_t BKP14R;  ///< Offset: 0x138 - TAMP backup register
        volatile uint32_t BKP15R;  ///< Offset: 0x13C - TAMP backup register
        volatile uint32_t BKP16R;  ///< Offset: 0x140 - TAMP backup register
        volatile uint32_t BKP17R;  ///< Offset: 0x144 - TAMP backup register
        volatile uint32_t BKP18R;  ///< Offset: 0x148 - TAMP backup register
        volatile uint32_t BKP19R;  ///< Offset: 0x14C - TAMP backup register
        volatile uint32_t BKP20R;  ///< Offset: 0x150 - TAMP backup register
        volatile uint32_t BKP21R;  ///< Offset: 0x154 - TAMP backup register
        volatile uint32_t BKP22R;  ///< Offset: 0x158 - TAMP backup register
        volatile uint32_t BKP23R;  ///< Offset: 0x15C - TAMP backup register
        volatile uint32_t BKP24R;  ///< Offset: 0x160 - TAMP backup register
        volatile uint32_t BKP25R;  ///< Offset: 0x164 - TAMP backup register
        volatile uint32_t BKP26R;  ///< Offset: 0x168 - TAMP backup register
        volatile uint32_t BKP27R;  ///< Offset: 0x16C - TAMP backup register
        volatile uint32_t BKP28R;  ///< Offset: 0x170 - TAMP backup register
        volatile uint32_t BKP29R;  ///< Offset: 0x174 - TAMP backup register
        volatile uint32_t BKP30R;  ///< Offset: 0x178 - TAMP backup register
        volatile uint32_t BKP31R;  ///< Offset: 0x17C - TAMP backup register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t ITAMP13E = (1U << 28);  ///< ITAMP13E
        constexpr uint32_t ITAMP12E = (1U << 27);  ///< ITAMP12E
        constexpr uint32_t ITAMP11E = (1U << 26);  ///< TAMP1E
        constexpr uint32_t ITAMP9E = (1U << 24);  ///< ITAMP9E
        constexpr uint32_t ITAMP8E = (1U << 23);  ///< ITAMP8E
        constexpr uint32_t ITAMP7E = (1U << 22);  ///< ITAMP7E
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< ITAMP6E
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< ITAMP5E
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< ITAMP3E
        constexpr uint32_t ITAMP2E = (1U << 17);  ///< ITAMP2E
        constexpr uint32_t ITAMP1E = (1U << 16);  ///< ITAMP1E
        constexpr uint32_t TAMP8E = (1U << 7);  ///< TAMP8E
        constexpr uint32_t TAMP7E = (1U << 6);  ///< TAMP7E
        constexpr uint32_t TAMP6E = (1U << 5);  ///< TAMP6E
        constexpr uint32_t TAMP5E = (1U << 4);  ///< TAMP5E
        constexpr uint32_t TAMP4E = (1U << 3);  ///< TAMP4E
        constexpr uint32_t TAMP3E = (1U << 2);  ///< TAMP3E
        constexpr uint32_t TAMP2E = (1U << 1);  ///< TAMP2E
        constexpr uint32_t TAMP1E = (1U << 0);  ///< TAMP1E
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< TAMP1NOER
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< TAMP2NOER
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< TAMP3NOER
        constexpr uint32_t TAMP4NOER = (1U << 3);  ///< TAMP4NOER
        constexpr uint32_t TAMP5NOER = (1U << 4);  ///< TAMP5NOER
        constexpr uint32_t TAMP6NOER = (1U << 5);  ///< TAMP6NOER
        constexpr uint32_t TAMP7NOER = (1U << 6);  ///< TAMP7NOER
        constexpr uint32_t TAMP8NOER = (1U << 7);  ///< TAMP8NOER
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< TAMP1MSK
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< TAMP2MSK
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< TAMP3MSK
        constexpr uint32_t BKBLOCK = (1U << 22);  ///< BKBLOCK
        constexpr uint32_t BKERASE = (1U << 23);  ///< BKERASE
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< TAMP1TRG
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< TAMP2TRG
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< TAMP3TRG
        constexpr uint32_t TAMP4TRG = (1U << 27);  ///< TAMP4TRG
        constexpr uint32_t TAMP5TRG = (1U << 28);  ///< TAMP5TRG
        constexpr uint32_t TAMP6TRG = (1U << 29);  ///< TAMP6TRG
        constexpr uint32_t TAMP7TRG = (1U << 30);  ///< TAMP7TRG
        constexpr uint32_t TAMP8TRG = (1U << 31);  ///< TAMP8TRG
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t ITAMP1NOER = (1U << 0);  ///< ITAMP1NOER
        constexpr uint32_t ITAMP2NOER = (1U << 1);  ///< ITAMP2NOER
        constexpr uint32_t ITAMP3NOER = (1U << 2);  ///< ITAMP3NOER
        constexpr uint32_t TAMP5NOER = (1U << 4);  ///< TAMP5NOER
        constexpr uint32_t TAMP6NOER = (1U << 5);  ///< TAMP6NOER
        constexpr uint32_t TAMP7NOER = (1U << 6);  ///< TAMP7NOER
        constexpr uint32_t TAMP8NOER = (1U << 7);  ///< TAMP8NOER
        constexpr uint32_t ITAMP9NOER = (1U << 8);  ///< ITAMP9NOER
        constexpr uint32_t ITAMP11NOER = (1U << 10);  ///< ITAMP11NOER
        constexpr uint32_t ITAMP12NOER = (1U << 11);  ///< ITAMP12NOER
        constexpr uint32_t ITAMP13NOER = (1U << 12);  ///< ITAMP13NOER
    }

    /// FLTCR Register bits
    namespace fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< TAMPFREQ
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMPFLT
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMPPRCH
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMPPUDIS
    }

    /// ATCR1 Register bits
    namespace atcr1_bits {
        constexpr uint32_t TAMP1AM = (1U << 0);  ///< TAMP1AM
        constexpr uint32_t TAMP2AM = (1U << 1);  ///< TAMP2AM
        constexpr uint32_t TAMP3AM = (1U << 2);  ///< TAMP3AM
        constexpr uint32_t TAMP4AM = (1U << 3);  ///< TAMP4AM
        constexpr uint32_t TAMP5AM = (1U << 4);  ///< TAMP5AM
        constexpr uint32_t TAMP6AM = (1U << 5);  ///< TAMP6AM
        constexpr uint32_t TAMP7AM = (1U << 6);  ///< TAMP7AM
        constexpr uint32_t TAMP8AM = (1U << 7);  ///< TAMP8AM
        constexpr uint32_t ATOSEL1 = (2 << 8);  ///< ATOSEL1
        constexpr uint32_t ATOSEL2 = (2 << 10);  ///< ATOSEL2
        constexpr uint32_t ATOSEL3 = (2 << 12);  ///< ATOSEL3
        constexpr uint32_t ATOSEL4 = (2 << 14);  ///< ATOSEL4
        constexpr uint32_t ATCKSEL = (3 << 16);  ///< ATCKSEL
        constexpr uint32_t ATPER = (3 << 24);  ///< ATPER
        constexpr uint32_t ATOSHARE = (1U << 30);  ///< ATOSHARE
        constexpr uint32_t FLTEN = (1U << 31);  ///< ATOSHARE
    }

    /// ATSEEDR Register bits
    namespace atseedr_bits {
        constexpr uint32_t SEED = (32 << 0);  ///< SEED
    }

    /// ATOR Register bits
    namespace ator_bits {
        constexpr uint32_t PRNG = (8 << 0);  ///< PRNG
        constexpr uint32_t SEEDF = (1U << 14);  ///< SEEDF
        constexpr uint32_t INITS = (1U << 15);  ///< INITS
    }

    /// ATCR2 Register bits
    namespace atcr2_bits {
        constexpr uint32_t ATOSEL1 = (3 << 8);  ///< ATOSEL1
        constexpr uint32_t ATOSEL2 = (3 << 11);  ///< ATOSEL2
        constexpr uint32_t ATOSEL3 = (3 << 14);  ///< ATOSEL3
        constexpr uint32_t ATOSEL4 = (2 << 17);  ///< ATOSEL4
        constexpr uint32_t ATOSEL5 = (3 << 20);  ///< ATOSEL5
        constexpr uint32_t ATOSEL6 = (3 << 23);  ///< ATOSEL6
        constexpr uint32_t ATOSEL7 = (3 << 26);  ///< ATOSEL7
        constexpr uint32_t ATOSEL8 = (3 << 29);  ///< ATOSEL8
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t BKPRWSEC = (8 << 0);  ///< BKPRWSEC
        constexpr uint32_t CNT1SEC = (1U << 15);  ///< CNT1SEC
        constexpr uint32_t BKPWSEC = (8 << 16);  ///< BKPWSEC
        constexpr uint32_t BHKLOCK = (1U << 30);  ///< BHKLOCK
        constexpr uint32_t TAMPSEC = (1U << 31);  ///< TAMPSEC
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t CNT1PRIV = (1U << 15);  ///< CNT1PRIV
        constexpr uint32_t BKPRWPRIV = (1U << 29);  ///< BKPRWPRIV
        constexpr uint32_t BKPWPRIV = (1U << 30);  ///< BKPWPRIV
        constexpr uint32_t TAMPPRIV = (1U << 31);  ///< TAMPPRIV
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< TAMP1IE
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< TAMP2IE
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< TAMP3IE
        constexpr uint32_t TAMP4IE = (1U << 3);  ///< TAMP4IE
        constexpr uint32_t TAMP5IE = (1U << 4);  ///< TAMP5IE
        constexpr uint32_t TAMP6IE = (1U << 5);  ///< TAMP6IE
        constexpr uint32_t TAMP7IE = (1U << 6);  ///< TAMP7IE
        constexpr uint32_t TAMP8IE = (1U << 7);  ///< TAMP8IE
        constexpr uint32_t ITAMP1IE = (1U << 16);  ///< ITAMP1IE
        constexpr uint32_t ITAMP2IE = (1U << 17);  ///< ITAMP2IE
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< ITAMP3IE
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< ITAMP5IE
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< ITAMP6IE
        constexpr uint32_t ITAMP7IE = (1U << 22);  ///< ITAMP7IE
        constexpr uint32_t ITAMP8IE = (1U << 23);  ///< ITAMP8IE
        constexpr uint32_t ITAMP9IE = (1U << 24);  ///< ITAMP9IE
        constexpr uint32_t ITAMP11IE = (1U << 26);  ///< ITAMP11IE
        constexpr uint32_t ITAMP12IE = (1U << 27);  ///< ITAMP12IE
        constexpr uint32_t ITAMP13IE = (1U << 28);  ///< ITAMP13IE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1F
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2F
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3F
        constexpr uint32_t TAMP4F = (1U << 3);  ///< TAMP4F
        constexpr uint32_t TAMP5F = (1U << 4);  ///< TAMP5F
        constexpr uint32_t TAMP6F = (1U << 5);  ///< TAMP6F
        constexpr uint32_t TAMP7F = (1U << 6);  ///< TAMP7F
        constexpr uint32_t TAMP8F = (1U << 7);  ///< TAMP8F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP2F = (1U << 17);  ///< CITAMP2F
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< ITAMP3F
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< ITAMP5F
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ITAMP6F
        constexpr uint32_t ITAMP7F = (1U << 22);  ///< ITAMP7F
        constexpr uint32_t ITAMP8F = (1U << 23);  ///< ITAMP8F
        constexpr uint32_t ITAMP9F = (1U << 24);  ///< ITAMP9F
        constexpr uint32_t CITAMP11F = (1U << 26);  ///< CITAMP11F
        constexpr uint32_t ITAMP12F = (1U << 27);  ///< ITAMP12F
        constexpr uint32_t ITAMP13IE = (1U << 28);  ///< ITAMP13IE
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4MF
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5MF
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6MF
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7MF
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< ITAMP2MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
        constexpr uint32_t ITAMP7MF = (1U << 22);  ///< ITAMP7MF
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< ITAMP8MF
        constexpr uint32_t ITAMP9MF = (1U << 24);  ///< ITAMP9MF
        constexpr uint32_t ITAMP11MF = (1U << 26);  ///< ITAMP11MF
        constexpr uint32_t ITAMP12MF = (1U << 27);  ///< ITAMP12MF
        constexpr uint32_t ITAMP13MF = (1U << 28);  ///< ITAMP13MF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4MF
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5MF
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6MF
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7MF
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< ITAMP2MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
        constexpr uint32_t ITAMP7MF = (1U << 22);  ///< ITAMP7MF
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< ITAMP8MF
        constexpr uint32_t ITAMP9MF = (1U << 24);  ///< ITAMP9MF
        constexpr uint32_t ITAMP11MF = (1U << 26);  ///< ITAMP11MF
        constexpr uint32_t ITAMP12MF = (1U << 27);  ///< ITAMP12MF
        constexpr uint32_t ITAMP13MF = (1U << 28);  ///< ITAMP13MF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< CTAMP1F
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< CTAMP2F
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< CTAMP3F
        constexpr uint32_t CTAMP4F = (1U << 3);  ///< CTAMP4F
        constexpr uint32_t CTAMP5F = (1U << 4);  ///< CTAMP5F
        constexpr uint32_t CTAMP6F = (1U << 5);  ///< CTAMP6F
        constexpr uint32_t CITAMP7F = (1U << 6);  ///< CITAMP3F
        constexpr uint32_t CITAMP8F = (1U << 7);  ///< CITAMP3F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP2F = (1U << 17);  ///< CITAMP2F
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< CITAMP3F
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< CITAMP5F
        constexpr uint32_t CITAMP6F_bit21 = (1U << 21);  ///< CITAMP6F_bit21
        constexpr uint32_t CITAMP7F_bit22 = (1U << 22);  ///< CITAMP7F_bit22
        constexpr uint32_t CITAMP8F_bit23 = (1U << 23);  ///< CITAMP8F_bit23
        constexpr uint32_t CITAMP9F = (1U << 24);  ///< CITAMP9F
        constexpr uint32_t CITAMP11F = (1U << 26);  ///< CITAMP11F
        constexpr uint32_t CITAMP12F = (1U << 27);  ///< CITAMP12F
        constexpr uint32_t CITAMP13F = (1U << 28);  ///< CITAMP13F
    }

    /// COUNT1R Register bits
    namespace count1r_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< COUNT
    }

    /// ERCFGR Register bits
    namespace ercfgr_bits {
        constexpr uint32_t ERCFG0 = (1U << 0);  ///< ERCFG0
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP5R Register bits
    namespace bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP6R Register bits
    namespace bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP7R Register bits
    namespace bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP8R Register bits
    namespace bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP9R Register bits
    namespace bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP10R Register bits
    namespace bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP11R Register bits
    namespace bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP12R Register bits
    namespace bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP13R Register bits
    namespace bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP14R Register bits
    namespace bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP15R Register bits
    namespace bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP16R Register bits
    namespace bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP17R Register bits
    namespace bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP18R Register bits
    namespace bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP19R Register bits
    namespace bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP20R Register bits
    namespace bkp20r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP21R Register bits
    namespace bkp21r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP22R Register bits
    namespace bkp22r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP23R Register bits
    namespace bkp23r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP24R Register bits
    namespace bkp24r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP25R Register bits
    namespace bkp25r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP26R Register bits
    namespace bkp26r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP27R Register bits
    namespace bkp27r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP28R Register bits
    namespace bkp28r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP29R Register bits
    namespace bkp29r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP30R Register bits
    namespace bkp30r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP31R Register bits
    namespace bkp31r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x40024000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t ICR;  ///< Offset: 0x08 - interrupt clear register
        volatile uint32_t ISR;  ///< Offset: 0x0C - interrupt status register
        volatile uint32_t IOHCR;  ///< Offset: 0x10 - I/O hysteresis control register
        volatile uint32_t IOASCR;  ///< Offset: 0x18 - I/O analog switch control register
        volatile uint32_t IOSCR;  ///< Offset: 0x20 - I/O sampling control register
        volatile uint32_t IOCCR;  ///< Offset: 0x28 - I/O channel control register
        volatile uint32_t IOGCSR;  ///< Offset: 0x30 - I/O group control status register
        volatile uint32_t IOG1CR;  ///< Offset: 0x34 - I/O group x counter register
        volatile uint32_t IOG2CR;  ///< Offset: 0x38 - I/O group x counter register
        volatile uint32_t IOG3CR;  ///< Offset: 0x3C - I/O group x counter register
        volatile uint32_t IOG4CR;  ///< Offset: 0x40 - I/O group x counter register
        volatile uint32_t IOG5CR;  ///< Offset: 0x44 - I/O group x counter register
        volatile uint32_t IOG6CR;  ///< Offset: 0x48 - I/O group x counter register
        volatile uint32_t IOG7CR;  ///< Offset: 0x4C - I/O group x counter register
        volatile uint32_t IOG8CR;  ///< Offset: 0x50 - I/O group x counter register
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CTPH = (4 << 28);  ///< Charge transfer pulse high
        constexpr uint32_t CTPL = (4 << 24);  ///< Charge transfer pulse low
        constexpr uint32_t SSD = (7 << 17);  ///< Spread spectrum deviation
        constexpr uint32_t SSE = (1U << 16);  ///< Spread spectrum enable
        constexpr uint32_t SSPSC = (1U << 15);  ///< Spread spectrum prescaler
        constexpr uint32_t PGPSC = (3 << 12);  ///< pulse generator prescaler
        constexpr uint32_t MCV = (3 << 5);  ///< Max count value
        constexpr uint32_t IODEF = (1U << 4);  ///< I/O Default mode
        constexpr uint32_t SYNCPOL = (1U << 3);  ///< Synchronization pin polarity
        constexpr uint32_t AM = (1U << 2);  ///< Acquisition mode
        constexpr uint32_t START = (1U << 1);  ///< Start a new acquisition
        constexpr uint32_t TSCE = (1U << 0);  ///< Touch sensing controller enable
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t MCEIE = (1U << 1);  ///< Max count error interrupt enable
        constexpr uint32_t EOAIE = (1U << 0);  ///< End of acquisition interrupt enable
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t MCEIC = (1U << 1);  ///< Max count error interrupt clear
        constexpr uint32_t EOAIC = (1U << 0);  ///< End of acquisition interrupt clear
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t MCEF = (1U << 1);  ///< Max count error flag
        constexpr uint32_t EOAF = (1U << 0);  ///< End of acquisition flag
    }

    /// IOHCR Register bits
    namespace iohcr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOASCR Register bits
    namespace ioascr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOSCR Register bits
    namespace ioscr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOCCR Register bits
    namespace ioccr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOGCSR Register bits
    namespace iogcsr_bits {
        constexpr uint32_t G8S = (1U << 23);  ///< Analog I/O group x status
        constexpr uint32_t G7S = (1U << 22);  ///< Analog I/O group x status
        constexpr uint32_t G6S = (1U << 21);  ///< Analog I/O group x status
        constexpr uint32_t G5S = (1U << 20);  ///< Analog I/O group x status
        constexpr uint32_t G4S = (1U << 19);  ///< Analog I/O group x status
        constexpr uint32_t G3S = (1U << 18);  ///< Analog I/O group x status
        constexpr uint32_t G2S = (1U << 17);  ///< Analog I/O group x status
        constexpr uint32_t G1S = (1U << 16);  ///< Analog I/O group x status
        constexpr uint32_t G8E = (1U << 7);  ///< Analog I/O group x enable
        constexpr uint32_t G7E = (1U << 6);  ///< Analog I/O group x enable
        constexpr uint32_t G6E = (1U << 5);  ///< Analog I/O group x enable
        constexpr uint32_t G5E = (1U << 4);  ///< Analog I/O group x enable
        constexpr uint32_t G4E = (1U << 3);  ///< Analog I/O group x enable
        constexpr uint32_t G3E = (1U << 2);  ///< Analog I/O group x enable
        constexpr uint32_t G2E = (1U << 1);  ///< Analog I/O group x enable
        constexpr uint32_t G1E = (1U << 0);  ///< Analog I/O group x enable
    }

    /// IOG1CR Register bits
    namespace iog1cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG2CR Register bits
    namespace iog2cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG3CR Register bits
    namespace iog3cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG4CR Register bits
    namespace iog4cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG5CR Register bits
    namespace iog5cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG6CR Register bits
    namespace iog6cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG7CR Register bits
    namespace iog7cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG8CR Register bits
    namespace iog8cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x46007400;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< ENVR
        constexpr uint32_t HIZ = (1U << 1);  ///< HIZ
        constexpr uint32_t VRR = (1U << 3);  ///< VRR
        constexpr uint32_t VRS = (3 << 4);  ///< VRS
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< TRIM
    }

}

// ============================================================================
// DCB Peripheral
// ============================================================================

namespace dcb {
    /// Base addresses
    constexpr uint32_t DCB_BASE = 0xE000EE08;

    /// DCB Register structure
    struct Registers {
        volatile uint32_t DSCSR;  ///< Offset: 0x00 - Debug Security Control and Status Register
    };

    /// Peripheral instances
    inline Registers* DCB = reinterpret_cast<Registers*>(DCB_BASE);

    // Bit definitions
    /// DSCSR Register bits
    namespace dscsr_bits {
        constexpr uint32_t CDS = (1U << 16);  ///< Current domain Secure
    }

}


} // namespace alloy::generated::stm32u535

#endif // ALLOY_GENERATED_STM32U535_PERIPHERALS_HPP